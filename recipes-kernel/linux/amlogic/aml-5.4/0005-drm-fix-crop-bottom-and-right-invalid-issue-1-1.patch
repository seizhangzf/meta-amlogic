From 0493288f964ee176e9d1f185ec7878e76e1cdadd Mon Sep 17 00:00:00 2001
From: Ao Xu <ao.xu@amlogic.com>
Date: Wed, 2 Jun 2021 16:16:44 +0800
Subject: [PATCH 5/9] drm: fix crop bottom and right invalid issue [1/1]

PD#SWPL-xx

Problem:
vf crop bottom and right is invalid

Solution:
set vf crop bottom and right with correct value

Verify:
ah212

Change-Id: I370928609818dd559a335544cce9a4d7be167e93
Signed-off-by: Ao Xu <ao.xu@amlogic.com>
---
 .../drm/vpu-hw/meson_vpu_video_wrapper.c      | 60 +++++++++++++++----
 1 file changed, 49 insertions(+), 11 deletions(-)

diff --git a/drivers/amlogic/drm/vpu-hw/meson_vpu_video_wrapper.c b/drivers/amlogic/drm/vpu-hw/meson_vpu_video_wrapper.c
index 0f2f3b423aef..98664f71c042 100644
--- a/drivers/amlogic/drm/vpu-hw/meson_vpu_video_wrapper.c
+++ b/drivers/amlogic/drm/vpu-hw/meson_vpu_video_wrapper.c
@@ -169,10 +169,11 @@ static int video_check_state(struct meson_vpu_block *vblk,
 static void video_set_state(struct meson_vpu_block *vblk,
 			    struct meson_vpu_block_state *state)
 {
-	struct vframe_s *vf = NULL;
+	struct vframe_s *vf = NULL, *dec_vf = NULL, *vfp = NULL;
 	struct meson_vpu_video *video = to_video_block(vblk);
 	struct meson_vpu_video_state *mvvs = to_video_state(state);
-	u32 pixel_format, src_h, byte_stride;
+	u32 pixel_format, src_h, byte_stride, pic_w, pic_h;
+	u32 recal_src_w, recal_src_h;
 	u64 phy_addr, phy_addr2 = 0;
 
 	DRM_DEBUG("%s", __func__);
@@ -189,21 +190,58 @@ static void video_set_state(struct meson_vpu_block *vblk,
 	DRM_DEBUG("%s %d-%d-%llx", __func__, src_h, pixel_format, phy_addr);
 
 	if (mvvs->is_uvm) {
+		dec_vf = mvvs->vf;
 		vf = mvvs->vf;
-		if (vf->vf_ext && (vf->flag & VFRAME_FLAG_CONTAIN_POST_FRAME))
+		DRM_DEBUG("use dec vf, %s, flag-%u, type-%u, cw-%u, ch-%u, w-%u, h-%u\n",
+			  __func__, dec_vf->flag, dec_vf->type,
+			  dec_vf->compWidth, dec_vf->compHeight,
+			  dec_vf->width, dec_vf->height);
+		if (vf->vf_ext && (vf->flag & VFRAME_FLAG_CONTAIN_POST_FRAME)) {
 			vf = mvvs->vf->vf_ext;
+			DRM_DEBUG("use DI vf, %s, flag-%u, type-%u, cw-%u, ch-%u, w-%u, h-%u\n",
+				  __func__, vf->flag, vf->type,
+				  vf->compWidth, vf->compHeight,
+				  vf->width, vf->height);
+		}
 		vf->axis[0] = mvvs->dst_x;
 		vf->axis[1] = mvvs->dst_y;
 		vf->axis[2] = mvvs->dst_x + mvvs->dst_w - 1;
 		vf->axis[3] = mvvs->dst_y + mvvs->dst_h - 1;
-		vf->crop[0] = mvvs->src_y;/*crop top*/
-		vf->crop[1] = mvvs->src_x;/*crop left*/
-		/*vf->width is from mvvs->src_w which is the
-		 *valid content so the crop of bottom and right
-		 *could be 0
-		 */
-		vf->crop[2] = 0;/*crop bottow*/
-		vf->crop[3] = 0;/*crop right*/
+
+		if (dec_vf->type & VIDTYPE_COMPRESS) {
+			pic_w = dec_vf->compWidth;
+			pic_h = dec_vf->compHeight;
+			recal_src_w = mvvs->src_w * pic_w / dec_vf->width;
+			recal_src_h = mvvs->src_h * pic_h / dec_vf->height;
+			vf->crop[0] = mvvs->src_y * pic_h / dec_vf->height;
+			vf->crop[1] = mvvs->src_x * pic_w / dec_vf->width;
+		} else {
+			pic_w = dec_vf->width;
+			pic_h = dec_vf->height;
+			recal_src_w = mvvs->src_w;
+			recal_src_h = mvvs->src_h;
+			vf->crop[0] = mvvs->src_y;/*crop top*/
+			vf->crop[1] = mvvs->src_x;/*crop left*/
+		}
+
+		if ((pic_w == 0 || pic_h == 0) && dec_vf->vf_ext) {
+			vfp = dec_vf->vf_ext;
+			pic_w = vfp->width;
+			pic_h = vfp->height;
+		}
+
+		/*crop bottow*/
+		if (pic_h > recal_src_h + vf->crop[0])
+			vf->crop[2] = pic_h - recal_src_h - vf->crop[0];
+		else
+			vf->crop[2] = 0;
+
+		/*crop right*/
+		if (pic_w > recal_src_w + vf->crop[1])
+			vf->crop[3] = pic_w - recal_src_w - vf->crop[1];
+		else
+			vf->crop[3] = 0;
+		DRM_DEBUG("vf-crop:%u, %u, %u, %u\n", pic_w, pic_h, vf->crop[2], vf->crop[3]);
 		vf->flag |= VFRAME_FLAG_VIDEO_DRM;
 		if (!kfifo_put(&video->ready_q, vf))
 			DRM_INFO("ready_q is full!\n");
-- 
2.29.2

