From 6ea9fe6a08ffbeaefb187ed8b54757b9a14d9b08 Mon Sep 17 00:00:00 2001
From: sky zhou <sky.zhou@amlogic.com>
Date: Sat, 8 May 2021 15:20:55 +0800
Subject: [PATCH 2/8] drm: hdmitx add content protection set from userspace
 [1/1]

PD#SWPL-44550

Problem:
no drm ContentProtection prop set support

Solution:
add content protection prop set support

Verify:
verify on sc2

Change-Id: Ifbae27f7e9105d11828750d9da736c499584c0fe
Signed-off-by: sky zhou <sky.zhou@amlogic.com>
---
 .../dts/amlogic/tm2_t962e2_ab311_linux.dts    |   2 +-
 drivers/amlogic/drm/meson_atomic.c            |  21 +
 drivers/amlogic/drm/meson_cvbs.c              |  53 +--
 drivers/amlogic/drm/meson_cvbs.h              |   3 +-
 drivers/amlogic/drm/meson_drv.c               |   8 +-
 drivers/amlogic/drm/meson_drv.h               |  13 +
 drivers/amlogic/drm/meson_hdcp.c              | 400 ++++++++++++-----
 drivers/amlogic/drm/meson_hdcp.h              |  31 +-
 drivers/amlogic/drm/meson_hdmi.c              | 408 ++++++++++++------
 drivers/amlogic/drm/meson_hdmi.h              |  60 ++-
 .../vout/hdmitx/hdmi_tx_20/hdmi_tx_main.c     |  39 +-
 .../media/vout/hdmi_tx/hdmi_tx_module.h       |   9 +-
 .../media/vout/hdmi_tx/meson_drm_hdmitx.h     |  18 +-
 13 files changed, 694 insertions(+), 371 deletions(-)

diff --git a/arch/arm64/boot/dts/amlogic/tm2_t962e2_ab311_linux.dts b/arch/arm64/boot/dts/amlogic/tm2_t962e2_ab311_linux.dts
index 9abf27e5cdaa..7514ad4421be 100644
--- a/arch/arm64/boot/dts/amlogic/tm2_t962e2_ab311_linux.dts
+++ b/arch/arm64/boot/dts/amlogic/tm2_t962e2_ab311_linux.dts
@@ -1530,7 +1530,7 @@
 	status = "okay";
 	repeater_tx = <0x0>;
 	/* hdcp ctrl 0:sysctrl, 1: drv, 2: linux app */
-	hdcp_ctl_lvl = <1>;
+	hdcp_ctl_lvl = <2>;
 };
 
 &pcie_A {
diff --git a/drivers/amlogic/drm/meson_atomic.c b/drivers/amlogic/drm/meson_atomic.c
index cb36b1419aca..5621bfcd3106 100644
--- a/drivers/amlogic/drm/meson_atomic.c
+++ b/drivers/amlogic/drm/meson_atomic.c
@@ -27,6 +27,7 @@
 #include <drm/drm_fb_helper.h>
 
 #include "meson_drv.h"
+#include "meson_crtc.h"
 
 struct meson_commit_work_item {
 	struct kthread_work kthread_work;
@@ -414,3 +415,23 @@ int meson_atomic_commit(struct drm_device *dev,
 	drm_atomic_helper_cleanup_planes(dev, state);
 	return ret;
 }
+
+void meson_atomic_helper_commit_tail(struct drm_atomic_state *old_state)
+{
+	struct drm_connector *conn;
+	struct meson_connector *meson_conn;
+	struct drm_connector_state *new_conn_state, *old_conn_state;
+	int i;
+
+	/*do  update which dont need       pipe change.*/
+	for_each_oldnew_connector_in_state(old_state, conn, old_conn_state, new_conn_state, i) {
+		meson_conn = connector_to_meson_connector(conn);
+
+		if (meson_conn->update)
+			meson_conn->update(new_conn_state, old_conn_state);
+	}
+
+	/*use */
+	drm_atomic_helper_commit_tail_rpm(old_state);
+}
+
diff --git a/drivers/amlogic/drm/meson_cvbs.c b/drivers/amlogic/drm/meson_cvbs.c
index 59f9a44573cb..6c35a9a67f91 100644
--- a/drivers/amlogic/drm/meson_cvbs.c
+++ b/drivers/amlogic/drm/meson_cvbs.c
@@ -76,7 +76,7 @@ char *am_cvbs_get_voutmode(struct drm_display_mode *mode)
 
 static inline struct am_drm_cvbs_s *con_to_cvbs(struct drm_connector *con)
 {
-	return container_of(con, struct am_drm_cvbs_s, connector);
+	return container_of(connector_to_meson_connector(con), struct am_drm_cvbs_s, base);
 }
 
 static inline struct am_drm_cvbs_s *encoder_to_cvbs(struct drm_encoder *encoder)
@@ -145,46 +145,6 @@ static enum drm_connector_status am_cvbs_connector_detect
 	return connector_status_connected;
 }
 
-static int am_cvbs_connector_set_property(struct drm_connector *connector,
-					  struct drm_property *property,
-					  uint64_t val)
-{
-	struct am_drm_cvbs_s *am_drm_cvbs = con_to_cvbs(connector);
-	struct drm_connector_state *state = am_drm_cvbs->connector.state;
-	struct drm_mode_config *config = &connector->dev->mode_config;
-
-	if (property == config->content_protection_property) {
-		DRM_INFO("property:%s       val: %lld\n", property->name, val);
-		/* For none atomic commit */
-		/* atomic will be filter on drm_moder_object.c */
-		if (val == DRM_MODE_CONTENT_PROTECTION_ENABLED) {
-			DRM_DEBUG_KMS("only drivers can set CP Enabled\n");
-			return -EINVAL;
-		}
-		state->content_protection = val;
-	}
-	/*other parperty todo*/
-	return 0;
-}
-
-static int am_cvbs_connector_atomic_get_property
-	(struct drm_connector *connector,
-	const struct drm_connector_state *state,
-	struct drm_property *property, uint64_t *val)
-{
-	struct drm_mode_config *config = &connector->dev->mode_config;
-
-	if (property == config->content_protection_property) {
-		DRM_INFO("get content_protection val: %d\n",
-			 state->content_protection);
-		*val = state->content_protection;
-	} else {
-		DRM_DEBUG_ATOMIC("Unknown property %s\n", property->name);
-		return -EINVAL;
-	}
-	return 0;
-}
-
 static void am_cvbs_connector_destroy(struct drm_connector *connector)
 {
 	drm_connector_unregister(connector);
@@ -194,8 +154,6 @@ static void am_cvbs_connector_destroy(struct drm_connector *connector)
 static const struct drm_connector_funcs am_cvbs_connector_funcs = {
 	.detect			= am_cvbs_connector_detect,
 	.fill_modes		= drm_helper_probe_single_connector_modes,
-	.set_property		= am_cvbs_connector_set_property,
-	.atomic_get_property	= am_cvbs_connector_atomic_get_property,
 	.destroy		= am_cvbs_connector_destroy,
 	.reset			= drm_atomic_helper_connector_reset,
 	.atomic_duplicate_state	= drm_atomic_helper_connector_duplicate_state,
@@ -225,10 +183,6 @@ void am_cvbs_encoder_enable(struct drm_encoder *encoder,
 void am_cvbs_encoder_disable(struct drm_encoder *encoder,
 	struct drm_atomic_state *state)
 {
-	struct am_drm_cvbs_s *am_drm_cvbs = encoder_to_cvbs(encoder);
-	struct drm_connector_state *con_state = am_drm_cvbs->connector.state;
-
-	con_state->content_protection = DRM_MODE_CONTENT_PROTECTION_UNDESIRED;
 }
 
 static const struct drm_encoder_helper_funcs am_cvbs_encoder_helper_funcs = {
@@ -263,9 +217,8 @@ static int am_meson_cvbs_bind(struct device *dev,
 		return -ENOMEM;
 	}
 
-	am_drm_cvbs->drm = drm;
 	encoder = &am_drm_cvbs->encoder;
-	connector = &am_drm_cvbs->connector;
+	connector = &am_drm_cvbs->base.connector;
 
 	/* Encoder */
 	drm_encoder_helper_add(encoder, &am_cvbs_encoder_helper_funcs);
@@ -310,7 +263,7 @@ static int am_meson_cvbs_bind(struct device *dev,
 static void am_meson_cvbs_unbind(struct device *dev,
 				 struct device *master, void *data)
 {
-	am_drm_cvbs->connector.funcs->destroy(&am_drm_cvbs->connector);
+	am_drm_cvbs->base.connector.funcs->destroy(&am_drm_cvbs->base.connector);
 	am_drm_cvbs->encoder.funcs->destroy(&am_drm_cvbs->encoder);
 	kfree(am_drm_cvbs);
 }
diff --git a/drivers/amlogic/drm/meson_cvbs.h b/drivers/amlogic/drm/meson_cvbs.h
index 69d9641b57fd..601c0679bcbc 100644
--- a/drivers/amlogic/drm/meson_cvbs.h
+++ b/drivers/amlogic/drm/meson_cvbs.h
@@ -15,8 +15,7 @@
 #include "meson_drv.h"
 
 struct am_drm_cvbs_s {
-	struct drm_device *drm;
-	struct drm_connector connector;
+	struct meson_connector base;
 	struct drm_encoder encoder;
 };
 
diff --git a/drivers/amlogic/drm/meson_drv.c b/drivers/amlogic/drm/meson_drv.c
index 98c610c2f28b..4655687a9dc4 100644
--- a/drivers/amlogic/drm/meson_drv.c
+++ b/drivers/amlogic/drm/meson_drv.c
@@ -71,6 +71,10 @@ static const struct drm_mode_config_funcs meson_mode_config_funcs = {
 #endif
 };
 
+static const struct drm_mode_config_helper_funcs meson_mode_config_helpers = {
+	.atomic_commit_tail = meson_atomic_helper_commit_tail,
+};
+
 int am_meson_register_crtc_funcs(struct drm_crtc *crtc,
 				 const struct meson_crtc_funcs *crtc_funcs)
 {
@@ -108,9 +112,8 @@ static void am_meson_disable_vblank(struct drm_device *dev, unsigned int crtc)
 }
 
 static u32 am_meson_get_vblank_counter(struct drm_device *dev,
-				       unsigned int pipe)
+	unsigned int pipe)
 {
-	/*to do*/
 	return 0;
 }
 
@@ -621,6 +624,7 @@ static int am_meson_drm_bind(struct device *dev)
 	drm->mode_config.max_width = 4096;
 	drm->mode_config.max_height = 4096;
 	drm->mode_config.funcs = &meson_mode_config_funcs;
+	drm->mode_config.helper_private	= &meson_mode_config_helpers;
 	drm->mode_config.allow_fb_modifiers = true;
 
 	/* Try to bind all sub drivers. */
diff --git a/drivers/amlogic/drm/meson_drv.h b/drivers/amlogic/drm/meson_drv.h
index 124000c5ff26..88196461ace3 100644
--- a/drivers/amlogic/drm/meson_drv.h
+++ b/drivers/amlogic/drm/meson_drv.h
@@ -44,6 +44,15 @@ struct meson_drm_thread {
 	unsigned int crtc_id;
 };
 
+struct meson_connector {
+	struct drm_connector connector;
+	struct meson_drm *drm_priv;
+	void (*update)(struct drm_connector_state *new_state,
+		struct drm_connector_state *old_state);
+};
+
+#define connector_to_meson_connector(x) container_of(x, struct meson_connector, connector)
+
 struct meson_drm {
 	struct device *dev;
 
@@ -86,9 +95,13 @@ int am_meson_register_crtc_funcs(struct drm_crtc *crtc,
 				 const struct meson_crtc_funcs *crtc_funcs);
 void am_meson_unregister_crtc_funcs(struct drm_crtc *crtc);
 struct drm_connector *am_meson_hdmi_connector(void);
+
+/*meson mode config atomic func*/
 int meson_atomic_commit(struct drm_device *dev,
 			     struct drm_atomic_state *state,
 			     bool nonblock);
+void meson_atomic_helper_commit_tail(struct drm_atomic_state *old_state);
+/*******************************/
 
 #ifdef CONFIG_DEBUG_FS
 int meson_debugfs_init(struct drm_minor *minor);
diff --git a/drivers/amlogic/drm/meson_hdcp.c b/drivers/amlogic/drm/meson_hdcp.c
index 686e328ecd59..2f8dd8450c6e 100644
--- a/drivers/amlogic/drm/meson_hdcp.c
+++ b/drivers/amlogic/drm/meson_hdcp.c
@@ -39,16 +39,49 @@ enum {
 
 #define TEE_HDCP_IOC_START    _IOW('P', TEE_HDCP_START, int)
 #define TEE_HDCP_IOC_END    _IOW('P', TEE_HDCP_END, int)
-
 #define HDCP_DAEMON_IOC_LOAD_END    _IOW('P', HDCP_DAEMON_LOAD_END, int)
 #define HDCP_DAEMON_IOC_REPORT    _IOR('P', HDCP_DAEMON_REPORT, int)
-
 #define HDCP_EXE_VER_IOC_SET    _IOW('P', HDCP_EXE_VER_SET, int)
 #define HDCP_TX_VER_IOC_REPORT    _IOR('P', HDCP_TX_VER_REPORT, int)
 #define HDCP_DOWNSTR_VER_IOC_REPORT    _IOR('P', HDCP_DOWNSTR_VER_REPORT, int)
 #define HDCP_EXE_VER_IOC_REPORT    _IOR('P', HDCP_EXE_VER_REPORT, int)
 
-static unsigned int get_hdcp_downstream_ver(struct am_hdmi_tx *am_hdmi)
+enum {
+	HDCP_TX22_DISCONNECT = 0,
+	HDCP_TX22_START,
+	HDCP_TX22_STOP
+};
+
+enum {
+	HDCP22_KEY_LOADING = 0,
+	HDCP22_KEY_SUCCESS,
+	HDCP22_KEY_FAIL
+};
+
+#define HDCP_AUTH_TIMEOUT (40) /*40*200ms = 8s*/
+#define HDCP22_LOAD_TIMEOUT (160)
+
+struct meson_hdmitx_hdcp {
+	struct miscdevice hdcp_comm_device;
+	wait_queue_head_t hdcp_comm_queue;
+	unsigned int hdcp_tx_type;/*bit0:hdcp14 bit 1:hdcp22*/
+	unsigned int hdcp_downstream_type;/*bit0:hdcp14 bit 1:hdcp22*/
+	unsigned int hdcp_execute_type;/*0: null hdcp 1: hdcp14 2: hdcp22*/
+	unsigned int hdcp_debug_type;/*0: null hdcp 1: hdcp14 2: hdcp22*/
+
+	unsigned int hdcp_en;
+	int hdcp_poll_report;
+	int hdcp_auth_result;
+	int hdcp_fail_cnt;
+	int hdcp_report;
+	int bootup_ready;
+
+	hdcp_notify hdcp_cb;
+};
+
+static struct meson_hdmitx_hdcp meson_hdcp;
+
+static unsigned int get_hdcp_downstream_ver(void)
 {
 	unsigned int hdcp_downstream_type = drm_get_rx_hdcp_cap();
 
@@ -60,7 +93,7 @@ static unsigned int get_hdcp_downstream_ver(struct am_hdmi_tx *am_hdmi)
 	return hdcp_downstream_type;
 }
 
-static unsigned int get_hdcp_hdmitx_version(struct am_hdmi_tx *am_hdmi)
+unsigned int meson_hdcp_get_key_version(void)
 {
 	unsigned int hdcp_tx_type = drm_hdmitx_get_hdcp_cap();
 
@@ -71,40 +104,38 @@ static unsigned int get_hdcp_hdmitx_version(struct am_hdmi_tx *am_hdmi)
 	return hdcp_tx_type;
 }
 
-static int am_get_hdcp_exe_type(struct am_hdmi_tx *am_hdmi)
+int meson_hdcp_get_valid_type(int request_type_mask)
 {
 	int type;
 
-	am_hdmi->hdcp_tx_type = get_hdcp_hdmitx_version(am_hdmi);
+	meson_hdcp.hdcp_tx_type = meson_hdcp_get_key_version();
 	DRM_INFO("%s usr_type: %d, tx_type: %d\n",
-		 __func__, am_hdmi->hdcp_user_type, am_hdmi->hdcp_tx_type);
-	if (am_hdmi->hdcp_user_type == 0)
-		return HDCP_NULL;
-	if (/* !am_hdmi->hdcp_downstream_type && */
-		am_hdmi->hdcp_tx_type)
-		am_hdmi->hdcp_downstream_type =
-			get_hdcp_downstream_ver(am_hdmi);
-	switch (am_hdmi->hdcp_tx_type & 0x3) {
+		 __func__, request_type_mask, meson_hdcp.hdcp_tx_type);
+	if (/* !meson_hdcp.hdcp_downstream_type && */
+		meson_hdcp.hdcp_tx_type)
+		meson_hdcp.hdcp_downstream_type =
+			get_hdcp_downstream_ver();
+	switch (meson_hdcp.hdcp_tx_type & 0x3) {
 	case 0x3:
-		if ((am_hdmi->hdcp_downstream_type & 0x2) &&
-			(am_hdmi->hdcp_user_type & 0x2))
+		if ((meson_hdcp.hdcp_downstream_type & 0x2) &&
+			(request_type_mask & 0x2))
 			type = HDCP_MODE22;
-		else if ((am_hdmi->hdcp_downstream_type & 0x1) &&
-			 (am_hdmi->hdcp_user_type & 0x1))
+		else if ((meson_hdcp.hdcp_downstream_type & 0x1) &&
+			 (request_type_mask & 0x1))
 			type = HDCP_MODE14;
 		else
 			type = HDCP_NULL;
 		break;
 	case 0x2:
-		if ((am_hdmi->hdcp_downstream_type & 0x2) &&
-			(am_hdmi->hdcp_user_type & 0x2))
+		if ((meson_hdcp.hdcp_downstream_type & 0x2) &&
+			(request_type_mask & 0x2))
 			type = HDCP_MODE22;
 		else
 			type = HDCP_NULL;
 		break;
 	case 0x1:
-		if ((am_hdmi->hdcp_downstream_type & 0x1) &&
-			(am_hdmi->hdcp_user_type & 0x1))
+		if ((meson_hdcp.hdcp_downstream_type & 0x1) &&
+			(request_type_mask & 0x1))
 			type = HDCP_MODE14;
 		else
 			type = HDCP_NULL;
@@ -117,89 +148,140 @@ static int am_get_hdcp_exe_type(struct am_hdmi_tx *am_hdmi)
 	return type;
 }
 
-void am_hdcp_disable(struct am_hdmi_tx *am_hdmi)
+static int am_get_hdcp_exe_type(void)
 {
-	DRM_INFO("[%s]: %d\n", __func__, am_hdmi->hdcp_execute_type);
+	return meson_hdcp_get_valid_type(meson_hdcp.hdcp_debug_type);
+}
+
+void meson_hdcp_disable(void)
+{
+	if (!meson_hdcp.hdcp_en)
+		return;
+
+	DRM_INFO("[%s]: %d\n", __func__, meson_hdcp.hdcp_execute_type);
 	/* TODO: whether to keep exe type */
-	/* if (am_hdmi->hdcp_execute_type == HDCP_MODE22) { */
-		am_hdmi->hdcp_report = HDCP_TX22_DISCONNECT;
+	/* if (meson_hdcp.hdcp_execute_type == HDCP_MODE22) { */
+		meson_hdcp.hdcp_report = HDCP_TX22_DISCONNECT;
 		/* wait for tx22 to enter unconnected state */
 		msleep(200);
-		am_hdmi->hdcp_report = HDCP_TX22_STOP;
+		meson_hdcp.hdcp_report = HDCP_TX22_STOP;
 		/* wakeup hdcp_tx22 to stop hdcp22 */
-		wake_up(&am_hdmi->hdcp_comm_queue);
+		wake_up(&meson_hdcp.hdcp_comm_queue);
 		/* wait for hdcp_tx22 stop hdcp22 done */
 		msleep(200);
 		drm_hdmitx_hdcp_disable(HDCP_MODE22);
-	/* } else if (am_hdmi->hdcp_execute_type  == HDCP_MODE14) { */
+	/* } else if (meson_hdcp.hdcp_execute_type  == HDCP_MODE14) { */
 		drm_hdmitx_hdcp_disable(HDCP_MODE14);
 	/* } */
-	am_hdmi->hdcp_execute_type = HDCP_NULL;
-	am_hdmi->hdcp_result = 0;
-	am_hdmi->hdcp_en = 0;
+	meson_hdcp.hdcp_execute_type = HDCP_NULL;
+	meson_hdcp.hdcp_auth_result = HDCP_AUTH_UNKNOWN;
+	meson_hdcp.hdcp_en = 0;
+	meson_hdcp.hdcp_fail_cnt = 0;
 }
 
-void am_hdcp_disconnect(struct am_hdmi_tx *am_hdmi)
+void meson_hdcp_disconnect(void)
 {
-	/* if (am_hdmi->hdcp_execute_type == HDCP_MODE22) */
+	/* if (meson_hdcp.hdcp_execute_type == HDCP_MODE22) */
 		/* drm_hdmitx_hdcp_disable(HDCP_MODE22); */
-	/* else if (am_hdmi->hdcp_execute_type  == HDCP_MODE14) */
+	/* else if (meson_hdcp.hdcp_execute_type  == HDCP_MODE14) */
 		/* drm_hdmitx_hdcp_disable(HDCP_MODE14); */
-	am_hdmi->hdcp_report = HDCP_TX22_DISCONNECT;
-	am_hdmi->hdcp_downstream_type = 0;
+	meson_hdcp.hdcp_report = HDCP_TX22_DISCONNECT;
+	meson_hdcp.hdcp_downstream_type = 0;
 	/* TODO: for suspend/resume, need to stop/start hdcp22
 	 * need to keep exe type
 	 */
-	am_hdmi->hdcp_execute_type = HDCP_NULL;
-	am_hdmi->hdcp_result = 0;
-	am_hdmi->hdcp_en = 0;
+	meson_hdcp.hdcp_execute_type = HDCP_NULL;
+	meson_hdcp.hdcp_auth_result = HDCP_AUTH_UNKNOWN;
+	meson_hdcp.hdcp_en = 0;
+	meson_hdcp.hdcp_fail_cnt = 0;
 	DRM_INFO("[%s]: HDCP_TX22_DISCONNECT\n", __func__);
-	wake_up(&am_hdmi->hdcp_comm_queue);
+	wake_up(&meson_hdcp.hdcp_comm_queue);
 }
 
-void am_hdcp_enable(struct am_hdmi_tx *am_hdmi)
+static void meson_hdmitx_hdcp_cb(void *data, int auth)
 {
-	/* hdcp enabled, but may not start auth as key not ready */
-	am_hdmi->hdcp_en = 1;
+	struct meson_hdmitx_hdcp *hdcp_data = (struct meson_hdmitx_hdcp *)data;
+	int hdcp_auth_result = HDCP_AUTH_UNKNOWN;
 
-	if (!am_hdmi->bootup_ready) {
-		DRM_INFO("[%s]: hdcp_tx22 not ready, delay hdcp auth\n", __func__);
-		return;
+	if (hdcp_data->hdcp_en &&
+		hdcp_data->hdcp_auth_result == HDCP_AUTH_UNKNOWN) {
+		if (auth == 1) {
+			hdcp_auth_result = HDCP_AUTH_OK;
+		} else if (auth == 0) {
+			hdcp_data->hdcp_fail_cnt++;
+
+			if (hdcp_data->hdcp_execute_type == HDCP_MODE22 &&
+				hdcp_data->bootup_ready == HDCP22_KEY_LOADING) {
+				if (hdcp_data->hdcp_fail_cnt > HDCP22_LOAD_TIMEOUT) {
+					DRM_ERROR("hdcp 22 key load timeout\n");
+					hdcp_data->bootup_ready = HDCP22_KEY_FAIL;
+					hdcp_auth_result = HDCP_AUTH_FAIL;
+				}
+			} else if (hdcp_data->hdcp_fail_cnt > HDCP_AUTH_TIMEOUT) {
+				hdcp_auth_result = HDCP_AUTH_FAIL;
+			}
+		}
+
+		DRM_DEBUG("HDCP cb %d vs %d\n", hdcp_data->hdcp_auth_result, auth);
+
+		if (hdcp_auth_result != hdcp_data->hdcp_auth_result) {
+			hdcp_data->hdcp_auth_result = hdcp_auth_result;
+			if (meson_hdcp.hdcp_cb)
+				meson_hdcp.hdcp_cb(hdcp_data->hdcp_execute_type,
+					hdcp_data->hdcp_auth_result);
+		}
 	}
-	am_hdmi->hdcp_execute_type = am_get_hdcp_exe_type(am_hdmi);
-	if (am_hdmi->hdcp_execute_type == HDCP_MODE22) {
+}
+
+void meson_hdcp_reg_result_notify(hdcp_notify cb)
+{
+	if (meson_hdcp.hdcp_cb)
+		DRM_ERROR("Register hdcp notify again!?\n");
+	meson_hdcp.hdcp_cb = cb;
+}
+
+void meson_hdcp_enable(int hdcp_type)
+{
+	if (hdcp_type == HDCP_NULL)
+		return;
+
+	/* hdcp enabled, but may not start auth as key not ready */
+	meson_hdcp.hdcp_en = 1;
+	meson_hdcp.hdcp_fail_cnt = 0;
+	meson_hdcp.hdcp_auth_result = HDCP_AUTH_UNKNOWN;
+	meson_hdcp.hdcp_execute_type = hdcp_type;
+
+	if (meson_hdcp.hdcp_execute_type == HDCP_MODE22) {
+		if (meson_hdcp.bootup_ready != HDCP22_KEY_SUCCESS) {
+			DRM_INFO("[%s]: hdcp_tx22 not ready, delay hdcp auth\n", __func__);
+			return;
+		}
 		drm_hdmitx_hdcp_enable(2);
-		am_hdmi->hdcp_report = HDCP_TX22_START;
+		meson_hdcp.hdcp_report = HDCP_TX22_START;
 		msleep(50);
-		wake_up(&am_hdmi->hdcp_comm_queue);
-	} else if (am_hdmi->hdcp_execute_type == HDCP_MODE14) {
+		wake_up(&meson_hdcp.hdcp_comm_queue);
+	} else if (meson_hdcp.hdcp_execute_type == HDCP_MODE14) {
 		drm_hdmitx_hdcp_enable(1);
 	}
 	DRM_INFO("[%s]: report=%d, use_type=%u, execute=%u\n",
-		 __func__, am_hdmi->hdcp_report,
-		 am_hdmi->hdcp_user_type, am_hdmi->hdcp_execute_type);
+		 __func__, meson_hdcp.hdcp_report,
+		 meson_hdcp.hdcp_debug_type, meson_hdcp.hdcp_execute_type);
 }
 
 static long hdcp_comm_ioctl(struct file *file,
-			    unsigned int cmd,
-			    unsigned long arg)
+	unsigned int cmd,
+	unsigned long arg)
 {
 	int rtn_val;
 	unsigned int out_size;
-	struct miscdevice *phdcp_comm_device;
-	struct am_hdmi_tx *am_hdmi;
-
-	phdcp_comm_device = file->private_data;
-	am_hdmi = container_of(phdcp_comm_device,
-			       struct am_hdmi_tx,
-			       hdcp_comm_device);
+	int hdcp_type = HDCP_NULL;
 
 	switch (cmd) {
 	case TEE_HDCP_IOC_START:
 		/* notify by TEE, hdcp key ready, echo 2 > hdcp_mode */
 		rtn_val = 0;
-		am_hdmi->hdcp_tx_type = get_hdcp_hdmitx_version(am_hdmi);
-		if (am_hdmi->hdcp_tx_type & 0x2) {
+		meson_hdcp.hdcp_tx_type = meson_hdcp_get_key_version();
+		if (meson_hdcp.hdcp_tx_type & 0x2) {
 			/* when bootup, if hdcp22 init after hdcp14 auth,
 			 * hdcp path will switch to hdcp22. need to delay
 			 * hdcp auth to covery this issue.
@@ -213,20 +295,24 @@ static long hdcp_comm_ioctl(struct file *file,
 		break;
 	case HDCP_DAEMON_IOC_LOAD_END:
 		/* hdcp_tx22 load ready (after TEE key ready) */
-		DRM_INFO("IOC_LOAD_END %d, %d\n",
-			 am_hdmi->hdcp_report, am_hdmi->hdcp_poll_report);
-		am_hdmi->bootup_ready = true;
-		if (am_hdmi->hdcp_en)
-			am_hdcp_enable(am_hdmi);
-		am_hdmi->hdcp_poll_report = am_hdmi->hdcp_report;
+		DRM_ERROR("IOC_LOAD_END %d, %d\n",
+			 meson_hdcp.hdcp_report, meson_hdcp.hdcp_poll_report);
+		if (meson_hdcp.bootup_ready == HDCP22_KEY_FAIL)
+			DRM_ERROR("hdcp22 key load late than TIMEOUT.\n");
+		meson_hdcp.bootup_ready = HDCP22_KEY_SUCCESS;
+		if (meson_hdcp.hdcp_en && meson_hdcp.hdcp_execute_type == HDCP_MODE22)
+			meson_hdcp_enable(meson_hdcp.hdcp_execute_type);
+		else /*send notify when key load finished.*/
+			meson_hdcp.hdcp_cb(HDCP_NULL, HDCP_AUTH_OK);
+		meson_hdcp.hdcp_poll_report = meson_hdcp.hdcp_report;
 		rtn_val = 0;
 		break;
 	case HDCP_DAEMON_IOC_REPORT:
 		rtn_val = copy_to_user((void __user *)arg,
-				       (void *)&am_hdmi->hdcp_report,
-				       sizeof(am_hdmi->hdcp_report));
+				       (void *)&meson_hdcp.hdcp_report,
+				       sizeof(meson_hdcp.hdcp_report));
 		if (rtn_val != 0) {
-			out_size = sizeof(am_hdmi->hdcp_report);
+			out_size = sizeof(meson_hdcp.hdcp_report);
 			DRM_INFO("out_size: %u, leftsize: %u\n",
 				 out_size, rtn_val);
 			rtn_val = -1;
@@ -236,20 +322,21 @@ static long hdcp_comm_ioctl(struct file *file,
 		if (arg > 2) {
 			rtn_val = -1;
 		} else {
-			am_hdmi->hdcp_user_type = arg;
+			meson_hdcp.hdcp_debug_type = arg;
 			rtn_val = 0;
 			if (hdmitx_hpd_hw_op(HPD_READ_HPD_GPIO)) {
-				am_hdcp_disable(am_hdmi);
-				am_hdcp_enable(am_hdmi);
+				meson_hdcp_disable();
+				hdcp_type = am_get_hdcp_exe_type();
+				meson_hdcp_enable(hdcp_type);
 			}
 		}
 		break;
 	case HDCP_TX_VER_IOC_REPORT:
 		rtn_val = copy_to_user((void __user *)arg,
-				       (void *)&am_hdmi->hdcp_tx_type,
-				       sizeof(am_hdmi->hdcp_tx_type));
+				       (void *)&meson_hdcp.hdcp_tx_type,
+				       sizeof(meson_hdcp.hdcp_tx_type));
 		if (rtn_val != 0) {
-			out_size = sizeof(am_hdmi->hdcp_tx_type);
+			out_size = sizeof(meson_hdcp.hdcp_tx_type);
 			DRM_INFO("out_size: %u, leftsize: %u\n",
 				 out_size, rtn_val);
 			rtn_val = -1;
@@ -257,10 +344,10 @@ static long hdcp_comm_ioctl(struct file *file,
 		break;
 	case HDCP_DOWNSTR_VER_IOC_REPORT:
 		rtn_val = copy_to_user((void __user *)arg,
-				       (void *)&am_hdmi->hdcp_downstream_type,
-				       sizeof(am_hdmi->hdcp_downstream_type));
+				       (void *)&meson_hdcp.hdcp_downstream_type,
+				       sizeof(meson_hdcp.hdcp_downstream_type));
 		if (rtn_val != 0) {
-			out_size = sizeof(am_hdmi->hdcp_downstream_type);
+			out_size = sizeof(meson_hdcp.hdcp_downstream_type);
 			DRM_INFO("out_size: %u, leftsize: %u\n",
 				 out_size, rtn_val);
 			rtn_val = -1;
@@ -268,10 +355,10 @@ static long hdcp_comm_ioctl(struct file *file,
 		break;
 	case HDCP_EXE_VER_IOC_REPORT:
 		rtn_val = copy_to_user((void __user *)arg,
-				       (void *)&am_hdmi->hdcp_execute_type,
-				       sizeof(am_hdmi->hdcp_execute_type));
+				       (void *)&meson_hdcp.hdcp_execute_type,
+				       sizeof(meson_hdcp.hdcp_execute_type));
 		if (rtn_val != 0) {
-			out_size = sizeof(am_hdmi->hdcp_execute_type);
+			out_size = sizeof(meson_hdcp.hdcp_execute_type);
 			DRM_INFO("out_size: %u, leftsize: %u\n",
 				 out_size, rtn_val);
 			rtn_val = -1;
@@ -285,19 +372,13 @@ static long hdcp_comm_ioctl(struct file *file,
 
 static unsigned int hdcp_comm_poll(struct file *file, poll_table *wait)
 {
-	struct miscdevice *phdcp_comm_device;
-	struct am_hdmi_tx *am_hdmi;
 	unsigned int mask = 0;
 
-	phdcp_comm_device = file->private_data;
-	am_hdmi = container_of(phdcp_comm_device,
-			       struct am_hdmi_tx,
-			       hdcp_comm_device);
-	DRM_INFO("hdcp_poll %d, %d\n", am_hdmi->hdcp_report, am_hdmi->hdcp_poll_report);
-	poll_wait(file, &am_hdmi->hdcp_comm_queue, wait);
-	if (am_hdmi->hdcp_report != am_hdmi->hdcp_poll_report) {
+	DRM_INFO("hdcp_poll %d, %d\n", meson_hdcp.hdcp_report, meson_hdcp.hdcp_poll_report);
+	poll_wait(file, &meson_hdcp.hdcp_comm_queue, wait);
+	if (meson_hdcp.hdcp_report != meson_hdcp.hdcp_poll_report) {
 		mask = POLLIN | POLLRDNORM;
-		am_hdmi->hdcp_poll_report = am_hdmi->hdcp_report;
+		meson_hdcp.hdcp_poll_report = meson_hdcp.hdcp_report;
 	}
 	return mask;
 }
@@ -311,25 +392,124 @@ static const struct file_operations hdcp_comm_file_operations = {
 	.poll = hdcp_comm_poll,
 };
 
-void hdcp_comm_init(struct am_hdmi_tx *am_hdmi)
+/***** debug interface begin *****/
+static void am_hdmitx_set_hdcp_mode(unsigned int user_type)
 {
-	int ret = 0;
-
-	am_hdmi->hdcp_user_type = 0x3;
-	am_hdmi->hdcp_report = HDCP_TX22_DISCONNECT;
-	am_hdmi->hdcp_en = 0;
-	am_hdmi->bootup_ready = false;
-	init_waitqueue_head(&am_hdmi->hdcp_comm_queue);
-	am_hdmi->hdcp_comm_device.minor = MISC_DYNAMIC_MINOR;
-	am_hdmi->hdcp_comm_device.name = "tee_comm_hdcp";
-	am_hdmi->hdcp_comm_device.fops = &hdcp_comm_file_operations;
-	ret = misc_register(&am_hdmi->hdcp_comm_device);
+	meson_hdcp.hdcp_debug_type = user_type;
+	DRM_INFO("set_hdcp_mode: %d manually\n", user_type);
+}
+
+static void am_hdmitx_set_hdmi_mode(void)
+{
+	enum vmode_e vmode = get_current_vmode();
+
+	if (vmode == VMODE_HDMI) {
+		DRM_INFO("set_hdmi_mode manually\n");
+	} else {
+		DRM_INFO("set_hdmi_mode manually fail! vmode:%d\n", vmode);
+		return;
+	}
+
+	set_vout_mode_pre_process(vmode);
+	set_vout_vmode(vmode);
+	set_vout_mode_post_process(vmode);
+}
+
+/* set hdmi+hdcp mode */
+static void am_hdmitx_set_out_mode(void)
+{
+	enum vmode_e vmode = get_current_vmode();
+	struct hdmitx_dev *hdmitx_dev = get_hdmitx_device();
+	int last_hdcp_mode = HDCP_NULL;
+
+	if (vmode == VMODE_HDMI) {
+		DRM_INFO("set_out_mode\n");
+	} else {
+		DRM_INFO("set_out_mode fail! vmode:%d\n", vmode);
+		return;
+	}
+
+	if (hdmitx_dev->hdcp_ctl_lvl > 0) {
+		drm_hdmitx_avmute(1);
+		msleep(100);
+		last_hdcp_mode = meson_hdcp.hdcp_execute_type;
+		meson_hdcp_disable();
+	}
+	set_vout_mode_pre_process(vmode);
+	set_vout_vmode(vmode);
+	set_vout_mode_post_process(vmode);
+	/* msleep(1000); */
+	if (hdmitx_dev->hdcp_ctl_lvl > 0) {
+		drm_hdmitx_avmute(0);
+		meson_hdcp_enable(last_hdcp_mode);
+	}
+}
+
+static void am_hdmitx_hdcp_disable(void)
+{
+	struct hdmitx_dev *hdmitx_dev = get_hdmitx_device();
+
+	if (hdmitx_dev->hdcp_ctl_lvl >= 1)
+		meson_hdcp_disable();
+	DRM_INFO("hdcp disable manually\n");
+}
+
+static void am_hdmitx_hdcp_enable(void)
+{
+	struct hdmitx_dev *hdmitx_dev = get_hdmitx_device();
+	int hdcp_type = HDCP_NULL;
+
+	if (hdmitx_dev->hdcp_ctl_lvl >= 1) {
+		hdcp_type = am_get_hdcp_exe_type();
+		meson_hdcp_enable(hdcp_type);
+	}
+	DRM_INFO("hdcp enable manually\n");
+}
+
+static void am_hdmitx_hdcp_disconnect(void)
+{
+	struct hdmitx_dev *hdmitx_dev = get_hdmitx_device();
+
+	if (hdmitx_dev->hdcp_ctl_lvl >= 1)
+		meson_hdcp_disconnect();
+	DRM_INFO("hdcp disconnect manually\n");
+}
+
+/***** debug interface end *****/
+
+void meson_hdcp_init(void)
+{
+	int ret;
+	struct drm_hdmitx_hdcp_cb hdcp_cb;
+	struct hdmitx_dev *hdmitx_dev;
+
+	meson_hdcp.hdcp_debug_type = 0x3;
+	meson_hdcp.hdcp_report = HDCP_TX22_DISCONNECT;
+	meson_hdcp.hdcp_en = 0;
+	meson_hdcp.bootup_ready = HDCP22_KEY_LOADING;
+	init_waitqueue_head(&meson_hdcp.hdcp_comm_queue);
+	meson_hdcp.hdcp_comm_device.minor = MISC_DYNAMIC_MINOR;
+	meson_hdcp.hdcp_comm_device.name = "tee_comm_hdcp";
+	meson_hdcp.hdcp_comm_device.fops = &hdcp_comm_file_operations;
+	ret = misc_register(&meson_hdcp.hdcp_comm_device);
 	if (ret < 0)
 		DRM_ERROR("%s [ERROR] misc_register fail\n", __func__);
+
+	hdcp_cb.callback = meson_hdmitx_hdcp_cb;
+	hdcp_cb.data = &meson_hdcp;
+	drm_hdmitx_register_hdcp_cb(&hdcp_cb);
+
+	hdmitx_dev = get_hdmitx_device();
+	hdmitx_dev->hwop.am_hdmitx_set_hdcp_mode = am_hdmitx_set_hdcp_mode;
+	hdmitx_dev->hwop.am_hdmitx_set_hdmi_mode = am_hdmitx_set_hdmi_mode;
+	hdmitx_dev->hwop.am_hdmitx_set_out_mode = am_hdmitx_set_out_mode;
+	hdmitx_dev->hwop.am_hdmitx_hdcp_disable = am_hdmitx_hdcp_disable;
+	hdmitx_dev->hwop.am_hdmitx_hdcp_enable = am_hdmitx_hdcp_enable;
+	hdmitx_dev->hwop.am_hdmitx_hdcp_disconnect = am_hdmitx_hdcp_disconnect;
 }
 
-void hdcp_comm_exit(struct am_hdmi_tx *am_hdmi)
+void meson_hdcp_exit(void)
 {
-	misc_deregister(&am_hdmi->hdcp_comm_device);
+	misc_deregister(&meson_hdcp.hdcp_comm_device);
 }
 
diff --git a/drivers/amlogic/drm/meson_hdcp.h b/drivers/amlogic/drm/meson_hdcp.h
index f784d384615c..5da00addc4f3 100644
--- a/drivers/amlogic/drm/meson_hdcp.h
+++ b/drivers/amlogic/drm/meson_hdcp.h
@@ -6,21 +6,30 @@
 #ifndef __MESON_HDCP_H__
 #define __MESON_HDCP_H__
 
-#define HDCP_MODE14    1
-#define HDCP_MODE22    2
-#define HDCP_NULL      0
 
 enum {
-	HDCP_TX22_DISCONNECT,
-	HDCP_TX22_START,
-	HDCP_TX22_STOP
+	HDCP_NULL = 0,
+	HDCP_MODE14 = 1 << 0,
+	HDCP_MODE22 = 1 << 1,
 };
 
-void am_hdcp_disable(struct am_hdmi_tx *am_hdmi);
-void am_hdcp_enable(struct am_hdmi_tx *am_hdmi);
-void am_hdcp_disconnect(struct am_hdmi_tx *am_hdmi);
+enum {
+	HDCP_AUTH_FAIL = 0,
+	HDCP_AUTH_OK = 1,
+	HDCP_AUTH_UNKNOWN = 0xff,
+};
+
+typedef void (*hdcp_notify)(int type, int auth_result);
+
+void meson_hdcp_init(void);
+void meson_hdcp_exit(void);
+
+void meson_hdcp_enable(int hdcp_type);
+void meson_hdcp_disable(void);
+void meson_hdcp_disconnect(void);
 
-void hdcp_comm_init(struct am_hdmi_tx *am_hdmi);
-void hdcp_comm_exit(struct am_hdmi_tx *am_hdmi);
+unsigned int meson_hdcp_get_key_version(void);
+int meson_hdcp_get_valid_type(int request_type_mask);
+void meson_hdcp_reg_result_notify(hdcp_notify cb);
 
 #endif
diff --git a/drivers/amlogic/drm/meson_hdmi.c b/drivers/amlogic/drm/meson_hdmi.c
index b467a5037d6b..a9c3938e0360 100644
--- a/drivers/amlogic/drm/meson_hdmi.c
+++ b/drivers/amlogic/drm/meson_hdmi.c
@@ -11,7 +11,7 @@
 #include <drm/drm_atomic_helper.h>
 #include <drm/drm_connector.h>
 #include <drm/drm_hdcp.h>
-
+#include <drm/drm_modeset_lock.h>
 
 #include <linux/component.h>
 #include <linux/irq.h>
@@ -20,13 +20,13 @@
 #include <linux/jiffies.h>
 #include <linux/kthread.h>
 #include <linux/device.h>
-
 #include <linux/workqueue.h>
 #include <linux/amlogic/media/vout/vout_notify.h>
 #include <linux/amlogic/media/vout/hdmi_tx/hdmi_tx_module.h>
 #include <linux/amlogic/media/vout/hdmi_tx/hdmi_common.h>
 #include <linux/amlogic/media/vout/hdmi_tx/meson_drm_hdmitx.h>
 #include <linux/miscdevice.h>
+#include <linux/amlogic/media/vout/hdmi_tx/meson_drm_hdmitx.h>
 
 #include "meson_hdmi.h"
 #include "meson_hdcp.h"
@@ -34,6 +34,8 @@
 #include "meson_crtc.h"
 
 #define DEVICE_NAME "amhdmitx"
+#define HDCP_KEY_INVALID 0xff00
+
 static struct am_hdmi_tx am_hdmi_info;
 
 /*for hw limitiation, limit to 1080p/720p for recovery ui.*/
@@ -355,7 +357,7 @@ struct drm_connector_state *am_hdmitx_atomic_duplicate_state
 }
 
 void am_hdmitx_atomic_destroy_state(struct drm_connector *connector,
-				 struct drm_connector_state *state)
+	 struct drm_connector_state *state)
 {
 	struct am_hdmitx_connector_state *hdmitx_state;
 
@@ -378,6 +380,211 @@ void am_hdmitx_reset(struct drm_connector *connector)
 	kfree(connector->state);
 
 	__drm_atomic_helper_connector_reset(connector, &hdmitx_state->base);
+
+	hdmitx_state->base.hdcp_content_type = am_hdmi_info.hdcp_request_content_type;
+	hdmitx_state->base.content_protection = am_hdmi_info.hdcp_request_content_protection;
+}
+
+static bool meson_hdmitx_is_hdcp_running(void)
+{
+	if (am_hdmi_info.hdcp_state == HDCP_STATE_DISCONNECT ||
+		am_hdmi_info.hdcp_state == HDCP_STATE_STOP)
+		return false;
+
+	if (am_hdmi_info.hdcp_mode == HDCP_NULL)
+		DRM_ERROR("hdcp mode should NOT null for state [%d]\n",
+			am_hdmi_info.hdcp_state);
+
+	return true;
+}
+
+static void meson_hdmitx_set_hdcp_result(int result)
+{
+	struct drm_connector *connector = &am_hdmi_info.base.connector;
+	struct drm_modeset_lock *mode_lock =
+		&connector->dev->mode_config.connection_mutex;
+
+	if (result == HDCP_AUTH_OK) {
+		am_hdmi_info.hdcp_state = HDCP_STATE_SUCCESS;
+		drm_modeset_lock(mode_lock, NULL);
+		drm_hdcp_update_content_protection(connector, DRM_MODE_CONTENT_PROTECTION_ENABLED);
+		drm_modeset_unlock(mode_lock);
+		DRM_DEBUG("hdcp [%d] set result ok.\n", am_hdmi_info.hdcp_mode);
+	} else if (result == HDCP_AUTH_FAIL) {
+		am_hdmi_info.hdcp_state = HDCP_STATE_FAIL;
+		/*no event needed when fail.*/
+		DRM_ERROR("hdcp [%d] set result fail.\n", am_hdmi_info.hdcp_mode);
+	} else if (result == HDCP_AUTH_UNKNOWN) {
+		/*reset property value to DESIRED.*/
+		if (connector->state &&
+			connector->state->content_protection ==
+				DRM_MODE_CONTENT_PROTECTION_ENABLED) {
+			drm_modeset_lock(mode_lock, NULL);
+			drm_hdcp_update_content_protection(connector,
+				DRM_MODE_CONTENT_PROTECTION_DESIRED);
+			drm_modeset_unlock(mode_lock);
+		}
+	}
+}
+
+static void meson_hdmitx_start_hdcp(int hdcp_mode)
+{
+	if (hdcp_mode == HDCP_NULL)
+		return;
+
+	am_hdmi_info.hdcp_mode = hdcp_mode;
+	am_hdmi_info.hdcp_state = HDCP_STATE_START;
+	meson_hdcp_enable(hdcp_mode);
+	DRM_DEBUG("start hdcp [%d-%d]...\n",
+		am_hdmi_info.hdcp_request_content_type, am_hdmi_info.hdcp_mode);
+}
+
+static void meson_hdmitx_stop_hdcp(void)
+{
+	if (meson_hdmitx_is_hdcp_running()) {
+		meson_hdcp_disable();
+		am_hdmi_info.hdcp_state = HDCP_STATE_STOP;
+		am_hdmi_info.hdcp_mode = HDCP_NULL;
+		meson_hdmitx_set_hdcp_result(HDCP_AUTH_UNKNOWN);
+	}
+}
+
+static void meson_hdmitx_disconnect_hdcp(void)
+{
+	if (meson_hdmitx_is_hdcp_running()) {
+		meson_hdcp_disconnect();
+		am_hdmi_info.hdcp_state = HDCP_STATE_DISCONNECT;
+		am_hdmi_info.hdcp_mode = HDCP_NULL;
+		meson_hdmitx_set_hdcp_result(HDCP_AUTH_UNKNOWN);
+	}
+}
+
+void meson_hdmitx_update_hdcp(void)
+{
+	int hdcp_request_mode = HDCP_NULL;
+	int hdcp_request_mask = HDCP_NULL;
+	unsigned int hdcp_key_mask = 0;
+
+	DRM_DEBUG("%s\n", __func__);
+
+	/*Undesired, disable hdcp.*/
+	if (am_hdmi_info.hdcp_request_content_protection == DRM_MODE_CONTENT_PROTECTION_UNDESIRED) {
+		meson_hdmitx_stop_hdcp();
+		return;
+	}
+
+	if (am_hdmi_info.hdcp_request_content_type == DRM_MODE_HDCP_CONTENT_TYPE0)
+		hdcp_request_mask = HDCP_MODE14 | HDCP_MODE22;
+	else
+		hdcp_request_mask = HDCP_MODE22;
+
+	/*current hdcp mode is valid, check to use last state*/
+	if (hdcp_request_mask & am_hdmi_info.hdcp_mode) {
+		switch (am_hdmi_info.hdcp_state) {
+		case HDCP_STATE_START:
+			DRM_INFO("waiting hdcp result.\n");
+			return;
+		case HDCP_STATE_SUCCESS:
+			meson_hdmitx_set_hdcp_result(HDCP_AUTH_OK);
+			return;
+		case HDCP_STATE_FAIL:
+			/*failed mode, dont try again.*/
+			hdcp_request_mask &= ~(am_hdmi_info.hdcp_mode);
+			break;
+		default:
+			DRM_ERROR("meet stopped hdcp stat\n");
+			break;
+		};
+	}
+
+	meson_hdmitx_stop_hdcp();
+
+	/*try to get latest key state.*/
+	if (am_hdmi_info.hdcp_key == HDCP_KEY_INVALID) {
+		hdcp_request_mode = HDCP_MODE22;
+		DRM_INFO("first load hdcp key %u\n", hdcp_key_mask);
+	} else {
+		hdcp_request_mode = meson_hdcp_get_valid_type(hdcp_request_mask);
+	}
+
+	if (hdcp_request_mode == HDCP_NULL) {
+		DRM_ERROR("No valid hdcp mode exit.\n");
+		return;
+	}
+
+	meson_hdmitx_start_hdcp(hdcp_request_mode);
+}
+
+void meson_hdmitx_update_hdcp_locked(void)
+{
+	struct drm_connector *connector = &am_hdmi_info.base.connector;
+	struct drm_modeset_lock *mode_lock =
+		&connector->dev->mode_config.connection_mutex;
+
+	drm_modeset_lock(mode_lock, NULL);
+	meson_hdmitx_update_hdcp();
+	drm_modeset_unlock(mode_lock);
+}
+
+void meson_hdmitx_update(struct drm_connector_state *new_state,
+	struct drm_connector_state *old_state)
+{
+	if (!am_hdmi_info.android_path) {
+		/*nothing changed, exit.*/
+		if (old_state->hdcp_content_type == new_state->hdcp_content_type) {
+			if (old_state->content_protection == new_state->content_protection)
+				return;
+			/*omit desired->enable which switch by driver.*/
+			if (new_state->content_protection == DRM_MODE_CONTENT_PROTECTION_ENABLED)
+				return;
+		}
+
+		/*check hdcp property update*/
+		am_hdmi_info.hdcp_request_content_type = new_state->hdcp_content_type;
+		am_hdmi_info.hdcp_request_content_protection = new_state->content_protection;
+
+		if (!drm_atomic_crtc_needs_modeset(new_state->crtc->state))
+			meson_hdmitx_update_hdcp();
+	}
+}
+
+static void meson_hdmitx_hdcp_notify(int type, int result)
+{
+	if (type == HDCP_NULL && result == HDCP_AUTH_OK) {
+		DRM_ERROR("HDCP KEY LOAD FINISHED, need update?\n");
+		//meson_hdmitx_update_hdcp_locked();
+		return;
+	}
+
+	if (type != am_hdmi_info.hdcp_mode) {
+		DRM_DEBUG("notify type is mismatch[%d]-[%d]\n",
+			type, am_hdmi_info.hdcp_mode);
+		return;
+	}
+
+	if (result != HDCP_AUTH_UNKNOWN && am_hdmi_info.hdcp_key == HDCP_KEY_INVALID) {
+		am_hdmi_info.hdcp_key = meson_hdcp_get_key_version();
+		DRM_INFO("update hdcp key in mode22 fail to [%d]\n",
+			am_hdmi_info.hdcp_key);
+	}
+
+	if (result == HDCP_AUTH_OK) {
+		meson_hdmitx_set_hdcp_result(HDCP_AUTH_OK);
+	} else if (result == HDCP_AUTH_FAIL) {
+		if (type == HDCP_MODE14) {
+			meson_hdmitx_set_hdcp_result(HDCP_AUTH_FAIL);
+		} else if (type == HDCP_MODE22) {
+			if (am_hdmi_info.hdcp_request_content_type == DRM_MODE_HDCP_CONTENT_TYPE0) {
+				DRM_ERROR("ContentType0 hdcp 22 -> hdcp14.\n");
+				meson_hdmitx_stop_hdcp();
+				meson_hdmitx_start_hdcp(HDCP_MODE14);
+			} else {
+				meson_hdmitx_set_hdcp_result(HDCP_AUTH_FAIL);
+			}
+		}
+	} else {
+		DRM_ERROR("HDCP report unknown result [%d-%d]\n", type, result);
+	}
 }
 
 static const struct drm_connector_helper_funcs am_hdmi_connector_helper_funcs = {
@@ -406,18 +613,16 @@ void am_hdmi_encoder_atomic_mode_set(struct drm_encoder *encoder,
 	bool support = false;
 	char mode_tmp[DRM_MODE_LEN_MAX];
 	char attr_tmp[DRM_ATTR_LEN_MAX];
-	struct hdmitx_dev *hdmitx_dev = get_hdmitx_device();
 
-	am_hdmi_info.hdcp_ctl_lvl = hdmitx_dev->hdcp_ctl_lvl;
-	/* android should not use this interface */
-	if (am_hdmi_info.hdcp_ctl_lvl == 0)
+	/*android should not use this interface*/
+	if (am_hdmi_info.android_path)
 		return;
 	if (!crtc_state)
 		return;
 
 	memset(mode_tmp, 0, sizeof(mode_tmp));
 	memset(attr_tmp, 0, sizeof(attr_tmp));
-	/* get attr from ubootenv */
+	/*get attr from ubootenv*/
 	amhdmitx_get_attr(attr_tmp);
 
 	DRM_INFO("new mode name :%s, current attr: %s\n",
@@ -447,13 +652,9 @@ void am_hdmi_encoder_atomic_mode_set(struct drm_encoder *encoder,
 
 void am_hdmi_encoder_atomic_enable(struct drm_encoder *encoder,
 	struct drm_atomic_state *state)
-
 {
 	enum vmode_e vmode = get_current_vmode();
 	struct am_meson_crtc_state *meson_crtc_state = to_am_meson_crtc_state(encoder->crtc->state);
-	struct hdmitx_dev *hdmitx_dev = get_hdmitx_device();
-
-	am_hdmi_info.hdcp_ctl_lvl = hdmitx_dev->hdcp_ctl_lvl;
 
 	if (vmode == VMODE_HDMI) {
 		DRM_INFO("[%s]\n", __func__);
@@ -468,33 +669,28 @@ void am_hdmi_encoder_atomic_enable(struct drm_encoder *encoder,
 	 * (no need when boot up && hdmi output
 	 * enabled under uboot already)
 	 */
-	if (am_hdmi_info.hdcp_ctl_lvl == 1) {
+	if (!am_hdmi_info.android_path) {
 		if ((vmode & VMODE_INIT_BIT_MASK) !=
 			VMODE_INIT_BIT_MASK) {
 			drm_hdmitx_avmute(1);
 			msleep(100);
 		}
-		am_hdcp_disable(&am_hdmi_info);
+		meson_hdmitx_stop_hdcp();
 	}
 	set_vout_mode_pre_process(vmode);
 	set_vout_vmode(vmode);
 	set_vout_mode_post_process(vmode);
 	/* msleep(1000); */
 	/* todo: clear avmute */
-	if (am_hdmi_info.hdcp_ctl_lvl == 1) {
+	if (!am_hdmi_info.android_path) {
 		drm_hdmitx_avmute(0);
-		am_hdcp_enable(&am_hdmi_info);
+		meson_hdmitx_update_hdcp();
 	}
 }
 
 void am_hdmi_encoder_atomic_disable(struct drm_encoder *encoder,
 	struct drm_atomic_state *state)
 {
-	struct am_hdmi_tx *am_hdmi = encoder_to_am_hdmi(encoder);
-	struct drm_connector_state *conn_state = am_hdmi->connector.state;
-
-	/* to be test: move hdcp disable here */
-	conn_state->content_protection = DRM_MODE_CONTENT_PROTECTION_UNDESIRED;
 	DRM_INFO("[%s]\n", __func__);
 }
 
@@ -516,11 +712,6 @@ static const struct of_device_id am_meson_hdmi_dt_ids[] = {
 
 MODULE_DEVICE_TABLE(of, am_meson_hdmi_dt_ids);
 
-struct drm_connector *am_meson_hdmi_connector(void)
-{
-	return &am_hdmi_info.connector;
-}
-
 static void am_meson_hdmi_connector_init_property(struct drm_device *drm_dev,
 						  struct am_hdmi_tx *am_hdmi)
 {
@@ -529,22 +720,21 @@ static void am_meson_hdmi_connector_init_property(struct drm_device *drm_dev,
 	prop = drm_property_create_bool(drm_dev, 0, "UPDATE");
 	if (prop) {
 		am_hdmi->update_attr_prop = prop;
-		drm_object_attach_property(&am_hdmi->connector.base, prop, 0);
+		drm_object_attach_property(&am_hdmi->base.connector.base, prop, 0);
 	} else {
 		DRM_ERROR("Failed to UPDATE property\n");
 	}
 }
 
-static void am_meson_hdmi_hpd_cb(void *data)
+static void meson_hdmitx_hpd_cb(void *data)
 {
 	struct am_hdmi_tx *am_hdmi = (struct am_hdmi_tx *)data;
 
 	DRM_INFO("drm hdmitx hpd notify\n");
-	if (drm_hdmitx_detect_hpd() == 0 &&
-		am_hdmi->hdcp_ctl_lvl > 0)
-		am_hdcp_disconnect(am_hdmi);
+	if (drm_hdmitx_detect_hpd() == 0 && !am_hdmi->android_path)
+		meson_hdmitx_disconnect_hdcp();
 
-	drm_helper_hpd_irq_event(am_hdmi->connector.dev);
+	drm_helper_hpd_irq_event(am_hdmi->base.connector.dev);
 }
 
 static int am_meson_hdmi_bind(struct device *dev,
@@ -555,18 +745,21 @@ static int am_meson_hdmi_bind(struct device *dev,
 	struct am_hdmi_tx *am_hdmi;
 	struct drm_connector *connector;
 	struct drm_encoder *encoder;
+	struct meson_connector *mesonconn;
+	struct drm_hdmitx_hpd_cb hpd_cb;
 	int ret;
 
 	DRM_INFO("[%s] in\n", __func__);
-	am_hdmi = &am_hdmi_info;
-
 	DRM_INFO("drm hdmitx init and version:%s\n", DRM_HDMITX_VER);
-	am_hdmi->priv = priv;
+	am_hdmi = &am_hdmi_info;
+	mesonconn = &am_hdmi->base;
+	mesonconn->drm_priv = priv;
+	mesonconn->update = meson_hdmitx_update;
 	encoder = &am_hdmi->encoder;
-	connector = &am_hdmi->connector;
+	connector = &am_hdmi->base.connector;
 
 	/* Connector */
-	am_hdmi->connector.polled = DRM_CONNECTOR_POLL_HPD;
+	connector->polled = DRM_CONNECTOR_POLL_HPD;
 	drm_connector_helper_add(connector,
 				 &am_hdmi_connector_helper_funcs);
 
@@ -576,8 +769,6 @@ static int am_meson_hdmi_bind(struct device *dev,
 		dev_err(priv->dev, "Failed to init hdmi tx connector\n");
 		return ret;
 	}
-	am_meson_hdmi_connector_init_property(drm, am_hdmi);
-
 	connector->interlace_allowed = 1;
 
 	/* Encoder */
@@ -592,9 +783,20 @@ static int am_meson_hdmi_bind(struct device *dev,
 	drm_connector_attach_encoder(connector, encoder);
 
 	/*hpd irq moved to amhdmitx, registe call back */
-	drm_hdmitx_register_hpd_cb(am_meson_hdmi_hpd_cb, (void *)am_hdmi);
-	/*hdcp prop*/
-	drm_connector_attach_content_protection_property(connector, true);
+	hpd_cb.callback = meson_hdmitx_hpd_cb;
+	hpd_cb.data = &am_hdmi_info;
+	drm_hdmitx_register_hpd_cb(&hpd_cb);
+
+	/*hdcp init, default is disable state*/
+	if (!am_hdmi_info.android_path) {
+		drm_connector_attach_content_protection_property(connector, true);
+		meson_hdcp_reg_result_notify(meson_hdmitx_hdcp_notify);
+		am_hdmi_info.hdcp_mode = HDCP_NULL;
+		am_hdmi_info.hdcp_state = HDCP_STATE_DISCONNECT;
+	}
+
+	/*amlogic prop*/
+	am_meson_hdmi_connector_init_property(drm, am_hdmi);
 
 	DRM_INFO("[%s] out\n", __func__);
 	return 0;
@@ -603,7 +805,7 @@ static int am_meson_hdmi_bind(struct device *dev,
 static void am_meson_hdmi_unbind(struct device *dev,
 				 struct device *master, void *data)
 {
-	am_hdmi_info.connector.funcs->destroy(&am_hdmi_info.connector);
+	am_hdmi_info.base.connector.funcs->destroy(&am_hdmi_info.base.connector);
 	am_hdmi_info.encoder.funcs->destroy(&am_hdmi_info.encoder);
 }
 
@@ -612,119 +814,41 @@ static const struct component_ops am_meson_hdmi_ops = {
 	.unbind	= am_meson_hdmi_unbind,
 };
 
-/***** debug interface begin *****/
-static void am_hdmitx_set_hdcp_mode(unsigned int user_type)
-{
-	am_hdmi_info.hdcp_user_type = user_type;
-	DRM_INFO("set_hdcp_mode: %d manually\n", user_type);
-}
-
-static void am_hdmitx_set_hdmi_mode(void)
-{
-	enum vmode_e vmode = get_current_vmode();
-
-	if (vmode == VMODE_HDMI) {
-		DRM_INFO("set_hdmi_mode manually\n");
-	} else {
-		DRM_INFO("set_hdmi_mode manually fail! vmode:%d\n", vmode);
-		return;
-	}
-
-	set_vout_mode_pre_process(vmode);
-	set_vout_vmode(vmode);
-	set_vout_mode_post_process(vmode);
-}
-
-/* set hdmi+hdcp mode */
-static void am_hdmitx_set_out_mode(void)
+static int am_meson_hdmi_probe(struct platform_device *pdev)
 {
-	enum vmode_e vmode = get_current_vmode();
 	struct hdmitx_dev *hdmitx_dev = get_hdmitx_device();
 
-	am_hdmi_info.hdcp_ctl_lvl = hdmitx_dev->hdcp_ctl_lvl;
+	DRM_INFO("[%s] in\n", __func__);
+	memset(&am_hdmi_info, 0, sizeof(am_hdmi_info));
 
-	if (vmode == VMODE_HDMI) {
-		DRM_INFO("set_out_mode\n");
+	if (hdmitx_dev->hdcp_ctl_lvl == 0) {
+		am_hdmi_info.android_path = true;
 	} else {
-		DRM_INFO("set_out_mode fail! vmode:%d\n", vmode);
-		return;
-	}
-
-	if (am_hdmi_info.hdcp_ctl_lvl > 0) {
-		drm_hdmitx_avmute(1);
-		msleep(100);
-		am_hdcp_disable(&am_hdmi_info);
-	}
-	set_vout_mode_pre_process(vmode);
-	set_vout_vmode(vmode);
-	set_vout_mode_post_process(vmode);
-	/* msleep(1000); */
-	if (am_hdmi_info.hdcp_ctl_lvl > 0) {
-		drm_hdmitx_avmute(0);
-		am_hdcp_enable(&am_hdmi_info);
+		meson_hdcp_init();
+		am_hdmi_info.hdcp_key = HDCP_KEY_INVALID;/*set invalid.*/
+		if (hdmitx_dev->hdcp_ctl_lvl == 1) {
+			/*TODO: for westeros start hdcp by driver, will move to userspace.*/
+			am_hdmi_info.hdcp_request_content_type =
+				DRM_MODE_HDCP_CONTENT_TYPE0;
+			am_hdmi_info.hdcp_request_content_protection =
+				DRM_MODE_CONTENT_PROTECTION_DESIRED;
+		} else {
+			am_hdmi_info.hdcp_request_content_type =
+				DRM_MODE_HDCP_CONTENT_TYPE0;
+			am_hdmi_info.hdcp_request_content_protection =
+				DRM_MODE_CONTENT_PROTECTION_UNDESIRED;
+		}
 	}
-}
-
-static void am_hdmitx_hdcp_disable(void)
-{
-	struct hdmitx_dev *hdmitx_dev = get_hdmitx_device();
-
-	am_hdmi_info.hdcp_ctl_lvl = hdmitx_dev->hdcp_ctl_lvl;
-	if (am_hdmi_info.hdcp_ctl_lvl >= 1)
-		am_hdcp_disable(&am_hdmi_info);
-	DRM_INFO("hdcp disable manually\n");
-}
 
-static void am_hdmitx_hdcp_enable(void)
-{
-	struct hdmitx_dev *hdmitx_dev = get_hdmitx_device();
-
-	am_hdmi_info.hdcp_ctl_lvl = hdmitx_dev->hdcp_ctl_lvl;
-	if (am_hdmi_info.hdcp_ctl_lvl >= 1)
-		am_hdcp_enable(&am_hdmi_info);
-	DRM_INFO("hdcp enable manually\n");
-}
-
-static void am_hdmitx_hdcp_disconnect(void)
-{
-	struct hdmitx_dev *hdmitx_dev = get_hdmitx_device();
-
-	am_hdmi_info.hdcp_ctl_lvl = hdmitx_dev->hdcp_ctl_lvl;
-	if (am_hdmi_info.hdcp_ctl_lvl >= 1)
-		am_hdcp_disconnect(&am_hdmi_info);
-	DRM_INFO("hdcp disconnect manually\n");
-}
-
-/***** debug interface end *****/
-
-static int am_meson_hdmi_probe(struct platform_device *pdev)
-{
-	struct hdmitx_dev *hdmitx_dev;
-
-	DRM_INFO("[%s] in\n", __func__);
-	memset(&am_hdmi_info, 0, sizeof(am_hdmi_info));
-	hdcp_comm_init(&am_hdmi_info);
-	hdmitx_dev = get_hdmitx_device();
-	/* hdcp auth control owner:
-	 * 0: by android sysctrl
-	 * 1: by drm driver
-	 * 2: by linux app
-	 */
-	am_hdmi_info.hdcp_ctl_lvl = hdmitx_dev->hdcp_ctl_lvl;
 	am_hdmi_info.color_depth = COLORDEPTH_RESERVED;
 	am_hdmi_info.color_space = COLORSPACE_RESERVED;
-	hdmitx_dev->hwop.am_hdmitx_set_hdcp_mode = am_hdmitx_set_hdcp_mode;
-	hdmitx_dev->hwop.am_hdmitx_set_hdmi_mode = am_hdmitx_set_hdmi_mode;
-	hdmitx_dev->hwop.am_hdmitx_set_out_mode = am_hdmitx_set_out_mode;
-	hdmitx_dev->hwop.am_hdmitx_hdcp_disable = am_hdmitx_hdcp_disable;
-	hdmitx_dev->hwop.am_hdmitx_hdcp_enable = am_hdmitx_hdcp_enable;
-	hdmitx_dev->hwop.am_hdmitx_hdcp_disconnect = am_hdmitx_hdcp_disconnect;
+
 	return component_add(&pdev->dev, &am_meson_hdmi_ops);
 }
 
 static int am_meson_hdmi_remove(struct platform_device *pdev)
 {
-	hdcp_comm_exit(&am_hdmi_info);
+	meson_hdcp_exit();
 	component_del(&pdev->dev, &am_meson_hdmi_ops);
 	return 0;
 }
diff --git a/drivers/amlogic/drm/meson_hdmi.h b/drivers/amlogic/drm/meson_hdmi.h
index f5661fdd67e4..8695f351d550 100644
--- a/drivers/amlogic/drm/meson_hdmi.h
+++ b/drivers/amlogic/drm/meson_hdmi.h
@@ -9,6 +9,7 @@
 #include "meson_drv.h"
 #include <drm/drm_connector.h>
 #include <drm/drm_encoder.h>
+#include <linux/amlogic/media/vout/hdmi_tx/meson_drm_hdmitx.h>
 
 #define DDC_SEGMENT_ADDR   0x30
 #define VIC_MAX_NUM        512
@@ -42,51 +43,42 @@
 #define MODE_4K2KSMPTE50HZ              "smpte50hz"
 #define MODE_4K2KSMPTE60HZ              "smpte60hz"
 
-struct am_hdmi_data {
-	unsigned int vic;
-	u8 sink_is_hdmi;
-	u8 sink_has_audio;
-	unsigned int colorimetry;
-	unsigned int  cd; /* cd8, cd10 or cd12 */
-	unsigned int  cs; /* rgb, y444, y422, y420 */
-	unsigned int  cr; /* limit, full */
-	struct hdmi_pwr_ctl *pwr_ctl;
-	unsigned int aud_output_ch;
-	unsigned int tx_aud_cfg; /* 0, off; 1, on */
-	unsigned int tmds_clk_div40;
-	unsigned int VIC[VIC_MAX_NUM];
+enum {
+	HDCP_STATE_START = 0,
+	HDCP_STATE_SUCCESS,
+	HDCP_STATE_FAIL,
+	HDCP_STATE_STOP,
+	HDCP_STATE_DISCONNECT,
 };
 
 struct am_hdmi_tx {
-	struct device *dev;
+	struct meson_connector base;
 	struct drm_encoder encoder;
-	struct drm_connector connector;
-	struct meson_drm *priv;
-	int irq;
+
 	unsigned int input_color_format;
 	unsigned int output_color_format;
 	enum hdmi_color_depth color_depth;
 	enum hdmi_color_space color_space;
 	struct drm_property *color_depth_property;
 	struct drm_property *color_space_property;
-	struct drm_display_mode previous_mode;
-	struct am_hdmi_data hdmi_info;
 
-	unsigned int hpd_flag;/*0:none   1:up    2:down*/
-	unsigned int hdcp_tx_type;/*bit0:hdcp14 bit 1:hdcp22*/
-	unsigned int hdcp_downstream_type;/*bit0:hdcp14 bit 1:hdcp22*/
-	unsigned int hdcp_user_type;/*0: null hdcp 1: hdcp14 2: hdcp22*/
-	unsigned int hdcp_execute_type;/*0: null hdcp 1: hdcp14 2: hdcp22*/
+	/*drm request content type.*/
+	int hdcp_request_content_type;
+	int hdcp_request_content_protection;
+	/*current hdcp running mode, HDCP_NULL means hdcp disabled.*/
+	int hdcp_mode;
+	/*hdcp auth result, HDCP_AUTH_UNKNOWN means havenot finished auth.*/
+	int hdcp_state;
+	/*TODO:for check tee loading, should move to meson_hdcp.*/
+	int hdcp_key;
+
+	/*TODO: android compatible, remove later*/
+	bool android_path;
 
-	struct miscdevice hdcp_comm_device;
-	wait_queue_head_t hdcp_comm_queue;
+	/*amlogic property: force hdmitx update
+	 *colorspace/colordepth from sysfs.
+	 */
 	struct drm_property *update_attr_prop;
-	int hdcp_result;
-	int hdcp_report;
-	int hdcp_poll_report;
-	unsigned int hdcp_en;
-	unsigned int hdcp_ctl_lvl;
-	bool bootup_ready;
 };
 
 struct am_hdmitx_connector_state {
@@ -95,6 +87,8 @@ struct am_hdmitx_connector_state {
 };
 
 #define to_am_hdmitx_connector_state(x)	container_of(x, struct am_hdmitx_connector_state, base)
-#define connector_to_am_hdmi(x)	container_of(x, struct am_hdmi_tx, connector)
+#define meson_connector_to_am_hdmi(x)	container_of(x, struct am_hdmi_tx, base)
+#define connector_to_am_hdmi(x) \
+	container_of(connector_to_meson_connector(x), struct am_hdmi_tx, base)
 #define encoder_to_am_hdmi(x)	container_of(x, struct am_hdmi_tx, encoder)
 #endif
diff --git a/drivers/amlogic/media/vout/hdmitx/hdmi_tx_20/hdmi_tx_main.c b/drivers/amlogic/media/vout/hdmitx/hdmi_tx_20/hdmi_tx_main.c
index c95e0487e424..b934aeb36621 100644
--- a/drivers/amlogic/media/vout/hdmitx/hdmi_tx_20/hdmi_tx_main.c
+++ b/drivers/amlogic/media/vout/hdmitx/hdmi_tx_20/hdmi_tx_main.c
@@ -5646,8 +5646,8 @@ static void hdmitx_hpd_plugin_handler(struct work_struct *work)
 	hdmitx_notify_hpd(hdev->hpd_state);
 
 	/*notify to drm hdmi*/
-	if (hdmitx_device.drm_cb)
-		hdmitx_device.drm_cb(hdmitx_device.drm_data);
+	if (hdmitx_device.drm_hpd_cb.callback)
+		hdmitx_device.drm_hpd_cb.callback(hdmitx_device.drm_hpd_cb.data);
 
 	hdmitx_set_uevent(HDMITX_HPD_EVENT, 1);
 	hdmitx_set_uevent(HDMITX_AUDIO_EVENT, 1);
@@ -5716,8 +5716,8 @@ static void hdmitx_hpd_plugout_handler(struct work_struct *work)
 		hdmitx_notify_hpd(hdev->hpd_state);
 		hdev->hwop.cntlmisc(hdev, MISC_AVMUTE_OP, SET_AVMUTE);
 		/*notify to drm hdmi*/
-		if (hdmitx_device.drm_cb)
-			hdmitx_device.drm_cb(hdmitx_device.drm_data);
+		if (hdmitx_device.drm_hpd_cb.callback)
+			hdmitx_device.drm_hpd_cb.callback(hdmitx_device.drm_hpd_cb.data);
 
 		hdmitx_set_uevent(HDMITX_HPD_EVENT, 0);
 		hdmitx_set_uevent(HDMITX_AUDIO_EVENT, 0);
@@ -5747,8 +5747,8 @@ static void hdmitx_hpd_plugout_handler(struct work_struct *work)
 	hdmitx_notify_hpd(hdev->hpd_state);
 
 	/*notify to drm hdmi*/
-	if (hdmitx_device.drm_cb)
-		hdmitx_device.drm_cb(hdmitx_device.drm_data);
+	if (hdmitx_device.drm_hpd_cb.callback)
+		hdmitx_device.drm_hpd_cb.callback(hdmitx_device.drm_hpd_cb.data);
 
 	hdmitx_set_uevent(HDMITX_HPD_EVENT, 0);
 	hdmitx_set_uevent(HDMITX_AUDIO_EVENT, 0);
@@ -6033,6 +6033,9 @@ void hdmitx_event_notify(unsigned long state, void *arg)
 void hdmitx_hdcp_status(int hdmi_authenticated)
 {
 	hdmitx_set_uevent(HDMITX_HDCP_EVENT, hdmi_authenticated);
+	if (hdmitx_device.drm_hdcp_cb.callback)
+		hdmitx_device.drm_hdcp_cb.callback(hdmitx_device.drm_hdcp_cb.data,
+			hdmi_authenticated);
 }
 
 static void hdmitx_init_parameters(struct hdmitx_info *info)
@@ -6170,8 +6173,10 @@ static void amhdmitx_get_drm_info(void)
 		}
 	} else {
 		hdmitx_device.drm_feature = 0;
-		hdmitx_device.drm_cb = 0;
-		hdmitx_device.drm_data = 0;
+		hdmitx_device.drm_hpd_cb.callback = 0;
+		hdmitx_device.drm_hpd_cb.data = 0;
+		hdmitx_device.drm_hdcp_cb.callback = 0;
+		hdmitx_device.drm_hdcp_cb.data = 0;
 		pr_info("drm_feature skip.");
 	}
 }
@@ -6318,7 +6323,7 @@ static int amhdmitx_get_dt_info(struct platform_device *pdev)
 		ret = of_property_read_u32(pdev->dev.of_node, "hdcp_ctl_lvl",
 					   &hdmitx_device.hdcp_ctl_lvl);
 		if (ret)
-			hdmitx_device.hdcp_ctl_lvl = 0;
+			hdmitx_device.hdcp_ctl_lvl = 2;
 		if (hdmitx_device.hdcp_ctl_lvl > 0)
 			hdmitx_device.systemcontrol_on = true;
 		/* Get drm feature information */
@@ -6956,11 +6961,11 @@ int drm_hdmitx_detect_hpd(void)
 }
 EXPORT_SYMBOL(drm_hdmitx_detect_hpd);
 
-int drm_hdmitx_register_hpd_cb(drm_hpd_cb cb, void *data)
+int drm_hdmitx_register_hpd_cb(struct drm_hdmitx_hpd_cb *hpd_cb)
 {
 	mutex_lock(&setclk_mutex);
-	hdmitx_device.drm_cb = cb;
-	hdmitx_device.drm_data = data;
+	hdmitx_device.drm_hpd_cb.callback = hpd_cb->callback;
+	hdmitx_device.drm_hpd_cb.data = hpd_cb->data;
 	mutex_unlock(&setclk_mutex);
 	return 0;
 }
@@ -7016,6 +7021,16 @@ unsigned char *drm_hdmitx_get_raw_edid(void)
 }
 EXPORT_SYMBOL(drm_hdmitx_get_raw_edid);
 
+int drm_hdmitx_register_hdcp_cb(struct drm_hdmitx_hdcp_cb *hdcp_cb)
+{
+	mutex_lock(&setclk_mutex);
+	hdmitx_device.drm_hdcp_cb.callback = hdcp_cb->callback;
+	hdmitx_device.drm_hdcp_cb.data = hdcp_cb->data;
+	mutex_unlock(&setclk_mutex);
+	return 0;
+}
+EXPORT_SYMBOL(drm_hdmitx_register_hdcp_cb);
+
 /* bit[1]: hdcp22, bit[0]: hdcp14 */
 int drm_hdmitx_get_hdcp_cap(void)
 {
diff --git a/include/linux/amlogic/media/vout/hdmi_tx/hdmi_tx_module.h b/include/linux/amlogic/media/vout/hdmi_tx/hdmi_tx_module.h
index 20fcac8c0f0d..47cc865488fe 100644
--- a/include/linux/amlogic/media/vout/hdmi_tx/hdmi_tx_module.h
+++ b/include/linux/amlogic/media/vout/hdmi_tx/hdmi_tx_module.h
@@ -482,14 +482,15 @@ struct hdmitx_dev {
 	unsigned int vend_id_hit:1;
 	struct vpu_dev_s *hdmitx_vpu_clk_gate_dev;
 
-	/*DRM related*/
-	unsigned int drm_feature;/*force 0 now.*/
-	drm_hpd_cb drm_cb;
-	void *drm_data;
 	bool systemcontrol_on;
 	unsigned char vid_mute_op;
 	unsigned int hdcp_ctl_lvl;
 	spinlock_t edid_spinlock; /* edid hdr/dv cap lock */
+
+	/*DRM related*/
+	unsigned int drm_feature;/*force 0 now.*/
+	struct drm_hdmitx_hpd_cb drm_hpd_cb;
+	struct drm_hdmitx_hdcp_cb drm_hdcp_cb;
 };
 
 #define CMD_DDC_OFFSET          (0x10 << 24)
diff --git a/include/linux/amlogic/media/vout/hdmi_tx/meson_drm_hdmitx.h b/include/linux/amlogic/media/vout/hdmi_tx/meson_drm_hdmitx.h
index 2ca0bfd46d02..afe3782ea418 100644
--- a/include/linux/amlogic/media/vout/hdmi_tx/meson_drm_hdmitx.h
+++ b/include/linux/amlogic/media/vout/hdmi_tx/meson_drm_hdmitx.h
@@ -12,18 +12,28 @@
  */
 
 /*drm hpd*/
-typedef void (*drm_hpd_cb)(void *data);
+struct drm_hdmitx_hpd_cb {
+	void (*callback)(void *data);
+	void *data;
+};
 
-int drm_hdmitx_register_hpd_cb(drm_hpd_cb cb, void *data);
-int drm_hdmitx_detect_hpd(void);
+int drm_hdmitx_register_hpd_cb(struct drm_hdmitx_hpd_cb *hpd_cb);
+
+struct drm_hdmitx_hdcp_cb {
+	void (*callback)(void *data, int auth);
+	void *data;
+};
+
+int drm_hdmitx_register_hdcp_cb(struct drm_hdmitx_hdcp_cb *hdcp_cb);
 
+int drm_hdmitx_detect_hpd(void);
 unsigned char *drm_hdmitx_get_raw_edid(void);
 int drm_hdmitx_get_vic_list(int **vics);
-
 int drm_hdmitx_get_hdcp_cap(void);
 unsigned int drm_get_rx_hdcp_cap(void);
 int drm_hdmitx_hdcp_enable(unsigned int content_type);
 int drm_hdmitx_hdcp_disable(unsigned int content_type);
+
 int drm_get_hdcp_auth_sts(void);
 void drm_hdmitx_hdcp22_init(void);
 void drm_hdmitx_avmute(unsigned char mute);
-- 
2.29.2

