From a805a7a7c8316800092a44c8d504ad59cb929317 Mon Sep 17 00:00:00 2001
From: hang cheng <hang.cheng@amlogic.com>
Date: Wed, 28 Apr 2021 13:30:24 +0800
Subject: [PATCH 7/8] drm: add hdcp auth and optimize hdmitx flow [1/1]

PD#SWPL-48332

Problem:
hdcp auth not run

Solution:
add hdcp auth and optimize hdmitx flow

Verify:
ah212

Change-Id: Iaf7951fd50638c6f3014e6cd52056b0c3d050cf8
Signed-off-by: hang cheng <hang.cheng@amlogic.com>
---
 .../dts/amlogic/s4_s905y4_ap222_linux.dts     |    2 +
 .../dts/amlogic/sc2_s905x4_ah212_linux.dts    |    2 +
 drivers/amlogic/drm/meson_hdcp.c              |  605 ++++------
 drivers/amlogic/drm/meson_hdcp.h              |   26 +-
 drivers/amlogic/drm/meson_hdcp_tee.c          |  176 ---
 drivers/amlogic/drm/meson_hdmi.c              |   77 +-
 drivers/amlogic/drm/meson_hdmi.h              | 1060 +----------------
 .../vout/hdmitx/hdmi_tx_20/hdmi_tx_main.c     |  304 ++++-
 .../vout/hdmitx/hdmi_tx_20/hw/hdmi_tx_hw.c    |   26 +-
 .../media/vout/hdmi_tx/hdmi_tx_module.h       |   17 +-
 .../media/vout/hdmi_tx/meson_drm_hdmitx.h     |   30 +
 11 files changed, 646 insertions(+), 1679 deletions(-)
 delete mode 100644 drivers/amlogic/drm/meson_hdcp_tee.c
 create mode 100644 include/linux/amlogic/media/vout/hdmi_tx/meson_drm_hdmitx.h

diff --git a/arch/arm64/boot/dts/amlogic/s4_s905y4_ap222_linux.dts b/arch/arm64/boot/dts/amlogic/s4_s905y4_ap222_linux.dts
index da91f3ee8e54..56cb92ab2849 100644
--- a/arch/arm64/boot/dts/amlogic/s4_s905y4_ap222_linux.dts
+++ b/arch/arm64/boot/dts/amlogic/s4_s905y4_ap222_linux.dts
@@ -1490,6 +1490,8 @@
 };
 &amhdmitx {
 	status = "okay";
+	/* hdcp ctrl 0: sysctrl, 1: drv, 2: linux app */
+	hdcp_ctl_lvl = <1>;
 };
 
 &drm_amhdmitx {
diff --git a/arch/arm64/boot/dts/amlogic/sc2_s905x4_ah212_linux.dts b/arch/arm64/boot/dts/amlogic/sc2_s905x4_ah212_linux.dts
index 92682b332ef8..09f875b24bcf 100644
--- a/arch/arm64/boot/dts/amlogic/sc2_s905x4_ah212_linux.dts
+++ b/arch/arm64/boot/dts/amlogic/sc2_s905x4_ah212_linux.dts
@@ -1507,6 +1507,8 @@
 
 &amhdmitx {
 	status = "okay";
+	/* hdcp ctrl 0:sysctrl, 1: drv, 2: linux app */
+	hdcp_ctl_lvl = <1>;
 };
 
 /*if you want to use vdin just modify status to "ok"*/
diff --git a/drivers/amlogic/drm/meson_hdcp.c b/drivers/amlogic/drm/meson_hdcp.c
index bfb5b6584830..b20f1235294c 100644
--- a/drivers/amlogic/drm/meson_hdcp.c
+++ b/drivers/amlogic/drm/meson_hdcp.c
@@ -8,7 +8,6 @@
 #include <drm/drm_edid.h>
 #include <drm/drm_crtc_helper.h>
 #include <drm/drm_atomic_helper.h>
-#include <drm/drm_hdcp.h>
 
 #include <linux/component.h>
 #include <linux/irq.h>
@@ -20,391 +19,305 @@
 #include <linux/amlogic/media/vout/vout_notify.h>
 #include <linux/amlogic/media/vout/hdmi_tx/hdmi_tx_module.h>
 #include <linux/arm-smccc.h>
-
+#include <linux/workqueue.h>
+#include "meson_drv.h"
 #include "meson_hdmi.h"
 #include "meson_hdcp.h"
 
-static int hdcp_topo_st = -1;
-static int hdmitx_hdcp_opr(unsigned int val)
+/* ioctl numbers */
+enum {
+	TEE_HDCP_START,
+	TEE_HDCP_END,
+	HDCP_DAEMON_LOAD_END,
+	HDCP_DAEMON_REPORT,
+	HDCP_EXE_VER_SET,
+	HDCP_TX_VER_REPORT,
+	HDCP_DOWNSTR_VER_REPORT,
+	HDCP_EXE_VER_REPORT
+};
+
+#define TEE_HDCP_IOC_START    _IOW('P', TEE_HDCP_START, int)
+#define TEE_HDCP_IOC_END    _IOW('P', TEE_HDCP_END, int)
+
+#define HDCP_DAEMON_IOC_LOAD_END    _IOW('P', HDCP_DAEMON_LOAD_END, int)
+#define HDCP_DAEMON_IOC_REPORT    _IOR('P', HDCP_DAEMON_REPORT, int)
+
+#define HDCP_EXE_VER_IOC_SET    _IOW('P', HDCP_EXE_VER_SET, int)
+#define HDCP_TX_VER_IOC_REPORT    _IOR('P', HDCP_TX_VER_REPORT, int)
+#define HDCP_DOWNSTR_VER_IOC_REPORT    _IOR('P', HDCP_DOWNSTR_VER_REPORT, int)
+#define HDCP_EXE_VER_IOC_REPORT    _IOR('P', HDCP_EXE_VER_REPORT, int)
+
+static unsigned int get_hdcp_downstream_ver(struct am_hdmi_tx *am_hdmi)
 {
-	struct arm_smccc_res res;
+	unsigned int hdcp_downstream_type = drm_get_rx_hdcp_cap();
 
-	if (val == 1) { /* HDCP14_ENABLE */
-		arm_smccc_smc(0x82000010, 0, 0, 0, 0, 0, 0, 0, &res);
-	}
-	if (val == 2) { /* HDCP14_RESULT */
-		arm_smccc_smc(0x82000011, 0, 0, 0, 0, 0, 0, 0, &res);
-		return (unsigned int)((res.a0) & 0xffffffff);
-	}
-	if (val == 0) { /* HDCP14_INIT */
-		arm_smccc_smc(0x82000012, 0, 0, 0, 0, 0, 0, 0, &res);
-	}
-	if (val == 3) { /* HDCP14_EN_ENCRYPT */
-		arm_smccc_smc(0x82000013, 0, 0, 0, 0, 0, 0, 0, &res);
-	}
-	if (val == 4) { /* HDCP14_OFF */
-		arm_smccc_smc(0x82000014, 0, 0, 0, 0, 0, 0, 0, &res);
-	}
-	if (val == 5) {	/* HDCP_MUX_22 */
-		arm_smccc_smc(0x82000015, 0, 0, 0, 0, 0, 0, 0, &res);
-	}
-	if (val == 6) {	/* HDCP_MUX_14 */
-		arm_smccc_smc(0x82000016, 0, 0, 0, 0, 0, 0, 0, &res);
-	}
-	if (val == 7) { /* HDCP22_RESULT */
-		arm_smccc_smc(0x82000017, 0, 0, 0, 0, 0, 0, 0, &res);
-		return (unsigned int)((res.a0) & 0xffffffff);
-	}
-	if (val == 0xa) { /* HDCP14_KEY_LSTORE */
-		arm_smccc_smc(0x8200001a, 0, 0, 0, 0, 0, 0, 0, &res);
-		return (unsigned int)((res.a0) & 0xffffffff);
-	}
-	if (val == 0xb) { /* HDCP22_KEY_LSTORE */
-		arm_smccc_smc(0x8200001b, 0, 0, 0, 0, 0, 0, 0, &res);
-		return (unsigned int)((res.a0) & 0xffffffff);
-	}
-	if (val == 0xc) { /* HDCP22_KEY_SET_DUK */
-		arm_smccc_smc(0x8200001c, 0, 0, 0, 0, 0, 0, 0, &res);
-		return (unsigned int)((res.a0) & 0xffffffff);
-	}
-	if (val == 0xd) { /* HDCP22_SET_TOPO */
-		arm_smccc_smc(0x82000083, hdcp_topo_st, 0, 0, 0, 0, 0, 0, &res);
-	}
-	if (val == 0xe) { /* HDCP22_GET_TOPO */
-		arm_smccc_smc(0x82000084, 0, 0, 0, 0, 0, 0, 0, &res);
-		return (unsigned int)((res.a0) & 0xffffffff);
-	}
-	return -1;
-}
-
-static void get_hdcp_bstatus(void)
-{
-	int ret1 = 0;
-	int ret2 = 0;
+	DRM_INFO("downstream support hdcp14: %d\n",
+		 hdcp_downstream_type & 0x1);
+	DRM_INFO("downstream support hdcp22: %d\n",
+		 (hdcp_downstream_type & 0x2) >> 1);
 
-	hdmitx_set_reg_bits(HDMITX_DWC_A_KSVMEMCTRL, 1, 0, 1);
-	hdmitx_poll_reg(HDMITX_DWC_A_KSVMEMCTRL, (1 << 1), 2 * HZ);
-	ret1 = hdmitx_rd_reg(HDMITX_DWC_HDCP_BSTATUS_0);
-	ret2 = hdmitx_rd_reg(HDMITX_DWC_HDCP_BSTATUS_1);
-	hdmitx_set_reg_bits(HDMITX_DWC_A_KSVMEMCTRL, 0, 0, 1);
-	DRM_INFO("BSTATUS0 = 0x%x   BSTATUS1 = 0x%x\n", ret1, ret2);
+	return hdcp_downstream_type;
 }
 
-static void hdcp14_events_handle(struct timer_list *t)
+static unsigned int get_hdcp_hdmitx_version(struct am_hdmi_tx *am_hdmi)
 {
-	struct am_hdmi_tx *am_hdmi = from_timer(am_hdmi, t, hdcp_timer);
-	unsigned int bcaps_6_rp;
-	static unsigned int st_flag = -1;
-
-	bcaps_6_rp = !!(hdmitx_rd_reg(HDMITX_DWC_A_HDCPOBS3) & (1 << 6));
-	if (st_flag != hdmitx_rd_reg(HDMITX_DWC_A_APIINTSTAT)) {
-		st_flag = hdmitx_rd_reg(HDMITX_DWC_A_APIINTSTAT);
-		DRM_INFO("hdcp14: instat: 0x%x\n", st_flag);
-	}
-	if (st_flag & (1 << 7)) {
-		hdmitx_wr_reg(HDMITX_DWC_A_APIINTCLR, 1 << 7);
-		hdmitx_hdcp_opr(3);
-		get_hdcp_bstatus();
-	}
-
-	if (st_flag & (1 << 1)) {
-		hdmitx_wr_reg(HDMITX_DWC_A_APIINTCLR, (1 << 1));
-		hdmitx_wr_reg(HDMITX_DWC_A_KSVMEMCTRL, 0x1);
-		hdmitx_poll_reg(HDMITX_DWC_A_KSVMEMCTRL, (1 << 1), 2 * HZ);
-		if (hdmitx_rd_reg(HDMITX_DWC_A_KSVMEMCTRL) & (1 << 1)) {
-			;//hdcp_ksv_sha1_calc(hdev); todo
-		} else {
-			DRM_INFO("hdcptx14: KSV List memory access denied\n");
-			return;
-		}
-		hdmitx_wr_reg(HDMITX_DWC_A_KSVMEMCTRL, 0x4);
-	}
+	unsigned int hdcp_tx_type = drm_hdmitx_get_hdcp_cap();
 
-	if (am_hdmi->hdcp_try_times)
-		mod_timer(&am_hdmi->hdcp_timer, jiffies + HZ / 100);
-	else
-		return;
-	am_hdmi->hdcp_try_times--;
+	DRM_INFO("hdmitx support hdcp14: %d\n",
+		 hdcp_tx_type & 0x1);
+	DRM_INFO("hdmitx support hdcp22: %d\n",
+		 (hdcp_tx_type & 0x2) >> 1);
+	return hdcp_tx_type;
 }
 
-static void hdcp14_start_timer(struct am_hdmi_tx *am_hdmi)
+static int am_get_hdcp_exe_type(struct am_hdmi_tx *am_hdmi)
 {
-	static int init_flag;
-
-	if (!init_flag) {
-		init_flag = 1;
-		timer_setup(&am_hdmi->hdcp_timer, hdcp14_events_handle, 0);
-		am_hdmi->hdcp_timer.expires = jiffies + HZ / 100;
-		add_timer(&am_hdmi->hdcp_timer);
-		am_hdmi->hdcp_try_times = 500;
-		return;
+	int type;
+
+	am_hdmi->hdcp_tx_type = get_hdcp_hdmitx_version(am_hdmi);
+	DRM_INFO("%s usr_type: %d, tx_type: %d\n",
+		 __func__, am_hdmi->hdcp_user_type, am_hdmi->hdcp_tx_type);
+	if (am_hdmi->hdcp_user_type == 0)
+		return HDCP_NULL;
+	if (/* !am_hdmi->hdcp_downstream_type && */
+		am_hdmi->hdcp_tx_type)
+		am_hdmi->hdcp_downstream_type =
+			get_hdcp_downstream_ver(am_hdmi);
+	switch (am_hdmi->hdcp_tx_type & 0x3) {
+	case 0x3:
+		if ((am_hdmi->hdcp_downstream_type & 0x2) &&
+			(am_hdmi->hdcp_user_type & 0x2))
+			type = HDCP_MODE22;
+		else if ((am_hdmi->hdcp_downstream_type & 0x1) &&
+			 (am_hdmi->hdcp_user_type & 0x1))
+			type = HDCP_MODE14;
+		else
+			type = HDCP_NULL;
+		break;
+	case 0x2:
+		if ((am_hdmi->hdcp_downstream_type & 0x2) &&
+			(am_hdmi->hdcp_user_type & 0x2))
+			type = HDCP_MODE22;
+		else
+			type = HDCP_NULL;
+		break;
+	case 0x1:
+		if ((am_hdmi->hdcp_downstream_type & 0x1) &&
+			(am_hdmi->hdcp_user_type & 0x1))
+			type = HDCP_MODE14;
+		else
+			type = HDCP_NULL;
+		break;
+	default:
+		type = HDCP_NULL;
+		DRM_INFO("[%s]: TX no hdcp key\n", __func__);
+		break;
 	}
-	am_hdmi->hdcp_try_times = 500;
-	am_hdmi->hdcp_timer.expires = jiffies + HZ / 100;
-	mod_timer(&am_hdmi->hdcp_timer, jiffies + HZ / 100);
+	return type;
 }
 
-static int am_hdcp14_enable(struct am_hdmi_tx *am_hdmi)
-{
-	am_hdmi->hdcp_mode = HDCP_MODE14;
-	hdmitx_ddc_hw_op(DDC_MUX_DDC);
-	hdmitx_hdcp_opr(6);
-	hdmitx_hdcp_opr(1);
-	hdcp14_start_timer(am_hdmi);
-	return 0;
-}
-
-static int am_hdcp14_disable(struct am_hdmi_tx *am_hdmi)
-{
-	hdmitx_hdcp_opr(4);
-	return 0;
-}
-
-static void set_pkf_duk_nonce(void)
+void am_hdcp_disable(struct am_hdmi_tx *am_hdmi)
 {
-	static int nonce_mode = 1; /* 1: use HW nonce   0: use SW nonce */
-
-	/* Configure duk/pkf */
-	hdmitx_hdcp_opr(0xc);
-	if (nonce_mode == 1) {
-		hdmitx_wr_reg(HDMITX_TOP_SKP_CNTL_STAT, 0xf);
-	} else {
-		hdmitx_wr_reg(HDMITX_TOP_SKP_CNTL_STAT, 0xe);
-/* Configure nonce[127:0].
- * MSB must be written the last to assert nonce_vld signal.
- */
-		hdmitx_wr_reg(HDMITX_TOP_NONCE_0,  0x32107654);
-		hdmitx_wr_reg(HDMITX_TOP_NONCE_1,  0xba98fedc);
-		hdmitx_wr_reg(HDMITX_TOP_NONCE_2,  0xcdef89ab);
-		hdmitx_wr_reg(HDMITX_TOP_NONCE_3,  0x45670123);
-		hdmitx_wr_reg(HDMITX_TOP_NONCE_0,  0x76543210);
-		hdmitx_wr_reg(HDMITX_TOP_NONCE_1,  0xfedcba98);
-		hdmitx_wr_reg(HDMITX_TOP_NONCE_2,  0x89abcdef);
-		hdmitx_wr_reg(HDMITX_TOP_NONCE_3,  0x01234567);
+	DRM_INFO("[%s]: %d\n", __func__, am_hdmi->hdcp_execute_type);
+	if (am_hdmi->hdcp_execute_type == HDCP_MODE22) {
+		drm_hdmitx_hdcp_disable(HDCP_MODE22);
+		am_hdmi->hdcp_report = HDCP_TX22_STOP;
+		wake_up(&am_hdmi->hdcp_comm_queue);
+	} else if (am_hdmi->hdcp_execute_type  == HDCP_MODE14) {
+		drm_hdmitx_hdcp_disable(HDCP_MODE14);
 	}
-	usleep_range(9, 11);
+	am_hdmi->hdcp_execute_type = HDCP_NULL;
+	am_hdmi->hdcp_result = 0;
+	am_hdmi->hdcp_en = 0;
 }
 
-static void am_sysfs_hdcp_event(struct drm_device *dev, unsigned int flag)
+int am_hdcp_disconnect(struct am_hdmi_tx *am_hdmi)
 {
-	char *envp1[2] = {  "HDCP22=1", NULL };
-	char *envp0[2] = {  "HDCP22=0", NULL };
-
-	DRM_INFO("generating hdcp22: %d\n  event\n", flag);
-	if (flag)
-		kobject_uevent_env(&dev->primary->kdev->kobj,
-				   KOBJ_CHANGE, envp1);
-	else
-		kobject_uevent_env(&dev->primary->kdev->kobj,
-				   KOBJ_CHANGE, envp0);
-}
-
-static int am_hdcp22_enable(struct am_hdmi_tx *am_hdmi)
-{
-	am_hdmi->hdcp_mode = HDCP_MODE22;
-	hdmitx_ddc_hw_op(DDC_MUX_DDC);
-	hdmitx_set_reg_bits(HDMITX_DWC_MC_CLKDIS, 1, 6, 1);
-	usleep_range(4, 6);
-	hdmitx_set_reg_bits(HDMITX_DWC_HDCP22REG_CTRL, 3, 1, 2);
-	hdmitx_set_reg_bits(HDMITX_TOP_SW_RESET, 1, 5, 1);
-	usleep_range(9, 11);
-	hdmitx_set_reg_bits(HDMITX_TOP_SW_RESET, 0, 5, 1);
-	usleep_range(9, 11);
-	hdmitx_wr_reg(HDMITX_DWC_HDCP22REG_MASK, 0);
-	hdmitx_wr_reg(HDMITX_DWC_HDCP22REG_MUTE, 0);
-	set_pkf_duk_nonce();
-
-	/*uevent to open hdcp_tx22*/
-	am_sysfs_hdcp_event(am_hdmi->connector.dev, 1);
+	/* if (am_hdmi->hdcp_execute_type == HDCP_MODE22) */
+		/* drm_hdmitx_hdcp_disable(HDCP_MODE22); */
+	/* else if (am_hdmi->hdcp_execute_type  == HDCP_MODE14) */
+		/* drm_hdmitx_hdcp_disable(HDCP_MODE14); */
+	am_hdmi->hdcp_report = HDCP_TX22_DISCONNECT;
+	am_hdmi->hdcp_downstream_type = 0;
+	am_hdmi->hdcp_execute_type = HDCP_NULL;
+	am_hdmi->hdcp_result = 0;
+	am_hdmi->hdcp_en = 0;
+	DRM_INFO("[%s]: HDCP_TX22_DISCONNECT\n", __func__);
+	wake_up(&am_hdmi->hdcp_comm_queue);
 	return 0;
 }
 
-static int am_hdcp22_disable(struct am_hdmi_tx *am_hdmi)
-{
-	hdmitx_hdcp_opr(6);
-	/*uevent to close hdcp_tx22*/
-	am_sysfs_hdcp_event(am_hdmi->connector.dev, 0);
-	return 0;
-}
-
-void am_hdcp_disable(struct am_hdmi_tx *am_hdmi)
+void am_hdcp_enable(struct am_hdmi_tx *am_hdmi)
 {
-	if (am_hdmi->hdcp_mode == HDCP_MODE22)
-		am_hdcp22_disable(am_hdmi);
-	else if (am_hdmi->hdcp_mode == HDCP_MODE14)
-		am_hdcp14_disable(am_hdmi);
+	/* hdcp enabled, but may not start auth as key not ready */
+	am_hdmi->hdcp_en = 1;
+	am_hdmi->hdcp_execute_type = am_get_hdcp_exe_type(am_hdmi);
+
+	if (am_hdmi->hdcp_execute_type == HDCP_MODE22) {
+		drm_hdmitx_hdcp_enable(2);
+		am_hdmi->hdcp_report = HDCP_TX22_START;
+		msleep(50);
+		wake_up(&am_hdmi->hdcp_comm_queue);
+	} else if (am_hdmi->hdcp_execute_type == HDCP_MODE14) {
+		drm_hdmitx_hdcp_enable(1);
+	}
+	DRM_INFO("[%s]: report=%d, use_type=%u, execute=%u\n",
+		 __func__, am_hdmi->hdcp_report,
+		 am_hdmi->hdcp_user_type, am_hdmi->hdcp_execute_type);
 }
-EXPORT_SYMBOL(am_hdcp_disable);
 
-static int is_hdcp_hdmirx_supported(struct am_hdmi_tx *am_hdmi)
+static long hdcp_comm_ioctl(struct file *file,
+			    unsigned int cmd,
+			    unsigned long arg)
 {
-	unsigned int hdcp_rx_type = 0x1;
-	int st;
-
-	/*if tx has hdcp22, then check if rx support hdcp22*/
-	if (am_hdmi->hdcp_tx_type & 0x2) {
-		hdmitx_ddc_hw_op(DDC_MUX_DDC);
-		//mutex_lock(&am_hdmi->hdcp_mutex);
-		hdmitx_wr_reg(HDMITX_DWC_I2CM_SLAVE, HDCP_SLAVE);
-		hdmitx_wr_reg(HDMITX_DWC_I2CM_ADDRESS, HDCP2_VERSION);
-		hdmitx_wr_reg(HDMITX_DWC_I2CM_OPERATION, 1 << 0);
-		mdelay(2);
-		if (hdmitx_rd_reg(HDMITX_DWC_IH_I2CM_STAT0) & (1 << 0)) {
-			st = 0;
-			DRM_INFO("ddc rd8b error 0x%02x 0x%02x\n",
-				 HDCP_SLAVE, HDCP2_VERSION);
+	int rtn_val;
+	unsigned int out_size;
+	struct miscdevice *phdcp_comm_device;
+	struct am_hdmi_tx *am_hdmi;
+
+	phdcp_comm_device = file->private_data;
+	am_hdmi = container_of(phdcp_comm_device,
+			       struct am_hdmi_tx,
+			       hdcp_comm_device);
+
+	switch (cmd) {
+	case TEE_HDCP_IOC_START:
+		/* notify by TEE, hdcp key ready, echo 2 > hdcp_mode */
+		rtn_val = 0;
+		am_hdmi->hdcp_tx_type = get_hdcp_hdmitx_version(am_hdmi);
+		if (am_hdmi->hdcp_tx_type & 0x2)
+			drm_hdmitx_hdcp22_init();
+		DRM_INFO("hdcp key load ready\n");
+		break;
+	case TEE_HDCP_IOC_END:
+		rtn_val = 0;
+		break;
+	case HDCP_DAEMON_IOC_LOAD_END:
+		/* hdcp_tx22 load ready (after TEE key ready) */
+		DRM_INFO("IOC_LOAD_END %d, %d\n",
+			 am_hdmi->hdcp_report, am_hdmi->hdcp_poll_report);
+		if (am_hdmi->hdcp_en && am_hdmi->hdcp_execute_type == 0) {
+			am_hdmi->hdcp_execute_type = am_get_hdcp_exe_type(am_hdmi);
+			if (am_hdmi->hdcp_execute_type == HDCP_MODE22) {
+				am_hdmi->hdcp_report = HDCP_TX22_START;
+				drm_hdmitx_hdcp_enable(2);
+			} else if (am_hdmi->hdcp_execute_type == HDCP_MODE14) {
+				drm_hdmitx_hdcp_enable(1);
+			}
+			DRM_INFO("hdcp start before key ready, restart: %d\n",
+				 am_hdmi->hdcp_execute_type);
+		}
+		am_hdmi->hdcp_poll_report = am_hdmi->hdcp_report;
+		rtn_val = 0;
+		break;
+	case HDCP_DAEMON_IOC_REPORT:
+		rtn_val = copy_to_user((void __user *)arg,
+				       (void *)&am_hdmi->hdcp_report,
+				       sizeof(am_hdmi->hdcp_report));
+		if (rtn_val != 0) {
+			out_size = sizeof(am_hdmi->hdcp_report);
+			DRM_INFO("out_size: %u, leftsize: %u\n",
+				 out_size, rtn_val);
+			rtn_val = -1;
+		}
+		break;
+	case HDCP_EXE_VER_IOC_SET:
+		if (arg > 2) {
+			rtn_val = -1;
 		} else {
-			st = 1;
+			am_hdmi->hdcp_user_type = arg;
+			rtn_val = 0;
+			if (hdmitx_hpd_hw_op(HPD_READ_HPD_GPIO)) {
+				am_hdcp_disable(am_hdmi);
+				am_hdcp_enable(am_hdmi);
+			}
+		}
+		break;
+	case HDCP_TX_VER_IOC_REPORT:
+		rtn_val = copy_to_user((void __user *)arg,
+				       (void *)&am_hdmi->hdcp_tx_type,
+				       sizeof(am_hdmi->hdcp_tx_type));
+		if (rtn_val != 0) {
+			out_size = sizeof(am_hdmi->hdcp_tx_type);
+			DRM_INFO("out_size: %u, leftsize: %u\n",
+				 out_size, rtn_val);
+			rtn_val = -1;
+		}
+		break;
+	case HDCP_DOWNSTR_VER_IOC_REPORT:
+		rtn_val = copy_to_user((void __user *)arg,
+				       (void *)&am_hdmi->hdcp_downstream_type,
+				       sizeof(am_hdmi->hdcp_downstream_type));
+		if (rtn_val != 0) {
+			out_size = sizeof(am_hdmi->hdcp_downstream_type);
+			DRM_INFO("out_size: %u, leftsize: %u\n",
+				 out_size, rtn_val);
+			rtn_val = -1;
+		}
+		break;
+	case HDCP_EXE_VER_IOC_REPORT:
+		rtn_val = copy_to_user((void __user *)arg,
+				       (void *)&am_hdmi->hdcp_execute_type,
+				       sizeof(am_hdmi->hdcp_execute_type));
+		if (rtn_val != 0) {
+			out_size = sizeof(am_hdmi->hdcp_execute_type);
+			DRM_INFO("out_size: %u, leftsize: %u\n",
+				 out_size, rtn_val);
+			rtn_val = -1;
 		}
-		hdmitx_wr_reg(HDMITX_DWC_IH_I2CM_STAT0, 0x7);
-		if (hdmitx_rd_reg(HDMITX_DWC_I2CM_DATAI) & (1 << 2))
-			hdcp_rx_type = 0x3;
-		//mutex_unlock(&am_hdmi->hdcp_mutex);
-	} else {
-	/*if tx has hdcp14 or no key, then rx support hdcp14 acquiescently*/
-		hdcp_rx_type = 0x1;
+		break;
+	default:
+		rtn_val = -EPERM;
 	}
-	am_hdmi->hdcp_rx_type = hdcp_rx_type;
-
-	DRM_INFO("hdmirx support hdcp14: %d\n", hdcp_rx_type & 0x1);
-	DRM_INFO("hdmirx support hdcp22: %d\n", (hdcp_rx_type & 0x2) >> 1);
-	return hdcp_rx_type;
+	return rtn_val;
 }
 
-int am_hdcp14_auth(struct am_hdmi_tx *am_hdmi)
+static unsigned int hdcp_comm_poll(struct file *file, poll_table *wait)
 {
-	return hdmitx_hdcp_opr(0x2);
+	struct miscdevice *phdcp_comm_device;
+	struct am_hdmi_tx *am_hdmi;
+	unsigned int mask = 0;
+
+	phdcp_comm_device = file->private_data;
+	am_hdmi = container_of(phdcp_comm_device,
+			       struct am_hdmi_tx,
+			       hdcp_comm_device);
+	DRM_INFO("hdcp_poll %d, %d\n", am_hdmi->hdcp_report, am_hdmi->hdcp_poll_report);
+	poll_wait(file, &am_hdmi->hdcp_comm_queue, wait);
+	if (am_hdmi->hdcp_report != am_hdmi->hdcp_poll_report) {
+		mask = POLLIN | POLLRDNORM;
+		am_hdmi->hdcp_poll_report = am_hdmi->hdcp_report;
+	}
+	return mask;
 }
 
-int am_hdcp22_auth(struct am_hdmi_tx *am_hdmi)
-{
-	return hdmitx_hdcp_opr(0x7);
-}
+static const struct file_operations hdcp_comm_file_operations = {
+	.owner = THIS_MODULE,
+	.unlocked_ioctl = hdcp_comm_ioctl,
+#ifdef CONFIG_COMPAT
+	.compat_ioctl = hdcp_comm_ioctl,
+#endif
+	.poll = hdcp_comm_poll,
+};
 
-/*firstly,check the hdmirx key
- *if hdmirx has hdcp22 key, start hdcp22. check auth status,
- *if failure,then start hdcp14
- *if hdmirx has hdcp14 key, start hdcp 14
- */
-int am_hdcp_work(void *data)
+int hdcp_comm_init(struct am_hdmi_tx *am_hdmi)
 {
-	struct am_hdmi_tx *am_hdmi = data;
-	struct drm_connector *conn = &am_hdmi->connector;
-	int hdcp_fsm = HDCP_READY;
-	int hdcp_feature = 0;
-
-	DRM_INFO("start hdcp work CP=%u\n", conn->state->content_protection);
-	is_hdcp_hdmirx_supported(am_hdmi);
-	if ((am_hdmi->hdcp_tx_type & 0x2) &&
-	    (am_hdmi->hdcp_rx_type & 0x2))
-		hdcp_feature = HDCP22_ENABLE;
-	else
-		hdcp_feature = HDCP14_ENABLE;
-
-	do {
-		/* The state ptr will update pre atomic commit */
-		if (conn->state->content_protection ==
-				DRM_MODE_CONTENT_PROTECTION_UNDESIRED) {
-			if (hdcp_fsm != HDCP_READY) {
-				hdcp_fsm = HDCP_READY;
-				DRM_INFO("HDCP status reset!\n");
-			}
-		} else if (hdcp_fsm == HDCP_READY) {
-			hdcp_fsm = hdcp_feature;
-		}
-		if (hdcp_fsm == HDCP_QUIT)
-			conn->state->content_protection =
-				DRM_MODE_CONTENT_PROTECTION_UNDESIRED;
-
-		switch (hdcp_fsm) {
-		case HDCP_READY:
-			/* wait for content_protection change. */
-			msleep_interruptible(5000);
-			break;
-		case HDCP22_ENABLE:
-			am_hdcp22_enable(am_hdmi);
-			DRM_INFO("hdcp22 work after 10s\n");
-			/*this time is used to debug*/
-			msleep_interruptible(10000);
-			hdcp_fsm = HDCP22_AUTH;
-			break;
-		case HDCP22_AUTH:
-			if (am_hdcp22_auth(am_hdmi))
-				hdcp_fsm = HDCP22_SUCCESS;
-			else
-				hdcp_fsm = HDCP22_FAIL;
-			break;
-		case HDCP22_SUCCESS:
-			conn->state->content_protection =
-				DRM_MODE_CONTENT_PROTECTION_ENABLED;
-			hdcp_fsm = HDCP22_AUTH;
-			msleep_interruptible(200);
-			break;
-		case HDCP22_FAIL:
-			am_hdcp22_disable(am_hdmi);
-			DRM_INFO("hdcp22 failure and start hdcp14\n");
-			hdcp_fsm = HDCP14_ENABLE;
-			msleep_interruptible(2000);
-			break;
-		case HDCP14_ENABLE:
-			if ((am_hdmi->hdcp_tx_type & 0x1) == 0) {
-				hdcp_fsm = HDCP_QUIT;
-				break;
-			}
-			DRM_INFO("hdcp14 work start");
-			am_hdcp14_enable(am_hdmi);
-			msleep_interruptible(500);
-			hdcp_fsm = HDCP14_AUTH;
-			break;
-		case HDCP14_AUTH:
-			if (am_hdcp14_auth(am_hdmi))
-				hdcp_fsm = HDCP14_SUCCESS;
-			else
-				hdcp_fsm = HDCP14_FAIL;
-			break;
-		case HDCP14_SUCCESS:
-			conn->state->content_protection =
-				DRM_MODE_CONTENT_PROTECTION_ENABLED;
-			hdcp_fsm = HDCP14_AUTH;
-			msleep_interruptible(200);
-			break;
-		case HDCP14_FAIL:
-			am_hdcp14_disable(am_hdmi);
-			DRM_INFO("hdcp14 failure\n");
-			hdcp_fsm = HDCP_QUIT;
-			break;
-		case HDCP_QUIT:
-		default:
-			break;
-		}
-	} while (!kthread_should_stop());
-	DRM_INFO("hdcp worker stopped\n");
-	return 0;
+	int ret = 0;
+
+	am_hdmi->hdcp_user_type = 3;
+	am_hdmi->hdcp_report = HDCP_TX22_DISCONNECT;
+	init_waitqueue_head(&am_hdmi->hdcp_comm_queue);
+	am_hdmi->hdcp_comm_device.minor = MISC_DYNAMIC_MINOR;
+	am_hdmi->hdcp_comm_device.name = "tee_comm_hdcp";
+	am_hdmi->hdcp_comm_device.fops = &hdcp_comm_file_operations;
+	ret = misc_register(&am_hdmi->hdcp_comm_device);
+	if (ret < 0)
+		DRM_INFO("%s misc_register fail\n", __func__);
+	return ret;
 }
-EXPORT_SYMBOL(am_hdcp_work);
 
-int am_hdcp_init(struct am_hdmi_tx *am_hdmi)
+void hdcp_comm_exit(struct am_hdmi_tx *am_hdmi)
 {
-	int ret;
-	struct drm_connector *connector = &am_hdmi->connector;
-
-	ret = drm_connector_attach_content_protection_property(connector, 0);
-	if (ret)
-		return ret;
-	return 0;
+	misc_deregister(&am_hdmi->hdcp_comm_device);
 }
-EXPORT_SYMBOL(am_hdcp_init);
 
-/*bit0:hdcp14 bit 1:hdcp22*/
-int is_hdcp_hdmitx_supported(struct am_hdmi_tx *am_hdmi)
-{
-	unsigned int hdcp_tx_type = 0;
-
-	hdcp_tx_type |= hdmitx_hdcp_opr(0xa);
-	hdcp_tx_type |= ((hdmitx_hdcp_opr(0xb)) << 1);
-	am_hdmi->hdcp_tx_type = hdcp_tx_type;
-	DRM_INFO("hdmitx support hdcp14: %d\n", hdcp_tx_type & 0x1);
-	DRM_INFO("hdmitx support hdcp22: %d\n", (hdcp_tx_type & 0x2) >> 1);
-	return hdcp_tx_type;
-}
-EXPORT_SYMBOL(is_hdcp_hdmitx_supported);
diff --git a/drivers/amlogic/drm/meson_hdcp.h b/drivers/amlogic/drm/meson_hdcp.h
index c7c31168e444..d3f17403ea00 100644
--- a/drivers/amlogic/drm/meson_hdcp.h
+++ b/drivers/amlogic/drm/meson_hdcp.h
@@ -6,25 +6,21 @@
 #ifndef __AM_MESON_HDCP_H
 #define __AM_MESON_HDCP_H
 
-#define HDCP_SLAVE     0x3a
-#define HDCP2_VERSION  0x50
 #define HDCP_MODE14    1
 #define HDCP_MODE22    2
+#define HDCP_NULL      0
 
-#define HDCP_QUIT      0
-#define HDCP14_ENABLE  1
-#define HDCP14_AUTH    2
-#define HDCP14_SUCCESS 3
-#define HDCP14_FAIL    4
-#define HDCP22_ENABLE  5
-#define HDCP22_AUTH    6
-#define HDCP22_SUCCESS 7
-#define HDCP22_FAIL    8
-#define HDCP_READY     9
+enum {
+	HDCP_TX22_DISCONNECT,
+	HDCP_TX22_START,
+	HDCP_TX22_STOP
+};
 
-int am_hdcp_init(struct am_hdmi_tx *am_hdmi);
-int is_hdcp_hdmitx_supported(struct am_hdmi_tx *am_hdmi);
-int am_hdcp_work(void *data);
 void am_hdcp_disable(struct am_hdmi_tx *am_hdmi);
+void am_hdcp_enable(struct am_hdmi_tx *am_hdmi);
+int am_hdcp_disconnect(struct am_hdmi_tx *am_hdmi);
+
+int hdcp_comm_init(struct am_hdmi_tx *am_hdmi);
+void hdcp_comm_exit(struct am_hdmi_tx *am_hdmi);
 
 #endif
diff --git a/drivers/amlogic/drm/meson_hdcp_tee.c b/drivers/amlogic/drm/meson_hdcp_tee.c
deleted file mode 100644
index 3ac46d365a19..000000000000
--- a/drivers/amlogic/drm/meson_hdcp_tee.c
+++ /dev/null
@@ -1,176 +0,0 @@
-// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
-/*
- * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
- */
-
-#include <linux/miscdevice.h>
-#include <drm/drmP.h>
-#include <linux/amlogic/media/vout/hdmi_tx/hdmi_common.h>
-#include <linux/amlogic/media/vout/hdmi_tx/hdmi_tx_module.h>
-#include <linux/uaccess.h>
-#include <linux/workqueue.h>
-#include "meson_hdmi.h"
-#include "meson_hdcp.h"
-
-/* ioctl numbers */
-enum {
-	TEE_HDCP_START,
-	TEE_HDCP_END,
-	HDCP_DAEMON_LOAD_END,
-	HDCP_DAEMON_REPORT,
-	HDCP_EXE_VER_SET,
-	HDCP_TX_VER_REPORT,
-	HDCP_DOWNSTR_VER_REPORT,
-	HDCP_EXE_VER_REPORT
-};
-
-#define TEE_HDCP_IOC_START    _IOW('P', TEE_HDCP_START, int)
-#define TEE_HDCP_IOC_END    _IOW('P', TEE_HDCP_END, int)
-
-#define HDCP_DAEMON_IOC_LOAD_END    _IOW('P', HDCP_DAEMON_LOAD_END, int)
-#define HDCP_DAEMON_IOC_REPORT    _IOR('P', HDCP_DAEMON_REPORT, int)
-
-#define HDCP_EXE_VER_IOC_SET    _IOW('P', HDCP_EXE_VER_SET, int)
-#define HDCP_TX_VER_IOC_REPORT    _IOR('P', HDCP_TX_VER_REPORT, int)
-#define HDCP_DOWNSTR_VER_IOC_REPORT    _IOR('P', HDCP_DOWNSTR_VER_REPORT, int)
-#define HDCP_EXE_VER_IOC_REPORT    _IOR('P', HDCP_EXE_VER_REPORT, int)
-
-static long hdcp_comm_ioctl(struct file *file,
-			    unsigned int cmd,
-			    unsigned long arg)
-{
-	int rtn_val;
-	unsigned int out_size;
-	struct miscdevice *phdcp_comm_device;
-	struct am_hdmi_tx *am_hdmi;
-
-	phdcp_comm_device = file->private_data;
-	am_hdmi = container_of(phdcp_comm_device,
-			       struct am_hdmi_tx,
-			       hdcp_comm_device);
-
-	switch (cmd) {
-	case TEE_HDCP_IOC_START:
-		rtn_val = 0;
-		get_hdcp_hdmitx_version(am_hdmi);
-		if (am_hdmi->hdcp_tx_type & 0x2)
-			am_hdcp22_init(am_hdmi);
-		break;
-	case TEE_HDCP_IOC_END:
-		rtn_val = 0;
-		break;
-	case HDCP_DAEMON_IOC_LOAD_END:
-		am_hdmi->hdcp_poll_report = am_hdmi->hdcp_report;
-		rtn_val = 0;
-		break;
-	case HDCP_DAEMON_IOC_REPORT:
-		rtn_val = copy_to_user((void __user *)arg,
-				       (void *)&am_hdmi->hdcp_report,
-				       sizeof(am_hdmi->hdcp_report));
-		if (rtn_val != 0) {
-			out_size = sizeof(am_hdmi->hdcp_report);
-			DRM_INFO("out_size: %u, leftsize: %u\n",
-				 out_size, rtn_val);
-			rtn_val = -1;
-		}
-		break;
-	case HDCP_EXE_VER_IOC_SET:
-		if (arg > 2) {
-			rtn_val = -1;
-		} else {
-			am_hdmi->hdcp_user_type = arg;
-			rtn_val = 0;
-			if (hdmitx_hpd_hw_op(HPD_READ_HPD_GPIO)) {
-				cancel_delayed_work(&am_hdmi->hdcp_prd_proc);
-				flush_workqueue(am_hdmi->hdcp_wq);
-				am_hdcp_disable(am_hdmi);
-				queue_delayed_work(am_hdmi->hdcp_wq,
-					&am_hdmi->hdcp_prd_proc, 0);
-			}
-		}
-		break;
-	case HDCP_TX_VER_IOC_REPORT:
-		rtn_val = copy_to_user((void __user *)arg,
-				       (void *)&am_hdmi->hdcp_tx_type,
-				       sizeof(am_hdmi->hdcp_tx_type));
-		if (rtn_val != 0) {
-			out_size = sizeof(am_hdmi->hdcp_tx_type);
-			DRM_INFO("out_size: %u, leftsize: %u\n",
-				 out_size, rtn_val);
-			rtn_val = -1;
-		}
-		break;
-	case HDCP_DOWNSTR_VER_IOC_REPORT:
-		rtn_val = copy_to_user((void __user *)arg,
-				       (void *)&am_hdmi->hdcp_downstream_type,
-				       sizeof(am_hdmi->hdcp_downstream_type));
-		if (rtn_val != 0) {
-			out_size = sizeof(am_hdmi->hdcp_downstream_type);
-			DRM_INFO("out_size: %u, leftsize: %u\n",
-				 out_size, rtn_val);
-			rtn_val = -1;
-		}
-		break;
-	case HDCP_EXE_VER_IOC_REPORT:
-		rtn_val = copy_to_user((void __user *)arg,
-				       (void *)&am_hdmi->hdcp_execute_type,
-				       sizeof(am_hdmi->hdcp_execute_type));
-		if (rtn_val != 0) {
-			out_size = sizeof(am_hdmi->hdcp_execute_type);
-			DRM_INFO("out_size: %u, leftsize: %u\n",
-				 out_size, rtn_val);
-			rtn_val = -1;
-		}
-		break;
-	default:
-		rtn_val = -EPERM;
-	}
-	return rtn_val;
-}
-
-static unsigned int hdcp_comm_poll(struct file *file, poll_table *wait)
-{
-	struct miscdevice *phdcp_comm_device;
-	struct am_hdmi_tx *am_hdmi;
-	unsigned int mask = 0;
-
-	phdcp_comm_device = file->private_data;
-	am_hdmi = container_of(phdcp_comm_device,
-			       struct am_hdmi_tx,
-			       hdcp_comm_device);
-	poll_wait(file, &am_hdmi->hdcp_comm_queue, wait);
-	if (am_hdmi->hdcp_report != am_hdmi->hdcp_poll_report) {
-		mask = POLLIN | POLLRDNORM;
-		am_hdmi->hdcp_poll_report = am_hdmi->hdcp_report;
-	}
-	return mask;
-}
-
-static const struct file_operations hdcp_comm_file_operations = {
-	.unlocked_ioctl = hdcp_comm_ioctl,
-#ifdef CONFIG_COMPAT
-	.compat_ioctl = hdcp_comm_ioctl,
-#endif
-	.poll = hdcp_comm_poll,
-	.owner = THIS_MODULE,
-};
-
-int hdcp_comm_init(struct am_hdmi_tx *am_hdmi)
-{
-	am_hdmi->hdcp_user_type = 3;
-	init_waitqueue_head(&am_hdmi->hdcp_comm_queue);
-	am_hdmi->hdcp_wq = alloc_workqueue(DEVICE_NAME,
-		WQ_HIGHPRI | WQ_CPU_INTENSIVE, 0);
-	INIT_DELAYED_WORK(&am_hdmi->hdcp_prd_proc,
-			  am_hdcp_enable);
-	am_hdmi->hdcp_comm_device.minor = MISC_DYNAMIC_MINOR;
-	am_hdmi->hdcp_comm_device.name = "tee_comm_hdcp";
-	am_hdmi->hdcp_comm_device.fops = &hdcp_comm_file_operations;
-	return misc_register(&am_hdmi->hdcp_comm_device);
-}
-
-void hdcp_comm_exit(struct am_hdmi_tx *am_hdmi)
-{
-	misc_deregister(&am_hdmi->hdcp_comm_device);
-}
-
diff --git a/drivers/amlogic/drm/meson_hdmi.c b/drivers/amlogic/drm/meson_hdmi.c
index 9de024b866d3..4777e81044e2 100644
--- a/drivers/amlogic/drm/meson_hdmi.c
+++ b/drivers/amlogic/drm/meson_hdmi.c
@@ -25,6 +25,8 @@
 #include <linux/amlogic/media/vout/vout_notify.h>
 #include <linux/amlogic/media/vout/hdmi_tx/hdmi_tx_module.h>
 #include <linux/amlogic/media/vout/hdmi_tx/hdmi_common.h>
+#include <linux/amlogic/media/vout/hdmi_tx/meson_drm_hdmitx.h>
+#include <linux/miscdevice.h>
 
 #include "meson_hdmi.h"
 #include "meson_hdcp.h"
@@ -32,9 +34,10 @@
 #include "meson_crtc.h"
 
 #define DEVICE_NAME "amhdmitx"
-struct am_hdmi_tx am_hdmi_info;
+static struct am_hdmi_tx am_hdmi_info;
+
 /*for hw limitiation, limit to 1080p/720p for recovery ui.*/
-bool hdmitx_set_smaller_pref = true;
+static bool hdmitx_set_smaller_pref = true;
 
 /*TODO:will remove later.*/
 static struct drm_display_mode dummy_mode = {
@@ -311,17 +314,19 @@ static const struct drm_connector_funcs am_hdmi_connector_funcs = {
 	.atomic_destroy_state	= am_hdmitx_atomic_destroy_state,
 };
 
-void am_hdmi_encoder_atomic_mode_set(struct drm_encoder *encoder,
-	struct drm_crtc_state *crtc_state,
-	struct drm_connector_state *conn_state)
+void am_hdmi_encoder_mode_set(struct drm_encoder *encoder,
+	struct drm_display_mode *mode,
+	struct drm_display_mode *adjusted_mode)
 {
 }
 
-void am_hdmi_encoder_atomic_enable(struct drm_encoder *encoder,
-	struct drm_atomic_state *state)
+void am_hdmi_encoder_enable(struct drm_encoder *encoder)
 {
 	enum vmode_e vmode = get_current_vmode();
 	struct am_meson_crtc_state *meson_crtc_state = to_am_meson_crtc_state(encoder->crtc->state);
+	struct hdmitx_dev *hdmitx_dev = get_hdmitx_device();
+
+	am_hdmi_info.hdcp_ctl_lvl = hdmitx_dev->hdcp_ctl_lvl;
 
 	if (vmode == VMODE_HDMI) {
 		DRM_INFO("enable\n");
@@ -332,17 +337,37 @@ void am_hdmi_encoder_atomic_enable(struct drm_encoder *encoder,
 
 	if (meson_crtc_state->uboot_mode_init == 1)
 		vmode |= VMODE_INIT_BIT_MASK;
-
+	if (am_hdmi_info.hdcp_ctl_lvl == 1)
+		am_hdcp_disable(&am_hdmi_info);
 	set_vout_mode_pre_process(vmode);
 	set_vout_vmode(vmode);
 	set_vout_mode_post_process(vmode);
 	/* msleep(1000); */
+	if (am_hdmi_info.hdcp_ctl_lvl == 1)
+		am_hdcp_enable(&am_hdmi_info);
+}
+
+void am_hdmi_encoder_disable(struct drm_encoder *encoder)
+{
+	struct am_hdmi_tx *am_hdmi = encoder_to_am_hdmi(encoder);
+	struct drm_connector_state *state = am_hdmi->connector.state;
+
+	state->content_protection = DRM_MODE_CONTENT_PROTECTION_UNDESIRED;
 }
 
+static int am_hdmi_encoder_atomic_check(struct drm_encoder *encoder,
+					struct drm_crtc_state *crtc_state,
+				struct drm_connector_state *conn_state)
+{
+	return 0;
+}
 
-static const struct drm_encoder_helper_funcs am_hdmi_encoder_helper_funcs = {
-	.atomic_mode_set = am_hdmi_encoder_atomic_mode_set,
-	.atomic_enable = am_hdmi_encoder_atomic_enable,
+static const struct drm_encoder_helper_funcs
+	am_hdmi_encoder_helper_funcs = {
+	.mode_set	= am_hdmi_encoder_mode_set,
+	.enable		= am_hdmi_encoder_enable,
+	.disable	= am_hdmi_encoder_disable,
+	.atomic_check	= am_hdmi_encoder_atomic_check,
 };
 
 static const struct drm_encoder_funcs am_hdmi_encoder_funcs = {
@@ -380,6 +405,10 @@ static void am_meson_hdmi_hpd_cb(void *data)
 	struct am_hdmi_tx *am_hdmi = (struct am_hdmi_tx *)data;
 
 	DRM_INFO("drm hdmitx hpd notify\n");
+	if (drm_hdmitx_detect_hpd() == 0 &&
+		am_hdmi->hdcp_ctl_lvl > 0)
+		am_hdcp_disconnect(am_hdmi);
+
 	drm_helper_hpd_irq_event(am_hdmi->connector.dev);
 }
 
@@ -395,7 +424,6 @@ static int am_meson_hdmi_bind(struct device *dev,
 
 	DRM_INFO("[%s] in\n", __func__);
 	am_hdmi = &am_hdmi_info;
-	memset(am_hdmi, 0, sizeof(*am_hdmi));
 
 	DRM_INFO("drm hdmitx init and version:%s\n", DRM_HDMITX_VER);
 	am_hdmi->priv = priv;
@@ -413,6 +441,8 @@ static int am_meson_hdmi_bind(struct device *dev,
 		dev_err(priv->dev, "Failed to init hdmi tx connector\n");
 		return ret;
 	}
+	am_meson_hdmi_connector_init_property(drm, am_hdmi);
+
 	connector->interlace_allowed = 1;
 
 	/* Encoder */
@@ -428,9 +458,8 @@ static int am_meson_hdmi_bind(struct device *dev,
 
 	/*hpd irq moved to amhdmitx, registe call back */
 	drm_hdmitx_register_hpd_cb(am_meson_hdmi_hpd_cb, (void *)am_hdmi);
-
-	/*TODO: amlogic private prop*/
-	am_meson_hdmi_connector_init_property(drm, am_hdmi);
+	/*hdcp prop*/
+	drm_connector_attach_content_protection_property(connector, true);
 
 	DRM_INFO("[%s] out\n", __func__);
 	return 0;
@@ -448,14 +477,32 @@ static const struct component_ops am_meson_hdmi_ops = {
 	.unbind	= am_meson_hdmi_unbind,
 };
 
+void am_hdmitx_set_hdcp_mode(unsigned int user_type)
+{
+	am_hdmi_info.hdcp_user_type = user_type;
+}
+
 static int am_meson_hdmi_probe(struct platform_device *pdev)
 {
+	struct hdmitx_dev *hdmitx_dev;
+
 	DRM_INFO("[%s] in\n", __func__);
+	memset(&am_hdmi_info, 0, sizeof(am_hdmi_info));
+	hdcp_comm_init(&am_hdmi_info);
+	hdmitx_dev = get_hdmitx_device();
+	/* hdcp auth control owner:
+	 * 0: by android sysctrl
+	 * 1: by drm driver
+	 * 2: by linux app
+	 */
+	am_hdmi_info.hdcp_ctl_lvl = hdmitx_dev->hdcp_ctl_lvl;
+	hdmitx_dev->hwop.am_hdmitx_set_hdcp_mode = am_hdmitx_set_hdcp_mode;
 	return component_add(&pdev->dev, &am_meson_hdmi_ops);
 }
 
 static int am_meson_hdmi_remove(struct platform_device *pdev)
 {
+	hdcp_comm_exit(&am_hdmi_info);
 	component_del(&pdev->dev, &am_meson_hdmi_ops);
 	return 0;
 }
diff --git a/drivers/amlogic/drm/meson_hdmi.h b/drivers/amlogic/drm/meson_hdmi.h
index be8b5b361f82..00afd7442389 100644
--- a/drivers/amlogic/drm/meson_hdmi.h
+++ b/drivers/amlogic/drm/meson_hdmi.h
@@ -7,9 +7,12 @@
 #define __AM_MESON_HDMI_H
 
 #include "meson_drv.h"
+#include <drm/drm_connector.h>
+#include <drm/drm_encoder.h>
+
 #define DDC_SEGMENT_ADDR   0x30
 #define VIC_MAX_NUM        512
-#define DRM_HDMITX_VER     "20180705"
+#define DRM_HDMITX_VER     "20210428"
 //Not sure the default value
 #define MESON_DEFAULT_COLOR_DEPTH COLORDEPTH_24B
 #define MESON_DEFAULT_COLOR_SPACE HDMI_COLORSPACE_RGB
@@ -31,8 +34,8 @@ struct am_hdmi_data {
 
 struct am_hdmi_tx {
 	struct device *dev;
-	struct drm_encoder	encoder;
-	struct drm_connector	connector;
+	struct drm_encoder encoder;
+	struct drm_connector connector;
 	struct meson_drm *priv;
 	int irq;
 	unsigned int input_color_format;
@@ -43,21 +46,21 @@ struct am_hdmi_tx {
 	struct drm_property *color_space_property;
 	struct drm_display_mode previous_mode;
 	struct am_hdmi_data hdmi_info;
-	struct workqueue_struct *hdmi_wq;
-	const char *hpd_pin;
+
 	unsigned int hpd_flag;/*0:none   1:up    2:down*/
-	struct mutex hdcp_mutex;
-	unsigned int hdcp_feature;
 	unsigned int hdcp_tx_type;/*bit0:hdcp14 bit 1:hdcp22*/
-	unsigned int hdcp_rx_type;/*bit0:hdcp14 bit 1:hdcp22*/
-	struct timer_list hdcp_timer;
-	unsigned int hdcp_mode;
-	unsigned int hdcp_state;
-	unsigned int hdcp_stop_flag;/*turn off hdcp state machine*/
-	unsigned int hdcp_try_times;
-	struct task_struct *hdcp_work;
+	unsigned int hdcp_downstream_type;/*bit0:hdcp14 bit 1:hdcp22*/
+	unsigned int hdcp_user_type;/*0: null hdcp 1: hdcp14 2: hdcp22*/
+	unsigned int hdcp_execute_type;/*0: null hdcp 1: hdcp14 2: hdcp22*/
 
+	struct miscdevice hdcp_comm_device;
+	wait_queue_head_t hdcp_comm_queue;
 	struct drm_property *update_attr_prop;
+	int hdcp_result;
+	int hdcp_report;
+	int hdcp_poll_report;
+	unsigned int hdcp_en;
+	unsigned int hdcp_ctl_lvl;
 };
 
 struct am_hdmitx_connector_state {
@@ -68,1033 +71,4 @@ struct am_hdmitx_connector_state {
 #define to_am_hdmitx_connector_state(x)	container_of(x, struct am_hdmitx_connector_state, base)
 #define connector_to_am_hdmi(x)	container_of(x, struct am_hdmi_tx, connector)
 #define encoder_to_am_hdmi(x)	container_of(x, struct am_hdmi_tx, encoder)
-
-#define HDMITX_REG_IDX		6
-#define HDMITX_SEC_REG_IDX	7
-#define BASE_REG_OFFSET		24
-
-#define HDMITX_SEC_REG_ADDR(reg) \
-	((HDMITX_SEC_REG_IDX << BASE_REG_OFFSET) + ((reg) << 2))
-#define HDMITX_REG_ADDR(reg) \
-	((HDMITX_REG_IDX << BASE_REG_OFFSET) + ((reg) << 2))
-
-/* TOP-level wrapper registers addresses
- * bit24: 1 means secure access
- * bit28: 1 means DWC, 0 means TOP
- */
-#define SEC_OFFSET           (0x1UL << 24)
-#define TOP_OFFSET_MASK      (0x0UL << 24)
-#define TOP_SEC_OFFSET_MASK  ((TOP_OFFSET_MASK) | (SEC_OFFSET))
-#define DWC_OFFSET_MASK      (0x10UL << 24)
-#define DWC_SEC_OFFSET_MASK  ((DWC_OFFSET_MASK) | (SEC_OFFSET))
-
-/* Bit 7 RW Reserved. Default 1.
- * Bit 6 RW Reserved. Default 1.
- * Bit 5 RW Reserved. Default 1.
- * Bit 4 RW sw_reset_phyif: PHY interface. 1=Apply reset; 0=Release from reset.
- *     Default 1.
- * Bit 3 RW sw_reset_intr:  interrupt module. 1=Apply reset;
- *     0=Release from reset. Default 1.
- * Bit 2 RW sw_reset_mem:   KSV/REVOC mem. 1=Apply reset; 0=Release from reset.
- *     Default 1.
- * Bit 1 RW sw_reset_rnd:   random number interface to HDCP. 1=Apply reset;
- *     0=Release from reset. Default 1.
- * Bit 0 RW sw_reset_core: connects to IP's ~irstz. 1=Apply reset;
- *     0=Release from reset. Default 1.
- */
-#define HDMITX_TOP_SW_RESET                     (TOP_OFFSET_MASK + 0x000)
-
-/* Bit 12 RW i2s_ws_inv:1=Invert i2s_ws; 0=No invert. Default 0. */
-/* Bit 11 RW i2s_clk_inv: 1=Invert i2s_clk; 0=No invert. Default 0. */
-/* Bit 10 RW spdif_clk_inv: 1=Invert spdif_clk; 0=No invert. Default 0. */
-/* Bit 9 RW tmds_clk_inv: 1=Invert tmds_clk; 0=No invert. Default 0. */
-/* Bit 8 RW pixel_clk_inv: 1=Invert pixel_clk; 0=No invert. Default 0. */
-/* Bit 4 RW cec_clk_en: 1=enable cec_clk; 0=disable. Default 0. */
-/* Bit 3 RW i2s_clk_en: 1=enable i2s_clk; 0=disable. Default 0. */
-/* Bit 2 RW spdif_clk_en: 1=enable spdif_clk; 0=disable. Default 0. */
-/* Bit 1 RW tmds_clk_en: 1=enable tmds_clk;  0=disable. Default 0. */
-/* Bit 0 RW pixel_clk_en: 1=enable pixel_clk; 0=disable. Default 0. */
-#define HDMITX_TOP_CLK_CNTL                     (TOP_OFFSET_MASK + 0x001)
-
-/* Bit 11: 0 RW hpd_valid_width: filter out width <= M*1024.    Default 0. */
-/* Bit 15:12 RW hpd_glitch_width: filter out glitch <= N.       Default 0. */
-#define HDMITX_TOP_HPD_FILTER                   (TOP_OFFSET_MASK + 0x002)
-
-/* intr_maskn: MASK_N, one bit per interrupt source.
- *     1=Enable interrupt source; 0=Disable interrupt source. Default 0.
- * [  4] hdcp22_rndnum_err
- * [  3] nonce_rfrsh_rise
- * [  2] hpd_fall_intr
- * [  1] hpd_rise_intr
- * [  0] core_intr
- */
-#define HDMITX_TOP_INTR_MASKN                   (TOP_OFFSET_MASK + 0x003)
-
-/* Bit 30: 0 RW intr_stat: For each bit, write 1 to manually set the interrupt
- *     bit, read back the interrupt status.
- * Bit    31 R  IP interrupt status
- * Bit     2 RW hpd_fall
- * Bit     1 RW hpd_rise
- * Bit     0 RW IP interrupt
- */
-#define HDMITX_TOP_INTR_STAT                    (TOP_OFFSET_MASK + 0x004)
-
-/* [4]	  hdcp22_rndnum_err */
-/* [3]	  nonce_rfrsh_rise */
-/* [2]	  hpd_fall */
-/* [1]	  hpd_rise */
-/* [0]	  core_intr_rise */
-#define HDMITX_TOP_INTR_STAT_CLR                (TOP_OFFSET_MASK + 0x005)
-
-/* Bit 14:12 RW tmds_sel: 3'b000=Output zero; 3'b001=Output normal TMDS data;
- *     3'b010=Output PRBS data; 3'b100=Output shift pattern.         Default 0.
- * Bit 11: 9 RW shift_pttn_repeat: 0=New pattern every clk cycle; 1=New pattern
- *     every 2 clk cycles; ...; 7=New pattern every 8 clk cycles.  Default 0.
- * Bit 8 RW shift_pttn_en: 1= Eanble shift pattern generator; 0=Disable.
- *     Default 0.
- * Bit 4: 3 RW prbs_pttn_mode: 0=PRBS11; 1=PRBS15; 2=PRBS7; 3=PRBS31. Default 0.
- * Bit 2: 1 RW prbs_pttn_width: 0=idle; 1=output 8-bit pattern;
- *     2=Output 1-bit pattern; 3=output 10-bit pattern. Default 0.
- * Bit 0 RW prbs_pttn_en: 1=Enable PRBS generator; 0=Disable. Default 0.
- */
-#define HDMITX_TOP_BIST_CNTL                    (TOP_OFFSET_MASK + 0x006)
-
-/* Bit 29:20 RW shift_pttn_data[59:50]. Default 0. */
-/* Bit 19:10 RW shift_pttn_data[69:60]. Default 0. */
-/* Bit  9: 0 RW shift_pttn_data[79:70]. Default 0. */
-#define HDMITX_TOP_SHIFT_PTTN_012               (TOP_OFFSET_MASK + 0x007)
-
-/* Bit 29:20 RW shift_pttn_data[29:20]. Default 0. */
-/* Bit 19:10 RW shift_pttn_data[39:30]. Default 0. */
-/* Bit  9: 0 RW shift_pttn_data[49:40]. Default 0. */
-#define HDMITX_TOP_SHIFT_PTTN_345               (TOP_OFFSET_MASK + 0x008)
-
-/* Bit 19:10 RW shift_pttn_data[ 9: 0]. Default 0. */
-/* Bit  9: 0 RW shift_pttn_data[19:10]. Default 0. */
-#define HDMITX_TOP_SHIFT_PTTN_67                (TOP_OFFSET_MASK + 0x009)
-
-/* Bit 25:16 RW tmds_clk_pttn[19:10]. Default 0. */
-/* Bit  9: 0 RW tmds_clk_pttn[ 9: 0]. Default 0. */
-#define HDMITX_TOP_TMDS_CLK_PTTN_01             (TOP_OFFSET_MASK + 0x00A)
-
-/* Bit 25:16 RW tmds_clk_pttn[39:30]. Default 0. */
-/* Bit  9: 0 RW tmds_clk_pttn[29:20]. Default 0. */
-#define HDMITX_TOP_TMDS_CLK_PTTN_23             (TOP_OFFSET_MASK + 0x00B)
-
-/* Bit 1 RW shift_tmds_clk_pttn:1=Enable shifting clk pattern,
- * used when TMDS CLK rate = TMDS character rate /4.    Default 0.
- * Bit 0 R  Reserved. Default 0.
- */
-/* [	1] shift_tmds_clk_pttn */
-/* [	0] load_tmds_clk_pttn */
-#define HDMITX_TOP_TMDS_CLK_PTTN_CNTL           (TOP_OFFSET_MASK + 0x00C)
-
-/* Bit 0 RW revocmem_wr_fail: Read back 1 to indicate Host write REVOC MEM
- * failure, write 1 to clear the failure flag.  Default 0.
- */
-#define HDMITX_TOP_REVOCMEM_STAT                (TOP_OFFSET_MASK + 0x00D)
-
-/* Bit     0 R  filtered HPD status. */
-#define HDMITX_TOP_STAT0                        (TOP_OFFSET_MASK + 0x00E)
-#define HDMITX_TOP_SKP_CNTL_STAT                (TOP_SEC_OFFSET_MASK + 0x010)
-#define HDMITX_TOP_NONCE_0                      (TOP_SEC_OFFSET_MASK + 0x011)
-#define HDMITX_TOP_NONCE_1                      (TOP_SEC_OFFSET_MASK + 0x012)
-#define HDMITX_TOP_NONCE_2                      (TOP_SEC_OFFSET_MASK + 0x013)
-#define HDMITX_TOP_NONCE_3                      (TOP_SEC_OFFSET_MASK + 0x014)
-#define HDMITX_TOP_PKF_0                        (TOP_SEC_OFFSET_MASK + 0x015)
-#define HDMITX_TOP_PKF_1                        (TOP_SEC_OFFSET_MASK + 0x016)
-#define HDMITX_TOP_PKF_2                        (TOP_SEC_OFFSET_MASK + 0x017)
-#define HDMITX_TOP_PKF_3                        (TOP_SEC_OFFSET_MASK + 0x018)
-#define HDMITX_TOP_DUK_0                        (TOP_SEC_OFFSET_MASK + 0x019)
-#define HDMITX_TOP_DUK_1                        (TOP_SEC_OFFSET_MASK + 0x01A)
-#define HDMITX_TOP_DUK_2                        (TOP_SEC_OFFSET_MASK + 0x01B)
-#define HDMITX_TOP_DUK_3                        (TOP_SEC_OFFSET_MASK + 0x01C)
-/* [26:24] infilter_ddc_intern_clk_divide */
-/* [23:16] infilter_ddc_sample_clk_divide */
-/* [10: 8] infilter_cec_intern_clk_divide */
-/* [ 7: 0] infilter_cec_sample_clk_divide */
-#define HDMITX_TOP_INFILTER                     (TOP_OFFSET_MASK + 0x01D)
-#define HDMITX_TOP_NSEC_SCRATCH                 (TOP_OFFSET_MASK + 0x01E)
-#define HDMITX_TOP_SEC_SCRATCH                  (TOP_SEC_OFFSET_MASK + 0x01F)
-
-#define HDMITX_TOP_DONT_TOUCH0                  (TOP_OFFSET_MASK + 0x0FE)
-#define HDMITX_TOP_DONT_TOUCH1                  (TOP_OFFSET_MASK + 0x0FF)
-
-/* DWC_HDMI_TX Controller registers addresses */
-
-/* Identification Registers */
-#define HDMITX_DWC_DESIGN_ID                    (DWC_OFFSET_MASK + 0x0000)
-#define HDMITX_DWC_REVISION_ID                  (DWC_OFFSET_MASK + 0x0001)
-#define HDMITX_DWC_PRODUCT_ID0                  (DWC_OFFSET_MASK + 0x0002)
-#define HDMITX_DWC_PRODUCT_ID1                  (DWC_OFFSET_MASK + 0x0003)
-#define HDMITX_DWC_CONFIG0_ID                   (DWC_OFFSET_MASK + 0x0004)
-#define HDMITX_DWC_CONFIG1_ID                   (DWC_OFFSET_MASK + 0x0005)
-#define HDMITX_DWC_CONFIG2_ID                   (DWC_OFFSET_MASK + 0x0006)
-#define HDMITX_DWC_CONFIG3_ID                   (DWC_OFFSET_MASK + 0x0007)
-
-/* Interrupt Registers */
-#define HDMITX_DWC_IH_FC_STAT0                  (DWC_OFFSET_MASK + 0x0100)
-#define HDMITX_DWC_IH_FC_STAT1                  (DWC_OFFSET_MASK + 0x0101)
-#define HDMITX_DWC_IH_FC_STAT2                  (DWC_OFFSET_MASK + 0x0102)
-#define HDMITX_DWC_IH_AS_STAT0                  (DWC_OFFSET_MASK + 0x0103)
-#define HDMITX_DWC_IH_PHY_STAT0                 (DWC_OFFSET_MASK + 0x0104)
-#define HDMITX_DWC_IH_I2CM_STAT0                (DWC_OFFSET_MASK + 0x0105)
-#define HDMITX_DWC_IH_CEC_STAT0                 (DWC_OFFSET_MASK + 0x0106)
-#define HDMITX_DWC_IH_VP_STAT0                  (DWC_OFFSET_MASK + 0x0107)
-#define HDMITX_DWC_IH_I2CMPHY_STAT0             (DWC_OFFSET_MASK + 0x0108)
-#define HDMITX_DWC_IH_DECODE                    (DWC_OFFSET_MASK + 0x0170)
-/* [  7] mute_AUDI */
-/* [  6] mute_ACP */
-/* [  5] mute_HBR */
-/* [  4] mute_MAS */
-/* [  3] mute_NVBI */
-/* [  2] mute_AUDS */
-/* [  1] mute_ACR */
-/* [  0] mute_NULL */
-#define HDMITX_DWC_IH_MUTE_FC_STAT0             (DWC_OFFSET_MASK + 0x0180)
-/* [  7] mute_GMD */
-/* [  6] mute_ISRC1 */
-/* [  5] mute_ISRC2 */
-/* [  4] mute_VSD */
-/* [  3] mute_SPD */
-/* [  2] mute_AMP */
-/* [  1] mute_AVI */
-/* [  0] mute_GCP */
-#define HDMITX_DWC_IH_MUTE_FC_STAT1             (DWC_OFFSET_MASK + 0x0181)
-/* [  1] mute_LowPriority_fifo_full */
-/* [  0] mute_HighPriority_fifo_full */
-#define HDMITX_DWC_IH_MUTE_FC_STAT2             (DWC_OFFSET_MASK + 0x0182)
-/* [  4] mute_aud_fifo_underrun */
-/* [  3] mute_aud_fifo_overrun */
-/* [  2] mute_aud_fifo_empty_thr. oififoemptythr tied to 0. */
-/* [  1] mute_aud_fifo_empty */
-/* [  0] mute_aud_fifo_full */
-#define HDMITX_DWC_IH_MUTE_AS_STAT0             (DWC_OFFSET_MASK + 0x0183)
-#define HDMITX_DWC_IH_MUTE_PHY_STAT0            (DWC_OFFSET_MASK + 0x0184)
-/* [  2] mute_scdc_readreq */
-/* [  1] mute_edid_i2c_master_done */
-/* [  0] mute_edid_i2c_master_error */
-#define HDMITX_DWC_IH_MUTE_I2CM_STAT0           (DWC_OFFSET_MASK + 0x0185)
-/* [  6] cec_wakeup */
-/* [  5] cec_error_follower */
-/* [  4] cec_error_initiator */
-/* [  3] cec_arb_lost */
-/* [  2] cec_nack */
-/* [  1] cec_eom */
-/* [  0] cec_done */
-#define HDMITX_DWC_IH_MUTE_CEC_STAT0            (DWC_OFFSET_MASK + 0x0186)
-#define HDMITX_DWC_IH_MUTE_VP_STAT0             (DWC_OFFSET_MASK + 0x0187)
-#define HDMITX_DWC_IH_MUTE_I2CMPHY_STAT0        (DWC_OFFSET_MASK + 0x0188)
-/* [  1] mute_wakeup_interrupt */
-/* [  0] mute_all_interrupt */
-#define HDMITX_DWC_IH_MUTE                      (DWC_OFFSET_MASK + 0x01FF)
-
-/* Video Sampler Registers */
-/* [  7] internal_de_generator */
-/* [4:0] video_mapping */
-#define HDMITX_DWC_TX_INVID0                    (DWC_OFFSET_MASK + 0x0200)
-/* [  2] bcbdata_stuffing */
-/* [  1] rcrdata_stuffing */
-/* [  0] gydata_stuffing */
-#define HDMITX_DWC_TX_INSTUFFING                (DWC_OFFSET_MASK + 0x0201)
-#define HDMITX_DWC_TX_GYDATA0                   (DWC_OFFSET_MASK + 0x0202)
-#define HDMITX_DWC_TX_GYDATA1                   (DWC_OFFSET_MASK + 0x0203)
-#define HDMITX_DWC_TX_RCRDATA0                  (DWC_OFFSET_MASK + 0x0204)
-#define HDMITX_DWC_TX_RCRDATA1                  (DWC_OFFSET_MASK + 0x0205)
-#define HDMITX_DWC_TX_BCBDATA0                  (DWC_OFFSET_MASK + 0x0206)
-#define HDMITX_DWC_TX_BCBDATA1                  (DWC_OFFSET_MASK + 0x0207)
-
-/* Video Packetizer Registers */
-#define HDMITX_DWC_VP_STATUS                    (DWC_OFFSET_MASK + 0x0800)
-/* [3:0] desired_pr_factor */
-#define HDMITX_DWC_VP_PR_CD                     (DWC_OFFSET_MASK + 0x0801)
-/* [  5] default_phase */
-/* [  2] ycc422_stuffing */
-/* [  1] pp_stuffing */
-/* [  0] pr_stuffing */
-#define HDMITX_DWC_VP_STUFF                     (DWC_OFFSET_MASK + 0x0802)
-#define HDMITX_DWC_VP_REMAP                     (DWC_OFFSET_MASK + 0x0803)
-#define HDMITX_DWC_VP_CONF                      (DWC_OFFSET_MASK + 0x0804)
-/* [  7] mask_int_full_prpt */
-/* [  6] mask_int_empty_prpt */
-/* [  5] mask_int_full_ppack */
-/* [  4] mask_int_empty_ppack */
-/* [  3] mask_int_full_remap */
-/* [  2] mask_int_empty_remap */
-/* [  1] mask_int_full_byp */
-/* [  0] mask_int_empty_byp */
-#define HDMITX_DWC_VP_MASK                      (DWC_OFFSET_MASK + 0x0807)
-
-/* Frmae Composer Registers */
-/* [  7] HDCP_keepout */
-/* [  6] vs_in_pol: 0=active low; 1=active high. */
-/* [  5] hs_in_pol: 0=active low; 1=active high. */
-/* [  4] de_in_pol: 0=active low; 1=active high. */
-/* [  3] dvi_modez: 0=dvi; 1=hdmi. */
-/* [  1] r_v_blank_in_osc */
-/* [  0] in_I_P: 0=progressive; 1=interlaced. */
-#define HDMITX_DWC_FC_INVIDCONF                 (DWC_OFFSET_MASK + 0x1000)
-/* [7:0] H_in_active[7:0] */
-#define HDMITX_DWC_FC_INHACTV0                  (DWC_OFFSET_MASK + 0x1001)
-/* [5:0] H_in_active[13:8] */
-#define HDMITX_DWC_FC_INHACTV1                  (DWC_OFFSET_MASK + 0x1002)
-/* [7:0] H_in_blank[7:0] */
-#define HDMITX_DWC_FC_INHBLANK0                 (DWC_OFFSET_MASK + 0x1003)
-/* [4:0] H_in_blank[12:8] */
-#define HDMITX_DWC_FC_INHBLANK1                 (DWC_OFFSET_MASK + 0x1004)
-/* [7:0] V_in_active[7:0] */
-#define HDMITX_DWC_FC_INVACTV0                  (DWC_OFFSET_MASK + 0x1005)
-/* [4:0] V_in_active[12:8] */
-#define HDMITX_DWC_FC_INVACTV1                  (DWC_OFFSET_MASK + 0x1006)
-/* [7:0] V_in_blank */
-#define HDMITX_DWC_FC_INVBLANK                  (DWC_OFFSET_MASK + 0x1007)
-/* [7:0] H_in_delay[7:0] */
-#define HDMITX_DWC_FC_HSYNCINDELAY0             (DWC_OFFSET_MASK + 0x1008)
-/* [4:0] H_in_delay[12:8] */
-#define HDMITX_DWC_FC_HSYNCINDELAY1             (DWC_OFFSET_MASK + 0x1009)
-/* [7:0] H_in_width[7:0] */
-#define HDMITX_DWC_FC_HSYNCINWIDTH0             (DWC_OFFSET_MASK + 0x100A)
-/* [1:0] H_in_width[9:8] */
-#define HDMITX_DWC_FC_HSYNCINWIDTH1             (DWC_OFFSET_MASK + 0x100B)
-/* [7:0] V_in_delay */
-#define HDMITX_DWC_FC_VSYNCINDELAY              (DWC_OFFSET_MASK + 0x100C)
-/* [5:0] V_in_width */
-#define HDMITX_DWC_FC_VSYNCINWIDTH              (DWC_OFFSET_MASK + 0x100D)
-#define HDMITX_DWC_FC_INFREQ0                   (DWC_OFFSET_MASK + 0x100E)
-#define HDMITX_DWC_FC_INFREQ1                   (DWC_OFFSET_MASK + 0x100F)
-#define HDMITX_DWC_FC_INFREQ2                   (DWC_OFFSET_MASK + 0x1010)
-#define HDMITX_DWC_FC_CTRLDUR                   (DWC_OFFSET_MASK + 0x1011)
-#define HDMITX_DWC_FC_EXCTRLDUR                 (DWC_OFFSET_MASK + 0x1012)
-#define HDMITX_DWC_FC_EXCTRLSPAC                (DWC_OFFSET_MASK + 0x1013)
-#define HDMITX_DWC_FC_CH0PREAM                  (DWC_OFFSET_MASK + 0x1014)
-#define HDMITX_DWC_FC_CH1PREAM                  (DWC_OFFSET_MASK + 0x1015)
-#define HDMITX_DWC_FC_CH2PREAM                  (DWC_OFFSET_MASK + 0x1016)
-/* [3:2] YQ */
-/* [1:0] CN */
-#define HDMITX_DWC_FC_AVICONF3                  (DWC_OFFSET_MASK + 0x1017)
-/* [  2] default_phase */
-/* [  1] set_avmute */
-/* [  0] clear_avmute */
-#define HDMITX_DWC_FC_GCP                       (DWC_OFFSET_MASK + 0x1018)
-/* [  7] rgb_ycc_indication[2] */
-/* [  6] active_format_present */
-/* [5:4] scan_information */
-/* [3:2] bar_information */
-/* [1:0] rgb_ycc_indication[1:0] */
-#define HDMITX_DWC_FC_AVICONF0                  (DWC_OFFSET_MASK + 0x1019)
-/* [7:6] colorimetry */
-/* [5:4] picture_aspect_ratio */
-/* [3:0] active_aspect_ratio */
-#define HDMITX_DWC_FC_AVICONF1                  (DWC_OFFSET_MASK + 0x101A)
-/* [  7] IT_content */
-/* [6:4] extended_colorimetry */
-/* [3:2] quantization_range */
-/* [1:0] non_uniform_picture_scaling */
-#define HDMITX_DWC_FC_AVICONF2                  (DWC_OFFSET_MASK + 0x101B)
-#define HDMITX_DWC_FC_AVIVID                    (DWC_OFFSET_MASK + 0x101C)
-#define HDMITX_DWC_FC_AVIETB0                   (DWC_OFFSET_MASK + 0x101D)
-#define HDMITX_DWC_FC_AVIETB1                   (DWC_OFFSET_MASK + 0x101E)
-#define HDMITX_DWC_FC_AVISBB0                   (DWC_OFFSET_MASK + 0x101F)
-#define HDMITX_DWC_FC_AVISBB1                   (DWC_OFFSET_MASK + 0x1020)
-#define HDMITX_DWC_FC_AVIELB0                   (DWC_OFFSET_MASK + 0x1021)
-#define HDMITX_DWC_FC_AVIELB1                   (DWC_OFFSET_MASK + 0x1022)
-#define HDMITX_DWC_FC_AVISRB0                   (DWC_OFFSET_MASK + 0x1023)
-#define HDMITX_DWC_FC_AVISRB1                   (DWC_OFFSET_MASK + 0x1024)
-/* [3:0] CT: coding type */
-#define HDMITX_DWC_FC_AUDICONF0                 (DWC_OFFSET_MASK + 0x1025)
-/* [5:4] SS: sampling size */
-/* [2:0] SF: sampling frequency */
-#define HDMITX_DWC_FC_AUDICONF1                 (DWC_OFFSET_MASK + 0x1026)
-/* CA: channel allocation */
-#define HDMITX_DWC_FC_AUDICONF2                 (DWC_OFFSET_MASK + 0x1027)
-/* [6:5] LFEPBL: LFE playback info */
-/* [  4] DM_INH: down mix enable */
-/* [3:0] LSv: Level shift value */
-#define HDMITX_DWC_FC_AUDICONF3                 (DWC_OFFSET_MASK + 0x1028)
-#define HDMITX_DWC_FC_VSDIEEEID0                (DWC_OFFSET_MASK + 0x1029)
-#define HDMITX_DWC_FC_VSDSIZE                   (DWC_OFFSET_MASK + 0x102A)
-#define HDMITX_DWC_FC_VSDIEEEID1                (DWC_OFFSET_MASK + 0x1030)
-#define HDMITX_DWC_FC_VSDIEEEID2                (DWC_OFFSET_MASK + 0x1031)
-#define HDMITX_DWC_FC_VSDPAYLOAD0               (DWC_OFFSET_MASK + 0x1032)
-#define HDMITX_DWC_FC_VSDPAYLOAD1               (DWC_OFFSET_MASK + 0x1033)
-#define HDMITX_DWC_FC_VSDPAYLOAD2               (DWC_OFFSET_MASK + 0x1034)
-#define HDMITX_DWC_FC_VSDPAYLOAD3               (DWC_OFFSET_MASK + 0x1035)
-#define HDMITX_DWC_FC_VSDPAYLOAD4               (DWC_OFFSET_MASK + 0x1036)
-#define HDMITX_DWC_FC_VSDPAYLOAD5               (DWC_OFFSET_MASK + 0x1037)
-#define HDMITX_DWC_FC_VSDPAYLOAD6               (DWC_OFFSET_MASK + 0x1038)
-#define HDMITX_DWC_FC_VSDPAYLOAD7               (DWC_OFFSET_MASK + 0x1039)
-#define HDMITX_DWC_FC_VSDPAYLOAD8               (DWC_OFFSET_MASK + 0x103A)
-#define HDMITX_DWC_FC_VSDPAYLOAD9               (DWC_OFFSET_MASK + 0x103B)
-#define HDMITX_DWC_FC_VSDPAYLOAD10              (DWC_OFFSET_MASK + 0x103C)
-#define HDMITX_DWC_FC_VSDPAYLOAD11              (DWC_OFFSET_MASK + 0x103D)
-#define HDMITX_DWC_FC_VSDPAYLOAD12              (DWC_OFFSET_MASK + 0x103E)
-#define HDMITX_DWC_FC_VSDPAYLOAD13              (DWC_OFFSET_MASK + 0x103F)
-#define HDMITX_DWC_FC_VSDPAYLOAD14              (DWC_OFFSET_MASK + 0x1040)
-#define HDMITX_DWC_FC_VSDPAYLOAD15              (DWC_OFFSET_MASK + 0x1041)
-#define HDMITX_DWC_FC_VSDPAYLOAD16              (DWC_OFFSET_MASK + 0x1042)
-#define HDMITX_DWC_FC_VSDPAYLOAD17              (DWC_OFFSET_MASK + 0x1043)
-#define HDMITX_DWC_FC_VSDPAYLOAD18              (DWC_OFFSET_MASK + 0x1044)
-#define HDMITX_DWC_FC_VSDPAYLOAD19              (DWC_OFFSET_MASK + 0x1045)
-#define HDMITX_DWC_FC_VSDPAYLOAD20              (DWC_OFFSET_MASK + 0x1046)
-#define HDMITX_DWC_FC_VSDPAYLOAD21              (DWC_OFFSET_MASK + 0x1047)
-#define HDMITX_DWC_FC_VSDPAYLOAD22              (DWC_OFFSET_MASK + 0x1048)
-#define HDMITX_DWC_FC_VSDPAYLOAD23              (DWC_OFFSET_MASK + 0x1049)
-#define HDMITX_DWC_FC_SPDVENDORNAME0            (DWC_OFFSET_MASK + 0x104A)
-#define HDMITX_DWC_FC_SPDVENDORNAME1            (DWC_OFFSET_MASK + 0x104B)
-#define HDMITX_DWC_FC_SPDVENDORNAME2            (DWC_OFFSET_MASK + 0x104C)
-#define HDMITX_DWC_FC_SPDVENDORNAME3            (DWC_OFFSET_MASK + 0x104D)
-#define HDMITX_DWC_FC_SPDVENDORNAME4            (DWC_OFFSET_MASK + 0x104E)
-#define HDMITX_DWC_FC_SPDVENDORNAME5            (DWC_OFFSET_MASK + 0x104F)
-#define HDMITX_DWC_FC_SPDVENDORNAME6            (DWC_OFFSET_MASK + 0x1050)
-#define HDMITX_DWC_FC_SPDVENDORNAME7            (DWC_OFFSET_MASK + 0x1051)
-#define HDMITX_DWC_FC_SDPPRODUCTNAME0           (DWC_OFFSET_MASK + 0x1052)
-#define HDMITX_DWC_FC_SDPPRODUCTNAME1           (DWC_OFFSET_MASK + 0x1053)
-#define HDMITX_DWC_FC_SDPPRODUCTNAME2           (DWC_OFFSET_MASK + 0x1054)
-#define HDMITX_DWC_FC_SDPPRODUCTNAME3           (DWC_OFFSET_MASK + 0x1055)
-#define HDMITX_DWC_FC_SDPPRODUCTNAME4           (DWC_OFFSET_MASK + 0x1056)
-#define HDMITX_DWC_FC_SDPPRODUCTNAME5           (DWC_OFFSET_MASK + 0x1057)
-#define HDMITX_DWC_FC_SDPPRODUCTNAME6           (DWC_OFFSET_MASK + 0x1058)
-#define HDMITX_DWC_FC_SDPPRODUCTNAME7           (DWC_OFFSET_MASK + 0x1059)
-#define HDMITX_DWC_FC_SDPPRODUCTNAME8           (DWC_OFFSET_MASK + 0x105A)
-#define HDMITX_DWC_FC_SDPPRODUCTNAME9           (DWC_OFFSET_MASK + 0x105B)
-#define HDMITX_DWC_FC_SDPPRODUCTNAME10          (DWC_OFFSET_MASK + 0x105C)
-#define HDMITX_DWC_FC_SDPPRODUCTNAME11          (DWC_OFFSET_MASK + 0x105D)
-#define HDMITX_DWC_FC_SDPPRODUCTNAME12          (DWC_OFFSET_MASK + 0x105E)
-#define HDMITX_DWC_FC_SDPPRODUCTNAME13          (DWC_OFFSET_MASK + 0x105F)
-#define HDMITX_DWC_FC_SDPPRODUCTNAME14          (DWC_OFFSET_MASK + 0x1060)
-#define HDMITX_DWC_FC_SPDPRODUCTNAME15          (DWC_OFFSET_MASK + 0x1061)
-#define HDMITX_DWC_FC_SPDDEVICEINF              (DWC_OFFSET_MASK + 0x1062)
-/* [7:4] aud_packet_sampflat */
-/* [  0] aud_packet_layout */
-#define HDMITX_DWC_FC_AUDSCONF                  (DWC_OFFSET_MASK + 0x1063)
-#define HDMITX_DWC_FC_AUDSSTAT                  (DWC_OFFSET_MASK + 0x1064)
-/* [  7] V3r */
-/* [  6] V2r */
-/* [  5] V1r */
-/* [  4] V0r */
-/* [  3] V3l */
-/* [  2] V2l */
-/* [  1] V1l */
-/* [  0] V0l */
-#define HDMITX_DWC_FC_AUDSV                     (DWC_OFFSET_MASK + 0x1065)
-#define HDMITX_DWC_FC_AUDSU                     (DWC_OFFSET_MASK + 0x1066)
-/* bit5:4  CSB 41:40 */
-/* bit0  CSB 2 */
-#define HDMITX_DWC_FC_AUDSCHNLS0                (DWC_OFFSET_MASK + 0x1067)
-/* bit7:0  CSB 15:8 */
-#define HDMITX_DWC_FC_AUDSCHNLS1                (DWC_OFFSET_MASK + 0x1068)
-/* bit6:4  CSB 5:3 */
-/* bit3:0  CSB 17:16 */
-#define HDMITX_DWC_FC_AUDSCHNLS2                (DWC_OFFSET_MASK + 0x1069)
-/* bit7:4 CSB 22:21 2nd right sub */
-/* bit3:0 CSB 22:21 1st right sub */
-#define HDMITX_DWC_FC_AUDSCHNLS3                (DWC_OFFSET_MASK + 0x106A)
-/* bit?? CSB 22:21 4th right sub */
-/* bit?? CSB 22:21 3rd right sub */
-#define HDMITX_DWC_FC_AUDSCHNLS4                (DWC_OFFSET_MASK + 0x106B)
-/* bit7:4 CSB 22:21 2nd left sub */
-/* bit3:0 CSB 22:21 1st left sub */
-#define HDMITX_DWC_FC_AUDSCHNLS5                (DWC_OFFSET_MASK + 0x106C)
-/* bit?? CSB 22:21 4th left sub */
-/* bit?? CSB 22:21 3rd left sub */
-#define HDMITX_DWC_FC_AUDSCHNLS6                (DWC_OFFSET_MASK + 0x106D)
-#define HDMITX_DWC_FC_AUDSCHNLS7                (DWC_OFFSET_MASK + 0x106E)
-#define HDMITX_DWC_FC_AUDSCHNLS8                (DWC_OFFSET_MASK + 0x106F)
-#define HDMITX_DWC_FC_DATACH0FILL               (DWC_OFFSET_MASK + 0x1070)
-#define HDMITX_DWC_FC_DATACH1FILL               (DWC_OFFSET_MASK + 0x1071)
-#define HDMITX_DWC_FC_DATACH2FILL               (DWC_OFFSET_MASK + 0x1072)
-#define HDMITX_DWC_FC_CTRLQHIGH                 (DWC_OFFSET_MASK + 0x1073)
-#define HDMITX_DWC_FC_CTRLQLOW                  (DWC_OFFSET_MASK + 0x1074)
-#define HDMITX_DWC_FC_ACP0                      (DWC_OFFSET_MASK + 0x1075)
-#define HDMITX_DWC_FC_ACP16                     (DWC_OFFSET_MASK + 0x1082)
-#define HDMITX_DWC_FC_ACP15                     (DWC_OFFSET_MASK + 0x1083)
-#define HDMITX_DWC_FC_ACP14                     (DWC_OFFSET_MASK + 0x1084)
-#define HDMITX_DWC_FC_ACP13                     (DWC_OFFSET_MASK + 0x1085)
-#define HDMITX_DWC_FC_ACP12                     (DWC_OFFSET_MASK + 0x1086)
-#define HDMITX_DWC_FC_ACP11                     (DWC_OFFSET_MASK + 0x1087)
-#define HDMITX_DWC_FC_ACP10                     (DWC_OFFSET_MASK + 0x1088)
-#define HDMITX_DWC_FC_ACP9                      (DWC_OFFSET_MASK + 0x1089)
-#define HDMITX_DWC_FC_ACP8                      (DWC_OFFSET_MASK + 0x108A)
-#define HDMITX_DWC_FC_ACP7                      (DWC_OFFSET_MASK + 0x108B)
-#define HDMITX_DWC_FC_ACP6                      (DWC_OFFSET_MASK + 0x108C)
-#define HDMITX_DWC_FC_ACP5                      (DWC_OFFSET_MASK + 0x108D)
-#define HDMITX_DWC_FC_ACP4                      (DWC_OFFSET_MASK + 0x108E)
-#define HDMITX_DWC_FC_ACP3                      (DWC_OFFSET_MASK + 0x108F)
-#define HDMITX_DWC_FC_ACP2                      (DWC_OFFSET_MASK + 0x1090)
-#define HDMITX_DWC_FC_ACP1                      (DWC_OFFSET_MASK + 0x1091)
-#define HDMITX_DWC_FC_ISCR1_0                   (DWC_OFFSET_MASK + 0x1092)
-#define HDMITX_DWC_FC_ISCR1_16                  (DWC_OFFSET_MASK + 0x1093)
-#define HDMITX_DWC_FC_ISCR1_15                  (DWC_OFFSET_MASK + 0x1094)
-#define HDMITX_DWC_FC_ISCR1_14                  (DWC_OFFSET_MASK + 0x1095)
-#define HDMITX_DWC_FC_ISCR1_13                  (DWC_OFFSET_MASK + 0x1096)
-#define HDMITX_DWC_FC_ISCR1_12                  (DWC_OFFSET_MASK + 0x1097)
-#define HDMITX_DWC_FC_ISCR1_11                  (DWC_OFFSET_MASK + 0x1098)
-#define HDMITX_DWC_FC_ISCR1_10                  (DWC_OFFSET_MASK + 0x1099)
-#define HDMITX_DWC_FC_ISCR1_9                   (DWC_OFFSET_MASK + 0x109A)
-#define HDMITX_DWC_FC_ISCR1_8                   (DWC_OFFSET_MASK + 0x109B)
-#define HDMITX_DWC_FC_ISCR1_7                   (DWC_OFFSET_MASK + 0x109C)
-#define HDMITX_DWC_FC_ISCR1_6                   (DWC_OFFSET_MASK + 0x109D)
-#define HDMITX_DWC_FC_ISCR1_5                   (DWC_OFFSET_MASK + 0x109E)
-#define HDMITX_DWC_FC_ISCR1_4                   (DWC_OFFSET_MASK + 0x109F)
-#define HDMITX_DWC_FC_ISCR1_3                   (DWC_OFFSET_MASK + 0x10A0)
-#define HDMITX_DWC_FC_ISCR1_2                   (DWC_OFFSET_MASK + 0x10A1)
-#define HDMITX_DWC_FC_ISCR1_1                   (DWC_OFFSET_MASK + 0x10A2)
-#define HDMITX_DWC_FC_ISCR0_15                  (DWC_OFFSET_MASK + 0x10A3)
-#define HDMITX_DWC_FC_ISCR0_14                  (DWC_OFFSET_MASK + 0x10A4)
-#define HDMITX_DWC_FC_ISCR0_13                  (DWC_OFFSET_MASK + 0x10A5)
-#define HDMITX_DWC_FC_ISCR0_12                  (DWC_OFFSET_MASK + 0x10A6)
-#define HDMITX_DWC_FC_ISCR0_11                  (DWC_OFFSET_MASK + 0x10A7)
-#define HDMITX_DWC_FC_ISCR0_10                  (DWC_OFFSET_MASK + 0x10A8)
-#define HDMITX_DWC_FC_ISCR0_9                   (DWC_OFFSET_MASK + 0x10A9)
-#define HDMITX_DWC_FC_ISCR0_8                   (DWC_OFFSET_MASK + 0x10AA)
-#define HDMITX_DWC_FC_ISCR0_7                   (DWC_OFFSET_MASK + 0x10AB)
-#define HDMITX_DWC_FC_ISCR0_6                   (DWC_OFFSET_MASK + 0x10AC)
-#define HDMITX_DWC_FC_ISCR0_5                   (DWC_OFFSET_MASK + 0x10AD)
-#define HDMITX_DWC_FC_ISCR0_4                   (DWC_OFFSET_MASK + 0x10AE)
-#define HDMITX_DWC_FC_ISCR0_3                   (DWC_OFFSET_MASK + 0x10AF)
-#define HDMITX_DWC_FC_ISCR0_2                   (DWC_OFFSET_MASK + 0x10B0)
-#define HDMITX_DWC_FC_ISCR0_1                   (DWC_OFFSET_MASK + 0x10B1)
-#define HDMITX_DWC_FC_ISCR0_0                   (DWC_OFFSET_MASK + 0x10B2)
-/* [  4] spd_auto */
-/* [  3] vsd_auto */
-/* [  2] isrc2_auto */
-/* [  1] isrc1_auto */
-/* [  0] acp_auto */
-#define HDMITX_DWC_FC_DATAUTO0                  (DWC_OFFSET_MASK + 0x10B3)
-#define HDMITX_DWC_FC_DATAUTO1                  (DWC_OFFSET_MASK + 0x10B4)
-#define HDMITX_DWC_FC_DATAUTO2                  (DWC_OFFSET_MASK + 0x10B5)
-#define HDMITX_DWC_FC_DATMAN                    (DWC_OFFSET_MASK + 0x10B6)
-/* [  6] drm_auto: instert on Vsync */
-/* [  5] nvbi_auto: insert on Vsync */
-/* [  4] amp_auto: insert on Vsync */
-/* [  3] avi_auto: insert on Vsync */
-/* [  2] gcp_auto: insert on Vsync */
-/* [  1] audi_auto: insert on Vsync */
-/* [  0] acr_auto: insert on CTS update. Assert this bit later to avoid
- * initial packets with false CTS value
- */
-#define HDMITX_DWC_FC_DATAUTO3                  (DWC_OFFSET_MASK + 0x10B7)
-#define HDMITX_DWC_FC_RDRB0                     (DWC_OFFSET_MASK + 0x10B8)
-#define HDMITX_DWC_FC_RDRB1                     (DWC_OFFSET_MASK + 0x10B9)
-#define HDMITX_DWC_FC_RDRB2                     (DWC_OFFSET_MASK + 0x10BA)
-#define HDMITX_DWC_FC_RDRB3                     (DWC_OFFSET_MASK + 0x10BB)
-#define HDMITX_DWC_FC_RDRB4                     (DWC_OFFSET_MASK + 0x10BC)
-#define HDMITX_DWC_FC_RDRB5                     (DWC_OFFSET_MASK + 0x10BD)
-#define HDMITX_DWC_FC_RDRB6                     (DWC_OFFSET_MASK + 0x10BE)
-#define HDMITX_DWC_FC_RDRB7                     (DWC_OFFSET_MASK + 0x10BF)
-#define HDMITX_DWC_FC_RDRB8                     (DWC_OFFSET_MASK + 0x10C0)
-#define HDMITX_DWC_FC_RDRB9                     (DWC_OFFSET_MASK + 0x10C1)
-#define HDMITX_DWC_FC_RDRB10                    (DWC_OFFSET_MASK + 0x10C2)
-#define HDMITX_DWC_FC_RDRB11                    (DWC_OFFSET_MASK + 0x10C3)
-/* [  7] AUDI_int_mask */
-/* [  6] ACP_int_mask */
-/* [  5] HBR_int_mask */
-/* [  2] AUDS_int_mask */
-/* [  1] ACR_int_mask */
-/* [  0] NULL_int_mask */
-#define HDMITX_DWC_FC_MASK0                     (DWC_OFFSET_MASK + 0x10D2)
-/* [  7] GMD_int_mask */
-/* [  6] ISRC1_int_mask */
-/* [  5] ISRC2_int_mask */
-/* [  4] VSD_int_mask */
-/* [  3] SPD_int_mask */
-/* [  1] AVI_int_mask */
-/* [  0] GCP_int_mask */
-#define HDMITX_DWC_FC_MASK1                     (DWC_OFFSET_MASK + 0x10D6)
-/* [  2] Mask bit for FC_INT2.DRM interrupt bit */
-/* [  1] LowPriority_fifo_full */
-/* [  0] HighPriority_fifo_full */
-#define HDMITX_DWC_FC_MASK2                     (DWC_OFFSET_MASK + 0x10DA)
-/* [7:4] incoming_pr_factor */
-/* [3:0] output_pr_factor */
-#define HDMITX_DWC_FC_PRCONF                    (DWC_OFFSET_MASK + 0x10E0)
-/* [  4] scrambler_ucp_line */
-/* [  0] scrambler_en. Only update this bit once we've sent SCDC message*/
-#define HDMITX_DWC_FC_SCRAMBLER_CTRL            (DWC_OFFSET_MASK + 0x10E1)
-#define HDMITX_DWC_FC_MULTISTREAM_CTRL          (DWC_OFFSET_MASK + 0x10E2)
-/* [  7] drm_tx_en */
-/* [  6] nvbi_tx_en */
-/* [  5] amp_tx_en */
-/* [  4] aut_tx_en */
-/* [  3] audi_tx_en */
-/* [  2] avi_tx_en */
-/* [  1] gcp_tx_en */
-/* [  0] acr_tx_en */
-#define HDMITX_DWC_FC_PACKET_TX_EN              (DWC_OFFSET_MASK + 0x10E3)
-/* [  1] actspc_hdlr_tgl */
-/* [  0] actspc_hdlr_en */
-#define HDMITX_DWC_FC_ACTSPC_HDLR_CFG           (DWC_OFFSET_MASK + 0x10E8)
-#define HDMITX_DWC_FC_INVACT_2D_0               (DWC_OFFSET_MASK + 0x10E9)
-/* [3:0] fc_invact_2d_0[11:8] */
-/* [7:0] fc_invact_2d_0[7:0] */
-#define HDMITX_DWC_FC_INVACT_2D_1               (DWC_OFFSET_MASK + 0x10EA)
-
-#define HDMITX_DWC_FC_GMD_STAT                  (DWC_OFFSET_MASK + 0x1100)
-#define HDMITX_DWC_FC_GMD_EN                    (DWC_OFFSET_MASK + 0x1101)
-#define HDMITX_DWC_FC_GMD_UP                    (DWC_OFFSET_MASK + 0x1102)
-#define HDMITX_DWC_FC_GMD_CONF                  (DWC_OFFSET_MASK + 0x1103)
-#define HDMITX_DWC_FC_GMD_HB                    (DWC_OFFSET_MASK + 0x1104)
-#define HDMITX_DWC_FC_GMD_PB0                   (DWC_OFFSET_MASK + 0x1105)
-#define HDMITX_DWC_FC_GMD_PB1                   (DWC_OFFSET_MASK + 0x1106)
-#define HDMITX_DWC_FC_GMD_PB2                   (DWC_OFFSET_MASK + 0x1107)
-#define HDMITX_DWC_FC_GMD_PB3                   (DWC_OFFSET_MASK + 0x1108)
-#define HDMITX_DWC_FC_GMD_PB4                   (DWC_OFFSET_MASK + 0x1109)
-#define HDMITX_DWC_FC_GMD_PB5                   (DWC_OFFSET_MASK + 0x110A)
-#define HDMITX_DWC_FC_GMD_PB6                   (DWC_OFFSET_MASK + 0x110B)
-#define HDMITX_DWC_FC_GMD_PB7                   (DWC_OFFSET_MASK + 0x110C)
-#define HDMITX_DWC_FC_GMD_PB8                   (DWC_OFFSET_MASK + 0x110D)
-#define HDMITX_DWC_FC_GMD_PB9                   (DWC_OFFSET_MASK + 0x110E)
-#define HDMITX_DWC_FC_GMD_PB10                  (DWC_OFFSET_MASK + 0x110F)
-#define HDMITX_DWC_FC_GMD_PB11                  (DWC_OFFSET_MASK + 0x1110)
-#define HDMITX_DWC_FC_GMD_PB12                  (DWC_OFFSET_MASK + 0x1111)
-#define HDMITX_DWC_FC_GMD_PB13                  (DWC_OFFSET_MASK + 0x1112)
-#define HDMITX_DWC_FC_GMD_PB14                  (DWC_OFFSET_MASK + 0x1113)
-#define HDMITX_DWC_FC_GMD_PB15                  (DWC_OFFSET_MASK + 0x1114)
-#define HDMITX_DWC_FC_GMD_PB16                  (DWC_OFFSET_MASK + 0x1115)
-#define HDMITX_DWC_FC_GMD_PB17                  (DWC_OFFSET_MASK + 0x1116)
-#define HDMITX_DWC_FC_GMD_PB18                  (DWC_OFFSET_MASK + 0x1117)
-#define HDMITX_DWC_FC_GMD_PB19                  (DWC_OFFSET_MASK + 0x1118)
-#define HDMITX_DWC_FC_GMD_PB20                  (DWC_OFFSET_MASK + 0x1119)
-#define HDMITX_DWC_FC_GMD_PB21                  (DWC_OFFSET_MASK + 0x111A)
-#define HDMITX_DWC_FC_GMD_PB22                  (DWC_OFFSET_MASK + 0x111B)
-#define HDMITX_DWC_FC_GMD_PB23                  (DWC_OFFSET_MASK + 0x111C)
-#define HDMITX_DWC_FC_GMD_PB24                  (DWC_OFFSET_MASK + 0x111D)
-#define HDMITX_DWC_FC_GMD_PB25                  (DWC_OFFSET_MASK + 0x111E)
-#define HDMITX_DWC_FC_GMD_PB26                  (DWC_OFFSET_MASK + 0x111F)
-#define HDMITX_DWC_FC_GMD_PB27                  (DWC_OFFSET_MASK + 0x1120)
-
-/* Audio Metadata Packet Registers */
-#define HDMITX_DWC_FC_AMP_HB01                  (DWC_OFFSET_MASK + 0x1128)
-#define HDMITX_DWC_FC_AMP_HB02                  (DWC_OFFSET_MASK + 0x1129)
-#define HDMITX_DWC_FC_AMP_PB00                  (DWC_OFFSET_MASK + 0x112A)
-#define HDMITX_DWC_FC_AMP_PB01                  (DWC_OFFSET_MASK + 0x112B)
-#define HDMITX_DWC_FC_AMP_PB02                  (DWC_OFFSET_MASK + 0x112C)
-#define HDMITX_DWC_FC_AMP_PB03                  (DWC_OFFSET_MASK + 0x112D)
-#define HDMITX_DWC_FC_AMP_PB04                  (DWC_OFFSET_MASK + 0x112E)
-#define HDMITX_DWC_FC_AMP_PB05                  (DWC_OFFSET_MASK + 0x112F)
-#define HDMITX_DWC_FC_AMP_PB06                  (DWC_OFFSET_MASK + 0x1130)
-#define HDMITX_DWC_FC_AMP_PB07                  (DWC_OFFSET_MASK + 0x1131)
-#define HDMITX_DWC_FC_AMP_PB08                  (DWC_OFFSET_MASK + 0x1132)
-#define HDMITX_DWC_FC_AMP_PB09                  (DWC_OFFSET_MASK + 0x1133)
-#define HDMITX_DWC_FC_AMP_PB10                  (DWC_OFFSET_MASK + 0x1134)
-#define HDMITX_DWC_FC_AMP_PB11                  (DWC_OFFSET_MASK + 0x1135)
-#define HDMITX_DWC_FC_AMP_PB12                  (DWC_OFFSET_MASK + 0x1136)
-#define HDMITX_DWC_FC_AMP_PB13                  (DWC_OFFSET_MASK + 0x1137)
-#define HDMITX_DWC_FC_AMP_PB14                  (DWC_OFFSET_MASK + 0x1138)
-#define HDMITX_DWC_FC_AMP_PB15                  (DWC_OFFSET_MASK + 0x1139)
-#define HDMITX_DWC_FC_AMP_PB16                  (DWC_OFFSET_MASK + 0x113A)
-#define HDMITX_DWC_FC_AMP_PB17                  (DWC_OFFSET_MASK + 0x113B)
-#define HDMITX_DWC_FC_AMP_PB18                  (DWC_OFFSET_MASK + 0x113C)
-#define HDMITX_DWC_FC_AMP_PB19                  (DWC_OFFSET_MASK + 0x113D)
-#define HDMITX_DWC_FC_AMP_PB20                  (DWC_OFFSET_MASK + 0x113E)
-#define HDMITX_DWC_FC_AMP_PB21                  (DWC_OFFSET_MASK + 0x113F)
-#define HDMITX_DWC_FC_AMP_PB22                  (DWC_OFFSET_MASK + 0x1140)
-#define HDMITX_DWC_FC_AMP_PB23                  (DWC_OFFSET_MASK + 0x1141)
-#define HDMITX_DWC_FC_AMP_PB24                  (DWC_OFFSET_MASK + 0x1142)
-#define HDMITX_DWC_FC_AMP_PB25                  (DWC_OFFSET_MASK + 0x1143)
-#define HDMITX_DWC_FC_AMP_PB26                  (DWC_OFFSET_MASK + 0x1144)
-#define HDMITX_DWC_FC_AMP_PB27                  (DWC_OFFSET_MASK + 0x1145)
-
-/* NTSC VBI Packet Registers */
-#define HDMITX_DWC_FC_NVBI_HB01                 (DWC_OFFSET_MASK + 0x1148)
-#define HDMITX_DWC_FC_NVBI_HB02                 (DWC_OFFSET_MASK + 0x1149)
-#define HDMITX_DWC_FC_NVBI_PB01                 (DWC_OFFSET_MASK + 0x114A)
-#define HDMITX_DWC_FC_NVBI_PB02                 (DWC_OFFSET_MASK + 0x114B)
-#define HDMITX_DWC_FC_NVBI_PB03                 (DWC_OFFSET_MASK + 0x114C)
-#define HDMITX_DWC_FC_NVBI_PB04                 (DWC_OFFSET_MASK + 0x114D)
-#define HDMITX_DWC_FC_NVBI_PB05                 (DWC_OFFSET_MASK + 0x114E)
-#define HDMITX_DWC_FC_NVBI_PB06                 (DWC_OFFSET_MASK + 0x114F)
-#define HDMITX_DWC_FC_NVBI_PB07                 (DWC_OFFSET_MASK + 0x1150)
-#define HDMITX_DWC_FC_NVBI_PB08                 (DWC_OFFSET_MASK + 0x1151)
-#define HDMITX_DWC_FC_NVBI_PB09                 (DWC_OFFSET_MASK + 0x1152)
-#define HDMITX_DWC_FC_NVBI_PB10                 (DWC_OFFSET_MASK + 0x1153)
-#define HDMITX_DWC_FC_NVBI_PB11                 (DWC_OFFSET_MASK + 0x1154)
-#define HDMITX_DWC_FC_NVBI_PB12                 (DWC_OFFSET_MASK + 0x1155)
-#define HDMITX_DWC_FC_NVBI_PB13                 (DWC_OFFSET_MASK + 0x1156)
-#define HDMITX_DWC_FC_NVBI_PB14                 (DWC_OFFSET_MASK + 0x1157)
-#define HDMITX_DWC_FC_NVBI_PB15                 (DWC_OFFSET_MASK + 0x1158)
-#define HDMITX_DWC_FC_NVBI_PB16                 (DWC_OFFSET_MASK + 0x1159)
-#define HDMITX_DWC_FC_NVBI_PB17                 (DWC_OFFSET_MASK + 0x115A)
-#define HDMITX_DWC_FC_NVBI_PB18                 (DWC_OFFSET_MASK + 0x115B)
-#define HDMITX_DWC_FC_NVBI_PB19                 (DWC_OFFSET_MASK + 0x115C)
-#define HDMITX_DWC_FC_NVBI_PB20                 (DWC_OFFSET_MASK + 0x115D)
-#define HDMITX_DWC_FC_NVBI_PB21                 (DWC_OFFSET_MASK + 0x115E)
-#define HDMITX_DWC_FC_NVBI_PB22                 (DWC_OFFSET_MASK + 0x115F)
-#define HDMITX_DWC_FC_NVBI_PB23                 (DWC_OFFSET_MASK + 0x1160)
-#define HDMITX_DWC_FC_NVBI_PB24                 (DWC_OFFSET_MASK + 0x1161)
-#define HDMITX_DWC_FC_NVBI_PB25                 (DWC_OFFSET_MASK + 0x1162)
-#define HDMITX_DWC_FC_NVBI_PB26                 (DWC_OFFSET_MASK + 0x1163)
-#define HDMITX_DWC_FC_NVBI_PB27                 (DWC_OFFSET_MASK + 0x1164)
-#define HDMITX_DWC_FC_DRM_HB01                  (DWC_OFFSET_MASK + 0x1168)
-#define HDMITX_DWC_FC_DRM_HB02                  (DWC_OFFSET_MASK + 0x1169)
-#define HDMITX_DWC_FC_DRM_PB00                  (DWC_OFFSET_MASK + 0x116A)
-#define HDMITX_DWC_FC_DRM_PB01                  (DWC_OFFSET_MASK + 0x116B)
-#define HDMITX_DWC_FC_DRM_PB02                  (DWC_OFFSET_MASK + 0x116C)
-#define HDMITX_DWC_FC_DRM_PB03                  (DWC_OFFSET_MASK + 0x116D)
-#define HDMITX_DWC_FC_DRM_PB04                  (DWC_OFFSET_MASK + 0x116E)
-#define HDMITX_DWC_FC_DRM_PB05                  (DWC_OFFSET_MASK + 0x116F)
-#define HDMITX_DWC_FC_DRM_PB06                  (DWC_OFFSET_MASK + 0x1170)
-#define HDMITX_DWC_FC_DRM_PB07                  (DWC_OFFSET_MASK + 0x1171)
-#define HDMITX_DWC_FC_DRM_PB08                  (DWC_OFFSET_MASK + 0x1172)
-#define HDMITX_DWC_FC_DRM_PB09                  (DWC_OFFSET_MASK + 0x1173)
-#define HDMITX_DWC_FC_DRM_PB10                  (DWC_OFFSET_MASK + 0x1174)
-#define HDMITX_DWC_FC_DRM_PB11                  (DWC_OFFSET_MASK + 0x1175)
-#define HDMITX_DWC_FC_DRM_PB12                  (DWC_OFFSET_MASK + 0x1176)
-#define HDMITX_DWC_FC_DRM_PB13                  (DWC_OFFSET_MASK + 0x1177)
-#define HDMITX_DWC_FC_DRM_PB14                  (DWC_OFFSET_MASK + 0x1178)
-#define HDMITX_DWC_FC_DRM_PB15                  (DWC_OFFSET_MASK + 0x1179)
-#define HDMITX_DWC_FC_DRM_PB16                  (DWC_OFFSET_MASK + 0x117A)
-#define HDMITX_DWC_FC_DRM_PB17                  (DWC_OFFSET_MASK + 0x117B)
-#define HDMITX_DWC_FC_DRM_PB18                  (DWC_OFFSET_MASK + 0x117C)
-#define HDMITX_DWC_FC_DRM_PB19                  (DWC_OFFSET_MASK + 0x117D)
-#define HDMITX_DWC_FC_DRM_PB20                  (DWC_OFFSET_MASK + 0x117E)
-#define HDMITX_DWC_FC_DRM_PB21                  (DWC_OFFSET_MASK + 0x117F)
-#define HDMITX_DWC_FC_DRM_PB22                  (DWC_OFFSET_MASK + 0x1180)
-#define HDMITX_DWC_FC_DRM_PB23                  (DWC_OFFSET_MASK + 0x1181)
-#define HDMITX_DWC_FC_DRM_PB24                  (DWC_OFFSET_MASK + 0x1182)
-#define HDMITX_DWC_FC_DRM_PB25                  (DWC_OFFSET_MASK + 0x1183)
-#define HDMITX_DWC_FC_DRM_PB26                  (DWC_OFFSET_MASK + 0x1184)
-
-#define HDMITX_DWC_FC_DBGFORCE                  (DWC_OFFSET_MASK + 0x1200)
-#define HDMITX_DWC_FC_DBGAUD0CH0                (DWC_OFFSET_MASK + 0x1201)
-#define HDMITX_DWC_FC_DBGAUD1CH0                (DWC_OFFSET_MASK + 0x1202)
-#define HDMITX_DWC_FC_DBGAUD2CH0                (DWC_OFFSET_MASK + 0x1203)
-#define HDMITX_DWC_FC_DBGAUD0CH1                (DWC_OFFSET_MASK + 0x1204)
-#define HDMITX_DWC_FC_DBGAUD1CH1                (DWC_OFFSET_MASK + 0x1205)
-#define HDMITX_DWC_FC_DBGAUD2CH1                (DWC_OFFSET_MASK + 0x1206)
-#define HDMITX_DWC_FC_DBGAUD0CH2                (DWC_OFFSET_MASK + 0x1207)
-#define HDMITX_DWC_FC_DBGAUD1CH2                (DWC_OFFSET_MASK + 0x1208)
-#define HDMITX_DWC_FC_DBGAUD2CH2                (DWC_OFFSET_MASK + 0x1209)
-#define HDMITX_DWC_FC_DBGAUD0CH3                (DWC_OFFSET_MASK + 0x120A)
-#define HDMITX_DWC_FC_DBGAUD1CH3                (DWC_OFFSET_MASK + 0x120B)
-#define HDMITX_DWC_FC_DBGAUD2CH3                (DWC_OFFSET_MASK + 0x120C)
-#define HDMITX_DWC_FC_DBGAUD0CH4                (DWC_OFFSET_MASK + 0x120D)
-#define HDMITX_DWC_FC_DBGAUD1CH4                (DWC_OFFSET_MASK + 0x120E)
-#define HDMITX_DWC_FC_DBGAUD2CH4                (DWC_OFFSET_MASK + 0x120F)
-#define HDMITX_DWC_FC_DBGAUD0CH5                (DWC_OFFSET_MASK + 0x1210)
-#define HDMITX_DWC_FC_DBGAUD1CH5                (DWC_OFFSET_MASK + 0x1211)
-#define HDMITX_DWC_FC_DBGAUD2CH5                (DWC_OFFSET_MASK + 0x1212)
-#define HDMITX_DWC_FC_DBGAUD0CH6                (DWC_OFFSET_MASK + 0x1213)
-#define HDMITX_DWC_FC_DBGAUD1CH6                (DWC_OFFSET_MASK + 0x1214)
-#define HDMITX_DWC_FC_DBGAUD2CH6                (DWC_OFFSET_MASK + 0x1215)
-#define HDMITX_DWC_FC_DBGAUD0CH7                (DWC_OFFSET_MASK + 0x1216)
-#define HDMITX_DWC_FC_DBGAUD1CH7                (DWC_OFFSET_MASK + 0x1217)
-#define HDMITX_DWC_FC_DBGAUD2CH7                (DWC_OFFSET_MASK + 0x1218)
-#define HDMITX_DWC_FC_DBGTMDS0                  (DWC_OFFSET_MASK + 0x1219)
-#define HDMITX_DWC_FC_DBGTMDS1                  (DWC_OFFSET_MASK + 0x121A)
-#define HDMITX_DWC_FC_DBGTMDS2                  (DWC_OFFSET_MASK + 0x121B)
-
-/* HDMI Source PHY Registers */
-#define HDMITX_DWC_PHY_CONF0                    (DWC_OFFSET_MASK + 0x3000)
-#define HDMITX_DWC_PHY_TST0                     (DWC_OFFSET_MASK + 0x3001)
-#define HDMITX_DWC_PHY_TST1                     (DWC_OFFSET_MASK + 0x3002)
-#define HDMITX_DWC_PHY_TST2                     (DWC_OFFSET_MASK + 0x3003)
-#define HDMITX_DWC_PHY_STAT0                    (DWC_OFFSET_MASK + 0x3004)
-#define HDMITX_DWC_PHY_INT0                     (DWC_OFFSET_MASK + 0x3005)
-#define HDMITX_DWC_PHY_MASK0                    (DWC_OFFSET_MASK + 0x3006)
-#define HDMITX_DWC_PHY_POL0                     (DWC_OFFSET_MASK + 0x3007)
-
-/* I2C Master PHY Registers */
-#define HDMITX_DWC_I2CM_PHY_SLAVE               (DWC_OFFSET_MASK + 0x3020)
-#define HDMITX_DWC_I2CM_PHY_ADDRESS             (DWC_OFFSET_MASK + 0x3021)
-#define HDMITX_DWC_I2CM_PHY_DATAO_1             (DWC_OFFSET_MASK + 0x3022)
-#define HDMITX_DWC_I2CM_PHY_DATAO_0             (DWC_OFFSET_MASK + 0x3023)
-#define HDMITX_DWC_I2CM_PHY_DATAI_1             (DWC_OFFSET_MASK + 0x3024)
-#define HDMITX_DWC_I2CM_PHY_DATAI_0             (DWC_OFFSET_MASK + 0x3025)
-#define HDMITX_DWC_I2CM_PHY_OPERATION           (DWC_OFFSET_MASK + 0x3026)
-#define HDMITX_DWC_I2CM_PHY_INT                 (DWC_OFFSET_MASK + 0x3027)
-#define HDMITX_DWC_I2CM_PHY_CTLINT              (DWC_OFFSET_MASK + 0x3028)
-#define HDMITX_DWC_I2CM_PHY_DIV                 (DWC_OFFSET_MASK + 0x3029)
-#define HDMITX_DWC_I2CM_PHY_SOFTRSTZ            (DWC_OFFSET_MASK + 0x302A)
-#define HDMITX_DWC_I2CM_PHY_SS_SCL_HCNT_1       (DWC_OFFSET_MASK + 0x302B)
-#define HDMITX_DWC_I2CM_PHY_SS_SCL_HCNT_0       (DWC_OFFSET_MASK + 0x302C)
-#define HDMITX_DWC_I2CM_PHY_SS_SCL_LCNT_1       (DWC_OFFSET_MASK + 0x302D)
-#define HDMITX_DWC_I2CM_PHY_SS_SCL_LCNT_0       (DWC_OFFSET_MASK + 0x302E)
-#define HDMITX_DWC_I2CM_PHY_FS_SCL_HCNT_1       (DWC_OFFSET_MASK + 0x302F)
-#define HDMITX_DWC_I2CM_PHY_FS_SCL_HCNT_0       (DWC_OFFSET_MASK + 0x3030)
-#define HDMITX_DWC_I2CM_PHY_FS_SCL_LCNT_1       (DWC_OFFSET_MASK + 0x3031)
-#define HDMITX_DWC_I2CM_PHY_FS_SCL_LCNT_0       (DWC_OFFSET_MASK + 0x3032)
-#define HDMITX_DWC_I2CM_PHY_SDA_HOLD            (DWC_OFFSET_MASK + 0x3033)
-
-/* Audio Sampler Registers */
-
-  /* [  7] sw_audio_fifo_rst */
-  /* [  5] 0=select SPDIF; 1=select I2S. */
-  /* [3:0] i2s_in_en: enable it later in test.c */
-#define HDMITX_DWC_AUD_CONF0                    (DWC_OFFSET_MASK + 0x3100)
-/* [4:0] i2s_width */
-/* [7:5] i2s_mode: 0=standard I2S mode */
-#define HDMITX_DWC_AUD_CONF1                    (DWC_OFFSET_MASK + 0x3101)
-/* [  3] fifo_empty_mask: 0=enable int; 1=mask int. */
-/* [  2] fifo_full_mask: 0=enable int; 1=mask int. */
-#define HDMITX_DWC_AUD_INT                      (DWC_OFFSET_MASK + 0x3102)
-  /* [  1] NLPCM */
-#define HDMITX_DWC_AUD_CONF2                    (DWC_OFFSET_MASK + 0x3103)
-
-/* [  4] fifo_overrun_mask: 0=enable int; 1=mask int.
- * Enable it later when audio starts.
- */
-#define HDMITX_DWC_AUD_INT1                     (DWC_OFFSET_MASK + 0x3104)
-
-#define HDMITX_DWC_AUD_N1                       (DWC_OFFSET_MASK + 0x3200)
-#define HDMITX_DWC_AUD_N2                       (DWC_OFFSET_MASK + 0x3201)
-#define HDMITX_DWC_AUD_N3                       (DWC_OFFSET_MASK + 0x3202)
-#define HDMITX_DWC_AUD_CTS1                     (DWC_OFFSET_MASK + 0x3203)
-#define HDMITX_DWC_AUD_CTS2                     (DWC_OFFSET_MASK + 0x3204)
-#define HDMITX_DWC_AUD_CTS3                     (DWC_OFFSET_MASK + 0x3205)
-#define HDMITX_DWC_AUD_INPUTCLKFS               (DWC_OFFSET_MASK + 0x3206)
-/* [  7] sw_audio_fifo_rst */
-#define HDMITX_DWC_AUD_SPDIF0                   (DWC_OFFSET_MASK + 0x3300)
-/* [4:0] spdif_width */
-/* [  7] setnlpcm */
-#define HDMITX_DWC_AUD_SPDIF1                   (DWC_OFFSET_MASK + 0x3301)
-/* [  3] SPDIF fifo_empty_mask: 0=enable int; 1=mask int. */
-/* [  2] SPDIF fifo_full_mask: 0=enable int; 1=mask int. */
-#define HDMITX_DWC_AUD_SPDIFINT                 (DWC_OFFSET_MASK + 0x3302)
-/* [  4] SPDIF fifo_overrun_mask: 0=enable int; 1=mask int. */
-#define HDMITX_DWC_AUD_SPDIFINT1                (DWC_OFFSET_MASK + 0x3303)
-
-/* Generic Parallel Audio Interface Registers   (DWC_OFFSET_MASK + 0x3500) */
-/* Audio DMA Registers                          (DWC_OFFSET_MASK + 0x3600) */
-
-/* Main Controller Registers */
-/* [  6] hdcpclk_disable */
-/* [  5] cecclk_disable */
-/* [  4] cscclk_disable */
-/* [  3] audclk_disable */
-/* [  2] prepclk_disable */
-/* [  1] tmdsclk_disable */
-/* [  0] pixelclk_disable */
-#define HDMITX_DWC_MC_CLKDIS                    (DWC_OFFSET_MASK + 0x4001)
-/*
- * [  7] gpaswrst_req: 0=generate reset pulse; 1=no reset.
- * [  6] cecswrst_req: 0=generate reset pulse; 1=no reset.
- * [  4] spdifswrst_req: 0=generate reset pulse; 1=no reset.
- * [  3] i2sswrst_req: 0=generate reset pulse; 1=no reset.
- * [  2] prepswrst_req: 0=generate reset pulse; 1=no reset.
- * [  1] tmdsswrst_req: 0=generate reset pulse; 1=no reset.
- * [  0] pixelswrst_req: 0=generate reset pulse; 1=no reset.
- */
-#define HDMITX_DWC_MC_SWRSTZREQ                 (DWC_OFFSET_MASK + 0x4002)
-#define HDMITX_DWC_MC_OPCTRL                    (DWC_OFFSET_MASK + 0x4003)
-/* [  0] CSC enable */
-#define HDMITX_DWC_MC_FLOWCTRL                  (DWC_OFFSET_MASK + 0x4004)
-#define HDMITX_DWC_MC_PHYRSTZ                   (DWC_OFFSET_MASK + 0x4005)
-#define HDMITX_DWC_MC_LOCKONCLOCK               (DWC_OFFSET_MASK + 0x4006)
-
-/* Color Space Converter Registers */
-/* [  7] csc_limit */
-#define HDMITX_DWC_CSC_CFG                      (DWC_OFFSET_MASK + 0x4100)
-#define HDMITX_DWC_CSC_SCALE                    (DWC_OFFSET_MASK + 0x4101)
-#define HDMITX_DWC_CSC_COEF_A1_MSB              (DWC_OFFSET_MASK + 0x4102)
-#define HDMITX_DWC_CSC_COEF_A1_LSB              (DWC_OFFSET_MASK + 0x4103)
-#define HDMITX_DWC_CSC_COEF_A2_MSB              (DWC_OFFSET_MASK + 0x4104)
-#define HDMITX_DWC_CSC_COEF_A2_LSB              (DWC_OFFSET_MASK + 0x4105)
-#define HDMITX_DWC_CSC_COEF_A3_MSB              (DWC_OFFSET_MASK + 0x4106)
-#define HDMITX_DWC_CSC_COEF_A3_LSB              (DWC_OFFSET_MASK + 0x4107)
-#define HDMITX_DWC_CSC_COEF_A4_MSB              (DWC_OFFSET_MASK + 0x4108)
-#define HDMITX_DWC_CSC_COEF_A4_LSB              (DWC_OFFSET_MASK + 0x4109)
-#define HDMITX_DWC_CSC_COEF_B1_MSB              (DWC_OFFSET_MASK + 0x410A)
-#define HDMITX_DWC_CSC_COEF_B1_LSB              (DWC_OFFSET_MASK + 0x410B)
-#define HDMITX_DWC_CSC_COEF_B2_MSB              (DWC_OFFSET_MASK + 0x410C)
-#define HDMITX_DWC_CSC_COEF_B2_LSB              (DWC_OFFSET_MASK + 0x410D)
-#define HDMITX_DWC_CSC_COEF_B3_MSB              (DWC_OFFSET_MASK + 0x410E)
-#define HDMITX_DWC_CSC_COEF_B3_LSB              (DWC_OFFSET_MASK + 0x410F)
-#define HDMITX_DWC_CSC_COEF_B4_MSB              (DWC_OFFSET_MASK + 0x4110)
-#define HDMITX_DWC_CSC_COEF_B4_LSB              (DWC_OFFSET_MASK + 0x4111)
-#define HDMITX_DWC_CSC_COEF_C1_MSB              (DWC_OFFSET_MASK + 0x4112)
-#define HDMITX_DWC_CSC_COEF_C1_LSB              (DWC_OFFSET_MASK + 0x4113)
-#define HDMITX_DWC_CSC_COEF_C2_MSB              (DWC_OFFSET_MASK + 0x4114)
-#define HDMITX_DWC_CSC_COEF_C2_LSB              (DWC_OFFSET_MASK + 0x4115)
-#define HDMITX_DWC_CSC_COEF_C3_MSB              (DWC_OFFSET_MASK + 0x4116)
-#define HDMITX_DWC_CSC_COEF_C3_LSB              (DWC_OFFSET_MASK + 0x4117)
-#define HDMITX_DWC_CSC_COEF_C4_MSB              (DWC_OFFSET_MASK + 0x4118)
-#define HDMITX_DWC_CSC_COEF_C4_LSB              (DWC_OFFSET_MASK + 0x4119)
-#define HDMITX_DWC_CSC_LIMIT_UP_MSB             (DWC_OFFSET_MASK + 0x411A)
-#define HDMITX_DWC_CSC_LIMIT_UP_LSB             (DWC_OFFSET_MASK + 0x411B)
-#define HDMITX_DWC_CSC_LIMIT_DN_MSB             (DWC_OFFSET_MASK + 0x411C)
-#define HDMITX_DWC_CSC_LIMIT_DN_LSB             (DWC_OFFSET_MASK + 0x411D)
-
-/* HDCP Encryption Engine Registers */
-#define HDMITX_DWC_A_HDCPCFG0                   (DWC_SEC_OFFSET_MASK + 0x5000)
-/* [  4] hdcp_lock */
-/* [  3] dissha1check */
-/* [  2] ph2upshiftenc */
-/* [  1] encryptiondisable */
-/* [  0] swresetn. Write 0 to activate, self-clear to 1. */
-#define HDMITX_DWC_A_HDCPCFG1                   (DWC_SEC_OFFSET_MASK + 0x5001)
-#define HDMITX_DWC_A_HDCPOBS0                   (DWC_OFFSET_MASK + 0x5002)
-#define HDMITX_DWC_A_HDCPOBS1                   (DWC_OFFSET_MASK + 0x5003)
-#define HDMITX_DWC_A_HDCPOBS2                   (DWC_OFFSET_MASK + 0x5004)
-#define HDMITX_DWC_A_HDCPOBS3                   (DWC_OFFSET_MASK + 0x5005)
-#define HDMITX_DWC_A_APIINTCLR                  (DWC_OFFSET_MASK + 0x5006)
-#define HDMITX_DWC_A_APIINTSTAT                 (DWC_OFFSET_MASK + 0x5007)
-/* [  7] hdcp_engaged_int_mask */
-/* [  6] hdcp_failed_int_mask */
-/* [  4] i2c_nack_int_mask */
-/* [  3] lost_arbitration_int_mask */
-/* [  2] keepout_error_int_mask */
-/* [  1] ksv_sha1_calc_int_mask */
-/* [  0] ksv_access_int_mask */
-#define HDMITX_DWC_A_APIINTMSK                  (DWC_OFFSET_MASK + 0x5008)
-/* [6:5] unencryptconf */
-/* [  4] dataenpol */
-/* [  3] vsyncpol */
-/* [  1] hsyncpol */
-#define HDMITX_DWC_A_VIDPOLCFG                  (DWC_OFFSET_MASK + 0x5009)
-#define HDMITX_DWC_A_OESSWCFG                   (DWC_OFFSET_MASK + 0x500A)
-#define HDMITX_DWC_A_COREVERLSB                 (DWC_OFFSET_MASK + 0x5014)
-#define HDMITX_DWC_A_COREVERMSB                 (DWC_OFFSET_MASK + 0x5015)
-/* [  3] sha1_fail */
-/* [  2] ksv_ctrl_update */
-/* [  1] Rsvd for read-only ksv_mem_access */
-/* [  0] ksv_mem_request */
-#define HDMITX_DWC_A_KSVMEMCTRL                 (DWC_OFFSET_MASK + 0x5016)
-
-#define HDMITX_DWC_HDCP_BSTATUS_0               (DWC_OFFSET_MASK + 0x5020)
-#define HDMITX_DWC_HDCP_BSTATUS_1               (DWC_OFFSET_MASK + 0x5021)
-#define HDMITX_DWC_HDCP_M0_0                    (DWC_OFFSET_MASK + 0x5022)
-#define HDMITX_DWC_HDCP_M0_1                    (DWC_OFFSET_MASK + 0x5023)
-#define HDMITX_DWC_HDCP_M0_2                    (DWC_OFFSET_MASK + 0x5024)
-#define HDMITX_DWC_HDCP_M0_3                    (DWC_OFFSET_MASK + 0x5025)
-#define HDMITX_DWC_HDCP_M0_4                    (DWC_OFFSET_MASK + 0x5026)
-#define HDMITX_DWC_HDCP_M0_5                    (DWC_OFFSET_MASK + 0x5027)
-#define HDMITX_DWC_HDCP_M0_6                    (DWC_OFFSET_MASK + 0x5028)
-#define HDMITX_DWC_HDCP_M0_7                    (DWC_OFFSET_MASK + 0x5029)
-#define HDMITX_DWC_HDCP_KSV                     (DWC_OFFSET_MASK + 0x502A)
-#define HDMITX_DWC_HDCP_VH                      (DWC_OFFSET_MASK + 0x52A5)
-#define HDMITX_DWC_HDCP_REVOC_SIZE_0            (DWC_OFFSET_MASK + 0x52B9)
-#define HDMITX_DWC_HDCP_REVOC_SIZE_1            (DWC_OFFSET_MASK + 0x52BA)
-#define HDMITX_DWC_HDCP_REVOC_LIST              (DWC_OFFSET_MASK + 0x52BB)
-#define HDMITX_DWC_HDCP_REVOC_LIST_END          (DWC_OFFSET_MASK + 0x667E)
-
-/* HDCP BKSV Registers */
-#define HDMITX_DWC_HDCPREG_BKSV0                (DWC_OFFSET_MASK + 0x7800)
-#define HDMITX_DWC_HDCPREG_BKSV1                (DWC_OFFSET_MASK + 0x7801)
-#define HDMITX_DWC_HDCPREG_BKSV2                (DWC_OFFSET_MASK + 0x7802)
-#define HDMITX_DWC_HDCPREG_BKSV3                (DWC_OFFSET_MASK + 0x7803)
-#define HDMITX_DWC_HDCPREG_BKSV4                (DWC_OFFSET_MASK + 0x7804)
-
-/* HDCP AN Registers */
-#define HDMITX_DWC_HDCPREG_ANCONF               (DWC_OFFSET_MASK + 0x7805)
-#define HDMITX_DWC_HDCPREG_AN0                  (DWC_OFFSET_MASK + 0x7806)
-#define HDMITX_DWC_HDCPREG_AN1                  (DWC_OFFSET_MASK + 0x7807)
-#define HDMITX_DWC_HDCPREG_AN2                  (DWC_OFFSET_MASK + 0x7808)
-#define HDMITX_DWC_HDCPREG_AN3                  (DWC_OFFSET_MASK + 0x7809)
-#define HDMITX_DWC_HDCPREG_AN4                  (DWC_OFFSET_MASK + 0x780A)
-#define HDMITX_DWC_HDCPREG_AN5                  (DWC_OFFSET_MASK + 0x780B)
-#define HDMITX_DWC_HDCPREG_AN6                  (DWC_OFFSET_MASK + 0x780C)
-#define HDMITX_DWC_HDCPREG_AN7                  (DWC_OFFSET_MASK + 0x780D)
-#define HDMITX_DWC_HDCPREG_RMLCTL               (DWC_OFFSET_MASK + 0x780E)
-
-/* Encrypted DPK Embedded Storage Registers */
-#define HDMITX_DWC_HDCPREG_RMLSTS               (DWC_OFFSET_MASK + 0x780F)
-#define HDMITX_DWC_HDCPREG_SEED0                (DWC_SEC_OFFSET_MASK + 0x7810)
-#define HDMITX_DWC_HDCPREG_SEED1                (DWC_SEC_OFFSET_MASK + 0x7811)
-#define HDMITX_DWC_HDCPREG_DPK0                 (DWC_SEC_OFFSET_MASK + 0x7812)
-#define HDMITX_DWC_HDCPREG_DPK1                 (DWC_SEC_OFFSET_MASK + 0x7813)
-#define HDMITX_DWC_HDCPREG_DPK2                 (DWC_SEC_OFFSET_MASK + 0x7814)
-#define HDMITX_DWC_HDCPREG_DPK3                 (DWC_SEC_OFFSET_MASK + 0x7815)
-#define HDMITX_DWC_HDCPREG_DPK4                 (DWC_SEC_OFFSET_MASK + 0x7816)
-#define HDMITX_DWC_HDCPREG_DPK5                 (DWC_SEC_OFFSET_MASK + 0x7817)
-#define HDMITX_DWC_HDCPREG_DPK6                 (DWC_SEC_OFFSET_MASK + 0x7818)
-
-/* HDCP22 Registers */
-#define HDMITX_DWC_HDCP22REG_ID                 (DWC_OFFSET_MASK + 0x7900)
-#define HDMITX_DWC_HDCP22REG_CTRL               (DWC_SEC_OFFSET_MASK + 0x7904)
-#define HDMITX_DWC_HDCP22REG_CTRL1              (DWC_OFFSET_MASK + 0x7905)
-#define HDMITX_DWC_HDCP22REG_STS                (DWC_OFFSET_MASK + 0x7908)
-#define HDMITX_DWC_HDCP22REG_MASK               (DWC_OFFSET_MASK + 0x790C)
-#define HDMITX_DWC_HDCP22REG_STAT               (DWC_OFFSET_MASK + 0x790D)
-#define HDMITX_DWC_HDCP22REG_MUTE               (DWC_OFFSET_MASK + 0x790E)
-
-/* ********** CEC related ********** */
-
-/* CEC 2.0 Engine Registers */
-#define HDMITX_DWC_CEC_CTRL                     (DWC_OFFSET_MASK + 0x7D00)
-#define HDMITX_DWC_CEC_INTR_MASK                (DWC_OFFSET_MASK + 0x7D02)
-#define HDMITX_DWC_CEC_LADD_LOW                 (DWC_OFFSET_MASK + 0x7D05)
-#define HDMITX_DWC_CEC_LADD_HIGH                (DWC_OFFSET_MASK + 0x7D06)
-#define HDMITX_DWC_CEC_TX_CNT                   (DWC_OFFSET_MASK + 0x7D07)
-#define HDMITX_DWC_CEC_RX_CNT                   (DWC_OFFSET_MASK + 0x7D08)
-#define HDMITX_DWC_CEC_TX_DATA00                (DWC_OFFSET_MASK + 0x7D10)
-#define HDMITX_DWC_CEC_TX_DATA01                (DWC_OFFSET_MASK + 0x7D11)
-#define HDMITX_DWC_CEC_TX_DATA02                (DWC_OFFSET_MASK + 0x7D12)
-#define HDMITX_DWC_CEC_TX_DATA03                (DWC_OFFSET_MASK + 0x7D13)
-#define HDMITX_DWC_CEC_TX_DATA04                (DWC_OFFSET_MASK + 0x7D14)
-#define HDMITX_DWC_CEC_TX_DATA05                (DWC_OFFSET_MASK + 0x7D15)
-#define HDMITX_DWC_CEC_TX_DATA06                (DWC_OFFSET_MASK + 0x7D16)
-#define HDMITX_DWC_CEC_TX_DATA07                (DWC_OFFSET_MASK + 0x7D17)
-#define HDMITX_DWC_CEC_TX_DATA08                (DWC_OFFSET_MASK + 0x7D18)
-#define HDMITX_DWC_CEC_TX_DATA09                (DWC_OFFSET_MASK + 0x7D19)
-#define HDMITX_DWC_CEC_TX_DATA10                (DWC_OFFSET_MASK + 0x7D1A)
-#define HDMITX_DWC_CEC_TX_DATA11                (DWC_OFFSET_MASK + 0x7D1B)
-#define HDMITX_DWC_CEC_TX_DATA12                (DWC_OFFSET_MASK + 0x7D1C)
-#define HDMITX_DWC_CEC_TX_DATA13                (DWC_OFFSET_MASK + 0x7D1D)
-#define HDMITX_DWC_CEC_TX_DATA14                (DWC_OFFSET_MASK + 0x7D1E)
-#define HDMITX_DWC_CEC_TX_DATA15                (DWC_OFFSET_MASK + 0x7D1F)
-#define HDMITX_DWC_CEC_RX_DATA00                (DWC_OFFSET_MASK + 0x7D20)
-#define HDMITX_DWC_CEC_RX_DATA01                (DWC_OFFSET_MASK + 0x7D21)
-#define HDMITX_DWC_CEC_RX_DATA02                (DWC_OFFSET_MASK + 0x7D22)
-#define HDMITX_DWC_CEC_RX_DATA03                (DWC_OFFSET_MASK + 0x7D23)
-#define HDMITX_DWC_CEC_RX_DATA04                (DWC_OFFSET_MASK + 0x7D24)
-#define HDMITX_DWC_CEC_RX_DATA05                (DWC_OFFSET_MASK + 0x7D25)
-#define HDMITX_DWC_CEC_RX_DATA06                (DWC_OFFSET_MASK + 0x7D26)
-#define HDMITX_DWC_CEC_RX_DATA07                (DWC_OFFSET_MASK + 0x7D27)
-#define HDMITX_DWC_CEC_RX_DATA08                (DWC_OFFSET_MASK + 0x7D28)
-#define HDMITX_DWC_CEC_RX_DATA09                (DWC_OFFSET_MASK + 0x7D29)
-#define HDMITX_DWC_CEC_RX_DATA10                (DWC_OFFSET_MASK + 0x7D2A)
-#define HDMITX_DWC_CEC_RX_DATA11                (DWC_OFFSET_MASK + 0x7D2B)
-#define HDMITX_DWC_CEC_RX_DATA12                (DWC_OFFSET_MASK + 0x7D2C)
-#define HDMITX_DWC_CEC_RX_DATA13                (DWC_OFFSET_MASK + 0x7D2D)
-#define HDMITX_DWC_CEC_RX_DATA14                (DWC_OFFSET_MASK + 0x7D2E)
-#define HDMITX_DWC_CEC_RX_DATA15                (DWC_OFFSET_MASK + 0x7D2F)
-#define HDMITX_DWC_CEC_LOCK_BUF                 (DWC_OFFSET_MASK + 0x7D30)
-#define HDMITX_DWC_CEC_WAKEUPCTRL               (DWC_OFFSET_MASK + 0x7D31)
-
-/* I2C Master Registers(E-DDC/SCDC) */
-#define HDMITX_DWC_I2CM_SLAVE                   (DWC_OFFSET_MASK + 0x7E00)
-#define HDMITX_DWC_I2CM_ADDRESS                 (DWC_OFFSET_MASK + 0x7E01)
-#define HDMITX_DWC_I2CM_DATAO                   (DWC_OFFSET_MASK + 0x7E02)
-#define HDMITX_DWC_I2CM_DATAI                   (DWC_OFFSET_MASK + 0x7E03)
-#define HDMITX_DWC_I2CM_OPERATION               (DWC_OFFSET_MASK + 0x7E04)
-/* [  2] done_mask */
-/* [  6] read_req_mask */
-#define HDMITX_DWC_I2CM_INT                     (DWC_OFFSET_MASK + 0x7E05)
-/* [  6] nack_mask */
-/* [  2] arbitration_error_mask */
-#define HDMITX_DWC_I2CM_CTLINT                  (DWC_OFFSET_MASK + 0x7E06)
-/* [  3] i2c_fast_mode: 0=standard mode; 1=fast mode. */
-#define HDMITX_DWC_I2CM_DIV                     (DWC_OFFSET_MASK + 0x7E07)
-#define HDMITX_DWC_I2CM_SEGADDR                 (DWC_OFFSET_MASK + 0x7E08)
-#define HDMITX_DWC_I2CM_SOFTRSTZ                (DWC_OFFSET_MASK + 0x7E09)
-#define HDMITX_DWC_I2CM_SEGPTR                  (DWC_OFFSET_MASK + 0x7E0A)
-/* I2CM_SS_SCL_HCNT = RndUp(min_ss_scl_htime*Freq(sfrclkInMHz)/1000) */
-/* I2CM_SS_SCL_LCNT = RndUp(min_ss_scl_ltime*Freq(sfrclkInMHz)/1000) */
-/* I2CM_FS_SCL_HCNT = RndUp(min_fs_scl_htime*Freq(sfrclkInMHz)/1000) */
-/* I2CM_FS_SCL_LCNT = RndUp(min_fs_scl_ltime*Freq(sfrclkInMHz)/1000) */
-/* Where Freq(sfrclkInMHz)=24; */
-#define HDMITX_DWC_I2CM_SS_SCL_HCNT_1           (DWC_OFFSET_MASK + 0x7E0B)
-#define HDMITX_DWC_I2CM_SS_SCL_HCNT_0           (DWC_OFFSET_MASK + 0x7E0C)
-#define HDMITX_DWC_I2CM_SS_SCL_LCNT_1           (DWC_OFFSET_MASK + 0x7E0D)
-#define HDMITX_DWC_I2CM_SS_SCL_LCNT_0           (DWC_OFFSET_MASK + 0x7E0E)
-#define HDMITX_DWC_I2CM_FS_SCL_HCNT_1           (DWC_OFFSET_MASK + 0x7E0F)
-#define HDMITX_DWC_I2CM_FS_SCL_HCNT_0           (DWC_OFFSET_MASK + 0x7E10)
-#define HDMITX_DWC_I2CM_FS_SCL_LCNT_1           (DWC_OFFSET_MASK + 0x7E11)
-#define HDMITX_DWC_I2CM_FS_SCL_LCNT_0           (DWC_OFFSET_MASK + 0x7E12)
-#define HDMITX_DWC_I2CM_SDA_HOLD                (DWC_OFFSET_MASK + 0x7E13)
-/* [  5] updt_rd_vsyncpoll_en */
-/* [  4] read_request_en */
-/* [  0] read_update */
-#define HDMITX_DWC_I2CM_SCDC_UPDATE             (DWC_OFFSET_MASK + 0x7E14)
-#define HDMITX_DWC_I2CM_READ_BUFF0              (DWC_OFFSET_MASK + 0x7E20)
-#define HDMITX_DWC_I2CM_READ_BUFF1              (DWC_OFFSET_MASK + 0x7E21)
-#define HDMITX_DWC_I2CM_READ_BUFF2              (DWC_OFFSET_MASK + 0x7E22)
-#define HDMITX_DWC_I2CM_READ_BUFF3              (DWC_OFFSET_MASK + 0x7E23)
-#define HDMITX_DWC_I2CM_READ_BUFF4              (DWC_OFFSET_MASK + 0x7E24)
-#define HDMITX_DWC_I2CM_READ_BUFF5              (DWC_OFFSET_MASK + 0x7E25)
-#define HDMITX_DWC_I2CM_READ_BUFF6              (DWC_OFFSET_MASK + 0x7E26)
-#define HDMITX_DWC_I2CM_READ_BUFF7              (DWC_OFFSET_MASK + 0x7E27)
-#define HDMITX_DWC_I2CM_SCDC_UPDATE0            (DWC_OFFSET_MASK + 0x7E30)
-#define HDMITX_DWC_I2CM_SCDC_UPDATE1            (DWC_OFFSET_MASK + 0x7E31)
 #endif
diff --git a/drivers/amlogic/media/vout/hdmitx/hdmi_tx_20/hdmi_tx_main.c b/drivers/amlogic/media/vout/hdmitx/hdmi_tx_20/hdmi_tx_main.c
index 7119bf9f6d3f..ea98e9e0ecb9 100644
--- a/drivers/amlogic/media/vout/hdmitx/hdmi_tx_20/hdmi_tx_main.c
+++ b/drivers/amlogic/media/vout/hdmitx/hdmi_tx_20/hdmi_tx_main.c
@@ -3900,6 +3900,8 @@ static ssize_t hdcp_lstore_store(struct device *dev,
 				 const char *buf, size_t count)
 {
 	pr_info("hdcp: set lstore as %s\n", buf);
+	if (strncmp(buf, "-1", 2) == 0)
+		hdmitx_device.lstore = 0x0;
 	if (strncmp(buf, "0", 1) == 0)
 		hdmitx_device.lstore = 0x10;
 	if (strncmp(buf, "11", 2) == 0)
@@ -3990,6 +3992,7 @@ static ssize_t hdcp_mode_show(struct device *dev,
 			      char *buf)
 {
 	int pos = 0;
+	unsigned int hdcp_ret = 0;
 
 	switch (hdmitx_device.hdcp_mode) {
 	case 1:
@@ -4002,6 +4005,15 @@ static ssize_t hdcp_mode_show(struct device *dev,
 		pos += snprintf(buf + pos, PAGE_SIZE, "off");
 		break;
 	}
+	if (hdmitx_device.hdcp_ctl_lvl > 0 &&
+	    hdmitx_device.hdcp_mode > 0) {
+		hdcp_ret = hdmitx_device.hwop.cntlddc(&hdmitx_device,
+						      DDC_HDCP_GET_AUTH, 0);
+		if (hdcp_ret == 1)
+			pos += snprintf(buf + pos, PAGE_SIZE, ": succeed\n");
+		else
+			pos += snprintf(buf + pos, PAGE_SIZE, ": fail\n");
+	}
 
 	return pos;
 }
@@ -4358,6 +4370,45 @@ static ssize_t sysctrl_enable_store(struct device *dev,
 	return count;
 }
 
+static ssize_t hdcp_ctl_lvl_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	int pos = 0;
+
+	pos += snprintf(buf + pos, PAGE_SIZE, "%d\r\n",
+		hdmitx_device.hdcp_ctl_lvl);
+	return pos;
+}
+
+static ssize_t hdcp_ctl_lvl_store(struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t count)
+{
+	unsigned long ctl_lvl = 0xf;
+
+	pr_info("set hdcp_ctl_lvl: %s\n", buf);
+	if (kstrtoul(buf, 10, &ctl_lvl) == 0) {
+		if (ctl_lvl >= 0 && ctl_lvl <= 2)
+			hdmitx_device.hdcp_ctl_lvl = ctl_lvl;
+	}
+	return count;
+}
+
+static ssize_t hdmitx_drm_flag_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	int pos = 0;
+	int flag = 0;
+
+	/* notify hdcp_tx22: use flow of drm */
+	if (hdmitx_device.hdcp_ctl_lvl > 0)
+		flag = 1;
+	else
+		flag = 0;
+
+	pos += snprintf(buf + pos, PAGE_SIZE, "%d", flag);
+	return pos;
+}
+
 void print_drm_config_data(void)
 {
 	enum hdmi_hdr_transfer hdr_transfer_feature;
@@ -5031,6 +5082,9 @@ static DEVICE_ATTR_RO(hdmi_config_info);
 static DEVICE_ATTR_RO(hdmirx_info);
 static DEVICE_ATTR_RO(hdmi_hsty_config);
 static DEVICE_ATTR_RW(sysctrl_enable);
+static DEVICE_ATTR_RW(hdcp_ctl_lvl);
+static DEVICE_ATTR_RO(hdmitx_drm_flag);
+
 
 #ifdef CONFIG_AMLOGIC_VOUT_SERVE
 static struct vinfo_s *hdmitx_get_current_vinfo(void *data)
@@ -5954,72 +6008,6 @@ void hdmitx_hdcp_status(int hdmi_authenticated)
 	hdmitx_set_uevent(HDMITX_HDCP_EVENT, hdmi_authenticated);
 }
 
-/*************DRM connector API**************/
-int drm_hdmitx_detect_hpd(void)
-{
-	return hdmitx_device.hpd_state;
-}
-EXPORT_SYMBOL(drm_hdmitx_detect_hpd);
-
-int drm_hdmitx_register_hpd_cb(drm_hpd_cb cb, void *data)
-{
-	mutex_lock(&setclk_mutex);
-	hdmitx_device.drm_cb = cb;
-	hdmitx_device.drm_data = data;
-	mutex_unlock(&setclk_mutex);
-	return 0;
-}
-EXPORT_SYMBOL(drm_hdmitx_register_hpd_cb);
-
-int drm_hdmitx_get_vic_list(int **vics)
-{
-	enum hdmi_vic vic;
-	char mode_tmp[32];
-	int len = sizeof(disp_mode_t) / sizeof(char *);
-	int i;
-	int count = 0;
-	int *viclist = 0;
-
-	if (hdmitx_device.tv_no_edid)
-		return 0;
-
-	viclist = kmalloc_array(len, sizeof(int), GFP_KERNEL);
-	for (i = 0; disp_mode_t[i]; i++) {
-		memset(mode_tmp, 0, sizeof(mode_tmp));
-		strncpy(mode_tmp, disp_mode_t[i], 31);
-		if (hdmitx_limited_1080p() && is_4k_fmt(mode_tmp))
-			continue;
-		vic = hdmitx_edid_get_VIC(&hdmitx_device, mode_tmp, 0);
-		/* Handling only 4k420 mode */
-		if (vic == HDMI_UNKNOWN && is_4k50_fmt(mode_tmp)) {
-			strcat(mode_tmp, "420");
-			vic = hdmitx_edid_get_VIC(&hdmitx_device,
-						  mode_tmp, 0);
-		}
-
-		if (vic != HDMI_UNKNOWN) {
-			viclist[count] = vic;
-			count++;
-		}
-	}
-
-	if (count == 0)
-		kfree(viclist);
-	else
-		*vics = viclist;
-
-	return count;
-}
-EXPORT_SYMBOL(drm_hdmitx_get_vic_list);
-
-unsigned char *drm_hdmitx_get_raw_edid(void)
-{
-	return hdmitx_device.EDID_buf;
-}
-EXPORT_SYMBOL(drm_hdmitx_get_raw_edid);
-
-/*************DRM connector API**************/
-
 static void hdmitx_init_parameters(struct hdmitx_info *info)
 {
 	memset(info, 0, sizeof(struct hdmitx_info));
@@ -6295,6 +6283,13 @@ static int amhdmitx_get_dt_info(struct platform_device *pdev)
 
 		/* Get reg information */
 		ret = hdmitx_init_reg_map(pdev);
+		/* hdcp ctrl 0:sysctrl, 1: drv, 2: linux app */
+		ret = of_property_read_u32(pdev->dev.of_node, "hdcp_ctl_lvl",
+					   &hdmitx_device.hdcp_ctl_lvl);
+		if (ret)
+			hdmitx_device.hdcp_ctl_lvl = 0;
+		if (hdmitx_device.hdcp_ctl_lvl > 0)
+			hdmitx_device.systemcontrol_on = true;
 	}
 
 #else
@@ -6495,6 +6490,8 @@ static int amhdmitx_probe(struct platform_device *pdev)
 	ret = device_create_file(dev, &dev_attr_hdmirx_info);
 	ret = device_create_file(dev, &dev_attr_hdmi_hsty_config);
 	ret = device_create_file(dev, &dev_attr_sysctrl_enable);
+	ret = device_create_file(dev, &dev_attr_hdcp_ctl_lvl);
+	ret = device_create_file(dev, &dev_attr_hdmitx_drm_flag);
 
 #ifdef CONFIG_AMLOGIC_LEGACY_EARLY_SUSPEND
 	register_early_suspend(&hdmitx_early_suspend_handler);
@@ -6665,6 +6662,8 @@ static int amhdmitx_remove(struct platform_device *pdev)
 	device_remove_file(dev, &dev_attr_hdmirx_info);
 	device_remove_file(dev, &dev_attr_hdmi_hsty_config);
 	device_remove_file(dev, &dev_attr_sysctrl_enable);
+	device_remove_file(dev, &dev_attr_hdcp_ctl_lvl);
+	device_remove_file(dev, &dev_attr_hdmitx_drm_flag);
 
 	cdev_del(&hdmitx_device.cdev);
 
@@ -6897,3 +6896,176 @@ __setup("hdmichecksum=", get_hdmi_checksum);
 
 MODULE_PARM_DESC(log_level, "\n log_level\n");
 module_param(log_level, int, 0644);
+
+/*************DRM connector API**************/
+int drm_hdmitx_detect_hpd(void)
+{
+	return hdmitx_device.hpd_state;
+}
+EXPORT_SYMBOL(drm_hdmitx_detect_hpd);
+
+int drm_hdmitx_register_hpd_cb(drm_hpd_cb cb, void *data)
+{
+	mutex_lock(&setclk_mutex);
+	hdmitx_device.drm_cb = cb;
+	hdmitx_device.drm_data = data;
+	mutex_unlock(&setclk_mutex);
+	return 0;
+}
+EXPORT_SYMBOL(drm_hdmitx_register_hpd_cb);
+
+int drm_hdmitx_get_vic_list(int **vics)
+{
+	enum hdmi_vic vic;
+	char mode_tmp[32];
+	int len = sizeof(disp_mode_t) / sizeof(char *);
+	int i;
+	int count = 0;
+	int *viclist = 0;
+
+	if (hdmitx_device.tv_no_edid)
+		return 0;
+
+	viclist = kmalloc_array(len, sizeof(int), GFP_KERNEL);
+	for (i = 0; disp_mode_t[i]; i++) {
+		memset(mode_tmp, 0, sizeof(mode_tmp));
+		strncpy(mode_tmp, disp_mode_t[i], 31);
+		if (hdmitx_limited_1080p() && is_4k_fmt(mode_tmp))
+			continue;
+		vic = hdmitx_edid_get_VIC(&hdmitx_device, mode_tmp, 0);
+		/* Handling only 4k420 mode */
+		if (vic == HDMI_UNKNOWN && is_4k50_fmt(mode_tmp)) {
+			strcat(mode_tmp, "420");
+			vic = hdmitx_edid_get_VIC(&hdmitx_device,
+						  mode_tmp, 0);
+		}
+
+		if (vic != HDMI_UNKNOWN) {
+			viclist[count] = vic;
+			count++;
+		}
+	}
+
+	if (count == 0)
+		kfree(viclist);
+	else
+		*vics = viclist;
+
+	return count;
+}
+EXPORT_SYMBOL(drm_hdmitx_get_vic_list);
+
+unsigned char *drm_hdmitx_get_raw_edid(void)
+{
+	if (hdmitx_device.edid_ptr)
+		return hdmitx_device.edid_ptr;
+	else
+		return hdmitx_device.EDID_buf;
+}
+EXPORT_SYMBOL(drm_hdmitx_get_raw_edid);
+
+/* bit[1]: hdcp22, bit[0]: hdcp14 */
+int drm_hdmitx_get_hdcp_cap(void)
+{
+	if (hdmitx_device.lstore < 0x10) {
+		hdmitx_device.lstore = 0;
+		if (hdmitx_device.hwop.cntlddc(&hdmitx_device, DDC_HDCP_14_LSTORE, 0))
+			hdmitx_device.lstore += 1;
+		if (hdmitx_device.hwop.cntlddc(&hdmitx_device, DDC_HDCP_22_LSTORE, 0) &&
+		    !hdmitx_limited_hdcp14())
+			hdmitx_device.lstore += 2;
+	}
+	return hdmitx_device.lstore & 0x3;
+}
+EXPORT_SYMBOL(drm_hdmitx_get_hdcp_cap);
+
+/* bit[1]: hdcp22, bit[0]: hdcp14 */
+unsigned int drm_get_rx_hdcp_cap(void)
+{
+	unsigned int ver = 0x0;
+
+	/* if TX don't have HDCP22 key, skip RX hdcp22 ver */
+	if (hdmitx_device.hwop.cntlddc(&hdmitx_device,
+		DDC_HDCP_22_LSTORE, 0) == 0)
+		return 0x1;
+
+	/* Detect RX support HDCP22 */
+	mutex_lock(&getedid_mutex);
+	ver = hdcp_rd_hdcp22_ver();
+	mutex_unlock(&getedid_mutex);
+	/* Here, must assume RX support HDCP14, otherwise affect 1A-03 */
+	if (ver)
+		return 0x3;
+	else
+		return 0x1;
+}
+EXPORT_SYMBOL(drm_get_rx_hdcp_cap);
+
+/* after TEE hdcp key valid, do hdcp22 init before tx22 start */
+void drm_hdmitx_hdcp22_init(void)
+{
+	hdmitx_hdcp_do_work(&hdmitx_device);
+	hdmitx_device.hwop.cntlddc(&hdmitx_device,
+		DDC_HDCP_MUX_INIT, 2);
+}
+EXPORT_SYMBOL(drm_hdmitx_hdcp22_init);
+
+/* echo 1/2 > hdcp_mode */
+int drm_hdmitx_hdcp_enable(unsigned int content_type)
+{
+	enum hdmi_vic vic =
+		hdmitx_device.hwop.getstate(&hdmitx_device, STAT_VIDEO_VIC, 0);
+
+	hdmitx_device.hwop.cntlddc(&hdmitx_device, DDC_HDCP_GET_AUTH, 0);
+
+	if (content_type == 1) {
+		hdmitx_device.hwop.cntlddc(&hdmitx_device, DDC_HDCP_MUX_INIT, 1);
+		if (vic == HDMI_576p50 || vic == HDMI_576p50_16x9)
+			usleep_range(500000, 500010);
+		hdmitx_device.hdcp_mode = 1;
+		hdmitx_hdcp_do_work(&hdmitx_device);
+		hdmitx_device.hwop.cntlddc(&hdmitx_device,
+			DDC_HDCP_OP, HDCP14_ON);
+	} else if (content_type == 2) {
+		hdmitx_device.hdcp_mode = 2;
+		hdmitx_hdcp_do_work(&hdmitx_device);
+		/* for drm hdcp_tx22, esm init only once
+		 * don't do HDCP22 IP reset after init done!
+		 */
+		hdmitx_device.hwop.cntlddc(&hdmitx_device,
+			DDC_HDCP_MUX_INIT, 3);
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(drm_hdmitx_hdcp_enable);
+
+/* echo -1 > hdcp_mode;echo stop14/22 > hdcp_ctrl */
+int drm_hdmitx_hdcp_disable(unsigned int content_type)
+{
+	hdmitx_device.hwop.cntlddc(&hdmitx_device, DDC_HDCP_MUX_INIT, 1);
+	hdmitx_device.hwop.cntlddc(&hdmitx_device, DDC_HDCP_GET_AUTH, 0);
+
+	if (content_type == 1) {
+		hdmitx_device.hwop.cntlddc(&hdmitx_device,
+			DDC_HDCP_OP, HDCP14_OFF);
+	} else if (content_type == 2) {
+		hdmitx_device.hwop.cntlddc(&hdmitx_device,
+			DDC_HDCP_OP, HDCP22_OFF);
+	}
+
+	hdmitx_device.hdcp_mode = 0;
+	hdmitx_hdcp_do_work(&hdmitx_device);
+
+	return 0;
+}
+EXPORT_SYMBOL(drm_hdmitx_hdcp_disable);
+
+int drm_get_hdcp_auth_sts(void)
+{
+	return hdmitx_device.hwop.cntlddc(&hdmitx_device, DDC_HDCP_GET_AUTH, 0);
+}
+EXPORT_SYMBOL(drm_get_hdcp_auth_sts);
+
+/*************DRM connector API end**************/
+
diff --git a/drivers/amlogic/media/vout/hdmitx/hdmi_tx_20/hw/hdmi_tx_hw.c b/drivers/amlogic/media/vout/hdmitx/hdmi_tx_20/hw/hdmi_tx_hw.c
index ca1065fdf299..7bc9a89c701b 100644
--- a/drivers/amlogic/media/vout/hdmitx/hdmi_tx_20/hw/hdmi_tx_hw.c
+++ b/drivers/amlogic/media/vout/hdmitx/hdmi_tx_20/hw/hdmi_tx_hw.c
@@ -3405,6 +3405,11 @@ static void hdmitx_debug(struct hdmitx_dev *hdev, const char *buf)
 		}
 	} else if (strncmp(tmpbuf, "stop_vsif", 9) == 0) {
 		hdmitx_disable_packet(HDMI_PACKET_VEND);
+	} else if (strncmp(tmpbuf, "hdcp_mode", 9) == 0) {
+		ret = kstrtoul(tmpbuf + 9, 16, &value);
+		if (value >= 0 && value <= 3 &&
+			hdev->hwop.am_hdmitx_set_hdcp_mode)
+			hdev->hwop.am_hdmitx_set_hdcp_mode(value);
 	}
 }
 
@@ -4021,11 +4026,24 @@ static int hdmitx_cntl_ddc(struct hdmitx_dev *hdev, unsigned int cmd,
 			hdmitx_wr_reg(HDMITX_DWC_HDCP22REG_MASK, 0);
 			hdmitx_wr_reg(HDMITX_DWC_HDCP22REG_MUTE, 0);
 			set_pkf_duk_nonce();
-		}
-		if (argv == 1)
+		} else if (argv == 1) {
 			hdmitx_hdcp_opr(6);
-		if (argv == 3)
-			hdmitx_set_reg_bits(HDMITX_DWC_HDCP22REG_CTRL, 1, 2, 1);
+		} else if (argv == 3) {
+			if (hdev->data->chip_type >= MESON_CPU_ID_SC2)
+				hd_write_reg(P_CLKCTRL_HDCP22_CLK_CTRL,
+					     0x01000100);
+			else
+				hd_write_reg(P_HHI_HDCP22_CLK_CNTL, 0x01000100);
+			hdmitx_ddc_hw_op(DDC_MUX_DDC);
+			if (hdev->data->chip_type >= MESON_CPU_ID_SC2)
+				hdmitx_set_reg_bits(HDMITX_DWC_MC_CLKDIS_SC2,
+						    1, 6, 1);
+			else
+				hdmitx_set_reg_bits(HDMITX_DWC_MC_CLKDIS,
+						    1, 6, 1);
+			usleep_range(4, 6);
+			hdmitx_set_reg_bits(HDMITX_DWC_HDCP22REG_CTRL, 3, 1, 2);
+		}
 		break;
 	case DDC_HDCP_OP:
 		hdev->hdcp_max_exceed_state = 0;
diff --git a/include/linux/amlogic/media/vout/hdmi_tx/hdmi_tx_module.h b/include/linux/amlogic/media/vout/hdmi_tx/hdmi_tx_module.h
index 348005d135b0..a174be5bb052 100644
--- a/include/linux/amlogic/media/vout/hdmi_tx/hdmi_tx_module.h
+++ b/include/linux/amlogic/media/vout/hdmi_tx/hdmi_tx_module.h
@@ -16,6 +16,7 @@
 #include <linux/pinctrl/consumer.h>
 #include <linux/amlogic/media/vout/vout_notify.h>
 #include <linux/amlogic/media/vpu/vpu.h>
+#include <linux/amlogic/media/vout/hdmi_tx/meson_drm_hdmitx.h>
 
 #define DEVICE_NAME "amhdmitx"
 
@@ -281,9 +282,6 @@ struct hdmitx_clk_tree_s {
 	struct clk *venci_1_gate;
 };
 
-/*drm hpd*/
-typedef void (*drm_hpd_cb)(void *data);
-
 #define EDID_MAX_BLOCK              4
 struct hdmitx_dev {
 	struct cdev cdev; /* The cdev structure */
@@ -371,10 +369,7 @@ struct hdmitx_dev {
 				unsigned int cmd, unsigned int arg);
 		int (*cntl)(struct hdmitx_dev *hdmitx_device, unsigned int cmd,
 			    unsigned int arg); /* Other control */
-		void (*am_hdmitx_hdcp_disable)(void);
-		void (*am_hdmitx_hdcp_enable)(void);
-		void (*am_hdmitx_hdcp_result)(unsigned int *exe_type,
-					      unsigned int *result_type);
+		void (*am_hdmitx_set_hdcp_mode)(unsigned int user_type);
 	} hwop;
 	struct {
 		unsigned int hdcp14_en;
@@ -486,6 +481,7 @@ struct hdmitx_dev {
 	void *drm_data;
 	bool systemcontrol_on;
 	unsigned char vid_mute_op;
+	unsigned int hdcp_ctl_lvl;
 };
 
 #define CMD_DDC_OFFSET          (0x10 << 24)
@@ -926,12 +922,5 @@ bool hdmitx_dv_en(void);
 bool hdmitx_hdr10p_en(void);
 bool LGAVIErrorTV(struct rx_cap *prxcap);
 bool hdmitx_find_vendor(struct hdmitx_dev *hdev);
-
-/*DRM connector API*/
-int drm_hdmitx_detect_hpd(void);
-int drm_hdmitx_register_hpd_cb(drm_hpd_cb cb, void *data);
-int drm_hdmitx_get_vic_list(int **vics);
-unsigned char *drm_hdmitx_get_raw_edid(void);
-/*DRM connector API end*/
 int hdmitx_uboot_already_display(int type);
 #endif
diff --git a/include/linux/amlogic/media/vout/hdmi_tx/meson_drm_hdmitx.h b/include/linux/amlogic/media/vout/hdmi_tx/meson_drm_hdmitx.h
new file mode 100644
index 000000000000..5fc5c56b9c78
--- /dev/null
+++ b/include/linux/amlogic/media/vout/hdmi_tx/meson_drm_hdmitx.h
@@ -0,0 +1,30 @@
+/* SPDX-License-Identifier: (GPL-2.0+ OR MIT) */
+/*
+ * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
+ */
+
+#ifndef _MESON_DRM_HDMITX_H
+#define _MESON_DRM_HDMITX_H
+/*
+ * The following interface is for amlogic DRM driver,
+ * it is similar to hdmi_tx_main.c.
+ * Currently it share most code of hdmi_tx_main.c.
+ */
+
+/*drm hpd*/
+typedef void (*drm_hpd_cb)(void *data);
+
+int drm_hdmitx_register_hpd_cb(drm_hpd_cb cb, void *data);
+int drm_hdmitx_detect_hpd(void);
+
+unsigned char *drm_hdmitx_get_raw_edid(void);
+int drm_hdmitx_get_vic_list(int **vics);
+
+int drm_hdmitx_get_hdcp_cap(void);
+unsigned int drm_get_rx_hdcp_cap(void);
+int drm_hdmitx_hdcp_enable(unsigned int content_type);
+int drm_hdmitx_hdcp_disable(unsigned int content_type);
+int drm_get_hdcp_auth_sts(void);
+void drm_hdmitx_hdcp22_init(void);
+
+#endif
-- 
2.31.1

