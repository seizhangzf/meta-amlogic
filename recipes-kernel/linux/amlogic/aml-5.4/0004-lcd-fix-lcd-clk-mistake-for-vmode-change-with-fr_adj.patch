From c4280aceb79ee43396884708f7565dbefd8fdfb0 Mon Sep 17 00:00:00 2001
From: Evoke Zhang <evoke.zhang@amlogic.com>
Date: Tue, 19 Apr 2022 12:10:55 +0800
Subject: [PATCH] lcd: fix lcd clk mistake for vmode change with fr_adj_type 4
 [2/2]

PD#SWPL-75290

Problem:
lcd clk mistake when frame rate 59.94hz->60hz with fr_adj_type 4

Solution:
fix lcd clk mistake for vmode change with fr_adj_type 4

Verify:
ar301

Change-Id: I5237c32cc03528a4c0c404878b0eac6590cae962
Signed-off-by: Evoke Zhang <evoke.zhang@amlogic.com>
---
 .../amlogic/media/vout/lcd/lcd_clk_config.c   | 20 +++++---
 drivers/amlogic/media/vout/lcd/lcd_common.c   | 50 ++++++++++---------
 drivers/amlogic/media/vout/lcd/lcd_common.h   |  3 +-
 3 files changed, 41 insertions(+), 32 deletions(-)

diff --git a/drivers/amlogic/media/vout/lcd/lcd_clk_config.c b/drivers/amlogic/media/vout/lcd/lcd_clk_config.c
index a5e944f73a94..ca90087486bd 100644
--- a/drivers/amlogic/media/vout/lcd/lcd_clk_config.c
+++ b/drivers/amlogic/media/vout/lcd/lcd_clk_config.c
@@ -4028,15 +4028,15 @@ void lcd_update_clk(struct aml_lcd_drv_s *pdrv)
 {
 	struct lcd_clk_config_s *cconf;
 	struct lcd_clk_ctrl_s *table;
-	unsigned int offset;
+	unsigned int offset, reg, val;
 	int i = 0;
 	unsigned long flags = 0;
 
-	spin_lock_irqsave(&lcd_clk_lock, flags);
-
 	cconf = get_lcd_clk_config(pdrv);
 	if (!cconf)
-		goto lcd_clk_update_end;
+		return;
+
+	spin_lock_irqsave(&lcd_clk_lock, flags);
 
 	if (cconf->data->pll_frac_generate)
 		cconf->data->pll_frac_generate(pdrv);
@@ -4050,15 +4050,21 @@ void lcd_update_clk(struct aml_lcd_drv_s *pdrv)
 		if (table[i].flag == LCD_CLK_CTRL_END)
 			break;
 		if (table[i].flag == LCD_CLK_CTRL_FRAC) {
-			lcd_ana_setb(table[i].reg + offset, cconf->pll_frac,
-				     table[i].bit, table[i].len);
+			reg = table[i].reg + offset;
+			val = lcd_ana_read(reg);
+			lcd_ana_setb(reg, cconf->pll_frac, table[i].bit, table[i].len);
+			if (lcd_debug_print_flag & LCD_DBG_PR_NORMAL) {
+				LCDPR("[%d]: %s: pll_frac reg 0x%x: 0x%08x->0x%08x\n",
+					pdrv->index, __func__, reg,
+					val, lcd_ana_read(reg));
+			}
 		}
 		i++;
 	}
 
 lcd_clk_update_end:
 	spin_unlock_irqrestore(&lcd_clk_lock, flags);
-	LCDPR("[%d]: %s\n", pdrv->index, __func__);
+	LCDPR("[%d]: %s: pll_frac=0x%x\n", pdrv->index, __func__, cconf->pll_frac);
 }
 
 /* for timing change */
diff --git a/drivers/amlogic/media/vout/lcd/lcd_common.c b/drivers/amlogic/media/vout/lcd/lcd_common.c
index 7695716b3bed..b6312671e3ad 100644
--- a/drivers/amlogic/media/vout/lcd/lcd_common.c
+++ b/drivers/amlogic/media/vout/lcd/lcd_common.c
@@ -2624,9 +2624,9 @@ int lcd_vmode_change(struct aml_lcd_drv_s *pdrv)
 			temp = duration_num;
 			temp = temp * h_period * v_period;
 			pclk = lcd_do_div(temp, duration_den);
-			if (pconf->timing.lcd_clk != pclk)
-				pconf->timing.clk_change = LCD_CLK_FRAC_UPDATE;
 		}
+		if (pconf->timing.lcd_clk != pclk)
+			pconf->timing.clk_change = LCD_CLK_FRAC_UPDATE;
 		break;
 	case 2: /* vtotal adjust */
 		temp = pclk;
@@ -2639,9 +2639,9 @@ int lcd_vmode_change(struct aml_lcd_drv_s *pdrv)
 			temp = duration_num;
 			temp = temp * h_period * v_period;
 			pclk = lcd_do_div(temp, duration_den);
-			if (pconf->timing.lcd_clk != pclk)
-				pconf->timing.clk_change = LCD_CLK_FRAC_UPDATE;
 		}
+		if (pconf->timing.lcd_clk != pclk)
+			pconf->timing.clk_change = LCD_CLK_FRAC_UPDATE;
 		break;
 	case 3: /* free adjust, use min/max range to calculate */
 		temp = pclk;
@@ -2659,15 +2659,13 @@ int lcd_vmode_change(struct aml_lcd_drv_s *pdrv)
 				temp = duration_num;
 				temp = temp * h_period * v_period;
 				pclk = lcd_do_div(temp, duration_den);
-				if (pconf->timing.lcd_clk != pclk) {
-					if (pclk > pclk_max) {
-						pclk = pclk_max;
-						LCDERR("[%d]: invalid vmode\n",
-						       pdrv->index);
-						return -1;
-					}
-					pconf->timing.clk_change = LCD_CLK_PLL_CHANGE;
+				if (pclk > pclk_max) {
+					LCDERR("[%d]:  %s: invalid vmode\n",
+						pdrv->index, __func__);
+					return -1;
 				}
+				if (pconf->timing.lcd_clk != pclk)
+					pconf->timing.clk_change = LCD_CLK_PLL_CHANGE;
 			}
 		} else if (v_period < pconf->basic.v_period_min) {
 			v_period = pconf->basic.v_period_min;
@@ -2679,15 +2677,13 @@ int lcd_vmode_change(struct aml_lcd_drv_s *pdrv)
 				temp = duration_num;
 				temp = temp * h_period * v_period;
 				pclk = lcd_do_div(temp, duration_den);
-				if (pconf->timing.lcd_clk != pclk) {
-					if (pclk < pclk_min) {
-						pclk = pclk_min;
-						LCDERR("[%d]: invalid vmode\n",
-						       pdrv->index);
-						return -1;
-					}
-					pconf->timing.clk_change = LCD_CLK_PLL_CHANGE;
+				if (pclk < pclk_min) {
+					LCDERR("[%d]: %s: invalid vmode\n",
+						pdrv->index, __func__);
+					return -1;
 				}
+				if (pconf->timing.lcd_clk != pclk)
+					pconf->timing.clk_change = LCD_CLK_PLL_CHANGE;
 			}
 		}
 		/* check clk frac update */
@@ -2722,9 +2718,9 @@ int lcd_vmode_change(struct aml_lcd_drv_s *pdrv)
 				temp = duration_num;
 				temp = temp * h_period * v_period;
 				pclk = lcd_do_div(temp, duration_den);
-				if (pconf->timing.lcd_clk != pclk)
-					pconf->timing.clk_change = LCD_CLK_FRAC_UPDATE;
 			}
+			if (pconf->timing.lcd_clk != pclk)
+				pconf->timing.clk_change = LCD_CLK_FRAC_UPDATE;
 		}
 		break;
 	default:
@@ -2751,10 +2747,11 @@ int lcd_vmode_change(struct aml_lcd_drv_s *pdrv)
 	if (pconf->timing.lcd_clk != pclk) {
 		if (len > 0)
 			len += sprintf(str + len, ", ");
-		len += sprintf(str + len, "pclk %u.%03uMHz->%u.%03uMHz",
+		len += sprintf(str + len, "pclk %u.%03uMHz->%u.%03uMHz, clk_change:%d",
 			       (pconf->timing.lcd_clk / 1000000),
 			       ((pconf->timing.lcd_clk / 1000) % 1000),
-			       (pclk / 1000000), ((pclk / 1000) % 1000));
+			       (pclk / 1000000), ((pclk / 1000) % 1000),
+			       pconf->timing.clk_change);
 		pconf->timing.lcd_clk = pclk;
 	}
 	if (lcd_debug_print_flag & LCD_DBG_PR_NORMAL) {
@@ -2767,6 +2764,11 @@ int lcd_vmode_change(struct aml_lcd_drv_s *pdrv)
 
 void lcd_clk_change(struct aml_lcd_drv_s *pdrv)
 {
+	if (lcd_debug_print_flag & LCD_DBG_PR_NORMAL) {
+		LCDPR("[%d]: %s: clk_change:%d\n",
+			pdrv->index, __func__, pdrv->config.timing.clk_change);
+	}
+
 	switch (pdrv->config.timing.clk_change) {
 	case LCD_CLK_PLL_CHANGE:
 		lcd_clk_generate_parameter(pdrv);
diff --git a/drivers/amlogic/media/vout/lcd/lcd_common.h b/drivers/amlogic/media/vout/lcd/lcd_common.h
index ff824260f70d..5f0663be63b5 100644
--- a/drivers/amlogic/media/vout/lcd/lcd_common.h
+++ b/drivers/amlogic/media/vout/lcd/lcd_common.h
@@ -35,7 +35,8 @@
 /* 20220119: support tcon multi list threshold overlap*/
 /* 20220121: update custom_pinmux and fr_auto_dis support*/
 /* 20220216: update vrr config when display mode change*/
-#define LCD_DRV_VERSION    "20220216"
+/* 20220421: fix lcd clk mistake for vmode change with fr_adj_type 4*/
+#define LCD_DRV_VERSION    "20220421"
 
 extern struct mutex lcd_vout_mutex;
 extern spinlock_t lcd_reg_spinlock;
-- 
2.31.0

