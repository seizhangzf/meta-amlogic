From e0442aae6d5befe04e0814443e2fcb33f5bab7bf Mon Sep 17 00:00:00 2001
From: Matthew Shyu <matthew.shyu@amlogic.com>
Date: Tue, 6 Dec 2016 11:28:24 +0800
Subject: [PATCH 3/3] fix-compilation-error-for-gcc6.patch

---
 arch/arm64/crypto/aes-ce-cipher.c                  |    5 +-
 arch/arm64/crypto/aes-glue.c                       |    2 +-
 arch/arm64/crypto/ghash-ce-glue.c                  |    7 +-
 arch/arm64/crypto/sha1-ce-glue.c                   |    5 +-
 arch/arm64/crypto/sha2-ce-glue.c                   |    7 +-
 drivers/amlogic/amlnf/dev/amlnf_dev.c              |    8 +-
 drivers/amlogic/amlnf/phy/chipenv.c                |   92 ++++++++++----------
 drivers/amlogic/amports/amvdec.c                   |    2 +-
 drivers/amlogic/amports/vh265.c                    |    7 +-
 drivers/amlogic/amports/video.c                    |    6 +-
 drivers/amlogic/amports/vvp9.c                     |   14 +--
 drivers/amlogic/amvecm/amcm.c                      |   22 ++---
 drivers/amlogic/deinterlace/vof_soft_top.c         |    2 +-
 .../display/backlight/aml_ldim/ldim_dev_drv.c      |    4 +-
 .../amlogic/display/backlight/aml_ldim/ldim_func.c |    2 +-
 drivers/amlogic/hdmi/hdmi_tx_20/hdmi_tx_edid.c     |   36 ++++----
 drivers/amlogic/input/sensor/l3gd20_gyr.c          |    4 +-
 drivers/amlogic/input/sensor/mm3a310.c             |    4 +-
 drivers/amlogic/mmc/aml_sd_emmc.c                  |    2 +-
 drivers/amlogic/mmc/amlsd.c                        |    2 +-
 drivers/amlogic/tvin/hdmirx/hdmi_rx_wrapper.c      |   10 +--
 drivers/amlogic/usb/dwc_otg/310/dwc_otg_driver.c   |    3 +-
 drivers/hid/hid-dia-remote.c                       |    4 +-
 drivers/media/dvb-core/dvb_frontend.c              |    6 +-
 drivers/misc/eeprom/at24.c                         |    2 +-
 drivers/net/usb/usbnet.c                           |    4 +-
 drivers/usb/gadget/android.c                       |    3 +-
 fs/compat_ioctl.c                                  |    2 +-
 fs/exfat/exfat_core.c                              |    2 +-
 include/linux/compiler-gcc6.h                      |   66 ++++++++++++++
 kernel/cgroup.c                                    |    8 +-
 kernel/sched/fair.c                                |   26 +++---
 kernel/trace/trace_output.c                        |    2 +-
 net/core/net-sysfs.c                               |    2 +
 net/core/rtnetlink.c                               |    4 +-
 net/ipv4/arp.c                                     |    4 +-
 net/ipv4/ping.c                                    |    4 +-
 sound/soc/aml/m8/aml_m8.c                          |    4 +-
 38 files changed, 234 insertions(+), 155 deletions(-)
 create mode 100644 include/linux/compiler-gcc6.h

diff --git a/arch/arm64/crypto/aes-ce-cipher.c b/arch/arm64/crypto/aes-ce-cipher.c
index 2075e1a..4f00cb2 100644
--- a/arch/arm64/crypto/aes-ce-cipher.c
+++ b/arch/arm64/crypto/aes-ce-cipher.c
@@ -150,6 +150,9 @@ static void __exit aes_mod_exit(void)
 {
 	crypto_unregister_alg(&aes_alg);
 }
-
+#ifdef MODULE
 module_cpu_feature_match(AES, aes_mod_init);
+#else
+module_init(aes_mod_init);
+#endif
 module_exit(aes_mod_exit);
diff --git a/arch/arm64/crypto/aes-glue.c b/arch/arm64/crypto/aes-glue.c
index 79cd911..998fe77 100644
--- a/arch/arm64/crypto/aes-glue.c
+++ b/arch/arm64/crypto/aes-glue.c
@@ -438,7 +438,7 @@ static void __exit aes_exit(void)
 	crypto_unregister_algs(aes_algs, ARRAY_SIZE(aes_algs));
 }
 
-#ifdef USE_V8_CRYPTO_EXTENSIONS
+#if defined(USE_V8_CRYPTO_EXTENSIONS) && defined(MODULE)
 module_cpu_feature_match(AES, aes_init);
 #else
 module_init(aes_init);
diff --git a/arch/arm64/crypto/ghash-ce-glue.c b/arch/arm64/crypto/ghash-ce-glue.c
index 833ec1e..da8f32d 100644
--- a/arch/arm64/crypto/ghash-ce-glue.c
+++ b/arch/arm64/crypto/ghash-ce-glue.c
@@ -141,16 +141,17 @@ static struct shash_alg ghash_alg = {
 		.cra_module		= THIS_MODULE,
 	},
 };
-
 static int __init ghash_ce_mod_init(void)
 {
 	return crypto_register_shash(&ghash_alg);
 }
-
 static void __exit ghash_ce_mod_exit(void)
 {
 	crypto_unregister_shash(&ghash_alg);
 }
-
+#ifdef MODULE
 module_cpu_feature_match(PMULL, ghash_ce_mod_init);
+#else
+module_init(ghash_ce_mod_init);
+#endif
 module_exit(ghash_ce_mod_exit);
diff --git a/arch/arm64/crypto/sha1-ce-glue.c b/arch/arm64/crypto/sha1-ce-glue.c
index 6fe83f3..6976122 100644
--- a/arch/arm64/crypto/sha1-ce-glue.c
+++ b/arch/arm64/crypto/sha1-ce-glue.c
@@ -169,6 +169,9 @@ static void __exit sha1_ce_mod_fini(void)
 {
 	crypto_unregister_shash(&alg);
 }
-
+#ifdef MODULE
 module_cpu_feature_match(SHA1, sha1_ce_mod_init);
+#else
+module_init(sha1_ce_mod_init);
+#endif
 module_exit(sha1_ce_mod_fini);
diff --git a/arch/arm64/crypto/sha2-ce-glue.c b/arch/arm64/crypto/sha2-ce-glue.c
index c294e67..0602deb 100644
--- a/arch/arm64/crypto/sha2-ce-glue.c
+++ b/arch/arm64/crypto/sha2-ce-glue.c
@@ -240,16 +240,17 @@ static struct shash_alg algs[] = { {
 		.cra_module		= THIS_MODULE,
 	}
 } };
-
 static int __init sha2_ce_mod_init(void)
 {
 	return crypto_register_shashes(algs, ARRAY_SIZE(algs));
 }
-
 static void __exit sha2_ce_mod_fini(void)
 {
 	crypto_unregister_shashes(algs, ARRAY_SIZE(algs));
 }
-
+#ifdef MODULE
 module_cpu_feature_match(SHA2, sha2_ce_mod_init);
+#else
+module_init(sha2_ce_mod_init);
+#endif
 module_exit(sha2_ce_mod_fini);
diff --git a/drivers/amlogic/amlnf/dev/amlnf_dev.c b/drivers/amlogic/amlnf/dev/amlnf_dev.c
index ff46114..bcc0592 100644
--- a/drivers/amlogic/amlnf/dev/amlnf_dev.c
+++ b/drivers/amlogic/amlnf/dev/amlnf_dev.c
@@ -97,7 +97,7 @@ exit_error0:
 	return ret;
 }
 
-
+#if 0
 static int amlnf_blk_open(struct block_device *bdev, fmode_t mode)
 {
 	return 0;
@@ -108,7 +108,6 @@ static void amlnf_blk_release(struct gendisk *disk, fmode_t mode)
 	return;
 }
 
-
 static int amlnf_blk_getgeo(struct block_device *bdev, struct hd_geometry *geo)
 {
 	return 0;
@@ -119,8 +118,9 @@ static int amlnf_blk_ioctl(struct block_device *bdev, fmode_t mode,
 {
 	return 0;
 }
+#endif
 
-
+#if 0
 static const struct block_device_operations amlnf_blk_ops = {
 	.owner		= THIS_MODULE,
 	.open		= amlnf_blk_open,
@@ -128,7 +128,7 @@ static const struct block_device_operations amlnf_blk_ops = {
 	.ioctl		= amlnf_blk_ioctl,
 	.getgeo		= amlnf_blk_getgeo,
 };
-
+#endif
 #define blk_queue_plugged(q)    test_bit(18, &(q)->queue_flags)
 
 
diff --git a/drivers/amlogic/amlnf/phy/chipenv.c b/drivers/amlogic/amlnf/phy/chipenv.c
index 6cd3ad0..2089d5a 100644
--- a/drivers/amlogic/amlnf/phy/chipenv.c
+++ b/drivers/amlogic/amlnf/phy/chipenv.c
@@ -1167,8 +1167,8 @@ get_free_blk:
 					&& (!full_page_flag)
 					&& (!arg_info->update_flag))
 					ops_para->page_addr += 1;
-					temp_page_num =
-					ops_para->page_addr % 256;
+				temp_page_num =
+				ops_para->page_addr % 256;
 			}
 
 			if ((ops_para->option & DEV_SLC_MODE)) {
@@ -2396,7 +2396,7 @@ int aml_nand_scan_hynix_info(struct amlnand_chip *aml_chip)
 
 		for (i = 0; i < pages_read; i++) {
 			memset((unsigned char *)ops_para, 0x0,
-				sizeof(struct chip_ops_para));
+					sizeof(struct chip_ops_para));
 
 			if ((flash->new_type) && (flash->new_type < 10))
 				ops_para->option |= DEV_SLC_MODE;
@@ -2407,20 +2407,20 @@ int aml_nand_scan_hynix_info(struct amlnand_chip *aml_chip)
 
 			ops_para->page_addr = (i + tmp_value * pages_per_blk);
 			if ((ops_para->option & DEV_SLC_MODE)
-				&& ((flash->new_type > 0)
-				&& (flash->new_type < 10))) {
+					&& ((flash->new_type > 0)
+						&& (flash->new_type < 10))) {
 				index = ops_para->page_addr;
 				index &= (~(pages_per_blk - 1));
 				ops_para->page_addr = index |
-				(slc_info->pagelist[ops_para->page_addr % 256]);
+					(slc_info->pagelist[ops_para->page_addr % 256]);
 			}
 			ops_para->chipnr = start_blk % controller->chip_num;
 			controller->select_chip(controller, ops_para->chipnr);
 
 			memset((unsigned char *)ops_para->data_buf, 0x0,
-				flash->pagesize);
+					flash->pagesize);
 			memset((unsigned char *)ops_para->oob_buf, 0x0,
-				sizeof(oob_buf));
+					sizeof(oob_buf));
 
 			nand_type = flash->new_type;
 			flash->new_type = 0;
@@ -2437,56 +2437,56 @@ int aml_nand_scan_hynix_info(struct amlnand_chip *aml_chip)
 			if ((ops_para->ecc_err) || (ret < 0)) {
 				aml_nand_msg("blk check good but read failed ");
 				aml_nand_msg("chip %d page %d",
-					ops_para->chipnr,
-					ops_para->page_addr);
+						ops_para->chipnr,
+						ops_para->page_addr);
 				continue;
 			}
 
 			memcpy(oob_buf, aml_chip->user_oob_buf,
-				sizeof(oob_buf));
+					sizeof(oob_buf));
 			if (!memcmp(oob_buf,
-				HYNIX_DEV_HEAD_MAGIC,
-				strlen(HYNIX_DEV_HEAD_MAGIC))) {
+						HYNIX_DEV_HEAD_MAGIC,
+						strlen(HYNIX_DEV_HEAD_MAGIC))) {
 				memcpy(&retry_info->reg_def_val[0][0],
-					(u8 *)aml_chip->user_page_buf,
-					MAX_CHIP_NUM*READ_RETRY_REG_NUM);
+						(u8 *)aml_chip->user_page_buf,
+						MAX_CHIP_NUM*READ_RETRY_REG_NUM);
 				aml_nand_msg("get def value at blk:%d,page:%d",
-					start_blk,
-					ops_para->page_addr);
+						start_blk,
+						ops_para->page_addr);
 
-		for (k = 0; k < controller->chip_num; k++)
-			for (j = 0; j < retry_info->reg_cnt_lp;
-				j++)
-				aml_nand_dbg("REG(0x%x):val:0x%x,for chip%d",
-				retry_info->reg_addr_lp[j],
-			retry_info->reg_def_val[k][j], k);
-
-	if ((flash->new_type == HYNIX_20NM_8GB)
-		|| (flash->new_type == HYNIX_20NM_4GB)
-		|| (flash->new_type == HYNIX_1YNM)) {
+				for (k = 0; k < controller->chip_num; k++)
+					for (j = 0; j < retry_info->reg_cnt_lp;
+							j++)
+						aml_nand_dbg("REG(0x%x):val:0x%x,for chip%d",
+								retry_info->reg_addr_lp[j],
+								retry_info->reg_def_val[k][j], k);
+
+				if ((flash->new_type == HYNIX_20NM_8GB)
+						|| (flash->new_type == HYNIX_20NM_4GB)
+						|| (flash->new_type == HYNIX_1YNM)) {
 #ifdef DEBUG_HYINX_DEF
-		for (n = 0; n < controller->chip_num; n++)
-			for (j = 0; j < save_cnt; j++)
-				memcpy(&retry_info->reg_offs_val_lp[n][j][0],
-					(u8 *)(aml_chip->user_page_buf +
-					MAX_CHIP_NUM*READ_RETRY_REG_NUM +
-					j*READ_RETRY_REG_NUM+n*save_cnt),
-					READ_RETRY_REG_NUM);
+					for (n = 0; n < controller->chip_num; n++)
+						for (j = 0; j < save_cnt; j++)
+							memcpy(&retry_info->reg_offs_val_lp[n][j][0],
+									(u8 *)(aml_chip->user_page_buf +
+										MAX_CHIP_NUM*READ_RETRY_REG_NUM +
+										j*READ_RETRY_REG_NUM+n*save_cnt),
+									READ_RETRY_REG_NUM);
 #else
-		memcpy(&retry_info->reg_offs_val_lp[0][0][0],
-			(u8 *)(aml_chip->user_page_buf +
-			MAX_CHIP_NUM*READ_RETRY_REG_NUM),
-			MAX_CHIP_NUM*READ_RETRY_CNT*READ_RETRY_REG_NUM);
+					memcpy(&retry_info->reg_offs_val_lp[0][0][0],
+							(u8 *)(aml_chip->user_page_buf +
+								MAX_CHIP_NUM*READ_RETRY_REG_NUM),
+							MAX_CHIP_NUM*READ_RETRY_CNT*READ_RETRY_REG_NUM);
 #endif
 				}
-for (n = 0; n < controller->chip_num; n++)
-	for (j = 0; j < retry_info->retry_cnt_lp; j++)
-		for (k = 0; k < retry_info->reg_cnt_lp; k++)
-			aml_nand_dbg("Retry%dst,REG(0x%x):val:0x%2x,for chip%d",
-				k,
-				retry_info->reg_addr_lp[k],
-			retry_info->reg_offs_val_lp[n][j][k],
-			n);
+				for (n = 0; n < controller->chip_num; n++)
+					for (j = 0; j < retry_info->retry_cnt_lp; j++)
+						for (k = 0; k < retry_info->reg_cnt_lp; k++)
+							aml_nand_dbg("Retry%dst,REG(0x%x):val:0x%2x,for chip%d",
+									k,
+									retry_info->reg_addr_lp[k],
+									retry_info->reg_offs_val_lp[n][j][k],
+									n);
 
 				retry_info->default_flag = 1;
 				retry_info->flag = 1;
diff --git a/drivers/amlogic/amports/amvdec.c b/drivers/amlogic/amports/amvdec.c
index 8ec2ce7..10ab4b6 100644
--- a/drivers/amlogic/amports/amvdec.c
+++ b/drivers/amlogic/amports/amvdec.c
@@ -775,7 +775,7 @@ static int vdec_is_paused(void)
 	}
 	/*have data,but output buffer is full */
 	if ((rp == old_rp && level > 1024) ||
-		(rp == old_rp && wp == old_wp && level == level)) {
+		(rp == old_rp && wp == old_wp /*&& level == level*/)) {
 		/*no write && not read */
 		paused_time++;
 	} else {
diff --git a/drivers/amlogic/amports/vh265.c b/drivers/amlogic/amports/vh265.c
index 6ed562b..50d0179 100644
--- a/drivers/amlogic/amports/vh265.c
+++ b/drivers/amlogic/amports/vh265.c
@@ -86,9 +86,9 @@ static s32 vh265_init(struct hevc_state_s *hevc);
 static void vh265_prot_init(struct hevc_state_s *hevc);
 static int vh265_local_init(struct hevc_state_s *hevc);
 static void vh265_put_timer_func(unsigned long arg);
-
+#if 0
 static const char vh265_dec_id[] = "vh265-dev";
-
+#endif
 #define PROVIDER_NAME   "decoder.h265"
 
 static const struct vframe_operations_s vh265_vf_provider = {
@@ -106,7 +106,7 @@ static u32 bit_depth_chroma;
 static u32 video_signal_type;
 
 #define VIDEO_SIGNAL_TYPE_AVAILABLE_MASK	0x20000000
-
+#if 0
 static const char * const video_format_names[] = {
 	"component", "PAL", "NTSC", "SECAM",
 	"MAC", "unspecified", "unspecified", "unspecified"
@@ -131,6 +131,7 @@ static const char * const matrix_coeffs_names[] = {
 	"fcc", "bt470bg", "smpte170m", "smpte240m",
 	"YCgCo", "bt2020nc", "bt2020c"
 };
+#endif
 
 #ifdef SUPPORT_10BIT
 #define HEVC_CM_BODY_START_ADDR                    0x3626
diff --git a/drivers/amlogic/amports/video.c b/drivers/amlogic/amports/video.c
index 7481409..c4bdd8f 100644
--- a/drivers/amlogic/amports/video.c
+++ b/drivers/amlogic/amports/video.c
@@ -6474,15 +6474,15 @@ static u32 yuv2rgb(u32 yuv)
 	r = r - 16;
 	if (r < 0)
 		r = 0;
-		r = r*1164/1000;
+	r = r*1164/1000;
 	g = g - 16;
 	if (g < 0)
 		g = 0;
-		g = g*1164/1000;
+	g = g*1164/1000;
 	b = b - 16;
 	if (b < 0)
 		b = 0;
-		b = b*1164/1000;
+	b = b*1164/1000;
 
 	r = (r <= 0) ? 0 : (r >= 255) ? 255 : r;
 	g = (g <= 0) ? 0 : (g >= 255) ? 255 : g;
diff --git a/drivers/amlogic/amports/vvp9.c b/drivers/amlogic/amports/vvp9.c
index 822f65c..fc6caad 100644
--- a/drivers/amlogic/amports/vvp9.c
+++ b/drivers/amlogic/amports/vvp9.c
@@ -177,9 +177,9 @@ static void vvp9_prot_init(struct VP9Decoder_s *pbi);
 static int vvp9_local_init(struct VP9Decoder_s *pbi);
 static void vvp9_put_timer_func(unsigned long arg);
 
-
+#if 0
 static const char vvp9_dec_id[] = "vvp9-dev";
-
+#endif
 #define PROVIDER_NAME   "decoder.vp9"
 
 static const struct vframe_operations_s vvp9_vf_provider = {
@@ -5305,11 +5305,11 @@ if (debug & VP9_DEBUG_DBG_LF_PRINT) {
 	for (i = 0; i < MAX_SEGMENTS; i++)
 		seg_4lf->feature_mask[i] = (vp9_param.p.seg_lf_info[i] &
 		0x8000) ? (1 << SEG_LVL_ALT_LF) : 0;
-		for (i = 0; i < MAX_SEGMENTS; i++)
-			seg_4lf->feature_data[i][SEG_LVL_ALT_LF]
-			= (vp9_param.p.seg_lf_info[i]
-			& 0x100) ? -(vp9_param.p.seg_lf_info[i]
-			& 0x3f) : (vp9_param.p.seg_lf_info[i] & 0x3f);
+	for (i = 0; i < MAX_SEGMENTS; i++)
+		seg_4lf->feature_data[i][SEG_LVL_ALT_LF]
+		= (vp9_param.p.seg_lf_info[i]
+		& 0x100) ? -(vp9_param.p.seg_lf_info[i]
+		& 0x3f) : (vp9_param.p.seg_lf_info[i] & 0x3f);
 	/*
 	* Update loop filter Thr/Lvl table for every frame
 	*/
diff --git a/drivers/amlogic/amvecm/amcm.c b/drivers/amlogic/amvecm/amcm.c
index 5005d45..f9dff45 100644
--- a/drivers/amlogic/amvecm/amcm.c
+++ b/drivers/amlogic/amvecm/amcm.c
@@ -190,17 +190,17 @@ void am_set_regmap(struct am_regs_s *p)
 				&& (p->am_reg[i].addr <= 0x32e4)) {
 				if (p->am_reg[i].addr == 0x32d7)
 					break;
-					sr1_temp = p->am_reg[i].addr - 0x3280;
-					sr1_regs[sr1_temp].addr =
-						p->am_reg[i].addr;
-					sr1_regs[sr1_temp].mask =
-						p->am_reg[i].mask;
-					sr1_regs[sr1_temp].val =
-						(sr1_regs[sr1_temp].val &
-						(~(p->am_reg[i].mask))) |
-					(p->am_reg[i].val & p->am_reg[i].mask);
-					sr1_reg_val[sr1_temp] =
-						sr1_regs[sr1_temp].val;
+				sr1_temp = p->am_reg[i].addr - 0x3280;
+				sr1_regs[sr1_temp].addr =
+					p->am_reg[i].addr;
+				sr1_regs[sr1_temp].mask =
+					p->am_reg[i].mask;
+				sr1_regs[sr1_temp].val =
+					(sr1_regs[sr1_temp].val &
+					(~(p->am_reg[i].mask))) |
+				(p->am_reg[i].val & p->am_reg[i].mask);
+				sr1_reg_val[sr1_temp] =
+					sr1_regs[sr1_temp].val;
 				aml_write_vcbus(p->am_reg[i].addr,
 					sr1_regs[sr1_temp].val);
 			} else
diff --git a/drivers/amlogic/deinterlace/vof_soft_top.c b/drivers/amlogic/deinterlace/vof_soft_top.c
index 6a1b65c..6625210 100644
--- a/drivers/amlogic/deinterlace/vof_soft_top.c
+++ b/drivers/amlogic/deinterlace/vof_soft_top.c
@@ -419,7 +419,7 @@ int VOFSftTop(UINT8 *rFlmPstGCm, UINT8 *rFlmSltPre, UINT8 *rFlmPstMod,
 				"WndXx[%d]=[%3d~%3d]\n",
 				nT0, VOFWnd[2*nT0], VOFWnd[2*nT0+1]);
 
-				nWCmb += VOFWnd[2*nT0+1]-VOFWnd[2*nT0]+1;
+			nWCmb += VOFWnd[2*nT0+1]-VOFWnd[2*nT0]+1;
 		}
 
 		nT1 = pRDat->pModXx[HISDETNUM - 1];
diff --git a/drivers/amlogic/display/backlight/aml_ldim/ldim_dev_drv.c b/drivers/amlogic/display/backlight/aml_ldim/ldim_dev_drv.c
index 939bf19e..da43c99 100644
--- a/drivers/amlogic/display/backlight/aml_ldim/ldim_dev_drv.c
+++ b/drivers/amlogic/display/backlight/aml_ldim/ldim_dev_drv.c
@@ -638,7 +638,7 @@ static int ldim_dev_get_config_from_dts(struct device_node *np, int index)
 				}
 				if (ldim_dev_config.init_on[i] == 0xff)
 					break;
-					i += ldim_dev_config.cmd_size;
+				i += ldim_dev_config.cmd_size;
 				}
 			}
 ldim_get_init_off:
@@ -665,7 +665,7 @@ ldim_get_init_off:
 				}
 				if (ldim_dev_config.init_off[i] == 0xff)
 					break;
-					i += ldim_dev_config.cmd_size;
+				i += ldim_dev_config.cmd_size;
 			}
 		}
 ldim_get_config_end:
diff --git a/drivers/amlogic/display/backlight/aml_ldim/ldim_func.c b/drivers/amlogic/display/backlight/aml_ldim/ldim_func.c
index 40a9ea3..38b25ba 100644
--- a/drivers/amlogic/display/backlight/aml_ldim/ldim_func.c
+++ b/drivers/amlogic/display/backlight/aml_ldim/ldim_func.c
@@ -596,7 +596,7 @@ int LD_GetBLMtxAvg(int pMtx[], int size, int mode)
 		da = 0;
 		for (i = 0; i < size; i++)
 			da += pMtx[i];
-			da = da/size;
+		da = da/size;
 	} else if (mode == 2) {
 		da = pMtx[0];
 		for (i = 1; i < size; i++)
diff --git a/drivers/amlogic/hdmi/hdmi_tx_20/hdmi_tx_edid.c b/drivers/amlogic/hdmi/hdmi_tx_20/hdmi_tx_edid.c
index d4fdcb5..555e18c 100644
--- a/drivers/amlogic/hdmi/hdmi_tx_20/hdmi_tx_edid.c
+++ b/drivers/amlogic/hdmi/hdmi_tx_20/hdmi_tx_edid.c
@@ -511,8 +511,8 @@ static void Edid_ParsingAudioDATABlock(struct hdmitx_info *info,
 				info->tv_audio_info._AC3._44k = 1;
 			if ((Data[i+1]&0x01))
 				info->tv_audio_info._AC3._32k = 1;
-				info->tv_audio_info._AC3._max_bit =
-					Data[i+2];
+			info->tv_audio_info._AC3._max_bit =
+				Data[i+2];
 			break;
 		case 3:
 			info->tv_audio_info._MPEG1.support_flag = 1;
@@ -532,8 +532,8 @@ static void Edid_ParsingAudioDATABlock(struct hdmitx_info *info,
 				info->tv_audio_info._MPEG1._44k = 1;
 			if ((Data[i+1]&0x01))
 				info->tv_audio_info._MPEG1._32k = 1;
-				info->tv_audio_info._MPEG1._max_bit =
-					Data[i+2];
+			info->tv_audio_info._MPEG1._max_bit =
+				Data[i+2];
 			break;
 		case 4:
 			info->tv_audio_info._MP3.support_flag = 1;
@@ -553,7 +553,7 @@ static void Edid_ParsingAudioDATABlock(struct hdmitx_info *info,
 				info->tv_audio_info._MP3._44k = 1;
 			if ((Data[i+1]&0x01))
 				info->tv_audio_info._MP3._32k = 1;
-				info->tv_audio_info._MP3._max_bit = Data[i+2];
+			info->tv_audio_info._MP3._max_bit = Data[i+2];
 			break;
 		case 5:
 			info->tv_audio_info._MPEG2.support_flag = 1;
@@ -573,7 +573,7 @@ static void Edid_ParsingAudioDATABlock(struct hdmitx_info *info,
 				info->tv_audio_info._MPEG2._44k = 1;
 			if ((Data[i+1]&0x01))
 				info->tv_audio_info._MPEG2._32k = 1;
-				info->tv_audio_info._MPEG2._max_bit = Data[i+2];
+			info->tv_audio_info._MPEG2._max_bit = Data[i+2];
 			break;
 		case 6:
 			info->tv_audio_info._AAC.support_flag = 1;
@@ -593,7 +593,7 @@ static void Edid_ParsingAudioDATABlock(struct hdmitx_info *info,
 				info->tv_audio_info._AAC._44k = 1;
 			if ((Data[i+1]&0x01))
 				info->tv_audio_info._AAC._32k = 1;
-				info->tv_audio_info._AAC._max_bit = Data[i+2];
+			info->tv_audio_info._AAC._max_bit = Data[i+2];
 			break;
 		case 7:
 			info->tv_audio_info._DTS.support_flag = 1;
@@ -613,7 +613,7 @@ static void Edid_ParsingAudioDATABlock(struct hdmitx_info *info,
 				info->tv_audio_info._DTS._44k = 1;
 			if ((Data[i+1]&0x01))
 				info->tv_audio_info._DTS._32k = 1;
-				info->tv_audio_info._DTS._max_bit = Data[i+2];
+			info->tv_audio_info._DTS._max_bit = Data[i+2];
 			break;
 		case 8:
 			info->tv_audio_info._ATRAC.support_flag = 1;
@@ -633,7 +633,7 @@ static void Edid_ParsingAudioDATABlock(struct hdmitx_info *info,
 				info->tv_audio_info._ATRAC._44k = 1;
 			if ((Data[i+1]&0x01))
 				info->tv_audio_info._ATRAC._32k = 1;
-				info->tv_audio_info._ATRAC._max_bit = Data[i+2];
+			info->tv_audio_info._ATRAC._max_bit = Data[i+2];
 			break;
 		case 9:
 			info->tv_audio_info._One_Bit_Audio.support_flag = 1;
@@ -653,8 +653,8 @@ static void Edid_ParsingAudioDATABlock(struct hdmitx_info *info,
 				info->tv_audio_info._One_Bit_Audio._44k = 1;
 			if ((Data[i+1]&0x01))
 				info->tv_audio_info._One_Bit_Audio._32k = 1;
-				info->tv_audio_info._One_Bit_Audio._max_bit =
-					Data[i+2];
+			info->tv_audio_info._One_Bit_Audio._max_bit =
+				Data[i+2];
 			break;
 		case 10:
 			info->tv_audio_info._Dolby.support_flag = 1;
@@ -674,7 +674,7 @@ static void Edid_ParsingAudioDATABlock(struct hdmitx_info *info,
 				info->tv_audio_info._Dolby._44k = 1;
 			if ((Data[i+1]&0x01))
 				info->tv_audio_info._Dolby._32k = 1;
-				info->tv_audio_info._Dolby._max_bit = Data[i+2];
+			info->tv_audio_info._Dolby._max_bit = Data[i+2];
 			break;
 
 		case 11:
@@ -695,8 +695,8 @@ static void Edid_ParsingAudioDATABlock(struct hdmitx_info *info,
 				info->tv_audio_info._DTS_HD._44k = 1;
 			if ((Data[i+1]&0x01))
 				info->tv_audio_info._DTS_HD._32k = 1;
-				info->tv_audio_info._DTS_HD._max_bit =
-					Data[i+2];
+			info->tv_audio_info._DTS_HD._max_bit =
+				Data[i+2];
 			break;
 		case 12:
 			info->tv_audio_info._MAT.support_flag = 1;
@@ -716,7 +716,7 @@ static void Edid_ParsingAudioDATABlock(struct hdmitx_info *info,
 				info->tv_audio_info._MAT._44k = 1;
 			if ((Data[i+1]&0x01))
 				info->tv_audio_info._MAT._32k = 1;
-				info->tv_audio_info._MAT._max_bit = Data[i+2];
+			info->tv_audio_info._MAT._max_bit = Data[i+2];
 			break;
 
 		case 13:
@@ -737,7 +737,7 @@ static void Edid_ParsingAudioDATABlock(struct hdmitx_info *info,
 				info->tv_audio_info._DST._44k = 1;
 			if ((Data[i+1]&0x01))
 				info->tv_audio_info._DST._32k = 1;
-				info->tv_audio_info._DST._max_bit = Data[i+2];
+			info->tv_audio_info._DST._max_bit = Data[i+2];
 			break;
 
 		case 14:
@@ -758,7 +758,7 @@ static void Edid_ParsingAudioDATABlock(struct hdmitx_info *info,
 				info->tv_audio_info._WMA._44k = 1;
 			if ((Data[i+1]&0x01))
 				info->tv_audio_info._WMA._32k = 1;
-				info->tv_audio_info._WMA._max_bit = Data[i+2];
+			info->tv_audio_info._WMA._max_bit = Data[i+2];
 			break;
 
 		default:
@@ -1035,7 +1035,7 @@ int Edid_ParsingCEADataBlockCollection(struct hdmitx_info *info,
 			if ((Addr + (Data&0x1f)) < D)
 				Edid_ParsingVideoDATABlock(info, buff,
 					Addr + 1, (Data & 0x1F));
-				break;
+			break;
 
 		case AUDIO_TAG:
 			len = (Data & 0x1f) + 1;
diff --git a/drivers/amlogic/input/sensor/l3gd20_gyr.c b/drivers/amlogic/input/sensor/l3gd20_gyr.c
index 6b80c21..2672a15 100644
--- a/drivers/amlogic/input/sensor/l3gd20_gyr.c
+++ b/drivers/amlogic/input/sensor/l3gd20_gyr.c
@@ -1781,12 +1781,12 @@ static const struct i2c_device_id l3gd20_gyr_id[] = {
 };
 
 MODULE_DEVICE_TABLE(i2c, l3gd20_gyr_id);
-
+#if 0
 static const struct dev_pm_ops l3gd20_gyr_pm = {
 	/* .suspend = l3gd20_gyr_suspend, */
 	/* .resume = l3gd20_gyr_resume, */
 };
-
+#endif
 static struct i2c_driver l3gd20_gyr_driver = {
 	.driver = {
 		.owner = THIS_MODULE,
diff --git a/drivers/amlogic/input/sensor/mm3a310.c b/drivers/amlogic/input/sensor/mm3a310.c
index 6f58a38..86641dd 100644
--- a/drivers/amlogic/input/sensor/mm3a310.c
+++ b/drivers/amlogic/input/sensor/mm3a310.c
@@ -2374,10 +2374,10 @@ static const struct i2c_device_id mm3a310_id[] = {
 };
 MODULE_DEVICE_TABLE(i2c, mm3a310_id);
 
-
+#if 0
 static const unsigned short normal_i2c[] = {
 	0x27,  0x26, I2C_CLIENT_END };
-
+#endif
 static struct i2c_driver mm3a310_driver = {
 	/*.class		= I2C_CLASS_HWMON,*/
 	.driver = {
diff --git a/drivers/amlogic/mmc/aml_sd_emmc.c b/drivers/amlogic/mmc/aml_sd_emmc.c
index 655fc37..ba4bfba 100644
--- a/drivers/amlogic/mmc/aml_sd_emmc.c
+++ b/drivers/amlogic/mmc/aml_sd_emmc.c
@@ -2851,7 +2851,7 @@ static void aml_sd_emmc_set_timing(
 		clk_div = clkc->div;
 		if (clk_div & 0x01)
 			clk_div++;
-			clkc->div = clk_div / 2;
+		clkc->div = clk_div / 2;
 		sd_emmc_regs->gclock = vclkc;
 		pdata->clkc = sd_emmc_regs->gclock;
 		pdata->mmc->actual_clock = clk_rate / clk_div;
diff --git a/drivers/amlogic/mmc/amlsd.c b/drivers/amlogic/mmc/amlsd.c
index 0c4876b..e98336b7 100644
--- a/drivers/amlogic/mmc/amlsd.c
+++ b/drivers/amlogic/mmc/amlsd.c
@@ -1444,7 +1444,7 @@ int aml_sd_voltage_switch(struct amlsd_platform *pdata, char signal_voltage)
 		|| (pdata->signal_voltage == signal_voltage)) {
 		if (aml_card_type_sdio(pdata))
 			host->sd_sdio_switch_volat_done = 1;
-			return 0;
+		return 0;
 	}
 	if (pdata->vol_switch) {
 		if (pdata->signal_voltage == 0xff) {
diff --git a/drivers/amlogic/tvin/hdmirx/hdmi_rx_wrapper.c b/drivers/amlogic/tvin/hdmirx/hdmi_rx_wrapper.c
index 5211b20..1f42974 100644
--- a/drivers/amlogic/tvin/hdmirx/hdmi_rx_wrapper.c
+++ b/drivers/amlogic/tvin/hdmirx/hdmi_rx_wrapper.c
@@ -1234,7 +1234,7 @@ static int hdmi_rx_ctrl_irq_handler(struct hdmi_rx_ctrl *ctx)
 		if (get(intr_pedc, DRM_RCV_EN | DRM_CKS_CHG) != 0) {
 			if (log_flag & 0x400)
 				rx_pr("[irq] DRM_RCV_EN %#x\n", intr_pedc);
-				drm_handle_flag = true;
+			drm_handle_flag = true;
 		}
 		/* if (get(intr_pedc, AIF_CKS_CHG) != 0) { */
 		/* if(log_flag&0x400) */
@@ -2157,9 +2157,9 @@ static int get_timing_fmt(struct hdmi_rx_ctrl_video *video_par)
 					 freq_ref[i].repeat) {
 					if (log_flag & PACKET_LOG)
 						rx_pr("\n repeat err1");
-						rx_pr("%d:%d(standard)",
-							video_par->repeat,
-							freq_ref[i].repeat);
+					rx_pr("%d:%d(standard)",
+						video_par->repeat,
+						freq_ref[i].repeat);
 					video_par->repeat =
 						freq_ref[i].repeat;
 				}
@@ -2715,7 +2715,7 @@ void edid_update(void)
 	static int step;
 	if (0 == step)
 		hdmirx_set_hpd(rx.port, 0);
-		rx.change = 1;
+	rx.change = 1;
 
 	if (2 == step)
 		hdmi_rx_ctrl_edid_update();
diff --git a/drivers/amlogic/usb/dwc_otg/310/dwc_otg_driver.c b/drivers/amlogic/usb/dwc_otg/310/dwc_otg_driver.c
index 804e1a6..4444976 100644
--- a/drivers/amlogic/usb/dwc_otg/310/dwc_otg_driver.c
+++ b/drivers/amlogic/usb/dwc_otg/310/dwc_otg_driver.c
@@ -74,8 +74,9 @@
 
 #define DWC_DRIVER_VERSION	"3.10a 12-MAY-2014"
 #define DWC_DRIVER_DESC		"HS OTG USB Controller driver"
-
+#if 0
 static const char dwc_driver_name[] = "dwc_otg";
+#endif
 extern int pcd_init(struct platform_device *pdev);
 extern int hcd_init(struct platform_device *pdev);
 extern int pcd_remove(struct platform_device *pdev);
diff --git a/drivers/hid/hid-dia-remote.c b/drivers/hid/hid-dia-remote.c
index 9f91c03..ab56882 100644
--- a/drivers/hid/hid-dia-remote.c
+++ b/drivers/hid/hid-dia-remote.c
@@ -49,7 +49,7 @@ MODULE_LICENSE("GPL v2");
 
 #define DIA_REMOTE_PCM_DEVICE_ID	"DIALOG PCM AUDIO" /* max=64 */
 #define DIA_REMOTE_PCM_DEVICE_NAME	"DIA PCM" /* max=80 */
-
+#if 0
 /* Supported devices GAP names */
 static const char * const supported_devices[] = {
 	"DA14582 M&VRemote",
@@ -59,7 +59,7 @@ static const char * const supported_devices[] = {
 	"RemoteB008",
 	"Remote"
 };
-
+#endif
 #define snd_dialog_log(...) pr_err("snd_dia: " __VA_ARGS__)
 
 
diff --git a/drivers/media/dvb-core/dvb_frontend.c b/drivers/media/dvb-core/dvb_frontend.c
index ec3d417..f40d045 100644
--- a/drivers/media/dvb-core/dvb_frontend.c
+++ b/drivers/media/dvb-core/dvb_frontend.c
@@ -619,7 +619,7 @@ static void dvb_frontend_swzigzag(struct dvb_frontend *fe)
 	} else {
 		if (fe->ops.read_status)
 			fe->ops.read_status(fe, &s);
-			time = jiffies_to_msecs(jiffies)-jiffiestime;
+		time = jiffies_to_msecs(jiffies)-jiffiestime;
 		dprintk("read status,time is %d,s is %d,status is %d\n",
 			time, s, fepriv->status);
 		if (((s != fepriv->status) && (time >= LOCK_TIMEOUT)) ||
@@ -2718,8 +2718,8 @@ static int dtv_set_frontend(struct dvb_frontend *fe)
 		fe->ops.set_frontend(fe);
 		if (c->delivery_system != SYS_ANALOG)
 			dvb_frontend_clear_events(fe);
-			dvb_frontend_add_event(fe, 0);
-			dvb_frontend_wakeup(fe);
+		dvb_frontend_add_event(fe, 0);
+		dvb_frontend_wakeup(fe);
 	}
 	fepriv->status = 0;
 
diff --git a/drivers/misc/eeprom/at24.c b/drivers/misc/eeprom/at24.c
index 3230c5b..ddf65ec 100644
--- a/drivers/misc/eeprom/at24.c
+++ b/drivers/misc/eeprom/at24.c
@@ -802,7 +802,7 @@ static struct i2c_driver at24_driver = {
 	.driver = {
 		.name = "at24",
 		.owner = THIS_MODULE,
-#ifdef CONFIG_USE_OF
+#ifdef CONFIG_OF
 		.of_match_table = at24_dt_match,
 #endif
 	},
diff --git a/drivers/net/usb/usbnet.c b/drivers/net/usb/usbnet.c
index eb103bc..f2f083a 100644
--- a/drivers/net/usb/usbnet.c
+++ b/drivers/net/usb/usbnet.c
@@ -80,9 +80,9 @@
 
 // randomly generated ethernet address
 static u8	node_id [ETH_ALEN];
-
+#if 0
 static const char driver_name [] = "usbnet";
-
+#endif
 /* use ethtool to change the level for any given device */
 static int msg_level = -1;
 module_param (msg_level, int, 0);
diff --git a/drivers/usb/gadget/android.c b/drivers/usb/gadget/android.c
index b46e089..d307f06 100644
--- a/drivers/usb/gadget/android.c
+++ b/drivers/usb/gadget/android.c
@@ -43,8 +43,9 @@ MODULE_AUTHOR("Mike Lockwood");
 MODULE_DESCRIPTION("Android Composite USB Driver");
 MODULE_LICENSE("GPL");
 MODULE_VERSION("1.0");
-
+#if 0
 static const char longname[] = "Gadget Android";
+#endif
 static struct android_dev *_android_dev;
 int android_usb_inited = 0;
 #include "f_fs.c"
diff --git a/fs/compat_ioctl.c b/fs/compat_ioctl.c
index 41bd7ae5..ea6f899 100644
--- a/fs/compat_ioctl.c
+++ b/fs/compat_ioctl.c
@@ -809,7 +809,7 @@ static int compat_ioctl_preallocate(struct file *file,
  * simple reversible transform to make our table more evenly
  * distributed after sorting.
  */
-#define XFORM(i) (((i) ^ ((i) << 27) ^ ((i) << 17)) & 0xffffffff)
+#define XFORM(i) (((i) ^ ((long)(i) << 27) ^ ((long)(i) << 17)) & 0xffffffff)
 
 #define COMPATIBLE_IOCTL(cmd) XFORM(cmd),
 /* ioctl should not be warned about even if it's not implemented.
diff --git a/fs/exfat/exfat_core.c b/fs/exfat/exfat_core.c
index cc1da5c..f737214 100644
--- a/fs/exfat/exfat_core.c
+++ b/fs/exfat/exfat_core.c
@@ -200,7 +200,7 @@ s32 ffsMountVol(struct super_block *sb)
 	if (sector_read(sb, 0, &tmp_bh, 1) != FFS_SUCCESS)
 		return FFS_MEDIAERR;
 
-		p_fs->PBR_sector = 0;
+	p_fs->PBR_sector = 0;
 
 	p_pbr = (struct PBR_SECTOR_T *) tmp_bh->b_data;
 
diff --git a/include/linux/compiler-gcc6.h b/include/linux/compiler-gcc6.h
new file mode 100644
index 0000000..cdd1cc2
--- /dev/null
+++ b/include/linux/compiler-gcc6.h
@@ -0,0 +1,66 @@
+#ifndef __LINUX_COMPILER_H
+#error "Please don't include <linux/compiler-gcc5.h> directly, include <linux/compiler.h> instead."
+#endif
+
+#define __used				__attribute__((__used__))
+#define __must_check			__attribute__((warn_unused_result))
+#define __compiler_offsetof(a, b)	__builtin_offsetof(a, b)
+
+/* Mark functions as cold. gcc will assume any path leading to a call
+   to them will be unlikely.  This means a lot of manual unlikely()s
+   are unnecessary now for any paths leading to the usual suspects
+   like BUG(), printk(), panic() etc. [but let's keep them for now for
+   older compilers]
+
+   Early snapshots of gcc 4.3 don't support this and we can't detect this
+   in the preprocessor, but we can live with this because they're unreleased.
+   Maketime probing would be overkill here.
+
+   gcc also has a __attribute__((__hot__)) to move hot functions into
+   a special section, but I don't see any sense in this right now in
+   the kernel context */
+#define __cold			__attribute__((__cold__))
+
+#define __UNIQUE_ID(prefix) __PASTE(__PASTE(__UNIQUE_ID_, prefix), __COUNTER__)
+
+#ifndef __CHECKER__
+# define __compiletime_warning(message) __attribute__((warning(message)))
+# define __compiletime_error(message) __attribute__((error(message)))
+#endif /* __CHECKER__ */
+
+/*
+ * Mark a position in code as unreachable.  This can be used to
+ * suppress control flow warnings after asm blocks that transfer
+ * control elsewhere.
+ *
+ * Early snapshots of gcc 4.5 don't support this and we can't detect
+ * this in the preprocessor, but we can live with this because they're
+ * unreleased.  Really, we need to have autoconf for the kernel.
+ */
+#define unreachable() __builtin_unreachable()
+
+/* Mark a function definition as prohibited from being cloned. */
+#define __noclone	__attribute__((__noclone__))
+
+/*
+ * Tell the optimizer that something else uses this function or variable.
+ */
+#define __visible __attribute__((externally_visible))
+
+/*
+ * GCC 'asm goto' miscompiles certain code sequences:
+ *
+ *   http://gcc.gnu.org/bugzilla/show_bug.cgi?id=58670
+ *
+ * Work it around via a compiler barrier quirk suggested by Jakub Jelinek.
+ * Fixed in GCC 4.8.2 and later versions.
+ *
+ * (asm goto is automatically volatile - the naming reflects this.)
+ */
+#define asm_volatile_goto(x...)	do { asm goto(x); asm (""); } while (0)
+
+#ifdef CONFIG_ARCH_USE_BUILTIN_BSWAP
+#define __HAVE_BUILTIN_BSWAP32__
+#define __HAVE_BUILTIN_BSWAP64__
+#define __HAVE_BUILTIN_BSWAP16__
+#endif /* CONFIG_ARCH_USE_BUILTIN_BSWAP */
diff --git a/kernel/cgroup.c b/kernel/cgroup.c
index 984ae7f..c51afc0 100644
--- a/kernel/cgroup.c
+++ b/kernel/cgroup.c
@@ -1232,11 +1232,11 @@ static int parse_cgroupfs_options(char *data, struct cgroup_sb_opts *opts)
 	 * otherwise if 'none', 'name=' and a subsystem name options
 	 * were not specified, let's default to 'all'
 	 */
-	if (all_ss || (!one_ss && !opts->none && !opts->name))
+	if (all_ss || (!one_ss && !opts->none && !opts->name)) {
 		for_each_subsys(ss, i)
 			if (!ss->disabled)
 				set_bit(i, &opts->subsys_mask);
-
+	}
 	/* Consistency checks */
 
 	if (opts->flags & CGRP_ROOT_SANE_BEHAVIOR) {
@@ -3878,7 +3878,7 @@ static int cgroup_pidlist_show(struct seq_file *s, void *v)
 {
 	return seq_printf(s, "%d\n", *(int *)v);
 }
-
+#if 0
 /*
  * seq_operations functions for iterating on pidlists through seq_file -
  * independent of whether it's tasks or procs
@@ -3889,7 +3889,7 @@ static const struct seq_operations cgroup_pidlist_seq_operations = {
 	.next = cgroup_pidlist_next,
 	.show = cgroup_pidlist_show,
 };
-
+#endif
 static u64 cgroup_read_notify_on_release(struct cgroup_subsys_state *css,
 					 struct cftype *cft)
 {
diff --git a/kernel/sched/fair.c b/kernel/sched/fair.c
index 420915c..6fd4dca 100644
--- a/kernel/sched/fair.c
+++ b/kernel/sched/fair.c
@@ -8185,20 +8185,20 @@ static int move_specific_task(struct lb_env *env, struct task_struct *pm)
 				env->dst_cpu))
 		continue;
 
-		if (!hmp_can_migrate_task(p, env))
-			continue;
-		/* Check if we found the right task */
-		if (p != pm)
-			continue;
+	if (!hmp_can_migrate_task(p, env))
+		continue;
+	/* Check if we found the right task */
+	if (p != pm)
+		continue;
 
-		move_task(p, env);
-		/*
-		 * Right now, this is only the third place move_task()
-		 * is called, so we can safely collect move_task()
-		 * stats here rather than inside move_task().
-		 */
-		schedstat_inc(env->sd, lb_gained[env->idle]);
-		return 1;
+	move_task(p, env);
+	/*
+	 * Right now, this is only the third place move_task()
+	 * is called, so we can safely collect move_task()
+	 * stats here rather than inside move_task().
+	 */
+	schedstat_inc(env->sd, lb_gained[env->idle]);
+	return 1;
 	}
 	return 0;
 }
diff --git a/kernel/trace/trace_output.c b/kernel/trace/trace_output.c
index 1083b61..dadca85 100644
--- a/kernel/trace/trace_output.c
+++ b/kernel/trace/trace_output.c
@@ -1174,7 +1174,7 @@ static enum print_line_t trace_graph_ret_raw(struct trace_iterator *iter, int fl
 			      field->ret.calltime,
 			      field->ret.rettime,
 			      field->ret.overrun,
-			      field->ret.depth));
+			      field->ret.depth))
 		return TRACE_TYPE_PARTIAL_LINE;
 
 	return TRACE_TYPE_HANDLED;
diff --git a/net/core/net-sysfs.c b/net/core/net-sysfs.c
index 9388624..68a3c2c 100644
--- a/net/core/net-sysfs.c
+++ b/net/core/net-sysfs.c
@@ -27,7 +27,9 @@
 
 #ifdef CONFIG_SYSFS
 static const char fmt_hex[] = "%#x\n";
+#if 0
 static const char fmt_long_hex[] = "%#lx\n";
+#endif
 static const char fmt_dec[] = "%d\n";
 static const char fmt_udec[] = "%u\n";
 static const char fmt_ulong[] = "%lu\n";
diff --git a/net/core/rtnetlink.c b/net/core/rtnetlink.c
index 4617586..5dd4af9 100644
--- a/net/core/rtnetlink.c
+++ b/net/core/rtnetlink.c
@@ -1258,7 +1258,7 @@ static const struct nla_policy ifla_info_policy[IFLA_INFO_MAX+1] = {
 	[IFLA_INFO_SLAVE_KIND]	= { .type = NLA_STRING },
 	[IFLA_INFO_SLAVE_DATA]	= { .type = NLA_NESTED },
 };
-
+#if 0
 static const struct nla_policy ifla_vfinfo_policy[IFLA_VF_INFO_MAX+1] = {
 	[IFLA_VF_INFO]		= { .type = NLA_NESTED },
 };
@@ -1273,7 +1273,7 @@ static const struct nla_policy ifla_vf_policy[IFLA_VF_MAX+1] = {
 	[IFLA_VF_SPOOFCHK]	= { .type = NLA_BINARY,
 				    .len = sizeof(struct ifla_vf_spoofchk) },
 };
-
+#endif
 static const struct nla_policy ifla_port_policy[IFLA_PORT_MAX+1] = {
 	[IFLA_PORT_VF]		= { .type = NLA_U32 },
 	[IFLA_PORT_PROFILE]	= { .type = NLA_STRING,
diff --git a/net/ipv4/arp.c b/net/ipv4/arp.c
index 1a9b99e..26386b8 100644
--- a/net/ipv4/arp.c
+++ b/net/ipv4/arp.c
@@ -148,7 +148,7 @@ static const struct neigh_ops arp_direct_ops = {
 	.output =		neigh_direct_output,
 	.connected_output =	neigh_direct_output,
 };
-
+#if IS_ENABLED(CONFIG_AX25)
 static const struct neigh_ops arp_broken_ops = {
 	.family =		AF_INET,
 	.solicit =		arp_solicit,
@@ -156,7 +156,7 @@ static const struct neigh_ops arp_broken_ops = {
 	.output =		neigh_compat_output,
 	.connected_output =	neigh_compat_output,
 };
-
+#endif
 struct neigh_table arp_tbl = {
 	.family		= AF_INET,
 	.key_len	= 4,
diff --git a/net/ipv4/ping.c b/net/ipv4/ping.c
index 0bb83e7..54e3e81 100644
--- a/net/ipv4/ping.c
+++ b/net/ipv4/ping.c
@@ -1133,14 +1133,14 @@ static int ping_v4_seq_show(struct seq_file *seq, void *v)
 	seq_pad(seq, '\n');
 	return 0;
 }
-
+#if 0
 static const struct seq_operations ping_v4_seq_ops = {
 	.show		= ping_v4_seq_show,
 	.start		= ping_v4_seq_start,
 	.next		= ping_seq_next,
 	.stop		= ping_seq_stop,
 };
-
+#endif
 static int ping_seq_open(struct inode *inode, struct file *file)
 {
 	struct ping_seq_afinfo *afinfo = PDE_DATA(inode);
diff --git a/sound/soc/aml/m8/aml_m8.c b/sound/soc/aml/m8/aml_m8.c
index 0c03db8..4d8be89 100644
--- a/sound/soc/aml/m8/aml_m8.c
+++ b/sound/soc/aml/m8/aml_m8.c
@@ -384,11 +384,11 @@ static const struct snd_soc_dapm_widget aml_asoc_dapm_widgets[] = {
 	SND_SOC_DAPM_MIC("MAIN MIC", NULL),
 	SND_SOC_DAPM_MIC("HEADSET MIC", NULL),
 };
-
+#if 0
 static const struct snd_kcontrol_new aml_asoc_controls[] = {
 	SOC_DAPM_PIN_SWITCH("Ext Spk"),
 };
-
+#endif
 static struct snd_soc_jack_pin jack_pins[] = {
 	{
 	 .pin = "HP",
-- 
1.7.9.5

