From 3a1e0a39772c8ecc3cb648df0f4e0f5f86ed0eb6 Mon Sep 17 00:00:00 2001
From: Dezhi Kong <dezhi.kong@amlogic.com>
Date: Fri, 22 Feb 2019 16:37:59 +0800
Subject: [PATCH] drm: workaround for 1080p scale to 4k [1/1]

PD#SWPL-4913

Problem:
drm not support 4k mode

Solution:
add workaround for 1080p scale to 4k

Verify:
verify on S905D2_U200 board

Change-Id: I4fa6ef351a95cb48bedcc966d867e453b2d5fca5
Signed-off-by: Dezhi Kong <dezhi.kong@amlogic.com>
---
 drivers/amlogic/drm/am_meson_hdmi.c | 19 ++++++++++++++++++-
 drivers/amlogic/drm/am_meson_vpu.c  | 15 +++++++++++++--
 2 files changed, 31 insertions(+), 3 deletions(-)

diff --git a/drivers/amlogic/drm/am_meson_hdmi.c b/drivers/amlogic/drm/am_meson_hdmi.c
index a2efd9c41972..0a7ab158bd88 100644
--- a/drivers/amlogic/drm/am_meson_hdmi.c
+++ b/drivers/amlogic/drm/am_meson_hdmi.c
@@ -218,6 +218,23 @@ static void am_hdmi_connector_destroy(struct drm_connector *connector)
 	drm_connector_cleanup(connector);
 }
 
+static int am_fill_modes(struct drm_connector *connector,
+			  uint32_t maxX, uint32_t maxY)
+{
+	struct drm_display_mode *mode;
+	int count = 0;
+
+	count = drm_helper_probe_single_connector_modes(connector, maxX, maxY);
+	/*work around for 1080 to 4k support*/
+	list_for_each_entry(mode, &connector->modes, head) {
+		if (mode->vdisplay == 2160) {
+			mode->vdisplay = 1080;
+			mode->hdisplay = 1920;
+		}
+	}
+	return count;
+}
+
 static const
 struct drm_connector_helper_funcs am_hdmi_connector_helper_funcs = {
 	.get_modes = am_hdmi_tx_get_modes,
@@ -228,7 +245,7 @@ struct drm_connector_helper_funcs am_hdmi_connector_helper_funcs = {
 static const struct drm_connector_funcs am_hdmi_connector_funcs = {
 	.dpms			= drm_atomic_helper_connector_dpms,
 	.detect			= am_hdmi_connector_detect,
-	.fill_modes		= drm_helper_probe_single_connector_modes,
+	.fill_modes		= am_fill_modes,
 	.set_property		= am_hdmi_connector_set_property,
 	.atomic_get_property	= am_hdmi_connector_atomic_get_property,
 	.destroy		= am_hdmi_connector_destroy,
diff --git a/drivers/amlogic/drm/am_meson_vpu.c b/drivers/amlogic/drm/am_meson_vpu.c
index 198d6b686995..3e1dcc60bcc7 100644
--- a/drivers/amlogic/drm/am_meson_vpu.c
+++ b/drivers/amlogic/drm/am_meson_vpu.c
@@ -392,6 +392,12 @@ void am_osd_do_display(
 				fb->flags, fb->pixel_format, state->zpos);
 	DRM_INFO("plane index=%d, type=%d\n", plane->index, plane->type);
 	#endif
+	if (amcrtc->base.mode.vtotal > 2160) {
+		plane_map.dst_x *= 2;
+		plane_map.dst_y *= 2;
+		plane_map.dst_w *= 2;
+		plane_map.dst_h *= 2;
+	}
 
 	spin_lock_irqsave(&amcrtc->vblank_irq_lock, flags);
 	osd_drm_plane_page_flip(&plane_map);
@@ -495,7 +501,13 @@ char *am_meson_crtc_get_voutmode(struct drm_display_mode *mode)
 		return "panel";
 
 	for (i = 0; i < ARRAY_SIZE(am_vout_modes); i++) {
-		if ((am_vout_modes[i].width == mode->hdisplay)
+		if (mode->htotal > 3840) {
+			if ((am_vout_modes[i].height == 2160)
+			&& (am_vout_modes[i].vrefresh == mode->vrefresh)
+			&& (am_vout_modes[i].flags ==
+				(mode->flags&DRM_MODE_FLAG_INTERLACE)))
+			return am_vout_modes[i].name;
+		} else if ((am_vout_modes[i].width == mode->hdisplay)
 			&& (am_vout_modes[i].height == mode->vdisplay)
 			&& (am_vout_modes[i].vrefresh == mode->vrefresh)
 			&& (am_vout_modes[i].flags ==
@@ -915,7 +927,6 @@ static int am_meson_vpu_probe(struct platform_device *pdev)
 		dev_err(dev, "%s NOT match\n", __func__);
 		return -ENODEV;
 	}
-
 	return component_add(dev, &am_meson_vpu_component_ops);
 }
 
-- 
2.11.0

