From a61a1fc2be5cb159251b5270ada341df52bac393 Mon Sep 17 00:00:00 2001
From: Dezhi Kong <dezhi.kong@amlogic.com>
Date: Fri, 27 Dec 2019 18:17:52 +0800
Subject: [PATCH 3/5] drm: add video overlay support [1/1]

PD#SWPL-13818

Problem:
drm have not support video overlay

Solution:
add video overlay

Verify:
verify by u212

Change-Id: I7e1391cfea51d1b4b420c9296a75dbe65c6ba5da
Signed-off-by: Dezhi Kong <dezhi.kong@amlogic.com>
---
 MAINTAINERS                                   |   5 +
 arch/arm/boot/dts/amlogic/mesong12a_drm.dtsi  |   8 +
 arch/arm/boot/dts/amlogic/mesontm2_drm.dtsi   |   8 +
 .../arm64/boot/dts/amlogic/mesong12a_drm.dtsi |   8 +
 arch/arm64/boot/dts/amlogic/mesontm2_drm.dtsi |   8 +
 drivers/amlogic/drm/Makefile                  |   1 +
 drivers/amlogic/drm/meson_drv.h               |  22 +-
 drivers/amlogic/drm/meson_fb.c                |  37 +-
 drivers/amlogic/drm/meson_fb.h                |   2 +-
 drivers/amlogic/drm/meson_plane.c             | 394 ++++++++++++++++--
 drivers/amlogic/drm/meson_plane.h             |   9 +
 drivers/amlogic/drm/meson_vpu.c               |  96 ++++-
 drivers/amlogic/drm/meson_vpu_pipeline.c      |  18 +
 drivers/amlogic/drm/meson_vpu_pipeline.h      |  68 +++
 .../amlogic/drm/meson_vpu_pipeline_private.c  |  79 +++-
 .../amlogic/drm/meson_vpu_pipeline_traverse.c |  65 ++-
 drivers/amlogic/drm/meson_vpu_util.h          |   2 +-
 .../amlogic/drm/vpu-hw/meson_vpu_video_mif.c  | 209 ++++++++++
 .../amlogic/drm/vpu-hw/meson_vpu_video_mif.h  |  23 +
 include/dt-bindings/display/meson-drm-ids.h   |   6 +-
 include/uapi/drm/drm_fourcc.h                 |   5 +
 21 files changed, 989 insertions(+), 84 deletions(-)
 create mode 100644 drivers/amlogic/drm/vpu-hw/meson_vpu_video_mif.c
 create mode 100644 drivers/amlogic/drm/vpu-hw/meson_vpu_video_mif.h

diff --git a/MAINTAINERS b/MAINTAINERS
index 4ccf24d88e92..7b36a04bfa17 100644
--- a/MAINTAINERS
+++ b/MAINTAINERS
@@ -15244,3 +15244,8 @@ F: drivers/amlogic/mailbox/scpi_protocol_dsp.c
 AMLOGIC SM1/G12A BL40 HEADER
 M: shunzhou jiang <shunzhou.jiang@amlogic.com>
 F: drivers/amlogic/firmware/bl40_module.h
+
+AMLOGIC DRM DRIVER
+M:  Dezhi Kong <dezhi.kong@amlogic.com>
+F:  drivers/amlogic/drm/vpu-hw/meson_vpu_video_mif.c
+F:  drivers/amlogic/drm/vpu-hw/meson_vpu_video_mif.h
diff --git a/arch/arm/boot/dts/amlogic/mesong12a_drm.dtsi b/arch/arm/boot/dts/amlogic/mesong12a_drm.dtsi
index ceb57254b3e3..dfabc81c297e 100644
--- a/arch/arm/boot/dts/amlogic/mesong12a_drm.dtsi
+++ b/arch/arm/boot/dts/amlogic/mesong12a_drm.dtsi
@@ -225,6 +225,14 @@
 						<1 &osd_blend_block>;
 					num_out_links = <0x0>;
 				};
+				video1_block: block@13 {
+					id = /bits/ 8 <VIDEO1_BLOCK>;
+					index = /bits/ 8  <0>;
+					type = /bits/ 8  <7>;
+					block_name = "video1_block";
+					num_in_links = /bits/ 8  <0x0>;
+					num_out_links = /bits/ 8  <0x0>;
+				};
 			};
 		};
 
diff --git a/arch/arm/boot/dts/amlogic/mesontm2_drm.dtsi b/arch/arm/boot/dts/amlogic/mesontm2_drm.dtsi
index b9ee40619322..0c753f87aace 100644
--- a/arch/arm/boot/dts/amlogic/mesontm2_drm.dtsi
+++ b/arch/arm/boot/dts/amlogic/mesontm2_drm.dtsi
@@ -225,6 +225,14 @@
 						<1 &osd_blend_block>;
 					num_out_links = <0x0>;
 				};
+				video1_block: block@13 {
+					id = /bits/ 8 <VIDEO1_BLOCK>;
+					index = /bits/ 8  <0>;
+					type = /bits/ 8  <7>;
+					block_name = "video1_block";
+					num_in_links = /bits/ 8  <0x0>;
+					num_out_links = /bits/ 8  <0x0>;
+				};
 			};
 		};
 
diff --git a/arch/arm64/boot/dts/amlogic/mesong12a_drm.dtsi b/arch/arm64/boot/dts/amlogic/mesong12a_drm.dtsi
index 175af5817592..df62a55de99b 100644
--- a/arch/arm64/boot/dts/amlogic/mesong12a_drm.dtsi
+++ b/arch/arm64/boot/dts/amlogic/mesong12a_drm.dtsi
@@ -225,6 +225,14 @@
 						<1 &osd_blend_block>;
 					num_out_links = <0x0>;
 				};
+				video1_block: block@13 {
+					id = /bits/ 8 <VIDEO1_BLOCK>;
+					index = /bits/ 8  <0>;
+					type = /bits/ 8  <7>;
+					block_name = "video1_block";
+					num_in_links = /bits/ 8  <0x0>;
+					num_out_links = /bits/ 8  <0x0>;
+				};
 			};
 		};
 
diff --git a/arch/arm64/boot/dts/amlogic/mesontm2_drm.dtsi b/arch/arm64/boot/dts/amlogic/mesontm2_drm.dtsi
index b9ee40619322..0c753f87aace 100644
--- a/arch/arm64/boot/dts/amlogic/mesontm2_drm.dtsi
+++ b/arch/arm64/boot/dts/amlogic/mesontm2_drm.dtsi
@@ -225,6 +225,14 @@
 						<1 &osd_blend_block>;
 					num_out_links = <0x0>;
 				};
+				video1_block: block@13 {
+					id = /bits/ 8 <VIDEO1_BLOCK>;
+					index = /bits/ 8  <0>;
+					type = /bits/ 8  <7>;
+					block_name = "video1_block";
+					num_in_links = /bits/ 8  <0x0>;
+					num_out_links = /bits/ 8  <0x0>;
+				};
 			};
 		};
 
diff --git a/drivers/amlogic/drm/Makefile b/drivers/amlogic/drm/Makefile
index 022ca0b8385d..65a249bcedea 100644
--- a/drivers/amlogic/drm/Makefile
+++ b/drivers/amlogic/drm/Makefile
@@ -24,6 +24,7 @@ meson-drm-y += meson_drv.o meson_plane.o meson_vpu_pipeline_traverse.o \
 		meson_debugfs.o	meson_vpu_util.o \
 
 meson-drm-y += \
+                vpu-hw/meson_vpu_video_mif.o \
                 vpu-hw/meson_vpu_osd_mif.o \
                 vpu-hw/meson_osd_afbc.o \
                 vpu-hw/meson_osd_scaler.o \
diff --git a/drivers/amlogic/drm/meson_drv.h b/drivers/amlogic/drm/meson_drv.h
index 3e35f272e091..2716ec396bb5 100644
--- a/drivers/amlogic/drm/meson_drv.h
+++ b/drivers/amlogic/drm/meson_drv.h
@@ -18,6 +18,7 @@
 #ifndef __AM_MESON_DRV_H
 #define __AM_MESON_DRV_H
 
+#include <linux/kfifo.h>
 #include <linux/platform_device.h>
 #include <linux/of.h>
 #include <drm/drmP.h>
@@ -25,8 +26,16 @@
 #include <ion/ion_priv.h>
 #endif
 
+#include <linux/amlogic/media/vfm/vframe.h>
+#include <linux/amlogic/media/vfm/vframe_provider.h>
+#include <linux/amlogic/media/vfm/vframe_receiver.h>
+#include <linux/amlogic/media/vfm/vfm_ext.h>
+
 #define MESON_MAX_CRTC		2
 #define MESON_MAX_OSD		4
+#define MESON_MAX_VIDEO		2
+#define VP_MAP_STRUCT_SIZE	120
+#define BUFFER_NUM		4
 
 /*
  * Amlogic drm private crtc funcs.
@@ -52,6 +61,13 @@ struct meson_drm {
 	struct drm_plane *primary_plane;
 	struct drm_plane *cursor_plane;
 	struct drm_property_blob *gamma_lut_blob;
+	struct vframe_provider_s vprov;
+	char vfm_map_id[VP_MAP_STRUCT_SIZE];
+	char vfm_map_chain[VP_MAP_STRUCT_SIZE];
+	DECLARE_KFIFO(ready_q, struct vframe_s *, BUFFER_NUM);
+	DECLARE_KFIFO(free_q, struct vframe_s *, BUFFER_NUM);
+	DECLARE_KFIFO(display_q, struct vframe_s *, BUFFER_NUM);
+	struct vframe_s vframe[BUFFER_NUM];
 
 #ifdef CONFIG_DRM_MESON_USE_ION
 	struct ion_client *gem_client;
@@ -66,6 +82,8 @@ struct meson_drm {
 
 	u32 num_planes;
 	struct am_osd_plane *planes[MESON_MAX_OSD];
+	struct am_video_plane *video_planes[MESON_MAX_VIDEO];
+	u32 video_path_reg;
 };
 
 static inline int meson_vpu_is_compatible(struct meson_drm *priv,
@@ -74,9 +92,9 @@ static inline int meson_vpu_is_compatible(struct meson_drm *priv,
 	return of_device_is_compatible(priv->dev->of_node, compat);
 }
 
-extern int am_meson_register_crtc_funcs(struct drm_crtc *crtc,
+int am_meson_register_crtc_funcs(struct drm_crtc *crtc,
 				 const struct meson_crtc_funcs *crtc_funcs);
-extern void am_meson_unregister_crtc_funcs(struct drm_crtc *crtc);
+void am_meson_unregister_crtc_funcs(struct drm_crtc *crtc);
 struct drm_connector *am_meson_hdmi_connector(void);
 
 #ifdef CONFIG_DEBUG_FS
diff --git a/drivers/amlogic/drm/meson_fb.c b/drivers/amlogic/drm/meson_fb.c
index 81fc0981c595..0a16a395c502 100644
--- a/drivers/amlogic/drm/meson_fb.c
+++ b/drivers/amlogic/drm/meson_fb.c
@@ -24,7 +24,7 @@ void am_meson_fb_destroy(struct drm_framebuffer *fb)
 {
 	struct am_meson_fb *meson_fb = to_am_meson_fb(fb);
 
-	drm_gem_object_unreference_unlocked(&meson_fb->bufp->base);
+	drm_gem_object_unreference_unlocked(&meson_fb->bufp[0]->base);
 	drm_framebuffer_cleanup(fb);
 	if (meson_fb->logo && meson_fb->logo->alloc_flag)
 		am_meson_free_logo_memory();
@@ -39,7 +39,7 @@ int am_meson_fb_create_handle(struct drm_framebuffer *fb,
 	struct am_meson_fb *meson_fb = to_am_meson_fb(fb);
 
 	return drm_gem_handle_create(file_priv,
-				     &meson_fb->bufp->base, handle);
+				     &meson_fb->bufp[0]->base, handle);
 }
 
 struct drm_framebuffer_funcs am_meson_fb_funcs = {
@@ -62,9 +62,9 @@ am_meson_fb_alloc(struct drm_device *dev,
 
 	if (obj) {
 		meson_gem = container_of(obj, struct am_meson_gem_object, base);
-		meson_fb->bufp = meson_gem;
+		meson_fb->bufp[0] = meson_gem;
 	} else {
-		meson_fb->bufp = NULL;
+		meson_fb->bufp[0] = NULL;
 	}
 	drm_helper_mode_fill_fb_struct(&meson_fb->base, mode_cmd);
 
@@ -75,10 +75,10 @@ am_meson_fb_alloc(struct drm_device *dev,
 			ret);
 		goto err_free_fb;
 	}
-	DRM_INFO("meson_fb[id:%d,ref:%d]=0x%p,meson_fb->bufp=0x%p\n",
+	DRM_INFO("meson_fb[id:%d,ref:%d]=0x%p,meson_fb->bufp[0]=0x%p\n",
 		 meson_fb->base.base.id,
 		 atomic_read(&meson_fb->base.base.refcount.refcount),
-		 meson_fb, meson_fb->bufp);
+		 meson_fb, meson_fb->bufp[0]);
 
 	return &meson_fb->base;
 
@@ -94,23 +94,24 @@ struct drm_framebuffer *am_meson_fb_create(struct drm_device *dev,
 	struct am_meson_fb *meson_fb = 0;
 	struct drm_gem_object *obj = 0;
 	struct am_meson_gem_object *meson_gem;
-	int ret;
+	int ret, i;
 
 	meson_fb = kzalloc(sizeof(*meson_fb), GFP_KERNEL);
 	if (!meson_fb)
 		return ERR_PTR(-ENOMEM);
 
-	/* only support one handle now.*/
-	obj = drm_gem_object_lookup(file_priv, mode_cmd->handles[0]);
-	if (!obj) {
-		dev_err(dev->dev, "Failed to lookup GEM handle\n");
-		kfree(meson_fb);
-		return ERR_PTR(-ENOMEM);
+	/* support multi handle .*/
+	for (i = 0; i < 4 && mode_cmd->handles[i]; i++) {
+		obj = drm_gem_object_lookup(file_priv, mode_cmd->handles[i]);
+		if (!obj) {
+			dev_err(dev->dev, "Failed to lookup GEM handle\n");
+			kfree(meson_fb);
+			return ERR_PTR(-ENOMEM);
+		}
+		meson_gem = container_of(obj, struct am_meson_gem_object, base);
+		meson_fb->bufp[i] = meson_gem;
 	}
 
-	meson_gem = container_of(obj, struct am_meson_gem_object, base);
-	meson_fb->bufp = meson_gem;
-
 	drm_helper_mode_fill_fb_struct(&meson_fb->base, mode_cmd);
 
 	ret = drm_framebuffer_init(dev, &meson_fb->base, &am_meson_fb_funcs);
@@ -122,10 +123,10 @@ struct drm_framebuffer *am_meson_fb_create(struct drm_device *dev,
 		kfree(meson_fb);
 		return ERR_PTR(ret);
 	}
-	DRM_DEBUG("meson_fb[in:%d,ref:%d]=0x%px,meson_fb->bufp=0x%p\n",
+	DRM_DEBUG("meson_fb[in:%d,ref:%d]=0x%px,meson_fb->bufp[0]=0x%p\n",
 		  meson_fb->base.base.id,
 		  atomic_read(&meson_fb->base.base.refcount.refcount),
-		  meson_fb, meson_fb->bufp);
+		  meson_fb, meson_fb->bufp[0]);
 
 	return &meson_fb->base;
 }
diff --git a/drivers/amlogic/drm/meson_fb.h b/drivers/amlogic/drm/meson_fb.h
index 0226ee765899..ec82eab4ed16 100644
--- a/drivers/amlogic/drm/meson_fb.h
+++ b/drivers/amlogic/drm/meson_fb.h
@@ -43,7 +43,7 @@ struct am_meson_logo {
 
 struct am_meson_fb {
 	struct drm_framebuffer base;
-	struct am_meson_gem_object *bufp;
+	struct am_meson_gem_object *bufp[4];
 	struct am_meson_logo *logo;
 };
 
diff --git a/drivers/amlogic/drm/meson_plane.c b/drivers/amlogic/drm/meson_plane.c
index 2c5820641ccb..53c5a6309421 100644
--- a/drivers/amlogic/drm/meson_plane.c
+++ b/drivers/amlogic/drm/meson_plane.c
@@ -36,12 +36,27 @@ static const u32 supported_drm_formats[] = {
 	DRM_FORMAT_ARGB4444,
 };
 
+static const u32 video_supported_drm_formats[] = {
+	DRM_FORMAT_NV12,
+	DRM_FORMAT_NV21,
+	DRM_FORMAT_YUYV,
+	DRM_FORMAT_YVYU
+};
+
 static u64 afbc_wb_modifier[] = {
 	DRM_FORMAT_MOD_MESON_AFBC_WB,
 	DRM_FORMAT_MOD_LINEAR,
 	DRM_FORMAT_MOD_INVALID
 };
 
+static u64 video_wb_modifier[] = {
+	DRM_FORMAT_MOD_MESON_YUV444_8BIT_WB,
+	DRM_FORMAT_MOD_MESON_YUV422_10BIT_WB,
+	DRM_FORMAT_MOD_MESON_YUV422_12BIT_WB,
+	DRM_FORMAT_MOD_MESON_YUV444_10BIT_WB,
+	DRM_FORMAT_MOD_INVALID
+};
+
 static void
 meson_plane_position_calc(struct meson_vpu_osd_layer_info *plane_info,
 			  struct drm_plane_state *state,
@@ -50,10 +65,80 @@ meson_plane_position_calc(struct meson_vpu_osd_layer_info *plane_info,
 	u32 dst_w, dst_h, src_w, src_h, scan_mode_out;
 	struct drm_display_mode *mode;
 
-	if (IS_ERR_OR_NULL(state->crtc))
-		mode = disp_mode;
+	if (!IS_ERR_OR_NULL(state->crtc) && state->crtc->mode.hdisplay &&
+	    state->crtc->mode.vdisplay)
+		mode = &state->crtc->mode;
 	else
+		mode = disp_mode;
+
+	scan_mode_out = mode->flags & DRM_MODE_FLAG_INTERLACE;
+	plane_info->src_x = state->src_x;
+	plane_info->src_y = state->src_y;
+	plane_info->src_w = (state->src_w >> 16) & 0xffff;
+	plane_info->src_h = (state->src_h >> 16) & 0xffff;
+
+	plane_info->dst_x = state->crtc_x;
+	plane_info->dst_y = state->crtc_y;
+	plane_info->dst_w = state->crtc_w;
+	plane_info->dst_h = state->crtc_h;
+	if (scan_mode_out) {
+		plane_info->dst_y >>= 1;
+		plane_info->dst_h >>= 1;
+	}
+	/*negative position process*/
+	if (state->crtc_x < 0) {
+		dst_w = state->crtc_w + state->crtc_x;
+		if (dst_w > 0) {
+			src_w = plane_info->src_w * dst_w / state->crtc_w;
+			plane_info->src_x = plane_info->src_w - src_w;
+			plane_info->src_w = src_w;
+			plane_info->dst_w = dst_w;
+			plane_info->dst_x = 0;
+		} else {
+			plane_info->enable = 0;
+		}
+	}
+	if (state->crtc_y < 0) {
+		dst_h = state->crtc_h + state->crtc_y;
+		if (dst_h > 0) {
+			src_h = plane_info->src_h * dst_h / state->crtc_h;
+			plane_info->src_y = plane_info->src_h - src_h;
+			plane_info->src_h = src_h;
+			plane_info->dst_h = dst_h;
+			plane_info->dst_y = 0;
+		} else {
+			plane_info->enable = 0;
+		}
+	}
+	/*overdisplay process*/
+	if ((plane_info->dst_x + plane_info->dst_w) > mode->hdisplay) {
+		if (plane_info->dst_x >= mode->hdisplay)
+			plane_info->enable = 0;
+		else
+			plane_info->dst_w =
+				mode->hdisplay - plane_info->dst_x;
+	}
+	if ((plane_info->dst_y + plane_info->dst_h) > mode->vdisplay) {
+		if (plane_info->dst_y >= mode->vdisplay)
+			plane_info->enable = 0;
+		else
+			plane_info->dst_h = mode->vdisplay - plane_info->dst_y;
+	}
+}
+
+static void
+meson_video_plane_position_calc(struct meson_vpu_video_layer_info *plane_info,
+				struct drm_plane_state *state,
+			  struct drm_display_mode *disp_mode)
+{
+	u32 dst_w, dst_h, src_w, src_h, scan_mode_out;
+	struct drm_display_mode *mode;
+
+	if (!IS_ERR_OR_NULL(state->crtc) && state->crtc->mode.hdisplay &&
+	    state->crtc->mode.vdisplay)
 		mode = &state->crtc->mode;
+	else
+		mode = disp_mode;
 
 	scan_mode_out = mode->flags & DRM_MODE_FLAG_INTERLACE;
 	plane_info->src_x = state->src_x;
@@ -108,6 +193,8 @@ meson_plane_position_calc(struct meson_vpu_osd_layer_info *plane_info,
 		else
 			plane_info->dst_h = mode->vdisplay - plane_info->dst_y;
 	}
+	DRM_DEBUG("mode->hdisplay=%d, mode->vdisplay=%d\n",
+		  mode->hdisplay, mode->vdisplay);
 }
 
 static int
@@ -169,8 +256,9 @@ static int meson_plane_fb_check(struct drm_plane *plane,
 	    meson_fb->logo->start) {
 		phyaddr = meson_fb->logo->start;
 		DRM_DEBUG("logo->phyaddr=0x%pa\n", &phyaddr);
-	} else  if (meson_fb->bufp) {
-		phyaddr = am_meson_gem_object_get_phyaddr(drv, meson_fb->bufp);
+	} else  if (meson_fb->bufp[0]) {
+		phyaddr = am_meson_gem_object_get_phyaddr(drv,
+							  meson_fb->bufp[0]);
 	} else {
 		phyaddr = 0;
 		DRM_INFO("don't find phyaddr!\n");
@@ -193,6 +281,63 @@ static int meson_plane_fb_check(struct drm_plane *plane,
 	return 0;
 }
 
+static int meson_video_plane_fb_check(struct drm_plane *plane,
+				      struct drm_plane_state *new_state,
+				struct meson_vpu_video_layer_info *plane_info)
+{
+	struct drm_framebuffer *fb = new_state->fb;
+	#ifdef CONFIG_DRM_MESON_USE_ION
+	struct am_video_plane *video_plane = to_am_video_plane(plane);
+	struct meson_drm *drv = video_plane->drv;
+	struct am_meson_fb *meson_fb;
+	#else
+	struct drm_gem_cma_object *gem;
+	#endif
+	phys_addr_t phyaddr, phyaddr1 = 0;
+
+	#ifdef CONFIG_DRM_MESON_USE_ION
+	meson_fb = container_of(fb, struct am_meson_fb, base);
+	if (!meson_fb) {
+		DRM_INFO("meson_fb is NULL!\n");
+		return -EINVAL;
+	}
+	DRM_DEBUG("meson_fb[id:%d,ref:%d]=0x%p\n",
+		  meson_fb->base.base.id,
+		  atomic_read(&meson_fb->base.base.refcount.refcount),
+		  meson_fb);
+	if (meson_fb->bufp[0]) {
+		phyaddr = am_meson_gem_object_get_phyaddr(drv,
+							  meson_fb->bufp[0]);
+	} else {
+		phyaddr = 0;
+		DRM_INFO("don't find phyaddr!\n");
+		return -EINVAL;
+	}
+	if (meson_fb->bufp[1] && meson_fb->bufp[1] != meson_fb->bufp[0] &&
+	    (fb->pixel_format == DRM_FORMAT_NV12 ||
+				  fb->pixel_format == DRM_FORMAT_NV21))
+		phyaddr1 = am_meson_gem_object_get_phyaddr(drv,
+							   meson_fb->bufp[1]);
+	else
+		DRM_INFO("don't find phyaddr1 for NV21/NV12!\n");
+	#else
+	if (!fb) {
+		DRM_INFO("fb is NULL!\n");
+		return -EINVAL;
+	}
+	/* Update Canvas with buffer address */
+	gem = drm_fb_cma_get_gem_obj(fb, 0);
+	if (!gem) {
+		DRM_INFO("gem is NULL!\n");
+		return -EINVAL;
+	}
+	phyaddr = gem->paddr;
+	#endif
+	plane_info->phy_addr[0] = phyaddr;
+	plane_info->phy_addr[1] = phyaddr1;
+	return 0;
+}
+
 static int meson_plane_get_fb_info(struct drm_plane *plane,
 				   struct drm_plane_state *new_state,
 				   struct meson_vpu_osd_layer_info *plane_info)
@@ -233,21 +378,77 @@ static int meson_plane_get_fb_info(struct drm_plane *plane,
 	};
 
 	DRM_DEBUG("flags:%d pixel_format:%d,modifer=%llu\n",
-				fb->flags, fb->pixel_format,
+		  fb->flags, fb->pixel_format,
 				fb->modifier);
 	DRM_DEBUG("plane afbc_en=%u, afbc_inter_format=%x\n",
-		plane_info->afbc_en, plane_info->afbc_inter_format);
+		  plane_info->afbc_en, plane_info->afbc_inter_format);
 
 	DRM_DEBUG("phy_addr=0x%x,byte_stride=%d,pixel_format=%d\n",
-		plane_info->phy_addr, plane_info->byte_stride,
+		  plane_info->phy_addr, plane_info->byte_stride,
+		  plane_info->pixel_format);
+	DRM_DEBUG("plane_index %d, size %d.\n",
+		  osd_plane->plane_index,
+		  plane_info->fb_size);
+	return 0;
+}
+
+static int meson_video_plane_get_fb_info(struct drm_plane *plane,
+					 struct drm_plane_state *new_state,
+			struct meson_vpu_video_layer_info *plane_info)
+{
+	struct am_video_plane *video_plane = to_am_video_plane(plane);
+	struct drm_framebuffer *fb = new_state->fb;
+	struct meson_drm *drv = video_plane->drv;
+
+	if (!drv) {
+		DRM_INFO("%s new_state/meson_drm is NULL!\n", __func__);
+		return -EINVAL;
+	}
+	if (video_plane->plane_index >= MESON_MAX_VIDEO) {
+		DRM_INFO("%s invalid plane_index!\n", __func__);
+		return -EINVAL;
+	}
+	plane_info->pixel_format = fb->pixel_format;
+	plane_info->byte_stride = fb->pitches[0];
+
+	/*setup afbc info*/
+	switch (fb->modifier) {
+	case DRM_FORMAT_MOD_MESON_AFBC:
+		plane_info->afbc_en = 1;
+		plane_info->afbc_inter_format = AFBC_EN;
+		break;
+	case DRM_FORMAT_MOD_MESON_AFBC_WB:
+		plane_info->afbc_en = 1;
+		plane_info->afbc_inter_format = AFBC_EN |
+			YUV_TRANSFORM | BLOCK_SPLIT |
+			SUPER_BLOCK_ASPECT;
+		break;
+	case DRM_FORMAT_MOD_INVALID:
+	case DRM_FORMAT_MOD_LINEAR:
+	default:
+		plane_info->afbc_en = 0;
+		plane_info->afbc_inter_format = 0;
+		break;
+	};
+
+	DRM_DEBUG("flags:%d pixel_format:%d,modifer=%llu\n",
+		  fb->flags, fb->pixel_format,
+				fb->modifier);
+	DRM_DEBUG("plane afbc_en=%u, afbc_inter_format=%x\n",
+		  plane_info->afbc_en, plane_info->afbc_inter_format);
+
+	DRM_DEBUG("phy_addr[0]=0x%x,byte_stride=%d,pixel_format=%d\n",
+		  plane_info->phy_addr[0], plane_info->byte_stride,
 		plane_info->pixel_format);
-	DRM_DEBUG("plane_index %d, size %d.\n", osd_plane->plane_index,
-							plane_info->fb_size);
+	DRM_DEBUG("phy_addr[1]=0x%x, plane_index %d, size %d.\n",
+		  plane_info->phy_addr[1],
+		  video_plane->plane_index,
+		  plane_info->fb_size);
 	return 0;
 }
 
 static int meson_plane_atomic_get_property(struct drm_plane *plane,
-					const struct drm_plane_state *state,
+					   const struct drm_plane_state *state,
 					struct drm_property *property,
 					uint64_t *val)
 {
@@ -262,7 +463,7 @@ static int meson_plane_atomic_get_property(struct drm_plane *plane,
 }
 
 static int meson_plane_atomic_set_property(struct drm_plane *plane,
-					 struct drm_plane_state *state,
+					   struct drm_plane_state *state,
 					 struct drm_property *property,
 					 uint64_t val)
 {
@@ -287,18 +488,18 @@ meson_plane_duplicate_state(struct drm_plane *plane)
 
 	old_plane_state = to_am_meson_plane_state(plane->state);
 	meson_plane_state = kmemdup(old_plane_state,
-		sizeof(*meson_plane_state), GFP_KERNEL);
+				    sizeof(*meson_plane_state), GFP_KERNEL);
 	if (!meson_plane_state)
 		return NULL;
 
 	__drm_atomic_helper_plane_duplicate_state(plane,
-		&meson_plane_state->base);
+						  &meson_plane_state->base);
 
 	return &meson_plane_state->base;
 }
 
 static void meson_plane_destroy_state(struct drm_plane *plane,
-					   struct drm_plane_state *state)
+				      struct drm_plane_state *state)
 {
 	struct am_meson_plane_state *amps;
 
@@ -349,6 +550,18 @@ static const struct drm_plane_funcs am_osd_plane_funs = {
 	.format_mod_supported = am_meson_vpu_check_format_mod,
 };
 
+static const struct drm_plane_funcs am_video_plane_funs = {
+	.update_plane		= drm_atomic_helper_update_plane,
+	.disable_plane		= drm_atomic_helper_disable_plane,
+	.destroy		= drm_plane_cleanup,
+	.reset			= drm_atomic_helper_plane_reset,
+	.atomic_duplicate_state = meson_plane_duplicate_state,
+	.atomic_destroy_state	= meson_plane_destroy_state,
+	.atomic_set_property = meson_plane_atomic_set_property,
+	.atomic_get_property = meson_plane_atomic_get_property,
+	.format_mod_supported = am_meson_vpu_check_format_mod,
+};
+
 static int meson_plane_prepare_fb(struct drm_plane *plane,
 				  struct drm_plane_state *new_state)
 {
@@ -358,20 +571,19 @@ static int meson_plane_prepare_fb(struct drm_plane *plane,
 static void meson_plane_cleanup_fb(struct drm_plane *plane,
 				   struct drm_plane_state *old_state)
 {
-	struct am_osd_plane *osd_plane = to_am_osd_plane(plane);
+	//struct am_osd_plane *osd_plane = to_am_osd_plane(plane);
 
-	DRM_DEBUG("osd %d.\n", osd_plane->plane_index);
+	//DRM_DEBUG("osd %d.\n", osd_plane->plane_index);
 }
 
 static void meson_plane_atomic_update(struct drm_plane *plane,
 				      struct drm_plane_state *old_state)
 {
-
 	DRM_DEBUG("plane atomic_update.\n");
 }
 
 static int meson_plane_atomic_check(struct drm_plane *plane,
-		struct drm_plane_state *state)
+				    struct drm_plane_state *state)
 {
 	struct meson_vpu_osd_layer_info *plane_info;
 	struct meson_vpu_pipeline_state *mvps;
@@ -399,14 +611,14 @@ static int meson_plane_atomic_check(struct drm_plane *plane,
 	if (ret < 0) {
 		plane_info->enable = 0;
 		DRM_INFO("plane%d size check unsupport!!!\n",
-			plane_info->plane_index);
+			 plane_info->plane_index);
 		return ret;
 	}
 	ret = meson_plane_fb_check(plane, state, plane_info);
 	if (ret < 0) {
 		plane_info->enable = 0;
 		DRM_DEBUG("plane%d fb is NULL,disable the plane!\n",
-			plane_info->plane_index);
+			  plane_info->plane_index);
 		return 0;
 	}
 	ret = meson_plane_get_fb_info(plane, state, plane_info);
@@ -420,24 +632,101 @@ static int meson_plane_atomic_check(struct drm_plane *plane,
 	plane_info->premult_en = plane_state->premult_en;
 	plane_info->enable = 1;
 	DRM_DEBUG("index=%d, zorder=%d\n",
-		plane_info->plane_index, plane_info->zorder);
+		  plane_info->plane_index, plane_info->zorder);
+	DRM_DEBUG("src_x/y/w/h=%d/%d/%d/%d\n",
+		  plane_info->src_x, plane_info->src_y,
+		plane_info->src_w, plane_info->src_h);
+	DRM_DEBUG("dst_x/y/w/h=%d/%d/%d/%d\n",
+		  plane_info->dst_x, plane_info->dst_y,
+		plane_info->dst_w, plane_info->dst_h);
+	return 0;
+}
+
+static int meson_video_plane_atomic_check(struct drm_plane *plane,
+					  struct drm_plane_state *state)
+{
+	struct meson_vpu_video_layer_info *plane_info;
+	struct meson_vpu_pipeline_state *mvps;
+	struct am_video_plane *video_plane = to_am_video_plane(plane);
+	struct meson_drm *drv = video_plane->drv;
+	struct am_meson_plane_state *plane_state;
+	int ret, i;
+
+	if (!state || !drv) {
+		DRM_INFO("%s state/meson_drm is NULL!\n", __func__);
+		return -EINVAL;
+	}
+	mvps = meson_vpu_pipeline_get_state(drv->pipeline, state->state);
+	if (!mvps || video_plane->plane_index >= MESON_MAX_VIDEO) {
+		DRM_INFO("%s mvps/video_plane is NULL!\n", __func__);
+		return -EINVAL;
+	}
+	plane_info = &mvps->video_plane_info[video_plane->plane_index];
+	plane_info->plane_index = video_plane->plane_index;
+	plane_info->zorder = state->zpos;
+
+	mvps->plane_index[video_plane->plane_index] = video_plane->plane_index;
+	meson_video_plane_position_calc(plane_info, state,
+					&mvps->pipeline->mode);
+	ret = meson_video_plane_fb_check(plane, state, plane_info);
+	if (ret < 0) {
+		plane_info->enable = 0;
+		DRM_DEBUG("plane%d fb is NULL,disable the plane!\n",
+			  plane_info->plane_index);
+		return 0;
+	}
+	ret = meson_video_plane_get_fb_info(plane, state, plane_info);
+	if (ret < 0 ||
+	    plane_info->src_w == 0) {
+		plane_info->enable = 0;
+		return ret;
+	}
+
+	plane_state = to_am_meson_plane_state(state);
+	plane_info->enable = 1;
+	if (!drv->video_path_reg) {
+		kfifo_reset(&drv->ready_q);
+		kfifo_reset(&drv->free_q);
+		kfifo_reset(&drv->display_q);
+		for (i = 0; i < BUFFER_NUM; i++)
+			kfifo_put(&drv->free_q, &drv->vframe[i]);
+		vf_reg_provider(&drv->vprov);
+		vf_notify_receiver(drv->video_planes[0]->base.name,
+				   VFRAME_EVENT_PROVIDER_START, NULL);
+		drv->video_path_reg = 1;
+	}
+	DRM_DEBUG("index=%d, zorder=%d\n",
+		  plane_info->plane_index, plane_info->zorder);
 	DRM_DEBUG("src_x/y/w/h=%d/%d/%d/%d\n",
-		plane_info->src_x, plane_info->src_y,
+		  plane_info->src_x, plane_info->src_y,
 		plane_info->src_w, plane_info->src_h);
 	DRM_DEBUG("dst_x/y/w/h=%d/%d/%d/%d\n",
-		plane_info->dst_x, plane_info->dst_y,
+		  plane_info->dst_x, plane_info->dst_y,
 		plane_info->dst_w, plane_info->dst_h);
 	return 0;
 }
 
 static void meson_plane_atomic_disable(struct drm_plane *plane,
-		struct drm_plane_state *old_state)
+				       struct drm_plane_state *old_state)
 {
 	struct am_osd_plane *osd_plane = to_am_osd_plane(plane);
 
 	DRM_DEBUG("%s osd %d.\n", __func__, osd_plane->plane_index);
 }
 
+static void meson_video_plane_atomic_disable(struct drm_plane *plane,
+					     struct drm_plane_state *old_state)
+{
+	struct am_video_plane *video_plane = to_am_video_plane(plane);
+	struct meson_drm *drv = video_plane->drv;
+
+	if (drv->video_path_reg) {
+		vf_unreg_provider(&drv->vprov);
+		drv->video_path_reg = 0;
+	}
+	DRM_DEBUG("%s video %d.\n", __func__, video_plane->plane_index);
+}
+
 static const struct drm_plane_helper_funcs am_osd_helper_funcs = {
 	.prepare_fb = meson_plane_prepare_fb,
 	.cleanup_fb = meson_plane_cleanup_fb,
@@ -446,6 +735,14 @@ static const struct drm_plane_helper_funcs am_osd_helper_funcs = {
 	.atomic_disable	= meson_plane_atomic_disable,
 };
 
+static const struct drm_plane_helper_funcs am_video_helper_funcs = {
+	.prepare_fb = meson_plane_prepare_fb,
+	.cleanup_fb = meson_plane_cleanup_fb,
+	.atomic_update	= meson_plane_atomic_update,
+	.atomic_check	= meson_video_plane_atomic_check,
+	.atomic_disable	= meson_video_plane_atomic_disable,
+};
+
 int drm_plane_create_premult_en_property(struct drm_plane *plane)
 {
 	struct drm_device *dev = plane->dev;
@@ -473,7 +770,7 @@ static struct am_osd_plane *am_plane_create(struct meson_drm *priv, int i)
 	const u64 *format_modifiers = afbc_wb_modifier;
 
 	osd_plane = devm_kzalloc(priv->drm->dev, sizeof(*osd_plane),
-				   GFP_KERNEL);
+				 GFP_KERNEL);
 	if (!osd_plane)
 		return 0;
 
@@ -502,12 +799,44 @@ static struct am_osd_plane *am_plane_create(struct meson_drm *priv, int i)
 	return osd_plane;
 }
 
+static struct am_video_plane *am_video_plane_create(struct meson_drm *priv,
+						    int i)
+{
+	struct am_video_plane *video_plane;
+	struct drm_plane *plane;
+	char plane_name[8];
+	const u64 *format_modifiers = video_wb_modifier;
+
+	video_plane = devm_kzalloc(priv->drm->dev, sizeof(*video_plane),
+				   GFP_KERNEL);
+	if (!video_plane)
+		return 0;
+
+	video_plane->drv = priv;
+	video_plane->plane_index = i;
+
+	plane = &video_plane->base;
+	sprintf(plane_name, "video%d", i);
+
+	drm_universal_plane_init(priv->drm, plane, 0xFF,
+				 &am_video_plane_funs,
+				 video_supported_drm_formats,
+				 ARRAY_SIZE(video_supported_drm_formats),
+				 format_modifiers,
+				 DRM_PLANE_TYPE_OVERLAY, plane_name);
+
+	drm_plane_helper_add(plane, &am_video_helper_funcs);
+	osd_drm_debugfs_add(&video_plane->plane_debugfs_dir,
+			    plane_name, video_plane->plane_index);
+	return video_plane;
+}
+
 int am_meson_plane_create(struct meson_drm *priv)
 {
 	struct am_osd_plane *plane;
+	struct am_video_plane *video_plane;
 	struct meson_vpu_pipeline *pipeline = priv->pipeline;
-	int i, osd_index;
-
+	int i, osd_index, video_index;
 
 	for (i = 0; i < pipeline->num_osds; i++) {
 		osd_index = pipeline->osds[i]->base.index;
@@ -521,6 +850,17 @@ int am_meson_plane_create(struct meson_drm *priv)
 
 		priv->planes[priv->num_planes++] = plane;
 	}
+	/*video plane*/
+	for (i = 0; i < pipeline->num_video; i++) {
+		video_index = pipeline->video[i]->base.index;
+		video_plane = am_video_plane_create(priv, video_index);
+
+		if (!video_plane)
+			return -ENOMEM;
+
+		priv->video_planes[i++] = video_plane;
+		priv->num_planes++;
+	}
 
 	DRM_DEBUG("%s. enter\n", __func__);
 
diff --git a/drivers/amlogic/drm/meson_plane.h b/drivers/amlogic/drm/meson_plane.h
index 5be8adc5dab0..b3bc9272b2cc 100644
--- a/drivers/amlogic/drm/meson_plane.h
+++ b/drivers/amlogic/drm/meson_plane.h
@@ -42,10 +42,19 @@ struct am_osd_plane {
 	struct drm_property *prop_premult_en;
 };
 
+struct am_video_plane {
+	struct drm_plane base; //must be first element.
+	struct meson_drm *drv; //point to struct parent.
+	struct dentry *plane_debugfs_dir;
+	int plane_index;
+};
+
 #define to_am_osd_plane(x) container_of(x, \
 	struct am_osd_plane, base)
 #define to_am_meson_plane_state(x) container_of(x, \
 	struct am_meson_plane_state, base)
+#define to_am_video_plane(x) container_of(x, \
+	struct am_video_plane, base)
 
 int am_meson_plane_create(struct meson_drm *priv);
 
diff --git a/drivers/amlogic/drm/meson_vpu.c b/drivers/amlogic/drm/meson_vpu.c
index 91102d5d6465..fbe771d97e63 100644
--- a/drivers/amlogic/drm/meson_vpu.c
+++ b/drivers/amlogic/drm/meson_vpu.c
@@ -448,6 +448,78 @@ static int am_meson_logo_info_update(struct meson_drm *priv)
 	return 0;
 }
 
+/* -----------------------------------------------------------------
+ *           provider opeations
+ * -----------------------------------------------------------------
+ */
+static struct vframe_s *vp_vf_peek(void *op_arg)
+{
+	struct meson_drm *dev = (struct meson_drm *)op_arg;
+	struct vframe_s *vf = NULL;
+
+	if (kfifo_peek(&dev->ready_q, &vf))
+		return vf;
+	else
+		return NULL;
+}
+
+static struct vframe_s *vp_vf_get(void *op_arg)
+{
+	struct meson_drm *dev = (struct meson_drm *)op_arg;
+	struct vframe_s *vf = NULL;
+
+	if (kfifo_get(&dev->ready_q, &vf)) {
+		if (!vf)
+			return NULL;
+		if (!kfifo_put(&dev->display_q, vf))
+			DRM_INFO("display_q is full!\n");
+		return vf;
+	} else {
+		return NULL;
+	}
+}
+
+static void vp_vf_put(struct vframe_s *vf, void *op_arg)
+{
+	struct meson_drm *dev = (struct meson_drm *)op_arg;
+
+	if (!vf)
+		return;
+
+	kfifo_put(&dev->free_q, vf);
+}
+
+static int vp_event_cb(int type, void *data, void *private_data)
+{
+	if (type & VFRAME_EVENT_RECEIVER_PUT)
+		;
+	else if (type & VFRAME_EVENT_RECEIVER_GET)
+		;
+	else if (type & VFRAME_EVENT_RECEIVER_FRAME_WAIT)
+		;
+	return 0;
+}
+
+static int vp_vf_states(struct vframe_states *states, void *op_arg)
+{
+	struct meson_drm *dev = (struct meson_drm *)op_arg;
+
+	states->vf_pool_size = BUFFER_NUM;
+	states->buf_recycle_num = 0;
+	states->buf_free_num = BUFFER_NUM
+		- kfifo_len(&dev->ready_q);
+	states->buf_avail_num = kfifo_len(&dev->ready_q);
+	return 0;
+}
+
+static const struct vframe_operations_s vp_vf_ops = {
+	.peek = vp_vf_peek,
+	.get  = vp_vf_get,
+	.put  = vp_vf_put,
+	.event_cb = vp_event_cb,
+	.vf_states = vp_vf_states,
+};
+
 static int am_meson_vpu_bind(struct device *dev,
 				struct device *master, void *data)
 {
@@ -459,7 +531,7 @@ static int am_meson_vpu_bind(struct device *dev,
 #ifdef CONFIG_CMA
 	struct cma *cma;
 #endif
-	int ret, irq;
+	int ret, irq, i;
 
 	/* Allocate crtc struct */
 	DRM_INFO("[%s] in\n", __func__);
@@ -522,6 +594,26 @@ static int am_meson_vpu_bind(struct device *dev,
 	if (ret)
 		return ret;
 
+	if (pipeline->num_video) {
+		INIT_KFIFO(private->ready_q);
+		INIT_KFIFO(private->free_q);
+		INIT_KFIFO(private->display_q);
+		kfifo_reset(&private->ready_q);
+		kfifo_reset(&private->free_q);
+		kfifo_reset(&private->display_q);
+		for (i = 0; i < BUFFER_NUM; i++)
+			kfifo_put(&private->free_q, &private->vframe[i]);
+		snprintf(private->vfm_map_chain, VP_MAP_STRUCT_SIZE,
+			 "%s %s", private->video_planes[0]->base.name,
+			 "amvideo");
+		snprintf(private->vfm_map_id, VP_MAP_STRUCT_SIZE,
+			 "video-map");
+		vfm_map_add(private->vfm_map_id, private->vfm_map_chain);
+		vf_provider_init(&private->vprov,
+				 private->video_planes[0]->base.name,
+				 &vp_vf_ops, private);
+	}
+
 	am_meson_register_crtc_funcs(private->crtc, &meson_private_crtc_funcs);
 
 	ret = of_property_read_u8(dev->of_node,
@@ -555,6 +647,8 @@ static void am_meson_vpu_unbind(struct device *dev,
 	struct drm_device *drm_dev = data;
 	struct meson_drm *private = drm_dev->dev_private;
 
+	if (private->pipeline->num_video)
+		vfm_map_remove(private->vfm_map_id);
 	am_meson_unregister_crtc_funcs(private->crtc);
 #ifdef CONFIG_AMLOGIC_MEDIA_ENHANCEMENT
 	amvecm_drm_gamma_disable(0);
diff --git a/drivers/amlogic/drm/meson_vpu_pipeline.c b/drivers/amlogic/drm/meson_vpu_pipeline.c
index bb1d72cae9e3..32ebeae06e15 100644
--- a/drivers/amlogic/drm/meson_vpu_pipeline.c
+++ b/drivers/amlogic/drm/meson_vpu_pipeline.c
@@ -220,6 +220,13 @@ meson_vpu_create_block(struct meson_vpu_block_para *para,
 
 		pipeline->postblend = to_postblend_block(mvb);
 		break;
+	case MESON_BLK_VIDEO:
+		blk_size = sizeof(struct meson_vpu_video);
+		mvb = create_block(blk_size, para, &video_ops, pipeline);
+
+		pipeline->video[mvb->index] = to_video_block(mvb);
+		pipeline->num_video++;
+		break;
 	default:
 		return NULL;
 	}
@@ -307,6 +314,14 @@ static void vpu_pipeline_planes_calc(struct meson_vpu_pipeline *pipeline,
 			mvps->num_plane++;
 		}
 	}
+	for (i = 0; i < pipeline->num_video; i++) {
+		if (mvps->video_plane_info[i].enable) {
+			mvps->enable_blocks |=
+				BIT(pipeline->video[i]->base.id);
+			DRM_INFO("video[%d]-id=%d\n", i,
+				 pipeline->video[i]->base.id);
+		}
+	}
 	DRM_DEBUG("num_plane=%d.\n", mvps->num_plane);
 }
 
@@ -333,6 +348,9 @@ void vpu_pipeline_init(struct meson_vpu_pipeline *pipeline)
 	for (i = 0; i < pipeline->num_osds; i++)
 		VPU_PIPELINE_HW_INIT(&pipeline->osds[i]->base);
 
+	for (i = 0; i < pipeline->num_video; i++)
+		VPU_PIPELINE_HW_INIT(&pipeline->video[i]->base);
+
 	for (i = 0; i < pipeline->num_afbc_osds; i++)
 		VPU_PIPELINE_HW_INIT(&pipeline->afbc_osds[i]->base);
 
diff --git a/drivers/amlogic/drm/meson_vpu_pipeline.h b/drivers/amlogic/drm/meson_vpu_pipeline.h
index 06c3624deef7..a523b4efbede 100644
--- a/drivers/amlogic/drm/meson_vpu_pipeline.h
+++ b/drivers/amlogic/drm/meson_vpu_pipeline.h
@@ -29,6 +29,7 @@
 #define MESON_OSD2 1
 #define MESON_OSD3 2
 #define MESON_MAX_OSDS 4
+#define MESON_MAX_VIDEO 2
 #define MESON_MAX_OSD_BLEND 3
 #define MESON_MAX_OSD_TO_VPP 2
 #define MESON_MAX_SCALERS 4
@@ -82,6 +83,7 @@ enum meson_vpu_blk_type {
 	MESON_BLK_HDR,
 	MESON_BLK_DOVI,
 	MESON_BLK_VPPBLEND,
+	MESON_BLK_VIDEO,
 };
 
 struct meson_vpu_pipeline;
@@ -210,6 +212,65 @@ struct meson_vpu_osd_state {
 	u32 afbc_en;
 };
 
+struct meson_vpu_video_layer_info {
+	u32 src_x;
+	u32 src_y;
+	u32 src_w;
+	u32 src_h;
+	u32 dst_w;
+	u32 dst_h;
+	int dst_x;
+	int dst_y;
+	u32 zorder;
+	u32 byte_stride;
+	u32 pixel_format;
+	u32 phy_addr[2];
+	u32 plane_index;
+	u32 enable;
+	u32 ratio_x;/*input_w/output_w*/
+	u32 afbc_inter_format;
+	u32 afbc_en;
+	u32 fb_size;
+	u32 premult_en;
+};
+
+struct meson_vpu_video {
+	struct meson_vpu_block base;
+	//struct osd_mif_reg_s *reg;
+};
+
+struct meson_vpu_video_state {
+	struct meson_vpu_block_state base;
+
+	u32 index;
+	u32 enable;
+	u32 color_key_enable;
+	u32 dimm_enable;
+	u32 mode_3d_enable;
+
+	u32 color_key;
+	u32 alpha;
+	u32 global_alpha;
+	u32 dimm_color;
+	u32 phy_addr[2];
+	u32 pixel_format;
+	u32 zorder;
+	u32 byte_stride;
+	u32 src_x;
+	u32 src_y;
+	u32 src_w;
+	u32 src_h;
+	u32 dst_w;
+	u32 dst_h;
+	int dst_x;
+	int dst_y;
+	int s_mode;
+	int r_mode;
+	u32 plane_index;
+	u32 fb_size;
+	u32 premult_en;
+};
+
 struct meson_vpu_afbc {
 	struct meson_vpu_block base;
 	struct afbc_osd_reg_s *afbc_regs;
@@ -335,6 +396,7 @@ struct meson_vpu_pipeline {
 	struct drm_private_obj obj;
 	struct drm_display_mode mode;
 	struct meson_vpu_osd *osds[MESON_MAX_OSDS];
+	struct meson_vpu_video *video[MESON_MAX_VIDEO];
 	struct meson_vpu_afbc *afbc_osds[MESON_MAX_OSDS];
 	struct meson_vpu_scaler *scalers[MESON_MAX_SCALERS];
 	struct meson_vpu_osdblend *osdblend;
@@ -343,6 +405,7 @@ struct meson_vpu_pipeline {
 	struct meson_vpu_postblend *postblend;
 	struct meson_vpu_pipeline_state *state;
 	u32 num_osds;
+	u32 num_video;
 	u32 num_afbc_osds;
 	u32 num_scalers;
 	u8 osd_version;
@@ -374,6 +437,7 @@ struct meson_vpu_pipeline_state {
 	struct meson_vpu_pipeline *pipeline;
 	u64 enable_blocks;
 	struct meson_vpu_osd_layer_info plane_info[MESON_MAX_OSDS];
+	struct meson_vpu_video_layer_info video_plane_info[MESON_MAX_VIDEO];
 	u32 num_plane;
 	/*min --> max*/
 	u32 zorder_plane_index[MESON_MAX_OSDS];
@@ -389,6 +453,7 @@ struct meson_vpu_pipeline_state {
 	struct meson_vpu_traverse osd_traverse[MESON_MAX_OSDS];
 
 	u32 plane_index[MESON_MAX_OSDS];
+	u32 video_plane_index[MESON_MAX_VIDEO];
 	u32 din_index[MAX_DIN_NUM];
 	u32 dout_index[MAX_DIN_NUM];
 	u32 scaler_cnt[MAX_DIN_NUM];
@@ -403,6 +468,7 @@ struct meson_vpu_pipeline_state {
 #define to_hdr_block(x) container_of(x, struct meson_vpu_hdr, base)
 #define to_dolby_block(x) container_of(x, struct meson_vpu_dolby, base)
 #define to_postblend_block(x) container_of(x, struct meson_vpu_postblend, base)
+#define to_video_block(x) container_of(x, struct meson_vpu_video, base)
 
 #define to_osd_state(x) container_of(x, struct meson_vpu_osd_state, base)
 #define to_afbc_state(x) container_of(x, struct meson_vpu_afbc_state, base)
@@ -413,6 +479,7 @@ struct meson_vpu_pipeline_state {
 #define to_dolby_state(x) container_of(x, struct meson_vpu_dolby_state, base)
 #define to_postblend_state(x) container_of(x, \
 		struct meson_vpu_postblend_state, base)
+#define to_video_state(x) container_of(x, struct meson_vpu_video_state, base)
 
 #define priv_to_block(x) container_of(x, struct meson_vpu_block, obj)
 #define priv_to_block_state(x) container_of(x, \
@@ -450,6 +517,7 @@ int vpu_pipeline_check_osdblend(u32 *out_port, int num_planes,
 				struct meson_vpu_pipeline_state *mvps,
 					struct drm_atomic_state *state);
 
+extern struct meson_vpu_block_ops video_ops;
 extern struct meson_vpu_block_ops osd_ops;
 extern struct meson_vpu_block_ops afbc_ops;
 extern struct meson_vpu_block_ops scaler_ops;
diff --git a/drivers/amlogic/drm/meson_vpu_pipeline_private.c b/drivers/amlogic/drm/meson_vpu_pipeline_private.c
index a4ecb0e5dfd8..7ad549325475 100644
--- a/drivers/amlogic/drm/meson_vpu_pipeline_private.c
+++ b/drivers/amlogic/drm/meson_vpu_pipeline_private.c
@@ -56,13 +56,13 @@ meson_vpu_osd_atomic_duplicate_state(struct drm_private_obj *obj)
 }
 
 static void meson_vpu_osd_atomic_destroy_state(struct drm_private_obj *obj,
-				struct drm_private_state *state)
+					       struct drm_private_state *state)
 {
 	struct meson_vpu_block_state *mvbs = priv_to_block_state(state);
 	struct meson_vpu_osd_state *mvos = to_osd_state(mvbs);
 
 	DRM_DEBUG("%s id=%d,index=%d\n",
-		mvbs->pblk->name, mvbs->pblk->id, mvbs->pblk->index);
+		  mvbs->pblk->name, mvbs->pblk->id, mvbs->pblk->index);
 	kfree(mvos);
 }
 
@@ -72,7 +72,7 @@ static const struct drm_private_state_funcs meson_vpu_osd_obj_funcs = {
 };
 
 static int meson_vpu_osd_state_init(struct meson_drm *private,
-						struct meson_vpu_osd *osd)
+				    struct meson_vpu_osd *osd)
 {
 	struct meson_vpu_osd_state *state;
 
@@ -88,6 +88,57 @@ static int meson_vpu_osd_state_init(struct meson_drm *private,
 	return 0;
 }
 
+static struct drm_private_state *
+meson_vpu_video_atomic_duplicate_state(struct drm_private_obj *obj)
+{
+	struct meson_vpu_block *mvb;
+	struct meson_vpu_video_state *state;
+
+	mvb = priv_to_block(obj);
+
+	state = kzalloc(sizeof(*state), GFP_KERNEL);
+	state->base.pblk = mvb;
+
+	__drm_atomic_helper_private_obj_duplicate_state(obj, &state->base.obj);
+	vpu_pipeline_state_set(mvb, &state->base);
+
+	return &state->base.obj;
+}
+
+static void
+meson_vpu_video_atomic_destroy_state(struct drm_private_obj *obj,
+				     struct drm_private_state *state)
+{
+	struct meson_vpu_block_state *mvbs = priv_to_block_state(state);
+	struct meson_vpu_video_state *mvvs = to_video_state(mvbs);
+
+	DRM_DEBUG("%s id=%d,index=%d\n",
+		  mvbs->pblk->name, mvbs->pblk->id, mvbs->pblk->index);
+	kfree(mvvs);
+}
+
+static const struct drm_private_state_funcs meson_vpu_video_obj_funcs = {
+	.atomic_duplicate_state = meson_vpu_video_atomic_duplicate_state,
+	.atomic_destroy_state = meson_vpu_video_atomic_destroy_state,
+};
+
+static int meson_vpu_video_state_init(struct meson_drm *private,
+				      struct meson_vpu_video *video)
+{
+	struct meson_vpu_video_state *state;
+
+	state = kzalloc(sizeof(*state), GFP_KERNEL);
+	if (!state)
+		return -ENOMEM;
+
+	state->base.pblk = &video->base;
+	drm_atomic_private_obj_init(&video->base.obj,
+				    &state->base.obj,
+				    &meson_vpu_video_obj_funcs);
+
+	return 0;
+}
+
 static struct drm_private_state *
 meson_vpu_afbc_atomic_duplicate_state(struct drm_private_obj *obj)
 {
@@ -366,8 +417,9 @@ meson_vpu_pipeline_atomic_duplicate_state(struct drm_private_obj *obj)
 	return &state->obj;
 }
 
-static void meson_vpu_pipeline_atomic_destroy_state(struct drm_private_obj *obj,
-				struct drm_private_state *state)
+static void
+meson_vpu_pipeline_atomic_destroy_state(struct drm_private_obj *obj,
+					struct drm_private_state *state)
 {
 	struct meson_vpu_pipeline_state *mvps = priv_to_pipeline_state(state);
 
@@ -388,7 +440,7 @@ static const struct drm_private_state_funcs meson_vpu_pipeline_obj_funcs = {
 };
 
 static int meson_vpu_pipeline_state_init(struct meson_drm *private,
-		struct meson_vpu_pipeline *pipeline)
+					 struct meson_vpu_pipeline *pipeline)
 {
 	struct meson_vpu_pipeline_state *state;
 
@@ -398,7 +450,7 @@ static int meson_vpu_pipeline_state_init(struct meson_drm *private,
 
 	state->pipeline = pipeline;
 	drm_atomic_private_obj_init(&pipeline->obj, &state->obj,
-		&meson_vpu_pipeline_obj_funcs);
+				    &meson_vpu_pipeline_obj_funcs);
 
 	return 0;
 }
@@ -435,7 +487,7 @@ meson_vpu_pipeline_get_state(struct meson_vpu_pipeline *pipeline,
 }
 
 int meson_vpu_block_state_init(struct meson_drm *private,
-	struct meson_vpu_pipeline *pipeline)
+			       struct meson_vpu_pipeline *pipeline)
 {
 	int i, ret;
 
@@ -449,21 +501,26 @@ int meson_vpu_block_state_init(struct meson_drm *private,
 			return ret;
 	}
 
+	for (i = 0; i < pipeline->num_video; i++) {
+		ret = meson_vpu_video_state_init(private, pipeline->video[i]);
+		if (ret)
+			return ret;
+	}
+
 	for (i = 0; i < pipeline->num_afbc_osds; i++) {
 		ret = meson_vpu_afbc_state_init(private,
-			pipeline->afbc_osds[i]);
+						pipeline->afbc_osds[i]);
 		if (ret)
 			return ret;
 	}
 
 	for (i = 0; i < pipeline->num_scalers; i++) {
 		ret = meson_vpu_scaler_state_init(private,
-			pipeline->scalers[i]);
+						  pipeline->scalers[i]);
 		if (ret)
 			return ret;
 	}
 
-
 	ret = meson_vpu_osdblend_state_init(private, pipeline->osdblend);
 	if (ret)
 		return ret;
diff --git a/drivers/amlogic/drm/meson_vpu_pipeline_traverse.c b/drivers/amlogic/drm/meson_vpu_pipeline_traverse.c
index 4ff06f26346e..d94d509b9530 100644
--- a/drivers/amlogic/drm/meson_vpu_pipeline_traverse.c
+++ b/drivers/amlogic/drm/meson_vpu_pipeline_traverse.c
@@ -153,7 +153,7 @@ static void pipeline_dfs(int osd_index, struct meson_vpu_pipeline_state *mvps,
 }
 
 static u8 find_out_port(struct meson_vpu_block *in,
-				struct meson_vpu_block *out)
+			struct meson_vpu_block *out)
 {
 	int i;
 	struct meson_vpu_block_link *mvbl;
@@ -167,7 +167,7 @@ static u8 find_out_port(struct meson_vpu_block *in,
 }
 
 void vpu_pipeline_scaler_scope_size_calc(u8 index, u8 osd_index,
-			struct meson_vpu_pipeline_state *mvps)
+					 struct meson_vpu_pipeline_state *mvps)
 {
 	u8 m, i;
 	u32 ratio_x[MESON_MAX_SCALERS], ratio_y[MESON_MAX_SCALERS];
@@ -325,6 +325,7 @@ void vpu_pipeline_scaler_scope_size_calc(u8 index, u8 osd_index,
 		}
 	}
 }
+
 static void vpu_osd_shift_recalc(struct meson_vpu_pipeline_state *state)
 {
 	u8 i;
@@ -335,8 +336,9 @@ static void vpu_osd_shift_recalc(struct meson_vpu_pipeline_state *state)
 	}
 	state->scaler_param[0].input_height += 1;
 }
+
 int vpu_pipeline_scaler_check(int *combination, int num_planes,
-				struct meson_vpu_pipeline_state *mvps)
+			      struct meson_vpu_pipeline_state *mvps)
 {
 	int i, j, osd_index, ret, m;
 	struct meson_vpu_traverse *mvt;
@@ -349,9 +351,9 @@ int vpu_pipeline_scaler_check(int *combination, int num_planes,
 	ret = 0;
 	/*clean up scaler and scope size before check & calc*/
 	memset(mvps->scaler_param, 0,
-		MESON_MAX_SCALERS * sizeof(struct meson_vpu_scaler_param));
+	       MESON_MAX_SCALERS * sizeof(struct meson_vpu_scaler_param));
 	memset(mvps->osd_scope_pre, 0,
-		MESON_MAX_OSDS * sizeof(struct osd_scope_s));
+	       MESON_MAX_OSDS * sizeof(struct osd_scope_s));
 	for (i = 0; i < MESON_MAX_OSDS && !ret; i++) {
 		if (!mvps->plane_info[i].enable)
 			continue;
@@ -375,7 +377,7 @@ int vpu_pipeline_scaler_check(int *combination, int num_planes,
 				mvps->scaler_param[m].plane_mask |=
 					BIT(osd_index);
 				mvps->scaler_param[m].before_osdblend =
-					have_blend ? 0:1;
+					have_blend ? 0 : 1;
 			}
 		}
 
@@ -387,15 +389,15 @@ int vpu_pipeline_scaler_check(int *combination, int num_planes,
 				RATIO_BASE) /
 				mvps->plane_info[osd_index].dst_h;
 			if (ratio_x[0] != RATIO_BASE ||
-				ratio_y[0] != RATIO_BASE) {
+			    ratio_y[0] != RATIO_BASE) {
 				ret = -1;
 				break;
 			}
 			vpu_pipeline_scaler_scope_size_calc(i,
-				osd_index, mvps);
+							    osd_index, mvps);
 		} else if (mvps->scaler_cnt[i] == 1) {
 			vpu_pipeline_scaler_scope_size_calc(i,
-				osd_index, mvps);
+							    osd_index, mvps);
 		} else if (mvps->scaler_cnt[i] == 2) {
 			/*
 			 *check second scaler firstly,
@@ -444,11 +446,11 @@ int vpu_pipeline_scaler_check(int *combination, int num_planes,
 				break;
 			}
 			vpu_pipeline_scaler_scope_size_calc(i,
-				osd_index, mvps);
+							    osd_index, mvps);
 		}
 	}
 	if (ret == 0 && mvps->num_plane > 0 &&
-		mvps->pipeline->osd_version <= OSD_V2)
+	    mvps->pipeline->osd_version <= OSD_V2)
 		vpu_osd_shift_recalc(mvps);
 	return ret;
 }
@@ -465,7 +467,7 @@ int vpu_pipeline_scaler_check(int *combination, int num_planes,
  * 0 for the valid path or -1 for the invalid path
  */
 int vpu_pipeline_check_block(int *combination, int num_planes,
-					struct meson_vpu_pipeline_state *mvps,
+			     struct meson_vpu_pipeline_state *mvps,
 					struct drm_atomic_state *state)
 {
 	int i, j, osd_index, ret;
@@ -495,9 +497,9 @@ int vpu_pipeline_check_block(int *combination, int num_planes,
 
 			if (block == osdblend) {
 				mvps->dout_index[i] =
-					find_out_port(block, mvb[j+1]);
+					find_out_port(block, mvb[j + 1]);
 				DRM_DEBUG("osd-%d blend out port: %d.\n",
-						i, mvps->dout_index[i]);
+					  i, mvps->dout_index[i]);
 				break;
 			}
 		}
@@ -522,25 +524,42 @@ int vpu_pipeline_check_block(int *combination, int num_planes,
 
 				if (ret) {
 					DRM_ERROR("%s block check error.\n",
-						block->name);
+						  block->name);
 					return ret;
 				}
 			}
 		}
 	}
+	/*TODO*/
+	for (i = 0; i < MESON_MAX_VIDEO; i++) {
+		if (!mvps->video_plane_info[i].enable)
+			continue;
+		block = &mvps->pipeline->video[0]->base;
+		if (block->ops && block->ops->check_state) {
+			mvbs = meson_vpu_block_get_state(block, state);
+			ret = block->ops->check_state(block,
+					mvbs, mvps);
+
+			if (ret) {
+				DRM_ERROR("%s block check error.\n",
+					  block->name);
+				return ret;
+			}
+		}
+	}
 
 	return ret;
 }
 
 void vpu_pipeline_enable_block(int *combination, int num_planes,
-				struct meson_vpu_pipeline_state *mvps)
+			       struct meson_vpu_pipeline_state *mvps)
 {
 	int i, j, osd_index;
 	struct meson_vpu_traverse *mvt;
 	struct meson_vpu_block **mvb;
 	struct meson_vpu_block *block;
 
-	mvps->enable_blocks = 0;
+	//mvps->enable_blocks = 0;
 
 	for (i = 0; i < MESON_MAX_OSDS; i++) {
 		if (!mvps->plane_info[i].enable)
@@ -556,6 +575,8 @@ void vpu_pipeline_enable_block(int *combination, int num_planes,
 			mvps->enable_blocks |= BIT(block->id);
 		}
 	}
+	/*TODO*/
+	//for (i = 0; i < MESON_MAX_VIDEO; i++)
 }
 
 /**
@@ -569,7 +590,7 @@ void vpu_pipeline_enable_block(int *combination, int num_planes,
  * 0 for the valid path or -1 for the invalid path
  */
 int combinate_layer_path(int *path_num_array, int num_planes,
-				struct meson_vpu_pipeline_state *mvps,
+			 struct meson_vpu_pipeline_state *mvps,
 					struct drm_atomic_state *state)
 {
 	int i, j, ret;
@@ -582,12 +603,12 @@ int combinate_layer_path(int *path_num_array, int num_planes,
 	do {
 		// sum the combination result to check osd blend block
 		ret = vpu_pipeline_check_block(combination,
-				num_planes, mvps, state);
+					       num_planes, mvps, state);
 		if (!ret)
 			break;
 
 		i++;
-		combination[num_planes-1] = i;
+		combination[num_planes - 1] = i;
 
 		for (j = num_planes - 1; j >= 0; j--) {
 			if (combination[j] >= path_num_array[j]) {
@@ -621,7 +642,7 @@ int combinate_layer_path(int *path_num_array, int num_planes,
  * 0 for the valid path or -1 for the invalid path
  */
 int vpu_pipeline_traverse(struct meson_vpu_pipeline_state *mvps,
-					struct drm_atomic_state *state)
+			  struct drm_atomic_state *state)
 {
 	int i, osd_index, ret;
 	int num_planes;
@@ -652,7 +673,7 @@ int vpu_pipeline_traverse(struct meson_vpu_pipeline_state *mvps,
 		osd_index = mvps->plane_index[i];
 		path[i] = mvps->osd_traverse[osd_index].num_path;
 		DRM_DEBUG("osd%d traverse path num: %d\n",
-			(osd_index + 1), path[i]);
+			  (osd_index + 1), path[i]);
 	}
 
 	ret = combinate_layer_path(path, num_planes, mvps, state);
diff --git a/drivers/amlogic/drm/meson_vpu_util.h b/drivers/amlogic/drm/meson_vpu_util.h
index 764bcc34167e..920da1aacfeb 100644
--- a/drivers/amlogic/drm/meson_vpu_util.h
+++ b/drivers/amlogic/drm/meson_vpu_util.h
@@ -52,5 +52,5 @@ void meson_util_canvas_config(u32 index, unsigned long addr, u32 width,
 					u32 height, u32 wrap, u32 blkmode);
 int meson_util_canvas_pool_alloc_table(const char *owner, u32 *table, int size,
 					enum canvas_map_type_e type);
-
+extern void amvideo_set_scaler_para(int x, int y, int w, int h, int flag);
 #endif
diff --git a/drivers/amlogic/drm/vpu-hw/meson_vpu_video_mif.c b/drivers/amlogic/drm/vpu-hw/meson_vpu_video_mif.c
new file mode 100644
index 000000000000..953b34098a1a
--- /dev/null
+++ b/drivers/amlogic/drm/vpu-hw/meson_vpu_video_mif.c
@@ -0,0 +1,209 @@
+/*
+ * drivers/amlogic/drm/vpu-hw/meson_vpu_video_mif.c
+ *
+ * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/fs.h>
+#include <linux/uaccess.h>
+
+#ifdef CONFIG_AMLOGIC_MEDIA_CANVAS
+#include <linux/amlogic/media/canvas/canvas.h>
+#include <linux/amlogic/media/canvas/canvas_mgr.h>
+#endif
+#include "meson_vpu_pipeline.h"
+#include "meson_crtc.h"
+#include "meson_vpu_reg.h"
+#include "meson_vpu_util.h"
+#include "meson_drv.h"
+#include "meson_plane.h"
+
+static unsigned int video_canvas0[2][2] = {
+	{0x26, 0x27}, {0x28, 0x29} };
+static unsigned int video_canvas1[2][2] = {
+	{0x2a, 0x2b}, {0x2c, 0x2d} };
+static u32 video_canvas_index[2] = {0, 0};
+
+static u32 video_type_get(u32 pixel_format)
+{
+	u32 vframe_type = 0;
+
+	switch (pixel_format) {
+	case DRM_FORMAT_NV12:
+	case DRM_FORMAT_NV21:
+		vframe_type = VIDTYPE_VIU_NV21 | VIDTYPE_VIU_FIELD |
+				VIDTYPE_PROGRESSIVE;
+		break;
+	case DRM_FORMAT_YUYV:
+	case DRM_FORMAT_YVYU:
+		vframe_type = VIDTYPE_VIU_422 | VIDTYPE_VIU_FIELD |
+				VIDTYPE_VIU_SINGLE_PLANE;
+		break;
+	default:
+		DRM_INFO("no support pixel format:0x%x\n", pixel_format);
+		break;
+	}
+	return vframe_type;
+}
+
+static int video_check_state(struct meson_vpu_block *vblk,
+			     struct meson_vpu_block_state *state,
+		struct meson_vpu_pipeline_state *mvps)
+{
+	struct meson_vpu_video_layer_info *plane_info;
+	struct meson_vpu_video *video = to_video_block(vblk);
+	struct meson_vpu_video_state *mvvs = to_video_state(state);
+
+	if (state->checked)
+		return 0;
+
+	state->checked = true;
+
+	if (!mvvs || mvvs->plane_index >= MESON_MAX_VIDEO) {
+		DRM_INFO("mvvs is NULL!\n");
+		return -1;
+	}
+	DRM_DEBUG("%s check_state called.\n", video->base.name);
+	plane_info = &mvps->video_plane_info[vblk->index];
+	mvvs->src_x = plane_info->src_x;
+	mvvs->src_y = plane_info->src_y;
+	mvvs->src_w = plane_info->src_w;
+	mvvs->src_h = plane_info->src_h;
+	mvvs->dst_x = plane_info->dst_x;
+	mvvs->dst_y = plane_info->dst_y;
+	mvvs->dst_w = plane_info->dst_w;
+	mvvs->dst_h = plane_info->dst_h;
+	mvvs->byte_stride = plane_info->byte_stride;
+	mvvs->phy_addr[0] = plane_info->phy_addr[0];
+	mvvs->phy_addr[1] = plane_info->phy_addr[1];
+
+	mvvs->pixel_format = plane_info->pixel_format;
+	mvvs->fb_size = plane_info->fb_size;
+	return 0;
+}
+
+static void video_set_state(struct meson_vpu_block *vblk,
+			    struct meson_vpu_block_state *state)
+{
+	struct drm_crtc *crtc;
+	struct drm_device *drm_dev;
+	struct meson_drm *private;
+	struct vframe_s *vf = NULL;
+	struct meson_vpu_video *video = to_video_block(vblk);
+	struct meson_vpu_video_state *mvvs = to_video_state(state);
+	u32 pixel_format, canvas_index0, src_h, byte_stride, phy_addr;
+	u32 phy_addr2 = 0, index, canvas_index1 = 0;
+
+	if (!vblk) {
+		DRM_DEBUG("set_state break for NULL.\n");
+		return;
+	}
+
+	crtc = vblk->pipeline->crtc;
+	drm_dev = crtc->dev;
+	private = drm_dev->dev_private;
+	src_h = mvvs->src_h;
+	byte_stride = mvvs->byte_stride;
+	phy_addr = mvvs->phy_addr[0];
+	pixel_format = mvvs->pixel_format;
+	index =  video_canvas_index[vblk->index];
+	canvas_index0 = video_canvas0[vblk->index][index];
+	canvas_config(canvas_index0, phy_addr, byte_stride, src_h,
+		      CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_LINEAR);
+	if (pixel_format == DRM_FORMAT_NV12 ||
+	    pixel_format == DRM_FORMAT_NV21) {
+		canvas_index1 = video_canvas1[vblk->index][index];
+		if (!mvvs->phy_addr[1])
+			phy_addr2 = phy_addr + byte_stride * src_h;
+		else
+			phy_addr2 = mvvs->phy_addr[1];
+		canvas_config(canvas_index1, phy_addr2, byte_stride, src_h/2,
+			      CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_LINEAR);
+	}
+	video_canvas_index[vblk->index] ^= 1;
+	if (kfifo_get(&private->free_q, &vf)) {
+		if (!vf)
+			DRM_INFO("free_q is NULL");
+		memset(vf, 0, sizeof(struct vframe_s));
+		vf->width = mvvs->src_w;
+		vf->height = mvvs->src_h;
+		vf->source_type = VFRAME_SOURCE_TYPE_OTHERS;
+		vf->source_mode = VFRAME_SOURCE_MODE_OTHERS;
+		vf->bitdepth = BITDEPTH_Y8 | BITDEPTH_U8 | BITDEPTH_V8;
+		vf->type = video_type_get(pixel_format);
+		vf->canvas0Addr = (canvas_index1 << 8) | canvas_index0;
+		if (!kfifo_put(&private->ready_q, vf))
+			DRM_INFO("ready_q is full!\n");
+	} else {
+		DRM_INFO("free_q get fail!");
+	}
+	amvideo_set_scaler_para(mvvs->dst_x, mvvs->dst_y, mvvs->dst_w,
+				mvvs->dst_h, 0);
+	DRM_DEBUG("plane_index=%d,HW-video=%d, byte_stride=%d\n",
+		  mvvs->plane_index, vblk->index, byte_stride);
+	DRM_DEBUG("canvas_index[%d]=0x%x,phy_addr=0x%x,phy_addr2=0x%x\n",
+		  video_canvas_index[vblk->index], canvas_index0,
+		  phy_addr, phy_addr2);
+	DRM_DEBUG("vframe info:type(0x%x)\n", vf->type);
+	DRM_DEBUG("%s set_state done.\n", video->base.name);
+}
+
+static void video_hw_enable(struct meson_vpu_block *vblk)
+{
+	struct meson_vpu_video *video = to_video_block(vblk);
+
+	if (!video) {
+		DRM_DEBUG("enable break for NULL.\n");
+		return;
+	}
+	DRM_DEBUG("%s enable done.\n", video->base.name);
+}
+
+static void video_hw_disable(struct meson_vpu_block *vblk)
+{
+	struct meson_vpu_video *video = to_video_block(vblk);
+
+	if (!video) {
+		DRM_DEBUG("disable break for NULL.\n");
+		return;
+	}
+	DRM_DEBUG("%s disable done.\n", video->base.name);
+}
+
+static void video_dump_register(struct meson_vpu_block *vblk,
+				struct seq_file *seq)
+{
+}
+
+static void video_hw_init(struct meson_vpu_block *vblk)
+{
+	struct meson_vpu_video *video = to_video_block(vblk);
+
+	if (!vblk || !video) {
+		DRM_DEBUG("video_hw_init break for NULL.\n");
+		return;
+	}
+	DRM_DEBUG("%s video_hw_init done.\n", video->base.name);
+}
+
+struct meson_vpu_block_ops video_ops = {
+	.check_state = video_check_state,
+	.update_state = video_set_state,
+	.enable = video_hw_enable,
+	.disable = video_hw_disable,
+	.dump_register = video_dump_register,
+	.init = video_hw_init,
+};
diff --git a/drivers/amlogic/drm/vpu-hw/meson_vpu_video_mif.h b/drivers/amlogic/drm/vpu-hw/meson_vpu_video_mif.h
new file mode 100644
index 000000000000..80b913d37400
--- /dev/null
+++ b/drivers/amlogic/drm/vpu-hw/meson_vpu_video_mif.h
@@ -0,0 +1,23 @@
+/*
+ * drivers/amlogic/drm/vpu-hw/meson_vpu_video_mif.h
+ *
+ * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#ifndef _MESON_VPU_VIDEO_MIF_H_
+#define _MESON_VPU_VIDEO_MIF_H_
+
+#define HW_VIDEO_MIF_NUM 2
+
+#endif
diff --git a/include/dt-bindings/display/meson-drm-ids.h b/include/dt-bindings/display/meson-drm-ids.h
index 8170899dcc74..0c67e245314e 100644
--- a/include/dt-bindings/display/meson-drm-ids.h
+++ b/include/dt-bindings/display/meson-drm-ids.h
@@ -13,7 +13,9 @@
 #define OSD_BLEND_BLOCK 9
 #define OSD1_HDR_BLOCK 10
 #define VPP_POSTBLEND_BLOCK 11
-#define BLOCK_ID_MAX 12
+#define VIDEO1_BLOCK 12
+#define VIDEO2_BLOCK 13
+#define BLOCK_ID_MAX 14
 
 #define OSD1_PORT 0
 #define OSD2_PORT 1
@@ -34,6 +36,8 @@
 #define VPP_POSTBLEND_OSD1_IN_PORT 16
 #define VPP_POSTBLEND_OSD2_IN_PORT 17
 #define VPP_POSTBLEND_OUT_PORT 18
+#define VIDEO1_PORT 19
+#define VIDEO2_PORT 20
 
 /*
  *OSD VERSION
diff --git a/include/uapi/drm/drm_fourcc.h b/include/uapi/drm/drm_fourcc.h
index 9f74715c586c..ad3611ba4517 100644
--- a/include/uapi/drm/drm_fourcc.h
+++ b/include/uapi/drm/drm_fourcc.h
@@ -258,6 +258,11 @@ extern "C" {
 
 #define DRM_FORMAT_MOD_MESON_AFBC	fourcc_mod_code(AMLOGIC, 1)
 #define DRM_FORMAT_MOD_MESON_AFBC_WB	fourcc_mod_code(AMLOGIC, 2)
+#define DRM_FORMAT_MOD_MESON_YUV444_8BIT_WB	fourcc_mod_code(AMLOGIC, 3)
+#define DRM_FORMAT_MOD_MESON_YUV422_10BIT_WB	fourcc_mod_code(AMLOGIC, 4)
+#define DRM_FORMAT_MOD_MESON_YUV422_12BIT_WB	fourcc_mod_code(AMLOGIC, 5)
+#define DRM_FORMAT_MOD_MESON_YUV444_10BIT_WB	fourcc_mod_code(AMLOGIC, 6)
+
 
 #if defined(__cplusplus)
 }
-- 
2.24.1

