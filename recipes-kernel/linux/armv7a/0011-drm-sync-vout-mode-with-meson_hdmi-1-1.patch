From 8b129c1930948cc8ac19086d2226caecef78c6a6 Mon Sep 17 00:00:00 2001
From: Dezhi Kong <dezhi.kong@amlogic.com>
Date: Mon, 16 Mar 2020 08:43:58 +0800
Subject: [PATCH] drm: sync vout mode with meson_hdmi [1/1]

PD#SWPL-22246

Problem:
when connetor is 4K-tv,the crash of NULL pointer maybe happen

Solution:
1.replace the vout name get interface with hdmitx internal interface
2.add null vout mode for crtc vout mode check
3.fix primary plane display issue for not full screen case
4.fix display issue when mode change from non 4K to 4K first time
5.change osdblend alpha to 0 as default,sync from osd driver
6.add cvbs get mode interface
7.fix osd scaler bank length issue
8.fix osd input mif scope calc issue

Verify:
verify by u212

Change-Id: I7479796e043b871fbb6fef081150b90a659eaf96
Signed-off-by: Dezhi Kong <dezhi.kong@amlogic.com>
---
 drivers/amlogic/drm/meson_drv.c               |  6 +-
 drivers/amlogic/drm/meson_plane.c             | 49 +++++++------
 drivers/amlogic/drm/meson_vpu.c               | 69 ++++---------------
 drivers/amlogic/drm/meson_vpu.h               |  7 +-
 .../amlogic/drm/meson_vpu_pipeline_traverse.c | 33 ++++++---
 drivers/amlogic/drm/vpu-hw/meson_osd_scaler.c |  4 +-
 .../amlogic/drm/vpu-hw/meson_vpu_osdblend.c   |  4 +-
 7 files changed, 79 insertions(+), 93 deletions(-)

diff --git a/drivers/amlogic/drm/meson_drv.c b/drivers/amlogic/drm/meson_drv.c
index 504f30915453..b5eda379acb1 100644
--- a/drivers/amlogic/drm/meson_drv.c
+++ b/drivers/amlogic/drm/meson_drv.c
@@ -180,6 +180,7 @@ am_meson_drm_display_mode_init(struct drm_connector *connector)
 	struct drm_display_mode *mode;
 	struct drm_device *dev;
 	u32 found, num_modes;
+	char *name;
 
 	if (!connector || !connector->dev)
 		return NULL;
@@ -197,7 +198,8 @@ am_meson_drm_display_mode_init(struct drm_connector *connector)
 		return NULL;
 	}
 	list_for_each_entry(mode, &connector->modes, head) {
-		if (am_meson_crtc_check_mode(mode, logo.outputmode) == true) {
+		name = am_meson_crtc_get_voutmode(mode);
+		if (!strcmp(name, logo.outputmode)) {
 			found = 1;
 			break;
 		}
@@ -415,7 +417,9 @@ static void am_meson_load_logo(struct drm_device *dev)
 				      GFP_KERNEL);
 	if (!connector_set)
 		return;
+#ifdef CONFIG_DRM_MESON_HDMI
 	connector_set[0] = am_meson_hdmi_connector();
+#endif
 	if (!connector_set[0]) {
 		DRM_INFO("%s:connector is NULL!\n", __func__);
 		kfree(connector_set);
diff --git a/drivers/amlogic/drm/meson_plane.c b/drivers/amlogic/drm/meson_plane.c
index 00dbede80766..569e7e2e9ad0 100644
--- a/drivers/amlogic/drm/meson_plane.c
+++ b/drivers/amlogic/drm/meson_plane.c
@@ -52,17 +52,15 @@ static u64 afbc_wb_modifier[] = {
 static void
 meson_plane_position_calc(struct meson_vpu_osd_layer_info *plane_info,
 			  struct drm_plane_state *state,
-			  struct drm_display_mode *disp_mode)
+			  struct meson_vpu_pipeline *pipeline)
 {
 	u32 dst_w, dst_h, src_w, src_h, scan_mode_out;
-	struct drm_display_mode *mode;
 	struct am_osd_plane *amp;
-
-	if (!IS_ERR_OR_NULL(state->crtc) && state->crtc->mode.hdisplay &&
-	    state->crtc->mode.vdisplay)
-		mode = &state->crtc->mode;
-	else
-		mode = disp_mode;
+	struct drm_atomic_state *atomic_state = state->state;
+	struct drm_crtc *crtc = pipeline->crtc;
+	unsigned int index = drm_crtc_index(crtc);
+	struct drm_crtc_state *crtc_state = atomic_state->crtcs[index].state;
+	struct drm_display_mode *mode = &crtc_state->mode;
 
 	scan_mode_out = mode->flags & DRM_MODE_FLAG_INTERLACE;
 	plane_info->src_x = state->src_x >> 16;
@@ -114,15 +112,26 @@ meson_plane_position_calc(struct meson_vpu_osd_layer_info *plane_info,
 	if ((plane_info->dst_x + plane_info->dst_w) > mode->hdisplay) {
 		if (plane_info->dst_x >= mode->hdisplay)
 			plane_info->enable = 0;
-		else
+		else {
+			dst_w = plane_info->dst_w;
+			src_w = plane_info->src_w;
 			plane_info->dst_w =
 				mode->hdisplay - plane_info->dst_x;
+			plane_info->src_w =
+				(src_w * plane_info->dst_w) / dst_w;
+		}
 	}
 	if ((plane_info->dst_y + plane_info->dst_h) > mode->vdisplay) {
 		if (plane_info->dst_y >= mode->vdisplay)
 			plane_info->enable = 0;
-		else
-			plane_info->dst_h = mode->vdisplay - plane_info->dst_y;
+		else {
+			dst_h = plane_info->dst_h;
+			src_h = plane_info->src_h;
+			plane_info->dst_h =
+				mode->vdisplay - plane_info->dst_y;
+			plane_info->src_h =
+				(src_h * plane_info->dst_h) / dst_h;
+		}
 	}
 	/*reverse process*/
 	if (plane_info->rotation & DRM_REFLECT_X)
@@ -136,16 +145,14 @@ meson_plane_position_calc(struct meson_vpu_osd_layer_info *plane_info,
 static void
 meson_video_plane_position_calc(struct meson_vpu_video_layer_info *plane_info,
 				struct drm_plane_state *state,
-			  struct drm_display_mode *disp_mode)
+				struct meson_vpu_pipeline *pipeline)
 {
 	u32 dst_w, dst_h, src_w, src_h, scan_mode_out;
-	struct drm_display_mode *mode;
-
-	if (!IS_ERR_OR_NULL(state->crtc) && state->crtc->mode.hdisplay &&
-	    state->crtc->mode.vdisplay)
-		mode = &state->crtc->mode;
-	else
-		mode = disp_mode;
+	struct drm_atomic_state *atomic_state = state->state;
+	struct drm_crtc *crtc = pipeline->crtc;
+	unsigned int index = drm_crtc_index(crtc);
+	struct drm_crtc_state *crtc_state = atomic_state->crtcs[index].state;
+	struct drm_display_mode *mode = &crtc_state->mode;
 
 	scan_mode_out = mode->flags & DRM_MODE_FLAG_INTERLACE;
 	plane_info->src_x = state->src_x >> 16;
@@ -619,7 +626,7 @@ static int meson_plane_atomic_check(struct drm_plane *plane,
 	plane_info->zorder = state->zpos;
 
 	mvps->plane_index[osd_plane->plane_index] = osd_plane->plane_index;
-	meson_plane_position_calc(plane_info, state, &mvps->pipeline->mode);
+	meson_plane_position_calc(plane_info, state, mvps->pipeline);
 	ret = meson_plane_check_size_range(plane_info);
 	if (ret < 0) {
 		plane_info->enable = 0;
@@ -680,7 +687,7 @@ static int meson_video_plane_atomic_check(struct drm_plane *plane,
 
 	mvps->plane_index[video_plane->plane_index] = video_plane->plane_index;
 	meson_video_plane_position_calc(plane_info, state,
-					&mvps->pipeline->mode);
+					mvps->pipeline);
 	ret = meson_video_plane_fb_check(plane, state, plane_info);
 	if (ret < 0) {
 		plane_info->enable = 0;
diff --git a/drivers/amlogic/drm/meson_vpu.c b/drivers/amlogic/drm/meson_vpu.c
index 91102d5d6465..2312d64bd909 100644
--- a/drivers/amlogic/drm/meson_vpu.c
+++ b/drivers/amlogic/drm/meson_vpu.c
@@ -63,29 +63,7 @@ struct vpu_device_data_s {
 	u32 viu1_osd_count;
 	struct clk *vpu_clkc;
 };
-
-static struct am_vout_mode am_vout_modes[] = {
-	{ "1080p60hz", VMODE_HDMI, 1920, 1080, 60, 0},
-	{ "1080p30hz", VMODE_HDMI, 1920, 1080, 30, 0},
-	{ "1080p50hz", VMODE_HDMI, 1920, 1080, 50, 0},
-	{ "1080p25hz", VMODE_HDMI, 1920, 1080, 25, 0},
-	{ "1080p24hz", VMODE_HDMI, 1920, 1080, 24, 0},
-	{ "2160p30hz", VMODE_HDMI, 3840, 2160, 30, 0},
-	{ "2160p60hz", VMODE_HDMI, 3840, 2160, 60, 0},
-	{ "2160p50hz", VMODE_HDMI, 3840, 2160, 50, 0},
-	{ "2160p25hz", VMODE_HDMI, 3840, 2160, 25, 0},
-	{ "2160p24hz", VMODE_HDMI, 3840, 2160, 24, 0},
-	{ "1080i60hz", VMODE_HDMI, 1920, 1080, 60, DRM_MODE_FLAG_INTERLACE},
-	{ "1080i50hz", VMODE_HDMI, 1920, 1080, 50, DRM_MODE_FLAG_INTERLACE},
-	{ "720p60hz", VMODE_HDMI, 1280, 720, 60, 0},
-	{ "720p50hz", VMODE_HDMI, 1280, 720, 50, 0},
-	{ "480p60hz", VMODE_HDMI, 720, 480, 60, 0},
-	{ "480i60hz", VMODE_HDMI, 720, 480, 60, DRM_MODE_FLAG_INTERLACE},
-	{ "576p50hz", VMODE_HDMI, 720, 576, 50, 0},
-	{ "576i50hz", VMODE_HDMI, 720, 576, 50, DRM_MODE_FLAG_INTERLACE},
-	{ "480p60hz", VMODE_HDMI, 720, 480, 60, 0},
-};
-
+#define AM_VOUT_NULL_MODE "null"
 
 static struct osd_device_data_s osd_gxbb = {
 	.cpu_id = __MESON_CPU_MAJOR_ID_GXBB,
@@ -328,45 +306,24 @@ const struct meson_crtc_funcs meson_private_crtc_funcs = {
 
 char *am_meson_crtc_get_voutmode(struct drm_display_mode *mode)
 {
-	int i;
 	struct vinfo_s *vinfo;
+	char *name = NULL;
 
 	vinfo = get_current_vinfo();
 
 	if (vinfo && vinfo->mode == VMODE_LCD)
 		return mode->name;
-
-	for (i = 0; i < ARRAY_SIZE(am_vout_modes); i++) {
-		if (am_vout_modes[i].width == mode->hdisplay &&
-		    am_vout_modes[i].height == mode->vdisplay &&
-		    am_vout_modes[i].vrefresh == mode->vrefresh &&
-		    am_vout_modes[i].flags ==
-		    (mode->flags & DRM_MODE_FLAG_INTERLACE))
-			return am_vout_modes[i].name;
-	}
-	return NULL;
-}
-
-bool am_meson_crtc_check_mode(struct drm_display_mode *mode, char *outputmode)
-{
-	int i;
-
-	if (!mode || !outputmode)
-		return false;
-	if (!strcmp(mode->name, "panel"))
-		return true;
-
-	for (i = 0; i < ARRAY_SIZE(am_vout_modes); i++) {
-		if (!strcmp(am_vout_modes[i].name, outputmode) &&
-		    am_vout_modes[i].width == mode->hdisplay &&
-		    am_vout_modes[i].height == mode->vdisplay &&
-		    am_vout_modes[i].vrefresh == mode->vrefresh &&
-		    am_vout_modes[i].flags ==
-		    (mode->flags & DRM_MODE_FLAG_INTERLACE)) {
-			return true;
-		}
-	}
-	return false;
+#ifdef CONFIG_DRM_MESON_HDMI
+	name = am_meson_hdmi_get_voutmode(mode);
+#endif
+#ifdef CONFIG_DRM_MESON_CVBS
+	if (name == NULL)
+		name = am_cvbs_get_voutmode(mode);
+#endif
+	if (name == NULL)
+		return AM_VOUT_NULL_MODE;
+	else
+		return name;
 }
 
 void am_meson_crtc_handle_vsync(struct am_meson_crtc *amcrtc)
diff --git a/drivers/amlogic/drm/meson_vpu.h b/drivers/amlogic/drm/meson_vpu.h
index f400ee263f3a..fe1e71b71cee 100644
--- a/drivers/amlogic/drm/meson_vpu.h
+++ b/drivers/amlogic/drm/meson_vpu.h
@@ -35,6 +35,11 @@ extern struct am_meson_logo logo;
 extern struct osd_device_data_s osd_meson_dev;
 char *am_meson_crtc_get_voutmode(struct drm_display_mode *mode);
 void am_meson_free_logo_memory(void);
-bool am_meson_crtc_check_mode(struct drm_display_mode *mode, char *outputmode);
+#ifdef CONFIG_DRM_MESON_HDMI
+extern char *am_meson_hdmi_get_voutmode(struct drm_display_mode *mode);
+#endif
+#ifdef CONFIG_DRM_MESON_CVBS
+extern char *am_cvbs_get_voutmode(struct drm_display_mode *mode);
+#endif
 
 #endif /* __AM_MESON_VPU_H */
diff --git a/drivers/amlogic/drm/meson_vpu_pipeline_traverse.c b/drivers/amlogic/drm/meson_vpu_pipeline_traverse.c
index bf6ce499205e..7f8ec14e148a 100644
--- a/drivers/amlogic/drm/meson_vpu_pipeline_traverse.c
+++ b/drivers/amlogic/drm/meson_vpu_pipeline_traverse.c
@@ -177,15 +177,15 @@ void vpu_pipeline_scaler_scope_size_calc(u8 index, u8 osd_index,
 	if (mvps->scaler_cnt[i] == 0) {
 		/*scope size calc*/
 		mvps->osd_scope_pre[osd_index].h_start =
-			mvps->plane_info[osd_index].src_x;
+			mvps->plane_info[osd_index].dst_x;
 		mvps->osd_scope_pre[osd_index].v_start =
-			mvps->plane_info[osd_index].src_y;
+			mvps->plane_info[osd_index].dst_y;
 		mvps->osd_scope_pre[osd_index].h_end =
 			mvps->osd_scope_pre[osd_index].h_start
-			+ mvps->plane_info[osd_index].src_w - 1;
+			+ mvps->plane_info[osd_index].dst_w - 1;
 		mvps->osd_scope_pre[osd_index].v_end =
 			mvps->osd_scope_pre[osd_index].v_start
-			+ mvps->plane_info[osd_index].src_h - 1;
+			+ mvps->plane_info[osd_index].dst_h - 1;
 	} else if (mvps->scaler_cnt[i] == 1) {
 		m = mvps->scale_blk[i][0]->index;
 		scaler_param = &mvps->scaler_param[m];
@@ -215,7 +215,7 @@ void vpu_pipeline_scaler_scope_size_calc(u8 index, u8 osd_index,
 				SCALER_IN_H_CALC_DONE |
 				SCALER_OUT_W_CALC_DONE |
 				SCALER_OUT_H_CALC_DONE;
-			/*scope size calc*/
+			/*osdblend scope size calc*/
 			mvps->osd_scope_pre[osd_index].h_start =
 				mvps->plane_info[osd_index].dst_x;
 			mvps->osd_scope_pre[osd_index].v_start =
@@ -227,17 +227,30 @@ void vpu_pipeline_scaler_scope_size_calc(u8 index, u8 osd_index,
 				mvps->osd_scope_pre[osd_index].v_start
 				+ scaler_param->output_height - 1;
 		} else {/*scaler position is after osdlend*/
-			/*scope size calc firstly*/
+			/*osdblend scope size calc firstly*/
 			mvps->osd_scope_pre[osd_index].h_start =
-				mvps->plane_info[osd_index].src_x;
+				(mvps->plane_info[osd_index].dst_x *
+				scaler_param->ratio_x) / RATIO_BASE;
 			mvps->osd_scope_pre[osd_index].v_start =
-				mvps->plane_info[osd_index].src_y;
+				(mvps->plane_info[osd_index].dst_y *
+				scaler_param->ratio_y) / RATIO_BASE;
 			mvps->osd_scope_pre[osd_index].h_end =
 				mvps->osd_scope_pre[osd_index].h_start
-				+ mvps->plane_info[osd_index].src_w - 1;
+				+ (mvps->plane_info[osd_index].dst_w *
+				scaler_param->ratio_x) / RATIO_BASE - 1;
 			mvps->osd_scope_pre[osd_index].v_end =
 				mvps->osd_scope_pre[osd_index].v_start
-				+ mvps->plane_info[osd_index].src_h - 1;
+				+ (mvps->plane_info[osd_index].dst_h *
+				scaler_param->ratio_y) / RATIO_BASE - 1;
+			/*reset osd input mif scope,avoid no match with
+			 *the result of osdblend scope
+			 */
+			mvps->plane_info[osd_index].src_w =
+				mvps->osd_scope_pre[osd_index].h_end -
+				mvps->osd_scope_pre[osd_index].h_start + 1;
+			mvps->plane_info[osd_index].src_h =
+				mvps->osd_scope_pre[osd_index].v_end -
+				mvps->osd_scope_pre[osd_index].v_start + 1;
 			/*scaler size calc*/
 			scaler_param->input_width =
 				mvps->osd_scope_pre[osd_index].h_end + 1;
diff --git a/drivers/amlogic/drm/vpu-hw/meson_osd_scaler.c b/drivers/amlogic/drm/vpu-hw/meson_osd_scaler.c
index 712228919140..e903fb40a7a5 100644
--- a/drivers/amlogic/drm/vpu-hw/meson_osd_scaler.c
+++ b/drivers/amlogic/drm/vpu-hw/meson_osd_scaler.c
@@ -182,7 +182,7 @@ void osd_vsc_top_ini_rcv_num_set(struct osd_scaler_reg_s *reg, u32 data)
 /*vsc bank length??*/
 void osd_vsc_bank_length_set(struct osd_scaler_reg_s *reg, u32 data)
 {
-	VSYNCOSD_WR_MPEG_REG_BITS(reg->vpp_osd_vsc_ctrl0, data, 0, 2);
+	VSYNCOSD_WR_MPEG_REG_BITS(reg->vpp_osd_vsc_ctrl0, data, 0, 3);
 }
 /*********vsc config end**********/
 
@@ -244,7 +244,7 @@ void osd_hsc_ini_rcv_num0_set(struct osd_scaler_reg_s *reg, u32 data)
 /*hsc bank length*/
 void osd_hsc_bank_length_set(struct osd_scaler_reg_s *reg, u32 data)
 {
-	VSYNCOSD_WR_MPEG_REG_BITS(reg->vpp_osd_hsc_ctrl0, data, 0, 2);
+	VSYNCOSD_WR_MPEG_REG_BITS(reg->vpp_osd_hsc_ctrl0, data, 0, 3);
 }
 /*
  *hsc init pattern
diff --git a/drivers/amlogic/drm/vpu-hw/meson_vpu_osdblend.c b/drivers/amlogic/drm/vpu-hw/meson_vpu_osdblend.c
index 5c048ab82f09..e3fb091c490d 100644
--- a/drivers/amlogic/drm/vpu-hw/meson_vpu_osdblend.c
+++ b/drivers/amlogic/drm/vpu-hw/meson_vpu_osdblend.c
@@ -269,9 +269,9 @@ static void osdblend_hw_update(struct osdblend_reg_s *reg,
 	osd_blend_dummy_data_set(reg, dummy_data);
 
 	/*alpha config*/
-	osd_blend0_dummy_alpha_set(reg, 0x1ff);
+	osd_blend0_dummy_alpha_set(reg, 0);
 	osd_blend1_dummy_alpha_set(reg, 0);
-	osd_blend2_dummy_alpha_set(reg, 0x1ff);
+	osd_blend2_dummy_alpha_set(reg, 0);
 
 	/*internal channel disable default*/
 	osd_din0_input_enable_set(reg, (mvobs->input_mask >> DIN0) & 0x1);
-- 
2.24.1

