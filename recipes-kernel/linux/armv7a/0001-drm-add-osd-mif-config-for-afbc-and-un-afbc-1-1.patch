From b3ec29306193eae66affd7ac2ebc08581791d3e1 Mon Sep 17 00:00:00 2001
From: Dezhi Kong <dezhi.kong@amlogic.com>
Date: Mon, 6 Jan 2020 22:34:04 +0800
Subject: [PATCH 01/11] drm: add osd mif config for afbc and un-afbc [1/1]

PD#SWPL-19163

Problem:
osd/gfx corruption when use drm display

Solution:
add osd mif endian-mode/unpack-mode/mem-mode update.

Verify:
t962x3_ab301 u212-g12a

Change-Id: I30c20f78a2b151c6c9f8789bb3a0b2ff6bb375a9
Signed-off-by: Dezhi Kong <dezhi.kong@amlogic.com>
---
 drivers/amlogic/drm/meson_vpu_pipeline.h      |   1 +
 .../amlogic/drm/vpu-hw/meson_vpu_osd_mif.c    | 164 +++++++++++++++---
 .../amlogic/drm/vpu-hw/meson_vpu_osd_mif.h    |  38 +++-
 3 files changed, 174 insertions(+), 29 deletions(-)

diff --git a/drivers/amlogic/drm/meson_vpu_pipeline.h b/drivers/amlogic/drm/meson_vpu_pipeline.h
index 2ce8d9f2215f..06c3624deef7 100644
--- a/drivers/amlogic/drm/meson_vpu_pipeline.h
+++ b/drivers/amlogic/drm/meson_vpu_pipeline.h
@@ -207,6 +207,7 @@ struct meson_vpu_osd_state {
 	u32 plane_index;
 	u32 fb_size;
 	u32 premult_en;
+	u32 afbc_en;
 };
 
 struct meson_vpu_afbc {
diff --git a/drivers/amlogic/drm/vpu-hw/meson_vpu_osd_mif.c b/drivers/amlogic/drm/vpu-hw/meson_vpu_osd_mif.c
index 01e4ab7e37cf..c19e973ac8c9 100644
--- a/drivers/amlogic/drm/vpu-hw/meson_vpu_osd_mif.c
+++ b/drivers/amlogic/drm/vpu-hw/meson_vpu_osd_mif.c
@@ -110,29 +110,92 @@ const struct meson_drm_format_info *__meson_drm_format_info(u32 format)
 {
 	static const struct meson_drm_format_info formats[] = {
 		{ .format = DRM_FORMAT_XRGB8888,
-			.hw_blkmode = 5, .hw_colormat = 1, .alpha_replace = 1 },
+			.hw_blkmode = BLOCK_MODE_32BIT,
+			.hw_colormat = COLOR_MATRIX_ARGB8888,
+			.alpha_replace = 1 },
 		{ .format = DRM_FORMAT_XBGR8888,
-			.hw_blkmode = 5, .hw_colormat = 2, .alpha_replace = 1 },
+			.hw_blkmode = BLOCK_MODE_32BIT,
+			.hw_colormat = COLOR_MATRIX_ABGR8888,
+			.alpha_replace = 1 },
 		{ .format = DRM_FORMAT_RGBX8888,
-			.hw_blkmode = 5, .hw_colormat = 0, .alpha_replace = 1 },
+			.hw_blkmode = BLOCK_MODE_32BIT,
+			.hw_colormat = COLOR_MATRIX_RGBA8888,
+			.alpha_replace = 1 },
 		{ .format = DRM_FORMAT_BGRX8888,
-			.hw_blkmode = 5, .hw_colormat = 3, .alpha_replace = 1 },
+			.hw_blkmode = BLOCK_MODE_32BIT,
+			.hw_colormat = COLOR_MATRIX_BGRA8888,
+			.alpha_replace = 1 },
 		{ .format = DRM_FORMAT_ARGB8888,
-			.hw_blkmode = 5, .hw_colormat = 1, .alpha_replace = 0 },
+			.hw_blkmode = BLOCK_MODE_32BIT,
+			.hw_colormat = COLOR_MATRIX_ARGB8888,
+			.alpha_replace = 0 },
 		{ .format = DRM_FORMAT_ABGR8888,
-			.hw_blkmode = 5, .hw_colormat = 2, .alpha_replace = 0 },
+			.hw_blkmode = BLOCK_MODE_32BIT,
+			.hw_colormat = COLOR_MATRIX_ABGR8888,
+			.alpha_replace = 0 },
 		{ .format = DRM_FORMAT_RGBA8888,
-			.hw_blkmode = 5, .hw_colormat = 0, .alpha_replace = 0 },
+			.hw_blkmode = BLOCK_MODE_32BIT,
+			.hw_colormat = COLOR_MATRIX_RGBA8888,
+			.alpha_replace = 0 },
 		{ .format = DRM_FORMAT_BGRA8888,
-			.hw_blkmode = 5, .hw_colormat = 3, .alpha_replace = 0 },
+			.hw_blkmode = BLOCK_MODE_32BIT,
+			.hw_colormat = COLOR_MATRIX_BGRA8888,
+			.alpha_replace = 0 },
 		{ .format = DRM_FORMAT_RGB888,
-			.hw_blkmode = 7, .hw_colormat = 0, .alpha_replace = 0 },
+			.hw_blkmode = BLOCK_MODE_24BIT,
+			.hw_colormat = COLOR_MATRIX_RGB888,
+			.alpha_replace = 0 },
 		{ .format = DRM_FORMAT_RGB565,
-			.hw_blkmode = 4, .hw_colormat = 4, .alpha_replace = 0 },
-		{ .format = DRM_FORMAT_ARGB1555,
-			.hw_blkmode = 4, .hw_colormat = 6, .alpha_replace = 0 },
-		{ .format = DRM_FORMAT_ARGB4444,
-			.hw_blkmode = 4, .hw_colormat = 5, .alpha_replace = 0 },
+			.hw_blkmode = BLOCK_MODE_16BIT,
+			.hw_colormat = COLOR_MATRIX_565,
+			.alpha_replace = 0 },
+	};
+
+	unsigned int i;
+
+	for (i = 0; i < ARRAY_SIZE(formats); ++i) {
+		if (formats[i].format == format)
+			return &formats[i];
+	}
+
+	return NULL;
+}
+const struct meson_drm_format_info *__meson_drm_afbc_format_info(u32 format)
+{
+	static const struct meson_drm_format_info formats[] = {
+		{ .format = DRM_FORMAT_XRGB8888,
+			.hw_blkmode = BLOCK_MODE_RGBA8888,
+			.alpha_replace = 1 },
+		{ .format = DRM_FORMAT_XBGR8888,
+			.hw_blkmode = BLOCK_MODE_RGBA8888,
+			.alpha_replace = 1 },
+		{ .format = DRM_FORMAT_RGBX8888,
+			.hw_blkmode = BLOCK_MODE_RGBA8888,
+			.alpha_replace = 1 },
+		{ .format = DRM_FORMAT_BGRX8888,
+			.hw_blkmode = BLOCK_MODE_RGBA8888,
+			.alpha_replace = 1 },
+		{ .format = DRM_FORMAT_ARGB8888,
+			.hw_blkmode = BLOCK_MODE_RGBA8888,
+			.alpha_replace = 0 },
+		{ .format = DRM_FORMAT_ABGR8888,
+			.hw_blkmode = BLOCK_MODE_RGBA8888,
+			.alpha_replace = 0 },
+		{ .format = DRM_FORMAT_RGBA8888,
+			.hw_blkmode = BLOCK_MODE_RGBA8888,
+			.alpha_replace = 0 },
+		{ .format = DRM_FORMAT_BGRA8888,
+			.hw_blkmode = BLOCK_MODE_RGBA8888,
+			.alpha_replace = 0 },
+		{ .format = DRM_FORMAT_RGB888,
+			.hw_blkmode = BLOCK_MODE_RGB888,
+			.alpha_replace = 0 },
+		{ .format = DRM_FORMAT_RGB565,
+			.hw_blkmode = BLOCK_MODE_RGB565,
+			.alpha_replace = 0 },
+		{ .format = DRM_FORMAT_RGBA1010102,
+			.hw_blkmode = BLOCK_MODE_RGBA1010102,
+			.alpha_replace = 0 },
 	};
 
 	unsigned int i;
@@ -155,11 +218,15 @@ const struct meson_drm_format_info *__meson_drm_format_info(u32 format)
  * The instance of struct meson_drm_format_info that describes the
  * pixel format, or NULL if the format is unsupported.
  */
-const struct meson_drm_format_info *meson_drm_format_info(u32 format)
+const struct meson_drm_format_info *meson_drm_format_info(u32 format,
+							  bool afbc_en)
 {
 	const struct meson_drm_format_info *info;
 
-	info = __meson_drm_format_info(format);
+	if (afbc_en)
+		info = __meson_drm_afbc_format_info(format);
+	else
+		info = __meson_drm_format_info(format);
 	WARN_ON(!info);
 	return info;
 }
@@ -170,11 +237,11 @@ const struct meson_drm_format_info *meson_drm_format_info(u32 format)
  * Returns:
  * The hw_blkmode match the specified pixel format.
  */
-static u8 meson_drm_format_hw_blkmode(uint32_t format)
+static u8 meson_drm_format_hw_blkmode(uint32_t format, bool afbc_en)
 {
 	const struct meson_drm_format_info *info;
 
-	info = meson_drm_format_info(format);
+	info = meson_drm_format_info(format, afbc_en);
 	return info ? info->hw_blkmode : 0;
 }
 /**
@@ -184,11 +251,11 @@ static u8 meson_drm_format_hw_blkmode(uint32_t format)
  * Returns:
  * The hw_colormat match the specified pixel format.
  */
-static u8 meson_drm_format_hw_colormat(uint32_t format)
+static u8 meson_drm_format_hw_colormat(uint32_t format, bool afbc_en)
 {
 	const struct meson_drm_format_info *info;
 
-	info = meson_drm_format_info(format);
+	info = meson_drm_format_info(format, afbc_en);
 	return info ? info->hw_colormat : 0;
 }
 /**
@@ -198,11 +265,11 @@ static u8 meson_drm_format_hw_colormat(uint32_t format)
  * Returns:
  * The alpha_replace match the specified pixel format.
  */
-static u8 meson_drm_format_alpha_replace(uint32_t format)
+static u8 meson_drm_format_alpha_replace(uint32_t format, bool afbc_en)
 {
 	const struct meson_drm_format_info *info;
 
-	info = meson_drm_format_info(format);
+	info = meson_drm_format_info(format, afbc_en);
 	return info ? info->alpha_replace : 0;
 }
 /*osd input size config*/
@@ -221,12 +288,34 @@ void osd_canvas_config(struct osd_mif_reg_s *reg, u32 canvas_index)
 	VSYNCOSD_WR_MPEG_REG_BITS(reg->viu_osd_blk0_cfg_w0,
 		canvas_index, 16, 8);
 }
+/*osd mali afbc src en
+ * 1: read data from mali afbcd;0: read data from DDR directly
+ */
+void osd_mali_src_en(struct osd_mif_reg_s *reg, bool flag)
+{
+	VSYNCOSD_WR_MPEG_REG_BITS(reg->viu_osd_blk0_cfg_w0, flag, 30, 1);
+}
+/*osd endian mode
+ * 1: little endian;0: big endian[for mali afbc input]
+ */
+void osd_endian_mode(struct osd_mif_reg_s *reg, bool flag)
+{
+	VSYNCOSD_WR_MPEG_REG_BITS(reg->viu_osd_blk0_cfg_w0, flag, 15, 1);
+}
 /*osd mif enable*/
 void osd_block_enable(struct osd_mif_reg_s *reg, bool flag)
 {
 	VSYNCOSD_WR_MPEG_REG_BITS(reg->viu_osd_ctrl_stat, flag, 0, 1);
 }
 
+/*osd mem mode
+ * 0: canvas_addr;1:linear_addr[for mali-afbc-mode]
+ */
+void osd_mem_mode(struct osd_mif_reg_s *reg, bool mode)
+{
+	VSYNCOSD_WR_MPEG_REG_BITS(reg->viu_osd_ctrl_stat, mode, 2, 1);
+}
+
 /*osd alpha_div en
  *if input is premult,alpha_div=1,else alpha_div=0
  */
@@ -234,6 +323,13 @@ void osd_alpha_div_enable(struct osd_mif_reg_s *reg, bool flag)
 {
 	VSYNCOSD_WR_MPEG_REG_BITS(reg->viu_osd_mali_unpack_ctrl, flag, 28, 1);
 }
+/*osd mali unpack en
+ * 1: osd will unpack mali_afbc_src;0:osd will unpack normal src
+ */
+void osd_mali_unpack_enable(struct osd_mif_reg_s *reg, bool flag)
+{
+	VSYNCOSD_WR_MPEG_REG_BITS(reg->viu_osd_mali_unpack_ctrl, flag, 31, 1);
+}
 
 /*osd ctrl config*/
 void osd_ctrl_set(struct osd_mif_reg_s *reg)
@@ -320,13 +416,14 @@ void osd_ctrl_set(struct osd_mif_reg_s *reg)
 			     (4 << 0)/*afbcd_r_reorder alpha 4bits*/);
 }
 
-static void osd_color_config(struct osd_mif_reg_s *reg, u32 pixel_format)
+static void osd_color_config(struct osd_mif_reg_s *reg,
+			     u32 pixel_format, bool afbc_en)
 {
 	u8 blk_mode, colormat, alpha_replace;
 
-	blk_mode = meson_drm_format_hw_blkmode(pixel_format);
-	colormat = meson_drm_format_hw_colormat(pixel_format);
-	alpha_replace = meson_drm_format_alpha_replace(pixel_format);
+	blk_mode = meson_drm_format_hw_blkmode(pixel_format, afbc_en);
+	colormat = meson_drm_format_hw_colormat(pixel_format, afbc_en);
+	alpha_replace = meson_drm_format_alpha_replace(pixel_format, afbc_en);
 	VSYNCOSD_WR_MPEG_REG_BITS(reg->viu_osd_blk0_cfg_w0,
 			blk_mode, 8, 4);
 	VSYNCOSD_WR_MPEG_REG_BITS(reg->viu_osd_blk0_cfg_w0,
@@ -335,6 +432,14 @@ static void osd_color_config(struct osd_mif_reg_s *reg, u32 pixel_format)
 				  alpha_replace, 14, 1);
 }
 
+static void osd_afbc_config(struct osd_mif_reg_s *reg, bool afbc_en)
+{
+	osd_mali_unpack_enable(reg, afbc_en);
+	osd_mali_src_en(reg, afbc_en);
+	osd_endian_mode(reg, ~afbc_en);
+	osd_mem_mode(reg, afbc_en);
+}
+
 static int osd_check_state(struct meson_vpu_block *vblk,
 		struct meson_vpu_block_state *state,
 		struct meson_vpu_pipeline_state *mvps)
@@ -363,6 +468,7 @@ static int osd_check_state(struct meson_vpu_block *vblk,
 	mvos->pixel_format = plane_info->pixel_format;
 	mvos->fb_size = plane_info->fb_size;
 	mvos->premult_en = plane_info->premult_en;
+	mvos->afbc_en = plane_info->afbc_en;
 	return 0;
 }
 
@@ -380,7 +486,7 @@ static void osd_set_state(struct meson_vpu_block *vblk,
 	u32 pixel_format, canvas_index, src_h, byte_stride, phy_addr;
 	struct osd_scope_s scope_src = {0, 1919, 0, 1079};
 	struct osd_mif_reg_s *reg = osd->reg;
-	bool alpha_div_en;
+	bool alpha_div_en, afbc_en;
 
 	crtc = vblk->pipeline->crtc;
 	amc = to_am_meson_crtc(crtc);
@@ -390,6 +496,7 @@ static void osd_set_state(struct meson_vpu_block *vblk,
 		return;
 	}
 	alpha_div_en = mvos->premult_en ? 1 : 0;
+	afbc_en = mvos->afbc_en ? 1 : 0;
 	src_h = mvos->src_h;
 	byte_stride = mvos->byte_stride;
 	phy_addr = mvos->phy_addr;
@@ -407,7 +514,8 @@ static void osd_set_state(struct meson_vpu_block *vblk,
 	osd_canvas_index[vblk->index] ^= 1;
 	osd_canvas_config(reg, canvas_index);
 	osd_input_size_config(reg, scope_src);
-	osd_color_config(reg, pixel_format);
+	osd_color_config(reg, pixel_format, afbc_en);
+	osd_afbc_config(reg, afbc_en);
 	osd_alpha_div_enable(reg, alpha_div_en);
 	DRM_DEBUG("plane_index=%d,HW-OSD=%d\n",
 		mvos->plane_index, vblk->index);
diff --git a/drivers/amlogic/drm/vpu-hw/meson_vpu_osd_mif.h b/drivers/amlogic/drm/vpu-hw/meson_vpu_osd_mif.h
index f9cf58698562..6f0b0db070ce 100644
--- a/drivers/amlogic/drm/vpu-hw/meson_vpu_osd_mif.h
+++ b/drivers/amlogic/drm/vpu-hw/meson_vpu_osd_mif.h
@@ -151,5 +151,41 @@ struct meson_drm_format_info {
 	u8 alpha_replace;
 };
 
-const struct meson_drm_format_info *meson_drm_format_info(u32 format);
+enum osd_blk_mode_e {
+	BLOCK_MODE_2BIT_PER_PIXEL = 0,
+	BLOCK_MODE_4BIT_PER_PIXEL,
+	BLOCK_MODE_8BIT_PER_PIXEL,
+	BLOCK_MODE_422,
+	BLOCK_MODE_16BIT,
+	BLOCK_MODE_32BIT,
+	BLOCK_MODE_24BIT = 7,
+	/*bellow is for afbc mode*/
+	BLOCK_MODE_R8 = 0,
+	BLOCK_MODE_YUV422_8BIT,
+	BLOCK_MODE_RGB565,
+	BLOCK_MODE_RGBA5551,
+	BLOCK_MODE_RGBA4444,
+	BLOCK_MODE_RGBA8888,
+	BLOCK_MODE_RGB888 = 7,
+	BLOCK_MODE_YUV422_10BIT,
+	BLOCK_MODE_RGBA1010102,
+};
+
+enum osd_color_matrix_e {
+	/*for 16bit:blk-mode=BLOCK_MODE_16BIT*/
+	COLOR_MATRIX_655 = 0,
+	COLOR_MATRIX_844,
+	COLOR_MATRIX_565 = 4,
+	/*for 32bit:blk-mode=BLOCK_MODE_32BIT*/
+	COLOR_MATRIX_RGBA8888 = 0,
+	COLOR_MATRIX_ARGB8888,
+	COLOR_MATRIX_ABGR8888,
+	COLOR_MATRIX_BGRA8888,
+	/*for 24bit:blk-mode=BLOCK_MODE_24BIT*/
+	COLOR_MATRIX_RGB888 = 0,
+	COLOR_MATRIX_BGR888 = 5,
+};
+
+const struct meson_drm_format_info *meson_drm_format_info(u32 format,
+							  bool afbc_en);
 #endif
-- 
2.24.1

