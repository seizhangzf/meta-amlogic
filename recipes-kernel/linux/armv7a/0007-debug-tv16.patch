From b087f8e248efd8a5adfc6f447f086ad7e6b3261d Mon Sep 17 00:00:00 2001
From: yao liu <yao.liu@amlogic.com>
Date: Thu, 14 Nov 2019 19:04:41 +0800
Subject: [PATCH 7/7] debug tv16

Change-Id: I25e38142cc30f4b47c407f32dd777a8c6751c014
Signed-off-by: yao liu <yao.liu@amlogic.com>
---
 .../amdolby_vision/amdolby_vision.c           | 1351 +++++++++++++++--
 .../amdolby_vision/amdolby_vision.h           |  129 +-
 .../amvecm/arch/vpp_dolbyvision_regs.h        |    5 +
 .../media/enhancement/amvecm/arch/vpp_regs.h  |    5 +
 4 files changed, 1326 insertions(+), 164 deletions(-)

diff --git a/drivers/amlogic/media/enhancement/amdolby_vision/amdolby_vision.c b/drivers/amlogic/media/enhancement/amdolby_vision/amdolby_vision.c
index bc9da77a2efe..fbbb0363ce73 100644
--- a/drivers/amlogic/media/enhancement/amdolby_vision/amdolby_vision.c
+++ b/drivers/amlogic/media/enhancement/amdolby_vision/amdolby_vision.c
@@ -205,6 +205,21 @@ static unsigned int dolby_vision_src_format;
 module_param(dolby_vision_src_format, uint, 0664);
 MODULE_PARM_DESC(dolby_vision_src_format, "\n dolby_vision_src_format\n");
 
+static unsigned int force_mel;
+module_param(force_mel, uint, 0664);
+MODULE_PARM_DESC(force_mel, "\n force_mel\n");
+
+static unsigned int force_best_pq;
+module_param(force_best_pq, uint, 0664);
+MODULE_PARM_DESC(force_best_pq, "\n force_best_pq\n");
+
+/*0:cfg_0.001_6300_POWER_2.4_YUV_NARROW_v2.txt      -tid2*/
+/*1:cfg_0.034_890_BT1886_2.2_YUV_NARROW_v2.txt      -tid2*/
+/*2:cfg_0.01_700_POWER_2.4_YUV_NARROW_v1-12.txt      -tid2*/
+static unsigned int cfg_ll_id;
+module_param(cfg_ll_id, uint, 0664);
+MODULE_PARM_DESC(cfg_ll_id, "\n cfg_ll_id\n");
+
 static uint dolby_vision_on_count;
 static bool dolby_vision_el_disable;
 
@@ -293,6 +308,9 @@ static bool force_set_lut;
 /*core reg must be set at first time. bit0 is for core2, bit1 is for core3*/
 static u32 first_reseted;
 
+module_param(dma_start_line, uint, 0664);
+MODULE_PARM_DESC(dma_start_line, "\n dma_start_line\n");
+
 module_param(vtotal_add, uint, 0664);
 MODULE_PARM_DESC(vtotal_add, "\n vtotal_add\n");
 module_param(vpotch, uint, 0664);
@@ -368,6 +386,12 @@ static unsigned int dolby_vision_graphics_priority;
 module_param(dolby_vision_graphics_priority, uint, 0664);
 MODULE_PARM_DESC(dolby_vision_graphics_priority, "\n dolby_vision_graphics_priority\n");
 
+
+static unsigned int enable_tunnel_before_vdin1;
+module_param(enable_tunnel_before_vdin1, uint, 0664);
+MODULE_PARM_DESC(enable_tunnel_before_vdin1, "\n enable_tunnel_before_vdin1\n");
+
+
 uint16_t L2PQ_100_500[] = {
 	2081, /* 100 */
 	2157, /* 120 */
@@ -438,6 +462,681 @@ static unsigned int panel_max_lumin = 350;
 module_param(panel_max_lumin, uint, 0664);
 MODULE_PARM_DESC(panel_max_lumin, "\n panel_max_lumin\n");
 
+static unsigned int sdr_ref_mode;
+module_param(sdr_ref_mode, uint, 0664);
+MODULE_PARM_DESC(sdr_ref_mode, "\n sdr_ref_mode\n");
+
+#ifdef V1_6_1
+/*cfg_0.005_500_BT1886_2.4_YUV_NARROW_v0.txt    --tid 0 */
+/*tv cert: OTT mode/HDMI MODE(5010~5013 and 5232,5272,5332) use this cfg*/
+struct TargetDisplayConfig def_tgt_display_cfg = {
+	39322, /* gamma */
+	0, /* eotf */
+	0, /* rangeSpec */
+	2771, /* maxPq */
+	62, /* minPq */
+	2771, /* maxPq_dm3 */
+	1311, /* min_lin */
+	131072000, /* max_lin */
+	131072000, /* max_lin_dm3 */
+	{
+	42949672,
+	22145926,
+	20132660,
+	40265320,
+	10066330,
+	4026532,
+	20984942,
+	22078816
+	},/*Target primaries */
+	2048, /* mSWeight */
+	0, /* trimSlopeBias */
+	0, /* trimOffsetBias */
+	0, /* trimPowerBias */
+	0, /* msWeightBias */
+	0, /* chromaWeightBias */
+	0, /* saturationGainBias */
+	0, /* tuningMode */
+	0, /* brightness */
+	0, /* contrast */
+	0, /* brief  ColorShift */
+	0, /* brief  Saturation */
+	4095, /* brief  Backlight */
+	0, /* dbgExecParamsPrintPeriod */
+	0, /* dbgDmMdPrintPeriod */
+	0, /* dbgDmCfgPrintPeriod */
+	{
+		1, /* gdEnable */
+		13, /* gdWMin */
+		131072000, /* gdWMax */
+		1310720, /* gdWMm */
+		82897208, /* gdWDynRngSqrt */
+		4095, /* gdWeightMean */
+		2048, /* gdWeightStd */
+		0, /* gdDelayMilliSec_hdmi */
+		1, /* gdRgb2YuvExt */
+		{
+			{5960, 20047, 2023},
+			{-3286, -11052, 14336},
+			{14336, -13022, -1316}
+		}, /* gdM33Rgb2Yuv[3][3] */
+		15, /* gdM33Rgb2YuvScale2P */
+		1, /* gdRgb2YuvOffExt */
+		{2048, 16384, 16384},/* gdV3Rgb2YuvOff[3] */
+		414486, /* gdUpBound */
+		82897, /* gdLowBound */
+		0, /* lastMaxPq */
+		5, /*gdWMinPq */
+		2771, /*gdWMaxPq */
+		1015, /*gdWMmPq */
+		0, /*gdTriggerPeriod */
+		0, /* gdTriggerLinThresh */
+		0, /* gdDelayMilliSec_ott */
+		4095, /*gdRiseWeight */
+		4095, /* gdFallWeight */
+		0, /* gdDelayMilliSec_ll */
+		444596224, /* gdContrast */
+		{0, 0, 0}
+	},
+	{
+		0,
+		0,
+		0,
+		0,
+		0,
+		0,
+		0,
+		0,
+		{0, 0, 0}
+	},/*TgtABCfg*/
+	{
+		65536,
+		0,
+		4096,
+		5,
+		4096,
+		{10247, 10781},
+		32768,
+		3277,
+		0,
+		1365,
+		1365
+	},/*AmbientCfg*/
+	/*{0, 0, 0, 68, 124, 49, 230},*/
+	{4, 216, 163, 84, 218, 76, 153},/*vsvdb*/
+	0, /*dm31_avail*/
+	2, /*reference_mode_dark_id*/
+	0, /*applyL11*/
+	{0}, /*reserved*/
+	0, /* backlight_scaler */
+	{
+		/* lms2RgbMat[3][3] */
+		{
+			{22416, -19015, 695},
+			{-4609, 9392, -688},
+			{122, -791, 4765}
+		},
+		12, /* lms2RgbMatScale */
+		{0, 0, 0, 0} /* reserved[4] */
+	}, /* TgtOutCscCfg */
+	4096, /* brightnessPreservation */
+	1, /* num_total_viewing_modes */
+	1, /* viewing_mode_valid */
+	{
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	} /* padding[128] */
+};
+struct TargetDisplayConfig def_tgt_display_cfg_bestpq = {
+	36045, /* gamma */
+	2, /* eotf */
+	0, /* rangeSpec */
+	2920, /* maxPq */
+	88, /* minPq */
+	2771, /* maxPq_dm3 */
+	2621, /* min_lin */
+	183500800, /* max_lin */
+	183500800, /* max_lin_dm3 */
+	{
+	45305196,
+	20964810,
+	17971754,
+	43708004,
+	10415296,
+	3180960,
+	20984942,
+	22078816
+	},/*Target primaries */
+	2048, /* mSWeight */
+	0, /* trimSlopeBias */
+	0, /* trimOffsetBias */
+	0, /* trimPowerBias */
+	0, /* msWeightBias */
+	0, /* chromaWeightBias */
+	0, /* saturationGainBias */
+	0, /* tuningMode */
+	1229, /* brightness */
+	0, /* contrast */
+	0, /* brief  ColorShift */
+	0, /* brief  Saturation */
+	4095, /* brief  Backlight */
+	0, /* dbgExecParamsPrintPeriod */
+	0, /* dbgDmMdPrintPeriod */
+	0, /* dbgDmCfgPrintPeriod */
+	{
+		0, /* gdEnable */
+		13, /* gdWMin */
+		131072000, /* gdWMax */
+		1310720, /* gdWMm */
+		82897208, /* gdWDynRngSqrt */
+		4095, /* gdWeightMean */
+		2048, /* gdWeightStd */
+		100, /* gdDelayMilliSec_hdmi */
+		1, /* gdRgb2YuvExt */
+		{
+			{5961, 20053, 2024},
+			{-3287, -11053, 14340},
+			{14340, -13026, -1313}
+		}, /* gdM33Rgb2Yuv[3][3] */
+		15, /* gdM33Rgb2YuvScale2P */
+		1, /* gdRgb2YuvOffExt */
+		{2048, 16384, 16384},/* gdV3Rgb2YuvOff[3] */
+		414486, /* gdUpBound */
+		82897, /* gdLowBound */
+		0, /* lastMaxPq */
+		5, /*gdWMinPq */
+		2771, /*gdWMaxPq */
+		1015, /*gdWMmPq */
+		0, /*gdTriggerPeriod */
+		0, /* gdTriggerLinThresh */
+		50, /* gdDelayMilliSec_ott */
+		3276, /*gdRiseWeight */
+		3276, /* gdFallWeight */
+		200, /* gdDelayMilliSec_ll */
+		444596224, /* gdContrast */
+		{0, 0, 0}
+	},
+	{
+		0,
+		0,
+		0,
+		0,
+		0,
+		0,
+		0,
+		0,
+		{0, 0, 0}
+	},/*TgtABCfg*/
+	{
+		65536,
+		0,
+		4096,
+		5,
+		4096,
+		{10247, 10781},
+		32768,
+		3277,
+		0,
+		1365,
+		1365
+	},/*AmbientCfg*/
+	/*{0, 0, 0, 68, 124, 49, 230},*/
+	{4, 216, 163, 84, 218, 76, 153},/*vsvdb*/
+	0, /*dm31_avail*/
+	2, /*reference_mode_dark_id*/
+	0, /*applyL11*/
+	{0}, /*reserved*/
+	0, /* backlight_scaler */
+	{
+		/* lms2RgbMat[3][3] */
+		{
+			{22416, -19015, 695},
+			{-4609, 9392, -688},
+			{122, -791, 4765}
+		},
+		12, /* lms2RgbMatScale */
+		{0, 0, 0, 0} /* reserved[4] */
+	}, /* TgtOutCscCfg */
+	4096, /* brightnessPreservation */
+	1, /* num_total_viewing_modes */
+	1, /* viewing_mode_valid */
+	{
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	} /* padding[128] */
+};
+
+/*cfg_0.001_6300_POWER_2.4_YUV_NARROW_v2.txt	  --tid 2*/
+/*tv cert: DV LL case 5053 use this cfg */
+struct TargetDisplayConfig def_tgt_display_cfg_ll = {
+	39322, /* gamma */
+	2, /* eotf */
+	0, /* rangeSpec */
+	3895, /* maxPq */
+	26, /* minPq */
+	3246, /* maxPq_dm3 */
+	262, /* min_lin */
+	1651507200, /* max_lin */
+	381117088, /* max_lin_dm3 */
+	{
+	44922672,
+	22152636,
+	17844246,
+	44969648,
+	9489194,
+	3342022,
+	20984942,
+	22078816
+	},/*Target primaries */
+	2048, /* mSWeight */
+	0, /* trimSlopeBias */
+	0, /* trimOffsetBias */
+	0, /* trimPowerBias */
+	0, /* msWeightBias */
+	0, /* chromaWeightBias */
+	0, /* saturationGainBias */
+	0, /* tuningMode */
+	4095, /* brightness */
+	0, /* contrast */
+	0, /* ColorShift */
+	0, /* Saturation */
+	4095, /* Backlight */
+	0, /* dbgExecParamsPrintPeriod */
+	0, /* dbgDmMdPrintPeriod */
+	0, /* dbgDmCfgPrintPeriod */
+	{
+		1, /* gdEnable */
+		0, /* gdWMin */
+		1651507200, /* gdWMax */
+		1310720, /* gdWMm */
+		657976192, /* gdWDynRngSqrt */
+		4095, /* gdWeightMean */
+		2048, /* gdWeightStd */
+		0, /* gdDelayMilliSec_hdmi */
+		1, /* gdRgb2YuvExt */
+		{
+			{5967, 20067, 2026},
+			{-3289, -11061, 14350},
+			{14350, -13034, -1316}
+		}, /* gdM33Rgb2Yuv[3][3] */
+		15, /* gdM33Rgb2YuvScale2P */
+		1, /* gdRgb2YuvOffExt */
+		{2048, 16384, 16384},/* gdV3Rgb2YuvOff[3] */
+		657976, /* gdUpBound */
+		10444, /* gdLowBound */
+		0, /* lastMaxPq */
+		0, /*gdWMinPq */
+		3895, /*gdWMaxPq */
+		1015, /*gdWMmPq */
+		0, /*gdTriggerPeriod */
+		0, /* gdTriggerLinThresh */
+		0, /* gdDelayMilliSec_ott */
+		1400, /*gdRiseWeight */
+		2940, /* gdFallWeight */
+		0, /* gdDelayMilliSec_ll */
+		2239627264u, /* gdContrast */
+		{0, 0, 0}
+	},
+	{
+		0,
+		0,
+		0,
+		0,
+		0,
+		0,
+		0,
+		0,
+		{0, 0, 0}
+	},/*TgtABCfg*/
+	{
+		0,
+		0,
+		4096,
+		5,
+		4096,
+		{10247, 10781},
+		32768,
+		3277,
+		0,
+		1365,
+		1365
+	},/*AmbientCfg*/
+	{72, 15, 234, 136, 88, 92, 173},/*vsvdb*/
+	1, /*dm31_avail*/
+	2, /*reference_mode_dark_id*/
+	0, /*applyL11*/
+	{0}, /*reserved*/
+	0, /* backlight_scaler */
+	{
+		/* lms2RgbMat[3][3] */
+		{
+			{17486, -13950, 560},
+			{-4081, 8776, -599},
+			{257, -562, 4401}
+		},
+		12, /* lms2RgbMatScale */
+		{0, 0, 0, 0} /* reserved[4] */
+	}, /* TgtOutCscCfg */
+	4096, /* brightnessPreservation */
+	1, /* num_total_viewing_modes */
+	1, /* viewing_mode_valid */
+	{
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	} /* padding[128] */
+};
+
+/*cfg_0.034_890_BT1886_2.2_YUV_NARROW_v2.txt --tid 2*/
+/*tv cert: DV LL case 5052 use this cfg */
+struct TargetDisplayConfig def_tgt_display_cfg_ll_1 = {
+	36045, /* gamma */
+	0, /* eotf */
+	0, /* rangeSpec */
+	3027, /* maxPq */
+	159, /* minPq */
+	2383, /* maxPq_dm3 */
+	8913, /* min_lin */
+	233308160, /* max_lin */
+	53840348, /* max_lin_dm3 */
+	{
+	42781900,
+	22434494,
+	20179636,
+	41016936,
+	10153572,
+	3684277,
+	20984942,
+	22078816
+	},/*Target primaries */
+	2048, /* mSWeight */
+	0, /* trimSlopeBias */
+	0, /* trimOffsetBias */
+	0, /* trimPowerBias */
+	0, /* msWeightBias */
+	0, /* chromaWeightBias */
+	0, /* saturationGainBias */
+	0, /* tuningMode */
+	4095, /* brightness */
+	0, /* contrast */
+	0, /* ColorShift */
+	0, /* Saturation */
+	4095, /* Backlight */
+	0, /* dbgExecParamsPrintPeriod */
+	0, /* dbgDmMdPrintPeriod */
+	0, /* dbgDmCfgPrintPeriod */
+	{
+		1, /* gdEnable */
+		50, /* gdWMin */
+		233308160, /* gdWMax */
+		1310720, /* gdWMm */
+		42412656, /* gdWDynRngSqrt */
+		4095, /* gdWeightMean */
+		2048, /* gdWeightStd */
+		0, /* gdDelayMilliSec_hdmi */
+		1, /* gdRgb2YuvExt */
+		{
+			{5961, 20053, 2024},
+			{-3287, -11053, 14340},
+			{14340, -13026, -1313}
+		}, /* gdM33Rgb2Yuv[3][3] */
+		15, /* gdM33Rgb2YuvScale2P */
+		1, /* gdRgb2YuvOffExt */
+		{2048, 16384, 16384},/* gdV3Rgb2YuvOff[3] */
+		1442030, /* gdUpBound */
+		162025, /* gdLowBound */
+		0, /* lastMaxPq */
+		10, /*gdWMinPq */
+		3027, /*gdWMaxPq */
+		1015, /*gdWMmPq */
+		0, /*gdTriggerPeriod */
+		0, /* gdTriggerLinThresh */
+		0, /* gdDelayMilliSec_ott */
+		4095, /*gdRiseWeight */
+		4095, /* gdFallWeight */
+		0, /* gdDelayMilliSec_ll */
+		2567036928u, /* gdContrast */
+		{0, 0, 0}
+	},
+	{
+		0,
+		0,
+		0,
+		0,
+		0,
+		0,
+		0,
+		0,
+		{0, 0, 0}
+	},/*TgtABCfg*/
+	{
+		0,
+		0,
+		4096,
+		5,
+		4096,
+		{10247, 10781},
+		32768,
+		3277,
+		0,
+		1365,
+		1365
+	},/*AmbientCfg*/
+	{72, 63, 122, 154, 56, 31, 182},/*vsvdb*/
+	1, /*dm31_avail*/
+	2, /*reference_mode_dark_id*/
+	0, /*applyL11*/
+	{0}, /*reserved*/
+	0, /* backlight_scaler */
+	{
+		/* lms2RgbMat[3][3] */
+		{
+			{22406, -18942, 632},
+			{-4730, 9453, -627},
+			{81, -650, 4665}
+		},
+		12, /* lms2RgbMatScale */
+		{0, 0, 0, 0} /* reserved[4] */
+	}, /* TgtOutCscCfg */
+	4096, /* brightnessPreservation */
+	1, /* num_total_viewing_modes */
+	1, /* viewing_mode_valid */
+	{
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	} /* padding[128] */
+};
+
+/*cfg_0.01_700_POWER_2.4_YUV_NARROW_v1-12.txt --tid2*/
+/*tv cert: DV LL case 5051 and 5055 use this cfg */
+struct TargetDisplayConfig def_tgt_display_cfg_ll_2 = {
+	36045, /* gamma */
+	2, /* eotf */
+	0, /* rangeSpec */
+	2920, /* maxPq */
+	88, /* minPq */
+	2383, /* maxPq_dm3 */
+	2621, /* min_lin */
+	183500800, /* max_lin */
+	53840348, /* max_lin_dm3 */
+	{
+	45305196,
+	20964810,
+	17971754,
+	43708004,
+	10415296,
+	3180960,
+	20984942,
+	22078816
+	},/*Target primaries */
+	2048, /* mSWeight */
+	0, /* trimSlopeBias */
+	0, /* trimOffsetBias */
+	0, /* trimPowerBias */
+	0, /* msWeightBias */
+	0, /* chromaWeightBias */
+	0, /* saturationGainBias */
+	0, /* tuningMode */
+	0, /* brightness */
+	0, /* contrast */
+	0, /* ColorShift */
+	0, /* Saturation */
+	0, /* Backlight */
+	0, /* dbgExecParamsPrintPeriod */
+	0, /* dbgDmMdPrintPeriod */
+	0, /* dbgDmCfgPrintPeriod */
+	{
+		1, /* gdEnable */
+		187, /* gdWMin */
+		183500800, /* gdWMax */
+		13107200, /* gdWMm */
+		69356784, /* gdWDynRngSqrt */
+		4095, /* gdWeightMean */
+		2048, /* gdWeightStd */
+		100, /* gdDelayMilliSec_hdmi */
+		1, /* gdRgb2YuvExt */
+		{
+			{5961, 20053, 2024},
+			{-3287, -11053, 14340},
+			{14340, -13026, -1313}
+		}, /* gdM33Rgb2Yuv[3][3] */
+		15, /* gdM33Rgb2YuvScale2P */
+		1, /* gdRgb2YuvOffExt */
+		{2048, 16384, 16384},/* gdV3Rgb2YuvOff[3] */
+		693567, /* gdUpBound */
+		99081, /* gdLowBound */
+		0, /* lastMaxPq */
+		21, /*gdWMinPq */
+		2920, /*gdWMaxPq */
+		1803, /*gdWMmPq */
+		0, /*gdTriggerPeriod */
+		0, /* gdTriggerLinThresh */
+		50, /* gdDelayMilliSec_ott */
+		3276, /*gdRiseWeight */
+		3276, /* gdFallWeight */
+		200, /* gdDelayMilliSec_ll */
+		1170210816u, /* gdContrast */
+		{0, 0, 0}
+	},
+	{
+		0,
+		0,
+		0,
+		0,
+		0,
+		0,
+		0,
+		0,
+		{0, 0, 0}
+	},/*TgtABCfg*/
+	{
+		0,
+		0,
+		4096,
+		5,
+		4096,
+		{10247, 10781},
+		32768,
+		3277,
+		0,
+		1365,
+		1365
+	},/*AmbientCfg*/
+	{42, 25, 25, 241, 138, 78, 108},/*vsvdb*/
+	1, /*dm31_avail*/
+	2, /*reference_mode_dark_id*/
+	0, /*applyL11*/
+	{0}, /*reserved*/
+	0, /* backlight_scaler */
+	{
+		/* lms2RgbMat[3][3] */
+		{
+			{18835, -15103, 363},
+			{-3457, 8025, -472},
+			{155, -605, 4546}
+		},
+		12, /* lms2RgbMatScale */
+		{0, 0, 0, 0} /* reserved[4] */
+	}, /* TgtOutCscCfg */
+	4096, /* brightnessPreservation */
+	1, /* num_total_viewing_modes */
+	1, /* viewing_mode_valid */
+	{
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	} /* padding[128] */
+};
+
+#else
 #ifdef V1_5
 struct TargetDisplayConfig def_tgt_display_cfg = {
 	4095, /* gain */
@@ -636,6 +1335,7 @@ struct TargetDisplayConfig def_tgt_display_cfg = {
 	0, /* chip_nolvl5 */
 	{0, 0, 0, 0, 0, 0, 0, 0} /* padding[8] */
 };
+
 struct TargetDisplayConfig def_tgt_display_cfg_ll = {
 	4095, /* gain */
 	0, /* offset */
@@ -1033,6 +1733,21 @@ struct TargetDisplayConfig def_tgt_display_cfg = {
 	{0, 0, 0, 0, 0, 0, 0, 0} /* padding[8] */
 };
 #endif
+#endif
+
+#ifdef V1_6_1
+struct TargetDisplayConfig *DV_cfg_ll[3] = {
+	/*cfg_0.001_6300_POWER_2.4_YUV_NARROW_v2.txt -tid2*/
+	/*tv cert: DV LL case 5053 use this cfg */
+	&def_tgt_display_cfg_ll,
+	/*cfg_0.034_890_BT1886_2.2_YUV_NARROW_v2.txt     -tid2*/
+	/*tv cert: DV LL case 5052 use this cfg */
+	&def_tgt_display_cfg_ll_1,
+	/*cfg_0.01_700_POWER_2.4_YUV_NARROW_v1-12.txt     -tid2*/
+	/*tv cert: DV LL case 5051 and 5055 use this cfg */
+	&def_tgt_display_cfg_ll_2
+};
+#endif
 
 static unsigned int debug_dolby;
 module_param(debug_dolby, uint, 0664);
@@ -1073,6 +1788,11 @@ static char *comp_buf[2];
 static char *drop_md_buf[2];
 static char *drop_comp_buf[2];
 
+#ifdef V1_6_1
+#define VSEM_IF_BUF_SIZE 4096
+static char *vsem_if_buf;/* buffer for vsem or vsif */
+#endif
+
 static int currentId = 1;
 static int backup_comp_size;
 static int backup_md_size;
@@ -1082,6 +1802,10 @@ static struct dovi_setting_s new_dovi_setting;
 void *pq_config_fake;
 struct tv_dovi_setting_s *tv_dovi_setting;
 static bool pq_config_set_flag;
+
+#ifdef V1_6_1
+static bool best_pq_config_set_flag;
+#endif
 struct ui_menu_params_s menu_param = {50, 50, 50};
 static bool tv_dovi_setting_change_flag;
 static bool tv_dovi_setting_update_flag;
@@ -1678,16 +2402,108 @@ static uint32_t tv_run_mode(int vsize, bool hdmi, bool hdr10, int el_41_mode)
 				run_mode =
 					0x0000004c;
 			else
-				run_mode =
-					0x00000044;
+				run_mode =
+					0x00000044;
+		}
+	}
+	if (dolby_vision_flags & FLAG_BYPASS_CSC)
+		run_mode |= 1 << 12; /* bypass CSC */
+	if ((dolby_vision_flags & FLAG_BYPASS_CVM)
+		&& !(dolby_vision_flags & FLAG_FORCE_CVM))
+		run_mode |= 1 << 13; /* bypass CVM */
+	return run_mode;
+}
+static void adjust_vpotch(void)
+{
+	const struct vinfo_s *vinfo = get_current_vinfo();
+	int sync_duration_num = 60;
+
+	if (is_meson_txlx_stbmode()
+		|| force_stb_mode) {
+		if (vinfo && (vinfo->width >= 1920) &&
+			(vinfo->height >= 1080) &&
+			(vinfo->field_height >= 1080))
+			dma_start_line = 0x400;
+		else
+			dma_start_line = 0x180;
+		/* adjust core2 setting to work around*/
+		/* fixing with 1080p24hz and 480p60hz */
+		if (vinfo && (vinfo->width < 1280) &&
+			(vinfo->height < 720) &&
+			(vinfo->field_height < 720))
+			g_vpotch = 0x60;
+		else
+			g_vpotch = 0x20;
+	} else if (is_meson_g12()) {
+		if (vinfo) {
+			if (vinfo->sync_duration_den)
+				sync_duration_num = vinfo->sync_duration_num /
+						    vinfo->sync_duration_den;
+			if (debug_dolby & 2)
+				pr_dolby_dbg("vinfo %d %d %d %d %d %d\n",
+					     vinfo->width,
+					     vinfo->height,
+					     vinfo->field_height,
+					     vinfo->sync_duration_num,
+					     vinfo->sync_duration_den,
+					     sync_duration_num);
+			if ((vinfo->width < 1280) &&
+				(vinfo->height < 720) &&
+				(vinfo->field_height < 720))
+				g_vpotch = 0x60;
+			else if ((vinfo->width == 1280) &&
+				 (vinfo->height == 720))
+				g_vpotch = 0x38;
+			else if ((vinfo->width == 1280) &&
+				 (vinfo->height == 720) &&
+				 (vinfo->field_height < 720))
+				g_vpotch = 0x60;
+			else if ((vinfo->width == 1920) &&
+				 (vinfo->height == 1080) &&
+				 (sync_duration_num < 30))
+				g_vpotch = 0x60;
+			else if ((vinfo->width == 1920) &&
+				 (vinfo->height == 1080) &&
+				 (vinfo->field_height < 1080))
+				g_vpotch = 0x60;
+			else
+				g_vpotch = 0x20;
+			if (vinfo->width > 1920)
+				htotal_add = 0xc0;
+			else
+				htotal_add = 0x140;
+		} else
+			g_vpotch = 0x20;
+	} else if (is_meson_tm2_stbmode()) {
+		if (vinfo) {
+			if (debug_dolby & 2)
+				pr_dolby_dbg("vinfo %d %d %d\n",
+					vinfo->width,
+					vinfo->height,
+					vinfo->field_height);
+			if ((vinfo->width < 1280) &&
+				(vinfo->height < 720) &&
+				(vinfo->field_height < 720))
+				g_vpotch = 0x60;
+			else if ((vinfo->width <= 1920) &&
+				(vinfo->height <= 1080) &&
+				(vinfo->field_height <= 1080))
+				g_vpotch = 0x50;
+			else
+				g_vpotch = 0x20;
+		} else
+			g_vpotch = 0x20;
+	} else if (is_meson_tm2_tvmode()) {
+		if (vinfo) {
+			if (vinfo && (vinfo->width >= 1920) &&
+			(vinfo->height >= 1080) &&
+			(vinfo->field_height >= 1080))
+				dma_start_line = 0x400;
+			else
+				dma_start_line = 0x180;
 		}
 	}
-	if (dolby_vision_flags & FLAG_BYPASS_CSC)
-		run_mode |= 1 << 12; /* bypass CSC */
-	if ((dolby_vision_flags & FLAG_BYPASS_CVM)
-		&& !(dolby_vision_flags & FLAG_FORCE_CVM))
-		run_mode |= 1 << 13; /* bypass CVM */
-	return run_mode;
+
 }
 
 static int tv_dolby_core1_set(
@@ -1711,6 +2527,8 @@ static int tv_dolby_core1_set(
 		FLAG_DISABE_CORE_SETTING))
 		return 0;
 
+	adjust_vpotch();
+
 	WRITE_VPP_DV_REG(
 		DOLBY_TV_CLKGATE_CTRL, 0x2800);
 
@@ -1736,9 +2554,10 @@ static int tv_dolby_core1_set(
 	VSYNC_WR_DV_REG_BITS(DOLBY_TV_SWAP_CTRL5, 0x2c2d0, 14, 18);
 	VSYNC_WR_DV_REG_BITS(DOLBY_TV_SWAP_CTRL5, 0xa, 0, 4);
 
-	if ((hdmi) && (!hdr10))
+	if ((hdmi) && (!hdr10)) {
+		/*hdmi DV STD and DV LL:  need detunnel*/
 		VSYNC_WR_DV_REG_BITS(DOLBY_TV_SWAP_CTRL5, 1, 4, 1);
-	else
+	} else
 		VSYNC_WR_DV_REG_BITS(DOLBY_TV_SWAP_CTRL5, 0, 4, 1);
 
 	/*set diag reg to 0xb can bypass dither, not need set swap ctrl6 */
@@ -2749,90 +3568,6 @@ int get_mute_type(void)
 		return MUTE_TYPE_NONE;
 }
 
-static void adjust_vpotch(void)
-{
-	const struct vinfo_s *vinfo = get_current_vinfo();
-	int sync_duration_num = 60;
-
-	if (is_meson_txlx_stbmode()
-		|| force_stb_mode) {
-		if (vinfo && (vinfo->width >= 1920) &&
-			(vinfo->height >= 1080) &&
-			(vinfo->field_height >= 1080))
-			dma_start_line = 0x400;
-		else
-			dma_start_line = 0x180;
-		/* adjust core2 setting to work around*/
-		/* fixing with 1080p24hz and 480p60hz */
-		if (vinfo && (vinfo->width < 1280) &&
-			(vinfo->height < 720) &&
-			(vinfo->field_height < 720))
-			g_vpotch = 0x60;
-		else
-			g_vpotch = 0x20;
-	} else if (is_meson_g12()) {
-		if (vinfo) {
-			if (vinfo->sync_duration_den)
-				sync_duration_num = vinfo->sync_duration_num /
-						    vinfo->sync_duration_den;
-			if (debug_dolby & 2)
-				pr_dolby_dbg("vinfo %d %d %d %d %d %d\n",
-					     vinfo->width,
-					     vinfo->height,
-					     vinfo->field_height,
-					     vinfo->sync_duration_num,
-					     vinfo->sync_duration_den,
-					     sync_duration_num);
-			if ((vinfo->width < 1280) &&
-				(vinfo->height < 720) &&
-				(vinfo->field_height < 720))
-				g_vpotch = 0x60;
-			else if ((vinfo->width == 1280) &&
-				 (vinfo->height == 720))
-				g_vpotch = 0x38;
-			else if ((vinfo->width == 1280) &&
-				 (vinfo->height == 720) &&
-				 (vinfo->field_height < 720))
-				g_vpotch = 0x60;
-			else if ((vinfo->width == 1920) &&
-				 (vinfo->height == 1080) &&
-				 (sync_duration_num < 30))
-				g_vpotch = 0x60;
-			else if ((vinfo->width == 1920) &&
-				 (vinfo->height == 1080) &&
-				 (vinfo->field_height < 1080))
-				g_vpotch = 0x60;
-			else
-				g_vpotch = 0x20;
-			if (vinfo->width > 1920)
-				htotal_add = 0xc0;
-			else
-				htotal_add = 0x140;
-		} else
-			g_vpotch = 0x20;
-	} else if (is_meson_tm2_stbmode()) {
-		if (vinfo) {
-			if (debug_dolby & 2)
-				pr_dolby_dbg("vinfo %d %d %d\n",
-					vinfo->width,
-					vinfo->height,
-					vinfo->field_height);
-			if ((vinfo->width < 1280) &&
-				(vinfo->height < 720) &&
-				(vinfo->field_height < 720))
-				g_vpotch = 0x60;
-			else if ((vinfo->width <= 1920) &&
-				(vinfo->height <= 1080) &&
-				(vinfo->field_height <= 1080))
-				g_vpotch = 0x50;
-			else
-				g_vpotch = 0x20;
-		} else
-			g_vpotch = 0x20;
-	}
-
-}
-
 static void apply_stb_core_settings(
 	int enable, unsigned int mask,
 	bool reset, u32 frame_size, u8 pps_state)
@@ -3002,6 +3737,8 @@ static uint32_t viu_eotf_ctrl_backup;
 static uint32_t xvycc_lut_ctrl_backup;
 static uint32_t inv_lut_ctrl_backup;
 static uint32_t vpp_vadj_backup;
+static uint32_t vpp_vadj1_backup;
+static uint32_t vpp_vadj2_backup;
 static uint32_t vpp_gainoff_backup;
 static uint32_t vpp_ve_enable_ctrl_backup;
 static uint32_t xvycc_vd1_rgb_ctrst_backup;
@@ -3011,44 +3748,70 @@ static void video_effect_bypass(int bypass)
 {
 	if (bypass) {
 		if (!is_video_effect_bypass) {
-			viu_eotf_ctrl_backup =
-				VSYNC_RD_DV_REG(VIU_EOTF_CTL);
-			xvycc_lut_ctrl_backup =
-				VSYNC_RD_DV_REG(XVYCC_LUT_CTL);
-			inv_lut_ctrl_backup =
-				VSYNC_RD_DV_REG(XVYCC_INV_LUT_CTL);
-			vpp_vadj_backup =
-				VSYNC_RD_DV_REG(VPP_VADJ_CTRL);
+			if (is_meson_txlx()) {
+				viu_eotf_ctrl_backup =
+					VSYNC_RD_DV_REG(VIU_EOTF_CTL);
+				xvycc_lut_ctrl_backup =
+					VSYNC_RD_DV_REG(XVYCC_LUT_CTL);
+				inv_lut_ctrl_backup =
+					VSYNC_RD_DV_REG(XVYCC_INV_LUT_CTL);
+				vpp_vadj_backup =
+					VSYNC_RD_DV_REG(VPP_VADJ_CTRL);
+				xvycc_vd1_rgb_ctrst_backup =
+					VSYNC_RD_DV_REG(XVYCC_VD1_RGB_CTRST);
+			} else {
+				vpp_vadj1_backup =
+					VSYNC_RD_DV_REG(VPP_VADJ1_MISC);
+				vpp_vadj2_backup =
+					VSYNC_RD_DV_REG(VPP_VADJ2_MISC);
+				xvycc_vd1_rgb_ctrst_backup =
+					VSYNC_RD_DV_REG(VPP_VD1_RGB_CTRST);
+			}
 			vpp_gainoff_backup =
 				VSYNC_RD_DV_REG(VPP_GAINOFF_CTRL0);
 			vpp_ve_enable_ctrl_backup =
 				VSYNC_RD_DV_REG(VPP_VE_ENABLE_CTRL);
-			xvycc_vd1_rgb_ctrst_backup =
-				VSYNC_RD_DV_REG(XVYCC_VD1_RGB_CTRST);
 			is_video_effect_bypass = true;
 		}
-		VSYNC_WR_DV_REG(VIU_EOTF_CTL, 0);
-		VSYNC_WR_DV_REG(XVYCC_LUT_CTL, 0);
-		VSYNC_WR_DV_REG(XVYCC_INV_LUT_CTL, 0);
-		VSYNC_WR_DV_REG(VPP_VADJ_CTRL, 0);
+		if (is_meson_txlx()) {
+			VSYNC_WR_DV_REG(VIU_EOTF_CTL, 0);
+			VSYNC_WR_DV_REG(XVYCC_LUT_CTL, 0);
+			VSYNC_WR_DV_REG(XVYCC_INV_LUT_CTL, 0);
+			VSYNC_WR_DV_REG(VPP_VADJ_CTRL, 0);
+			VSYNC_WR_DV_REG(XVYCC_VD1_RGB_CTRST, 0);
+		} else {
+			VSYNC_WR_DV_REG(VPP_VADJ1_MISC, 0);
+			VSYNC_WR_DV_REG(VPP_VADJ2_MISC, 0);
+			VSYNC_WR_DV_REG(VPP_VD1_RGB_CTRST, 0);
+		}
+
 		VSYNC_WR_DV_REG(VPP_GAINOFF_CTRL0, 0);
 		VSYNC_WR_DV_REG(VPP_VE_ENABLE_CTRL, 0);
-		VSYNC_WR_DV_REG(XVYCC_VD1_RGB_CTRST, 0);
+
 	} else if (is_video_effect_bypass) {
-		VSYNC_WR_DV_REG(VIU_EOTF_CTL,
-			viu_eotf_ctrl_backup);
-		VSYNC_WR_DV_REG(XVYCC_LUT_CTL,
-			xvycc_lut_ctrl_backup);
-		VSYNC_WR_DV_REG(XVYCC_INV_LUT_CTL,
-			inv_lut_ctrl_backup);
-		VSYNC_WR_DV_REG(VPP_VADJ_CTRL,
-			vpp_vadj_backup);
+		if (is_meson_txlx()) {
+			VSYNC_WR_DV_REG(VIU_EOTF_CTL,
+				viu_eotf_ctrl_backup);
+			VSYNC_WR_DV_REG(XVYCC_LUT_CTL,
+				xvycc_lut_ctrl_backup);
+			VSYNC_WR_DV_REG(XVYCC_INV_LUT_CTL,
+				inv_lut_ctrl_backup);
+			VSYNC_WR_DV_REG(VPP_VADJ_CTRL,
+				vpp_vadj_backup);
+			VSYNC_WR_DV_REG(XVYCC_VD1_RGB_CTRST,
+				xvycc_vd1_rgb_ctrst_backup);
+		} else {
+			VSYNC_WR_DV_REG(VPP_VADJ1_MISC,
+				vpp_vadj1_backup);
+			VSYNC_WR_DV_REG(VPP_VADJ2_MISC,
+				vpp_vadj2_backup);
+			VSYNC_WR_DV_REG(VPP_VD1_RGB_CTRST,
+				xvycc_vd1_rgb_ctrst_backup);
+		}
 		VSYNC_WR_DV_REG(VPP_GAINOFF_CTRL0,
 			vpp_gainoff_backup);
 		VSYNC_WR_DV_REG(VPP_VE_ENABLE_CTRL,
 			vpp_ve_enable_ctrl_backup);
-		VSYNC_WR_DV_REG(XVYCC_VD1_RGB_CTRST,
-			xvycc_vd1_rgb_ctrst_backup);
 	}
 }
 
@@ -3203,6 +3966,8 @@ static uint32_t vpp_matrix_backup;
 static uint32_t vpp_dummy1_backup;
 static uint32_t vpp_data_conv_para0_backup;
 static uint32_t vpp_data_conv_para1_backup;
+static uint32_t vpp_data_422T0444_backup;
+
 void enable_dolby_vision(int enable)
 {
 	uint32_t size = 0;
@@ -3285,16 +4050,18 @@ void enable_dolby_vision(int enable)
 						VPP_DOLBY_CTRL, 3, 0, 2);
 					/* bypass all video effect */
 					video_effect_bypass(1);
-					/* 12 bit unsigned to sign*/
-					/*   before vadj1 */
-					/* 12 bit sign to unsign*/
-					/*   before post blend */
-					VSYNC_WR_DV_REG(
+					if (is_meson_txlx_tvmode()) {
+						/* 12 bit unsigned to sign*/
+						/*   before vadj1 */
+						/* 12 bit sign to unsign*/
+						/*   before post blend */
+						VSYNC_WR_DV_REG(
 						VPP_DAT_CONV_PARA0, 0x08000800);
-					/* 12->10 before vadj2*/
-					/*   10->12 after gainoff */
-					VSYNC_WR_DV_REG(
+						/* 12->10 before vadj2*/
+						/*   10->12 after gainoff */
+						VSYNC_WR_DV_REG(
 						VPP_DAT_CONV_PARA1, 0x20002000);
+					}
 					WRITE_VPP_DV_REG(DOLBY_TV_DIAG_CTRL,
 							 0xb);
 				} else {
@@ -3302,14 +4069,16 @@ void enable_dolby_vision(int enable)
 					if (dolby_vision_flags
 					& FLAG_BYPASS_VPP)
 						video_effect_bypass(1);
-					/* 12->10 before vadj1*/
-					/*   10->12 before post blend */
-					VSYNC_WR_DV_REG(
+					if (is_meson_txlx_tvmode()) {
+						/* 12->10 before vadj1*/
+						/*   10->12 before post blend */
+						VSYNC_WR_DV_REG(
 						VPP_DAT_CONV_PARA0, 0x20002000);
-					/* 12->10 before vadj2*/
-					/*   10->12 after gainoff */
-					VSYNC_WR_DV_REG(
+						/* 12->10 before vadj2*/
+						/*   10->12 after gainoff */
+						VSYNC_WR_DV_REG(
 						VPP_DAT_CONV_PARA1, 0x20002000);
+					}
 				}
 				VSYNC_WR_DV_REG(
 					VPP_DUMMY_DATA1,
@@ -3724,6 +4493,20 @@ void enable_dolby_vision(int enable)
 					VSYNC_WR_DV_REG_BITS(
 						DOLBY_PATH_CTRL, 3, 0, 2);
 #ifdef V1_5
+#ifdef V1_6_1
+				if (p_funcs_tv) /* destroy ctx */
+					p_funcs_tv->tv_control_path(
+						FORMAT_INVALID, 0,
+						NULL, 0,
+						NULL, 0,
+						0,	0,
+						SIG_RANGE_SMPTE,
+						NULL, NULL,
+						0,
+						NULL,
+						NULL,
+						NULL, 0);
+#else
 				if (p_funcs_tv) /* destroy ctx */
 					p_funcs_tv->tv_control_path(
 						FORMAT_INVALID, 0,
@@ -3735,6 +4518,7 @@ void enable_dolby_vision(int enable)
 						0,
 						NULL,
 						NULL);
+#endif
 #endif
 				pr_dolby_dbg("Dolby Vision TV core turn off\n");
 			} else if (is_meson_txlx_stbmode()
@@ -4048,6 +4832,11 @@ void dolby_vision_init_receiver(void *pdev)
 		if (drop_comp_buf[i] != NULL)
 			memset(drop_comp_buf[i], 0, COMP_BUF_SIZE);
 	}
+#ifdef V1_6_1
+	vsem_if_buf = vmalloc(VSEM_IF_BUF_SIZE);
+		if (vsem_if_buf != NULL)
+			memset(vsem_if_buf, 0, VSEM_IF_BUF_SIZE);
+#endif
 }
 
 #define MAX_FILENAME_LENGTH 64
@@ -4339,6 +5128,7 @@ static int is_policy_changed(void)
 			pr_dolby_dbg("ll policy changed %d->%d\n",
 				     last_dolby_vision_ll_policy,
 				     dolby_vision_ll_policy);
+			last_dolby_vision_ll_policy = dolby_vision_ll_policy;
 			ret |= 2;
 		}
 	}
@@ -5071,7 +5861,6 @@ static int parse_sei_and_meta(
 		type = (type << 8) | *p++;
 		type = (type << 8) | *p++;
 		type = (type << 8) | *p++;
-
 		if (type == 0x01000000) {
 			/* source is VS10 */
 			*total_comp_size = 0;
@@ -5094,7 +5883,6 @@ static int parse_sei_and_meta(
 						meta_buf[i+6],
 						meta_buf[i+7]);
 			}
-
 			if (tv_mode) {
 				if (!p_funcs_tv)
 					return -1;
@@ -5917,6 +6705,9 @@ static void calculate_panel_max_pq(
 {
 	uint32_t max_lin = tv_max_lin;
 	uint16_t max_pq = tv_max_pq;
+#ifdef V1_6_1
+	return;
+#endif
 
 	if (dolby_vision_flags & FLAG_CERTIFICAION)
 		return;
@@ -5943,12 +6734,16 @@ static void calculate_panel_max_pq(
 				     tv_max_lin, tv_max_pq, max_lin, max_pq);
 		tv_max_lin = max_lin;
 		tv_max_pq = max_pq;
-		config->max_lin =
+		config->max_lin = tv_max_lin << 18;
+#ifndef V1_6_1
 		config->max_lin_dupli =
 			tv_max_lin << 18;
-		config->maxPq =
+#endif
+		config->maxPq = tv_max_pq;
+#ifndef V1_6_1
 		config->maxPq_dupli =
 			tv_max_pq;
+#endif
 	}
 }
 
@@ -6004,7 +6799,10 @@ int dolby_vision_parse_metadata(
 	static int last_current_format;
 	int ret = -1;
 	bool mel_flag = false;
-
+#ifdef V1_6_1
+	int vsem_if_size = 0;
+	char *vsem_if = NULL;/* buffer for vsem or vsif */
+#endif
 	memset(&req, 0, (sizeof(struct provider_aux_req_s)));
 	memset(&el_req, 0, (sizeof(struct provider_aux_req_s)));
 
@@ -6062,7 +6860,22 @@ int dolby_vision_parse_metadata(
 				p_mdc->luminance[0] *= 10000;
 				prepare_hdr10_param(
 					p_mdc, &hdr10_param);
+				req.dv_enhance_exist = 0;
+				src_bdp = 12;
+			}
+#ifdef V1_6_1
+			if (dolby_vision_flags & FLAG_CERTIFICAION) {
+				if ((src_format != FORMAT_DOVI)
+					&& is_hlg_frame(vf)) {
+					src_format = FORMAT_HLG;
+					src_bdp = 12;
+				}
+				if ((src_format == FORMAT_SDR)
+					&& is_meson_tm2_tvmode()
+					&& !req.dv_enhance_exist)
+					src_bdp = 12;
 			}
+#endif
 		}
 		if (debug_dolby & 4) {
 			pr_dolby_dbg("metadata(%d):\n", req.aux_size);
@@ -6094,7 +6907,8 @@ int dolby_vision_parse_metadata(
 			frame_count, vf->pts_us64,
 			(src_format == FORMAT_HDR10) ? "HDR10" :
 			((src_format == FORMAT_DOVI) ? "DOVI" :
-			((src_format == FORMAT_DOVI_LL) ? "DOVI_LL" : "SDR")));
+			((src_format == FORMAT_DOVI_LL) ? "DOVI_LL" :
+			((src_format == FORMAT_HLG) ? "HLG" : "SDR"))));
 
 		if (toggle_mode == 1) {
 			if (debug_dolby & 2)
@@ -6103,6 +6917,24 @@ int dolby_vision_parse_metadata(
 					vf, vf->pts_us64);
 			dolby_vision_vf_add(vf, NULL);
 		}
+#ifdef V1_6_1
+		if (vf->vsif.size > 0) {
+			/*i= 1;*/
+			vsem_if_size = vf->vsif.size;
+			memset(vsem_if_buf, 0, VSEM_IF_BUF_SIZE);
+			memcpy(vsem_if_buf, vf->vsif.addr, vsem_if_size);
+			if (debug_dolby & 8) {
+				vsem_if = vf->vsif.addr;
+				for (i = 0; i < vsem_if_size + 4; i += 4) {
+					pr_info("\t%02x %02x %02x %02x\n",
+						vsem_if[i],
+						vsem_if[i+1],
+						vsem_if[i+2],
+						vsem_if[i+3]);
+				}
+			}
+		}
+#endif
 	} else if (vf && (vf->source_type == VFRAME_SOURCE_TYPE_OTHERS)) {
 		/* check source format */
 		input_mode = INPUT_MODE_OTT;
@@ -6126,6 +6958,8 @@ int dolby_vision_parse_metadata(
 				&total_md_size,
 				&src_format,
 				&ret_flags, drop_flag);
+			if (force_mel)
+				ret_flags = 1;
 			if (ret_flags && req.dv_enhance_exist
 				&& (frame_count == 0)) {
 				vf_notify_provider_by_name(
@@ -6134,6 +6968,11 @@ int dolby_vision_parse_metadata(
 					(void *)&req);
 				pr_dolby_dbg("bypass mel\n");
 			}
+			//201912 add for tm2 tvcore idk 5009, check box need?
+			if (req.dv_enhance_exist && ret_flags) {
+				if (is_meson_tm2_tvmode())
+					req.dv_enhance_exist = 0;
+			}
 			if (ret_flags == 1)
 				mel_flag = true;
 			if (!is_dv_standard_es(req.dv_enhance_exist,
@@ -6156,6 +6995,17 @@ int dolby_vision_parse_metadata(
 				src_bdp = 10;
 				bypass_release = true;
 			}
+			if (is_meson_tm2_tvmode() &&
+				(req.dv_enhance_exist && !mel_flag)) {
+				src_format = FORMAT_SDR;
+				/* dovi_setting.src_format = src_format; */
+				total_comp_size = 0;
+				total_md_size = 0;
+				src_bdp = 10;
+				bypass_release = true;
+				if (debug_dolby & 1)
+					pr_dolby_dbg("tm2 tv: bypass fel\n");
+			}
 		} else if (is_dolby_vision_stb_mode())
 			src_format = dovi_setting.src_format;
 		else if (is_meson_tvmode())
@@ -6175,6 +7025,10 @@ int dolby_vision_parse_metadata(
 		if ((src_format != FORMAT_DOVI)
 			&& is_hlg_frame(vf)) {
 			src_format = FORMAT_HLG;
+#ifdef V1_6_1
+			if (is_meson_tm2_tvmode())
+				src_bdp = 10;
+#endif
 		}
 
 		if ((src_format != FORMAT_DOVI)
@@ -6194,6 +7048,13 @@ int dolby_vision_parse_metadata(
 			&& !req.dv_enhance_exist)
 			src_bdp = 10;
 #endif
+#ifdef V1_6_1
+		if ((src_format == FORMAT_SDR)
+			&& is_meson_tm2_tvmode()
+			&& !req.dv_enhance_exist)
+			src_bdp = 10;
+#endif
+
 		if (((debug_dolby & 1)
 			|| (frame_count == 0))
 			&& (toggle_mode == 1))
@@ -6357,7 +7218,6 @@ int dolby_vision_parse_metadata(
 		dolby_vision_request_mode = 0xff;
 	}
 	current_mode = dolby_vision_mode;
-
 	if (dolby_vision_policy_process(
 		&current_mode, check_format)) {
 		if (!dolby_vision_wait_init)
@@ -6416,15 +7276,26 @@ int dolby_vision_parse_metadata(
 
 	/* TV core */
 	if (is_meson_tvmode() && !force_stb_mode) {
-		if (src_format != tv_dovi_setting->src_format)
+		if (src_format != tv_dovi_setting->src_format ||
+			(dolby_vision_flags & FLAG_CERTIFICAION)) {
 			pq_config_set_flag = false;
+#ifdef V1_6_1
+			best_pq_config_set_flag = false;
+#endif
+		}
 		if (!pq_config_set_flag) {
+			if (debug_dolby & 1)
+				pr_dolby_dbg("update def_tgt_display_cfg\n");
 			if ((dolby_vision_flags & FLAG_FORCE_DOVI_LL)
 				|| (req.low_latency == 1))
 				memcpy(&(((struct pq_config_s *)
 				pq_config_fake)->target_display_config),
-					&def_tgt_display_cfg_ll,
-					sizeof(def_tgt_display_cfg_ll));
+#ifdef V1_6_1
+				DV_cfg_ll[cfg_ll_id],
+#else
+				&def_tgt_display_cfg_ll,
+#endif
+				sizeof(def_tgt_display_cfg_ll));
 			else
 				memcpy(&(((struct pq_config_s *)
 				pq_config_fake)->target_display_config),
@@ -6432,12 +7303,34 @@ int dolby_vision_parse_metadata(
 				sizeof(def_tgt_display_cfg));
 			pq_config_set_flag = true;
 		}
+#ifdef V1_6_1
+		if (force_best_pq && !best_pq_config_set_flag) {
+			pr_dolby_dbg("update best def_tgt_display_cfg\n");
+			memcpy(&(((struct pq_config_s *)
+				pq_config_fake)->target_display_config),
+				&def_tgt_display_cfg_bestpq,
+				sizeof(def_tgt_display_cfg_bestpq));
+			best_pq_config_set_flag = true;
+
+			if (p_funcs_tv && (p_funcs_tv->tv_control_path))
+				p_funcs_tv->tv_control_path(
+					FORMAT_INVALID, 0,
+					NULL, 0,
+					NULL, 0,
+					0, 0,
+					SIG_RANGE_SMPTE,
+					NULL, NULL,
+					0,
+					NULL,
+					NULL,
+					NULL, 0);
+		}
+#endif
 		calculate_panel_max_pq(
 			vinfo,
 			&(((struct pq_config_s *)
 			pq_config_fake)->target_display_config));
-		tv_dovi_setting->video_width = w << 16;
-		tv_dovi_setting->video_height = h << 16;
+
 		((struct pq_config_s *)
 			pq_config_fake)->target_display_config.tuningMode =
 			dolby_vision_tunning_mode;
@@ -6451,6 +7344,7 @@ int dolby_vision_parse_metadata(
 				->target_display_config.tuningMode &=
 				(~TUNINGMODE_EL_FORCEDDISABLE);
 #ifdef V1_5
+#ifndef V1_6_1
 		/* disable global dimming */
 		if (dolby_vision_flags & FLAG_CERTIFICAION)
 			((struct pq_config_s *)pq_config_fake)
@@ -6460,8 +7354,40 @@ int dolby_vision_parse_metadata(
 			((struct pq_config_s *)pq_config_fake)
 				->target_display_config.tuningMode |=
 				TUNINGMODE_EXTLEVEL4_DISABLE;
-
-		if (src_format != tv_dovi_setting->src_format) {
+#endif
+#ifdef V1_6_1
+		if ((dolby_vision_flags & FLAG_CERTIFICAION) && sdr_ref_mode) {
+			((struct pq_config_s *)pq_config_fake)
+				->target_display_config.ambientConfig.ambient
+				= 0;
+			((struct pq_config_s *)pq_config_fake)
+				->target_display_config.reference_mode_dark_id
+				= 0;
+			((struct pq_config_s *)pq_config_fake)
+				->target_display_config.dm31_avail = 1;
+		}
+#endif
+		if ((src_format != tv_dovi_setting->src_format) ||
+			(tv_dovi_setting->video_width != w) ||
+			(tv_dovi_setting->video_height != h)) {
+			pr_dolby_dbg("reset control_path fmt %d->%d, w %d->%d, h %d->%d\n",
+				tv_dovi_setting->src_format, src_format,
+				tv_dovi_setting->video_width, w,
+				tv_dovi_setting->video_height, h);
+#ifdef V1_6_1
+			if (p_funcs_tv && (p_funcs_tv->tv_control_path))
+				p_funcs_tv->tv_control_path(
+					FORMAT_INVALID, 0,
+					NULL, 0,
+					NULL, 0,
+					0, 0,
+					SIG_RANGE_SMPTE,
+					NULL, NULL,
+					0,
+					NULL,
+					NULL,
+					NULL, 0);
+#else
 			if (p_funcs_tv && (p_funcs_tv->tv_control_path))
 				p_funcs_tv->tv_control_path(
 					FORMAT_INVALID, 0,
@@ -6473,10 +7399,28 @@ int dolby_vision_parse_metadata(
 					0,
 					NULL,
 					NULL);
+#endif
 		}
 #endif
+		tv_dovi_setting->video_width = w << 16;
+		tv_dovi_setting->video_height = h << 16;
 		if ((!p_funcs_tv) || (!p_funcs_tv->tv_control_path))
 			return -1;
+#ifdef V1_6_1
+		flag = p_funcs_tv->tv_control_path(
+			src_format, input_mode,
+			comp_buf[currentId], total_comp_size,
+			md_buf[currentId], total_md_size,
+			src_bdp,
+			src_chroma_format,
+			SIG_RANGE_SMPTE, /* bit/chroma/range */
+			(struct pq_config_s *)pq_config_fake, &menu_param,
+			(!el_flag) ||
+			(dolby_vision_flags & FLAG_DISABLE_COMPOSER),
+			&hdr10_param,
+			tv_dovi_setting,
+			vsem_if_buf, vsem_if_size);
+#else
 		flag = p_funcs_tv->tv_control_path(
 			src_format, input_mode,
 			comp_buf[currentId], total_comp_size,
@@ -6489,6 +7433,7 @@ int dolby_vision_parse_metadata(
 			(dolby_vision_flags & FLAG_DISABLE_COMPOSER),
 			&hdr10_param,
 			tv_dovi_setting);
+#endif
 		if (flag >= 0) {
 			if (input_mode == INPUT_MODE_HDMI) {
 				if (h > 1080)
@@ -6942,9 +7887,12 @@ int dolby_vision_wait_metadata(struct vframe_s *vf)
 			&& !force_stb_mode)
 			ott_mode = tv_dovi_setting->input_mode !=
 				INPUT_MODE_HDMI;
-		if ((setting_update_count > crc_count)
-			&& (ott_mode == true))
-			return 1;
+		if (setting_update_count > crc_count) {
+			if (ott_mode == true)
+				return 1;
+			else if (is_meson_tm2_tvmode()) /*tm2 tv hdmi mode*/
+				return 1;
+		}
 	}
 
 	if (vf) {
@@ -7119,7 +8067,6 @@ static void bypass_pps_path(u8 pps_state)
 		last_pps_state = pps_state;
 	}
 }
-
 /* toggle mode: 0: not toggle; 1: toggle frame; 2: use keep frame */
 /* pps_state 0: no change, 1: pps enable, 2: pps disable */
 int dolby_vision_process(
@@ -7141,6 +8088,7 @@ int dolby_vision_process(
 	int policy_changed = 0;
 	int sink_changed = 0;
 	int format_changed = 0;
+	bool src_is_42210bit = false;
 
 	if (!is_meson_box() && !is_meson_txlx() && !is_meson_tm2())
 		return -1;
@@ -7160,6 +8108,28 @@ int dolby_vision_process(
 		}
 		dolby_vision_on_count = 1 +
 			dolby_vision_run_mode_delay;
+
+		if (is_meson_tm2_tvmode()) {
+			/*for vdin1 loop back, 444,12bit->422,12bit->444,8bit*/
+			if (enable_tunnel_before_vdin1) {
+				if (vpp_data_422T0444_backup == 0) {
+					vpp_data_422T0444_backup =
+					VSYNC_RD_DV_REG(VPU_422T0444_CTRL1);
+					pr_dolby_dbg("vpp_data_422T0444_backup %x\n",
+						     vpp_data_422T0444_backup);
+				}
+				VSYNC_WR_DV_REG(VPU_422T0444_CTRL1, 0x04c0ba14);
+				/* reset RST bit1 to reset tunnel module */
+				VSYNC_WR_DV_REG(VPU_422T0444_RST, 0x2);
+				VSYNC_WR_DV_REG(VPU_422T0444_RST, 0);
+			} else {
+				if (vpp_data_422T0444_backup) {
+					VSYNC_WR_DV_REG(VPU_422T0444_CTRL1,
+					vpp_data_422T0444_backup);
+				}
+			}
+
+		}
 	}
 
 	if (dolby_vision_flags & FLAG_TOGGLE_FRAME)	{
@@ -7232,6 +8202,7 @@ int dolby_vision_process(
 			ott_mode =
 				(tv_dovi_setting->input_mode !=
 				INPUT_MODE_HDMI);
+
 		if ((is_meson_txlx_stbmode() ||
 			is_meson_tm2_stbmode() ||
 			is_meson_box() || force_stb_mode)
@@ -7242,11 +8213,19 @@ int dolby_vision_process(
 			crc_read_delay++;
 		} else {
 			crc_read_delay++;
-			if ((crc_read_delay > delay_count)
-				&& (ott_mode == true)) {
-				tv_dolby_vision_insert_crc(
+			if (crc_read_delay > delay_count) {
+				if (ott_mode == true) {
+					tv_dolby_vision_insert_crc(
 					(crc_count == 0) ? true : false);
-				crc_read_delay = 0;
+					crc_read_delay = 0;
+				} else if (is_meson_tm2_tvmode()) {
+					/*tm2 hdmi mode*/
+					u32 crc =
+					READ_VPP_DV_REG(DOLBY_TV_OUTPUT_DM_CRC);
+					pr_dolby_dbg("crc = 0x%08x\n", crc);
+					crc_count++;
+					crc_read_delay = 0;
+				}
 			}
 		}
 	}
@@ -7424,6 +8403,23 @@ int dolby_vision_process(
 					!(dolby_vision_flags
 					& FLAG_CERTIFICAION))
 					reset_flag = true;
+
+				if ((dolby_vision_flags & FLAG_CERTIFICAION)) {
+					if (tv_dovi_setting->src_format ==
+						FORMAT_HDR10 ||
+						tv_dovi_setting->src_format ==
+						FORMAT_HLG ||
+						tv_dovi_setting->src_format ==
+						FORMAT_SDR)
+					src_is_42210bit = true;
+				} else {
+					if ((tv_dovi_setting->src_format ==
+					FORMAT_HDR10) ||
+					(tv_dovi_setting->src_format ==
+					FORMAT_HLG))
+					src_is_42210bit = true;
+				}
+
 				tv_dolby_core1_set(
 					 tv_dovi_setting->core1_reg_lut,
 					h_size,
@@ -7431,12 +8427,11 @@ int dolby_vision_process(
 					dovi_setting_video_flag, /* BL enable */
 					dovi_setting_video_flag
 					&& (tv_dovi_setting->el_flag),
-					 tv_dovi_setting->el_halfsize_flag,
+					tv_dovi_setting->el_halfsize_flag,
 					src_chroma_format,
 					tv_dovi_setting->input_mode ==
 					INPUT_MODE_HDMI,
-					 tv_dovi_setting->src_format ==
-					FORMAT_HDR10,
+					src_is_42210bit,
 					reset_flag
 				);
 				if (!h_size || !v_size)
@@ -7577,6 +8572,21 @@ int dolby_vision_process(
 				|| force_set) {
 				if (force_set)
 					reset_flag = true;
+				if ((dolby_vision_flags & FLAG_CERTIFICAION)) {
+					if (tv_dovi_setting->src_format ==
+					FORMAT_HDR10 ||
+					tv_dovi_setting->src_format ==
+					FORMAT_HLG ||
+					tv_dovi_setting->src_format ==
+					FORMAT_SDR)
+					src_is_42210bit = true;
+				} else {
+					if ((tv_dovi_setting->src_format ==
+					FORMAT_HDR10) ||
+					(tv_dovi_setting->src_format ==
+					FORMAT_HLG))
+					src_is_42210bit = true;
+				}
 				tv_dolby_core1_set(
 					tv_dovi_setting->core1_reg_lut,
 					h_size,
@@ -7588,8 +8598,7 @@ int dolby_vision_process(
 					src_chroma_format,
 					tv_dovi_setting->input_mode ==
 					INPUT_MODE_HDMI,
-					tv_dovi_setting->src_format ==
-					FORMAT_HDR10,
+					src_is_42210bit,
 					reset_flag);
 				core1_disp_hsize = h_size;
 				core1_disp_vsize = v_size;
@@ -7736,6 +8745,16 @@ int get_dolby_vision_policy(void)
 	return dolby_vision_policy;
 }
 EXPORT_SYMBOL(get_dolby_vision_policy);
+static unsigned long __invoke_psci_fn_smc(unsigned long function_id,
+			unsigned long arg0, unsigned long arg1,
+			unsigned long arg2)
+{
+	struct arm_smccc_res res;
+
+	arm_smccc_smc(function_id, arg0, arg1, arg2, 0, 0, 0, 0, &res);
+	pr_info("arm_smccc_smc 0x%lx, get res.a0 0x%lx\n", function_id, res.a0);
+	return res.a0;
+}
 
 int register_dv_functions(const struct dolby_vision_func_s *func)
 {
@@ -7791,7 +8810,7 @@ int register_dv_functions(const struct dolby_vision_func_s *func)
 			else
 				efuse_mode = 1;
 		}
-		pr_dolby_dbg("efuse_mode=%d reg_value = 0x%x\n",
+		pr_info("efuse_mode=%d reg_value = 0x%x\n",
 			efuse_mode, reg_value);
 		/*stb core doesn't need run mode*/
 		/*TV core need run mode and the value is 2*/
@@ -7816,6 +8835,7 @@ int register_dv_functions(const struct dolby_vision_func_s *func)
 		}
 		adjust_vpotch();
 	}
+	__invoke_psci_fn_smc(0x82000080, 0, 0, 0);
 	return ret;
 }
 EXPORT_SYMBOL(register_dv_functions);
@@ -7843,6 +8863,12 @@ int unregister_dv_functions(void)
 			drop_comp_buf[i] = NULL;
 		}
 	}
+#ifdef V1_6_1
+	if (vsem_if_buf != NULL) {
+		vfree(vsem_if_buf);
+		vsem_if_buf = NULL;
+	}
+#endif
 	if (p_funcs_stb || p_funcs_tv) {
 		pr_info("*** unregister_dv_functions ***\n");
 		if (pq_config_fake) {
@@ -7923,7 +8949,7 @@ void tv_dolby_vision_insert_crc(bool print)
 		&crc_output_buf[crc_output_buff_off],
 		&str[0], len);
 	crc_output_buff_off += len;
-	if (print || (debug_dolby & 2))
+	//if (print || (debug_dolby & 2))
 		pr_info("%s\n", str);
 	crc_count++;
 }
@@ -8510,6 +9536,7 @@ static int amdolby_vision_probe(struct platform_device *pdev)
 		else
 			tv_mode = val;
 	}
+	tv_mode = 1;
 	pr_info("\n cpu_id=%d tvmode=%d\n", dv_meson_dev.cpu_id, tv_mode);
 	memset(devp, 0, (sizeof(struct amdolby_vision_dev_s)));
 	ret = alloc_chrdev_region(&devp->devno, 0, 1, AMDOLBY_VISION_NAME);
diff --git a/drivers/amlogic/media/enhancement/amdolby_vision/amdolby_vision.h b/drivers/amlogic/media/enhancement/amdolby_vision/amdolby_vision.h
index a1f854cca3cb..c2e74f783962 100644
--- a/drivers/amlogic/media/enhancement/amdolby_vision/amdolby_vision.h
+++ b/drivers/amlogic/media/enhancement/amdolby_vision/amdolby_vision.h
@@ -18,6 +18,7 @@
 #define _AMDV_H_
 
 #define V1_5
+#define V1_6_1
 #define V2_4
 /*  driver version */
 #define DRIVER_VER "20181220"
@@ -67,9 +68,13 @@ enum core3_switch_type {
 struct TgtOutCscCfg {
 	int32_t   lms2RgbMat[3][3]; /**<@brief  LMS to RGB matrix */
 	int32_t   lms2RgbMatScale;  /**<@brief  LMS 2 RGB matrix scale */
+#ifdef V1_6_1
+	int32_t   reserved[4];
+#else
 	uint8_t   whitePoint[3];    /**<@brief  White point */
 	uint8_t   whitePointScale;  /**<@brief  White point scale */
 	int32_t   reserved[3];
+#endif
 };
 #pragma pack(pop)
 
@@ -98,14 +103,102 @@ struct TgtGDCfg {
 	uint16_t  gdTriggerPeriod;
 	uint32_t  gdTriggerLinThresh;
 	uint32_t  gdDelayMilliSec_ott;
+#ifdef V1_6_1
+	int16_t   gdRiseWeight;      /*Back light rise weight signed Q3.12 */
+	int16_t   gdFallWeight;      /*Back light fall weight signed Q3.12 */
+	uint32_t  gdDelayMilliSec_ll;/*Back light delay for LL case */
+	uint32_t  gdContrast;        /*GD Contrast DM 4 only */
+	uint32_t  reserved[3];
+#else
 #ifdef V1_5
 	uint32_t  reserved[6];
 #else
 	uint32_t  reserved[9];
 #endif
+#endif
 };
 #pragma pack(pop)
 
+#ifdef V1_6_1
+/*! @brief Ambient light configuration.*/
+# pragma pack(push, 1)
+struct AmbientCfg {
+	uint32_t ambient;
+	uint32_t tFrontLux;
+	uint32_t tFrontLuxScale;
+	uint32_t tRearLum;
+	uint32_t tRearLumScale;
+	uint32_t tWhitexy[2];
+	uint32_t tSurroundReflection;
+	uint32_t tScreenReflection;
+	uint32_t alDelay;
+	uint32_t alRise;
+	uint32_t alFall;
+};
+#pragma pack(pop)
+
+/*! @brief Adaptive Boost configuration.*/
+# pragma pack(push, 1)
+struct TgtABCfg {
+	int32_t   abEnable;             /*Adaptive boost enabled */
+	uint32_t  abHighestTmax;        /*Adaptive boost highest Tmax */
+	uint32_t  abLowestTmax;         /*Adaptive boost lowest Tmax  */
+	int16_t   abRiseWeight;         /*Back light rise weight signed Q3.12 */
+	int16_t   abFallWeight;         /*Back light fall weight signed Q3.12 */
+	uint32_t  abDelayMilliSec_hdmi; /*Back light delay for HDMI case */
+	uint32_t  abDelayMilliSec_ott;  /*Back light delay for OTT case */
+	uint32_t  abDelayMilliSec_ll;   /*Back light delay for LL case */
+	uint32_t  reserved[3];
+};
+#pragma pack(pop)
+
+
+# pragma pack(push, 1)
+struct TargetDisplayConfig {
+	uint16_t gamma;        /*Gamma */
+	uint16_t eotf;         /*Target EOTF */
+	uint16_t rangeSpec;    /*Target Range */
+	uint16_t maxPq;        /*Target max luminance in PQ */
+	uint16_t minPq;        /*Target min luminance in PQ */
+	uint16_t maxPq_dm3;    /*Target max luminance for DM3 in PQ  */
+	int32_t  min_lin;      /*Target min luminance in linear scale 2^18 */
+	int32_t  max_lin;      /*Target max luminance in linear scale 2^18 */
+	int32_t  max_lin_dm3;  /*Target max luminance for DM 3*/
+	int32_t  tPrimaries[8];/*Target primaries */
+	uint16_t mSWeight;  /*Multi-scale Weight,maybe overwritten by metadata*/
+	int16_t  trimSlopeBias;  /*Trim Slope bias */
+	int16_t  trimOffsetBias; /*Trim Offset bias */
+	int16_t  trimPowerBias;      /*Trim Power bias */
+	int16_t  msWeightBias;       /*Multi-scale weight bias */
+	int16_t  chromaWeightBias;   /*Tone mapping chroma weight bias */
+	int16_t  saturationGainBias; /*Tone mapping saturation gain bias */
+	uint16_t tuningMode;         /*Tuning Mode */
+	int16_t  brightness;         /*Brightness */
+	int16_t  contrast;           /*Contrast */
+	int16_t  dColorShift;        /*ColorShift */
+	int16_t  dSaturation;        /*Saturation */
+	int16_t  dBacklight;         /*Backlight */
+	int16_t  dbgExecParamsPrintPeriod; /*Print reg values every n-th frame*/
+	int16_t  dbgDmMdPrintPeriod;       /*Print DM metadata*/
+	int16_t  dbgDmCfgPrintPeriod;      /*Print DM configuration*/
+	struct TgtGDCfg  gdConfig;         /*Global Dimming configuration */
+	struct TgtABCfg  abConfig;         /*Adaptive boost configuration */
+	struct AmbientCfg ambientConfig;   /*Ambient light configuration */
+	uint8_t  vsvdb[7];
+	uint8_t  dm31_avail;
+	uint8_t  reference_mode_dark_id;
+	uint8_t  applyL11;
+	uint8_t  reserved1[1];
+	int16_t  backlight_scaler;       /*Backlight Scaler */
+	struct TgtOutCscCfg ocscConfig;  /*Output CSC configuration */
+	int16_t  brightnessPreservation; /*Brightness preservation */
+	uint8_t  num_total_viewing_modes;/*Num of total viewing modes in cfg*/
+	uint8_t  viewing_mode_valid;     /*1 if the viewing mode is valid*/
+	int16_t  padding[128];
+};
+#pragma pack(pop)
+
+#else
 /*! @defgroup general Enumerations and data structures*/
 # pragma pack(push, 1)
 struct TargetDisplayConfig {
@@ -177,13 +270,15 @@ struct TargetDisplayConfig {
 	int16_t  padding[8];
 };
 #pragma pack(pop)
-
+#endif
 /*! @brief PQ config main data structure.*/
 struct pq_config_s {
+#ifndef V1_6_1
 	unsigned char default_gm_lut[GM_LUT_HDR_SIZE + GM_LUT_SIZE];
 	unsigned char gd_gm_lut_min[GM_LUT_HDR_SIZE + GM_LUT_SIZE];
 	unsigned char gd_gm_lut_max[GM_LUT_HDR_SIZE + GM_LUT_SIZE];
 	unsigned char pq2gamma[sizeof(int32_t)*PQ2G_LUT_SIZE];
+#endif
 	unsigned char backlight_lut[BACLIGHT_LUT_SIZE];
 	struct TargetDisplayConfig target_display_config;
 };
@@ -587,7 +682,20 @@ struct tv_dovi_setting_s {
 	uint32_t video_height;
 	enum input_mode_e input_mode;
 };
-
+#ifdef V1_6_1
+extern int tv_control_path(
+	enum signal_format_e in_format,
+	enum input_mode_e in_mode,
+	char *in_comp, int in_comp_size,
+	char *in_md, int in_md_size,
+	int set_bit_depth, int set_chroma_format, int set_yuv_range,
+	struct pq_config_s *pq_config,
+	struct ui_menu_params_s *menu_param,
+	int set_no_el,
+	struct hdr10_param_s *hdr10_param,
+	struct tv_dovi_setting_s *output,
+	char *vsem_if, int vsem_if_size);
+#else
 extern int tv_control_path(
 	enum signal_format_e in_format,
 	enum input_mode_e in_mode,
@@ -600,6 +708,8 @@ extern int tv_control_path(
 	struct hdr10_param_s *hdr10_param,
 	struct tv_dovi_setting_s *output);
 
+#endif
+
 extern void *metadata_parser_init(int flag);
 extern int metadata_parser_reset(int flag);
 extern int metadata_parser_process(
@@ -629,6 +739,20 @@ struct dolby_vision_func_s {
 		int set_no_el,
 		struct hdr10_param_s *hdr10_param,
 		struct dovi_setting_s *output);
+#ifdef V1_6_1
+	int (*tv_control_path)(
+		enum signal_format_e in_format,
+		enum input_mode_e in_mode,
+		char *in_comp, int in_comp_size,
+		char *in_md, int in_md_size,
+		int set_bit_depth, int set_chroma_format, int set_yuv_range,
+		struct pq_config_s *pq_config,
+		struct ui_menu_params_s *menu_param,
+		int set_no_el,
+		struct hdr10_param_s *hdr10_param,
+		struct tv_dovi_setting_s *output,
+		char *vsem_if, int vsem_if_size);
+#else
 	int (*tv_control_path)(
 		enum signal_format_e in_format,
 		enum input_mode_e in_mode,
@@ -640,6 +764,7 @@ struct dolby_vision_func_s {
 		int set_no_el,
 		struct hdr10_param_s *hdr10_param,
 		struct tv_dovi_setting_s *output);
+#endif
 };
 
 extern int register_dv_functions(const struct dolby_vision_func_s *func);
diff --git a/drivers/amlogic/media/enhancement/amvecm/arch/vpp_dolbyvision_regs.h b/drivers/amlogic/media/enhancement/amvecm/arch/vpp_dolbyvision_regs.h
index bc4ecf0d2d5f..8d202bdff8ad 100644
--- a/drivers/amlogic/media/enhancement/amvecm/arch/vpp_dolbyvision_regs.h
+++ b/drivers/amlogic/media/enhancement/amvecm/arch/vpp_dolbyvision_regs.h
@@ -116,6 +116,11 @@
 #define VPP_DOLBY_CTRL			0x1d93
 #define VIU_SW_RESET			0x1a01
 #define VPU_HDMI_FMT_CTRL		0x2743
+#define VPU_422T0444_CTRL0		0x274b
+#define VPU_422T0444_CTRL1		0x274c
+#define VPU_422T0444_CTRL2		0x274d
+#define VPU_422T0444_RST		0x274a
+
 #if 0
 /* core 1 display manager 24 registers */
 struct dm_register_ipcore_1_s {
diff --git a/drivers/amlogic/media/enhancement/amvecm/arch/vpp_regs.h b/drivers/amlogic/media/enhancement/amvecm/arch/vpp_regs.h
index 93c941cbe884..858fb0a37315 100644
--- a/drivers/amlogic/media/enhancement/amvecm/arch/vpp_regs.h
+++ b/drivers/amlogic/media/enhancement/amvecm/arch/vpp_regs.h
@@ -79,6 +79,10 @@
 #define VPP_VADJ2_Y 0x1d44
 #define VPP_VADJ2_MA_MB 0x1d45
 #define VPP_VADJ2_MC_MD 0x1d46
+
+#define VPP_VADJ2_MISC 0x32a0
+#define VPP_VADJ1_MISC 0x3280
+
 #define VPP_HSHARP_CTRL 0x1d50
 #define VPP_HSHARP_LUMA_THRESH01 0x1d51
 #define VPP_HSHARP_LUMA_THRESH23 0x1d52
@@ -350,6 +354,7 @@
 #define VPU_VLOCK_WIN1_TH				0x3028
 
 #define XVYCC_VD1_RGB_CTRST			0x3170
+#define VPP_VD1_RGB_CTRST			0x3289
 
 #define VIU_EOTF_CTL 0x31d0
 #define VIU_EOTF_COEF00_01 0x31d1
-- 
2.24.1

