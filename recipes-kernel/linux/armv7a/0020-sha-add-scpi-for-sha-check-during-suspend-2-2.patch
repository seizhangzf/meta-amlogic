From 29d66b03c38ad2be43241821836f686981e8f4b5 Mon Sep 17 00:00:00 2001
From: Qiufang Dai <qiufang.dai@amlogic.com>
Date: Thu, 19 Dec 2019 17:56:08 +0800
Subject: [PATCH 7/7] sha: add scpi for sha check during suspend [2/2]

PD#TV-12019

Problem:
Need check ddr region sha during suspend

Solution:
Add scpi interface to register mem region check

Verify:
T962X3_X309

Change-Id: I519e5f495c9fe0aaf70e5d8b5df7ad5174730b7e
Signed-off-by: Qiufang Dai <qiufang.dai@amlogic.com>
---
 drivers/amlogic/mailbox/scpi_protocol.c | 22 +++++++++++++++
 drivers/amlogic/pm/gx_pm.c              | 49 +++++++++++++++++++++++++++++++++
 include/linux/amlogic/scpi_protocol.h   |  3 ++
 3 files changed, 74 insertions(+)

diff --git a/drivers/amlogic/mailbox/scpi_protocol.c b/drivers/amlogic/mailbox/scpi_protocol.c
index 513a370..fb45b4c 100644
--- a/drivers/amlogic/mailbox/scpi_protocol.c
+++ b/drivers/amlogic/mailbox/scpi_protocol.c
@@ -731,6 +731,28 @@ int scpi_unlock_bl40(void)
 }
 EXPORT_SYMBOL_GPL(scpi_unlock_bl40);
 
+/* parameter 'addr' is a physical address.*/
+int scpi_str_sha_check(unsigned int addr, unsigned int length)
+{
+	struct scpi_data_buf sdata;
+	struct mhu_data_buf mdata;
+	u32 temp = 0;
+	struct __packed {
+		u32 addr;
+		u32 length;
+	} buf;
+	buf.addr = addr;
+	buf.length = length;
+
+	SCPI_SETUP_DBUF(sdata, mdata, SCPI_CL_NONE,
+			SCPI_CMD_SHA_REGION_SET, buf, temp);
+	if (scpi_execute_cmd(&sdata))
+		return -EPERM;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(scpi_str_sha_check);
+
 int scpi_send_bl40(unsigned int cmd, struct bl40_msg_buf *bl40_buf)
 {
 	struct scpi_data_buf sdata;
diff --git a/drivers/amlogic/pm/gx_pm.c b/drivers/amlogic/pm/gx_pm.c
index 0ea41c5..7c6ccef 100644
--- a/drivers/amlogic/pm/gx_pm.c
+++ b/drivers/amlogic/pm/gx_pm.c
@@ -184,6 +184,53 @@ ssize_t suspend_reason_store(struct device *dev, struct device_attribute *attr,
 
 DEVICE_ATTR(suspend_reason, 0664, suspend_reason_show, suspend_reason_store);
 
+
+static unsigned int sha_check_addr;
+ssize_t sha_check_addr_show(struct device *dev, struct device_attribute *attr,
+		char *buf)
+{
+	unsigned int len;
+
+	len = sprintf(buf, "%d\n", sha_check_addr);
+
+	return len;
+}
+ssize_t sha_check_addr_store(struct device *dev, struct device_attribute *attr,
+		 const char *buf, size_t count)
+{
+	int ret;
+
+	ret = kstrtouint(buf, 0, &sha_check_addr);
+
+	return count;
+}
+DEVICE_ATTR(sha_check_addr, 0664, sha_check_addr_show, sha_check_addr_store);
+
+
+static unsigned int sha_check_size;
+ssize_t sha_check_size_show(struct device *dev, struct device_attribute *attr,
+		char *buf)
+{
+	unsigned int len;
+
+	len = sprintf(buf, "%d\n", sha_check_size);
+
+	return len;
+}
+ssize_t sha_check_size_store(struct device *dev, struct device_attribute *attr,
+		 const char *buf, size_t count)
+{
+	int ret;
+
+	ret = kstrtouint(buf, 0, &sha_check_size);
+
+	if (scpi_str_sha_check(sha_check_addr, sha_check_size))
+		return -EPERM;
+
+	return count;
+}
+DEVICE_ATTR(sha_check_size, 0664, sha_check_size_show, sha_check_size_store);
+
 ssize_t time_out_show(struct device *dev, struct device_attribute *attr,
 		char *buf)
 {
@@ -276,6 +323,8 @@ static int __init meson_pm_probe(struct platform_device *pdev)
 	}
 
 	device_create_file(&pdev->dev, &dev_attr_suspend_reason);
+	device_create_file(&pdev->dev, &dev_attr_sha_check_addr);
+	device_create_file(&pdev->dev, &dev_attr_sha_check_size);
 	device_create_file(&pdev->dev, &dev_attr_time_out);
 #ifdef CONFIG_AMLOGIC_LEGACY_EARLY_SUSPEND
 	if (lgcy_early_suspend_init())
diff --git a/include/linux/amlogic/scpi_protocol.h b/include/linux/amlogic/scpi_protocol.h
index 045cecb..c1c45fc 100644
--- a/include/linux/amlogic/scpi_protocol.h
+++ b/include/linux/amlogic/scpi_protocol.h
@@ -71,6 +71,8 @@ enum scpi_std_cmd {
 	SCPI_CMD_GET_CPUINFO = 0x33,
 	SCPI_CMD_INIT_DSP = 0x34,
 
+	SCPI_CMD_SHA_REGION_SET	= 0x60,
+
 	SCPI_CMD_GET_CEC1		= 0xB4,
 	SCPI_CMD_GET_CEC2		= 0xB5,
 	SCPI_CMD_SEND_DSP_DATA		= 0xB6,
@@ -132,6 +134,7 @@ u8  scpi_get_ethernet_calc(void);
 int scpi_get_cpuinfo(enum scpi_get_pfm_type type, u32 *freq, u32 *vol);
 int scpi_init_dsp_cfg0(u32 id, u32 addr, u32 cfg0);
 int scpi_unlock_bl40(void);
+int scpi_str_sha_check(unsigned int addr, unsigned int length);
 int scpi_send_dsp_cmd(void *data, int size, bool to_dspa, int cmd, int taskid);
 int scpi_req_handle(void *p, u32 size, u32 cmd);
 int scpi_send_bl40(unsigned int cmd, struct bl40_msg_buf *bl40_buf);
-- 
2.7.4

