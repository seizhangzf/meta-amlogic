From 632fc82eea186fbb9d5435c36e1e3a57260e59f5 Mon Sep 17 00:00:00 2001
From: Ao Xu <ao.xu@amlogic.com>
Date: Mon, 30 Dec 2019 17:45:31 +0800
Subject: [PATCH 1/2] uvm: add dmabuf wrap vframe mechanism [1/1]

PD#SWPL-18483

Problem:
video pipeline use vframe as the video metadata and buffer allocation info.
for RDK, drm only receive the dmabuf fd as the drm_gem_obj

Solution:
add dmabuf wrap vframe mechanism.

Verify:
none

Change-Id: I24c73b0e9887794175c73faaed83862bbbbe6796
Signed-off-by: Ao Xu <ao.xu@amlogic.com>
---
 MAINTAINERS                                       |  21 +
 arch/arm/configs/meson64_a32_defconfig            |   3 +-
 arch/arm64/configs/meson64_defconfig              |   1 +
 drivers/amlogic/media/common/Kconfig              |   1 +
 drivers/amlogic/media/common/Makefile             |   1 +
 drivers/amlogic/media/common/uvm/Kconfig          |  13 +
 drivers/amlogic/media/common/uvm/Makefile         |   8 +
 drivers/amlogic/media/common/uvm/meson_uvm_core.c | 581 ++++++++++++++++++++++
 include/linux/amlogic/meson_uvm_core.h            | 183 +++++++
 9 files changed, 810 insertions(+), 2 deletions(-)
 create mode 100644 drivers/amlogic/media/common/uvm/Kconfig
 create mode 100644 drivers/amlogic/media/common/uvm/Makefile
 create mode 100644 drivers/amlogic/media/common/uvm/meson_uvm_core.c
 create mode 100644 include/linux/amlogic/meson_uvm_core.h

diff --git a/MAINTAINERS b/MAINTAINERS
index 705e36f..c899e9d 100644
--- a/MAINTAINERS
+++ b/MAINTAINERS
@@ -15282,3 +15282,24 @@ F:  arch/arm64/boot/dts/amlogic/tm2_revb_t962e2_ab319.dts
 F:  arch/arm64/boot/dts/amlogic/tm2_revb_t962x3_ab301.dts
 F:  arch/arm64/boot/dts/amlogic/tm2_revb_t962x3_ab309.dts
 F:  arch/arm64/boot/dts/amlogic/tm2_revb_t962x3_t312.dts
+
+AMLOGIC TM2_REVB PANEL DTSI
+M: Evoke Zhang <evoke.zhang@amlogic.com>
+F: arch/arm/boot/dts/amlogic/mesontm2_revb_t962x3_ab301-panel.dtsi
+F: arch/arm/boot/dts/amlogic/mesontm2_revb_t962x3_ab309-panel.dtsi
+F: arch/arm/boot/dts/amlogic/mesontm2_revb_t962x3_t312-panel.dtsi
+F: arch/arm64/boot/dts/amlogic/mesontm2_revb_t962x3_ab301-panel.dtsi
+F: arch/arm64/boot/dts/amlogic/mesontm2_revb_t962x3_ab309-panel.dtsi
+F: arch/arm64/boot/dts/amlogic/mesontm2_revb_t962x3_t312-panel.dtsi
+
+AMLOGIC ION
+M: Dezhi Kong <dezhi.kong@amlogic.com>
+F:  drivers/staging/android/ion/ion_secure_heap.c
+
+AMLOGIC DECODE RESOURCE MANAGE
+M: Baoguo Chen <baoguo.chen@amlogic.com>
+F: drivers/amlogic/media/common/resource_mgr/*
+
+AMLOGIC UVM
+M:     Ao Xu <ao.xu@amlogic.com>
+F:     drivers/amlogic/media/common/uvm/
diff --git a/arch/arm/configs/meson64_a32_defconfig b/arch/arm/configs/meson64_a32_defconfig
index be476f4..ad92860 100644
--- a/arch/arm/configs/meson64_a32_defconfig
+++ b/arch/arm/configs/meson64_a32_defconfig
@@ -279,6 +279,7 @@ CONFIG_AMLOGIC_MEDIA_GE2D=y
 CONFIG_AMLOGIC_ION=y
 CONFIG_AMLOGIC_MEDIA_RDMA=y
 CONFIG_AMLOGIC_MEDIA_VSYNC_RDMA=y
+CONFIG_AMLOGIC_UVM_CORE=y
 CONFIG_AMLOGIC_MEDIA_VFM=y
 CONFIG_AMLOGIC_VPU=y
 CONFIG_AMLOGIC_VIDEOBUF_RESOURCE=y
@@ -300,8 +301,6 @@ CONFIG_AMLOGIC_BL_EXTERN=y
 CONFIG_AMLOGIC_BL_EXTERN_I2C_LP8556=y
 CONFIG_AMLOGIC_BL_EXTERN_MIPI_LT070ME05=y
 CONFIG_AMLOGIC_LOCAL_DIMMING=y
-CONFIG_AMLOGIC_LOCAL_DIMMING_IW7038=y
-CONFIG_AMLOGIC_LOCAL_DIMMING_IW7027=y
 CONFIG_AMLOGIC_VOUT_SERVE=y
 CONFIG_AMLOGIC_VOUT2_SERVE=y
 CONFIG_AMLOGIC_MEDIA_FB=y
diff --git a/arch/arm64/configs/meson64_defconfig b/arch/arm64/configs/meson64_defconfig
index 10226a7..d4d7b46 100644
--- a/arch/arm64/configs/meson64_defconfig
+++ b/arch/arm64/configs/meson64_defconfig
@@ -274,6 +274,7 @@ CONFIG_AMLOGIC_MEDIA_GE2D=y
 CONFIG_AMLOGIC_ION=y
 CONFIG_AMLOGIC_MEDIA_RDMA=y
 CONFIG_AMLOGIC_MEDIA_VSYNC_RDMA=y
+CONFIG_AMLOGIC_UVM_CORE=y
 CONFIG_AMLOGIC_MEDIA_VFM=y
 CONFIG_AMLOGIC_VPU=y
 CONFIG_AMLOGIC_VIDEOBUF_RESOURCE=y
diff --git a/drivers/amlogic/media/common/Kconfig b/drivers/amlogic/media/common/Kconfig
index b06a63a..0eacd34 100644
--- a/drivers/amlogic/media/common/Kconfig
+++ b/drivers/amlogic/media/common/Kconfig
@@ -5,6 +5,7 @@ source "drivers/amlogic/media/common/ge2d/Kconfig"
 source "drivers/amlogic/media/common/ion_dev/Kconfig"
 source "drivers/amlogic/media/common/rdma/Kconfig"
 source "drivers/amlogic/media/common/secmem/Kconfig"
+source "drivers/amlogic/media/common/uvm/Kconfig"
 source "drivers/amlogic/media/common/vfm/Kconfig"
 source "drivers/amlogic/media/common/vpu/Kconfig"
 source "drivers/amlogic/media/common/v4l_util/Kconfig"
diff --git a/drivers/amlogic/media/common/Makefile b/drivers/amlogic/media/common/Makefile
index b1f87a4..0745a38 100644
--- a/drivers/amlogic/media/common/Makefile
+++ b/drivers/amlogic/media/common/Makefile
@@ -6,6 +6,7 @@ obj-$(CONFIG_AMLOGIC_ION)			+= ion_dev/
 obj-$(CONFIG_AMLOGIC_MEDIA_GE2D)	+=	ge2d/
 obj-$(CONFIG_AMLOGIC_MEDIA_RDMA)	+=	rdma/
 obj-$(CONFIG_AMLOGIC_SECMEM)		+=	secmem/
+obj-$(CONFIG_AMLOGIC_UVM_CORE)		+=	uvm/
 obj-$(CONFIG_AMLOGIC_MEDIA_VFM)	+=	vfm/
 obj-$(CONFIG_AMLOGIC_VPU)	+=	vpu/
 obj-$(CONFIG_AMLOGIC_VIDEOBUF_RESOURCE)	+= v4l_util/
diff --git a/drivers/amlogic/media/common/uvm/Kconfig b/drivers/amlogic/media/common/uvm/Kconfig
new file mode 100644
index 00000000..3157845
--- /dev/null
+++ b/drivers/amlogic/media/common/uvm/Kconfig
@@ -0,0 +1,13 @@
+#
+# uvm core configuration
+#
+
+
+menuconfig AMLOGIC_UVM_CORE
+	bool "Amlogic unified video memory management"
+	default n
+	help
+	  say y to enable Amlogic unified video memory management.
+	  uvm wrap the video metadata info vframe_s so that decoder
+	  and display can decouple.
+
diff --git a/drivers/amlogic/media/common/uvm/Makefile b/drivers/amlogic/media/common/uvm/Makefile
new file mode 100644
index 00000000..410de66
--- /dev/null
+++ b/drivers/amlogic/media/common/uvm/Makefile
@@ -0,0 +1,8 @@
+#
+# Makefile for amlogic uvm
+#
+
+ccflags-y += -Idrivers/staging/android/ -Idrivers/amlogic/
+
+obj-$(CONFIG_AMLOGIC_UVM_CORE)		+= meson_uvm_core.o
+
diff --git a/drivers/amlogic/media/common/uvm/meson_uvm_core.c b/drivers/amlogic/media/common/uvm/meson_uvm_core.c
new file mode 100644
index 00000000..060a91e
--- /dev/null
+++ b/drivers/amlogic/media/common/uvm/meson_uvm_core.c
@@ -0,0 +1,581 @@
+/*
+ * drivers/amlogic/media/common/uvm/meson_uvm_core.c
+ *
+ * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#include <linux/device.h>
+#include <linux/kernel.h>
+#include <linux/platform_device.h>
+#include <linux/err.h>
+#include <linux/file.h>
+#include <linux/fs.h>
+#include <linux/miscdevice.h>
+#include <linux/rbtree.h>
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+#include <linux/vmalloc.h>
+#include <linux/debugfs.h>
+#include <linux/module.h>
+#include <linux/dma-buf.h>
+#include <linux/pagemap.h>
+#include <linux/amlogic/meson_uvm_core.h>
+
+static int debug_level;
+module_param(debug_level, int, 0644);
+
+#define UVM_PRINTK(level, fmt, arg...) \
+	do {	\
+		if (debug_level >= level)	\
+			pr_info("UVM: " fmt, ## arg); \
+	} while (0)
+
+static void uvm_hook_mod_release(struct kref *kref);
+static struct uvm_hook_mod *uvm_find_hook_mod(struct uvm_handle *handle,
+						     int type);
+
+static void uvm_handle_destroy(struct kref *kref)
+{
+	struct uvm_handle *handle;
+
+	handle = container_of(kref, struct uvm_handle, ref);
+
+	kfree(handle->ua);
+
+	kfree(handle);
+}
+
+static int meson_uvm_attach(struct dma_buf *dmabuf, struct device *dev,
+			    struct dma_buf_attachment *attach)
+{
+	UVM_PRINTK(1, "meson_uvm_attach called, %s.\n", current->comm);
+	return 0;
+}
+
+static void meson_uvm_detach(struct dma_buf *dmabuf,
+			     struct dma_buf_attachment *attach)
+{
+	UVM_PRINTK(1, "meson_uvm_detach called, %s.\n", current->comm);
+	/* TODO */
+}
+
+static struct sg_table *meson_uvm_map_dma_buf(
+			struct dma_buf_attachment *attachment,
+			enum dma_data_direction direction)
+{
+	struct dma_buf *dmabuf;
+	struct uvm_handle *handle;
+	struct uvm_alloc *ua;
+	struct sg_table *sgt;
+
+	dmabuf = attachment->dmabuf;
+	handle = dmabuf->priv;
+	ua = handle->ua;
+	sgt = ua->sgt;
+
+	UVM_PRINTK(1, "meson_uvm_map_dma_buf called, %s.\n", current->comm);
+
+	if (ua->flags | BIT(UVM_FAKE_ALLOC)) {
+		dma_map_page(attachment->dev, sg_page(sgt->sgl), 0,
+				UVM_FAKE_SIZE, direction);
+	} else if (!dma_map_sg(attachment->dev, sgt->sgl, sgt->nents,
+				direction)) {
+		UVM_PRINTK(0, "meson_uvm: dma_map_sg call failed.\n");
+		return ERR_PTR(-ENOMEM);
+	}
+	dma_sync_sg_for_device(NULL, sgt->sgl, sgt->nents, DMA_BIDIRECTIONAL);
+	return sgt;
+}
+
+static void meson_uvm_unmap_dma_buf(struct dma_buf_attachment *attachment,
+				    struct sg_table *sgt,
+				    enum dma_data_direction direction)
+{
+	struct dma_buf *dmabuf;
+	struct uvm_handle *handle;
+	struct uvm_alloc *ua;
+
+	dmabuf = attachment->dmabuf;
+	handle = dmabuf->priv;
+	ua = handle->ua;
+
+	UVM_PRINTK(1, "meson_uvm_unmap_dma_buf called, %s.\n", current->comm);
+	if (ua->flags | BIT(UVM_FAKE_ALLOC))
+		dma_unmap_page(attachment->dev, sgt->sgl->dma_address,
+			UVM_FAKE_SIZE, direction);
+	else
+		dma_unmap_sg(attachment->dev, sgt->sgl, sgt->nents, direction);
+}
+
+static void meson_uvm_release(struct dma_buf *dmabuf)
+{
+	struct uvm_hook_mod *uhmod, *uhtmp;
+
+	struct uvm_handle *handle = dmabuf->priv;
+	struct uvm_alloc *ua = handle->ua;
+
+	UVM_PRINTK(1, "meson_uvm_release called.\n");
+
+	ua->free(ua->obj);
+
+	list_for_each_entry_safe(uhmod, uhtmp, &handle->mod_attached, list)
+		kref_put(&uhmod->ref, uvm_hook_mod_release);
+
+	kref_put(&handle->ref, uvm_handle_destroy);
+}
+
+static int meson_uvm_begin_cpu_access(struct dma_buf *dmabuf,
+				      enum dma_data_direction dir)
+{
+	UVM_PRINTK(1, "meson_uvm_begin_cpu_access called.\n");
+	return 0;
+}
+
+static int meson_uvm_end_cpu_access(struct dma_buf *dmabuf,
+				    enum dma_data_direction dir)
+{
+	UVM_PRINTK(1, "meson_uvm_end_cpu_access called.\n");
+	return 0;
+}
+
+static void *meson_uvm_kmap(struct dma_buf *dmabuf, unsigned long offset)
+{
+	UVM_PRINTK(1, "meson_uvm_kmap called.\n");
+	return NULL;
+}
+
+static void meson_uvm_kunmap(struct dma_buf *dmabuf,
+			     unsigned long offset, void *ptr)
+{
+	UVM_PRINTK(1, "meson_uvm_kunmap called.\n");
+	/* TODO */
+}
+
+static void *meson_uvm_kmap_atomic(struct dma_buf *dmabuf,
+				   unsigned long offset)
+{
+	UVM_PRINTK(1, "meson_uvm_kmap_atomic called.\n");
+	return NULL;
+}
+
+static void meson_uvm_kunmap_atomic(struct dma_buf *dmabuf,
+				    unsigned long offset, void *ptr)
+{
+	UVM_PRINTK(1, "meson_uvm_kunmap_atomic called.\n");
+	/* TODO */
+}
+
+static void *meson_uvm_vmap(struct dma_buf *dmabuf)
+{
+	struct uvm_handle *handle;
+	struct sg_table *sgt;
+	struct scatterlist *sg;
+	struct page **pages;
+	struct page **tmp;
+	int npages, i, j;
+	pgprot_t pgprot;
+	void *vaddr;
+
+	handle = dmabuf->priv;
+	sgt = handle->ua->sgt;
+	npages = PAGE_ALIGN(handle->size) / PAGE_SIZE;
+	pgprot = pgprot_writecombine(PAGE_KERNEL);
+
+	pages = vmalloc(sizeof(struct page *) * npages);
+	if (!pages)
+		return NULL;
+
+	tmp = pages;
+	for_each_sg(sgt->sgl, sg, sgt->nents, i) {
+		int npages_this_entry = PAGE_ALIGN(sg->length) / PAGE_SIZE;
+		struct page *page = sg_page(sg);
+
+		WARN_ON(i >= npages);
+		for (j = 0; j < npages_this_entry; j++)
+			*(tmp++) = page++;
+	}
+	vaddr = vmap(pages, npages, VM_MAP, pgprot);
+	vfree(pages);
+
+	if (vaddr == NULL)
+		return ERR_PTR(-ENOMEM);
+
+	handle->ua->vaddr = vaddr;
+	UVM_PRINTK(1, "meson_uvm_vmap called.\n");
+	return vaddr;
+}
+
+static void meson_uvm_vunmap(struct dma_buf *dmabuf, void *vaddr)
+{
+	struct uvm_handle *handle = dmabuf->priv;
+	UVM_PRINTK(1, "meson_uvm_vunmap called.\n");
+	vunmap(handle->ua->vaddr);
+}
+
+static int meson_uvm_mmap(struct dma_buf *dmabuf, struct vm_area_struct *vma)
+{
+	int i;
+	int ret;
+	struct scatterlist *sg;
+	struct uvm_handle *handle = dmabuf->priv;
+	struct sg_table *table = handle->ua->sgt;
+	unsigned long addr = vma->vm_start;
+	unsigned long offset = vma->vm_pgoff * PAGE_SIZE;
+
+	UVM_PRINTK(1, "meson_uvm_mmap called.\n");
+
+	if (!table) {
+		UVM_PRINTK(0, "buffer was not allocated.\n");
+		return -EINVAL;
+	}
+
+	for_each_sg(table->sgl, sg, table->nents, i) {
+		struct page *page = sg_page(sg);
+		unsigned long remainder = vma->vm_end - addr;
+		unsigned long len = sg->length;
+
+		if (offset >= sg->length) {
+			offset -= sg->length;
+			continue;
+		} else if (offset) {
+			page += offset / PAGE_SIZE;
+			len = sg->length - offset;
+			offset = 0;
+		}
+		len = min(len, remainder);
+		ret = remap_pfn_range(vma, addr, page_to_pfn(page), len,
+				      vma->vm_page_prot);
+		if (ret)
+			return ret;
+		addr += len;
+		if (addr >= vma->vm_end)
+			return 0;
+	}
+
+	return 0;
+}
+
+static struct dma_buf_ops meson_uvm_dma_ops = {
+	.attach = meson_uvm_attach,
+	.detach = meson_uvm_detach,
+	.map_dma_buf = meson_uvm_map_dma_buf,
+	.unmap_dma_buf = meson_uvm_unmap_dma_buf,
+	.release = meson_uvm_release,
+	.begin_cpu_access = meson_uvm_begin_cpu_access,
+	.end_cpu_access = meson_uvm_end_cpu_access,
+	.kmap = meson_uvm_kmap,
+	.kmap_atomic = meson_uvm_kmap_atomic,
+	.kunmap = meson_uvm_kunmap,
+	.kunmap_atomic = meson_uvm_kunmap_atomic,
+	.vmap = meson_uvm_vmap,
+	.vunmap = meson_uvm_vunmap,
+	.mmap = meson_uvm_mmap,
+};
+
+static struct uvm_handle *uvm_handle_alloc(size_t len, size_t align,
+					   ulong flags)
+{
+	struct uvm_handle *handle;
+	struct uvm_alloc *ua;
+
+	handle = kzalloc(sizeof(*handle), GFP_KERNEL);
+	if (!handle)
+		return ERR_PTR(-ENOMEM);
+
+	kref_init(&handle->ref);
+	mutex_init(&handle->lock);
+	handle->size = len;
+	handle->align = align;
+	handle->flags = flags;
+	INIT_LIST_HEAD(&handle->mod_attached);
+
+	ua = kzalloc(sizeof(*ua), GFP_KERNEL);
+	if (!ua) {
+		kfree(handle);
+		return ERR_PTR(-ENOMEM);
+	}
+	handle->ua = ua;
+
+	return handle;
+}
+
+static struct dma_buf *uvm_dmabuf_export(struct uvm_handle *handle)
+{
+	struct dma_buf *dmabuf;
+
+	struct dma_buf_export_info exp_info = {
+		.exp_name = KBUILD_MODNAME,
+		.owner = THIS_MODULE,
+		.ops = &meson_uvm_dma_ops,
+		.size = handle->size,
+		.flags = handle->flags,
+		.priv = handle,
+	};
+
+	dmabuf = dma_buf_export(&exp_info);
+	if (IS_ERR(dmabuf)) {
+		UVM_PRINTK(0, "uvm_dmabuf_export fail.\n");
+		return ERR_PTR(-ENOMEM);
+	}
+
+	handle->dmabuf = dmabuf;
+
+	return dmabuf;
+}
+
+struct dma_buf *uvm_alloc_dmabuf(size_t len, size_t align, ulong flags)
+{
+	struct uvm_handle *handle;
+	struct dma_buf *dmabuf;
+
+	handle = uvm_handle_alloc(len, align, flags);
+	if (IS_ERR(handle))
+		return ERR_PTR(-ENOMEM);
+
+	dmabuf = uvm_dmabuf_export(handle);
+	if (IS_ERR(dmabuf)) {
+		kfree(handle);
+		return ERR_PTR(-EINVAL);
+	}
+
+	return dmabuf;
+}
+EXPORT_SYMBOL(uvm_alloc_dmabuf);
+
+bool dmabuf_is_uvm(struct dma_buf *dmabuf)
+{
+	return dmabuf->ops == &meson_uvm_dma_ops;
+}
+EXPORT_SYMBOL(dmabuf_is_uvm);
+
+static struct sg_table *uvm_copy_sgt(struct sg_table *src_table)
+{
+	struct sg_table *dst_table = NULL;
+	struct scatterlist *dst_sgl = NULL;
+	struct scatterlist *src_sgl = NULL;
+	int i, ret;
+
+	dst_table = kzalloc(sizeof(*dst_table), GFP_KERNEL);
+	if (!dst_table)
+		return ERR_PTR(-ENOMEM);
+
+	ret = sg_alloc_table(dst_table, src_table->nents, GFP_KERNEL);
+	if (ret) {
+		kfree(dst_table);
+		return ERR_PTR(-ENOMEM);
+	}
+
+	dst_sgl = dst_table->sgl;
+	src_sgl = src_table->sgl;
+	for (i = 0; i < src_table->nents; i++) {
+		sg_set_page(dst_sgl, sg_page(src_sgl), src_sgl->length, 0);
+		sg_dma_address(dst_sgl) = sg_phys(src_sgl);
+		sg_dma_len(dst_sgl) = sg_dma_len(src_sgl);
+		dst_sgl = sg_next(dst_sgl);
+		src_sgl = sg_next(src_sgl);
+	}
+
+	return dst_table;
+
+}
+
+int dmabuf_bind_uvm_alloc(struct dma_buf *dmabuf, struct uvm_alloc_info *info)
+{
+	struct uvm_handle *handle;
+	struct uvm_alloc *ua;
+
+	if (!dmabuf || !dmabuf_is_uvm(dmabuf)) {
+		UVM_PRINTK(0, "dmabuf is not uvm.\n");
+		return -EINVAL;
+	}
+
+	handle = dmabuf->priv;
+	ua = handle->ua;
+
+	if (!info->sgt) {
+		UVM_PRINTK(0, "invalid sg_table.\n");
+		return -EINVAL;
+	}
+
+	ua->size = info->size;
+	ua->flags = info->flags;
+	ua->sgt = uvm_copy_sgt(info->sgt);
+	ua->obj = info->obj;
+	ua->obj->dmabuf = dmabuf;
+	ua->free = info->free;
+
+	return 0;
+
+}
+EXPORT_SYMBOL(dmabuf_bind_uvm_alloc);
+
+int dmabuf_set_vframe(struct dma_buf *dmabuf, struct vframe_s *vf)
+{
+	struct uvm_handle *handle;
+
+	if (!dmabuf || !dmabuf_is_uvm(dmabuf)) {
+		UVM_PRINTK(0, "dmabuf is not uvm.\n");
+		return -EINVAL;
+	}
+
+	handle = dmabuf->priv;
+	memcpy(&handle->vf, vf, sizeof(struct vframe_s));
+	handle->vfp = vf;
+
+	return 0;
+}
+EXPORT_SYMBOL(dmabuf_set_vframe);
+
+struct vframe_s *dmabuf_get_vframe(struct dma_buf *dmabuf)
+{
+	struct uvm_handle *handle;
+
+	if (!dmabuf || !dmabuf_is_uvm(dmabuf)) {
+		UVM_PRINTK(0, "dmabuf is not uvm.\n");
+		return ERR_PTR(-EINVAL);
+	}
+
+	handle = dmabuf->priv;
+	kref_get(&handle->ref);
+
+	return &handle->vf;
+}
+EXPORT_SYMBOL(dmabuf_get_vframe);
+
+int dmabuf_put_vframe(struct dma_buf *dmabuf)
+{
+	struct uvm_handle *handle;
+
+	if (!dmabuf || !dmabuf_is_uvm(dmabuf)) {
+		UVM_PRINTK(0, "dmabuf is not uvm.\n");
+		return -EINVAL;
+	}
+
+	handle = dmabuf->priv;
+	return kref_put(&handle->ref, uvm_handle_destroy);
+}
+EXPORT_SYMBOL(dmabuf_put_vframe);
+
+int uvm_attach_hook_mod(struct dma_buf *dmabuf,
+			      struct uvm_hook_mod_info *info)
+{
+	struct uvm_handle *handle;
+	struct uvm_hook_mod *uhmod;
+
+	if (!dmabuf || !dmabuf_is_uvm(dmabuf)) {
+		UVM_PRINTK(0, "dmabuf is not uvm.\n");
+		return -EINVAL;
+	}
+
+	handle = dmabuf->priv;
+	uhmod = kzalloc(sizeof(*uhmod), GFP_KERNEL);
+	if (!uhmod) {
+		UVM_PRINTK(0, "kzalloc uvm_hook_mod fail.\n");
+		return -ENOMEM;
+	}
+
+	kref_init(&uhmod->ref);
+	uhmod->type = info->type;
+	uhmod->arg = info->arg;
+	uhmod->free = info->free;
+	uhmod->acquire_fence = info->acquire_fence;
+
+	mutex_lock(&handle->lock);
+	list_add_tail(&uhmod->list, &handle->mod_attached);
+	handle->n_mod_attached++;
+	handle->mod_attached_mask |= 1 << (uhmod->type);
+	mutex_unlock(&handle->lock);
+
+	UVM_PRINTK(1, "%s called.\n", __func__);
+
+	return 0;
+}
+EXPORT_SYMBOL(uvm_attach_hook_mod);
+
+int uvm_detach_hook_mod(struct dma_buf *dmabuf, int type)
+{
+	UVM_PRINTK(1, "%s called.\n", __func__);
+	return uvm_put_hook_mod(dmabuf, type);
+}
+EXPORT_SYMBOL(uvm_detach_hook_mod);
+
+static struct uvm_hook_mod *uvm_find_hook_mod(struct uvm_handle *handle,
+						     int type)
+{
+	struct uvm_hook_mod *uhmod = NULL;
+
+	mutex_lock(&handle->lock);
+	list_for_each_entry(uhmod, &handle->mod_attached, list) {
+		if (uhmod->type == type)
+			break;
+	}
+	mutex_unlock(&handle->lock);
+
+	if (!uhmod) {
+		UVM_PRINTK(0, "uvm_find_hook_mod fail.\n");
+		return ERR_PTR(-EINVAL);
+	}
+
+	return uhmod;
+}
+
+struct uvm_hook_mod *uvm_get_hook_mod(struct dma_buf *dmabuf,
+						     int type)
+{
+	struct uvm_handle *handle;
+	struct uvm_hook_mod *uhmod = NULL;
+
+	if (!dmabuf || !dmabuf_is_uvm(dmabuf)) {
+		UVM_PRINTK(0, "dmabuf is not uvm.\n");
+		return ERR_PTR(-EINVAL);
+	}
+
+	handle = dmabuf->priv;
+	uhmod = uvm_find_hook_mod(handle, type);
+	if (uhmod)
+		kref_get(&uhmod->ref);
+
+	return uhmod;
+}
+EXPORT_SYMBOL(uvm_get_hook_mod);
+
+static void uvm_hook_mod_release(struct kref *kref)
+{
+	struct uvm_hook_mod *uhmod;
+
+	uhmod = container_of(kref, struct uvm_hook_mod, ref);
+	list_del(&uhmod->list);
+	UVM_PRINTK(1, "uvm_hook_mod_release.\n");
+	uhmod->free(uhmod->arg);
+}
+
+int uvm_put_hook_mod(struct dma_buf *dmabuf, int type)
+{
+	struct uvm_handle *handle;
+	struct uvm_hook_mod *uhmod = NULL;
+
+	if (!dmabuf || !dmabuf_is_uvm(dmabuf)) {
+		UVM_PRINTK(0, "dmabuf is not uvm.\n");
+		return -EINVAL;
+	}
+
+	handle = dmabuf->priv;
+	uhmod = uvm_find_hook_mod(handle, type);
+
+	if (uhmod)
+		return kref_put(&uhmod->ref, uvm_hook_mod_release);
+	else
+		return -EINVAL;
+}
+EXPORT_SYMBOL(uvm_put_hook_mod);
diff --git a/include/linux/amlogic/meson_uvm_core.h b/include/linux/amlogic/meson_uvm_core.h
new file mode 100644
index 00000000..2750246
--- /dev/null
+++ b/include/linux/amlogic/meson_uvm_core.h
@@ -0,0 +1,183 @@
+/*
+ * include/linux/amlogic/meson_uvm_core.h
+ *
+ * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#ifndef __MESON_UVM_H
+#define __MESON_UVM_H
+
+#include <linux/device.h>
+#include <linux/dma-direction.h>
+#include <linux/miscdevice.h>
+#include <linux/kref.h>
+#include <linux/mm_types.h>
+#include <linux/mutex.h>
+#include <linux/rbtree.h>
+#include <linux/sched.h>
+#include <linux/ioctl.h>
+#include <linux/types.h>
+
+#include <linux/amlogic/media/vfm/vframe.h>
+
+#define MAX_BUFF_NUMS	4
+#define UVM_FAKE_SIZE 4096
+
+enum uvm_alloc_flag {
+	UVM_IMM_ALLOC,
+	UVM_DELAY_ALLOC,
+	UVM_FAKE_ALLOC,
+};
+
+/**
+ * struct uvm_handle - video dmabuffer wrap vframe
+ *
+ * @ref:	reference count
+ * @lock:	protects the uvm_handle fields
+ * @uvm_alloc:	buffer alloc info
+ * @dma_buf:	dmabuf structure
+ * @alloc:		non-alloc or allocated
+ * @size:		dmabuf size
+ * @align:		dmabuf align size
+ * @flags:		alloc flag and usage flag
+ * @vf:			builtin vframe
+ * @vfp:		pointer the origin vframe
+ * @mod_attached:	list of attached module
+ * @n_mod_attached:	num of attached module
+ * @mod_attached_mask:	mask of attached module
+ */
+struct uvm_handle {
+	struct kref ref;
+	struct mutex lock;
+
+	struct uvm_alloc *ua;
+	struct dma_buf *dmabuf;
+	bool alloc;
+	size_t size;
+	size_t align;
+	unsigned long flags;
+
+	struct vframe_s vf;
+	struct vframe_s *vfp;
+
+	struct list_head mod_attached;
+	size_t n_mod_attached;
+	unsigned long mod_attached_mask;
+};
+
+/**
+ * struct uvm_buf_obj - uvm buffer object
+ * This structure define the uvm buffer object. uvm do not allocate buffer.
+ * device that allocate buffer, wrap this structure.
+ *
+ * @arg:	uvm dmabuf exporter device priv structure
+ * @dev:	uvm dmabuf exporter device
+ */
+struct uvm_buf_obj {
+	void *arg;
+	struct device *dev;
+	struct dma_buf *dmabuf;
+};
+
+/**
+ * struct uvm_alloc - uvm buffer alloc struct
+ *
+ * @sgt:	dmabuf sg_table
+ * @pages:	dmabuf page array
+ * @vaddr:	dmabuf kernel address
+ * @size:	dmabuf real size
+ * @obj:	uvm buffer object
+ * @free:	free uvm_buf_obj related
+ */
+struct uvm_alloc {
+	struct sg_table *sgt;
+	struct page **pages;
+	void *vaddr;
+	size_t size;
+	uint64_t flags;
+	struct uvm_buf_obj *obj;
+	void (*free)(struct uvm_buf_obj *obj);
+};
+
+struct uvm_alloc_info {
+	size_t size;
+	uint64_t flags;
+	struct sg_table *sgt;
+	struct uvm_buf_obj *obj;
+	void (*free)(struct uvm_buf_obj *obj);
+};
+
+enum uvm_hook_mod_type {
+	VF_SRC_DECODER,
+	VF_SRC_VDIN,
+	VF_PROCESS_V4LVIDEO,
+	VF_PROCESS_DI,
+	VF_PROCESS_VIDEOCOMPOSER,
+};
+
+/**
+ * struct uvm_hook_mod - uvm hook module
+ *
+ * @ref:	reference count
+ * @type:	module type
+ * @arg:	module private data
+ * @free:	module free function
+ * @acquire_fence:	module acquire fence
+ * @head:	module link node
+ */
+struct uvm_hook_mod {
+	struct kref ref;
+	enum uvm_hook_mod_type type;
+	void *arg;
+	void (*free)(void *arg);
+	struct sync_fence *acquire_fence;
+	struct list_head list;
+};
+
+struct uvm_hook_mod_info {
+	enum uvm_hook_mod_type type;
+	void *arg;
+	void (*free)(void *arg);
+	struct sync_fence *acquire_fence;
+};
+
+struct dma_buf *uvm_alloc_dmabuf(size_t len, size_t align, ulong flags);
+
+bool dmabuf_is_uvm(struct dma_buf *dmabuf);
+
+int dmabuf_bind_uvm_alloc(struct dma_buf *dmabuf, struct uvm_alloc_info *info);
+
+/**
+ * uvm vframe interface
+ */
+int dmabuf_set_vframe(struct dma_buf *dmabuf, struct vframe_s *vf);
+
+struct vframe_s *dmabuf_get_vframe(struct dma_buf *dmabuf);
+
+int dmabuf_put_vframe(struct dma_buf *dmabuf);
+
+/**
+ * uvm hook module interface
+ */
+int uvm_attach_hook_mod(struct dma_buf *dmabuf,
+					struct uvm_hook_mod_info *info);
+int uvm_detach_hook_mod(struct dma_buf *dmabuf,
+					int type);
+
+struct uvm_hook_mod *uvm_get_hook_mod(struct dma_buf *dmabuf,
+						     int type);
+
+int uvm_put_hook_mod(struct dma_buf *dmabuf, int type);
+
+#endif
-- 
2.7.4

