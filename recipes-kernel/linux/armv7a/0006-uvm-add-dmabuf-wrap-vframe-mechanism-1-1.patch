From 7e33a61d032d230b7d831a0e80ce5ffcdd6692b8 Mon Sep 17 00:00:00 2001
From: Ao Xu <ao.xu@amlogic.com>
Date: Mon, 30 Dec 2019 17:45:31 +0800
Subject: [PATCH 1/2] uvm: add dmabuf wrap vframe mechanism [1/1]

PD#SWPL-18483

Problem:
video pipeline use vframe as the video metadata and buffer allocation info.
for RDK, drm only receive the dmabuf fd as the drm_gem_obj

Solution:
add dmabuf wrap vframe mechanism.

Verify:
none

Change-Id: I24c73b0e9887794175c73faaed83862bbbbe6796
Signed-off-by: Ao Xu <ao.xu@amlogic.com>
---
 arch/arm/configs/meson64_a32_defconfig |   1 +
 arch/arm64/configs/meson64_defconfig   |   1 +
 drivers/amlogic/Kconfig                |   2 +
 drivers/amlogic/Makefile               |   2 +
 drivers/amlogic/uvm/Kconfig            |  12 +
 drivers/amlogic/uvm/Makefile           |   8 +
 drivers/amlogic/uvm/meson_uvm_core.c   | 472 +++++++++++++++++++++++++
 include/linux/amlogic/meson_uvm_core.h | 117 ++++++
 8 files changed, 615 insertions(+)
 create mode 100644 drivers/amlogic/uvm/Kconfig
 create mode 100644 drivers/amlogic/uvm/Makefile
 create mode 100644 drivers/amlogic/uvm/meson_uvm_core.c
 create mode 100644 include/linux/amlogic/meson_uvm_core.h

diff --git a/arch/arm/configs/meson64_a32_defconfig b/arch/arm/configs/meson64_a32_defconfig
index be476f4afc51..a4251a1512bf 100644
--- a/arch/arm/configs/meson64_a32_defconfig
+++ b/arch/arm/configs/meson64_a32_defconfig
@@ -391,6 +391,7 @@ CONFIG_DOLBY_FW=y
 CONFIG_AMLOGIC_HIFI4DSP=y
 CONFIG_AMLOGIC_PIXEL_PROBE=y
 CONFIG_AMLOGIC_FIRMWARE=y
+CONFIG_AMLOGIC_UVM=y
 CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
 CONFIG_DEVTMPFS=y
 CONFIG_DEVTMPFS_MOUNT=y
diff --git a/arch/arm64/configs/meson64_defconfig b/arch/arm64/configs/meson64_defconfig
index 10226a7111d1..b39bccf1e895 100644
--- a/arch/arm64/configs/meson64_defconfig
+++ b/arch/arm64/configs/meson64_defconfig
@@ -386,6 +386,7 @@ CONFIG_DOLBY_FW=y
 CONFIG_AMLOGIC_HIFI4DSP=y
 CONFIG_AMLOGIC_PIXEL_PROBE=y
 CONFIG_AMLOGIC_FIRMWARE=y
+CONFIG_AMLOGIC_UVM=y
 CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
 CONFIG_DEVTMPFS=y
 CONFIG_DEVTMPFS_MOUNT=y
diff --git a/drivers/amlogic/Kconfig b/drivers/amlogic/Kconfig
index 914146f80a1e..50dafb125036 100644
--- a/drivers/amlogic/Kconfig
+++ b/drivers/amlogic/Kconfig
@@ -148,5 +148,7 @@ source "drivers/amlogic/pixel_probe/Kconfig"
 
 source "drivers/amlogic/firmware/Kconfig"
 
+source "drivers/amlogic/uvm/Kconfig"
+
 endmenu
 endif
diff --git a/drivers/amlogic/Makefile b/drivers/amlogic/Makefile
index 1933aa2b0ebb..2fd76906a107 100644
--- a/drivers/amlogic/Makefile
+++ b/drivers/amlogic/Makefile
@@ -145,3 +145,5 @@ obj-$(CONFIG_AMLOGIC_IRCUT) += ircut/
 obj-$(CONFIG_AMLOGIC_PIXEL_PROBE) += pixel_probe/
 
 obj-$(CONFIG_AMLOGIC_FIRMWARE) += firmware/
+
+obj-$(CONFIG_AMLOGIC_UVM) += uvm/
diff --git a/drivers/amlogic/uvm/Kconfig b/drivers/amlogic/uvm/Kconfig
new file mode 100644
index 000000000000..bd30bc6bae15
--- /dev/null
+++ b/drivers/amlogic/uvm/Kconfig
@@ -0,0 +1,12 @@
+#
+# uvm configuration
+#
+
+
+menuconfig AMLOGIC_UVM
+	bool "Amlogic unified video memory management"
+	default n
+	help
+	  say y to enable Amlogic unified video memory management.
+	  The uvm driver is based on the ion driver.
+
diff --git a/drivers/amlogic/uvm/Makefile b/drivers/amlogic/uvm/Makefile
new file mode 100644
index 000000000000..6c3cfbdeec8e
--- /dev/null
+++ b/drivers/amlogic/uvm/Makefile
@@ -0,0 +1,8 @@
+#
+# Makefile for amlogic uvm driver
+#
+
+ccflags-y += -Idrivers/staging/android/ -Idrivers/amlogic/
+
+obj-$(CONFIG_AMLOGIC_UVM)		+= meson_uvm_core.o
+
diff --git a/drivers/amlogic/uvm/meson_uvm_core.c b/drivers/amlogic/uvm/meson_uvm_core.c
new file mode 100644
index 000000000000..41bb08f3005d
--- /dev/null
+++ b/drivers/amlogic/uvm/meson_uvm_core.c
@@ -0,0 +1,472 @@
+/*
+ * drivers/amlogic/uvm/meson_uvm.c
+ *
+ * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#include <linux/device.h>
+#include <linux/kernel.h>
+#include <linux/platform_device.h>
+#include <linux/err.h>
+#include <linux/file.h>
+#include <linux/fs.h>
+#include <linux/miscdevice.h>
+#include <linux/rbtree.h>
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+#include <linux/vmalloc.h>
+#include <linux/debugfs.h>
+#include <linux/module.h>
+#include <linux/dma-buf.h>
+#include <linux/pagemap.h>
+#include <ion/ion.h>
+#include <ion/ion_priv.h>
+#include <linux/meson_ion.h>
+#include <linux/amlogic/meson_uvm_core.h>
+#include <drm/drm.h>
+#include <drm/drmP.h>
+#include <drm/drm_gem.h>
+#include <drm/drm_vma_manager.h>
+#include <drm/meson_gem.h>
+
+
+static int debug_level;
+module_param(debug_level, int, 0644);
+
+#define UVM_PRINTK(level, fmt, arg...) \
+	do {	\
+		if (debug_level >= level)	\
+			pr_info("UVM: " fmt, ## arg); \
+	} while (0)
+
+static void uvm_handle_destroy(struct kref *kref)
+{
+	struct uvm_handle *handle;
+
+	handle = container_of(kref, struct uvm_handle, ref);
+
+	kfree(handle->buffer);
+
+	kfree(handle);
+}
+
+static int meson_uvm_attach(struct dma_buf *dmabuf, struct device *dev,
+			    struct dma_buf_attachment *attach)
+{
+	UVM_PRINTK(1, "meson_uvm_attach called, %s.\n", current->comm);
+	return 0;
+}
+
+static void meson_uvm_detach(struct dma_buf *dmabuf,
+			     struct dma_buf_attachment *attach)
+{
+	UVM_PRINTK(1, "meson_uvm_detach called, %s.\n", current->comm);
+	/* TODO */
+}
+
+static struct sg_table *meson_uvm_map_dma_buf(
+			struct dma_buf_attachment *attachment,
+			enum dma_data_direction direction)
+{
+	struct dma_buf *dmabuf;
+	struct uvm_handle *handle;
+	struct sg_table *sgt;
+	struct drm_gem_object *obj;
+
+	dmabuf = attachment->dmabuf;
+	handle = dmabuf->priv;
+	obj = handle->priv;
+
+	sgt = am_meson_gem_prime_get_sg_table(obj);
+	if (!sgt) {
+		UVM_PRINTK(0, "get_sg_table fail from gem\n");
+		return ERR_PTR(-ENOMEM);
+	}
+
+	handle->buffer->sgt = sgt;
+	UVM_PRINTK(1, "meson_uvm_map_dma_buf called, %s.\n", current->comm);
+
+	if (!dma_map_sg(attachment->dev, sgt->sgl, sgt->nents, direction)) {
+		UVM_PRINTK(0, "meson_uvm: dma_map_sg call failed.\n");
+		sgt = ERR_PTR(-ENOMEM);
+	}
+	dma_sync_sg_for_device(NULL, sgt->sgl, sgt->nents, DMA_BIDIRECTIONAL);
+	return sgt;
+}
+
+static void meson_uvm_unmap_dma_buf(struct dma_buf_attachment *attachment,
+				    struct sg_table *sgt,
+				    enum dma_data_direction direction)
+{
+	UVM_PRINTK(1, "meson_uvm_unmap_dma_buf called, %s.\n", current->comm);
+	dma_unmap_sg(attachment->dev, sgt->sgl, sgt->nents, direction);
+}
+
+static void meson_uvm_release(struct dma_buf *dmabuf)
+{
+	struct uvm_handle *handle = dmabuf->priv;
+	struct drm_gem_object *obj = handle->priv;
+
+	UVM_PRINTK(1, "meson_uvm_release called.\n");
+
+	drm_gem_object_unreference_unlocked(obj);
+
+	dmabuf_put_private_buffer(dmabuf, 0);
+
+	kref_put(&handle->ref, uvm_handle_destroy);
+}
+
+static int meson_uvm_begin_cpu_access(struct dma_buf *dmabuf,
+				      enum dma_data_direction dir)
+{
+	UVM_PRINTK(1, "meson_uvm_begin_cpu_access called.\n");
+	return 0;
+}
+
+static int meson_uvm_end_cpu_access(struct dma_buf *dmabuf,
+				    enum dma_data_direction dir)
+{
+	UVM_PRINTK(1, "meson_uvm_end_cpu_access called.\n");
+	return 0;
+}
+
+static void *meson_uvm_kmap(struct dma_buf *dmabuf, unsigned long offset)
+{
+	UVM_PRINTK(1, "meson_uvm_kmap called.\n");
+	return NULL;
+}
+
+static void meson_uvm_kunmap(struct dma_buf *dmabuf,
+			     unsigned long offset, void *ptr)
+{
+	UVM_PRINTK(1, "meson_uvm_kunmap called.\n");
+	/* TODO */
+}
+
+static void *meson_uvm_kmap_atomic(struct dma_buf *dmabuf,
+				   unsigned long offset)
+{
+	UVM_PRINTK(1, "meson_uvm_kmap_atomic called.\n");
+	return NULL;
+}
+
+static void meson_uvm_kunmap_atomic(struct dma_buf *dmabuf,
+				    unsigned long offset, void *ptr)
+{
+	UVM_PRINTK(1, "meson_uvm_kunmap_atomic called.\n");
+	/* TODO */
+}
+
+static void *meson_uvm_vmap(struct dma_buf *dmabuf)
+{
+	struct uvm_handle *handle;
+	struct drm_gem_object *obj;
+	struct sg_table *sgt;
+	struct scatterlist *sg;
+	struct page **pages;
+	struct page **tmp;
+	int npages, i, j;
+	pgprot_t pgprot;
+	void *vaddr;
+
+	handle = dmabuf->priv;
+	obj = handle->priv;
+	sgt = handle->buffer->sgt;
+	npages = PAGE_ALIGN(obj->size) / PAGE_SIZE;
+	pgprot = pgprot_writecombine(PAGE_KERNEL);
+
+	pages = vmalloc(sizeof(struct page *) * npages);
+	if (!pages)
+		return NULL;
+
+	tmp = pages;
+	for_each_sg(sgt->sgl, sg, sgt->nents, i) {
+		int npages_this_entry = PAGE_ALIGN(sg->length) / PAGE_SIZE;
+		struct page *page = sg_page(sg);
+
+		WARN_ON(i >= npages);
+		for (j = 0; j < npages_this_entry; j++)
+			*(tmp++) = page++;
+	}
+	vaddr = vmap(pages, npages, VM_MAP, pgprot);
+	vfree(pages);
+
+	if (vaddr == NULL)
+		return ERR_PTR(-ENOMEM);
+
+	handle->buffer->vaddr = vaddr;
+	UVM_PRINTK(1, "meson_uvm_vmap called.\n");
+	return vaddr;
+}
+
+static void meson_uvm_vunmap(struct dma_buf *dmabuf, void *vaddr)
+{
+	struct uvm_handle *handle = dmabuf->priv;
+	UVM_PRINTK(1, "meson_uvm_vunmap called.\n");
+	vunmap(handle->buffer->vaddr);
+}
+
+static int meson_uvm_mmap(struct dma_buf *dmabuf, struct vm_area_struct *vma)
+{
+	int i;
+	int ret;
+
+	struct uvm_handle *handle = dmabuf->priv;
+	struct sg_table *table = handle->buffer->sgt;
+	unsigned long addr = vma->vm_start;
+	unsigned long offset = vma->vm_pgoff * PAGE_SIZE;
+	struct scatterlist *sg;
+
+	UVM_PRINTK(1, "meson_uvm_mmap called.\n");
+
+	if (!table) {
+		UVM_PRINTK(0, "buffer was not allocated.\n");
+		return -EINVAL;
+	}
+
+	for_each_sg(table->sgl, sg, table->nents, i) {
+		struct page *page = sg_page(sg);
+		unsigned long remainder = vma->vm_end - addr;
+		unsigned long len = sg->length;
+
+		if (offset >= sg->length) {
+			offset -= sg->length;
+			continue;
+		} else if (offset) {
+			page += offset / PAGE_SIZE;
+			len = sg->length - offset;
+			offset = 0;
+		}
+		len = min(len, remainder);
+		ret = remap_pfn_range(vma, addr, page_to_pfn(page), len,
+				      vma->vm_page_prot);
+		if (ret)
+			return ret;
+		addr += len;
+		if (addr >= vma->vm_end)
+			return 0;
+	}
+
+	return 0;
+}
+
+static struct dma_buf_ops meson_uvm_dma_ops = {
+	.attach = meson_uvm_attach,
+	.detach = meson_uvm_detach,
+	.map_dma_buf = meson_uvm_map_dma_buf,
+	.unmap_dma_buf = meson_uvm_unmap_dma_buf,
+	.release = meson_uvm_release,
+	.begin_cpu_access = meson_uvm_begin_cpu_access,
+	.end_cpu_access = meson_uvm_end_cpu_access,
+	.kmap = meson_uvm_kmap,
+	.kmap_atomic = meson_uvm_kmap_atomic,
+	.kunmap = meson_uvm_kunmap,
+	.kunmap_atomic = meson_uvm_kunmap_atomic,
+	.vmap = meson_uvm_vmap,
+	.vunmap = meson_uvm_vunmap,
+	.mmap = meson_uvm_mmap,
+};
+
+static struct uvm_buffer *uvm_buffer_alloc(struct uvm_handle *handle)
+{
+	struct uvm_buffer *buffer;
+
+	buffer = kzalloc(sizeof(*buffer), GFP_KERNEL);
+	if (!buffer)
+		return ERR_PTR(-ENOMEM);
+
+	return buffer;
+}
+
+static struct uvm_handle *uvm_handle_alloc(size_t len, size_t align,
+					   ulong flags)
+{
+	struct uvm_handle *handle;
+	struct uvm_buffer *buffer;
+
+	handle = kzalloc(sizeof(*handle), GFP_KERNEL);
+	if (!handle)
+		return ERR_PTR(-ENOMEM);
+
+	kref_init(&handle->ref);
+	mutex_init(&handle->lock);
+	handle->size = len;
+	handle->align = align;
+	handle->flags = flags;
+
+	if (!(flags & UVM_DELAY_ALLOC)) {
+		buffer = uvm_buffer_alloc(handle);
+
+		if (!buffer) {
+			kfree(handle);
+			return ERR_PTR(-ENOMEM);
+		}
+		handle->buffer = buffer;
+	}
+
+	return handle;
+}
+
+static struct dma_buf *uvm_dmabuf_export(struct uvm_handle *handle)
+{
+	struct dma_buf *dmabuf;
+
+	struct dma_buf_export_info exp_info = {
+		.exp_name = KBUILD_MODNAME,
+		.owner = THIS_MODULE,
+		.ops = &meson_uvm_dma_ops,
+		.size = handle->size,
+		.flags = handle->flags,
+		.priv = handle,
+	};
+
+	dmabuf = dma_buf_export(&exp_info);
+	if (IS_ERR(dmabuf)) {
+		UVM_PRINTK(0, "uvm_dmabuf_export fail.\n");
+		return ERR_PTR(-ENOMEM);
+	}
+
+	handle->dmabuf = dmabuf;
+
+	return dmabuf;
+}
+
+struct dma_buf *uvm_alloc_dmabuf(size_t len, size_t align, ulong flags)
+{
+	struct uvm_handle *handle;
+	struct dma_buf *dmabuf;
+
+	handle = uvm_handle_alloc(len, align, flags);
+	if (IS_ERR(handle))
+		return ERR_PTR(-ENOMEM);
+
+	dmabuf = uvm_dmabuf_export(handle);
+	if (IS_ERR(dmabuf)) {
+		kfree(handle);
+		return ERR_PTR(-EINVAL);
+	}
+
+	return dmabuf;
+}
+EXPORT_SYMBOL(uvm_alloc_dmabuf);
+
+bool dmabuf_is_uvm(struct dma_buf *dmabuf)
+{
+	return dmabuf->ops == &meson_uvm_dma_ops;
+}
+EXPORT_SYMBOL(dmabuf_is_uvm);
+
+int dmabuf_set_vframe(struct dma_buf *dmabuf, struct vframe_s *vf)
+{
+	struct uvm_handle *handle;
+
+	handle = dmabuf->priv;
+	memcpy(&handle->vf, vf, sizeof(struct vframe_s));
+	handle->vfp = vf;
+
+	return 0;
+}
+EXPORT_SYMBOL(dmabuf_set_vframe);
+
+struct vframe_s *dmabuf_get_vframe(struct dma_buf *dmabuf)
+{
+	struct uvm_handle *handle;
+
+	handle = dmabuf->priv;
+	kref_get(&handle->ref);
+
+	return &handle->vf;
+}
+EXPORT_SYMBOL(dmabuf_get_vframe);
+
+int dmabuf_put_vframe(struct dma_buf *dmabuf)
+{
+	struct uvm_handle *handle;
+
+	handle = dmabuf->priv;
+	return kref_put(&handle->ref, uvm_handle_destroy);
+}
+EXPORT_SYMBOL(dmabuf_put_vframe);
+
+int dmabuf_set_private_buffer(struct dma_buf *dmabuf, int buffer_type,
+			      struct uvm_buffer_info *info)
+{
+	struct uvm_handle *handle;
+	struct uvm_private_buffer *upb;
+
+	handle = dmabuf->priv;
+	upb = kzalloc(sizeof(*upb), GFP_KERNEL);
+	if (!upb) {
+		UVM_PRINTK(0, "kzalloc uvm_private_buffer fail.\n");
+		return -ENOMEM;
+	}
+
+	kref_init(&upb->ref);
+	upb->size = info->size;
+	upb->arg = info->arg;
+	upb->free = info->free;
+
+	handle->buffs[buffer_type] = upb;
+
+	return 0;
+}
+EXPORT_SYMBOL(dmabuf_set_private_buffer);
+
+struct uvm_private_buffer *dmabuf_get_private_buffer(struct dma_buf *dmabuf,
+						     int buffer_type)
+{
+	struct uvm_handle *handle;
+	struct uvm_private_buffer *upb;
+
+	handle = dmabuf->priv;
+	upb = handle->buffs[buffer_type];
+
+	if (!upb) {
+		UVM_PRINTK(0, "dmabuf_get_private_buffer fail.\n");
+		return ERR_PTR(-EINVAL);
+	}
+
+	kref_get(&upb->ref);
+
+	return upb;
+}
+EXPORT_SYMBOL(dmabuf_get_private_buffer);
+
+static void uvm_private_buffer_release(struct kref *kref)
+{
+	struct uvm_private_buffer *upb;
+
+	upb = container_of(kref, struct uvm_private_buffer, ref);
+	UVM_PRINTK(1, "uvm_private_buffer_release.\n");
+	upb->free(upb->arg);
+
+	kfree(upb);
+}
+
+int dmabuf_put_private_buffer(struct dma_buf *dmabuf, int buffer_type)
+{
+	struct uvm_handle *handle;
+	struct uvm_private_buffer *upb;
+
+	handle = dmabuf->priv;
+	upb = handle->buffs[buffer_type];
+
+	if (!upb) {
+		UVM_PRINTK(1, "dmabuf_put_private_buffer fail.\n");
+		return -EINVAL;
+	}
+
+	return kref_put(&upb->ref, uvm_private_buffer_release);
+}
+EXPORT_SYMBOL(dmabuf_put_private_buffer);
diff --git a/include/linux/amlogic/meson_uvm_core.h b/include/linux/amlogic/meson_uvm_core.h
new file mode 100644
index 000000000000..81c25df9be4c
--- /dev/null
+++ b/include/linux/amlogic/meson_uvm_core.h
@@ -0,0 +1,117 @@
+/*
+ * drivers/amlogic/uvm/meson_uvm.h
+ *
+ * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#ifndef __MESON_UVM_H
+#define __MESON_UVM_H
+
+#include <linux/device.h>
+#include <linux/dma-direction.h>
+#include <linux/miscdevice.h>
+#include <linux/kref.h>
+#include <linux/mm_types.h>
+#include <linux/mutex.h>
+#include <linux/rbtree.h>
+#include <linux/sched.h>
+#include <linux/ioctl.h>
+#include <linux/types.h>
+
+#include <linux/amlogic/media/vfm/vframe.h>
+
+#define MAX_BUFF_NUMS	4
+
+enum UVM_ALLOC_FLAG {
+	UVM_IMM_ALLOC,
+	UVM_DELAY_ALLOC,
+};
+
+/**
+ * struct uvm_handle - metadata for the vframe based buffer
+ * @ref:	reference count
+ * @lock:	protects the uvm_handle fields
+ * @uvm_buffer:	the buffer info
+ */
+struct uvm_handle {
+	struct kref ref;
+	struct mutex lock;
+
+	struct uvm_buffer *buffer;
+	struct dma_buf *dmabuf;
+	bool alloc;
+	size_t size;
+	size_t align;
+	unsigned long flags;
+
+	struct vframe_s vf;
+	struct vframe_s *vfp;
+	atomic_t umap_count;
+	atomic_t kmap_count;
+
+	struct uvm_private_buffer *buffs[MAX_BUFF_NUMS];
+	u8 num_buffers;
+
+	void *priv;
+};
+
+struct uvm_buffer {
+	int alloc_type;
+	struct ion_client *client;
+	struct ion_handle *handle;
+
+	struct sg_table *sgt;
+	struct page **pages;
+	void *vaddr;
+	phys_addr_t paddr;
+};
+
+struct uvm_private_buffer {
+	struct kref ref;
+	int buffer_type;
+
+	size_t size;
+	size_t align;
+	unsigned long flags;
+	bool alloc;
+
+	void *arg;
+	void (*free)(void *arg);
+};
+
+struct uvm_buffer_info {
+	size_t size;
+	void *arg;
+	void (*free)(void *arg);
+};
+
+struct dma_buf *uvm_alloc_dmabuf(size_t len, size_t align, ulong flags);
+
+bool dmabuf_is_uvm(struct dma_buf *dmabuf);
+
+int dmabuf_set_vframe(struct dma_buf *dmabuf, struct vframe_s *vf);
+
+struct vframe_s *dmabuf_get_vframe(struct dma_buf *dmabuf);
+
+int dmabuf_put_vframe(struct dma_buf *dmabuf);
+
+int dmabuf_set_private_buffer(struct dma_buf *dmabuf, int buffer_type,
+			      struct uvm_buffer_info *info);
+
+struct uvm_private_buffer *dmabuf_get_private_buffer(struct dma_buf *dmabuf,
+						     int buffer_type);
+
+int dmabuf_put_private_buffer(struct dma_buf *dmabuf, int buffer_type);
+
+#endif
-- 
2.24.1

