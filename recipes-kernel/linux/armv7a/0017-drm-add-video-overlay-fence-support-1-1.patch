From db2a958a70b3afd0159d04a4e6efbf9c69976293 Mon Sep 17 00:00:00 2001
From: Dezhi Kong <dezhi.kong@amlogic.com>
Date: Fri, 27 Mar 2020 18:20:55 +0800
Subject: [PATCH 3/4] drm: add video overlay fence support [1/1]

PD#SWPL-20427

Problem:
the video layer latency time is two vsync default.
which is delay one vsync than osd layer.
so video plane couldn't use the same out fence with osd plane

Solution:
add seperated fence for video plane

Verify:
verify by u212

Change-Id: Ia56575e2547eba75479c440fb0efe2a23edee9bf
Signed-off-by: Dezhi Kong <dezhi.kong@amlogic.com>
---
 drivers/amlogic/drm/meson_crtc.c  | 101 +++++++++++++++++++++++++++++-
 drivers/amlogic/drm/meson_crtc.h  |  17 +++++
 drivers/amlogic/drm/meson_plane.c |  15 +++--
 drivers/amlogic/drm/meson_vpu.c   |  13 +++-
 drivers/amlogic/drm/meson_vpu.h   |   2 +
 5 files changed, 140 insertions(+), 8 deletions(-)

diff --git a/drivers/amlogic/drm/meson_crtc.c b/drivers/amlogic/drm/meson_crtc.c
index b06cda7b8493..d73590b8ad52 100644
--- a/drivers/amlogic/drm/meson_crtc.c
+++ b/drivers/amlogic/drm/meson_crtc.c
@@ -65,6 +65,7 @@ static int meson_crtc_atomic_get_property(struct drm_crtc *crtc,
 {
 	struct am_meson_crtc *amcrtc;
 	struct am_meson_crtc_state *meson_crtc_state;
+	int ret = -EINVAL;
 
 	amcrtc = to_am_meson_crtc(crtc);
 	meson_crtc_state = to_am_meson_crtc_state(state);
@@ -73,14 +74,19 @@ static int meson_crtc_atomic_get_property(struct drm_crtc *crtc,
 		meson_crtc_state->hdr_policy = get_hdr_policy();
 		#endif
 		*val = meson_crtc_state->hdr_policy;
+		ret = 0;
 	} else if (property == amcrtc->prop_dv_policy) {
 		#ifdef CONFIG_AMLOGIC_MEDIA_ENHANCEMENT_DOLBYVISION
 		meson_crtc_state->dv_policy = get_dolby_vision_policy();
 		#endif
 		*val = meson_crtc_state->dv_policy;
+		ret = 0;
+	} else if (property == amcrtc->prop_video_out_fence_ptr) {
+		*val = 0;
+		ret = 0;
 	} else
 		DRM_INFO("unsupported crtc property\n");
-	return 0;
+	return ret;
 }
 
 static int meson_crtc_atomic_set_property(struct drm_crtc *crtc,
@@ -90,6 +96,8 @@ static int meson_crtc_atomic_set_property(struct drm_crtc *crtc,
 {
 	struct am_meson_crtc *amcrtc;
 	struct am_meson_crtc_state *meson_crtc_state;
+	s32 __user *fence_ptr;
+	int ret = -EINVAL;
 
 	amcrtc = to_am_meson_crtc(crtc);
 	meson_crtc_state = to_am_meson_crtc_state(state);
@@ -98,14 +106,25 @@ static int meson_crtc_atomic_set_property(struct drm_crtc *crtc,
 		#ifdef CONFIG_AMLOGIC_MEDIA_ENHANCEMENT_VECM
 		set_hdr_policy(val);
 		#endif
+		ret = 0;
 	} else if (property == amcrtc->prop_dv_policy) {
 		meson_crtc_state->dv_policy = val;
 		#ifdef CONFIG_AMLOGIC_MEDIA_ENHANCEMENT_DOLBYVISION
 		set_dolby_vision_policy(val);
 		#endif
+		ret = 0;
+	} else if (property == amcrtc->prop_video_out_fence_ptr) {
+		fence_ptr = u64_to_user_ptr(val);
+		if (!fence_ptr)
+			return -EFAULT;
+		if (put_user(-1, fence_ptr))
+			return -EFAULT;
+		ret = 0;
+		meson_crtc_state->fence_state.video_out_fence_ptr = fence_ptr;
+		DRM_DEBUG("set video out fence ptr done\n");
 	} else
 		DRM_INFO("unsupported crtc property\n");
-	return 0;
+	return ret;
 }
 
 static const struct drm_crtc_funcs am_meson_crtc_funcs = {
@@ -211,13 +230,72 @@ static int am_meson_atomic_check(struct drm_crtc *crtc,
 
 }
 
+static int am_meson_video_fence_setup(struct video_out_fence_state *fence_state,
+				      struct fence *fence)
+{
+	fence_state->fd = get_unused_fd_flags(O_CLOEXEC);
+	if (fence_state->fd < 0)
+		return fence_state->fd;
+
+	if (put_user(fence_state->fd, fence_state->video_out_fence_ptr))
+		return -EFAULT;
+
+	fence_state->sync_file = sync_file_create(fence);
+	if (!fence_state->sync_file)
+		return -ENOMEM;
+
+	return 0;
+}
+
+static int am_meson_video_fence_create(struct drm_crtc *crtc)
+{
+	struct am_meson_crtc *amcrtc;
+	struct am_meson_crtc_state *meson_crtc_state;
+	struct fence *fence;
+	struct video_out_fence_state *fence_state;
+	int ret, i;
+
+	amcrtc = to_am_meson_crtc(crtc);
+	meson_crtc_state = to_am_meson_crtc_state(crtc->state);
+	fence_state = &meson_crtc_state->fence_state;
+	fence = drm_crtc_create_fence(crtc);
+	if (!fence)
+		return -ENOMEM;
+	/*setup out fence*/
+	ret = am_meson_video_fence_setup(fence_state, fence);
+	if (ret) {
+		fence_put(fence);
+		return ret;
+	}
+	fd_install(fence_state->fd, fence_state->sync_file->file);
+	for (i = 0; i < VIDEO_LATENCY_VSYNC; i++) {
+		if (amcrtc->video_fence[i].fence)
+			continue;
+		amcrtc->video_fence[i].fence = fence;
+		atomic_set(&amcrtc->video_fence[i].refcount,
+			   VIDEO_LATENCY_VSYNC);
+		DRM_DEBUG("video fence create done index:%d\n", i);
+		break;
+	}
+	return 0;
+}
+
 static void am_meson_crtc_atomic_begin(struct drm_crtc *crtc,
 			     struct drm_crtc_state *old_crtc_state)
 {
 	struct am_meson_crtc *amcrtc;
+	struct am_meson_crtc_state *meson_crtc_state;
 	unsigned long flags;
+	int ret = 0;
 
 	amcrtc = to_am_meson_crtc(crtc);
+	meson_crtc_state = to_am_meson_crtc_state(crtc->state);
+	if (meson_crtc_state->fence_state.video_out_fence_ptr) {
+		ret = am_meson_video_fence_create(crtc);
+		meson_crtc_state->fence_state.video_out_fence_ptr = NULL;
+	}
+	if (ret)
+		DRM_INFO("video fence create fail\n");
 
 	if (crtc->state->event) {
 		WARN_ON(drm_crtc_vblank_get(crtc) != 0);
@@ -357,6 +435,24 @@ int drm_plane_create_dv_policy_property(struct drm_crtc *crtc)
 	return 0;
 }
 
+int am_meson_crtc_create_video_out_fence_property(struct drm_crtc *crtc)
+{
+	struct drm_device *dev = crtc->dev;
+	struct drm_property *prop;
+	struct am_meson_crtc *amcrtc;
+
+	amcrtc = to_am_meson_crtc(crtc);
+	prop = drm_property_create_range(dev, DRM_MODE_PROP_ATOMIC,
+					 "VIDEO_OUT_FENCE_PTR", 0, U64_MAX);
+	if (!prop)
+		return -ENOMEM;
+
+	drm_object_attach_property(&crtc->base, prop, 0);
+	amcrtc->prop_video_out_fence_ptr = prop;
+
+	return 0;
+}
+
 int am_meson_crtc_create(struct am_meson_crtc *amcrtc)
 {
 	struct meson_drm *priv = amcrtc->priv;
@@ -378,6 +474,7 @@ int am_meson_crtc_create(struct am_meson_crtc *amcrtc)
 
 	drm_plane_create_hdr_policy_property(crtc);
 	drm_plane_create_dv_policy_property(crtc);
+	am_meson_crtc_create_video_out_fence_property(crtc);
 	drm_crtc_helper_add(crtc, &am_crtc_helper_funcs);
 	osd_drm_init(&osd_meson_dev);
 
diff --git a/drivers/amlogic/drm/meson_crtc.h b/drivers/amlogic/drm/meson_crtc.h
index d58ea2a0f177..c0431183975f 100644
--- a/drivers/amlogic/drm/meson_crtc.h
+++ b/drivers/amlogic/drm/meson_crtc.h
@@ -23,6 +23,7 @@
 #include <drm/drm_plane.h>
 #include <drm/drm_atomic.h>
 #include <drm/drm_atomic_helper.h>
+#include <linux/sync_file.h>
 #include <linux/amlogic/media/vout/vout_notify.h>
 #ifdef CONFIG_AMLOGIC_MEDIA_ENHANCEMENT
 #include <linux/amlogic/media/amvecm/amvecm.h>
@@ -33,12 +34,25 @@
 #include "meson_drv.h"
 #include "meson_fb.h"
 
+struct video_out_fence_state {
+	s32 __user *video_out_fence_ptr;
+	struct sync_file *sync_file;
+	int fd;
+};
+
 struct am_meson_crtc_state {
 	struct drm_crtc_state base;
 	u32 hdr_policy;
 	u32 dv_policy;
+	struct video_out_fence_state fence_state;
 };
 
+struct am_meson_video_out_fence {
+	struct fence *fence;
+	atomic_t refcount;
+};
+
+
 struct am_meson_crtc {
 	struct drm_crtc base;
 	struct device *dev;
@@ -47,6 +61,7 @@ struct am_meson_crtc {
 	struct meson_drm *priv;
 
 	struct drm_pending_vblank_event *event;
+	struct am_meson_video_out_fence video_fence[VIDEO_LATENCY_VSYNC];
 
 	unsigned int vblank_irq;
 	spinlock_t vblank_irq_lock;/*atomic*/
@@ -58,6 +73,7 @@ struct am_meson_crtc {
 	struct drm_property *prop_hdr_policy;
 	struct drm_property *prop_dv_policy;
 
+	struct drm_property *prop_video_out_fence_ptr;
 	int dump_enable;
 	int blank_enable;
 	int dump_counts;
@@ -79,4 +95,5 @@ extern int get_dolby_vision_policy(void);
 extern void set_hdr_policy(int policy);
 extern int get_hdr_policy(void);
 #endif
+struct fence *drm_crtc_create_fence(struct drm_crtc *crtc);
 #endif
diff --git a/drivers/amlogic/drm/meson_plane.c b/drivers/amlogic/drm/meson_plane.c
index ba4fff5007d7..ae77f3a7a671 100644
--- a/drivers/amlogic/drm/meson_plane.c
+++ b/drivers/amlogic/drm/meson_plane.c
@@ -474,12 +474,15 @@ static int meson_plane_atomic_get_property(struct drm_plane *plane,
 {
 	struct am_osd_plane *osd_plane;
 	struct am_meson_plane_state *plane_state;
+	int ret = -EINVAL;
 
 	osd_plane = to_am_osd_plane(plane);
 	plane_state = to_am_meson_plane_state(state);
-	if (property == osd_plane->prop_premult_en)
+	if (property == osd_plane->prop_premult_en) {
 		*val = plane_state->premult_en;
-	return 0;
+		ret = 0;
+	}
+	return ret;
 }
 
 static int meson_plane_atomic_set_property(struct drm_plane *plane,
@@ -489,13 +492,15 @@ static int meson_plane_atomic_set_property(struct drm_plane *plane,
 {
 	struct am_osd_plane *osd_plane;
 	struct am_meson_plane_state *plane_state;
+	int ret = -EINVAL;
 
 	osd_plane = to_am_osd_plane(plane);
 	plane_state = to_am_meson_plane_state(state);
-	if (property == osd_plane->prop_premult_en)
+	if (property == osd_plane->prop_premult_en) {
 		plane_state->premult_en = val;
-
-	return 0;
+		ret = 0;
+	}
+	return ret;
 }
 
 static struct drm_plane_state *
diff --git a/drivers/amlogic/drm/meson_vpu.c b/drivers/amlogic/drm/meson_vpu.c
index 2312d64bd909..c7145281e5fd 100644
--- a/drivers/amlogic/drm/meson_vpu.c
+++ b/drivers/amlogic/drm/meson_vpu.c
@@ -330,10 +330,21 @@ void am_meson_crtc_handle_vsync(struct am_meson_crtc *amcrtc)
 {
 	unsigned long flags;
 	struct drm_crtc *crtc;
+	int i;
 
 	crtc = &amcrtc->base;
 	drm_crtc_handle_vblank(crtc);
-
+	for (i = 0; i < VIDEO_LATENCY_VSYNC; i++) {
+		if (!amcrtc->video_fence[i].fence)
+			continue;
+		atomic_dec(&amcrtc->video_fence[i].refcount);
+		if (!atomic_read(&amcrtc->video_fence[i].refcount)) {
+			fence_signal(amcrtc->video_fence[i].fence);
+			fence_put(amcrtc->video_fence[i].fence);
+			amcrtc->video_fence[i].fence = NULL;
+			DRM_DEBUG("video fence signal done index:%d\n", i);
+		}
+	}
 	spin_lock_irqsave(&crtc->dev->event_lock, flags);
 	if (amcrtc->event) {
 		drm_crtc_send_vblank_event(crtc, amcrtc->event);
diff --git a/drivers/amlogic/drm/meson_vpu.h b/drivers/amlogic/drm/meson_vpu.h
index fe1e71b71cee..07406d78bed8 100644
--- a/drivers/amlogic/drm/meson_vpu.h
+++ b/drivers/amlogic/drm/meson_vpu.h
@@ -20,6 +20,8 @@
 
 #include <linux/amlogic/media/vout/vout_notify.h>
 
+#define VIDEO_LATENCY_VSYNC 2
+
 struct am_meson_vpu_data {
 	u32 version;
 };
-- 
2.24.1

