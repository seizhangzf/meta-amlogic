From fc502a664a885f69bb29b1aea4a05ce897481acb Mon Sep 17 00:00:00 2001
From: Yong Qin <yong.qin@amlogic.com>
Date: Thu, 2 Jan 2020 16:40:55 +0800
Subject: [PATCH 4/7] vdin: for support DV 5 metadata pkt [1/1]

PD#SWPL-19257

Problem:
not support DV multi metadata pkt mode.

Solution:
add feature for support DV 5 metadata pkt

Verify:
tm2

Change-Id: I9da885dffec9a3863a028c48fb02eaabcdae75da
Signed-off-by: Yong Qin <yong.qin@amlogic.com>
---
 .../amlogic/media/vin/tvin/vdin/vdin_ctl.c    | 245 ++++++++++++------
 .../amlogic/media/vin/tvin/vdin/vdin_ctl.h    |  21 ++
 .../amlogic/media/vin/tvin/vdin/vdin_debug.c  |  11 +
 .../amlogic/media/vin/tvin/vdin/vdin_drv.h    |   1 +
 4 files changed, 203 insertions(+), 75 deletions(-)

diff --git a/drivers/amlogic/media/vin/tvin/vdin/vdin_ctl.c b/drivers/amlogic/media/vin/tvin/vdin/vdin_ctl.c
index c1a5d16f6d0b..5cec6321a298 100644
--- a/drivers/amlogic/media/vin/tvin/vdin/vdin_ctl.c
+++ b/drivers/amlogic/media/vin/tvin/vdin/vdin_ctl.c
@@ -47,11 +47,6 @@
  */
 #define VDIN_WR_BURST_MODE 2
 
-#define DV_META_PACKET_SIZE			128
-#define DV_META_HEADER_LEN	  2
-#define DV_META_TAIL_CRC_SIZE		4
-#define DV_META_PACKET_TYPE_SIZE		3
-
 static bool cm_enable = 1;
 module_param(cm_enable, bool, 0644);
 MODULE_PARM_DESC(cm_enable, "cm_enable");
@@ -3021,9 +3016,10 @@ void vdin_set_default_regmap(unsigned int offset)
 				AFBCE_OUT_SEL_BIT, VDIN_REORDER_SEL_WID);
 			wr_bits(0, VDIN_TOP_DOUBLE_CTRL, WR_SEL_VDIN0_NOR,
 				MIF0_OUT_SEL_BIT, VDIN_REORDER_SEL_WID);
+
+			/*set vdin0 out to mif0 normal end*/
+			wr(offset, VDIN_HDR2_MATRIXI_EN_CTRL, 0);
 		}
-		/*set vdin0 out to mif0 normal end*/
-		wr(offset, VDIN_HDR2_MATRIXI_EN_CTRL, 0);
 	} else
 		wr(offset, VDIN_LFIFO_CTRL,     0x00000780);
 	/* [15:14]     clkgate.bbar             = 0/(auto, off, on, on) */
@@ -4103,6 +4099,13 @@ void vdin_dolby_addr_alloc(struct vdin_dev_s *devp, unsigned int size)
 	devp->dv.dv_mem_alloced = 1;
 	pr_info("%s:dv_dma_vaddr=0x%p,dv_dma_paddr=0x%lx\n", __func__,
 		devp->dv.dv_dma_vaddr, (ulong)devp->dv.dv_dma_paddr);
+
+	devp->dv.temp_meta_data = kmalloc(2048, GFP_KERNEL);
+	if (IS_ERR_OR_NULL(devp->dv.temp_meta_data)) {
+		pr_info("malloc dv temp buffer fail\n");
+		devp->dv.temp_meta_data = NULL;
+	} else
+		pr_info("malloc dv temp 2k buffer\n");
 }
 void vdin_dolby_addr_release(struct vdin_dev_s *devp, unsigned int size)
 {
@@ -4134,6 +4137,12 @@ void vdin_dolby_addr_release(struct vdin_dev_s *devp, unsigned int size)
 		}
 	}
 	devp->dv.dv_mem_alloced = 0;
+
+	if (!IS_ERR_OR_NULL(devp->dv.temp_meta_data)) {
+		kfree(devp->dv.temp_meta_data);
+		devp->dv.temp_meta_data = NULL;
+		pr_info("release dv temp buffer\n");
+	}
 }
 
 static void vdin_dolby_metadata_swap(struct vdin_dev_s *devp, char *buf)
@@ -4217,99 +4226,180 @@ static uint32_t crc32(uint32_t crc, const void *buf, size_t size)
 	return crc;
 }
 
+void vdin_dolby_pr_meta_data(void *addr, unsigned int size)
+{
+	unsigned int i;
+	char *c = addr;
+
+	for (i = 0; i < size; i += 16) {
+		pr_info("\t%02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n",
+			c[i], c[i + 1], c[i + 2], c[i + 3],
+			c[i + 4], c[i + 5], c[i + 6], c[i + 7],
+			c[i + 8], c[i + 9], c[i + 10], c[i + 11],
+			c[i + 12], c[i + 13], c[i + 14], c[i + 15]);
+	}
+}
+
 void vdin_dolby_buffer_update(struct vdin_dev_s *devp, unsigned int index)
 {
-	uint32_t *p;
+	u32 *p;
 	char *c;
+	char *cp;
 	uint32_t meta32, meta_size;
-	int i;
+	int i, j;
 	int count;
 	unsigned int offset = devp->addr_offset;
-	uint32_t crc_result, crc;
+	u32 crc_r = 0, crc = 1;
 	bool multimeta_flag = 0;
 	bool multimetatail_flag = 0;
-	uint32_t crc_result1 = 0;
-	uint32_t crc1 = 0;
-	int j, k;
-	char  tmpmeta[1024];
-	uint32_t extmetasize;
-	uint32_t metapayloadsize;
-
-	metapayloadsize = DV_META_PACKET_SIZE -
-		DV_META_PACKET_TYPE_SIZE -
-		DV_META_HEADER_LEN -
-		DV_META_TAIL_CRC_SIZE;
+	u32 crc1_r = 0;
+	u32 crc1 = 0;
+	u32 max_pkt = 15;
+	static u32 cnt;
+	u32 rpt_cnt = 0, tail_cnt = 0, rev_cnt = 0;
+	u8 pkt_type;
+	struct dv_meta_pkt *pkt_p;
+	u32 cp_size, cp_offset, cp_sum = 0;
+
 	if (index >= devp->canvas_max_num)
 		return;
 
-	c = devp->vfp->dv_buf_ori[index];
+	cp = devp->dv.temp_meta_data;
+	/*c = devp->vfp->dv_buf_ori[index];*/
+	c = devp->vfp->dv_buf_vmem[index];
 	p = (uint32_t *)c;
 	for (count = 0; count < META_RETRY_MAX; count++) {
 		if (dv_dbg_mask & DV_READ_MODE_AXI) {
-			memcpy(p, devp->vfp->dv_buf_vmem[index], 128);
-			vdin_dma_flush(devp, p, 128, DMA_TO_DEVICE);
+			memcpy(p, devp->vfp->dv_buf_vmem[index], 128 * max_pkt);
+			vdin_dma_flush(devp, p, 128 * max_pkt, DMA_TO_DEVICE);
 			vdin_dolby_metadata_swap(devp, c);
+			/*vdin_dma_flush(devp, p, 128*max_pkt, DMA_TO_DEVICE);*/
 		} else {
-			wr(offset, VDIN_DOLBY_DSC_CTRL3, 0);
-			wr(offset, VDIN_DOLBY_DSC_CTRL2, 0xd180c0d5);
-			for (i = 0; i < 128; i++) {
+			if (cpu_after_eq(MESON_CPU_MAJOR_ID_TM2))
+				wr(offset, VDIN_DOLBY_DSC_CTRL2, 0xe800c0d5);
+			else
+				wr(offset, VDIN_DOLBY_DSC_CTRL2, 0xd180c0d5);
+			rpt_cnt = 0;
+			tail_cnt = 0;
+			rev_cnt = 0;
+			for (i = 0; i < (32 * max_pkt); i++) {
 				meta32 = rd(offset, VDIN_DOLBY_DSC_STATUS1);
 				p[i] = swap32(meta32);
-			if (((c[0] & (1 << 7)) == 0) &&
-				((c[0] & (1 << 6)) != 0))
-				multimeta_flag = 1;
-			if ((i == 31) && (multimeta_flag == 0))
-				break;
+				if ((i % 32) == 0) {
+					rev_cnt++;
+					pkt_type = c[i * 4] & 0xc0;
+					if (pkt_type == META_PKY_TYPE_START)
+						multimeta_flag = 1;
+
+					if (pkt_type == META_PKY_TYPE_START)
+						rpt_cnt++;
+
+					if (pkt_type == META_PKY_TYPE_TAIL) {
+						multimetatail_flag = 1;
+						tail_cnt++;
+						//if (tail_cnt > rpt_cnt)
+						//	break;
+					}
+				}
+
+				if ((i == 31) && (multimeta_flag == 0))
+					break;
 			}
-			vdin_dma_flush(devp, p, 128, DMA_TO_DEVICE);
 		}
 
 		meta_size = (c[3] << 8) | c[4];
-		crc = p[31];
-		crc_result = crc32(0, p, 124);
-		crc_result = swap32(crc_result);
-		for (j = 128; j < 128 * 4; j += 128) {
-			if ((meta_size > metapayloadsize) &&
-				((c[j] & (1 << 7)) != 0) &&
-				((c[j] & (1 << 6)) != 0))
-				multimetatail_flag = 1;
+		if ((meta_size > 1024) || (rev_cnt > 20) ||
+		    (rpt_cnt != tail_cnt) ||
+		    ((meta_size > 128) && (rev_cnt == 1))) {
+			if (((cnt % 60) == 0) && (dv_dbg_log & (1 << 0)))
+				pr_info("err size:%d rp_cnt:%d, tal_cnt:%d, rv_cnt:%d\n",
+					meta_size, rpt_cnt, tail_cnt, rev_cnt);
+
+			devp->dv.dv_crc_check = false;
+			return;
 		}
-		if (dv_dbg_log&(1<<0))
-			pr_info("multimeta_flag=%d multimetatail_flag=%d\n",
-			multimeta_flag, multimetatail_flag);
-		if ((multimeta_flag == 1) && (multimetatail_flag == 1)) {
-			crc1 = p[127];
-			crc_result1 = crc32(0,  p + 32 * 3, 124);
-			crc_result1 = swap32(crc_result1);
+		crc = p[31];/*first pkt chk sum*/
+		crc_r = crc32(0, p, 124);
+		crc_r = swap32(crc_r);
+		if ((meta_size > DV_META_SINGLE_PKT_SIZE) || multimeta_flag) {
+			rev_cnt = min(rev_cnt, max_pkt);
+			for (j = 0; j < (128 * rev_cnt); j += (128 * rpt_cnt)) {
+				pkt_type = c[j] & 0xc0;
+				cp_size = DV_META_SINGLE_PKT_SIZE;
+				if (!(pkt_type == META_PKY_TYPE_START)) {
+					cp_size += 2;
+					cp_offset = 3;
+				} else {
+					cp_offset = 5;
+				}
+				for (i = 0; i < rpt_cnt; i++) {
+					pkt_p = (struct dv_meta_pkt *)
+						&c[j + 128 * i];
+					crc1 = pkt_p->crc;
+					crc1_r = crc32(0, (char *)pkt_p, 124);
+					crc1_r = swap32(crc1_r);
+					if (((cnt % 60) == 0) &&
+					    (dv_dbg_log & (1 << 0)))
+						pr_info("crc:0x%x, 0x%x\n",
+							crc1, crc1_r);
+					if (crc1 == crc1_r) {
+						cp_offset += j + 128 * i;
+						memcpy(cp,
+						       &c[cp_offset], cp_size);
+						cp += cp_size;
+						cp_sum += cp_size;
+						break;
+					}
+				}
+				if (((cnt % 60) == 0) &&
+				    (dv_dbg_log & (1 << 0)))
+					pr_info("data idx %d:0x%x\n",
+						j, c[j] & 0xc0);
+			}
+		} else {
+			rev_cnt = 1;
+			rpt_cnt = 0;
+			tail_cnt = 0;
+		}
+
+		if (((cnt % 60) == 0) && (dv_dbg_log & (1 << 0))) {
+			pr_info("mult_flag=%d tail_flag=%d meta_size=%d\n",
+				multimeta_flag, multimetatail_flag, meta_size);
+			pr_info("rpt_cnt:%d tail_cnt:%d rev_cnt:%d cp_sum:%d\n",
+				rpt_cnt, tail_cnt, rev_cnt, cp_sum);
 		}
-		if (crc == crc_result) {
+
+		if (crc == crc_r) {
 			if ((multimeta_flag == 1) &&
 				(multimetatail_flag == 1)) {
-				if (crc1 == crc_result1)
+				if (crc1 == crc1_r)
 					break;
 			} else
 				break;
 		}
 	}
-	if ((crc != crc_result) || ((multimeta_flag == 1)
-		&& (multimetatail_flag == 1)
-		&& (crc1 != crc_result1))) {
+
+	/*meta data pkt data*/
+	if (((cnt % 60) == 0) && (dv_dbg_log & (1 << 5)))
+		vdin_dolby_pr_meta_data(c, 128 * rev_cnt);
+
+	if ((crc != crc_r) ||
+	    ((multimeta_flag == 1) && (multimetatail_flag == 1) &&
+	    (crc1 != crc1_r))) {
 		/* set small size to make control path return -1
 		 *	to use previous setting
 		 */
 		devp->vfp->dv_buf[index] = &c[5];
 		devp->vfp->dv_buf_size[index] = 4;
-		if (dv_dbg_log&(1<<3)) {
+		if (((cnt % 60) == 0) && (dv_dbg_log & (1 << 3))) {
 			pr_err("%s:hdmi dovi meta crc error:%08x!=%08x\n",
-				__func__, crc, crc_result);
+				__func__, crc, crc_r);
 			pr_info("%s:index:%d dma:%x vaddr:%p size:%d\n",
 				__func__, index,
 				devp->vfp->dv_buf_mem[index],
 				devp->vfp->dv_buf_vmem[index],
 				meta_size);
-			for (i = 0; i < 128; i += 4)
-				pr_info("\t%08x %08x %08x %08x\n",
-					p[i], p[i+1], p[i+2], p[i+3]);
+			vdin_dolby_pr_meta_data(p, 128);
 		}
 		devp->dv.dv_crc_check = false;
 	} else {
@@ -4317,24 +4407,27 @@ void vdin_dolby_buffer_update(struct vdin_dev_s *devp, unsigned int index)
 		devp->vfp->dv_buf[index] = &c[5];
 		devp->vfp->dv_buf_size[index] = meta_size;
 		if ((multimeta_flag == 1) && (multimetatail_flag == 1)) {
-			memcpy(tmpmeta, c + 5, metapayloadsize);
-			extmetasize = meta_size - metapayloadsize;
-			for (k = 0; k < extmetasize; k++)
-				tmpmeta[119 + k] = c[128 * 3 + 3 + k];
-			memcpy(devp->vfp->dv_buf[index], tmpmeta, meta_size);
-		} else if (meta_size > metapayloadsize)
+			devp->vfp->dv_buf[index] = c;
+			cp = devp->dv.temp_meta_data;
+			memcpy(c, cp, meta_size);
+			if (((cnt % 60) == 0) && (dv_dbg_log & (1 << 0)))
+				pr_info("cp %d meta to buff\n", meta_size);
+		} else if (meta_size > DV_META_SINGLE_PKT_SIZE) {
 			devp->dv.dv_crc_check = false;
-		if (dv_dbg_log&(1<<0))
+		}
+
+		if (((cnt % 60) == 0) && (dv_dbg_log & (1 << 0)))
 			pr_info("%s:index:%d dma:%x vaddr:%p size:%d crc:%x crc1:%x\n",
 				__func__, index,
 				devp->vfp->dv_buf_mem[index],
 				devp->vfp->dv_buf_vmem[index],
 				meta_size, crc, crc1);
-		if (dv_dbg_log&(1<<2))
-			for (i = 0; i < 128; i += 4)
-				pr_info("\t%08x %08x %08x %08x\n",
-					p[i], p[i+1], p[i+2], p[i+3]);
+		/*meta data raw data*/
+		if (((cnt % 60) == 0) && (dv_dbg_log & (1 << 4)))
+			vdin_dolby_pr_meta_data(c, meta_size);
 	}
+
+	cnt++;
 }
 
 void vdin_dolby_addr_update(struct vdin_dev_s *devp, unsigned int index)
@@ -4358,14 +4451,12 @@ void vdin_dolby_addr_update(struct vdin_dev_s *devp, unsigned int index)
 				index, devp->vfp->dv_buf_mem[index]);
 	} else {
 		wr(offset, VDIN_DOLBY_DSC_CTRL2, 0x5180c0d5);
+		if (cpu_after_eq(MESON_CPU_MAJOR_ID_TM2))
+			wr(offset, VDIN_DOLBY_DSC_CTRL2, 0x6800c0d5);
+		else
+			wr(offset, VDIN_DOLBY_DSC_CTRL2, 0x5180c0d5);
 		wr(offset, VDIN_DOLBY_DSC_CTRL3, 0);
-		if (dv_dbg_log&(1<<0))
-			pr_info("%s:index:%d\n", __func__,	index);
 	}
-
-	if (dv_dbg_log&(1<<2))
-		pr_info("%s:index:%d,paddr:0x%x\n", __func__, index,
-			devp->vfp->dv_buf_mem[index]);
 }
 
 void vdin_dolby_config(struct vdin_dev_s *devp)
@@ -4394,6 +4485,10 @@ void vdin_dolby_config(struct vdin_dev_s *devp)
 		/*disable wr memory*/
 		vdin_dobly_mdata_write_en(offset, 0);
 		wr(offset, VDIN_DOLBY_DSC_CTRL2, 0x5180c0d5);
+		if (cpu_after_eq(MESON_CPU_MAJOR_ID_TM2))
+			wr(offset, VDIN_DOLBY_DSC_CTRL2, 0x6800c0d5);
+		else
+			wr(offset, VDIN_DOLBY_DSC_CTRL2, 0x5180c0d5);
 		wr(offset, VDIN_DOLBY_DSC_CTRL3, 0x0);
 	}
 }
diff --git a/drivers/amlogic/media/vin/tvin/vdin/vdin_ctl.h b/drivers/amlogic/media/vin/tvin/vdin/vdin_ctl.h
index 12095fb26d5a..ff33f36d5faf 100644
--- a/drivers/amlogic/media/vin/tvin/vdin/vdin_ctl.h
+++ b/drivers/amlogic/media/vin/tvin/vdin/vdin_ctl.h
@@ -70,6 +70,27 @@ struct ldim_max_s {
 };
 #endif
 
+#define META_PKY_TYPE_SINGLE	0x00
+#define META_PKY_TYPE_START	0x40
+#define META_PKY_TYPE_MID	0x80
+#define META_PKY_TYPE_TAIL	0xc0
+
+#define DV_META_PACKET_SIZE		128
+#define DV_META_HEADER_LEN		2
+#define DV_META_TAIL_CRC_SIZE		4
+#define DV_META_PACKET_TYPE_SIZE	3
+
+#define DV_META_SINGLE_PKT_SIZE		119
+#define DV_META_NORMAL_PKT_SIZE		121
+
+struct dv_meta_pkt {
+	u8 head0;
+	u8 head1;
+	u8 head2;
+	u8 body[121];
+	u32 crc;
+};
+
 extern unsigned int game_mode;
 extern bool vdin_dbg_en;
 
diff --git a/drivers/amlogic/media/vin/tvin/vdin/vdin_debug.c b/drivers/amlogic/media/vin/tvin/vdin/vdin_debug.c
index e963891e59f7..639876c9abab 100644
--- a/drivers/amlogic/media/vin/tvin/vdin/vdin_debug.c
+++ b/drivers/amlogic/media/vin/tvin/vdin/vdin_debug.c
@@ -1524,6 +1524,17 @@ static void vdin_dump_regs(struct vdin_dev_s *devp)
 				(reg + offset), rd(offset, reg));
 		}
 		pr_info("vdin%d h/v sk regs end----\n\n", devp->index);
+
+		pr_info("vdin%d DV regs start----\n", devp->index);
+		for (reg = VDIN_DOLBY_DSC_CTRL0;
+		     reg <= VDIN_DOLBY_DSC_STATUS2; reg++) {
+			pr_info("0x%04x = 0x%08x\n",
+				(reg + offset), rd(offset, reg));
+		}
+		pr_info("0x%04x = 0x%08x\n",
+			(VDIN_DOLBY_DSC_STATUS3 + offset),
+			rd(offset, VDIN_DOLBY_DSC_STATUS3));
+		pr_info("vdin%d DV regs end----\n\n", devp->index);
 	}
 
 	if (devp->afbce_flag & VDIN_AFBCE_EN) {
diff --git a/drivers/amlogic/media/vin/tvin/vdin/vdin_drv.h b/drivers/amlogic/media/vin/tvin/vdin/vdin_drv.h
index 1a6761e33b6d..f20a093c28c1 100644
--- a/drivers/amlogic/media/vin/tvin/vdin/vdin_drv.h
+++ b/drivers/amlogic/media/vin/tvin/vdin/vdin_drv.h
@@ -265,6 +265,7 @@ struct vdin_dv_s {
 	unsigned int dolby_input;
 	dma_addr_t dv_dma_paddr;
 	void *dv_dma_vaddr;
+	void *temp_meta_data;
 	unsigned int dv_flag_cnt;/*cnt for no dv input*/
 	bool dv_flag;
 	bool dv_config;
-- 
2.24.1

