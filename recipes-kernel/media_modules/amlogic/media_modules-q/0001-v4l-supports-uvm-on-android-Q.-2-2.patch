From f2f1bd0d4c320dd94be2e90dbfad40baf3438410 Mon Sep 17 00:00:00 2001
From: Nanxin Qin <nanxin.qin@amlogic.com>
Date: Mon, 12 Oct 2020 21:23:14 +0800
Subject: [PATCH] v4l: supports uvm on android Q. [2/2]

PD#SWPL-34978

Problem:
enable uvm in media_module on 4.9_q_uvm branch

Solution:
porting uvm code from branch 4.9-dev and 5.4-dev.

Verify:
AH212

Change-Id: Ifa127b23e6481b58848d61793c91a9b7ff97813d
Signed-off-by: Nanxin Qin <nanxin.qin@amlogic.com>
---
 drivers/amvdec_ports/aml_vcodec_adapt.c       |   1 +
 drivers/amvdec_ports/aml_vcodec_adapt.h       |   1 -
 drivers/amvdec_ports/aml_vcodec_dec.c         | 907 +++++++++++++-----
 drivers/amvdec_ports/aml_vcodec_dec.h         |  14 +-
 drivers/amvdec_ports/aml_vcodec_dec_drv.c     |  34 +-
 drivers/amvdec_ports/aml_vcodec_drv.h         | 251 +++--
 drivers/amvdec_ports/aml_vcodec_util.c        |  66 --
 drivers/amvdec_ports/aml_vcodec_util.h        |   8 +-
 drivers/amvdec_ports/aml_vcodec_vfm.c         |  25 +-
 drivers/amvdec_ports/aml_vcodec_vfm.h         |   5 +-
 drivers/amvdec_ports/aml_vcodec_vpp.c         | 509 ++++++++++
 drivers/amvdec_ports/aml_vcodec_vpp.h         | 103 ++
 .../amvdec_ports/decoder/aml_hevc_parser.h    |   1 -
 .../amvdec_ports/decoder/aml_mpeg12_parser.h  |   1 -
 drivers/amvdec_ports/decoder/vdec_av1_if.c    |  94 +-
 drivers/amvdec_ports/decoder/vdec_h264_if.c   |  11 +-
 drivers/amvdec_ports/decoder/vdec_hevc_if.c   |  37 +-
 drivers/amvdec_ports/decoder/vdec_mjpeg_if.c  |  14 +-
 drivers/amvdec_ports/decoder/vdec_mpeg12_if.c |  10 +-
 drivers/amvdec_ports/decoder/vdec_mpeg4_if.c  |   4 +-
 drivers/amvdec_ports/decoder/vdec_vp9_if.c    |  42 +-
 drivers/amvdec_ports/vdec_drv_if.h            |  16 +-
 drivers/frame_provider/decoder/avs2/vavs2.c   |  32 +-
 .../decoder/h264_multi/vmh264.c               |  34 +-
 drivers/frame_provider/decoder/h265/vh265.c   | 522 +++++-----
 .../decoder/mjpeg/vmjpeg_multi.c              |   2 +-
 .../decoder/mpeg12/vmpeg12_multi.c            |  27 +-
 drivers/frame_provider/decoder/utils/vdec.c   |  13 +
 drivers/frame_provider/decoder/utils/vdec.h   |   2 +
 .../decoder/utils/vdec_v4l2_buffer_ops.c      |  36 +-
 .../decoder/utils/vdec_v4l2_buffer_ops.h      |   7 +
 drivers/frame_provider/decoder/vav1/vav1.c    | 329 ++++---
 drivers/frame_provider/decoder/vp9/vvp9.c     | 499 ++++++----
 33 files changed, 2532 insertions(+), 1125 deletions(-)
 create mode 100644 drivers/amvdec_ports/aml_vcodec_vpp.c
 create mode 100644 drivers/amvdec_ports/aml_vcodec_vpp.h

diff --git a/drivers/amvdec_ports/aml_vcodec_adapt.c b/drivers/amvdec_ports/aml_vcodec_adapt.c
index 95ee48a1..a4fc80cd 100644
--- a/drivers/amvdec_ports/aml_vcodec_adapt.c
+++ b/drivers/amvdec_ports/aml_vcodec_adapt.c
@@ -660,6 +660,7 @@ int aml_codec_reset(struct aml_vdec_adapt *ada_ctx, int *mode)
 	if (vdec) {
 		if (!ada_ctx->ctx->q_data[AML_Q_DATA_SRC].resolution_changed)
 			vdec_set_eos(vdec, false);
+
 		if (*mode == V4L_RESET_MODE_NORMAL &&
 			vdec->input.have_frame_num == 0) {
 			v4l_dbg(ada_ctx->ctx, V4L_DEBUG_CODEC_PRINFO,
diff --git a/drivers/amvdec_ports/aml_vcodec_adapt.h b/drivers/amvdec_ports/aml_vcodec_adapt.h
index b86cbffa..da6f4b5e 100644
--- a/drivers/amvdec_ports/aml_vcodec_adapt.h
+++ b/drivers/amvdec_ports/aml_vcodec_adapt.h
@@ -33,7 +33,6 @@ struct aml_vdec_adapt {
 	uint32_t inst_addr;
 	unsigned int signaled;
 	struct aml_vcodec_ctx *ctx;
-	struct platform_device *dev;
 	wait_queue_head_t wq;
 	struct file *filp;
 	struct vdec_s *vdec;
diff --git a/drivers/amvdec_ports/aml_vcodec_dec.c b/drivers/amvdec_ports/aml_vcodec_dec.c
index 790c7181..dfb1f4d6 100644
--- a/drivers/amvdec_ports/aml_vcodec_dec.c
+++ b/drivers/amvdec_ports/aml_vcodec_dec.c
@@ -31,16 +31,19 @@
 #include <linux/crc32.h>
 #include "aml_vcodec_adapt.h"
 #include <linux/spinlock.h>
+#include <linux/amlogic/meson_uvm_core.h>
 
 #include "aml_vcodec_vfm.h"
+#include "aml_vcodec_vpp.h"
 #include "../frame_provider/decoder/utils/decoder_bmmu_box.h"
 #include "../frame_provider/decoder/utils/decoder_mmu_box.h"
 
 #define KERNEL_ATRACE_TAG KERNEL_ATRACE_TAG_V4L2
 #include <trace/events/meson_atrace.h>
 
-#define OUT_FMT_IDX	0 //default h264
-#define CAP_FMT_IDX	8 //capture nv21
+#define OUT_FMT_IDX		(0) //default h264
+#define CAP_FMT_IDX		(9) //capture nv21
+#define CAP_FMT_I420_IDX	(12) //use for mjpeg
 
 #define AML_VDEC_MIN_W	64U
 #define AML_VDEC_MIN_H	64U
@@ -126,6 +129,11 @@ static struct aml_video_fmt aml_video_formats[] = {
 		.type = AML_FMT_FRAME,
 		.num_planes = 1,
 	},
+	{
+		.fourcc = V4L2_PIX_FMT_YUV420M,
+		.type = AML_FMT_FRAME,
+		.num_planes = 2,
+	},
 };
 
 static const struct aml_codec_framesizes aml_vdec_framesizes[] = {
@@ -184,16 +192,31 @@ static const struct aml_codec_framesizes aml_vdec_framesizes[] = {
 		.stepwise = {  AML_VDEC_MIN_W, AML_VDEC_MAX_W, 2,
 				AML_VDEC_MIN_H, AML_VDEC_MAX_H, 2},
 	},
+	{
+		.fourcc = V4L2_PIX_FMT_YUV420,
+		.stepwise = {  AML_VDEC_MIN_W, AML_VDEC_MAX_W, 2,
+				AML_VDEC_MIN_H, AML_VDEC_MAX_H, 2},
+	},
+	{
+		.fourcc = V4L2_PIX_FMT_YUV420M,
+		.stepwise = {  AML_VDEC_MIN_W, AML_VDEC_MAX_W, 2,
+				AML_VDEC_MIN_H, AML_VDEC_MAX_H, 2},
+	},
 };
 
 #define NUM_SUPPORTED_FRAMESIZE ARRAY_SIZE(aml_vdec_framesizes)
 #define NUM_FORMATS ARRAY_SIZE(aml_video_formats)
 
 extern bool multiplanar;
-extern bool dump_capture_frame;
+extern int dump_capture_frame;
+extern int bypass_vpp;
+extern bool support_format_I420;
+extern bool support_mjpeg;
 
 extern int dmabuf_fd_install_data(int fd, void* data, u32 size);
 extern bool is_v4l2_buf_file(struct file *file);
+static void box_release(struct kref *kref);
+extern int get_double_write_ratio(int dw_mode);
 
 static ulong aml_vcodec_ctx_lock(struct aml_vcodec_ctx *ctx)
 {
@@ -277,10 +300,54 @@ static void aml_vdec_flush_decoder(struct aml_vcodec_ctx *ctx)
 	aml_decoder_flush(ctx->ada_ctx);
 }
 
+/* Conditions:
+ * Always connect VPP for mpeg2 and h264 when the stream size is under 2K.
+ * Always connect VPP for hevc/av1/vp9 when color space is not SDR and
+ *     stream size is under 2K.
+ * For DV, need application to notify V4L2 driver to enforce the color space
+ *     conversion. Plan to do it through a system node.
+ * Do not connect VPP in other cases.
+ */
+static bool vpp_needed(struct aml_vcodec_ctx *ctx, u32* mode)
+{
+	if (bypass_vpp)
+		return false;
+
+	if (ctx->output_pix_fmt == V4L2_PIX_FMT_MPEG2) {
+		if (ctx->picinfo.coded_width <= 1920 &&
+			ctx->picinfo.coded_height <= 1088) {
+			*mode = VPP_MODE_DI;
+			return true;
+		}
+	}
+
+	if (ctx->output_pix_fmt == V4L2_PIX_FMT_H264) {
+		if (ctx->picinfo.coded_width <= 1920 &&
+			ctx->picinfo.coded_height <= 1088) {
+			*mode = VPP_MODE_DI;
+			return true;
+		}
+	}
+
+#if 0//enable later
+	if (ctx->output_pix_fmt == V4L2_PIX_FMT_HEVC ||
+		ctx->output_pix_fmt == V4L2_PIX_FMT_VP9) {
+		if (ctx->colorspace != V4L2_COLORSPACE_DEFAULT &&
+			ctx->picinfo.coded_width <= 1920 &&
+			ctx->picinfo.coded_height <= 1088) {
+			*mode = VPP_MODE_COLOR_CONV;
+			return true;
+		}
+	}
+#endif
+	return false;
+}
+
 static void aml_vdec_pic_info_update(struct aml_vcodec_ctx *ctx)
 {
 	unsigned int dpbsize = 0;
 	int ret;
+	u32 mode;
 
 	if (vdec_if_get_param(ctx, GET_PARAM_PIC_INFO, &ctx->last_decoded_picinfo)) {
 		v4l_dbg(ctx, V4L_DEBUG_CODEC_ERROR,
@@ -317,82 +384,42 @@ static void aml_vdec_pic_info_update(struct aml_vcodec_ctx *ctx)
 	/* update picture information */
 	ctx->dpb_size = dpbsize;
 	ctx->picinfo = ctx->last_decoded_picinfo;
-}
-
-static bool aml_check_inst_quit(struct aml_vcodec_dev *dev,
-	struct aml_vcodec_ctx * inst, u32 id)
-{
-	struct aml_vcodec_ctx *ctx = NULL;
-	bool ret = true;
-
-	if (dev == NULL)
-		return false;
-
-	mutex_lock(&dev->dev_mutex);
-
-	if (list_empty(&dev->ctx_list)) {
-		v4l_dbg(ctx, V4L_DEBUG_CODEC_ERROR,
-			"v4l inst list is empty.\n");
-		ret = true;
-		goto out;
-	}
 
-	list_for_each_entry(ctx, &dev->ctx_list, list) {
-		if ((ctx == inst) && (ctx->id == id)) {
-			ret = ctx->receive_cmd_stop ? true : false;
-			goto out;
-		}
-	}
-out:
-	mutex_unlock(&dev->dev_mutex);
-
-	return ret;
+	if (vpp_needed(ctx, &mode)) {
+		ctx->vpp_size = aml_v4l2_vpp_get_buf_num(mode);
+		v4l_dbg(ctx, V4L_DEBUG_VPP_BUFMGR,
+			"vpp_size: %d\n", ctx->vpp_size);
+	} else
+		ctx->vpp_size = 0;
 }
 
 void vdec_frame_buffer_release(void *data)
 {
 	struct file_private_data *priv_data =
 		(struct file_private_data *) data;
-	struct aml_vcodec_dev *dev = (struct aml_vcodec_dev *)
-		priv_data->vb_handle;
-	struct aml_vcodec_ctx *inst = (struct aml_vcodec_ctx *)
+	struct aml_vcodec_ctx *ctx = (struct aml_vcodec_ctx *)
 		priv_data->v4l_dec_ctx;
-	u32 id = priv_data->v4l_inst_id;
-
-	if (aml_check_inst_quit(dev, inst, id)) {
-		struct vframe_s *vf = &priv_data->vf;
-
-		v4l_dbg(0, V4L_DEBUG_CODEC_BUFMGR,
-			"[%d]: vf idx: %d, bmmu idx: %d, bmmu_box: %lx\n",
-			id, vf->index, vf->mm_box.bmmu_idx,
-			(ulong) vf->mm_box.bmmu_box);
-
-		v4l_dbg(0, V4L_DEBUG_CODEC_BUFMGR,
-			"[%d]: vf idx: %d, mmu_idx: %d, mmu_box: %lx\n",
-			id, vf->index, vf->mm_box.mmu_idx,
-			(ulong) vf->mm_box.mmu_box);
-
-		if (decoder_bmmu_box_valide_check(vf->mm_box.bmmu_box)) {
-			decoder_bmmu_box_free_idx(vf->mm_box.bmmu_box,
-				vf->mm_box.bmmu_idx);
-			decoder_bmmu_try_to_release_box(vf->mm_box.bmmu_box);
-		}
-
-		if (decoder_mmu_box_valide_check(vf->mm_box.mmu_box)) {
-			decoder_mmu_box_free_idx(vf->mm_box.mmu_box,
-				vf->mm_box.mmu_idx);
-			decoder_mmu_try_to_release_box(vf->mm_box.mmu_box);
-		}
+	struct aml_video_dec_buf *vb = (struct aml_video_dec_buf *)
+		priv_data->vb_handle;
+	struct uvm_hook_mod_info *uvm = NULL;
 
+	if (ctx && ctx->uvm_proxy) {
+		uvm = &ctx->uvm_proxy[vb->internal_index];
+		uvm->free(uvm->arg);
 	}
 
 	memset(data, 0, sizeof(struct file_private_data));
 	kfree(data);
 }
 
-int get_fb_from_queue(struct aml_vcodec_ctx *ctx, struct vdec_v4l2_buffer **out_fb)
+int get_fb_from_queue(struct aml_vcodec_ctx *ctx,
+		struct vdec_v4l2_buffer **out_fb,
+		bool for_vpp)
 {
+	int i;
 	ulong flags;
+	u32 buf_flag;
+	char plane_n[3] = {'Y','U','V'};
 	struct vb2_buffer *dst_buf = NULL;
 	struct vdec_v4l2_buffer *pfb;
 	struct aml_video_dec_buf *dst_buf_info, *info;
@@ -412,61 +439,45 @@ int get_fb_from_queue(struct aml_vcodec_ctx *ctx, struct vdec_v4l2_buffer **out_
 	}
 
 	v4l_dbg(ctx, V4L_DEBUG_CODEC_BUFMGR,
-		"vbuf idx: %d, state: %d, ready: %d\n",
+		"vbuf idx: %d, state: %d, ready: %d vpp: %d\n",
 		dst_buf->index, dst_buf->state,
-		v4l2_m2m_num_dst_bufs_ready(ctx->m2m_ctx));
+		v4l2_m2m_num_dst_bufs_ready(ctx->m2m_ctx), for_vpp);
 
 	dst_vb2_v4l2 = container_of(dst_buf, struct vb2_v4l2_buffer, vb2_buf);
 	dst_buf_info = container_of(dst_vb2_v4l2, struct aml_video_dec_buf, vb);
 
-	pfb	= &dst_buf_info->frame_buffer;
+	pfb = &dst_buf_info->frame_buffer;
 	pfb->buf_idx	= dst_buf->index;
-	pfb->num_planes	= dst_buf->num_planes;
+	pfb->num_planes = dst_buf->num_planes;
 	pfb->status		= FB_ST_NORMAL;
-	if (dst_buf->num_planes == 1) {
-		pfb->m.mem[0].dma_addr	= vb2_dma_contig_plane_dma_addr(dst_buf, 0);
-		pfb->m.mem[0].addr	= dma_to_phys(v4l_get_dev_from_codec_mm(), pfb->m.mem[0].dma_addr);
-		pfb->m.mem[0].size	= ctx->picinfo.y_len_sz + ctx->picinfo.c_len_sz;
-		pfb->m.mem[0].offset	= ctx->picinfo.y_len_sz;
-		v4l_dbg(ctx, V4L_DEBUG_CODEC_BUFMGR,
-			"idx: %u, 1 plane, y:(0x%lx, %d)\n", dst_buf->index,
-			pfb->m.mem[0].addr, pfb->m.mem[0].size);
-	} else if (dst_buf->num_planes == 2) {
-		pfb->m.mem[0].dma_addr	= vb2_dma_contig_plane_dma_addr(dst_buf, 0);
-		pfb->m.mem[0].addr	= dma_to_phys(v4l_get_dev_from_codec_mm(), pfb->m.mem[0].dma_addr);
-		pfb->m.mem[0].size	= ctx->picinfo.y_len_sz;
-		pfb->m.mem[0].offset	= 0;
-
-		pfb->m.mem[1].dma_addr	= vb2_dma_contig_plane_dma_addr(dst_buf, 1);
-		pfb->m.mem[1].addr	= dma_to_phys(v4l_get_dev_from_codec_mm(), pfb->m.mem[1].dma_addr);
-		pfb->m.mem[1].size	= ctx->picinfo.c_len_sz;
-		pfb->m.mem[1].offset	= ctx->picinfo.c_len_sz >> 1;
-		v4l_dbg(ctx, V4L_DEBUG_CODEC_BUFMGR,
-			"idx: %u, 2 planes, y:(0x%lx, %d), c:(0x%lx, %d)\n", dst_buf->index,
-			pfb->m.mem[0].addr, pfb->m.mem[0].size,
-			pfb->m.mem[1].addr, pfb->m.mem[1].size);
-	} else {
-		pfb->m.mem[0].dma_addr	= vb2_dma_contig_plane_dma_addr(dst_buf, 0);
-		pfb->m.mem[0].addr	= dma_to_phys(v4l_get_dev_from_codec_mm(), pfb->m.mem[0].dma_addr);
-		pfb->m.mem[0].size	= ctx->picinfo.y_len_sz;
-		pfb->m.mem[0].offset	= 0;
-
-		pfb->m.mem[1].dma_addr	= vb2_dma_contig_plane_dma_addr(dst_buf, 1);
-		pfb->m.mem[1].addr	= dma_to_phys(v4l_get_dev_from_codec_mm(), pfb->m.mem[2].dma_addr);
-		pfb->m.mem[1].size	= ctx->picinfo.c_len_sz >> 1;
-		pfb->m.mem[1].offset	= 0;
-
-		pfb->m.mem[2].dma_addr	= vb2_dma_contig_plane_dma_addr(dst_buf, 2);
-		pfb->m.mem[2].addr	= dma_to_phys(v4l_get_dev_from_codec_mm(), pfb->m.mem[3].dma_addr);
-		pfb->m.mem[2].size	= ctx->picinfo.c_len_sz >> 1;
-		pfb->m.mem[2].offset	= 0;
+	for (i = 0 ; i < dst_buf->num_planes ; i++) {
+		pfb->m.mem[i].dma_addr	= vb2_dma_contig_plane_dma_addr(dst_buf, i);
+		pfb->m.mem[i].addr	= dma_to_phys(v4l_get_dev_from_codec_mm(),
+				pfb->m.mem[i].dma_addr);
+		if (i == 0) {
+			//Y
+			if (dst_buf->num_planes == 1) {
+				pfb->m.mem[0].size	= ctx->picinfo.y_len_sz +
+					ctx->picinfo.c_len_sz;
+				pfb->m.mem[0].offset = ctx->picinfo.y_len_sz;
+			} else {
+				pfb->m.mem[0].size	= ctx->picinfo.y_len_sz;
+				pfb->m.mem[0].offset = 0;
+			}
+		} else {
+			if (dst_buf->num_planes == 2) {
+				//UV
+				pfb->m.mem[1].size	= ctx->picinfo.c_len_sz;
+				pfb->m.mem[1].offset = ctx->picinfo.c_len_sz >> 1;
+			} else {
+				pfb->m.mem[i].size  = ctx->picinfo.c_len_sz >> 1;
+				pfb->m.mem[i].offset = 0;
+			}
+		}
 
 		v4l_dbg(ctx, V4L_DEBUG_CODEC_BUFMGR,
-			"idx: %u, 3 planes, y:(0x%lx, %d), u:(0x%lx, %d), v:(0x%lx, %d)\n",
-			dst_buf->index,
-			pfb->m.mem[0].addr, pfb->m.mem[0].size,
-			pfb->m.mem[1].addr, pfb->m.mem[1].size,
-			pfb->m.mem[2].addr, pfb->m.mem[2].size);
+				"idx: %u, %c:(0x%lx, %d)\n", dst_buf->index,
+				plane_n[i], pfb->m.mem[i].addr, pfb->m.mem[i].size);
 	}
 
 	dst_buf_info->used = true;
@@ -476,9 +487,16 @@ int get_fb_from_queue(struct aml_vcodec_ctx *ctx, struct vdec_v4l2_buffer **out_
 
 	info = container_of(pfb, struct aml_video_dec_buf, frame_buffer);
 
-	ctx->cap_pool.dec++;
+	if (for_vpp) {
+		buf_flag = V4L_CAP_BUFF_IN_VPP;
+		ctx->cap_pool.vpp++;
+	} else {
+		buf_flag = V4L_CAP_BUFF_IN_DEC;
+		ctx->cap_pool.dec++;
+	}
 	ctx->cap_pool.seq[ctx->cap_pool.out++] =
-		(V4L_CAP_BUFF_IN_DEC << 16 | dst_buf->index);
+		(buf_flag << 16 | dst_buf->index);
+
 	v4l2_m2m_dst_buf_remove(ctx->m2m_ctx);
 
 	aml_vcodec_ctx_unlock(ctx, flags);
@@ -527,11 +545,11 @@ void trans_vframe_to_user(struct aml_vcodec_ctx *ctx, struct vdec_v4l2_buffer *f
 	struct vframe_s *vf = (struct vframe_s *)fb->vf_handle;
 
 	v4l_dbg(ctx, V4L_DEBUG_CODEC_OUTPUT,
-		"FROM (%s %s) vf: %lx, ts: %llu, idx: %d, "
+		"FROM (%s %s) vf: %px, ts: %llx, idx: %d, "
 		"Y:(%lx, %u) C/U:(%lx, %u) V:(%lx, %u)\n",
 		vf_get_provider(ctx->ada_ctx->recv_name)->name,
 		ctx->ada_ctx->vfm_path != FRAME_BASE_PATH_V4L_VIDEO ? "OSD" : "VIDEO",
-		(ulong) vf, vf->timestamp, vf->index,
+		vf, vf->timestamp, vf->index & 0xff,
 		fb->m.mem[0].addr, fb->m.mem[0].size,
 		fb->m.mem[1].addr, fb->m.mem[1].size,
 		fb->m.mem[2].addr, fb->m.mem[2].size);
@@ -540,50 +558,62 @@ void trans_vframe_to_user(struct aml_vcodec_ctx *ctx, struct vdec_v4l2_buffer *f
 	vb2_buf = &dstbuf->vb.vb2_buf;
 
 	if (dstbuf->frame_buffer.num_planes == 1) {
-		vb2_set_plane_payload(&dstbuf->vb.vb2_buf, 0, fb->m.mem[0].bytes_used);
+		vb2_set_plane_payload(vb2_buf, 0, fb->m.mem[0].bytes_used);
 	} else if (dstbuf->frame_buffer.num_planes == 2) {
-		vb2_set_plane_payload(&dstbuf->vb.vb2_buf, 0, fb->m.mem[0].bytes_used);
-		vb2_set_plane_payload(&dstbuf->vb.vb2_buf, 1, fb->m.mem[1].bytes_used);
+		vb2_set_plane_payload(vb2_buf, 0, fb->m.mem[0].bytes_used);
+		vb2_set_plane_payload(vb2_buf, 1, fb->m.mem[1].bytes_used);
 	}
-	dstbuf->vb.vb2_buf.timestamp = vf->timestamp;
-	dstbuf->ready_to_display = true;
+	vb2_buf->timestamp = vf->timestamp;
 
-	if (dump_capture_frame) {
+	do {
+		unsigned int dw_mode = VDEC_DW_NO_AFBC;
 		struct file *fp;
+
+		if (!dump_capture_frame || ctx->is_drm_mode)
+			break;
+		if (vdec_if_get_param(ctx, GET_PARAM_DW_MODE, &dw_mode))
+			break;
+		if (dw_mode == VDEC_DW_AFBC_ONLY)
+			break;
+
+		/* interlaced frame case 2 vf bind to the same vb2 */
+		if (ctx->vpp && (vb2_buf->state == V4L2_BUF_FLAG_DONE))
+			break;
+
 		fp = filp_open("/data/dec_dump.raw",
 				O_CREAT | O_RDWR | O_LARGEFILE | O_APPEND, 0600);
+
 		if (!IS_ERR(fp)) {
-			struct vb2_buffer *vb = &dstbuf->vb.vb2_buf;
-			kernel_write(fp,vb2_plane_vaddr(vb, 0),vb->planes[0].bytesused, 0);
+			struct vb2_buffer *vb = vb2_buf;
+
+			kernel_write(fp,vb2_plane_vaddr(vb, 0),vb->planes[0].length, 0);
 			if (dstbuf->frame_buffer.num_planes == 2)
 				kernel_write(fp,vb2_plane_vaddr(vb, 1),
-						vb->planes[1].bytesused, 0);
+						vb->planes[1].length, 0);
 			pr_info("dump idx: %d %dx%d\n", dump_capture_frame, vf->width, vf->height);
 			dump_capture_frame--;
 			filp_close(fp, NULL);
 		}
-	}
+	} while(0);
 
 	if (vf->flag & VFRAME_FLAG_EMPTY_FRAME_V4L) {
 		dstbuf->vb.flags = V4L2_BUF_FLAG_LAST;
 		if (dstbuf->frame_buffer.num_planes == 1) {
-			vb2_set_plane_payload(&dstbuf->vb.vb2_buf, 0, 0);
+			vb2_set_plane_payload(vb2_buf, 0, 0);
 		} else if (dstbuf->frame_buffer.num_planes == 2) {
-			vb2_set_plane_payload(&dstbuf->vb.vb2_buf, 0, 0);
-			vb2_set_plane_payload(&dstbuf->vb.vb2_buf, 1, 0);
+			vb2_set_plane_payload(vb2_buf, 0, 0);
+			vb2_set_plane_payload(vb2_buf, 1, 0);
 		}
 		ctx->has_receive_eos = true;
 		v4l_dbg(ctx, V4L_DEBUG_CODEC_BUFMGR,
 			"recevie a empty frame. idx: %d, state: %d\n",
-			dstbuf->vb.vb2_buf.index,
-			dstbuf->vb.vb2_buf.state);
+			vb2_buf->index, vb2_buf->state);
 		ATRACE_COUNTER("v4l2_eos", 0);
 	}
 
 	v4l_dbg(ctx, V4L_DEBUG_CODEC_EXINFO,
 		"receive vbuf idx: %d, state: %d\n",
-		dstbuf->vb.vb2_buf.index,
-		dstbuf->vb.vb2_buf.state);
+		vb2_buf->index, vb2_buf->state);
 
 	if (vf->flag & VFRAME_FLAG_EMPTY_FRAME_V4L) {
 		if (ctx->q_data[AML_Q_DATA_SRC].resolution_changed) {
@@ -610,8 +640,21 @@ void trans_vframe_to_user(struct aml_vcodec_ctx *ctx, struct vdec_v4l2_buffer *f
 		ATRACE_COUNTER("v4l2_from", vf->index_disp);
 		dstbuf->privdata.vf = *vf;
 		dstbuf->privdata.vf.omx_index =
-			dstbuf->vb.vb2_buf.index;
-
+			vb2_buf->index;
+
+		if (vb2_buf->memory == VB2_MEMORY_DMABUF) {
+			struct dma_buf * dma;
+
+			dma = dstbuf->vb.vb2_buf.planes[0].dbuf;
+			if (dmabuf_is_uvm(dma)) {
+				/* only Y will contain vframe */
+				dmabuf_set_vframe(vb2_buf->planes[0].dbuf,
+					vf, VF_SRC_DECODER);
+				v4l_dbg(ctx, V4L_DEBUG_CODEC_EXINFO,
+						"set vf(%px) into %dth buf\n",
+						vf, vb2_buf->index);
+			}
+		}
 		v4l2_m2m_buf_done(&dstbuf->vb, VB2_BUF_STATE_DONE);
 	}
 
@@ -660,8 +703,9 @@ static void aml_check_dpb_ready(struct aml_vcodec_ctx *ctx)
 			ctx->v4l_codec_dpb_ready = true;
 
 		v4l_dbg(ctx, V4L_DEBUG_CODEC_BUFMGR,
-			"dpb: %d, ready: %d, used: %d, dpb is ready: %s\n",
-			ctx->dpb_size, v4l2_m2m_num_dst_bufs_ready(ctx->m2m_ctx),
+			"dpb: %d, vpp: %d, ready: %d, used: %d, dpb is ready: %s\n",
+			ctx->dpb_size, ctx->vpp_size,
+			v4l2_m2m_num_dst_bufs_ready(ctx->m2m_ctx),
 			ctx->cap_pool.out, ctx->v4l_codec_dpb_ready ? "yes" : "no");
 	}
 }
@@ -718,7 +762,7 @@ static bool is_enough_work_items(struct aml_vcodec_ctx *ctx)
 	return true;
 }
 
-static void aml_wait_dpb_ready(struct aml_vcodec_ctx *ctx)
+static void aml_wait_buf_ready(struct aml_vcodec_ctx *ctx)
 {
 	ulong expires;
 
@@ -733,7 +777,7 @@ static void aml_wait_dpb_ready(struct aml_vcodec_ctx *ctx)
 		}
 
 		ready_num = v4l2_m2m_num_dst_bufs_ready(ctx->m2m_ctx);
-		if ((ready_num + ctx->buf_used_count) >= ctx->dpb_size)
+		if ((ready_num + ctx->buf_used_count) >= CTX_BUF_TOTAL(ctx))
 			ctx->v4l_codec_dpb_ready = true;
 	}
 }
@@ -824,7 +868,7 @@ static void aml_vdec_worker(struct work_struct *work)
 		}
 		mutex_unlock(&ctx->state_lock);
 
-		src_buf = v4l2_m2m_src_buf_remove(ctx->m2m_ctx);
+		v4l2_m2m_src_buf_remove(ctx->m2m_ctx);
 		v4l2_m2m_job_finish(dev->m2m_dev_dec, ctx->m2m_ctx);
 
 		/* sets eos data for vdec input. */
@@ -877,7 +921,7 @@ static void aml_vdec_worker(struct work_struct *work)
 			"error processing src data. %d.\n", ret);
 	} else if (res_chg) {
 		/* wait the DPB state to be ready. */
-		aml_wait_dpb_ready(ctx);
+		aml_wait_buf_ready(ctx);
 
 		src_buf_info->used = false;
 		aml_vdec_pic_info_update(ctx);
@@ -937,7 +981,7 @@ static void aml_vdec_reset(struct aml_vcodec_ctx *ctx)
 			"vcodec state (AML_STATE_PROBE)\n");
 
 		v4l_dbg(ctx, V4L_DEBUG_CODEC_BUFMGR,
-			"dpb: %d, ready: %d, used: %d\n", ctx->dpb_size,
+			"dpb: %d, ready: %d, used: %d\n", CTX_BUF_TOTAL(ctx),
 			v4l2_m2m_num_dst_bufs_ready(ctx->m2m_ctx),
 			ctx->buf_used_count);
 
@@ -1186,6 +1230,8 @@ static int vidioc_decoder_streamon(struct file *file, void *priv,
 	q = v4l2_m2m_get_vq(fh->m2m_ctx, i);
 	if (!V4L2_TYPE_IS_OUTPUT(q->type)) {
 		if (ctx->is_stream_off) {
+			u32 mode;
+
 			mutex_lock(&ctx->state_lock);
 			if ((ctx->state == AML_STATE_ACTIVE ||
 				ctx->state == AML_STATE_FLUSHING ||
@@ -1199,6 +1245,22 @@ static int vidioc_decoder_streamon(struct file *file, void *priv,
 					"vcodec state (AML_STATE_RESET)\n");
 				aml_vdec_reset(ctx);
 			}
+
+			if (vpp_needed(ctx, &mode)) {
+				int ret;
+
+				ret = aml_v4l2_vpp_init(ctx, mode,
+					ctx->cap_pix_fmt, &ctx->vpp);
+				if (ret) {
+					v4l_dbg(ctx, V4L_DEBUG_CODEC_ERROR,
+						"init vpp err:%d\n", ret);
+					mutex_unlock(&ctx->state_lock);
+					return ret;
+				} else {
+					v4l_dbg(ctx, V4L_DEBUG_CODEC_PRINFO,
+						"vl42 vpp init\n");
+				}
+			}
 			mutex_unlock(&ctx->state_lock);
 
 			ctx->is_stream_off = false;
@@ -1221,9 +1283,13 @@ static int vidioc_decoder_streamoff(struct file *file, void *priv,
 	struct vb2_queue *q;
 
 	q = v4l2_m2m_get_vq(fh->m2m_ctx, i);
-	if (!V4L2_TYPE_IS_OUTPUT(q->type))
+	if (!V4L2_TYPE_IS_OUTPUT(q->type)) {
 		ctx->is_stream_off = true;
-	else
+		if (ctx->vpp) {
+			aml_v4l2_vpp_destroy(ctx->vpp);
+			ctx->vpp = NULL;
+		}
+	} else
 		ctx->is_out_stream_off = true;
 
 	v4l_dbg(ctx, V4L_DEBUG_CODEC_PROT,
@@ -1249,11 +1315,11 @@ static int vidioc_decoder_reqbufs(struct file *file, void *priv,
 		__func__, q->type, rb->count);
 
 	if (!V4L2_TYPE_IS_OUTPUT(rb->type)) {
-		/* driver needs match v4l buffer number with dpb_size */
-		if (rb->count > ctx->dpb_size) {
+		/* driver needs match v4l buffer number with total size*/
+		if (rb->count > CTX_BUF_TOTAL(ctx)) {
 			v4l_dbg(ctx, V4L_DEBUG_CODEC_PROT,
 					"reqbufs (st:%d) %d -> %d\n",
-					ctx->state, rb->count, ctx->dpb_size);
+					ctx->state, rb->count, CTX_BUF_TOTAL(ctx));
 			//rb->count = ctx->dpb_size;
 		}
 	} else {
@@ -1293,6 +1359,8 @@ void aml_vcodec_dec_release(struct aml_vcodec_ctx *ctx)
 {
 	ulong flags;
 
+	kref_put(&ctx->box_ref, box_release);
+
 	flags = aml_vcodec_ctx_lock(ctx);
 	ctx->state = AML_STATE_ABORT;
 	ATRACE_COUNTER("v4l2_state", ctx->state);
@@ -1334,6 +1402,9 @@ void aml_vcodec_dec_set_default_params(struct aml_vcodec_ctx *ctx)
 	q_data->coded_width = DFT_CFG_WIDTH;
 	q_data->coded_height = DFT_CFG_HEIGHT;
 	q_data->fmt = &aml_video_formats[CAP_FMT_IDX];
+	if (support_format_I420)
+		q_data->fmt = &aml_video_formats[CAP_FMT_I420_IDX];
+
 	q_data->field = V4L2_FIELD_NONE;
 
 	v4l_bound_align_image(&q_data->coded_width,
@@ -1418,12 +1489,11 @@ static int vidioc_vdec_dqbuf(struct file *file, void *priv,
 		vq = v4l2_m2m_get_vq(ctx->m2m_ctx, buf->type);
 		vb2_v4l2 = to_vb2_v4l2_buffer(vq->bufs[buf->index]);
 		aml_buf = container_of(vb2_v4l2, struct aml_video_dec_buf, vb);
-		aml_buf->privdata.vb_handle	= (ulong) ctx->dev;
+		aml_buf->privdata.vb_handle	= (ulong) aml_buf;
 		aml_buf->privdata.v4l_dec_ctx	= (ulong) ctx;
-		aml_buf->privdata.v4l_inst_id		= ctx->id;
 
 		file = fget(vb2_v4l2->private);
-		if (is_v4l2_buf_file(file)) {
+		if (file && is_v4l2_buf_file(file)) {
 			dmabuf_fd_install_data(vb2_v4l2->private,
 				(void*)&aml_buf->privdata,
 				sizeof(struct file_private_data));
@@ -1431,8 +1501,8 @@ static int vidioc_vdec_dqbuf(struct file *file, void *priv,
 			v4l_dbg(ctx, V4L_DEBUG_CODEC_EXINFO, "disp: %d, vf: %lx\n",
 				aml_buf->privdata.vf.index_disp,
 				(ulong) v4l_get_vf_handle(vb2_v4l2->private));
+			fput(file);
 		}
-		fput(file);
 	}
 
 	return ret;
@@ -1493,7 +1563,7 @@ static int vidioc_try_fmt(struct v4l2_format *f, struct aml_video_fmt *fmt)
 		    pix_fmt_mp->pixelformat != V4L2_PIX_FMT_H264)
 			pix_fmt_mp->field = V4L2_FIELD_NONE;
 		else if (pix_fmt_mp->field != V4L2_FIELD_NONE)
-			pr_info("%s, field: %u, fmt: %u\n",
+			pr_info("%s, field: %u, fmt: %x\n",
 				__func__, pix_fmt_mp->field,
 				pix_fmt_mp->pixelformat);
 	} else if (!V4L2_TYPE_IS_OUTPUT(f->type)) {
@@ -1558,7 +1628,7 @@ static int vidioc_try_fmt_vid_cap_mplane(struct file *file, void *priv,
 	struct aml_vcodec_ctx *ctx = fh_to_ctx(priv);
 
 	v4l_dbg(ctx, V4L_DEBUG_CODEC_PROT,
-		"%s, type: %u, planes: %u, fmt: %u\n",
+		"%s, type: %u, planes: %u, fmt: %x\n",
 		__func__, f->type, f->fmt.pix_mp.num_planes,
 		f->fmt.pix_mp.pixelformat);
 
@@ -1577,7 +1647,7 @@ static int vidioc_try_fmt_vid_out_mplane(struct file *file, void *priv,
 	struct aml_vcodec_ctx *ctx = fh_to_ctx(priv);
 
 	v4l_dbg(ctx, V4L_DEBUG_CODEC_PROT,
-		"%s, type: %u, planes: %u, fmt: %u\n",
+		"%s, type: %u, planes: %u, fmt: %x\n",
 		__func__, f->type, f->fmt.pix_mp.num_planes,
 		f->fmt.pix_mp.pixelformat);
 
@@ -1599,29 +1669,34 @@ static int vidioc_vdec_g_selection(struct file *file, void *priv,
 {
 	struct aml_vcodec_ctx *ctx = fh_to_ctx(priv);
 	struct aml_q_data *q_data;
+	int ratio = 1;
 
 	if ((s->type != V4L2_BUF_TYPE_VIDEO_CAPTURE) &&
 		(s->type != V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE))
 		return -EINVAL;
 
+	if (ctx->state >= AML_STATE_PROBE) {
+		unsigned int dw_mode = VDEC_DW_NO_AFBC;
+		if (vdec_if_get_param(ctx, GET_PARAM_DW_MODE, &dw_mode))
+			return -EBUSY;
+		ratio = get_double_write_ratio(dw_mode);
+	}
+
 	q_data = &ctx->q_data[AML_Q_DATA_DST];
 
 	switch (s->target) {
 	case V4L2_SEL_TGT_COMPOSE_DEFAULT:
 	case V4L2_SEL_TGT_COMPOSE:
-		if (vdec_if_get_param(ctx, GET_PARAM_CROP_INFO, &(s->r))) {
-			/* set to default value if header info not ready yet*/
-			s->r.left = 0;
-			s->r.top = 0;
-			s->r.width = q_data->visible_width;
-			s->r.height = q_data->visible_height;
-		}
+		s->r.left = 0;
+		s->r.top = 0;
+		s->r.width = ctx->picinfo.visible_width/ratio;
+		s->r.height = ctx->picinfo.visible_height/ratio;
 		break;
 	case V4L2_SEL_TGT_COMPOSE_BOUNDS:
 		s->r.left = 0;
 		s->r.top = 0;
-		s->r.width = ctx->picinfo.coded_width;
-		s->r.height = ctx->picinfo.coded_height;
+		s->r.width = ctx->picinfo.coded_width/ratio;
+		s->r.height = ctx->picinfo.coded_height/ratio;
 		break;
 	default:
 		return -EINVAL;
@@ -1644,6 +1719,7 @@ static int vidioc_vdec_g_selection(struct file *file, void *priv,
 static int vidioc_vdec_s_selection(struct file *file, void *priv,
 	struct v4l2_selection *s)
 {
+	int ratio = 1;
 	struct aml_vcodec_ctx *ctx = fh_to_ctx(priv);
 
 	v4l_dbg(ctx, V4L_DEBUG_CODEC_PROT, "%s, type: %d\n",
@@ -1652,12 +1728,19 @@ static int vidioc_vdec_s_selection(struct file *file, void *priv,
 	if (s->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
 		return -EINVAL;
 
+	if (ctx->state >= AML_STATE_PROBE) {
+		unsigned int dw_mode = VDEC_DW_NO_AFBC;
+		if (vdec_if_get_param(ctx, GET_PARAM_DW_MODE, &dw_mode))
+			return -EBUSY;
+		ratio = get_double_write_ratio(dw_mode);
+	}
+
 	switch (s->target) {
 	case V4L2_SEL_TGT_COMPOSE:
 		s->r.left = 0;
 		s->r.top = 0;
-		s->r.width = ctx->picinfo.visible_width;
-		s->r.height = ctx->picinfo.visible_height;
+		s->r.width = ctx->picinfo.visible_width/ratio;
+		s->r.height = ctx->picinfo.visible_height/ratio;
 		break;
 	default:
 		return -EINVAL;
@@ -1666,6 +1749,41 @@ static int vidioc_vdec_s_selection(struct file *file, void *priv,
 	return 0;
 }
 
+/* called when it is beyong AML_STATE_PROBE */
+static void update_ctx_dimension(struct aml_vcodec_ctx *ctx, u32 type,
+		struct aml_video_fmt *fmt)
+{
+	struct aml_q_data *q_data;
+	unsigned int dw_mode = VDEC_DW_NO_AFBC;
+	int ratio = 1;
+
+	q_data = aml_vdec_get_q_data(ctx, type);
+	if (vdec_if_get_param(ctx, GET_PARAM_DW_MODE, &dw_mode))
+		return;
+
+	ratio = get_double_write_ratio(dw_mode);
+	/* Until STREAMOFF is called on the CAPTURE queue
+	 * (acknowledging the event), the driver operates as if
+	 * the resolution hasn't changed yet.
+	 * So we just return picinfo yet, and update picinfo in
+	 * stop_streaming hook function
+	 */
+	/* it is used for alloc the decode buffer size. */
+	if (fmt->num_planes == 1) {
+		q_data->sizeimage[0] = ctx->picinfo.y_len_sz + ctx->picinfo.c_len_sz;
+	} else if (fmt->num_planes == 2) {
+		q_data->sizeimage[0] = ctx->picinfo.y_len_sz;
+		q_data->sizeimage[1] = ctx->picinfo.c_len_sz;
+	}
+
+	/* it is used for alloc the EGL image buffer size. */
+	q_data->coded_width = ctx->picinfo.coded_width/ratio;
+	q_data->coded_height = ctx->picinfo.coded_height/ratio;
+
+	q_data->bytesperline[0] = ctx->picinfo.coded_width/ratio;
+	q_data->bytesperline[1] = ctx->picinfo.coded_width/ratio;
+}
+
 static void copy_v4l2_format_dimention(struct v4l2_pix_format_mplane *pix_mp,
 		struct aml_q_data *q_data, u32 type)
 {
@@ -1710,7 +1828,7 @@ static int vidioc_vdec_s_fmt(struct file *file, void *priv,
 	struct aml_video_fmt *fmt;
 
 	v4l_dbg(ctx, V4L_DEBUG_CODEC_PROT,
-		"%s, type: %u, planes: %u, fmt: %u\n",
+		"%s, type: %u, planes: %u, fmt: %x\n",
 		__func__, f->type, f->fmt.pix_mp.num_planes,
 		f->fmt.pix_mp.pixelformat);
 
@@ -1734,14 +1852,11 @@ static int vidioc_vdec_s_fmt(struct file *file, void *priv,
 	fmt = aml_vdec_find_format(f);
 	if (fmt == NULL) {
 		if (f->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {
-			f->fmt.pix.pixelformat =
-				aml_video_formats[OUT_FMT_IDX].fourcc;
-			fmt = aml_vdec_find_format(f);
+			fmt = &aml_video_formats[OUT_FMT_IDX];
 		} else if (!V4L2_TYPE_IS_OUTPUT(f->type)) {
-			f->fmt.pix.pixelformat =
-				aml_video_formats[CAP_FMT_IDX].fourcc;
-			fmt = aml_vdec_find_format(f);
+			fmt = &aml_video_formats[CAP_FMT_IDX];
 		}
+		f->fmt.pix.pixelformat = fmt->fourcc;
 	}
 
 	q_data->fmt = fmt;
@@ -1758,6 +1873,7 @@ static int vidioc_vdec_s_fmt(struct file *file, void *priv,
 			pix_mp->width, pix_mp->height,
 			pix_mp->plane_fmt[0].sizeimage);
 
+		ctx->output_pix_fmt = pix_mp->pixelformat;
 		ctx->colorspace = f->fmt.pix_mp.colorspace;
 		ctx->ycbcr_enc = f->fmt.pix_mp.ycbcr_enc;
 		ctx->quantization = f->fmt.pix_mp.quantization;
@@ -1782,8 +1898,10 @@ static int vidioc_vdec_s_fmt(struct file *file, void *priv,
 
 	if (!V4L2_TYPE_IS_OUTPUT(f->type)) {
 		ctx->cap_pix_fmt = pix_mp->pixelformat;
-		if (ctx->state >= AML_STATE_PROBE)
+		if (ctx->state >= AML_STATE_PROBE) {
+			update_ctx_dimension(ctx, f->type, fmt);
 			copy_v4l2_format_dimention(pix_mp, q_data, f->type);
+		}
 	}
 
 	return 0;
@@ -1833,16 +1951,31 @@ static int vidioc_enum_framesizes(struct file *file, void *priv,
 static int vidioc_enum_fmt(struct v4l2_fmtdesc *f, bool output_queue)
 {
 	struct aml_video_fmt *fmt;
-	int i, j = 0;
+	int i = 0, j = 0;
+
+	/* I420 only used for mjpeg. */
+	if (!output_queue && support_mjpeg && support_format_I420) {
+		for (i = 0; i < NUM_FORMATS; i++) {
+			fmt = &aml_video_formats[i];
+			if ((fmt->fourcc == V4L2_PIX_FMT_YUV420) ||
+				(fmt->fourcc == V4L2_PIX_FMT_YUV420M)) {
+				break;
+			}
+		}
+	}
 
-	for (i = 0; i < NUM_FORMATS; i++) {
-		if (output_queue && (aml_video_formats[i].type != AML_FMT_DEC))
+	for (; i < NUM_FORMATS; i++) {
+		fmt = &aml_video_formats[i];
+		if (output_queue && (fmt->type != AML_FMT_DEC))
 			continue;
-		if (!output_queue && (aml_video_formats[i].type != AML_FMT_FRAME))
+		if (!output_queue && (fmt->type != AML_FMT_FRAME))
+			continue;
+		if (support_mjpeg && !support_format_I420 &&
+			((fmt->fourcc == V4L2_PIX_FMT_YUV420) ||
+			(fmt->fourcc == V4L2_PIX_FMT_YUV420M)))
 			continue;
 
 		if (j == f->index) {
-			fmt = &aml_video_formats[i];
 			f->pixelformat = fmt->fourcc;
 			return 0;
 		}
@@ -1897,23 +2030,7 @@ static int vidioc_vdec_g_fmt(struct file *file, void *priv,
 
 	if ((!V4L2_TYPE_IS_OUTPUT(f->type)) &&
 	    (ctx->state >= AML_STATE_PROBE)) {
-		/* Until STREAMOFF is called on the CAPTURE queue
-		 * (acknowledging the event), the driver operates as if
-		 * the resolution hasn't changed yet.
-		 * So we just return picinfo yet, and update picinfo in
-		 * stop_streaming hook function
-		 */
-		/* it is used for alloc the decode buffer size. */
-		q_data->sizeimage[0] = ctx->picinfo.y_len_sz;
-		q_data->sizeimage[1] = ctx->picinfo.c_len_sz;
-
-		/* it is used for alloc the EGL image buffer size. */
-		q_data->coded_width = ctx->picinfo.coded_width;
-		q_data->coded_height = ctx->picinfo.coded_height;
-
-		q_data->bytesperline[0] = ctx->picinfo.coded_width;
-		q_data->bytesperline[1] = ctx->picinfo.coded_width;
-
+		update_ctx_dimension(ctx, f->type, q_data->fmt);
 		copy_v4l2_format_dimention(pix_mp, q_data, f->type);
 	} else if (f->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {
 		/*
@@ -1933,7 +2050,7 @@ static int vidioc_vdec_g_fmt(struct file *file, void *priv,
 	}
 
 	v4l_dbg(ctx, V4L_DEBUG_CODEC_PROT,
-		"%s, type: %u, planes: %u, fmt: %u\n",
+		"%s, type: %u, planes: %u, fmt: %x\n",
 		__func__, f->type, f->fmt.pix_mp.num_planes,
 		f->fmt.pix_mp.pixelformat);
 
@@ -1995,11 +2112,18 @@ static int vb2ops_vdec_queue_setup(struct vb2_queue *vq,
 			alloc_devs[i] = v4l_get_dev_from_codec_mm();//alloc mm from the codec mm
 		}
 	} else {
+		int dw_mode = VDEC_DW_NO_AFBC;
+
 		if (vq->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE)
 			*nplanes = 2;
 		else
 			*nplanes = 1;
 
+		if (vdec_if_get_param(ctx, GET_PARAM_DW_MODE, &dw_mode))
+			return -EACCES;
+		if (dw_mode == VDEC_DW_AFBC_ONLY)
+			*nplanes = 1;
+
 		for (i = 0; i < *nplanes; i++) {
 			sizes[i] = q_data->sizeimage[i];
 			if (V4L2_TYPE_IS_OUTPUT(vq->type) && ctx->output_dma_mode)
@@ -2044,6 +2168,222 @@ static int vb2ops_vdec_buf_prepare(struct vb2_buffer *vb)
 	return 0;
 }
 
+static int init_mmu_bmmu_box(struct aml_vcodec_ctx *ctx)
+{
+	int i;
+	int mmu_flag = ctx->is_drm_mode? CODEC_MM_FLAGS_TVP:0;
+	int bmmu_flag = mmu_flag;
+
+	ctx->comp_bufs = kzalloc(sizeof(*ctx->comp_bufs) * V4L_CAP_BUFF_MAX,
+			GFP_KERNEL);
+	if (!ctx->comp_bufs)
+		return -ENOMEM;
+
+	/* init bmmu box */
+	ctx->mmu_box = decoder_mmu_box_alloc_box("v4l2_dec",
+			ctx->id, V4L_CAP_BUFF_MAX,
+			ctx->comp_info.max_size * SZ_1M, mmu_flag);
+	if (!ctx->mmu_box) {
+		v4l_dbg(ctx, V4L_DEBUG_CODEC_ERROR, "fail to create bmmu box\n");
+		return -EINVAL;
+	}
+
+	/* init mmu box */
+	bmmu_flag |= CODEC_MM_FLAGS_CMA_CLEAR | CODEC_MM_FLAGS_FOR_VDECODER;
+	ctx->bmmu_box  = decoder_bmmu_box_alloc_box("v4l2_dec",
+			ctx->id, V4L_CAP_BUFF_MAX,
+			4 + PAGE_SHIFT, bmmu_flag);
+	if (!ctx->bmmu_box) {
+		v4l_dbg(ctx, V4L_DEBUG_CODEC_ERROR, "fail to create mmu box\n");
+		goto free_mmubox;
+	}
+
+	kref_init(&ctx->box_ref);
+	for (i = 0; i < V4L_CAP_BUFF_MAX; i++) {
+		struct internal_comp_buf *buf;
+		buf = &ctx->comp_bufs[i];
+		buf->index = i;
+		buf->ref = 0;
+		buf->box_ref = &ctx->box_ref;
+		buf->mmu_box = ctx->mmu_box;
+		buf->bmmu_box = ctx->bmmu_box;
+	}
+	kref_get(&ctx->ctx_ref);
+
+	ctx->uvm_proxy = kzalloc(sizeof(*ctx->uvm_proxy) * V4L_CAP_BUFF_MAX,
+			GFP_KERNEL);
+	if (!ctx->uvm_proxy)
+		goto free_mmubox;
+
+	v4l_dbg(ctx, V4L_DEBUG_CODEC_PRINFO, "box init, bmmu: %px, mmu: %px\n",
+		ctx->bmmu_box, ctx->mmu_box);
+
+	return 0;
+
+free_mmubox:
+	decoder_mmu_box_free(ctx->mmu_box);
+	ctx->mmu_box = NULL;
+	return -1;
+}
+
+void aml_v4l_ctx_release(struct kref *kref)
+{
+	struct aml_vcodec_ctx * ctx;
+
+	ctx = container_of(kref, struct aml_vcodec_ctx, ctx_ref);
+	kfree(ctx);
+}
+
+static void box_release(struct kref *kref)
+{
+	struct aml_vcodec_ctx * ctx
+		= container_of(kref, struct aml_vcodec_ctx, box_ref);
+
+	v4l_dbg(ctx, V4L_DEBUG_CODEC_PRINFO,
+		"%s, bmmu: %px, mmu: %px\n",
+		__func__, ctx->bmmu_box, ctx->mmu_box);
+
+	decoder_bmmu_box_free(ctx->bmmu_box);
+	decoder_mmu_box_free(ctx->mmu_box);
+	kfree(ctx->comp_bufs);
+	kref_put(&ctx->ctx_ref, aml_v4l_ctx_release);
+}
+
+static void internal_buf_free(void *arg)
+{
+	struct internal_comp_buf* ibuf =
+		(struct internal_comp_buf*)arg;
+
+	pr_info("%s, idx:%d\n", __func__, ibuf->index);
+	ibuf->ref = 0;
+	decoder_mmu_box_free_idx(ibuf->mmu_box, ibuf->index);
+	decoder_bmmu_box_free_idx(ibuf->bmmu_box, ibuf->index);
+	kref_put(ibuf->box_ref, box_release);
+}
+
+static void internal_buf_free2(void *arg)
+{
+	struct internal_comp_buf *ibuf =
+		container_of(arg, struct internal_comp_buf, priv_data);
+	struct file_private_data *priv_data =
+		(struct file_private_data *) arg;
+
+	pr_info("[%d]: %s, idx: %d\n",
+		priv_data->v4l_inst_id,
+		__func__, ibuf->index);
+
+	ibuf->ref = 0;
+	decoder_mmu_box_free_idx(ibuf->mmu_box, ibuf->index);
+	decoder_bmmu_box_free_idx(ibuf->bmmu_box, ibuf->index);
+	kref_put(ibuf->box_ref, box_release);
+}
+
+static int uvm_attach_hook_mod_local(struct aml_vcodec_ctx *ctx,
+				     struct uvm_hook_mod_info *uvm)
+{
+	struct internal_comp_buf* ibuf = uvm->arg;
+
+	ctx->uvm_proxy[ibuf->index] = *uvm;
+
+	return 0;
+}
+
+static int bind_comp_buffer_to_uvm(struct aml_vcodec_ctx *ctx,
+		struct aml_video_dec_buf *buf)
+{
+	struct dma_buf * dma = buf->vb.vb2_buf.planes[0].dbuf;
+	struct aml_dec_params *parms = &ctx->config.parm.dec;
+	struct uvm_hook_mod_info u_info;
+	int ret, i;
+	struct internal_comp_buf* ibuf;
+
+	/* get header and page size */
+	if (vdec_if_get_param(ctx, GET_PARAM_COMP_BUF_INFO, &ctx->comp_info)) {
+		v4l_dbg(ctx, V4L_DEBUG_CODEC_ERROR, "fail to get comp info\n");
+		return -EINVAL;
+	}
+
+	if (!ctx->bmmu_box || !ctx->mmu_box)
+		if (init_mmu_bmmu_box(ctx))
+			return -EINVAL;
+
+	for (i = 0; i < V4L_CAP_BUFF_MAX; i++) {
+		if (!ctx->comp_bufs[i].ref)
+			break;
+	}
+	if (i == V4L_CAP_BUFF_MAX) {
+		v4l_dbg(ctx, V4L_DEBUG_CODEC_ERROR, "out of internal buf\n");
+		return -EINVAL;
+	}
+
+	buf->internal_index = i;
+	ibuf = &ctx->comp_bufs[i];
+	ibuf->frame_buffer_size = ctx->comp_info.frame_buffer_size;
+
+	/* allocate header */
+	ret = decoder_bmmu_box_alloc_buf_phy(ctx->bmmu_box,
+			ibuf->index, ctx->comp_info.header_size,
+			"v4l2_dec", &ibuf->header_addr);
+	if (ret < 0) {
+		v4l_dbg(ctx, V4L_DEBUG_CODEC_ERROR, "fail to alloc %dth bmmu\n", i);
+		return -ENOMEM;
+	}
+	kref_get(&ctx->box_ref);
+	ibuf->ref = 1;
+
+	/* frame SG buffer need to be realloc inside decoder,
+	 * just before slice decoding to save memory
+	 */
+	u_info.type = VF_SRC_DECODER;
+	u_info.arg = ibuf;
+	u_info.free = internal_buf_free;
+
+	if (parms->cfg.uvm_hook_type == VF_PROCESS_V4LVIDEO) {
+		/* adapted video composer to use for hwc. */
+		ibuf->priv_data.v4l_inst_id = ctx->id;
+		u_info.type = VF_PROCESS_V4LVIDEO;
+		u_info.arg = &ibuf->priv_data;
+		u_info.free = internal_buf_free2;
+	}
+
+	ret = dmabuf_is_uvm(dma) ?
+		uvm_attach_hook_mod(dma, &u_info) :
+		uvm_attach_hook_mod_local(ctx, &u_info);
+	if (ret < 0) {
+		v4l_dbg(ctx, V4L_DEBUG_CODEC_ERROR, "fail to set dmabuf priv buf\n");
+		goto bmmu_box_free;
+	}
+
+	v4l_dbg(ctx, V4L_DEBUG_CODEC_BUFMGR,
+		"bind vb2:%d <--> internal: %d header_addr 0x%lx, size: %u\n",
+		buf->vb.vb2_buf.index, i,
+		ibuf->header_addr,
+		ctx->comp_info.header_size);
+
+	return 0;
+
+bmmu_box_free:
+	decoder_bmmu_box_free_idx(ibuf->bmmu_box, ibuf->index);
+	kref_put(&ctx->box_ref, box_release);
+	ibuf->ref = 0;
+	return -EINVAL;
+}
+
+static int vb_to_seq(struct aml_vcodec_ctx *ctx, int idx_vb)
+{
+	int i;
+
+	for (i = 0; i < V4L_CAP_BUFF_MAX; i++) {
+		if (!ctx->cap_pool.seq[i])
+			continue;
+
+		if (idx_vb == (ctx->cap_pool.seq[i] & 0xffff))
+			break;
+	}
+
+	return i;
+}
+
 static void vb2ops_vdec_buf_queue(struct vb2_buffer *vb)
 {
 	struct aml_vcodec_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);
@@ -2051,6 +2391,7 @@ static void vb2ops_vdec_buf_queue(struct vb2_buffer *vb)
 	struct aml_video_dec_buf *buf = NULL;
 	struct aml_vcodec_mem src_mem;
 	unsigned int dpb = 0;
+	u32 mode;
 
 	vb2_v4l2 = to_vb2_v4l2_buffer(vb);
 	buf = container_of(vb2_v4l2, struct aml_video_dec_buf, vb);
@@ -2063,10 +2404,17 @@ static void vb2ops_vdec_buf_queue(struct vb2_buffer *vb)
 	 * check if this buffer is ready to be used after decode
 	 */
 	if (!V4L2_TYPE_IS_OUTPUT(vb->vb2_queue->type)) {
-		if (vb->index >= ctx->dpb_size) {
+		unsigned int dw_mode = VDEC_DW_NO_AFBC;
+
+		if (vdec_if_get_param(ctx, GET_PARAM_DW_MODE, &dw_mode)) {
+			v4l_dbg(ctx, V4L_DEBUG_CODEC_ERROR, "invalid dw_mode\n");
+			return;
+
+		}
+		if (vb->index >= CTX_BUF_TOTAL(ctx)) {
 			v4l_dbg(ctx, V4L_DEBUG_CODEC_BUFMGR,
 				"enque capture buf idx %d/%d is invalid.\n",
-				vb->index, ctx->dpb_size);
+				vb->index, CTX_BUF_TOTAL(ctx));
 			return;
 		}
 
@@ -2081,24 +2429,34 @@ static void vb2ops_vdec_buf_queue(struct vb2_buffer *vb)
 				"enque capture buf idx %d, vf: %lx\n",
 				vb->index, (ulong) v4l_get_vf_handle(vb2_v4l2->private));
 
+			/* bind compressed buffer to uvm */
+			if ((dw_mode != VDEC_DW_NO_AFBC) &&
+				vb->memory == VB2_MEMORY_DMABUF &&
+				bind_comp_buffer_to_uvm(ctx, buf)) {
+				v4l_dbg(ctx, V4L_DEBUG_CODEC_ERROR, "fail to bind comp buffer\n");
+				return;
+			}
+
 			v4l2_m2m_buf_queue(ctx->m2m_ctx, vb2_v4l2);
 			buf->que_in_m2m = true;
-			buf->queued_in_vb2 = true;
-			buf->queued_in_v4l2 = true;
-			buf->ready_to_display = false;
 			ctx->cap_pool.seq[ctx->cap_pool.in++] =
 				(V4L_CAP_BUFF_IN_M2M << 16 | vb->index);
 
 			/* check dpb ready */
 			aml_check_dpb_ready(ctx);
 		} else if (buf->frame_buffer.status == FB_ST_DISPLAY) {
-			buf->queued_in_vb2 = false;
-			buf->queued_in_v4l2 = true;
-			buf->ready_to_display = false;
+			u32 state = (ctx->cap_pool.seq[vb_to_seq(ctx, vb->index)] >> 16);
 
 			/* recycle vf */
-			video_vf_put(ctx->ada_ctx->recv_name,
-				&buf->frame_buffer, ctx->id);
+			if (state == V4L_CAP_BUFF_IN_DEC) {
+				video_vf_put(ctx->ada_ctx->recv_name,
+					&buf->frame_buffer, ctx->id);
+			} else if (state == V4L_CAP_BUFF_IN_VPP) {
+				struct vframe_s *vf =
+					(struct vframe_s *)buf->frame_buffer.vf_handle;
+
+				aml_v4l2_vpp_rel_vframe(ctx->vpp, vf);
+			}
 		}
 		return;
 	}
@@ -2161,6 +2519,13 @@ static void vb2ops_vdec_buf_queue(struct vb2_buffer *vb)
 	if (!dpb)
 		return;
 
+	if (vpp_needed(ctx, &mode)) {
+		ctx->vpp_size = aml_v4l2_vpp_get_buf_num(mode);
+		v4l_dbg(ctx, V4L_DEBUG_VPP_BUFMGR,
+				"vpp_size:%d\n", ctx->vpp_size);
+	} else
+		ctx->vpp_size = 0;
+
 	ctx->dpb_size = dpb;
 	ctx->last_decoded_picinfo = ctx->picinfo;
 	aml_vdec_dispatch_event(ctx, V4L2_EVENT_SRC_CH_RESOLUTION);
@@ -2180,22 +2545,15 @@ static void vb2ops_vdec_buf_finish(struct vb2_buffer *vb)
 	struct aml_vcodec_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);
 	struct vb2_v4l2_buffer *vb2_v4l2 = NULL;
 	struct aml_video_dec_buf *buf = NULL;
-	bool buf_error;
 
 	v4l_dbg(ctx, V4L_DEBUG_CODEC_PROT,
 		"%s, type: %d, idx: %d\n",
 		__func__, vb->vb2_queue->type, vb->index);
 
-	vb2_v4l2 = container_of(vb, struct vb2_v4l2_buffer, vb2_buf);
+	vb2_v4l2 = to_vb2_v4l2_buffer(vb);
 	buf = container_of(vb2_v4l2, struct aml_video_dec_buf, vb);
 
-	if (!V4L2_TYPE_IS_OUTPUT(vb->vb2_queue->type)) {
-		buf->queued_in_v4l2 = false;
-		buf->queued_in_vb2 = false;
-	}
-	buf_error = buf->error;
-
-	if (buf_error) {
+	if (buf->error) {
 		v4l_dbg(ctx, V4L_DEBUG_CODEC_ERROR,
 			"Unrecoverable error on buffer.\n");
 		ctx->state = AML_STATE_ABORT;
@@ -2213,15 +2571,12 @@ static int vb2ops_vdec_buf_init(struct vb2_buffer *vb)
 	struct aml_video_dec_buf *buf = container_of(vb2_v4l2,
 					struct aml_video_dec_buf, vb);
 	unsigned int size, phy_addr = 0;
-	char *owner = __getname();
 
 	v4l_dbg(ctx, V4L_DEBUG_CODEC_PROT, "%s, type: %d, idx: %d\n",
 		__func__, vb->vb2_queue->type, vb->index);
 
 	if (!V4L2_TYPE_IS_OUTPUT(vb->vb2_queue->type)) {
 		buf->used = false;
-		buf->ready_to_display = false;
-		buf->queued_in_v4l2 = false;
 		buf->frame_buffer.status = FB_ST_NORMAL;
 	} else {
 		buf->lastframe = false;
@@ -2230,11 +2585,14 @@ static int vb2ops_vdec_buf_init(struct vb2_buffer *vb)
 	/* codec_mm buffers count */
 	if (V4L2_TYPE_IS_OUTPUT(vb->type)) {
 		if (vb->memory == VB2_MEMORY_MMAP) {
+			char *owner = __getname();
+
 			size = vb->planes[0].length;
 			phy_addr = vb2_dma_contig_plane_dma_addr(vb, 0);
 			snprintf(owner, PATH_MAX, "%s-%d", "v4l-input", ctx->id);
 			strncpy(buf->mem_onwer, owner, sizeof(buf->mem_onwer));
 			buf->mem_onwer[sizeof(buf->mem_onwer) - 1] = '\0';
+			__putname(owner);
 
 			buf->mem[0] = v4l_reqbufs_from_codec_mm(buf->mem_onwer,
 					phy_addr, size, vb->index);
@@ -2243,39 +2601,49 @@ static int vb2ops_vdec_buf_init(struct vb2_buffer *vb)
 				phy_addr, size, vb->index);
 		}
 	} else {
-		snprintf(owner, PATH_MAX, "%s-%d", "v4l-output", ctx->id);
-		strncpy(buf->mem_onwer, owner, sizeof(buf->mem_onwer));
-		buf->mem_onwer[sizeof(buf->mem_onwer) - 1] = '\0';
+		int i;
 
-		if ((vb->memory == VB2_MEMORY_MMAP) && (vb->num_planes == 1)) {
-			size = vb->planes[0].length;
-			phy_addr = vb2_dma_contig_plane_dma_addr(vb, 0);
-			buf->mem[0] = v4l_reqbufs_from_codec_mm(buf->mem_onwer,
-				phy_addr, size, vb->index);
-			v4l_dbg(ctx, V4L_DEBUG_CODEC_BUFMGR,
-				"OUT Y alloc, addr: %x, size: %u, idx: %u\n",
-				phy_addr, size, vb->index);
-		} else if ((vb->memory == VB2_MEMORY_MMAP) && (vb->num_planes == 2)) {
-			size = vb->planes[0].length;
-			phy_addr = vb2_dma_contig_plane_dma_addr(vb, 0);
-			buf->mem[0] = v4l_reqbufs_from_codec_mm(buf->mem_onwer,
-				phy_addr, size, vb->index);
-			v4l_dbg(ctx, V4L_DEBUG_CODEC_BUFMGR,
-				"OUT Y alloc, addr: %x, size: %u, idx: %u\n",
-				phy_addr, size, vb->index);
+		if (vb->memory == VB2_MEMORY_MMAP) {
+			char *owner = __getname();
 
-			size = vb->planes[1].length;
-			phy_addr = vb2_dma_contig_plane_dma_addr(vb, 1);
-			buf->mem[1] = v4l_reqbufs_from_codec_mm(buf->mem_onwer,
-					phy_addr, size, vb->index);
-			v4l_dbg(ctx, V4L_DEBUG_CODEC_BUFMGR,
-				"OUT C alloc, addr: %x, size: %u, idx: %u\n",
-				phy_addr, size, vb->index);
+			snprintf(owner, PATH_MAX, "%s-%d", "v4l-output", ctx->id);
+			strncpy(buf->mem_onwer, owner, sizeof(buf->mem_onwer));
+			buf->mem_onwer[sizeof(buf->mem_onwer) - 1] = '\0';
+			__putname(owner);
+
+			for (i = 0; i < vb->num_planes; i++) {
+				size = vb->planes[i].length;
+				phy_addr = vb2_dma_contig_plane_dma_addr(vb, i);
+				buf->mem[i] = v4l_reqbufs_from_codec_mm(buf->mem_onwer,
+						phy_addr, size, vb->index);
+				v4l_dbg(ctx, V4L_DEBUG_CODEC_BUFMGR,
+						"OUT %c alloc, addr: %x, size: %u, idx: %u\n",
+						(i == 0? 'Y':'C'), phy_addr, size, vb->index);
+			}
+		} else if (vb->memory == VB2_MEMORY_DMABUF) {
+			unsigned int dw_mode = VDEC_DW_NO_AFBC;
+
+			for (i = 0; i < vb->num_planes; i++) {
+				struct dma_buf * dma;
+
+				if (vdec_if_get_param(ctx, GET_PARAM_DW_MODE, &dw_mode)) {
+					v4l_dbg(ctx, V4L_DEBUG_CODEC_ERROR, "invalid dw_mode\n");
+					return -EINVAL;
+				}
+				/* None-DW mode means single layer */
+				if (dw_mode == VDEC_DW_AFBC_ONLY && i > 0) {
+					v4l_dbg(ctx, V4L_DEBUG_CODEC_ERROR,
+							"only support single plane in dw mode 0\n");
+					return -EINVAL;
+				}
+				size = vb->planes[i].length;
+				dma = vb->planes[i].dbuf;
+
+				if (!dmabuf_is_uvm(dma))
+					v4l_dbg(ctx, V4L_DEBUG_CODEC_PRINFO, "non-uvm dmabuf\n");
+			}
 		}
 	}
-
-	__putname(owner);
-
 	return 0;
 }
 
@@ -2303,17 +2671,16 @@ static void codec_mm_bufs_cnt_clean(struct vb2_queue *q)
 		}
 
 		if (q->memory == VB2_MEMORY_MMAP) {
-			v4l_freebufs_back_to_codec_mm(buf->mem_onwer, buf->mem[0]);
-			v4l_freebufs_back_to_codec_mm(buf->mem_onwer, buf->mem[1]);
-
-			v4l_dbg(ctx, V4L_DEBUG_CODEC_BUFMGR,
-				"OUT Y clean, addr: %lx, size: %u, idx: %u\n",
-				buf->mem[0]->phy_addr, buf->mem[0]->buffer_size, i);
-			v4l_dbg(ctx, V4L_DEBUG_CODEC_BUFMGR,
-				"OUT C clean, addr: %lx, size: %u, idx: %u\n",
-				buf->mem[1]->phy_addr, buf->mem[1]->buffer_size, i);
-			buf->mem[0] = NULL;
-			buf->mem[1] = NULL;
+			int j;
+
+			for (j = 0; j < q->bufs[i]->num_planes ; j++) {
+				v4l_freebufs_back_to_codec_mm(buf->mem_onwer, buf->mem[j]);
+				v4l_dbg(ctx, V4L_DEBUG_CODEC_BUFMGR,
+					"OUT %c clean, addr: %lx, size: %u, idx: %u\n",
+					(j == 0)? 'Y':'C',
+					buf->mem[j]->phy_addr, buf->mem[j]->buffer_size, i);
+				buf->mem[j] = NULL;
+			}
 		}
 	}
 }
@@ -2432,7 +2799,7 @@ static int aml_vdec_g_v_ctrl(struct v4l2_ctrl *ctrl)
 	switch (ctrl->id) {
 	case V4L2_CID_MIN_BUFFERS_FOR_CAPTURE:
 		if (ctx->state >= AML_STATE_PROBE) {
-			ctrl->val = ctx->dpb_size;
+			ctrl->val = CTX_BUF_TOTAL(ctx);
 		} else {
 			v4l_dbg(ctx, V4L_DEBUG_CODEC_ERROR,
 				"Seqinfo not ready.\n");
@@ -2546,6 +2913,26 @@ static int vidioc_vdec_g_parm(struct file *file, void *fh,
 	return 0;
 }
 
+static int check_dec_cfginfo(struct aml_vdec_cfg_infos *cfg)
+{
+	if (cfg->double_write_mode != 0 &&
+		cfg->double_write_mode != 1 &&
+		cfg->double_write_mode != 2 &&
+		cfg->double_write_mode != 3 &&
+		cfg->double_write_mode != 4 &&
+		cfg->double_write_mode != 16) {
+		pr_err("invalid double write mode %d\n", cfg->double_write_mode);
+		return -1;
+	}
+	if (cfg->ref_buf_margin > 20) {
+		pr_err("invalid margin %d\n", cfg->ref_buf_margin);
+		return -1;
+	}
+	pr_info("double write mode %d margin %d\n",
+		cfg->double_write_mode, cfg->ref_buf_margin);
+	return 0;
+}
+
 static int vidioc_vdec_s_parm(struct file *file, void *fh,
 	struct v4l2_streamparm *a)
 {
@@ -2553,15 +2940,19 @@ static int vidioc_vdec_s_parm(struct file *file, void *fh,
 
 	v4l_dbg(ctx, V4L_DEBUG_CODEC_PROT, "%s\n", __func__);
 
-	if (a->type == V4L2_BUF_TYPE_VIDEO_OUTPUT) {
+	if (a->type == V4L2_BUF_TYPE_VIDEO_OUTPUT ||
+		a->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {
 		struct aml_dec_params *in =
 			(struct aml_dec_params *) a->parm.raw_data;
 		struct aml_dec_params *dec = &ctx->config.parm.dec;
 
 		ctx->config.type = V4L2_CONFIG_PARM_DECODE;
 
-		if (in->parms_status & V4L2_CONFIG_PARM_DECODE_CFGINFO)
+		if (in->parms_status & V4L2_CONFIG_PARM_DECODE_CFGINFO) {
+			if (check_dec_cfginfo(&in->cfg))
+				return -EINVAL;
 			dec->cfg = in->cfg;
+		}
 		if (in->parms_status & V4L2_CONFIG_PARM_DECODE_PSINFO)
 			dec->ps = in->ps;
 		if (in->parms_status & V4L2_CONFIG_PARM_DECODE_HDRINFO)
@@ -2570,6 +2961,8 @@ static int vidioc_vdec_s_parm(struct file *file, void *fh,
 			dec->cnt = in->cnt;
 
 		dec->parms_status |= in->parms_status;
+		v4l_dbg(ctx, V4L_DEBUG_CODEC_PROT, "%s parms:%x\n",
+				__func__, in->parms_status);
 	}
 
 	return 0;
diff --git a/drivers/amvdec_ports/aml_vcodec_dec.h b/drivers/amvdec_ports/aml_vcodec_dec.h
index 3653ff07..dbee7e75 100644
--- a/drivers/amvdec_ports/aml_vcodec_dec.h
+++ b/drivers/amvdec_ports/aml_vcodec_dec.h
@@ -20,6 +20,7 @@
 #ifndef _AML_VCODEC_DEC_H_
 #define _AML_VCODEC_DEC_H_
 
+#include <linux/kref.h>
 #include <media/videobuf2-core.h>
 #include <media/videobuf2-v4l2.h>
 #include <linux/amlogic/media/codec_mm/codec_mm.h>
@@ -68,10 +69,6 @@ struct vdec_v4l2_buffer {
  * @list:	link list
  * @used:	Capture buffer contain decoded frame data and keep in
  *			codec data structure
- * @ready_to_display:	Capture buffer not display yet
- * @queued_in_vb2:	Capture buffer is queue in vb2
- * @queued_in_v4l2:	Capture buffer is in v4l2 driver, but not in vb2
- *			queue yet
  * @lastframe:		Intput buffer is last buffer - EOS
  * @error:		An unrecoverable error occurs on this buffer.
  * @frame_buffer:	Decode status, and buffer information of Capture buffer
@@ -87,12 +84,14 @@ struct aml_video_dec_buf {
 	struct codec_mm_s *mem[2];
 	char mem_onwer[32];
 	bool used;
-	bool ready_to_display;
 	bool que_in_m2m;
-	bool queued_in_vb2;
-	bool queued_in_v4l2;
 	bool lastframe;
 	bool error;
+
+	/* internal compressed buffer */
+	unsigned int internal_index;
+
+	ulong vpp_buf_handle;
 };
 
 extern const struct v4l2_ioctl_ops aml_vdec_ioctl_ops;
@@ -122,5 +121,6 @@ void wait_vcodec_ending(struct aml_vcodec_ctx *ctx);
 void vdec_frame_buffer_release(void *data);
 void aml_vdec_dispatch_event(struct aml_vcodec_ctx *ctx, u32 changes);
 void* v4l_get_vf_handle(int fd);
+void aml_v4l_ctx_release(struct kref *kref);
 
 #endif /* _AML_VCODEC_DEC_H_ */
diff --git a/drivers/amvdec_ports/aml_vcodec_dec_drv.c b/drivers/amvdec_ports/aml_vcodec_dec_drv.c
index 1ed0b976..4c389944 100644
--- a/drivers/amvdec_ports/aml_vcodec_dec_drv.c
+++ b/drivers/amvdec_ports/aml_vcodec_dec_drv.c
@@ -34,6 +34,7 @@
 #include "aml_vcodec_dec.h"
 #include "aml_vcodec_util.h"
 #include "aml_vcodec_vfm.h"
+#include "aml_vcodec_vpp.h"
 #include <linux/file.h>
 #include <linux/anon_inodes.h>
 
@@ -62,6 +63,8 @@ static int fops_vcodec_open(struct file *file)
 	ctx = kzalloc(sizeof(*ctx), GFP_KERNEL);
 	if (!ctx)
 		return -ENOMEM;
+	kref_init(&ctx->ctx_ref);
+
 	aml_buf = kzalloc(sizeof(*aml_buf), GFP_KERNEL);
 	if (!aml_buf) {
 		kfree(ctx);
@@ -112,6 +115,7 @@ static int fops_vcodec_open(struct file *file)
 	ctx->empty_flush_buf->vb.vb2_buf.vb2_queue = src_vq;
 	ctx->empty_flush_buf->lastframe = true;
 	aml_vcodec_dec_set_default_params(ctx);
+	ctx->is_stream_off = true;
 
 	ret = aml_thread_start(ctx, try_to_capture, AML_THREAD_CAPTURE, "cap");
 	if (ret) {
@@ -151,6 +155,12 @@ static int fops_vcodec_release(struct file *file)
 	v4l_dbg(ctx, V4L_DEBUG_CODEC_PRINFO, "release decoder %lx\n", (ulong) ctx);
 	mutex_lock(&dev->dev_mutex);
 
+	if (ctx->vpp) {
+		mutex_lock(&ctx->state_lock);
+		aml_v4l2_vpp_destroy(ctx->vpp);
+		ctx->vpp = NULL;
+		mutex_unlock(&ctx->state_lock);
+	}
 	/*
 	 * Call v4l2_m2m_ctx_release before aml_vcodec_dec_release. First, it
 	 * makes sure the worker thread is not running after vdec_if_deinit.
@@ -168,7 +178,7 @@ static int fops_vcodec_release(struct file *file)
 
 	list_del_init(&ctx->list);
 	kfree(ctx->empty_flush_buf);
-	kfree(ctx);
+	kref_put(&ctx->ctx_ref, aml_v4l_ctx_release);
 	mutex_unlock(&dev->dev_mutex);
 	return 0;
 }
@@ -302,8 +312,10 @@ void* v4l_get_vf_handle(int fd)
 
 	if (!is_v4l2_buf_file(file)) {
 		fput(file);
+#if 0
 		v4l_dbg(0, V4L_DEBUG_CODEC_ERROR,
 			"the buf file checked fail!\n");
+#endif
 		return NULL;
 	}
 
@@ -616,9 +628,13 @@ bool multiplanar;
 EXPORT_SYMBOL(multiplanar);
 module_param(multiplanar, bool, 0644);
 
-bool dump_capture_frame;
+int dump_capture_frame;
 EXPORT_SYMBOL(dump_capture_frame);
-module_param(dump_capture_frame, bool, 0644);
+module_param(dump_capture_frame, int, 0644);
+
+int dump_vpp_input;
+EXPORT_SYMBOL(dump_vpp_input);
+module_param(dump_vpp_input, int, 0644);
 
 int dump_output_frame;
 EXPORT_SYMBOL(dump_output_frame);
@@ -630,6 +646,18 @@ module_param(param_sets_from_ucode, bool, 0644);
 EXPORT_SYMBOL(enable_drm_mode);
 module_param(enable_drm_mode, bool, 0644);
 
+int bypass_vpp = 1;
+EXPORT_SYMBOL(bypass_vpp);
+module_param(bypass_vpp, int, 0644);
+
+bool support_mjpeg;
+EXPORT_SYMBOL(support_mjpeg);
+module_param(support_mjpeg, bool, 0644);
+
+bool support_format_I420;
+EXPORT_SYMBOL(support_format_I420);
+module_param(support_format_I420, bool, 0644);
+
 MODULE_LICENSE("GPL v2");
 MODULE_DESCRIPTION("AML video codec V4L2 decoder driver");
 
diff --git a/drivers/amvdec_ports/aml_vcodec_drv.h b/drivers/amvdec_ports/aml_vcodec_drv.h
index e9195dcf..23e1b889 100644
--- a/drivers/amvdec_ports/aml_vcodec_drv.h
+++ b/drivers/amvdec_ports/aml_vcodec_drv.h
@@ -20,6 +20,7 @@
 #ifndef _AML_VCODEC_DRV_H_
 #define _AML_VCODEC_DRV_H_
 
+#include <linux/kref.h>
 #include <linux/platform_device.h>
 #include <linux/videodev2.h>
 #include <media/v4l2-ctrls.h>
@@ -27,6 +28,7 @@
 #include <media/v4l2-ioctl.h>
 #include <media/videobuf2-core.h>
 #include <linux/amlogic/media/vfm/vframe.h>
+#include <linux/amlogic/media/video_sink/v4lvideo_ext.h>
 #include "aml_vcodec_util.h"
 
 #define AML_VCODEC_DRV_NAME	"aml_vcodec_drv"
@@ -66,6 +68,7 @@
 #define V4L_CAP_BUFF_INVALID		(0)
 #define V4L_CAP_BUFF_IN_M2M		(1)
 #define V4L_CAP_BUFF_IN_DEC		(2)
+#define V4L_CAP_BUFF_IN_VPP		(3)
 
 /* v4l reset mode */
 #define V4L_RESET_MODE_NORMAL		(1 << 0) /* reset vdec_input and decoder. */
@@ -79,6 +82,7 @@
 /* Instance is currently aborting */
 #define TRANS_ABORT		(1 << 2)
 
+#define CTX_BUF_TOTAL(ctx) (ctx->dpb_size + ctx->vpp_size)
 /**
  * enum aml_hw_reg_idx - AML hw register base index
  */
@@ -183,13 +187,13 @@ enum aml_q_type {
  * struct aml_q_data - Structure used to store information about queue
  */
 struct aml_q_data {
-	unsigned int	visible_width;
-	unsigned int	visible_height;
-	unsigned int	coded_width;
-	unsigned int	coded_height;
+	u32	visible_width;
+	u32	visible_height;
+	u32	coded_width;
+	u32	coded_height;
 	enum v4l2_field	field;
-	unsigned int	bytesperline[AML_VCODEC_MAX_PLANES];
-	unsigned int	sizeimage[AML_VCODEC_MAX_PLANES];
+	u32	bytesperline[AML_VCODEC_MAX_PLANES];
+	u32	sizeimage[AML_VCODEC_MAX_PLANES];
 	struct aml_video_fmt	*fmt;
 	bool resolution_changed;
 };
@@ -214,42 +218,19 @@ struct aml_q_data {
  * @force_intra: force/insert intra frame
  */
 struct aml_enc_params {
-	unsigned int	bitrate;
-	unsigned int	num_b_frame;
-	unsigned int	rc_frame;
-	unsigned int	rc_mb;
-	unsigned int	seq_hdr_mode;
-	unsigned int	intra_period;
-	unsigned int	gop_size;
-	unsigned int	framerate_num;
-	unsigned int	framerate_denom;
-	unsigned int	h264_max_qp;
-	unsigned int	h264_profile;
-	unsigned int	h264_level;
-	unsigned int	force_intra;
-};
-
-/**
- * struct aml_vcodec_pm - Power management data structure
- */
-struct aml_vcodec_pm {
-	struct clk	*vdec_bus_clk_src;
-	struct clk	*vencpll;
-
-	struct clk	*vcodecpll;
-	struct clk	*univpll_d2;
-	struct clk	*clk_cci400_sel;
-	struct clk	*vdecpll;
-	struct clk	*vdec_sel;
-	struct clk	*vencpll_d2;
-	struct clk	*venc_sel;
-	struct clk	*univpll1_d2;
-	struct clk	*venc_lt_sel;
-	struct device	*larbvdec;
-	struct device	*larbvenc;
-	struct device	*larbvenclt;
-	struct device	*dev;
-	struct aml_vcodec_dev	*amldev;
+	u32	bitrate;
+	u32	num_b_frame;
+	u32	rc_frame;
+	u32	rc_mb;
+	u32	seq_hdr_mode;
+	u32	intra_period;
+	u32	gop_size;
+	u32	framerate_num;
+	u32	framerate_denom;
+	u32	h264_max_qp;
+	u32	h264_profile;
+	u32	h264_level;
+	u32	force_intra;
 };
 
 /**
@@ -268,18 +249,30 @@ struct aml_vcodec_pm {
  *      buffer size will be aligned to 176x160.
  */
 struct vdec_pic_info {
-	unsigned int visible_width;
-	unsigned int visible_height;
-	unsigned int coded_width;
-	unsigned int coded_height;
-	unsigned int y_bs_sz;
-	unsigned int c_bs_sz;
-	unsigned int y_len_sz;
-	unsigned int c_len_sz;
+	u32 visible_width;
+	u32 visible_height;
+	u32 coded_width;
+	u32 coded_height;
+	u32 y_bs_sz;
+	u32 c_bs_sz;
+	u32 y_len_sz;
+	u32 c_len_sz;
 	int profile_idc;
 	int ref_frame_count;
 };
 
+/**
+ * struct vdec_comp_buf_info - compressed buffer info
+ * @max_size: max size needed for MMU Box in MB
+ * @header_size: contineous size for the compressed header
+ * @frame_buffer_size: SG page number to store the frame
+ */
+struct vdec_comp_buf_info {
+	u32 max_size;
+	u32 header_size;
+	u32 frame_buffer_size;
+};
+
 struct aml_vdec_cfg_infos {
 	u32 double_write_mode;
 	u32 init_width;
@@ -288,6 +281,7 @@ struct aml_vdec_cfg_infos {
 	u32 canvas_mem_mode;
 	u32 canvas_mem_endian;
 	u32 low_latency_mode;
+	u32 uvm_hook_type;
 };
 
 struct aml_vdec_hdr_infos {
@@ -369,25 +363,49 @@ enum aml_thread_type {
 typedef void (*aml_thread_func)(struct aml_vcodec_ctx *ctx);
 
 struct aml_vdec_thread {
-	struct list_head node;
-	spinlock_t lock;
-	struct semaphore sem;
-	struct task_struct *task;
-	enum aml_thread_type type;
-	void *priv;
-	int stop;
-
-	aml_thread_func func;
+	struct list_head	node;
+	spinlock_t		lock;
+	struct semaphore	sem;
+	struct task_struct	*task;
+	enum aml_thread_type	type;
+	void			*priv;
+	int			stop;
+
+	aml_thread_func		func;
 };
 
+/* struct internal_comp_buf - compressed buffer
+ * @index: index of this buf within (B)MMU BOX
+ * @ref: reference number of this buf
+ * @mmu_box: mmu_box of context
+ * @bmmu_box: bmmu_box of context
+ * @box_ref: box_ref of context
+ * @header_addr: header for compressed buffer
+ * @frame_buffer_size: SG buffer page number from
+ * @priv_data use for video composer
+ *  struct vdec_comp_buf_info
+ */
+struct internal_comp_buf {
+	u32		index;
+	u32		ref;
+	void		*mmu_box;
+	void		*bmmu_box;
+	struct kref	*box_ref;
+
+	ulong		header_addr;
+	u32		frame_buffer_size;
+	struct file_private_data priv_data;
+};
 /**
  * struct aml_vcodec_ctx - Context (instance) private data.
- *
  * @id: index of the context that this structure describes.
+ * @ctx_ref: for deferred free of this context.
  * @type: type of the instance - decoder or encoder.
  * @dev: pointer to the aml_vcodec_dev of the device.
  * @m2m_ctx: pointer to the v4l2_m2m_ctx of the context.
  * @ada_ctx: pointer to the aml_vdec_adapt of the context.
+ * @vpp: pointer to video post processor
+ * @vfm: pointer to video frame manager
  * @dec_if: hooked decoder driver interface.
  * @drv_handle: driver handle for specific decode instance
  * @fh: struct v4l2_fh.
@@ -405,6 +423,7 @@ struct aml_vdec_thread {
  * @cap_pool: capture buffers are remark in the pool.
  * @vdec_thread_list: vdec thread be used to capture.
  * @dpb_size: store dpb count after header parsing
+ * @vpp_size: store vpp buffer count after header parsing
  * @param_change: indicate encode parameter type
  * @param_sets_from_ucode: if true indicate ps from ucode.
  * @v4l_codec_dpb_ready: queue buffer number greater than dpb.
@@ -427,13 +446,21 @@ struct aml_vdec_thread {
  * @reset_flag: reset mode includes lightly and normal mode.
  * @decoded_frame_cnt: the capture buffer deque number to be count.
  * @buf_used_count: means that decode allocate how many buffs from v4l.
+ * @mmu_box: mmu_box of context.
+ * @bmmu_box: bmmu_box of context.
+ * @box_ref: box_ref of context.
+ * @comp_info: compress buffer information.
+ * @comp_bufs: compress buffer describe.
  */
 struct aml_vcodec_ctx {
 	int				id;
+	struct kref			ctx_ref;
 	enum aml_instance_type		type;
 	struct aml_vcodec_dev		*dev;
 	struct v4l2_m2m_ctx		*m2m_ctx;
 	struct aml_vdec_adapt		*ada_ctx;
+	struct aml_v4l2_vpp		*vpp;
+	struct vcodec_vfm_s 		*vfm;
 	const struct vdec_common_if	*dec_if;
 	ulong				drv_handle;
 	struct v4l2_fh			fh;
@@ -452,6 +479,7 @@ struct aml_vcodec_ctx {
 	struct list_head		vdec_thread_list;
 
 	int				dpb_size;
+	int				vpp_size;
 	bool				param_sets_from_ucode;
 	bool				v4l_codec_dpb_ready;
 	bool				v4l_resolution_change;
@@ -464,6 +492,7 @@ struct aml_vcodec_ctx {
 	enum v4l2_quantization		quantization;
 	enum v4l2_xfer_func		xfer_func;
 	u32				cap_pix_fmt;
+	u32				output_pix_fmt;
 
 	bool				has_receive_eos;
 	bool				is_drm_mode;
@@ -474,81 +503,47 @@ struct aml_vcodec_ctx {
 	int				reset_flag;
 	int				decoded_frame_cnt;
 	int				buf_used_count;
+
+	/* compressed buffer support */
+	void				*bmmu_box;
+	void				*mmu_box;
+	struct kref			box_ref;
+	struct vdec_comp_buf_info	comp_info;
+	struct internal_comp_buf	*comp_bufs;
+	struct uvm_hook_mod_info	*uvm_proxy;
 };
 
 /**
- * struct aml_vcodec_dev - driver data
+ * struct aml_vcodec_dev - driver data.
  * @v4l2_dev: V4L2 device to register video devices for.
- * @vfd_dec: Video device for decoder
- * @vfd_enc: Video device for encoder.
- *
- * @m2m_dev_dec: m2m device for decoder
- * @m2m_dev_enc: m2m device for encoder.
- * @plat_dev: platform device
- * @vpu_plat_dev: aml vpu platform device
- * @alloc_ctx: VB2 allocator context
- *	       (for allocations without kernel mapping).
- * @ctx_list: list of struct aml_vcodec_ctx
- * @irqlock: protect data access by irq handler and work thread
- * @curr_ctx: The context that is waiting for codec hardware
- *
- * @reg_base: Mapped address of AML Vcodec registers.
- *
- * @id_counter: used to identify current opened instance
- *
- * @encode_workqueue: encode work queue
- *
- * @int_cond: used to identify interrupt condition happen
- * @int_type: used to identify what kind of interrupt condition happen
- * @dev_mutex: video_device lock
- * @queue: waitqueue for waiting for completion of device commands
- *
- * @dec_irq: decoder irq resource
- * @enc_irq: h264 encoder irq resource
- * @enc_lt_irq: vp8 encoder irq resource
- *
- * @dec_mutex: decoder hardware lock
- * @enc_mutex: encoder hardware lock.
- *
- * @pm: power management control
+ * @vfd_dec: Video device for decoder.
+ * @plat_dev: platform device.
+ * @m2m_dev_dec: m2m device for decoder.
+ * @curr_ctx: The context that is waiting for codec hardware.
+ * @id_counter: used to identify current opened instance.
  * @dec_capability: used to identify decode capability, ex: 4k
- * @enc_capability: used to identify encode capability
+ * @decode_workqueue: the worker used to output buffer schedule.
+ * @ctx_list: list of struct aml_vcodec_ctx.
+ * @irqlock: protect data access by irq handler and work thread.
+ * @dev_mutex: video_device lock.
+ * @dec_mutex: decoder hardware lock.
+ * @queue: waitqueue for waiting for completion of device commands.
  */
 struct aml_vcodec_dev {
-	struct v4l2_device v4l2_dev;
-	struct video_device *vfd_dec;
-	struct video_device *vfd_enc;
-	struct file *filp;
-
-	struct v4l2_m2m_dev *m2m_dev_dec;
-	struct v4l2_m2m_dev *m2m_dev_enc;
-	struct platform_device *plat_dev;
-	struct platform_device *vpu_plat_dev;//??
-	struct vb2_alloc_ctx *alloc_ctx;//??
-	struct list_head ctx_list;
-	spinlock_t irqlock;
-	struct aml_vcodec_ctx *curr_ctx;
-	void __iomem *reg_base[NUM_MAX_VCODEC_REG_BASE];
-
-	unsigned long id_counter;
-
-	struct workqueue_struct *decode_workqueue;
-	struct workqueue_struct *encode_workqueue;
-	int int_cond;
-	int int_type;
-	struct mutex dev_mutex;
-	wait_queue_head_t queue;
-
-	int dec_irq;
-	int enc_irq;
-	int enc_lt_irq;
-
-	struct mutex dec_mutex;
-	struct mutex enc_mutex;
-
-	struct aml_vcodec_pm pm;
-	unsigned int dec_capability;
-	unsigned int enc_capability;
+	struct v4l2_device		v4l2_dev;
+	struct video_device		*vfd_dec;
+	struct platform_device		*plat_dev;
+	struct v4l2_m2m_dev		*m2m_dev_dec;
+	struct aml_vcodec_ctx		*curr_ctx;
+	ulong				id_counter;
+	u32				dec_capability;
+	struct workqueue_struct		*decode_workqueue;
+	struct list_head		ctx_list;
+	struct file			*filp;
+	spinlock_t			irqlock;
+	struct mutex			dev_mutex;
+	struct mutex			dec_mutex;
+	wait_queue_head_t		queue;
 };
 
 static inline struct aml_vcodec_ctx *fh_to_ctx(struct v4l2_fh *fh)
diff --git a/drivers/amvdec_ports/aml_vcodec_util.c b/drivers/amvdec_ports/aml_vcodec_util.c
index 509a42aa..54b0d069 100644
--- a/drivers/amvdec_ports/aml_vcodec_util.c
+++ b/drivers/amvdec_ports/aml_vcodec_util.c
@@ -22,72 +22,6 @@
 #include "aml_vcodec_drv.h"
 #include "aml_vcodec_util.h"
 
-void __iomem *aml_vcodec_get_reg_addr(struct aml_vcodec_ctx *data,
-					unsigned int reg_idx)
-{
-	struct aml_vcodec_ctx *ctx = (struct aml_vcodec_ctx *)data;
-
-	if (!data || reg_idx >= NUM_MAX_VCODEC_REG_BASE) {
-		v4l_dbg(ctx, V4L_DEBUG_CODEC_ERROR,
-			"Invalid arguments, reg_idx=%d\n", reg_idx);
-		return NULL;
-	}
-	return ctx->dev->reg_base[reg_idx];
-}
-EXPORT_SYMBOL(aml_vcodec_get_reg_addr);
-
-int aml_vcodec_mem_alloc(struct aml_vcodec_ctx *data,
-			struct aml_vcodec_mem *mem)
-{
-	unsigned long size = mem->size;
-	struct aml_vcodec_ctx *ctx = (struct aml_vcodec_ctx *)data;
-	struct device *dev = &ctx->dev->plat_dev->dev;
-
-	mem->vaddr = dma_alloc_coherent(dev, size, &mem->dma_addr, GFP_KERNEL);
-	//mem->vaddr = codec_mm_dma_alloc_coherent(dev_name(dev), size,
-	//		&mem->dma_addr, GFP_KERNEL, 0);
-	if (!mem->vaddr) {
-		v4l_dbg(ctx, V4L_DEBUG_CODEC_ERROR,
-			"%s dma_alloc size=%ld failed!\n", dev_name(dev),
-			     size);
-		return -ENOMEM;
-	}
-
-	memset(mem->vaddr, 0, size);
-
-	v4l_dbg(ctx, V4L_DEBUG_CODEC_PRINFO, "va: %p\n", mem->vaddr);
-	v4l_dbg(ctx, V4L_DEBUG_CODEC_PRINFO, "dma: 0x%lx\n", (ulong) mem->dma_addr);
-	v4l_dbg(ctx, V4L_DEBUG_CODEC_PRINFO, "size: 0x%lx\n", size);
-
-	return 0;
-}
-EXPORT_SYMBOL(aml_vcodec_mem_alloc);
-
-void aml_vcodec_mem_free(struct aml_vcodec_ctx *data,
-			struct aml_vcodec_mem *mem)
-{
-	unsigned long size = mem->size;
-	struct aml_vcodec_ctx *ctx = (struct aml_vcodec_ctx *)data;
-	struct device *dev = &ctx->dev->plat_dev->dev;
-
-	if (!mem->vaddr) {
-		v4l_dbg(ctx, V4L_DEBUG_CODEC_ERROR,
-			"%s dma_free size=%ld failed!\n", dev_name(dev),
-			     size);
-		return;
-	}
-
-	v4l_dbg(ctx, V4L_DEBUG_CODEC_PRINFO, "va: %p\n", mem->vaddr);
-	v4l_dbg(ctx, V4L_DEBUG_CODEC_PRINFO, "dma: 0x%lx\n", (ulong) mem->dma_addr);
-	v4l_dbg(ctx, V4L_DEBUG_CODEC_PRINFO, "size: 0x%lx\n", size);
-
-	dma_free_coherent(dev, size, mem->vaddr, mem->dma_addr);
-	mem->vaddr = NULL;
-	mem->dma_addr = 0;
-	mem->size = 0;
-}
-EXPORT_SYMBOL(aml_vcodec_mem_free);
-
 void aml_vcodec_set_curr_ctx(struct aml_vcodec_dev *dev,
 	struct aml_vcodec_ctx *ctx)
 {
diff --git a/drivers/amvdec_ports/aml_vcodec_util.h b/drivers/amvdec_ports/aml_vcodec_util.h
index 312ee406..0b68d04c 100644
--- a/drivers/amvdec_ports/aml_vcodec_util.h
+++ b/drivers/amvdec_ports/aml_vcodec_util.h
@@ -69,6 +69,8 @@ extern u32 debug_mode;
 #define V4L_DEBUG_CODEC_PARSER	(1 << 6)
 #define V4L_DEBUG_CODEC_PROT	(1 << 7)
 #define V4L_DEBUG_CODEC_EXINFO	(1 << 8)
+#define V4L_DEBUG_VPP_BUFMGR	(1 << 9)
+#define V4L_DEBUG_VPP_DETAIL	(1 << 10)
 
 #define __v4l_dbg(h, id, fmt, args...)					\
 	do {								\
@@ -92,12 +94,6 @@ extern u32 debug_mode;
 		}								\
 	} while (0)
 
-void __iomem *aml_vcodec_get_reg_addr(struct aml_vcodec_ctx *data,
-				unsigned int reg_idx);
-int aml_vcodec_mem_alloc(struct aml_vcodec_ctx *data,
-				struct aml_vcodec_mem *mem);
-void aml_vcodec_mem_free(struct aml_vcodec_ctx *data,
-				struct aml_vcodec_mem *mem);
 void aml_vcodec_set_curr_ctx(struct aml_vcodec_dev *dev,
 	struct aml_vcodec_ctx *ctx);
 struct aml_vcodec_ctx *aml_vcodec_get_curr_ctx(struct aml_vcodec_dev *dev);
diff --git a/drivers/amvdec_ports/aml_vcodec_vfm.c b/drivers/amvdec_ports/aml_vcodec_vfm.c
index 62896ea0..bad2cd77 100644
--- a/drivers/amvdec_ports/aml_vcodec_vfm.c
+++ b/drivers/amvdec_ports/aml_vcodec_vfm.c
@@ -21,6 +21,7 @@
 #include "aml_vcodec_vfq.h"
 #include "aml_vcodec_util.h"
 #include "aml_vcodec_adapt.h"
+#include "aml_vcodec_vpp.h"
 #include <media/v4l2-mem2mem.h>
 
 #define KERNEL_ATRACE_TAG KERNEL_ATRACE_TAG_VIDEO_COMPOSER
@@ -98,14 +99,27 @@ void video_vf_put(char *receiver, struct vdec_v4l2_buffer *fb, int id)
 	ATRACE_COUNTER("v4l2_to", vf->index_disp);
 
 	v4l_dbg(0, V4L_DEBUG_CODEC_OUTPUT,
-		"[%d]: TO   (%s) vf: %p, idx: %d, "
+		"[%d]: TO   (%s) vf: %px, idx: %d, "
 		"Y:(%lx, %u) C/U:(%lx, %u) V:(%lx, %u)\n",
-		id, vfp->name, vf, vf->index,
+		id, vfp->name, vf, vf->index & 0xff,
 		fb->m.mem[0].addr, fb->m.mem[0].size,
 		fb->m.mem[1].addr, fb->m.mem[1].size,
 		fb->m.mem[2].addr, fb->m.mem[2].size);
 
-	if (vfp && vf && atomic_dec_and_test(&vf->use_cnt))
+	if (vfp && vf)
+		vf_put(vf, receiver);
+}
+
+void vpp_vf_put(char *receiver, struct vframe_s *vf, int id)
+{
+	struct vframe_provider_s *vfp = vf_get_provider(receiver);
+	ATRACE_COUNTER("v4l2_to", vf->index_disp);
+
+	v4l_dbg(0, V4L_DEBUG_CODEC_OUTPUT,
+		"[%d]: TO   (%s) vf: %p, idx: %d\n",
+		id, vfp->name, vf, vf->index);
+
+	if (vfp && vf)
 		vf_put(vf, receiver);
 }
 
@@ -176,6 +190,11 @@ static int video_receiver_event_fun(int type, void *data, void *private_data)
 			break;
 		}
 
+		if (vfm->ctx->vpp) {
+			aml_v4l2_vpp_push_vframe(vfm->ctx->vpp, vfm->vf);
+			break;
+		}
+
 		vfq_push(&vfm->vf_que, vfm->vf);
 
 		if (vfm->ada_ctx->vfm_path == FRAME_BASE_PATH_V4L_VIDEO) {
diff --git a/drivers/amvdec_ports/aml_vcodec_vfm.h b/drivers/amvdec_ports/aml_vcodec_vfm.h
index 141e9a77..adc0ed68 100644
--- a/drivers/amvdec_ports/aml_vcodec_vfm.h
+++ b/drivers/amvdec_ports/aml_vcodec_vfm.h
@@ -52,9 +52,12 @@ struct vframe_s *peek_video_frame(struct vcodec_vfm_s *vfm);
 
 struct vframe_s *get_video_frame(struct vcodec_vfm_s *vfm);
 
-int get_fb_from_queue(struct aml_vcodec_ctx *ctx, struct vdec_v4l2_buffer **out_fb);
+int get_fb_from_queue(struct aml_vcodec_ctx *ctx,
+		struct vdec_v4l2_buffer **out_fb,
+		bool for_vpp);
 int put_fb_to_queue(struct aml_vcodec_ctx *ctx, struct vdec_v4l2_buffer *in_fb);
 
 void video_vf_put(char *receiver, struct vdec_v4l2_buffer *fb, int id);
 
+void vpp_vf_put(char *receiver, struct vframe_s *vf, int id);
 #endif /* __AML_VCODEC_VFM_H_ */
diff --git a/drivers/amvdec_ports/aml_vcodec_vpp.c b/drivers/amvdec_ports/aml_vcodec_vpp.c
new file mode 100644
index 00000000..c6123069
--- /dev/null
+++ b/drivers/amvdec_ports/aml_vcodec_vpp.c
@@ -0,0 +1,509 @@
+/*
+* Copyright (C) 2020 Amlogic, Inc. All rights reserved.
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT
+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+* more details.
+*
+* You should have received a copy of the GNU General Public License along
+* with this program; if not, write to the Free Software Foundation, Inc.,
+* 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+*
+* Description:
+*/
+
+#include <linux/types.h>
+#include <linux/delay.h>
+#include <linux/videodev2.h>
+#include "aml_vcodec_vpp.h"
+#include "aml_vcodec_vfm.h"
+#include "aml_vcodec_adapt.h"
+#include "vdec_drv_if.h"
+
+#define VPP_BUF_GET_IDX(vpp_buf) (vpp_buf->aml_buf->vb.vb2_buf.index)
+#define INPUT_PORT 0
+#define OUTPUT_PORT 1
+
+extern int dump_vpp_input;
+
+static enum DI_ERRORTYPE
+	v4l_vpp_empty_input_done(struct di_buffer *buf)
+{
+	struct aml_v4l2_vpp *vpp = buf->caller_data;
+	struct aml_v4l2_vpp_buf *vpp_buf;
+
+	if (!vpp || !vpp->ctx) {
+		pr_err("fatal %s %d vpp:%p\n",
+			__func__, __LINE__, vpp);
+		return DI_ERR_UNDEFINED;
+	}
+
+	vpp_buf = container_of(buf, struct aml_v4l2_vpp_buf, di_buf);
+	v4l_dbg(vpp->ctx, V4L_DEBUG_VPP_BUFMGR,
+			"vpp vf %p flag:%x done\n",
+			buf->vf, buf->flag);
+
+	if (!(buf->flag & DI_FLAG_BUF_BY_PASS)) {
+		/* recycle vf only in non-bypass mode */
+		vpp_vf_put(vpp->ctx->ada_ctx->recv_name,
+			vpp_buf->di_buf.vf, vpp->ctx->id);
+	}
+	vpp->out_num[INPUT_PORT]++;
+	kfree(vpp_buf);
+	return DI_ERR_NONE;
+}
+
+static enum DI_ERRORTYPE
+	v4l_vpp_fill_output_done(struct di_buffer *buf)
+{
+	struct aml_v4l2_vpp *vpp = buf->caller_data;
+	struct aml_v4l2_vpp_buf *vpp_buf = NULL;
+
+	if (!vpp || !vpp->ctx || !vpp->ctx->vfm) {
+	    pr_err("fatal %s %d vpp:%p\n",
+		    __func__, __LINE__, vpp);
+	    return DI_ERR_UNDEFINED;
+	}
+	vpp_buf = container_of(buf, struct aml_v4l2_vpp_buf, di_buf);
+
+	kfifo_put(&vpp->out_done_q, vpp_buf);
+	queue_work(vpp->wq, &vpp->vpp_work);
+
+	v4l_dbg(vpp->ctx, V4L_DEBUG_VPP_DETAIL,
+		"vpp di out done idx:%d flag:%x\n",
+		VPP_BUF_GET_IDX(vpp_buf), buf->flag);
+	vpp->out_num[OUTPUT_PORT]++;
+	return DI_ERR_NONE;
+}
+
+static void aml_vpp_disp_worker(struct work_struct *work)
+{
+	struct aml_v4l2_vpp *vpp =
+		container_of(work, struct aml_v4l2_vpp, vpp_work);
+	struct aml_v4l2_vpp_buf *vpp_buf = NULL;
+	struct di_buffer *buf;
+	struct vframe_s *vf;
+
+	if (!vpp || !vpp->ctx || !vpp->ctx->vfm) {
+	    pr_err("fatal %s %d vpp:%p\n",
+		    __func__, __LINE__, vpp);
+	    return;
+	}
+	while (kfifo_get(&vpp->out_done_q, &vpp_buf)) {
+		bool eos = false;
+
+		buf = &vpp_buf->di_buf;
+		vf = buf->vf;
+
+		if (buf->flag & DI_FLAG_EOS) {
+			v4l_dbg(vpp->ctx, V4L_DEBUG_VPP_DETAIL,
+				"%s %d got eos\n",
+				__func__, __LINE__);
+			vf->type |= VIDTYPE_V4L_EOS;
+			vf->flag = VFRAME_FLAG_EMPTY_FRAME_V4L;
+			eos = true;
+		}
+
+		v4l_dbg(vpp->ctx, V4L_DEBUG_VPP_DETAIL,
+			"vpp output %p idx:%d flag:%x\n",
+			buf, VPP_BUF_GET_IDX(vpp_buf), buf->flag);
+
+		if (buf->flag & DI_FLAG_BUF_BY_PASS && !eos) {
+			/* retrieve input buffer info */
+			vf = buf->vf->vf_ext;
+
+			v4l_dbg(vpp->ctx, V4L_DEBUG_VPP_DETAIL,
+				"vpp bypass %p idx:%d\n",
+				buf, VPP_BUF_GET_IDX(vpp_buf));
+
+			/* recycle output buffer directly */
+			mutex_lock(&vpp->output_lock);
+			kfifo_put(&vpp->frame, buf->vf);
+			kfifo_put(&vpp->output, vpp_buf);
+			mutex_unlock(&vpp->output_lock);
+			up(&vpp->sem_out);
+		} else
+			vf->v4l_mem_handle =
+				(ulong) &vpp_buf->aml_buf->frame_buffer;
+
+		vfq_push(&vpp->ctx->vfm->vf_que, vf);
+		vdec_device_vf_run(vpp->ctx);
+
+		v4l_dbg(vpp->ctx, V4L_DEBUG_VPP_DETAIL,
+			"vpp send out idx:%d\n",
+			VPP_BUF_GET_IDX(vpp_buf));
+	}
+}
+
+static int aml_v4l2_vpp_thread(void* param)
+{
+	struct aml_v4l2_vpp* vpp = param;
+	struct aml_vcodec_ctx *ctx = vpp->ctx;
+
+	v4l_dbg(ctx, V4L_DEBUG_VPP_DETAIL, "enter vpp thread\n");
+	while (vpp->running) {
+		bool eos = false;
+		struct aml_v4l2_vpp_buf *in_buf;
+		struct aml_v4l2_vpp_buf *out_buf = NULL;
+		struct vframe_s *vf_out = NULL;
+		struct vdec_v4l2_buffer *fb;
+
+		if (down_interruptible(&vpp->sem_in))
+			return -EINTR;
+retry:
+		if (!vpp->running)
+			break;
+
+		if (kfifo_is_empty(&vpp->output)) {
+			if (down_interruptible(&vpp->sem_out))
+				return -EINTR;
+			goto retry;
+		}
+
+		mutex_lock(&vpp->output_lock);
+		if (!kfifo_get(&vpp->output, &out_buf)) {
+			mutex_unlock(&vpp->output_lock);
+			v4l_dbg(ctx, 0, "vpp can not get output\n");
+			return -EAGAIN;
+		}
+		mutex_unlock(&vpp->output_lock);
+
+		/* bind v4l2 buffers */
+		if (!out_buf->aml_buf) {
+			struct vdec_v4l2_buffer *out;
+
+			if (get_fb_from_queue(vpp->ctx, &out, true)) {
+				usleep_range(5000, 5500);
+				mutex_lock(&vpp->output_lock);
+				kfifo_put(&vpp->output, out_buf);
+				mutex_unlock(&vpp->output_lock);
+				goto retry;
+			}
+			out_buf->aml_buf = container_of(out,
+				struct aml_video_dec_buf, frame_buffer);
+			out_buf->aml_buf->vpp_buf_handle = (ulong) out_buf;
+			v4l_dbg(ctx, V4L_DEBUG_VPP_BUFMGR,
+				"vpp bind buf:%d to vpp_buf:%p\n",
+				VPP_BUF_GET_IDX(out_buf), out_buf);
+			out->status = FB_ST_DISPLAY;
+			out->m.mem[0].bytes_used = out->m.mem[0].size;
+			out->m.mem[1].bytes_used = out->m.mem[1].size;
+		}
+
+		/* safe to pop in_buf */
+		if (!kfifo_get(&vpp->input, &in_buf)) {
+			v4l_dbg(ctx, 0, "vpp can not get input\n");
+			return -EAGAIN;
+		}
+
+		if (in_buf->di_buf.flag & DI_FLAG_EOS)
+			eos = true;
+
+		mutex_lock(&vpp->output_lock);
+		if (!kfifo_get(&vpp->frame, &vf_out)) {
+			mutex_unlock(&vpp->output_lock);
+			v4l_dbg(ctx, 0, "vpp can not get frame\n");
+			return -EAGAIN;
+		}
+		mutex_unlock(&vpp->output_lock);
+
+		fb = &out_buf->aml_buf->frame_buffer;
+		memcpy(vf_out->canvas0_config,
+			in_buf->di_buf.vf->canvas0_config,
+			2 * sizeof(struct canvas_config_s));
+		vf_out->canvas0_config[0].phy_addr = fb->m.mem[0].addr;
+		vf_out->canvas0_config[1].phy_addr = fb->m.mem[1].addr;
+
+		if (eos)
+			memset(vf_out, 0, sizeof(*vf_out));
+
+		out_buf->di_buf.vf = vf_out;
+		out_buf->di_buf.flag = 0;
+		out_buf->di_buf.caller_data = vpp;
+		di_fill_output_buffer(vpp->di_handle, &out_buf->di_buf);
+
+		v4l_dbg(ctx, V4L_DEBUG_VPP_DETAIL,
+				"v4l vpp handle in vf:%p outp:%p/%d iphy:%x/%x %dx%d ophy:%x/%x %dx%d\n",
+				in_buf->di_buf.vf, out_buf->di_buf.vf,
+				VPP_BUF_GET_IDX(out_buf),
+				in_buf->di_buf.vf->canvas0_config[0].phy_addr,
+				in_buf->di_buf.vf->canvas0_config[1].phy_addr,
+				in_buf->di_buf.vf->canvas0_config[0].width,
+				in_buf->di_buf.vf->canvas0_config[0].height,
+				vf_out->canvas0_config[0].phy_addr,
+				vf_out->canvas0_config[1].phy_addr,
+				vf_out->canvas0_config[0].width,
+				vf_out->canvas0_config[0].height
+				);
+		in_buf->di_buf.caller_data = vpp;
+		di_empty_input_buffer(vpp->di_handle, &(in_buf->di_buf));
+	}
+	v4l_dbg(ctx, V4L_DEBUG_VPP_DETAIL, "exit vpp thread\n");
+	return 0;
+}
+
+int aml_v4l2_vpp_get_buf_num(u32 mode)
+{
+	if (mode == VPP_MODE_DI)
+		return 6;
+	//TODO: support more modes
+	return 2;
+}
+
+int aml_v4l2_vpp_init(
+		struct aml_vcodec_ctx *ctx,
+		u32 mode,
+		u32 fmt,
+		struct aml_v4l2_vpp** vpp_handle)
+{
+	struct di_init_parm init;
+	u32 buf_size;
+	int i, ret;
+	struct sched_param param = { .sched_priority = MAX_RT_PRIO - 1 };
+	struct aml_v4l2_vpp *vpp;
+
+	if (mode > VPP_MODE_MAX || !ctx || !vpp_handle)
+		return -EINVAL;
+	if (fmt != V4L2_PIX_FMT_NV12M && fmt != V4L2_PIX_FMT_NV21M)
+		return -EINVAL;
+
+	vpp = kzalloc(sizeof(*vpp), GFP_KERNEL);
+	if (!vpp)
+		return -ENOMEM;
+
+	init.work_mode = WORK_MODE_PRE_POST;
+	init.buffer_mode = BUFFER_MODE_USE_BUF;
+	init.ops.empty_input_done = v4l_vpp_empty_input_done;
+	init.ops.fill_output_done = v4l_vpp_fill_output_done;
+	init.caller_data = (void *)vpp;
+
+	if (fmt == V4L2_PIX_FMT_NV12M)
+		init.output_format = DI_OUTPUT_NV12;
+	else
+		init.output_format = DI_OUTPUT_NV21;
+
+	vpp->di_handle = di_create_instance(init);
+	if (vpp->di_handle < 0) {
+		v4l_dbg(ctx, 0, "di_create_instance fail\n");
+		ret = -EINVAL;
+		goto error;
+	}
+	INIT_KFIFO(vpp->input);
+	INIT_KFIFO(vpp->output);
+	INIT_KFIFO(vpp->frame);
+	INIT_KFIFO(vpp->out_done_q);
+	vpp->ctx = ctx;
+
+	buf_size = aml_v4l2_vpp_get_buf_num(mode);
+	vpp->buf_size = buf_size;
+
+	/* setup output fifo */
+	ret = kfifo_alloc(&vpp->output, buf_size, GFP_KERNEL);
+	if (ret) {
+		v4l_dbg(ctx, 0, "%s %d fail\n", __func__, __LINE__);
+		ret = -ENOMEM;
+		goto error2;
+	}
+
+	vpp->vbpool = kzalloc(buf_size * sizeof(*vpp->vbpool), GFP_KERNEL);
+	if (!vpp->vbpool) {
+		v4l_dbg(ctx, 0, "%s %d fail\n", __func__, __LINE__);
+		ret = -ENOMEM;
+		goto error3;
+	}
+
+	/* setup vframe fifo */
+	ret = kfifo_alloc(&vpp->frame, buf_size, GFP_KERNEL);
+	if (ret) {
+		v4l_dbg(ctx, 0, "%s %d fail\n", __func__, __LINE__);
+		ret = -ENOMEM;
+		goto error4;
+	}
+
+	vpp->vfpool = kzalloc(buf_size * sizeof(*vpp->vfpool), GFP_KERNEL);
+	if (!vpp->vfpool) {
+		v4l_dbg(ctx, 0, "%s %d fail\n", __func__, __LINE__);
+		ret = -ENOMEM;
+		goto error5;
+	}
+
+	for (i = 0 ; i < buf_size ; i++) {
+		kfifo_put(&vpp->output, &vpp->vbpool[i]);
+		kfifo_put(&vpp->frame, &vpp->vfpool[i]);
+	}
+
+	mutex_init(&vpp->output_lock);
+	sema_init(&vpp->sem_in, 0);
+	sema_init(&vpp->sem_out, 0);
+	INIT_WORK(&vpp->vpp_work, aml_vpp_disp_worker);
+
+	vpp->wq = alloc_ordered_workqueue("aml-v4l-vpp",
+			WQ_MEM_RECLAIM | WQ_FREEZABLE);
+	if (!vpp->wq) {
+		v4l_dbg(ctx, V4L_DEBUG_CODEC_ERROR,
+			"Failed to create vpp workqueue\n");
+		ret = -EINVAL;
+		goto error6;
+	}
+
+	vpp->running = true;
+	vpp->task = kthread_run(aml_v4l2_vpp_thread, vpp,
+		"aml-%s", "aml-v4l2-vpp");
+	if (IS_ERR(vpp->task)) {
+		ret = PTR_ERR(vpp->task);
+		goto error7;
+	}
+	sched_setscheduler_nocheck(vpp->task, SCHED_FIFO, &param);
+
+	*vpp_handle = vpp;
+	return 0;
+error7:
+	destroy_workqueue(vpp->wq);
+error6:
+	kfree(vpp->vfpool);
+error5:
+	kfifo_free(&vpp->frame);
+error4:
+	kfree(vpp->vbpool);
+error3:
+	kfifo_free(&vpp->output);
+error2:
+	di_destroy_instance(vpp->di_handle);
+error:
+	kfree(vpp);
+	return ret;
+}
+EXPORT_SYMBOL(aml_v4l2_vpp_init);
+
+int aml_v4l2_vpp_destroy(struct aml_v4l2_vpp* vpp)
+{
+	struct aml_v4l2_vpp_buf* in_buf;
+
+	v4l_dbg(vpp->ctx, V4L_DEBUG_VPP_DETAIL,
+		"vpp destroy begin\n");
+	vpp->running = false;
+	up(&vpp->sem_in);
+	up(&vpp->sem_out);
+	kthread_stop(vpp->task);
+
+	di_destroy_instance(vpp->di_handle);
+	/* no more vpp callback below this line */
+
+	flush_workqueue(vpp->wq);
+	destroy_workqueue(vpp->wq);
+
+	kfifo_free(&vpp->frame);
+	kfree(vpp->vfpool);
+	kfifo_free(&vpp->output);
+	kfree(vpp->vbpool);
+	while (kfifo_get(&vpp->input, &in_buf))
+		kfree(in_buf);
+	kfifo_free(&vpp->input);
+	mutex_destroy(&vpp->output_lock);
+	kfree(vpp);
+	v4l_dbg(vpp->ctx, V4L_DEBUG_VPP_DETAIL,
+		"vpp destroy done\n");
+	return 0;
+}
+EXPORT_SYMBOL(aml_v4l2_vpp_destroy);
+
+int aml_v4l2_vpp_push_vframe(struct aml_v4l2_vpp* vpp, struct vframe_s *vf)
+{
+	struct aml_v4l2_vpp_buf* in_buf;
+	struct vdec_v4l2_buffer *fb = NULL;
+
+	if (!vpp)
+		return -EINVAL;
+
+	/* TODO: delete it after VPP supports bypass mode well */
+	if ((vf->type & VIDTYPE_TYPEMASK) == VIDTYPE_PROGRESSIVE &&
+		vpp->work_mode == VPP_MODE_DI) {
+		vfq_push(&vpp->ctx->vfm->vf_que, vf);
+		vdec_device_vf_run(vpp->ctx);
+		return 0;
+	}
+
+	in_buf = kzalloc(sizeof(*in_buf), GFP_KERNEL);
+	if (!in_buf)
+		return -ENOMEM;
+
+#if 0 //to debug di by frame
+	if (vpp->in_num[INPUT_PORT] > 2)
+		return 0;
+	if (vpp->in_num[INPUT_PORT] == 2)
+		vf->type |= VIDTYPE_V4L_EOS;
+#endif
+
+	in_buf->di_buf.vf = vf;
+	in_buf->di_buf.flag = 0;
+	if (vf->type & VIDTYPE_V4L_EOS)
+		in_buf->di_buf.flag |= DI_FLAG_EOS;
+
+	v4l_dbg(vpp->ctx, V4L_DEBUG_VPP_BUFMGR,
+		"vpp got input vf:%p type:%d ts:%llx\n",
+		vf, vf->type, vf->timestamp);
+
+	fb = (struct vdec_v4l2_buffer *)vf->v4l_mem_handle;
+	in_buf->aml_buf = container_of(fb, struct aml_video_dec_buf, frame_buffer);
+	fb->vf_handle = (ulong) vf;
+
+	do {
+		unsigned int dw_mode = VDEC_DW_NO_AFBC;
+		struct file *fp;
+
+		if (!dump_vpp_input || vpp->ctx->is_drm_mode)
+			break;
+		if (vdec_if_get_param(vpp->ctx, GET_PARAM_DW_MODE, &dw_mode))
+			break;
+		if (dw_mode == VDEC_DW_AFBC_ONLY)
+			break;
+
+		fp = filp_open("/data/dec_dump_before.raw",
+				O_CREAT | O_RDWR | O_LARGEFILE | O_APPEND, 0600);
+		if (!IS_ERR(fp)) {
+			struct vb2_buffer *vb = &in_buf->aml_buf->vb.vb2_buf;
+
+			kernel_write(fp,vb2_plane_vaddr(vb, 0),vb->planes[0].length, 0);
+			if (in_buf->aml_buf->frame_buffer.num_planes == 2)
+				kernel_write(fp,vb2_plane_vaddr(vb, 1),
+						vb->planes[1].length, 0);
+			dump_vpp_input--;
+			filp_close(fp, NULL);
+		}
+	} while(0);
+
+	kfifo_put(&vpp->input, in_buf);
+	up(&vpp->sem_in);
+	vpp->in_num[INPUT_PORT]++;
+	return 0;
+}
+EXPORT_SYMBOL(aml_v4l2_vpp_push_vframe);
+
+int aml_v4l2_vpp_rel_vframe(struct aml_v4l2_vpp* vpp, struct vframe_s *vf)
+{
+	struct vdec_v4l2_buffer *fb = NULL;
+	struct aml_video_dec_buf *aml_buf = NULL;
+	struct aml_v4l2_vpp_buf *vpp_buf = NULL;
+
+	fb = (struct vdec_v4l2_buffer *) vf->v4l_mem_handle;
+	aml_buf = container_of(fb, struct aml_video_dec_buf, frame_buffer);
+	vpp_buf = (struct aml_v4l2_vpp_buf *) aml_buf->vpp_buf_handle;
+	v4l_dbg(vpp->ctx, V4L_DEBUG_VPP_BUFMGR,
+			"vpp rel output vf:%p index:%d\n",
+			vf, VPP_BUF_GET_IDX(vpp_buf));
+
+	mutex_lock(&vpp->output_lock);
+	kfifo_put(&vpp->frame, vf);
+	kfifo_put(&vpp->output, vpp_buf);
+	mutex_unlock(&vpp->output_lock);
+	up(&vpp->sem_out);
+	vpp->in_num[OUTPUT_PORT]++;
+	return 0;
+}
+EXPORT_SYMBOL(aml_v4l2_vpp_rel_vframe);
diff --git a/drivers/amvdec_ports/aml_vcodec_vpp.h b/drivers/amvdec_ports/aml_vcodec_vpp.h
new file mode 100644
index 00000000..44e0f10e
--- /dev/null
+++ b/drivers/amvdec_ports/aml_vcodec_vpp.h
@@ -0,0 +1,103 @@
+/*
+* Copyright (C) 2020 Amlogic, Inc. All rights reserved.
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT
+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+* more details.
+*
+* You should have received a copy of the GNU General Public License along
+* with this program; if not, write to the Free Software Foundation, Inc.,
+* 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+*
+* Description:
+*/
+#ifndef _AML_VCODEC_VPP_H_
+#define _AML_VCODEC_VPP_H_
+
+#include <linux/kfifo.h>
+
+#ifdef di_multi_v3
+#include <linux/amlogic/media/di/di_interface.h>
+#endif
+
+#include "aml_vcodec_drv.h"
+#include "aml_vcodec_dec.h"
+
+enum vpp_work_mode {
+	VPP_MODE_DI,
+	VPP_MODE_COLOR_CONV,
+	VPP_MODE_NOISE_REDUC,
+	VPP_MODE_MAX
+};
+
+#define VPP_FRAME_SIZE 32
+
+struct aml_v4l2_vpp_buf {
+#ifdef di_multi_v3
+	struct di_buffer di_buf;
+#endif
+	struct aml_video_dec_buf *aml_buf;
+};
+
+struct aml_v4l2_vpp {
+	int di_handle; /* handle of DI */
+	struct aml_vcodec_ctx *ctx;
+	u32 buf_size; /* buffer size for vpp */
+	u32 work_mode; /* enum vpp_work_mode */
+	DECLARE_KFIFO(input, typeof(struct aml_v4l2_vpp_buf*), VPP_FRAME_SIZE);
+	DECLARE_KFIFO_PTR(output, typeof(struct aml_v4l2_vpp_buf*));
+	DECLARE_KFIFO_PTR(frame, typeof(struct vframe_s *));
+
+	/* handle fill_output_done() in irq context */
+	struct workqueue_struct	*wq;
+	DECLARE_KFIFO(out_done_q, struct aml_v4l2_vpp_buf *, VPP_FRAME_SIZE);
+
+	struct vframe_s *vfpool;
+	struct aml_v4l2_vpp_buf *vbpool;
+	struct task_struct *task;
+	bool running;
+	struct semaphore sem_in, sem_out;
+	struct work_struct vpp_work;
+
+	/* In p to i transition, output/frame can be multi writer */
+	struct mutex output_lock;
+
+	/* for debugging */
+	/*
+	 * in[0] --> vpp <-- in[1]
+	 * out[0]<-- vpp --> out[1]
+	 */
+	int in_num[2];
+	int out_num[2];
+};
+
+#ifdef di_multi_v3
+/* get number of buffer needed for a working mode */
+int aml_v4l2_vpp_get_buf_num(u32 mode);
+int aml_v4l2_vpp_init(
+	struct aml_vcodec_ctx *ctx,
+	u32 mode,
+	u32 fmt,
+	struct aml_v4l2_vpp** vpp_handle);
+int aml_v4l2_vpp_destroy(struct aml_v4l2_vpp* vpp);
+int aml_v4l2_vpp_push_vframe(struct aml_v4l2_vpp* vpp, struct vframe_s *vf);
+int aml_v4l2_vpp_rel_vframe(struct aml_v4l2_vpp* vpp, struct vframe_s *vf);
+#else
+static inline int aml_v4l2_vpp_get_buf_num(u32 mode) { return -1; }
+static inline int aml_v4l2_vpp_init(
+	struct aml_vcodec_ctx *ctx,
+	u32 mode,
+	u32 fmt,
+	struct aml_v4l2_vpp** vpp_handle) { return -1; }
+static inline int aml_v4l2_vpp_destroy(struct aml_v4l2_vpp* vpp) { return -1; }
+static inline int aml_v4l2_vpp_push_vframe(struct aml_v4l2_vpp* vpp, struct vframe_s *vf) { return -1; }
+static inline int aml_v4l2_vpp_rel_vframe(struct aml_v4l2_vpp* vpp, struct vframe_s *vf) { return -1; }
+#endif
+
+#endif
diff --git a/drivers/amvdec_ports/decoder/aml_hevc_parser.h b/drivers/amvdec_ports/decoder/aml_hevc_parser.h
index 0c81cb51..9223639b 100644
--- a/drivers/amvdec_ports/decoder/aml_hevc_parser.h
+++ b/drivers/amvdec_ports/decoder/aml_hevc_parser.h
@@ -22,7 +22,6 @@
 #include "../aml_vcodec_drv.h"
 #include "../utils/common.h"
 
-
 #define MAX_DPB_SIZE				16 // A.4.1
 #define MAX_REFS				16
 
diff --git a/drivers/amvdec_ports/decoder/aml_mpeg12_parser.h b/drivers/amvdec_ports/decoder/aml_mpeg12_parser.h
index 8abbc783..1af29190 100644
--- a/drivers/amvdec_ports/decoder/aml_mpeg12_parser.h
+++ b/drivers/amvdec_ports/decoder/aml_mpeg12_parser.h
@@ -23,7 +23,6 @@
 #include "../utils/pixfmt.h"
 #endif
 
-
 /* Start codes. */
 #define SEQ_END_CODE            0x000001b7
 #define SEQ_START_CODE          0x000001b3
diff --git a/drivers/amvdec_ports/decoder/vdec_av1_if.c b/drivers/amvdec_ports/decoder/vdec_av1_if.c
index e8693d40..acf2cf42 100644
--- a/drivers/amvdec_ports/decoder/vdec_av1_if.c
+++ b/drivers/amvdec_ports/decoder/vdec_av1_if.c
@@ -121,6 +121,7 @@ struct vdec_av1_inst {
 	struct vcodec_vfm_s vfm;
 	struct aml_dec_params parms;
 	struct completion comp;
+	struct vdec_comp_buf_info comp_info;
 };
 
 /*!\brief OBU types. */
@@ -273,10 +274,8 @@ static void vdec_parser_parms(struct vdec_av1_inst *inst)
 			ctx->config.parm.dec.cfg.ref_buf_margin);
 		pbuf += sprintf(pbuf, "av1_double_write_mode:%d;",
 			ctx->config.parm.dec.cfg.double_write_mode);
-		pbuf += sprintf(pbuf, "av1_buf_width:%d;",
-			ctx->config.parm.dec.cfg.init_width);
-		pbuf += sprintf(pbuf, "av1_buf_height:%d;",
-			ctx->config.parm.dec.cfg.init_height);
+		pbuf += sprintf(pbuf, "av1_buf_width:1920;");
+		pbuf += sprintf(pbuf, "av1_buf_height:1088;");
 		pbuf += sprintf(pbuf, "save_buffer_mode:0;");
 		pbuf += sprintf(pbuf, "no_head:0;");
 		pbuf += sprintf(pbuf, "parm_v4l_canvas_mem_mode:%d;",
@@ -529,7 +528,7 @@ static void vdec_av1_deinit(unsigned long h_vdec)
 
 static int vdec_av1_get_fb(struct vdec_av1_inst *inst, struct vdec_v4l2_buffer **out)
 {
-	return get_fb_from_queue(inst->ctx, out);
+	return get_fb_from_queue(inst->ctx, out, false);
 }
 
 static void vdec_av1_get_vf(struct vdec_av1_inst *inst, struct vdec_v4l2_buffer **out)
@@ -1160,6 +1159,12 @@ static int vdec_av1_decode(unsigned long h_vdec,
 		"parms status: %u\n", parms->parms_status);
  }
 
+static void get_param_comp_buf_info(struct vdec_av1_inst *inst,
+		struct vdec_comp_buf_info *params)
+{
+	memcpy(params, &inst->comp_info, sizeof(*params));
+}
+
 static int vdec_av1_get_param(unsigned long h_vdec,
 			       enum vdec_get_param_type type, void *out)
 {
@@ -1197,6 +1202,16 @@ static int vdec_av1_get_param(unsigned long h_vdec,
 		get_param_config_info(inst, out);
 		break;
 
+	case GET_PARAM_DW_MODE:
+	{
+		unsigned int *mode = out;
+		*mode = inst->ctx->config.parm.dec.cfg.double_write_mode;
+		break;
+	}
+	case GET_PARAM_COMP_BUF_INFO:
+		get_param_comp_buf_info(inst, out);
+		break;
+
 	default:
 		v4l_dbg(inst->ctx, V4L_DEBUG_CODEC_ERROR,
 			"invalid get parameter type=%d\n", type);
@@ -1211,12 +1226,68 @@ static void set_param_write_sync(struct vdec_av1_inst *inst)
 	complete(&inst->comp);
 }
 
+static int vdec_get_dw_mode(struct vdec_av1_inst *inst, int dw_mode)
+{
+	u32 valid_dw_mode = inst->parms.cfg.double_write_mode;
+	int w = inst->parms.cfg.init_width;
+	int h = inst->parms.cfg.init_height;
+	u32 dw = 0x1; /*1:1*/
+
+	switch (valid_dw_mode) {
+	case 0x100:
+		if (w > 1920 && h > 1088)
+			dw = 0x4; /*1:2*/
+		break;
+	case 0x200:
+		if (w > 1920 && h > 1088)
+			dw = 0x2; /*1:4*/
+		break;
+	case 0x300:
+		if (w > 1280 && h > 720)
+			dw = 0x4; /*1:2*/
+		break;
+	default:
+		dw = valid_dw_mode;
+		break;
+	}
+
+	return dw;
+}
+
+static int vdec_pic_scale(struct vdec_av1_inst *inst, int length, int dw_mode)
+{
+	int ret = 64;
+
+	switch (vdec_get_dw_mode(inst, dw_mode)) {
+	case 0x0: /* only afbc, output afbc */
+		ret = 64;
+		break;
+	case 0x1: /* afbc and (w x h), output YUV420 */
+		ret = length;
+		break;
+	case 0x2: /* afbc and (w/4 x h/4), output YUV420 */
+	case 0x3: /* afbc and (w/4 x h/4), output afbc and YUV420 */
+		ret = length >> 2;
+		break;
+	case 0x4: /* afbc and (w/2 x h/2), output YUV420 */
+		ret = length >> 1;
+		break;
+	case 0x10: /* (w x h), output YUV420-8bit) */
+	default:
+		ret = length;
+		break;
+	}
+
+	return ret;
+}
+
 static void set_param_ps_info(struct vdec_av1_inst *inst,
 	struct aml_vdec_ps_infos *ps)
 {
 	struct vdec_pic_info *pic = &inst->vsi->pic;
 	struct vdec_av1_dec_info *dec = &inst->vsi->dec;
 	struct v4l2_rect *rect = &inst->vsi->crop;
+	int dw = inst->parms.cfg.double_write_mode;
 
 	/* fill visible area size that be used for EGL. */
 	pic->visible_width	= ps->visible_width;
@@ -1232,7 +1303,8 @@ static void set_param_ps_info(struct vdec_av1_inst *inst,
 	pic->coded_width	= ps->coded_width;
 	pic->coded_height	= ps->coded_height;
 
-	pic->y_len_sz		= pic->coded_width * pic->coded_height;
+	pic->y_len_sz		= vdec_pic_scale(inst, pic->coded_width, dw) *
+				  vdec_pic_scale(inst, pic->coded_height, dw);
 	pic->c_len_sz		= pic->y_len_sz >> 1;
 
 	/* calc DPB size */
@@ -1252,6 +1324,12 @@ static void set_param_ps_info(struct vdec_av1_inst *inst,
 		ps->dpb_size);
 }
 
+static void set_param_comp_buf_info(struct vdec_av1_inst *inst,
+		struct vdec_comp_buf_info *info)
+{
+	memcpy(&inst->comp_info, info, sizeof(*info));
+}
+
 static void set_param_hdr_info(struct vdec_av1_inst *inst,
 	struct aml_vdec_hdr_infos *hdr)
 {
@@ -1295,6 +1373,10 @@ static int vdec_av1_set_param(unsigned long h_vdec,
 		set_param_ps_info(inst, in);
 		break;
 
+	case SET_PARAM_COMP_BUF_INFO:
+		set_param_comp_buf_info(inst, in);
+		break;
+
 	case SET_PARAM_HDR_INFO:
 		set_param_hdr_info(inst, in);
 		break;
diff --git a/drivers/amvdec_ports/decoder/vdec_h264_if.c b/drivers/amvdec_ports/decoder/vdec_h264_if.c
index d7c4f437..67825121 100644
--- a/drivers/amvdec_ports/decoder/vdec_h264_if.c
+++ b/drivers/amvdec_ports/decoder/vdec_h264_if.c
@@ -304,7 +304,6 @@ static int vdec_h264_init(struct aml_vcodec_ctx *ctx, unsigned long *h_vdec)
 		return -ENOMEM;
 
 	inst->vdec.video_type	= VFORMAT_H264;
-	inst->vdec.dev		= ctx->dev->vpu_plat_dev;
 	inst->vdec.filp		= ctx->dev->filp;
 	inst->vdec.ctx		= ctx;
 	inst->ctx		= ctx;
@@ -325,6 +324,7 @@ static int vdec_h264_init(struct aml_vcodec_ctx *ctx, unsigned long *h_vdec)
 		goto err;
 	}
 
+	ctx->vfm = &inst->vfm;
 	ret = video_decoder_init(&inst->vdec);
 	if (ret) {
 		v4l_dbg(inst->ctx, V4L_DEBUG_CODEC_ERROR,
@@ -713,7 +713,7 @@ static void vdec_h264_deinit(unsigned long h_vdec)
 
 static int vdec_h264_get_fb(struct vdec_h264_inst *inst, struct vdec_v4l2_buffer **out)
 {
-	return get_fb_from_queue(inst->ctx, out);
+	return get_fb_from_queue(inst->ctx, out, false);
 }
 
 static void vdec_h264_get_vf(struct vdec_h264_inst *inst, struct vdec_v4l2_buffer **out)
@@ -990,6 +990,13 @@ static int vdec_h264_get_param(unsigned long h_vdec,
 	case GET_PARAM_CONFIG_INFO:
 		get_param_config_info(inst, out);
 		break;
+
+	case GET_PARAM_DW_MODE:
+	{
+		unsigned int* mode = out;
+		*mode = inst->ctx->config.parm.dec.cfg.double_write_mode;
+		break;
+	}
 	default:
 		v4l_dbg(inst->ctx, V4L_DEBUG_CODEC_ERROR,
 			"invalid get parameter type=%d\n", type);
diff --git a/drivers/amvdec_ports/decoder/vdec_hevc_if.c b/drivers/amvdec_ports/decoder/vdec_hevc_if.c
index 569806d3..3a5b0e0b 100644
--- a/drivers/amvdec_ports/decoder/vdec_hevc_if.c
+++ b/drivers/amvdec_ports/decoder/vdec_hevc_if.c
@@ -115,6 +115,7 @@ struct vdec_hevc_inst {
 	struct vcodec_vfm_s vfm;
 	struct aml_dec_params parms;
 	struct completion comp;
+	struct vdec_comp_buf_info comp_info;
 };
 
 static void get_pic_info(struct vdec_hevc_inst *inst,
@@ -210,7 +211,6 @@ static int vdec_hevc_init(struct aml_vcodec_ctx *ctx, unsigned long *h_vdec)
 		return -ENOMEM;
 
 	inst->vdec.video_type	= VFORMAT_HEVC;
-	inst->vdec.dev		= ctx->dev->vpu_plat_dev;
 	inst->vdec.filp		= ctx->dev->filp;
 	inst->vdec.ctx		= ctx;
 	inst->ctx		= ctx;
@@ -234,6 +234,7 @@ static int vdec_hevc_init(struct aml_vcodec_ctx *ctx, unsigned long *h_vdec)
 		goto err;
 	}
 
+	ctx->vfm = &inst->vfm;
 	ret = video_decoder_init(&inst->vdec);
 	if (ret) {
 		v4l_dbg(inst->ctx, V4L_DEBUG_CODEC_ERROR,
@@ -551,7 +552,7 @@ static void vdec_hevc_deinit(unsigned long h_vdec)
 
 static int vdec_hevc_get_fb(struct vdec_hevc_inst *inst, struct vdec_v4l2_buffer **out)
 {
-	return get_fb_from_queue(inst->ctx, out);
+	return get_fb_from_queue(inst->ctx, out, false);
 }
 
 static void vdec_hevc_get_vf(struct vdec_hevc_inst *inst, struct vdec_v4l2_buffer **out)
@@ -713,6 +714,12 @@ static int vdec_hevc_decode(unsigned long h_vdec,
 		"parms status: %u\n", parms->parms_status);
  }
 
+static void get_param_comp_buf_info(struct vdec_hevc_inst *inst,
+		struct vdec_comp_buf_info *params)
+{
+	memcpy(params, &inst->comp_info, sizeof(*params));
+}
+
 static int vdec_hevc_get_param(unsigned long h_vdec,
 			       enum vdec_get_param_type type, void *out)
 {
@@ -749,6 +756,17 @@ static int vdec_hevc_get_param(unsigned long h_vdec,
 	case GET_PARAM_CONFIG_INFO:
 		get_param_config_info(inst, out);
 		break;
+
+	case GET_PARAM_DW_MODE:
+	{
+		unsigned int *mode = out;
+		*mode = inst->ctx->config.parm.dec.cfg.double_write_mode;
+		break;
+	}
+	case GET_PARAM_COMP_BUF_INFO:
+		get_param_comp_buf_info(inst, out);
+		break;
+
 	default:
 		v4l_dbg(inst->ctx, V4L_DEBUG_CODEC_ERROR,
 			"invalid get parameter type=%d\n", type);
@@ -769,6 +787,7 @@ static void set_param_ps_info(struct vdec_hevc_inst *inst,
 	struct vdec_pic_info *pic = &inst->vsi->pic;
 	struct vdec_hevc_dec_info *dec = &inst->vsi->dec;
 	struct v4l2_rect *rect = &inst->vsi->crop;
+	int dw = inst->parms.cfg.double_write_mode;
 
 	/* fill visible area size that be used for EGL. */
 	pic->visible_width	= ps->visible_width;
@@ -784,7 +803,9 @@ static void set_param_ps_info(struct vdec_hevc_inst *inst,
 
 	pic->coded_width 	= ps->coded_width;
 	pic->coded_height 	= ps->coded_height;
-	pic->y_len_sz		= pic->coded_width * pic->coded_height;
+
+	pic->y_len_sz		= vdec_pic_scale(inst, pic->coded_width, dw) *
+				  vdec_pic_scale(inst, pic->coded_height, dw);
 	pic->c_len_sz		= pic->y_len_sz >> 1;
 
 	dec->dpb_sz		= ps->dpb_size;
@@ -803,6 +824,12 @@ static void set_param_ps_info(struct vdec_hevc_inst *inst,
 		dec->dpb_sz);
 }
 
+static void set_param_comp_buf_info(struct vdec_hevc_inst *inst,
+		struct vdec_comp_buf_info *info)
+{
+	memcpy(&inst->comp_info, info, sizeof(*info));
+}
+
 static void set_param_hdr_info(struct vdec_hevc_inst *inst,
 	struct aml_vdec_hdr_infos *hdr)
 {
@@ -846,6 +873,10 @@ static int vdec_hevc_set_param(unsigned long h_vdec,
 		set_param_ps_info(inst, in);
 		break;
 
+	case SET_PARAM_COMP_BUF_INFO:
+		set_param_comp_buf_info(inst, in);
+		break;
+
 	case SET_PARAM_HDR_INFO:
 		set_param_hdr_info(inst, in);
 		break;
diff --git a/drivers/amvdec_ports/decoder/vdec_mjpeg_if.c b/drivers/amvdec_ports/decoder/vdec_mjpeg_if.c
index f9816cc3..c71f8917 100644
--- a/drivers/amvdec_ports/decoder/vdec_mjpeg_if.c
+++ b/drivers/amvdec_ports/decoder/vdec_mjpeg_if.c
@@ -158,6 +158,7 @@ static u32 vdec_config_default_parms(u8 *parm)
 	pbuf += sprintf(pbuf, "parm_v4l_codec_enable:1;");
 	pbuf += sprintf(pbuf, "parm_v4l_canvas_mem_mode:0;");
 	pbuf += sprintf(pbuf, "parm_v4l_buffer_margin:0;");
+	pbuf += sprintf(pbuf, "parm_v4l_canvas_mem_endian:0;");
 
 	return pbuf - parm;
 }
@@ -199,7 +200,6 @@ static int vdec_mjpeg_init(struct aml_vcodec_ctx *ctx, unsigned long *h_vdec)
 		return -ENOMEM;
 
 	inst->vdec.video_type	= VFORMAT_MJPEG;
-	inst->vdec.dev		= ctx->dev->vpu_plat_dev;
 	inst->vdec.filp		= ctx->dev->filp;
 	inst->vdec.config	= ctx->config;
 	inst->vdec.ctx		= ctx;
@@ -223,6 +223,7 @@ static int vdec_mjpeg_init(struct aml_vcodec_ctx *ctx, unsigned long *h_vdec)
 		goto err;
 	}
 
+	ctx->vfm = &inst->vfm;
 	ret = video_decoder_init(&inst->vdec);
 	if (ret) {
 		v4l_dbg(inst->ctx, V4L_DEBUG_CODEC_ERROR,
@@ -446,7 +447,7 @@ static void vdec_mjpeg_deinit(unsigned long h_vdec)
 
 static int vdec_mjpeg_get_fb(struct vdec_mjpeg_inst *inst, struct vdec_v4l2_buffer **out)
 {
-	return get_fb_from_queue(inst->ctx, out);
+	return get_fb_from_queue(inst->ctx, out, false);
 }
 
 static void vdec_mjpeg_get_vf(struct vdec_mjpeg_inst *inst, struct vdec_v4l2_buffer **out)
@@ -568,6 +569,13 @@ static int vdec_mjpeg_get_param(unsigned long h_vdec,
 		get_crop_info(inst, out);
 		break;
 
+	case GET_PARAM_DW_MODE:
+	{
+		unsigned int* mode = out;
+		*mode = VDEC_DW_NO_AFBC;
+		break;
+	}
+
 	default:
 		v4l_dbg(inst->ctx, V4L_DEBUG_CODEC_ERROR,
 			"invalid get parameter type=%d\n", type);
@@ -599,7 +607,7 @@ static void set_param_ps_info(struct vdec_mjpeg_inst *inst,
 	pic->coded_width	= ps->coded_width;
 	pic->coded_height	= ps->coded_height;
 	pic->y_len_sz		= pic->coded_width * pic->coded_height;
-	pic->c_len_sz		= pic->y_len_sz;
+	pic->c_len_sz		= pic->y_len_sz >> 1;
 
 	dec->dpb_sz		= ps->dpb_size;
 
diff --git a/drivers/amvdec_ports/decoder/vdec_mpeg12_if.c b/drivers/amvdec_ports/decoder/vdec_mpeg12_if.c
index fa272841..b1139481 100644
--- a/drivers/amvdec_ports/decoder/vdec_mpeg12_if.c
+++ b/drivers/amvdec_ports/decoder/vdec_mpeg12_if.c
@@ -194,7 +194,6 @@ static int vdec_mpeg12_init(struct aml_vcodec_ctx *ctx, unsigned long *h_vdec)
 		return -ENOMEM;
 
 	inst->vdec.video_type	= VFORMAT_MPEG12;
-	inst->vdec.dev		= ctx->dev->vpu_plat_dev;
 	inst->vdec.filp		= ctx->dev->filp;
 	inst->vdec.config	= ctx->config;
 	inst->vdec.ctx		= ctx;
@@ -219,6 +218,7 @@ static int vdec_mpeg12_init(struct aml_vcodec_ctx *ctx, unsigned long *h_vdec)
 		goto err;
 	}
 
+	ctx->vfm = &inst->vfm;
 	ret = video_decoder_init(&inst->vdec);
 	if (ret) {
 		v4l_dbg(inst->ctx, V4L_DEBUG_CODEC_ERROR,
@@ -433,7 +433,7 @@ static void vdec_mpeg12_deinit(unsigned long h_vdec)
 
 static int vdec_mpeg12_get_fb(struct vdec_mpeg12_inst *inst, struct vdec_v4l2_buffer **out)
 {
-	return get_fb_from_queue(inst->ctx, out);
+	return get_fb_from_queue(inst->ctx, out, false);
 }
 
 static void vdec_mpeg12_get_vf(struct vdec_mpeg12_inst *inst, struct vdec_v4l2_buffer **out)
@@ -555,6 +555,12 @@ static int vdec_mpeg12_get_param(unsigned long h_vdec,
 		get_crop_info(inst, out);
 		break;
 
+	case GET_PARAM_DW_MODE:
+	{
+		unsigned int* mode = out;
+		*mode = VDEC_DW_NO_AFBC;
+		break;
+	}
 	default:
 		v4l_dbg(inst->ctx, V4L_DEBUG_CODEC_ERROR,
 			"invalid get parameter type=%d\n", type);
diff --git a/drivers/amvdec_ports/decoder/vdec_mpeg4_if.c b/drivers/amvdec_ports/decoder/vdec_mpeg4_if.c
index e067e156..a3bc1d34 100644
--- a/drivers/amvdec_ports/decoder/vdec_mpeg4_if.c
+++ b/drivers/amvdec_ports/decoder/vdec_mpeg4_if.c
@@ -196,7 +196,6 @@ static int vdec_mpeg4_init(struct aml_vcodec_ctx *ctx, unsigned long *h_vdec)
 
 	inst->vdec.video_type	= VFORMAT_MPEG4;
 	inst->vdec.format	= VIDEO_DEC_FORMAT_MPEG4_5;
-	inst->vdec.dev		= ctx->dev->vpu_plat_dev;
 	inst->vdec.filp		= ctx->dev->filp;
 	inst->vdec.config	= ctx->config;
 	inst->vdec.ctx		= ctx;
@@ -221,6 +220,7 @@ static int vdec_mpeg4_init(struct aml_vcodec_ctx *ctx, unsigned long *h_vdec)
 	}
 	dec_init = true;
 
+	ctx->vfm = &inst->vfm;
 	ret = video_decoder_init(&inst->vdec);
 	if (ret) {
 		v4l_dbg(inst->ctx, V4L_DEBUG_CODEC_ERROR,
@@ -443,7 +443,7 @@ static void vdec_mpeg4_deinit(unsigned long h_vdec)
 
 static int vdec_mpeg4_get_fb(struct vdec_mpeg4_inst *inst, struct vdec_v4l2_buffer **out)
 {
-	return get_fb_from_queue(inst->ctx, out);
+	return get_fb_from_queue(inst->ctx, out, false);
 }
 
 static void vdec_mpeg4_get_vf(struct vdec_mpeg4_inst *inst, struct vdec_v4l2_buffer **out)
diff --git a/drivers/amvdec_ports/decoder/vdec_vp9_if.c b/drivers/amvdec_ports/decoder/vdec_vp9_if.c
index 6704350b..1deccaed 100644
--- a/drivers/amvdec_ports/decoder/vdec_vp9_if.c
+++ b/drivers/amvdec_ports/decoder/vdec_vp9_if.c
@@ -126,6 +126,7 @@ struct vdec_vp9_inst {
 	struct vcodec_vfm_s vfm;
 	struct aml_dec_params parms;
 	struct completion comp;
+	struct vdec_comp_buf_info comp_info;
 };
 
 static int vdec_write_nalu(struct vdec_vp9_inst *inst,
@@ -265,7 +266,6 @@ static int vdec_vp9_init(struct aml_vcodec_ctx *ctx, unsigned long *h_vdec)
 		return -ENOMEM;
 
 	inst->vdec.video_type	= VFORMAT_VP9;
-	inst->vdec.dev		= ctx->dev->vpu_plat_dev;
 	inst->vdec.filp		= ctx->dev->filp;
 	inst->vdec.ctx		= ctx;
 	inst->ctx		= ctx;
@@ -289,6 +289,7 @@ static int vdec_vp9_init(struct aml_vcodec_ctx *ctx, unsigned long *h_vdec)
 		goto err;
 	}
 
+	ctx->vfm = &inst->vfm;
 	/* probe info from the stream */
 	inst->vsi = kzalloc(sizeof(struct vdec_vp9_vsi), GFP_KERNEL);
 	if (!inst->vsi) {
@@ -580,7 +581,7 @@ static void vdec_vp9_deinit(unsigned long h_vdec)
 
 static int vdec_vp9_get_fb(struct vdec_vp9_inst *inst, struct vdec_v4l2_buffer **out)
 {
-	return get_fb_from_queue(inst->ctx, out);
+	return get_fb_from_queue(inst->ctx, out, false);
 }
 
 static void vdec_vp9_get_vf(struct vdec_vp9_inst *inst, struct vdec_v4l2_buffer **out)
@@ -917,6 +918,12 @@ static int vdec_vp9_decode(unsigned long h_vdec,
 		"parms status: %u\n", parms->parms_status);
  }
 
+static void get_param_comp_buf_info(struct vdec_vp9_inst *inst,
+		struct vdec_comp_buf_info *params)
+{
+	memcpy(params, &inst->comp_info, sizeof(*params));
+}
+
 static int vdec_vp9_get_param(unsigned long h_vdec,
 			       enum vdec_get_param_type type, void *out)
 {
@@ -953,6 +960,17 @@ static int vdec_vp9_get_param(unsigned long h_vdec,
 	case GET_PARAM_CONFIG_INFO:
 		get_param_config_info(inst, out);
 		break;
+
+	case GET_PARAM_DW_MODE:
+	{
+		unsigned int *mode = out;
+		*mode = inst->ctx->config.parm.dec.cfg.double_write_mode;
+		break;
+	}
+	case GET_PARAM_COMP_BUF_INFO:
+		get_param_comp_buf_info(inst, out);
+		break;
+
 	default:
 		v4l_dbg(inst->ctx, V4L_DEBUG_CODEC_ERROR,
 			"invalid get parameter type=%d\n", type);
@@ -973,6 +991,7 @@ static void set_param_ps_info(struct vdec_vp9_inst *inst,
 	struct vdec_pic_info *pic = &inst->vsi->pic;
 	struct vdec_vp9_dec_info *dec = &inst->vsi->dec;
 	struct v4l2_rect *rect = &inst->vsi->crop;
+	int dw = inst->parms.cfg.double_write_mode;
 
 	/* fill visible area size that be used for EGL. */
 	pic->visible_width	= ps->visible_width;
@@ -988,7 +1007,8 @@ static void set_param_ps_info(struct vdec_vp9_inst *inst,
 	pic->coded_width	= ps->coded_width;
 	pic->coded_height	= ps->coded_height;
 
-	pic->y_len_sz		= pic->coded_width * pic->coded_height;
+	pic->y_len_sz		= vdec_pic_scale(inst, pic->coded_width, dw) *
+				  vdec_pic_scale(inst, pic->coded_height, dw);
 	pic->c_len_sz		= pic->y_len_sz >> 1;
 
 	/* calc DPB size */
@@ -1003,9 +1023,15 @@ static void set_param_ps_info(struct vdec_vp9_inst *inst,
 
 	v4l_dbg(inst->ctx, V4L_DEBUG_CODEC_PRINFO,
 		"Parse from ucode, crop(%d x %d), coded(%d x %d) dpb: %d\n",
-		ps->visible_width, ps->visible_height,
-		ps->coded_width, ps->coded_height,
-		ps->dpb_size);
+		pic->visible_width, pic->visible_height,
+		pic->coded_width, pic->coded_height,
+		dec->dpb_sz);
+}
+
+static void set_param_comp_buf_info(struct vdec_vp9_inst *inst,
+		struct vdec_comp_buf_info *info)
+{
+	memcpy(&inst->comp_info, info, sizeof(*info));
 }
 
 static void set_param_hdr_info(struct vdec_vp9_inst *inst,
@@ -1051,6 +1077,10 @@ static int vdec_vp9_set_param(unsigned long h_vdec,
 		set_param_ps_info(inst, in);
 		break;
 
+	case SET_PARAM_COMP_BUF_INFO:
+		set_param_comp_buf_info(inst, in);
+		break;
+
 	case SET_PARAM_HDR_INFO:
 		set_param_hdr_info(inst, in);
 		break;
diff --git a/drivers/amvdec_ports/vdec_drv_if.h b/drivers/amvdec_ports/vdec_drv_if.h
index a04d8327..734d0fb9 100644
--- a/drivers/amvdec_ports/vdec_drv_if.h
+++ b/drivers/amvdec_ports/vdec_drv_if.h
@@ -60,6 +60,15 @@ enum vdec_fb_status {
 	FB_ST_FREE
 };
 
+enum vdec_dw_mode {
+	VDEC_DW_AFBC_ONLY = 0,
+	VDEC_DW_AFBC_1_1_DW = 1,
+	VDEC_DW_AFBC_1_4_DW = 2,
+	VDEC_DW_AFBC_x2_1_4_DW = 3,
+	VDEC_DW_AFBC_1_2_DW = 4,
+	VDEC_DW_NO_AFBC = 16,
+};
+
 /* For GET_PARAM_DISP_FRAME_BUFFER and GET_PARAM_FREE_FRAME_BUFFER,
  * the caller does not own the returned buffer. The buffer will not be
  *				released before vdec_if_deinit.
@@ -69,6 +78,8 @@ enum vdec_fb_status {
  * GET_PARAM_PIC_INFO		: get picture info, struct vdec_pic_info*
  * GET_PARAM_CROP_INFO		: get crop info, struct v4l2_crop*
  * GET_PARAM_DPB_SIZE		: get dpb size, unsigned int*
+ * GET_PARAM_DW_MODE:		: get double write mode, unsigned int*
+ * GET_PARAM_COMP_BUF_INFO	: get compressed buf info,  struct vdec_comp_buf_info*
  */
 enum vdec_get_param_type {
 	GET_PARAM_DISP_FRAME_BUFFER,
@@ -76,7 +87,9 @@ enum vdec_get_param_type {
 	GET_PARAM_PIC_INFO,
 	GET_PARAM_CROP_INFO,
 	GET_PARAM_DPB_SIZE,
-	GET_PARAM_CONFIG_INFO
+	GET_PARAM_CONFIG_INFO,
+	GET_PARAM_DW_MODE,
+	GET_PARAM_COMP_BUF_INFO,
 };
 
 /*
@@ -85,6 +98,7 @@ enum vdec_get_param_type {
 enum vdec_set_param_type {
 	SET_PARAM_WRITE_FRAME_SYNC,
 	SET_PARAM_PS_INFO,
+	SET_PARAM_COMP_BUF_INFO,
 	SET_PARAM_HDR_INFO,
 	SET_PARAM_POST_EVENT
 };
diff --git a/drivers/frame_provider/decoder/avs2/vavs2.c b/drivers/frame_provider/decoder/avs2/vavs2.c
index cf99ab5e..c9e5493b 100644
--- a/drivers/frame_provider/decoder/avs2/vavs2.c
+++ b/drivers/frame_provider/decoder/avs2/vavs2.c
@@ -932,18 +932,6 @@ static int get_double_write_mode_init(struct AVS2Decoder_s *dec)
 	return dw;
 }
 
-static int get_double_write_ratio(struct AVS2Decoder_s *dec,
-	int dw_mode)
-{
-	int ratio = 1;
-	if ((dw_mode == 2) ||
-			(dw_mode == 3))
-		ratio = 4;
-	else if (dw_mode == 4)
-		ratio = 2;
-	return ratio;
-}
-
 //#define	MAX_4K_NUM		0x1200
 #ifdef AVS2_10B_MMU
 int avs2_alloc_mmu(
@@ -1951,9 +1939,9 @@ static void init_buf_list(struct AVS2Decoder_s *dec)
 
 	if (dw_mode) {
 		int pic_width_dw = pic_width /
-			get_double_write_ratio(dec, dw_mode);
+			get_double_write_ratio(dw_mode);
 		int pic_height_dw = pic_height /
-			get_double_write_ratio(dec, dw_mode);
+			get_double_write_ratio(dw_mode);
 		int lcu_size = 64; /*fixed 64*/
 		int pic_width_64 = (pic_width_dw + 63) & (~0x3f);
 		int pic_height_32 = (pic_height_dw + 31) & (~0x1f);
@@ -2076,9 +2064,9 @@ static int config_pic(struct AVS2Decoder_s *dec,
 
 	if (dw_mode) {
 		int pic_width_dw = pic_width /
-			get_double_write_ratio(dec, dw_mode);
+			get_double_write_ratio(dw_mode);
 		int pic_height_dw = pic_height /
-			get_double_write_ratio(dec, dw_mode);
+			get_double_write_ratio(dw_mode);
 		int pic_width_64_dw = (pic_width_dw + 63) & (~0x3f);
 		int pic_height_32_dw = (pic_height_dw + 31) & (~0x1f);
 		int pic_width_lcu_dw  = (pic_width_64_dw % lcu_size) ?
@@ -3979,11 +3967,9 @@ static void set_canvas(struct AVS2Decoder_s *dec,
 	/*CANVAS_BLKMODE_64X32*/
 	if	(pic->double_write_mode) {
 		canvas_w = pic->pic_w	/
-				get_double_write_ratio(dec,
-					pic->double_write_mode);
+				get_double_write_ratio(pic->double_write_mode);
 		canvas_h = pic->pic_h /
-				get_double_write_ratio(dec,
-					pic->double_write_mode);
+				get_double_write_ratio(pic->double_write_mode);
 
 		if (mem_map_mode == 0)
 			canvas_w = ALIGN(canvas_w, 32);
@@ -4557,11 +4543,9 @@ static void set_vframe(struct AVS2Decoder_s *dec,
 		   vf->width,vf->height, pic->width,
 			pic->height); */
 		vf->width = pic->pic_w /
-			get_double_write_ratio(dec,
-				pic->double_write_mode);
+			get_double_write_ratio(pic->double_write_mode);
 		vf->height = pic->pic_h /
-			get_double_write_ratio(dec,
-				pic->double_write_mode);
+			get_double_write_ratio(pic->double_write_mode);
 		if (force_w_h != 0) {
 			vf->width = (force_w_h >> 16) & 0xffff;
 			vf->height = force_w_h & 0xffff;
diff --git a/drivers/frame_provider/decoder/h264_multi/vmh264.c b/drivers/frame_provider/decoder/h264_multi/vmh264.c
index 08c5d91c..92f5d335 100644
--- a/drivers/frame_provider/decoder/h264_multi/vmh264.c
+++ b/drivers/frame_provider/decoder/h264_multi/vmh264.c
@@ -1084,19 +1084,6 @@ static int  compute_losless_comp_header_size(int width, int height)
 	return  hsize;
 }
 
-static int get_double_write_ratio(struct vdec_h264_hw_s *hw)
-{
-	int ratio = 1;
-	int dw_mode = hw->double_write_mode;
-	if ((dw_mode == 2) ||
-			(dw_mode == 3))
-		ratio = 4;
-	else if (dw_mode == 4)
-		ratio = 2;
-	return ratio;
-}
-
-
 static int get_dw_size(struct vdec_h264_hw_s *hw, u32 *pdw_buffer_size_u_v_h)
 {
 	int pic_width, pic_height;
@@ -1111,9 +1098,9 @@ static int get_dw_size(struct vdec_h264_hw_s *hw, u32 *pdw_buffer_size_u_v_h)
 
 	if (dw_mode) {
 		int pic_width_dw = pic_width /
-			get_double_write_ratio(hw);
+			get_double_write_ratio(hw->double_write_mode);
 		int pic_height_dw = pic_height /
-			get_double_write_ratio(hw);
+			get_double_write_ratio(hw->double_write_mode);
 
 		int pic_width_lcu_dw = (pic_width_dw % lcu_size) ?
 			pic_width_dw / lcu_size + 1 :
@@ -1196,9 +1183,9 @@ static void hevc_mcr_config_canv2axitbl(struct vdec_h264_hw_s *hw, int restore)
 			int canvas_h;
 
 			canvas_w = hw->frame_width /
-				get_double_write_ratio(hw);
+				get_double_write_ratio(hw->double_write_mode);
 			canvas_h = hw->frame_height /
-				get_double_write_ratio(hw);
+				get_double_write_ratio(hw->double_write_mode);
 
 			if (hw->canvas_mode == 0)
 				canvas_w = ALIGN(canvas_w, 32);
@@ -2131,9 +2118,9 @@ static void config_decode_canvas_ex(struct vdec_h264_hw_s *hw, int i)
 	int canvas_h;
 
 	canvas_w = hw->frame_width /
-		get_double_write_ratio(hw);
+		get_double_write_ratio(hw->double_write_mode);
 	canvas_h = hw->frame_height /
-		get_double_write_ratio(hw);
+		get_double_write_ratio(hw->double_write_mode);
 
 	if (hw->canvas_mode == 0)
 		canvas_w = ALIGN(canvas_w, 32);
@@ -3021,9 +3008,9 @@ static int post_video_frame(struct vdec_s *vdec, struct FrameStore *frame)
 
 		if (hw->mmu_enable && hw->double_write_mode) {
 			vf->width = hw->frame_width /
-				get_double_write_ratio(hw);
+				get_double_write_ratio(hw->double_write_mode);
 			vf->height = hw->frame_height /
-				get_double_write_ratio(hw);
+				get_double_write_ratio(hw->double_write_mode);
 		}
 
 		vf->flag = 0;
@@ -4257,9 +4244,9 @@ static struct vframe_s *vh264_vf_get(void *op_arg)
 
 			if (hw->double_write_mode) {
 				vf->width = hw->frame_width /
-					get_double_write_ratio(hw);
+					get_double_write_ratio(hw->double_write_mode);
 				vf->height = hw->frame_height /
-					get_double_write_ratio(hw);
+					get_double_write_ratio(hw->double_write_mode);
 			}
 		} else {
 			vf->type = VIDTYPE_PROGRESSIVE | VIDTYPE_VIU_FIELD |
@@ -8824,6 +8811,7 @@ static int vmh264_get_ps_info(struct vdec_h264_hw_s *hw,
 	 * bit 15: frame_mbs_only_flag
 	 * bit 13-14: chroma_format_idc
 	 */
+	hw->seq_info = param2;
 	frame_mbs_only_flag = (hw->seq_info >> 15) & 0x01;
 	if (hw->dpb.mSPS.profile_idc != 100 &&
 		hw->dpb.mSPS.profile_idc != 110 &&
diff --git a/drivers/frame_provider/decoder/h265/vh265.c b/drivers/frame_provider/decoder/h265/vh265.c
index f97a71e5..a8291403 100644
--- a/drivers/frame_provider/decoder/h265/vh265.c
+++ b/drivers/frame_provider/decoder/h265/vh265.c
@@ -1414,6 +1414,9 @@ struct PIC_s {
 	unsigned int dw_y_adr;
 	unsigned int dw_u_v_adr;
 #endif
+	u32	luma_size;
+	u32	chroma_size;
+
 	int mc_canvas_y;
 	int mc_canvas_u_v;
 	int width;
@@ -1464,7 +1467,6 @@ struct PIC_s {
 
 	u32 hw_decode_time;
 	u32 frame_size; // For frame base mode
-	bool vframe_bound;
 	bool ip_mode;
 	u32 stream_frame_size;  //for stream base
 	u32 hdr10p_data_size;
@@ -2047,30 +2049,15 @@ static int get_double_write_mode(struct hevc_state_s *hevc)
 	int w = hevc->pic_w;
 	int h = hevc->pic_h;
 	u32 dw = 0x1; /*1:1*/
-	switch (valid_dw_mode) {
-	case 0x100:
-		if (w > 1920 && h > 1088)
-			dw = 0x4; /*1:2*/
-		break;
-	case 0x200:
-		if (w > 1920 && h > 1088)
-			dw = 0x2; /*1:4*/
-		break;
-	case 0x300:
-		if (w > 1280 && h > 720)
-			dw = 0x4; /*1:2*/
-		break;
-	default:
-		dw = valid_dw_mode;
-		break;
+
+	if (hevc->is_used_v4l) {
+		unsigned int out;
+
+		vdec_v4l_get_dw_mode(hevc->v4l2_ctx, &out);
+		dw = out;
+		return dw;
 	}
-	return dw;
-}
 
-static int v4l_parser_get_double_write_mode(struct hevc_state_s *hevc, int w, int h)
-{
-	u32 valid_dw_mode = get_valid_double_write_mode(hevc);
-	u32 dw = 0x1; /*1:1*/
 	switch (valid_dw_mode) {
 	case 0x100:
 		if (w > 1920 && h > 1088)
@@ -2099,19 +2086,6 @@ static int v4l_parser_get_double_write_mode(struct hevc_state_s *hevc, int w, in
 	return dw;
 }
 
-
-static int get_double_write_ratio(struct hevc_state_s *hevc,
-	int dw_mode)
-{
-	int ratio = 1;
-	if ((dw_mode == 2) ||
-			(dw_mode == 3))
-		ratio = 4;
-	else if ((dw_mode == 4) ||
-				(dw_mode == 5))
-		ratio = 2;
-	return ratio;
-}
 #ifdef CONFIG_AMLOGIC_MEDIA_MULTI_DEC
 static unsigned char get_idx(struct hevc_state_s *hevc)
 {
@@ -2861,68 +2835,33 @@ static unsigned int log2i(unsigned int val)
 
 static int init_buf_spec(struct hevc_state_s *hevc);
 
-static bool v4l_is_there_vframe_bound(struct hevc_state_s *hevc)
-{
-	int i;
 
-	for (i = 0; i < MAX_REF_PIC_NUM; i++) {
-		struct PIC_s *pic = hevc->m_PIC[i];
-
-		if (pic && pic->vframe_bound)
-			return true;
-	}
-
-	return false;
-}
-
-static void v4l_mmu_buffer_release(struct hevc_state_s *hevc)
+static void uninit_mmu_buffers(struct hevc_state_s *hevc)
 {
-	int i;
+	if (hevc->mmu_box) {
+		decoder_mmu_box_free(hevc->mmu_box);
+		hevc->mmu_box = NULL;
+	}
 
-	/* release workspace */
-	if (hevc->bmmu_box)
+	if (hevc->bmmu_box) {
+		/* release workspace */
 		decoder_bmmu_box_free_idx(hevc->bmmu_box,
 			BMMU_WORKSPACE_ID);
-	/*
-	 * it's only when vframe get back to driver, right now we can be sure
-	 * that vframe and fd are related. if the playback exits, the capture
-	 * requires the upper app to release when the fd is closed, and others
-	 * buffers drivers are released by driver.
-	 */
-	for (i = 0; i < MAX_REF_PIC_NUM; i++) {
-		struct PIC_s *pic = hevc->m_PIC[i];
-
-		if (pic && !pic->vframe_bound) {
-			if (hevc->bmmu_box)
-				decoder_bmmu_box_free_idx(hevc->bmmu_box,
-					VF_BUFFER_IDX(i));
-			if (hevc->mmu_box)
-				decoder_mmu_box_free_idx(hevc->mmu_box, i);
-
-			hevc_print(hevc, PRINT_FLAG_V4L_DETAIL,
-				"%s free buffer[%d], bmmu_box: %p, mmu_box: %p\n",
-				__func__, i, hevc->bmmu_box, hevc->mmu_box);
-		}
+		decoder_bmmu_box_free(hevc->bmmu_box);
+		hevc->bmmu_box = NULL;
 	}
 }
 
-static void uninit_mmu_buffers(struct hevc_state_s *hevc)
+/* return in MB */
+static int hevc_max_mmu_buf_size(int max_w, int max_h)
 {
-	if (hevc->is_used_v4l &&
-		v4l_is_there_vframe_bound(hevc)) {
-		if (get_double_write_mode(hevc) != 0x10) {
-			v4l_mmu_buffer_release(hevc);
-			return;
-		}
-	}
-
-	if (hevc->mmu_box)
-		decoder_mmu_box_free(hevc->mmu_box);
-	hevc->mmu_box = NULL;
+	int buf_size = 64;
 
-	if (hevc->bmmu_box)
-		decoder_bmmu_box_free(hevc->bmmu_box);
-	hevc->bmmu_box = NULL;
+	if ((max_w * max_h) > 0 &&
+		(max_w * max_h) <= 1920*1088) {
+		buf_size = 24;
+	}
+	return buf_size;
 }
 
 static int init_mmu_box(struct hevc_state_s *hevc)
@@ -2964,12 +2903,8 @@ static int init_mmu_buffers(struct hevc_state_s *hevc)
 {
 	int tvp_flag = vdec_secure(hw_to_vdec(hevc)) ?
 		CODEC_MM_FLAGS_TVP : 0;
-	int buf_size = 64;
-
-	if ((hevc->max_pic_w * hevc->max_pic_h) > 0 &&
-		(hevc->max_pic_w * hevc->max_pic_h) <= 1920*1088) {
-		buf_size = 24;
-	}
+	int buf_size = hevc_max_mmu_buf_size(hevc->max_pic_w,
+			hevc->max_pic_h);
 
 	if (get_dbg_flag(hevc)) {
 		hevc_print(hevc, 0, "%s max_w %d max_h %d\n",
@@ -2978,8 +2913,7 @@ static int init_mmu_buffers(struct hevc_state_s *hevc)
 
 	hevc->need_cache_size = buf_size * SZ_1M;
 	hevc->sc_start_time = get_jiffies_64();
-	if (hevc->mmu_enable
-		&& ((get_double_write_mode(hevc) & 0x10) == 0)) {
+	if (hevc->mmu_enable && !hevc->is_used_v4l) {
 		hevc->mmu_box = decoder_mmu_box_alloc_box(DRIVER_NAME,
 			hevc->index,
 			MAX_REF_PIC_NUM,
@@ -3226,9 +3160,9 @@ static int cal_current_buf_size(struct hevc_state_s *hevc,
 
 	if (dw_mode) {
 		int pic_width_dw = pic_width /
-			get_double_write_ratio(hevc, dw_mode);
+			get_double_write_ratio(dw_mode);
 		int pic_height_dw = pic_height /
-			get_double_write_ratio(hevc, dw_mode);
+			get_double_write_ratio(dw_mode);
 
 		int pic_width_lcu_dw = (pic_width_dw % lcu_size) ?
 			pic_width_dw / lcu_size + 1 :
@@ -3269,15 +3203,45 @@ static int cal_current_buf_size(struct hevc_state_s *hevc,
 	return buf_size;
 }
 
+static int hevc_get_header_size(int w, int h)
+{
+	if ((get_cpu_major_id() >= AM_MESON_CPU_MAJOR_ID_SM1) &&
+			(IS_8K_SIZE(w, h)))
+		return ALIGN(MMU_COMPRESS_8K_HEADER_SIZE, 0x10000);
+	else
+		return ALIGN(MMU_COMPRESS_HEADER_SIZE, 0x10000);
+}
+
+static struct internal_comp_buf* v4lfb_to_icomp_buf(
+		struct hevc_state_s *hevc,
+		struct vdec_v4l2_buffer *fb)
+{
+	struct aml_video_dec_buf *aml_fb = NULL;
+	struct aml_vcodec_ctx * v4l2_ctx = hevc->v4l2_ctx;
+
+	aml_fb = container_of(fb, struct aml_video_dec_buf, frame_buffer);
+	return &v4l2_ctx->comp_bufs[aml_fb->internal_index];
+}
+
+static struct internal_comp_buf* index_to_icomp_buf(
+		struct hevc_state_s *hevc, int index)
+{
+	struct aml_video_dec_buf *aml_fb = NULL;
+	struct aml_vcodec_ctx * v4l2_ctx = hevc->v4l2_ctx;
+	struct vdec_v4l2_buffer *fb = NULL;
+
+	fb = (struct vdec_v4l2_buffer *)
+		hevc->m_BUF[index].v4l_ref_buf_addr;
+	aml_fb = container_of(fb, struct aml_video_dec_buf, frame_buffer);
+	return &v4l2_ctx->comp_bufs[aml_fb->internal_index];
+}
+
 static int v4l_alloc_buf(struct hevc_state_s *hevc, struct PIC_s *pic)
 {
 	int ret = -1;
 	int i = pic->index;
 	struct vdec_v4l2_buffer *fb = NULL;
 
-	if (hevc->fatal_error & DECODER_FATAL_ERROR_NO_MEM)
-		return ret;
-
 	ret = vdec_v4l_get_buffer(hevc->v4l2_ctx, &fb);
 	if (ret < 0) {
 		hevc_print(hevc, 0, "[%d] H265 get buffer fail.\n",
@@ -3286,23 +3250,8 @@ static int v4l_alloc_buf(struct hevc_state_s *hevc, struct PIC_s *pic)
 	}
 
 	if (hevc->mmu_enable) {
-		if ((get_cpu_major_id() >= AM_MESON_CPU_MAJOR_ID_SM1) &&
-			(IS_8K_SIZE(hevc->pic_w, hevc->pic_h)))
-			hevc->m_BUF[i].header_size =
-				ALIGN(MMU_COMPRESS_8K_HEADER_SIZE, 0x10000);
-		else
-			hevc->m_BUF[i].header_size =
-				ALIGN(MMU_COMPRESS_HEADER_SIZE, 0x10000);
-
-		ret = decoder_bmmu_box_alloc_buf_phy(hevc->bmmu_box,
-			VF_BUFFER_IDX(i), hevc->m_BUF[i].header_size,
-			DRIVER_NAME, &hevc->m_BUF[i].header_addr);
-		if (ret < 0) {
-			hevc_print(hevc, PRINT_FLAG_ERROR,
-				"%s[%d], header size: %d, no mem fatal err\n",
-				__func__, i, hevc->m_BUF[i].header_size);
-			return ret;
-		}
+		struct internal_comp_buf *ibuf = v4lfb_to_icomp_buf(hevc, fb);
+		hevc->m_BUF[i].header_addr = ibuf->header_addr;
 	}
 
 	hevc->m_BUF[i].used_flag	= 0;
@@ -3315,6 +3264,8 @@ static int v4l_alloc_buf(struct hevc_state_s *hevc, struct PIC_s *pic)
 		fb->m.mem[0].bytes_used = fb->m.mem[0].size;
 		pic->dw_y_adr = hevc->m_BUF[i].start_adr;
 		pic->dw_u_v_adr = pic->dw_y_adr + hevc->m_BUF[i].luma_size;
+		pic->luma_size = fb->m.mem[0].offset;
+		pic->chroma_size = fb->m.mem[0].size - fb->m.mem[0].offset;
 	} else if (fb->num_planes == 2) {
 		hevc->m_BUF[i].start_adr = fb->m.mem[0].addr;
 		hevc->m_BUF[i].luma_size = fb->m.mem[0].size;
@@ -3325,6 +3276,8 @@ static int v4l_alloc_buf(struct hevc_state_s *hevc, struct PIC_s *pic)
 		fb->m.mem[1].bytes_used = fb->m.mem[1].size;
 		pic->dw_y_adr = hevc->m_BUF[i].start_adr;
 		pic->dw_u_v_adr = hevc->m_BUF[i].chroma_addr;
+		pic->luma_size = fb->m.mem[0].size;
+		pic->chroma_size = fb->m.mem[1].size;
 	}
 
 	return ret;
@@ -3435,6 +3388,7 @@ static void dealloc_unused_buf(struct hevc_state_s *hevc)
 					hevc->bmmu_box,
 					VF_BUFFER_IDX(i));
 			hevc->m_BUF[i].start_adr = 0;
+			hevc->m_BUF[i].header_addr = 0;
 			hevc->m_BUF[i].size = 0;
 		}
 	}
@@ -3461,6 +3415,7 @@ static void dealloc_pic_buf(struct hevc_state_s *hevc,
 				VF_BUFFER_IDX(i));
 		hevc->m_BUF[i].used_flag = 0;
 		hevc->m_BUF[i].start_adr = 0;
+		hevc->m_BUF[i].header_addr = 0;
 		hevc->m_BUF[i].size = 0;
 	}
 }
@@ -5533,6 +5488,17 @@ static void config_sao_hw(struct hevc_state_s *hevc, union param_u *params)
 	data32 = (mc_buffer_size_u_v_h << 16);
 	WRITE_VREG(HEVC_SAO_C_LENGTH, data32);
 
+	if (hevc->is_used_v4l) {
+		WRITE_VREG(HEVC_SAO_Y_LENGTH, cur_pic->luma_size);
+		WRITE_VREG(HEVC_SAO_C_LENGTH, cur_pic->chroma_size);
+		if (debug & PRINT_FLAG_V4L_DETAIL) {
+			pr_info("[%d] config pic, id: %d, Y:(%x, %d) C:(%x, %d).\n",
+				v4l2_ctx->id, cur_pic->index,
+				cur_pic->dw_y_adr, cur_pic->luma_size,
+				cur_pic->dw_u_v_adr, cur_pic->chroma_size);
+		}
+	}
+
 #ifdef LOSLESS_COMPRESS_MODE
 /*SUPPORT_10BIT*/
 	if (get_double_write_mode(hevc)) {
@@ -6043,7 +6009,6 @@ static struct PIC_s *v4l_get_new_pic(struct hevc_state_s *hevc,
 			}
 			break;
 		default:
-			pr_err("v4l buffer state err %d.\n", state);
 			break;
 		}
 
@@ -6077,7 +6042,6 @@ static struct PIC_s *v4l_get_new_pic(struct hevc_state_s *hevc,
 	new_pic->referenced = 1;
 	new_pic->decode_idx = hevc->decode_idx;
 	new_pic->slice_idx = 0;
-	new_pic->referenced = 1;
 	new_pic->output_mark = 0;
 	new_pic->recon_mark = 0;
 	new_pic->error_mark = 0;
@@ -6417,6 +6381,39 @@ static void release_aux_data(struct hevc_state_s *hevc,
 	pic->aux_data_size = 0;
 }
 
+static int recycle_mmu_buf_tail(struct hevc_state_s *hevc,
+		bool check_dma)
+{
+	hevc_print(hevc,
+			H265_DEBUG_BUFMGR_MORE,
+			"%s pic index %d scatter_alloc %d page_start %d\n",
+			"decoder_mmu_box_free_idx_tail",
+			hevc->cur_pic->index,
+			hevc->cur_pic->scatter_alloc,
+			hevc->used_4k_num);
+	if (check_dma)
+		hevc_mmu_dma_check(hw_to_vdec(hevc));
+
+	if (hevc->is_used_v4l) {
+		int index = hevc->cur_pic->BUF_index;
+		struct internal_comp_buf *ibuf =
+			index_to_icomp_buf(hevc, index);
+
+		decoder_mmu_box_free_idx_tail(
+				ibuf->mmu_box,
+				ibuf->index,
+				hevc->used_4k_num);
+	} else {
+		decoder_mmu_box_free_idx_tail(
+				hevc->mmu_box,
+				hevc->cur_pic->index,
+				hevc->used_4k_num);
+	}
+	hevc->cur_pic->scatter_alloc = 2;
+	hevc->used_4k_num = -1;
+	return 0;
+}
+
 static inline void hevc_pre_pic(struct hevc_state_s *hevc,
 			struct PIC_s *pic)
 {
@@ -6464,23 +6461,8 @@ static inline void hevc_pre_pic(struct hevc_state_s *hevc,
 					if ((!is_skip_decoding(hevc, pic)) &&
 						(hevc->used_4k_num >= 0) &&
 						(hevc->cur_pic->scatter_alloc
-						== 1)) {
-						hevc_print(hevc,
-						H265_DEBUG_BUFMGR_MORE,
-						"%s pic index %d scatter_alloc %d page_start %ld\n",
-						"decoder_mmu_box_free_idx_tail",
-						hevc->cur_pic->index,
-						hevc->cur_pic->scatter_alloc,
-						hevc->used_4k_num);
-						hevc_mmu_dma_check(hw_to_vdec(hevc));
-						decoder_mmu_box_free_idx_tail(
-						hevc->mmu_box,
-						hevc->cur_pic->index,
-						hevc->used_4k_num);
-						hevc->cur_pic->scatter_alloc
-							= 2;
-					}
-					hevc->used_4k_num = -1;
+						== 1))
+						recycle_mmu_buf_tail(hevc, true);
 				}
 			}
 			if (!pic->ip_mode)
@@ -7823,46 +7805,67 @@ static int hevc_slice_segment_header_process(struct hevc_state_s *hevc,
 	return 0;
 }
 
+/* return page number */
+static int hevc_mmu_page_num(struct hevc_state_s *hevc,
+		int w, int h, int save_mode)
+{
+	int picture_size;
+	int page_num;
+	int max_frame_num;
 
+	picture_size = compute_losless_comp_body_size(hevc, w,
+				h, save_mode);
+	page_num = ((picture_size + PAGE_SIZE - 1) >> PAGE_SHIFT);
+
+	if (get_cpu_major_id() >= AM_MESON_CPU_MAJOR_ID_SM1)
+		max_frame_num = MAX_FRAME_8K_NUM;
+	else
+		max_frame_num = MAX_FRAME_4K_NUM;
+
+	if (page_num > max_frame_num) {
+		hevc_print(hevc, 0, "over max !! 0x%x width %d height %d\n",
+			page_num, w, h);
+		return -1;
+	}
+	return page_num;
+}
 
 static int H265_alloc_mmu(struct hevc_state_s *hevc, struct PIC_s *new_pic,
 		unsigned short bit_depth, unsigned int *mmu_index_adr) {
-	int cur_buf_idx = new_pic->index;
 	int bit_depth_10 = (bit_depth != 0x00);
-	int picture_size;
 	int cur_mmu_4k_number;
-	int ret, max_frame_num;
-	picture_size = compute_losless_comp_body_size(hevc, new_pic->width,
-				new_pic->height, !bit_depth_10);
-	cur_mmu_4k_number = ((picture_size+(1<<12)-1) >> 12);
+	int ret;
+
 	if (get_double_write_mode(hevc) == 0x10)
 		return 0;
-	/*hevc_print(hevc, 0,
-	"alloc_mmu cur_idx : %d picture_size : %d mmu_4k_number : %d\r\n",
-	cur_buf_idx, picture_size, cur_mmu_4k_number);*/
 
-	if (get_cpu_major_id() >= AM_MESON_CPU_MAJOR_ID_SM1)
-		max_frame_num = MAX_FRAME_8K_NUM;
-	else
-		max_frame_num = MAX_FRAME_4K_NUM;
-	if (cur_mmu_4k_number > max_frame_num) {
-		hevc_print(hevc, 0, "over max !! 0x%x width %d height %d\n",
-			cur_mmu_4k_number,
-			new_pic->width,
-			new_pic->height);
+	cur_mmu_4k_number = hevc_mmu_page_num(hevc, new_pic->width,
+			new_pic->height, !bit_depth_10);
+	if (cur_mmu_4k_number < 0)
 		return -1;
+
+	if (hevc->is_used_v4l) {
+		struct internal_comp_buf *ibuf =
+			index_to_icomp_buf(hevc, new_pic->BUF_index);
+
+		ret = decoder_mmu_box_alloc_idx(
+				ibuf->mmu_box,
+				ibuf->index,
+				ibuf->frame_buffer_size,
+				mmu_index_adr);
+	} else {
+		ret = decoder_mmu_box_alloc_idx(
+				hevc->mmu_box,
+				new_pic->index,
+				cur_mmu_4k_number,
+				mmu_index_adr);
 	}
-	ret = decoder_mmu_box_alloc_idx(
-		hevc->mmu_box,
-		cur_buf_idx,
-		cur_mmu_4k_number,
-		mmu_index_adr);
 
 	new_pic->scatter_alloc = 1;
 
 	hevc_print(hevc, H265_DEBUG_BUFMGR_MORE,
 		"%s pic index %d page count(%d) ret =%d\n",
-		__func__, cur_buf_idx,
+		__func__, new_pic->index,
 		cur_mmu_4k_number, ret);
 	return ret;
 }
@@ -7877,9 +7880,16 @@ static void release_pic_mmu_buf(struct hevc_state_s *hevc,
 	pic->scatter_alloc);
 
 	if (hevc->mmu_enable
-		&& ((hevc->double_write_mode & 0x10) == 0)
-		&& pic->scatter_alloc)
-		decoder_mmu_box_free_idx(hevc->mmu_box, pic->index);
+		&& !(hevc->double_write_mode & 0x10)
+		&& pic->scatter_alloc) {
+		if (!hevc->is_used_v4l)
+			decoder_mmu_box_free_idx(hevc->mmu_box, pic->index);
+		else {
+			struct internal_comp_buf *ibuf =
+				ibuf = index_to_icomp_buf(hevc, pic->BUF_index);
+			decoder_mmu_box_free_idx(ibuf->mmu_box, ibuf->index);
+		}
+	}
 	pic->scatter_alloc = 0;
 }
 
@@ -8058,9 +8068,9 @@ static void set_canvas(struct hevc_state_s *hevc, struct PIC_s *pic)
 #ifdef SUPPORT_10BIT
 	if	(pic->double_write_mode) {
 		canvas_w = pic->width /
-			get_double_write_ratio(hevc, pic->double_write_mode);
+			get_double_write_ratio(pic->double_write_mode);
 		canvas_h = pic->height /
-			get_double_write_ratio(hevc, pic->double_write_mode);
+			get_double_write_ratio(pic->double_write_mode);
 
 		if (hevc->mem_map_mode == 0)
 			canvas_w = ALIGN(canvas_w, 32);
@@ -8401,9 +8411,9 @@ static void set_frame_info(struct hevc_state_s *hevc, struct vframe_s *vf,
 		= &vf->prop.master_display_colour;
 
 	vf->width = pic->width /
-		get_double_write_ratio(hevc, pic->double_write_mode);
+		get_double_write_ratio(pic->double_write_mode);
 	vf->height = pic->height /
-		get_double_write_ratio(hevc, pic->double_write_mode);
+		get_double_write_ratio(pic->double_write_mode);
 
 	vf->duration = hevc->frame_dur;
 	vf->duration_pulldown = 0;
@@ -8675,9 +8685,9 @@ static struct vframe_s *vh265_vf_get(void *op_arg)
 		set_frame_info(hevc, vf);
 
 		vf->width = pic->width /
-			get_double_write_ratio(hevc, pic->double_write_mode);
+			get_double_write_ratio(pic->double_write_mode);
 		vf->height = pic->height /
-			get_double_write_ratio(hevc, pic->double_write_mode);
+			get_double_write_ratio(pic->double_write_mode);
 
 		force_disp_pic_index |= 0x200;
 		return vf;
@@ -8811,8 +8821,6 @@ static void vh265_vf_put(struct vframe_s *vf, void *op_arg)
 	if (index_top != 0xff
 		&& index_top < MAX_REF_PIC_NUM
 		&& hevc->m_PIC[index_top]) {
-		if (hevc->is_used_v4l)
-			hevc->m_PIC[index_top]->vframe_bound = true;
 		if (hevc->m_PIC[index_top]->vf_ref > 0) {
 			hevc->m_PIC[index_top]->vf_ref--;
 
@@ -8830,8 +8838,6 @@ static void vh265_vf_put(struct vframe_s *vf, void *op_arg)
 	if (index_bot != 0xff
 		&& index_bot < MAX_REF_PIC_NUM
 		&& hevc->m_PIC[index_bot]) {
-		if (hevc->is_used_v4l)
-			hevc->m_PIC[index_bot]->vframe_bound = true;
 		if (hevc->m_PIC[index_bot]->vf_ref > 0) {
 			hevc->m_PIC[index_bot]->vf_ref--;
 
@@ -8973,6 +8979,8 @@ static int process_pending_vframe(struct hevc_state_s *hevc,
 					if (hevc->mmu_enable)
 						vf->type |= VIDTYPE_SCATTER;
 		}
+		if (hevc->is_used_v4l && hevc->double_write_mode != 16)
+			vf->type |= VIDTYPE_COMPRESS | VIDTYPE_SCATTER;
 		hevc->vf_pre_count++;
 		kfifo_put(&hevc->newframe_q, (const struct vframe_s *)vf);
 		spin_lock_irqsave(&lock, flags);
@@ -9013,6 +9021,8 @@ static int process_pending_vframe(struct hevc_state_s *hevc,
 					if (hevc->mmu_enable)
 						vf->type |= VIDTYPE_SCATTER;
 				}
+				if (hevc->is_used_v4l && hevc->double_write_mode != 16)
+					vf->type |= VIDTYPE_COMPRESS | VIDTYPE_SCATTER;
 				hevc->vf_pre_count++;
 				vdec_vframe_ready(hw_to_vdec(hevc), vf);
 				kfifo_put(&hevc->display_q,
@@ -9033,6 +9043,8 @@ static int process_pending_vframe(struct hevc_state_s *hevc,
 					if (hevc->mmu_enable)
 						vf->type |= VIDTYPE_SCATTER;
 				}
+				if (hevc->is_used_v4l && hevc->double_write_mode != 16)
+					vf->type |= VIDTYPE_COMPRESS | VIDTYPE_SCATTER;
 				vf->index &= 0xff;
 				vf->index |= (pair_pic->index << 8);
 				vf->canvas1Addr = spec2canvas(pair_pic);
@@ -9061,6 +9073,8 @@ static int process_pending_vframe(struct hevc_state_s *hevc,
 					if (hevc->mmu_enable)
 						vf->type |= VIDTYPE_SCATTER;
 				}
+				if (hevc->is_used_v4l && hevc->double_write_mode != 16)
+					vf->type |= VIDTYPE_COMPRESS | VIDTYPE_SCATTER;
 				vf->index &= 0xff00;
 				vf->index |= pair_pic->index;
 				vf->canvas0Addr = spec2canvas(pair_pic);
@@ -9083,10 +9097,14 @@ static int process_pending_vframe(struct hevc_state_s *hevc,
 static void update_vf_memhandle(struct hevc_state_s *hevc,
 	struct vframe_s *vf, struct PIC_s *pic)
 {
-	if (pic->index < 0) {
-		vf->mem_handle = NULL;
-		vf->mem_head_handle = NULL;
-	} else if (vf->type & VIDTYPE_SCATTER) {
+	vf->mem_handle = NULL;
+	vf->mem_head_handle = NULL;
+
+	/* keeper not needed for v4l solution */
+	if (hevc->is_used_v4l)
+		return;
+
+	if (vf->type & VIDTYPE_SCATTER) {
 		vf->mem_handle =
 			decoder_mmu_box_get_mem_handle(
 				hevc->mmu_box, pic->index);
@@ -9396,6 +9414,8 @@ static int post_video_frame(struct vdec_s *vdec, struct PIC_s *pic)
 				if (hevc->mmu_enable)
 					vf->type |= VIDTYPE_SCATTER;
 			}
+			if (hevc->is_used_v4l && pic->double_write_mode != 16)
+				vf->type |= VIDTYPE_COMPRESS | VIDTYPE_SCATTER;
 #ifdef MULTI_INSTANCE_SUPPORT
 			if (hevc->m_ins_flag &&
 				(get_dbg_flag(hevc)
@@ -9541,9 +9561,9 @@ static int post_video_frame(struct vdec_s *vdec, struct PIC_s *pic)
 		vf->sar_height = hevc->cur_pic->sar_height;
 
 		vf->width = vf->width /
-			get_double_write_ratio(hevc, pic->double_write_mode);
+			get_double_write_ratio(pic->double_write_mode);
 		vf->height = vf->height /
-			get_double_write_ratio(hevc, pic->double_write_mode);
+			get_double_write_ratio(pic->double_write_mode);
 #ifdef HEVC_PIC_STRUCT_SUPPORT
 		if (pic->pic_struct == 3 || pic->pic_struct == 4) {
 			struct vframe_s *vf2;
@@ -10259,17 +10279,34 @@ static void read_decode_info(struct hevc_state_s *hevc)
 
 static int vh265_get_ps_info(struct hevc_state_s *hevc, int width, int height, struct aml_vdec_ps_infos *ps)
 {
-	int dw_mode = v4l_parser_get_double_write_mode(hevc, width, height);
-
-	ps->visible_width 	= width / get_double_write_ratio(hevc, dw_mode);
-	ps->visible_height 	= height / get_double_write_ratio(hevc, dw_mode);
-	ps->coded_width 	= ALIGN(width, 32) / get_double_write_ratio(hevc, dw_mode);
-	ps->coded_height 	= ALIGN(height, 32) / get_double_write_ratio(hevc, dw_mode);
+	ps->visible_width 	= width;
+	ps->visible_height 	= height;
+	ps->coded_width 	= ALIGN(width, 32);
+	ps->coded_height 	= ALIGN(height, 32);
 	ps->dpb_size 		= v4l_parser_work_pic_num(hevc);
 
 	return 0;
 }
 
+static void get_comp_buf_info(struct hevc_state_s *hevc,
+		struct vdec_comp_buf_info *info)
+{
+	u16 bit_depth = hevc->param.p.bit_depth;
+	int w = hevc->param.p.pic_width_in_luma_samples;
+	int h = hevc->param.p.pic_height_in_luma_samples;
+
+	info->max_size = hevc_max_mmu_buf_size(
+			hevc->max_pic_w,
+			hevc->max_pic_h);
+	info->header_size = hevc_get_header_size(w,h);
+	info->frame_buffer_size = hevc_mmu_page_num(
+			hevc, w, h,	bit_depth == 0);
+
+	pr_info("hevc get comp info: %d %d %d\n",
+			info->max_size, info->header_size,
+			info->frame_buffer_size);
+}
+
 static int v4l_res_change(struct hevc_state_s *hevc, union param_u *rpm_param)
 {
 	struct aml_vcodec_ctx *ctx =
@@ -10292,6 +10329,13 @@ static int v4l_res_change(struct hevc_state_s *hevc, union param_u *rpm_param)
 				height,
 				hevc->interlace_flag);
 
+			if (get_valid_double_write_mode(hevc) != 16) {
+				struct vdec_comp_buf_info info;
+
+				get_comp_buf_info(hevc, &info);
+				vdec_v4l_set_comp_buf_info(ctx, &info);
+			}
+
 			vh265_get_ps_info(hevc, width, height, &ps);
 			vdec_v4l_set_ps_infos(ctx, &ps);
 			vdec_v4l_res_ch_event(ctx);
@@ -10726,22 +10770,8 @@ pic_done:
 							if ((!is_skip_decoding(hevc, pic)) &&
 								(hevc->used_4k_num >= 0) &&
 								(hevc->cur_pic->scatter_alloc
-								== 1)) {
-								hevc_print(hevc,
-								H265_DEBUG_BUFMGR_MORE,
-								"%s pic index %d scatter_alloc %d page_start %ld\n",
-								"decoder_mmu_box_free_idx_tail",
-								hevc->cur_pic->index,
-								hevc->cur_pic->scatter_alloc,
-								hevc->used_4k_num);
-								decoder_mmu_box_free_idx_tail(
-								hevc->mmu_box,
-								hevc->cur_pic->index,
-								hevc->used_4k_num);
-								hevc->cur_pic->scatter_alloc
-									= 2;
-							}
-							hevc->used_4k_num = -1;
+								== 1))
+								recycle_mmu_buf_tail(hevc, false);
 						}
 					}
 
@@ -11200,8 +11230,21 @@ force_output:
 						struct aml_vdec_ps_infos ps;
 						int width = hevc->param.p.pic_width_in_luma_samples;
 						int height = hevc->param.p.pic_height_in_luma_samples;
+						int log = hevc->param.p.log2_min_coding_block_size_minus3;
+						int log_s = hevc->param.p.log2_diff_max_min_coding_block_size;
+
+						hevc->pic_w = width;
+						hevc->pic_h = height;
+						hevc->lcu_size = 1 << (log + 3 + log_s);
 
 						pr_debug("set ucode parse\n");
+						if (get_valid_double_write_mode(hevc) != 16) {
+							struct vdec_comp_buf_info info;
+
+							get_comp_buf_info(hevc, &info);
+							vdec_v4l_set_comp_buf_info(ctx, &info);
+						}
+
 						vh265_get_ps_info(hevc, width, height, &ps);
 						/*notice the v4l2 codec.*/
 						vdec_v4l_set_ps_infos(ctx, &ps);
@@ -11221,7 +11264,6 @@ force_output:
 					reset_process_time(hevc);
 					vdec_schedule_work(&hevc->work);
 					return IRQ_HANDLED;
-
 				}
 			}
 
@@ -12721,6 +12763,28 @@ static int get_used_buf_count(struct hevc_state_s *hevc)
 }
 #endif
 
+static bool is_avaliable_buffer(struct hevc_state_s *hevc)
+{
+	struct PIC_s *pic;
+	int i, free_count = 0;
+
+	for (i = 0; i < MAX_REF_PIC_NUM; i++) {
+		pic = hevc->m_PIC[i];
+		if (pic == NULL ||
+			pic->index == -1 ||
+			pic->BUF_index == -1)
+			continue;
+
+		if (pic->output_mark == 0 &&
+			pic->referenced == 0 &&
+			pic->output_ready == 0 &&
+			pic->cma_alloc_addr) {
+			free_count++;
+		}
+	}
+
+	return free_count < run_ready_min_buf_num ? 0 : 1;
+}
 
 static unsigned char is_new_pic_available(struct hevc_state_s *hevc)
 {
@@ -12939,6 +13003,14 @@ static unsigned char get_data_check_sum
 	for (jj = 0; jj < size; jj++)
 		sum += data[jj];
 
+	hevc_print(hevc, PRINT_FLAG_VDEC_STATUS,
+		"%s: size 0x%x sum 0x%x %02x %02x %02x %02x %02x %02x .. %02x %02x %02x %02x\n",
+		__func__, size, sum,
+		data[0], data[1], data[2], data[3],
+		data[4], data[5], data[size - 4],
+		data[size - 3], data[size - 2],
+		data[size - 1]);
+
 	if (!hevc->chunk->block->is_mapped)
 		codec_mm_unmap_phyaddr(data);
 	return sum;
@@ -13168,21 +13240,8 @@ static void vh265_work_implement(struct hevc_state_s *hevc,
 			if (hevc->used_4k_num >= 0 &&
 				hevc->cur_pic &&
 				hevc->cur_pic->scatter_alloc
-				== 1) {
-				hevc_print(hevc, H265_DEBUG_BUFMGR_MORE,
-				"%s pic index %d scatter_alloc %d page_start %ld\n",
-				"decoder_mmu_box_free_idx_tail",
-				hevc->cur_pic->index,
-				hevc->cur_pic->scatter_alloc,
-				hevc->used_4k_num);
-				if (hevc->m_ins_flag)
-					hevc_mmu_dma_check(hw_to_vdec(hevc));
-				decoder_mmu_box_free_idx_tail(
-				hevc->mmu_box,
-				hevc->cur_pic->index,
-				hevc->used_4k_num);
-				hevc->cur_pic->scatter_alloc = 2;
-			}
+				== 1)
+				recycle_mmu_buf_tail(hevc, hevc->m_ins_flag);
 		}
 		hevc->pic_decoded_lcu_idx =
 			READ_VREG(HEVC_PARSER_LCU_START)
@@ -13542,7 +13601,17 @@ static unsigned long run_ready(struct vdec_s *vdec, unsigned long mask)
 	}
 	hevc->timeout_processing = 0;
 	if (!hevc->first_sc_checked && hevc->mmu_enable) {
-		int size = decoder_mmu_box_sc_check(hevc->mmu_box, tvp);
+		int size;
+		void * mmu_box;
+
+		if (hevc->is_used_v4l) {
+			struct aml_vcodec_ctx *ctx =
+				(struct aml_vcodec_ctx *)(hevc->v4l2_ctx);
+			mmu_box = ctx->mmu_box;
+		} else
+			mmu_box = hevc->mmu_box;
+
+		size = decoder_mmu_box_sc_check(mmu_box, tvp);
 		hevc->first_sc_checked =1;
 		hevc_print(hevc, 0,
 			"vh265 cached=%d  need_size=%d speed= %d ms\n",
@@ -13630,10 +13699,14 @@ static unsigned long run_ready(struct vdec_s *vdec, unsigned long mask)
 
 		if (ctx->param_sets_from_ucode) {
 			if (hevc->v4l_params_parsed) {
-				if (!ctx->v4l_codec_dpb_ready &&
-				v4l2_m2m_num_dst_bufs_ready(ctx->m2m_ctx) <
-				run_ready_min_buf_num)
-					ret = 0;
+				if (ctx->cap_pool.in < get_work_pic_num(hevc)) {
+					if (is_avaliable_buffer(hevc) ||
+						(v4l2_m2m_num_dst_bufs_ready(ctx->m2m_ctx) >=
+						run_ready_min_buf_num)) {
+						ret = 1;
+					} else
+						ret = 0;
+				}
 			} else {
 				if (ctx->v4l_resolution_change)
 					ret = 0;
@@ -14182,9 +14255,10 @@ static void vh265_dump_state(struct vdec_s *vdec)
 
 	for (i = 0; i < BUF_POOL_SIZE; i++) {
 		hevc_print(hevc, 0,
-			"Buf(%d) start_adr 0x%lx size 0x%x used %d\n",
+			"Buf(%d) start_adr 0x%x header_addr 0x%x size 0x%x used %d\n",
 			i,
 			hevc->m_BUF[i].start_adr,
+			hevc->m_BUF[i].header_addr,
 			hevc->m_BUF[i].size,
 			hevc->m_BUF[i].used_flag);
 	}
diff --git a/drivers/frame_provider/decoder/mjpeg/vmjpeg_multi.c b/drivers/frame_provider/decoder/mjpeg/vmjpeg_multi.c
index 1add1537..467f7fdb 100644
--- a/drivers/frame_provider/decoder/mjpeg/vmjpeg_multi.c
+++ b/drivers/frame_provider/decoder/mjpeg/vmjpeg_multi.c
@@ -1008,7 +1008,7 @@ static int vmjpeg_v4l_alloc_buff_config_canvas(struct vdec_mjpeg_hw_s *hw, int i
 		decbuf_start	= fb->m.mem[0].addr;
 		decbuf_y_size	= fb->m.mem[0].size;
 		decbuf_u_start	= fb->m.mem[1].addr;
-		decbuf_u_size	= fb->m.mem[1].size;
+		decbuf_u_size	= fb->m.mem[1].size >> 1;
 		decbuf_v_start	= decbuf_u_start + decbuf_u_size;
 		decbuf_v_size	= decbuf_u_size;
 		canvas_width	= ALIGN(hw->frame_width, 64);
diff --git a/drivers/frame_provider/decoder/mpeg12/vmpeg12_multi.c b/drivers/frame_provider/decoder/mpeg12/vmpeg12_multi.c
index 0d4f007e..bde1b656 100644
--- a/drivers/frame_provider/decoder/mpeg12/vmpeg12_multi.c
+++ b/drivers/frame_provider/decoder/mpeg12/vmpeg12_multi.c
@@ -229,6 +229,7 @@ struct pic_info_t {
 	ulong v4l_ref_buf_addr;
 	u32 hw_decode_time;
 	u32 frame_size; // For frame base mode
+	u64 timestamp;
 };
 
 struct vdec_mpeg12_hw_s {
@@ -532,6 +533,10 @@ static int vmpeg12_v4l_alloc_buff_config_canvas(struct vdec_mpeg12_hw_s *hw, int
 		(hw->canvas_mode == CANVAS_BLKMODE_LINEAR) ? 7 : 0;
 	canvas_config_config(canvas_y(canvas), &hw->canvas_config[i][0]);
 
+	/* mpeg2 decoder canvas need to be revert to match display canvas */
+	hw->canvas_config[i][0].endian          =
+		(hw->canvas_mode != CANVAS_BLKMODE_LINEAR) ? 7 : 0;
+
 	hw->canvas_config[i][1].phy_addr	= decbuf_uv_start;
 	hw->canvas_config[i][1].width		= canvas_width;
 	hw->canvas_config[i][1].height		= canvas_height / 2;
@@ -540,6 +545,10 @@ static int vmpeg12_v4l_alloc_buff_config_canvas(struct vdec_mpeg12_hw_s *hw, int
 		(hw->canvas_mode == CANVAS_BLKMODE_LINEAR) ? 7 : 0;
 	canvas_config_config(canvas_u(canvas), &hw->canvas_config[i][1]);
 
+	/* mpeg2 decoder canvas need to be revert to match display canvas */
+	hw->canvas_config[i][1].endian          =
+		(hw->canvas_mode != CANVAS_BLKMODE_LINEAR) ? 7 : 0;
+
 	debug_print(DECODE_ID(hw), PRINT_FLAG_BUFFER_DETAIL,
 		"[%d] %s(), canvas: 0x%x mode: %d y: %lx uv: %lx w: %d h: %d\n",
 		ctx->id, __func__, canvas, hw->canvas_mode,
@@ -1657,9 +1666,6 @@ static int prepare_display_buf(struct vdec_mpeg12_hw_s *hw,
 	ulong nv_order = VIDTYPE_VIU_NV21;
 	bool pb_skip = false;
 
-#ifdef NV21
-	type = nv_order;
-#endif
 	/* swap uv */
 	if (hw->is_used_v4l) {
 		if ((v4l2_ctx->cap_pix_fmt == V4L2_PIX_FMT_NV12) ||
@@ -1667,6 +1673,9 @@ static int prepare_display_buf(struct vdec_mpeg12_hw_s *hw,
 			nv_order = VIDTYPE_VIU_NV12;
 	}
 
+#ifdef NV21
+	type = nv_order;
+#endif
 	if (hw->i_only) {
 		pb_skip = 1;
 	}
@@ -1744,9 +1753,11 @@ static int prepare_display_buf(struct vdec_mpeg12_hw_s *hw,
 		if (i > 0) {
 			vf->pts = 0;
 			vf->pts_us64 = 0;
+			vf->timestamp = 0;
 		} else {
 			vf->pts = (pic->pts_valid) ? pic->pts : 0;
 			vf->pts_us64 = (pic->pts_valid) ? pic->pts64 : 0;
+			vf->timestamp = pic->timestamp;
 		}
 		vf->type_original = vf->type;
 
@@ -2175,6 +2186,7 @@ static irqreturn_t vmpeg12_isr_thread_fn(struct vdec_s *vdec, int irq)
 				new_pic->pts_valid = hw->chunk->pts_valid;
 				new_pic->pts = hw->chunk->pts;
 				new_pic->pts64 = hw->chunk->pts64;
+				new_pic->timestamp = hw->chunk->timestamp;
 				if (hw->last_chunk_pts == hw->chunk->pts) {
 					new_pic->pts_valid = 0;
 					debug_print(DECODE_ID(hw), PRINT_FLAG_TIMEINFO,
@@ -2192,8 +2204,10 @@ static irqreturn_t vmpeg12_isr_thread_fn(struct vdec_s *vdec, int irq)
 				}
 			}
 		} else {
-			if (hw->chunk)
+			if (hw->chunk) {
 				hw->last_chunk_pts = hw->chunk->pts;
+				new_pic->timestamp = hw->chunk->timestamp;
+			}
 			new_pic->pts_valid = false;
 		}
 
@@ -2252,9 +2266,10 @@ static irqreturn_t vmpeg12_isr_thread_fn(struct vdec_s *vdec, int irq)
 		}
 
 		debug_print(DECODE_ID(hw), PRINT_FLAG_RUN_FLOW,
-			"mmpeg12: disp_pic=%d(%c), ind=%d, offst=%x, pts=(%d,%lld)(%d)\n",
+			"mmpeg12: disp_pic=%d(%c), ind=%d, offst=%x, pts=(%d,%lld,%llx)(%d)\n",
 			hw->disp_num, GET_SLICE_TYPE(info), index, disp_pic->offset,
-			disp_pic->pts, disp_pic->pts64, disp_pic->pts_valid);
+			disp_pic->pts, disp_pic->pts64,
+			disp_pic->timestamp, disp_pic->pts_valid);
 
 		prepare_display_buf(hw, disp_pic);
 		vdec_schedule_work(&hw->work);
diff --git a/drivers/frame_provider/decoder/utils/vdec.c b/drivers/frame_provider/decoder/utils/vdec.c
index 254959ab..049c05bf 100644
--- a/drivers/frame_provider/decoder/utils/vdec.c
+++ b/drivers/frame_provider/decoder/utils/vdec.c
@@ -5935,6 +5935,19 @@ void vdec_config_vld_reg(struct vdec_s *vdec, u32 addr, u32 size)
 }
 EXPORT_SYMBOL(vdec_config_vld_reg);
 
+int get_double_write_ratio(int dw_mode)
+{
+	int ratio = 1;
+
+	if ((dw_mode == 2) ||
+			(dw_mode == 3))
+		ratio = 4;
+	else if (dw_mode == 4)
+		ratio = 2;
+	return ratio;
+}
+EXPORT_SYMBOL(get_double_write_ratio);
+
 RESERVEDMEM_OF_DECLARE(vdec, "amlogic, vdec-memory", vdec_mem_setup);
 /*
 uint force_hevc_clock_cntl;
diff --git a/drivers/frame_provider/decoder/utils/vdec.h b/drivers/frame_provider/decoder/utils/vdec.h
index 188500df..c81b62d9 100644
--- a/drivers/frame_provider/decoder/utils/vdec.h
+++ b/drivers/frame_provider/decoder/utils/vdec.h
@@ -514,6 +514,8 @@ int vdec_get_frame_num(struct vdec_s *vdec);
 int show_stream_buffer_status(char *buf,
 	int (*callback) (struct stream_buf_s *, char *));
 
+extern int get_double_write_ratio(int dw_mode);
+
 bool is_support_no_parser(void);
 
 extern u32 timestamp_avsync_counter_get(void);
diff --git a/drivers/frame_provider/decoder/utils/vdec_v4l2_buffer_ops.c b/drivers/frame_provider/decoder/utils/vdec_v4l2_buffer_ops.c
index e892127c..6575097a 100644
--- a/drivers/frame_provider/decoder/utils/vdec_v4l2_buffer_ops.c
+++ b/drivers/frame_provider/decoder/utils/vdec_v4l2_buffer_ops.c
@@ -66,6 +66,22 @@ int vdec_v4l_set_ps_infos(struct aml_vcodec_ctx *ctx,
 }
 EXPORT_SYMBOL(vdec_v4l_set_ps_infos);
 
+int vdec_v4l_set_comp_buf_info(struct aml_vcodec_ctx *ctx,
+		struct vdec_comp_buf_info *info)
+{
+	int ret = 0;
+
+	if (ctx->drv_handle == 0)
+		return -EIO;
+
+	ret = ctx->dec_if->set_param(ctx->drv_handle,
+		SET_PARAM_COMP_BUF_INFO, info);
+
+	return ret;
+
+}
+EXPORT_SYMBOL(vdec_v4l_set_comp_buf_info);
+
 int vdec_v4l_set_hdr_infos(struct aml_vcodec_ctx *ctx,
 	struct aml_vdec_hdr_infos *hdr)
 {
@@ -81,7 +97,7 @@ int vdec_v4l_set_hdr_infos(struct aml_vcodec_ctx *ctx,
 }
 EXPORT_SYMBOL(vdec_v4l_set_hdr_infos);
 
-static void aml_wait_dpb_ready(struct aml_vcodec_ctx *ctx)
+static void aml_wait_buf_ready(struct aml_vcodec_ctx *ctx)
 {
 	ulong expires;
 
@@ -95,7 +111,7 @@ static void aml_wait_dpb_ready(struct aml_vcodec_ctx *ctx)
 		}
 
 		ready_num = v4l2_m2m_num_dst_bufs_ready(ctx->m2m_ctx);
-		if ((ready_num + ctx->buf_used_count) >= ctx->dpb_size)
+		if ((ready_num + ctx->buf_used_count) >= CTX_BUF_TOTAL(ctx))
 			ctx->v4l_codec_dpb_ready = true;
 	}
 }
@@ -151,7 +167,7 @@ int vdec_v4l_res_ch_event(struct aml_vcodec_ctx *ctx)
 		return -EIO;
 
 	/* wait the DPB state to be ready. */
-	aml_wait_dpb_ready(ctx);
+	aml_wait_buf_ready(ctx);
 
 	aml_vdec_pic_info_update(ctx);
 
@@ -185,3 +201,17 @@ int vdec_v4l_write_frame_sync(struct aml_vcodec_ctx *ctx)
 }
 EXPORT_SYMBOL(vdec_v4l_write_frame_sync);
 
+int vdec_v4l_get_dw_mode(struct aml_vcodec_ctx *ctx,
+	unsigned int *dw_mode)
+{
+	int ret = -1;
+
+	if (ctx->drv_handle == 0)
+		return -EIO;
+
+	ret = ctx->dec_if->get_param(ctx->drv_handle,
+		GET_PARAM_DW_MODE, dw_mode);
+
+	return ret;
+}
+EXPORT_SYMBOL(vdec_v4l_get_dw_mode);
diff --git a/drivers/frame_provider/decoder/utils/vdec_v4l2_buffer_ops.h b/drivers/frame_provider/decoder/utils/vdec_v4l2_buffer_ops.h
index 1494f106..ddb46cb9 100644
--- a/drivers/frame_provider/decoder/utils/vdec_v4l2_buffer_ops.h
+++ b/drivers/frame_provider/decoder/utils/vdec_v4l2_buffer_ops.h
@@ -35,6 +35,10 @@ int vdec_v4l_set_ps_infos(
 	struct aml_vcodec_ctx *ctx,
 	struct aml_vdec_ps_infos *ps);
 
+int vdec_v4l_set_comp_buf_info(
+	struct aml_vcodec_ctx *ctx,
+	struct vdec_comp_buf_info *info);
+
 int vdec_v4l_set_hdr_infos(
 	struct aml_vcodec_ctx *ctx,
 	struct aml_vdec_hdr_infos *hdr);
@@ -49,4 +53,7 @@ int vdec_v4l_post_evet(
 int vdec_v4l_res_ch_event(
 	struct aml_vcodec_ctx *ctx);
 
+int vdec_v4l_get_dw_mode(
+	struct aml_vcodec_ctx *ctx,
+	unsigned int *dw_mode);
 #endif
diff --git a/drivers/frame_provider/decoder/vav1/vav1.c b/drivers/frame_provider/decoder/vav1/vav1.c
index d3c7e75f..3025a061 100644
--- a/drivers/frame_provider/decoder/vav1/vav1.c
+++ b/drivers/frame_provider/decoder/vav1/vav1.c
@@ -297,7 +297,7 @@ static u32 double_write_mode;
 
 #define DUR2PTS(x) ((x)*90/96)
 #define PTS2DUR(x) ((x)*96/90)
-
+#define PTS2DUR_u64(x) (div_u64((x)*96, 90))
 
 struct AV1HW_s;
 static int vav1_vf_states(struct vframe_states *states, void *);
@@ -965,40 +965,6 @@ static u32 get_valid_double_write_mode(struct AV1HW_s *hw)
 	return dw;
 }
 
-static int v4l_parser_get_double_write_mode(struct AV1HW_s *hw)
-{
-	u32 valid_dw_mode = get_valid_double_write_mode(hw);
-	u32 dw;
-	int w, h;
-
-	/* mask for supporting double write value bigger than 0x100 */
-	if (valid_dw_mode & 0xffffff00) {
-		w = hw->frame_width;
-		h = hw->frame_height;
-
-		dw = 0x1; /*1:1*/
-		switch (valid_dw_mode) {
-		case 0x100:
-			if (w > 1920 && h > 1088)
-				dw = 0x4; /*1:2*/
-			break;
-		case 0x200:
-			if (w > 1920 && h > 1088)
-				dw = 0x2; /*1:4*/
-			break;
-		case 0x300:
-			if (w > 1280 && h > 720)
-				dw = 0x4; /*1:2*/
-			break;
-		default:
-			break;
-		}
-		return dw;
-	}
-
-	return valid_dw_mode;
-}
-
 static int get_double_write_mode(struct AV1HW_s *hw)
 {
 	u32 valid_dw_mode = get_valid_double_write_mode(hw);
@@ -1009,6 +975,15 @@ static int get_double_write_mode(struct AV1HW_s *hw)
 
 	if (!cm->cur_frame)
 		return 1;/*no valid frame,*/
+
+	if (hw->is_used_v4l) {
+		unsigned int out;
+
+		vdec_v4l_get_dw_mode(hw->v4l2_ctx, &out);
+		dw = out;
+		return dw;
+	}
+
 	cur_pic_config = &cm->cur_frame->buf;
 	w = cur_pic_config->y_crop_width;
 	h = cur_pic_config->y_crop_height;
@@ -1064,19 +1039,6 @@ static int get_double_write_mode_init(struct AV1HW_s *hw)
 }
 #endif
 
-static int get_double_write_ratio(struct AV1HW_s *hw,
-	int dw_mode)
-{
-	int ratio = 1;
-	int dw_mode_ratio = dw_mode & 0xf;
-	if ((dw_mode_ratio == 2) ||
-			(dw_mode_ratio == 3))
-		ratio = 4;
-	else if (dw_mode_ratio == 4)
-		ratio = 2;
-	return ratio;
-}
-
 /* return page number */
 static int av1_mmu_page_num(struct AV1HW_s *hw,
 		int w, int h, int save_mode)
@@ -1101,6 +1063,31 @@ static int av1_mmu_page_num(struct AV1HW_s *hw,
 	return cur_mmu_4k_number;
 }
 
+static struct internal_comp_buf* v4lfb_to_icomp_buf(
+		struct AV1HW_s *hw,
+		struct vdec_v4l2_buffer *fb)
+{
+	struct aml_video_dec_buf *aml_fb = NULL;
+	struct aml_vcodec_ctx * v4l2_ctx = hw->v4l2_ctx;
+
+	aml_fb = container_of(fb, struct aml_video_dec_buf, frame_buffer);
+
+	return &v4l2_ctx->comp_bufs[aml_fb->internal_index];
+}
+
+static struct internal_comp_buf* index_to_icomp_buf(
+		struct AV1HW_s *hw, int index)
+{
+	struct aml_video_dec_buf *aml_fb = NULL;
+	struct aml_vcodec_ctx * v4l2_ctx = hw->v4l2_ctx;
+	struct vdec_v4l2_buffer *fb = NULL;
+
+	fb = (struct vdec_v4l2_buffer *)
+		hw->m_BUF[index].v4l_ref_buf_addr;
+	aml_fb = container_of(fb, struct aml_video_dec_buf, frame_buffer);
+	return &v4l2_ctx->comp_bufs[aml_fb->internal_index];
+}
+
 //#define	MAX_4K_NUM		0x1200
 int av1_alloc_mmu(
 	struct AV1HW_s *hw,
@@ -1114,11 +1101,6 @@ int av1_alloc_mmu(
 	int bit_depth_10 = (bit_depth == AOM_BITS_10);
 	int cur_mmu_4k_number;
 
-	if (!hw->mmu_box) {
-		pr_err("error no mmu box!\n");
-		return -1;
-	}
-
 	if (hw->double_write_mode & 0x10)
 		return 0;
 
@@ -1135,11 +1117,22 @@ int av1_alloc_mmu(
 	if (cur_mmu_4k_number < 0)
 		return -1;
 
-	ret = decoder_mmu_box_alloc_idx(
-		hw->mmu_box,
-		hw->buffer_wrap[cur_buf_idx],
-		cur_mmu_4k_number,
-		mmu_index_adr);
+	if (hw->is_used_v4l) {
+		struct internal_comp_buf *ibuf =
+			index_to_icomp_buf(hw, cur_buf_idx);
+
+		ret = decoder_mmu_box_alloc_idx(
+				ibuf->mmu_box,
+				ibuf->index,
+				ibuf->frame_buffer_size,
+				mmu_index_adr);
+	} else {
+		ret = decoder_mmu_box_alloc_idx(
+			hw->mmu_box,
+			hw->buffer_wrap[cur_buf_idx],
+			cur_mmu_4k_number,
+			mmu_index_adr);
+	}
 
 	return ret;
 }
@@ -2523,64 +2516,13 @@ static void init_buff_spec(struct AV1HW_s *hw,
 	}
 }
 
-static bool v4l_is_there_vframe_bound(struct AV1HW_s *hw)
-{
-	int i;
-	struct AV1_Common_s *const cm = &hw->common;
-	struct RefCntBuffer_s *frame_bufs = cm->buffer_pool->frame_bufs;
-
-	for (i = 0; i < hw->used_buf_num; ++i) {
-		if (frame_bufs[i].buf.vframe_bound)
-			return true;
-	}
-
-	return false;
-}
-
-static void v4l_mmu_buffer_release(struct AV1HW_s *hw)
-{
-	struct AV1_Common_s *const cm = &hw->common;
-	struct RefCntBuffer_s *frame_bufs = cm->buffer_pool->frame_bufs;
-	int i;
-
-	/* release workspace */
-	if (hw->bmmu_box)
-		decoder_bmmu_box_free_idx(hw->bmmu_box,
-			WORK_SPACE_BUF_ID);
-	/*
-	 * it's only when vframe get back to driver, right now we can be sure
-	 * that vframe and fd are related. if the playback exits, the capture
-	 * requires the upper app to release when the fd is closed, and others
-	 * buffers drivers are released by driver.
-	 */
-	for (i = 0; i < hw->used_buf_num; ++i) {
-		if (!frame_bufs[i].buf.vframe_bound) {
-			if (hw->bmmu_box)
-				decoder_bmmu_box_free_idx(hw->bmmu_box,
-					HEADER_BUFFER_IDX(hw->buffer_wrap[i]));
-			if (hw->mmu_box)
-				decoder_mmu_box_free_idx(hw->mmu_box, hw->buffer_wrap[i]);
 
-			av1_print(hw, PRINT_FLAG_V4L_DETAIL,
-				"%s free buffer[%d], bmmu_box: %p, mmu_box: %p\n",
-				__func__, i, hw->bmmu_box, hw->mmu_box);
-		}
-	}
-}
 
 static void uninit_mmu_buffers(struct AV1HW_s *hw)
 {
 #ifndef MV_USE_FIXED_BUF
 	dealloc_mv_bufs(hw);
 #endif
-	if (hw->is_used_v4l &&
-		v4l_is_there_vframe_bound(hw)) {
-		if (get_double_write_mode(hw) != 0x10) {
-			v4l_mmu_buffer_release(hw);
-			return;
-		}
-	}
-
 	if (hw->mmu_box)
 		decoder_mmu_box_free(hw->mmu_box);
 	hw->mmu_box = NULL;
@@ -2607,6 +2549,31 @@ static int calc_luc_quantity(int lcu_size, u32 w, u32 h)
 	return pic_width_lcu * pic_height_lcu;
 }
 
+/* return in MB */
+static int av1_max_mmu_buf_size(int max_w, int max_h)
+{
+	int buf_size = 48;
+
+	if ((max_w * max_h > 1280*736) &&
+		(max_w * max_h <= 1920*1088)) {
+		buf_size = 12;
+	} else if ((max_w * max_h > 0) &&
+		(max_w * max_h <= 1280*736)) {
+		buf_size = 4;
+	}
+
+	return buf_size;
+}
+
+static int av1_get_header_size(int w, int h)
+{
+	if ((get_cpu_major_id() >= AM_MESON_CPU_MAJOR_ID_SM1) &&
+		IS_8K_SIZE(w, h))
+		return MMU_COMPRESS_8K_HEADER_SIZE;
+
+	return MMU_COMPRESS_HEADER_SIZE;
+}
+
 static int v4l_alloc_and_config_pic(struct AV1HW_s *hw,
 	struct PIC_BUFFER_CONFIG_s *pic)
 {
@@ -2638,8 +2605,9 @@ static int v4l_alloc_and_config_pic(struct AV1HW_s *hw,
 	}
 
 	if (hw->mmu_enable) {
-		hw->m_BUF[i].header_addr = decoder_bmmu_box_get_phy_addr(
-			hw->bmmu_box, HEADER_BUFFER_IDX(hw->buffer_wrap[i]));
+		struct internal_comp_buf *ibuf = v4lfb_to_icomp_buf(hw, fb);
+
+		hw->m_BUF[i].header_addr = ibuf->header_addr;
 		if (debug & AV1_DEBUG_BUFMGR_MORE) {
 			pr_info("MMU header_adr %d: %ld\n",
 				i, hw->m_BUF[i].header_addr);
@@ -2771,9 +2739,9 @@ static int config_pic(struct AV1HW_s *hw,
 
 	if (dw_mode && (dw_mode & 0x20) == 0) {
 		int pic_width_dw = pic_width /
-			get_double_write_ratio(hw, dw_mode);
+			get_double_write_ratio(dw_mode & 0xf);
 		int pic_height_dw = pic_height /
-			get_double_write_ratio(hw, dw_mode);
+			get_double_write_ratio(dw_mode & 0xf);
 
 		int pic_width_64_dw = (pic_width_dw + 63) & (~0x3f);
 		int pic_height_32_dw = (pic_height_dw + 31) & (~0x1f);
@@ -3687,7 +3655,7 @@ static void config_sao_hw(struct AV1HW_s *hw, union param_u *params)
 	!!!!!!!!!!!!!!!!!!!!!!!!!TODO .... !!!!!!!!!!!
 	mem_map_mode, endian, get_double_write_mode
 	*/
-    AV1_COMMON *cm = &hw->common;
+	AV1_COMMON *cm = &hw->common;
     PIC_BUFFER_CONFIG* pic_config = &cm->cur_frame->buf;
     uint32_t data32;
     int32_t lcu_size =
@@ -5538,11 +5506,11 @@ static void set_canvas(struct AV1HW_s *hw,
 	/*CANVAS_BLKMODE_64X32*/
 	if	(pic_config->double_write_mode) {
 		canvas_w = pic_config->y_crop_width	/
-				get_double_write_ratio(hw,
-					pic_config->double_write_mode);
+				get_double_write_ratio(
+					pic_config->double_write_mode & 0xf);
 		canvas_h = pic_config->y_crop_height /
-				get_double_write_ratio(hw,
-					pic_config->double_write_mode);
+				get_double_write_ratio(
+					pic_config->double_write_mode & 0xf);
 
 		if (mem_map_mode == 0)
 			canvas_w = ALIGN(canvas_w, 32);
@@ -5747,10 +5715,6 @@ static void vav1_vf_put(struct vframe_s *vf, void *op_arg)
 			if (pool->frame_bufs[index].buf.vf_ref > 0)
 				pool->frame_bufs[index].buf.vf_ref--;
 		}
-
-		if (hw->is_used_v4l)
-			pool->frame_bufs[index].buf.vframe_bound = true;
-
 		if (hw->wait_buf)
 			WRITE_VREG(HEVC_ASSIST_MBOX0_IRQ_REG,
 						0x1);
@@ -6194,7 +6158,7 @@ static int prepare_display_buf(struct AV1HW_s *hw,
 			(pic_config->double_write_mode & 0x20) == 0) {
 			vf->type = VIDTYPE_PROGRESSIVE |
 				VIDTYPE_VIU_FIELD;
-			vf->type |= VIDTYPE_VIU_NV21;
+			vf->type |= nv_order;
 			if ((pic_config->double_write_mode == 3 ||
 				pic_config->double_write_mode == 5) &&
 				(!IS_8K_SIZE(pic_config->y_crop_width,
@@ -6255,11 +6219,11 @@ static int prepare_display_buf(struct AV1HW_s *hw,
 		   vf->width,vf->height, pic_config->width,
 			pic_config->height); */
 		vf->width = pic_config->y_crop_width /
-			get_double_write_ratio(hw,
-				pic_config->double_write_mode);
+			get_double_write_ratio(
+				pic_config->double_write_mode & 0xf);
 		vf->height = pic_config->y_crop_height /
-			get_double_write_ratio(hw,
-				pic_config->double_write_mode);
+			get_double_write_ratio(
+				pic_config->double_write_mode & 0xf);
 		if (force_w_h != 0) {
 			vf->width = (force_w_h >> 16) & 0xffff;
 			vf->height = force_w_h & 0xffff;
@@ -6268,11 +6232,11 @@ static int prepare_display_buf(struct AV1HW_s *hw,
 			((pic_config->double_write_mode & 0xf) == 2 ||
 			(pic_config->double_write_mode & 0xf) == 4)) {
 			vf->compWidth = pic_config->y_crop_width /
-				get_double_write_ratio(hw,
-					pic_config->double_write_mode);
+				get_double_write_ratio(
+					pic_config->double_write_mode & 0xf);
 			vf->compHeight = pic_config->y_crop_height /
-				get_double_write_ratio(hw,
-					pic_config->double_write_mode);
+				get_double_write_ratio(
+					pic_config->double_write_mode & 0xf);
 		} else {
 			vf->compWidth = pic_config->y_crop_width;
 			vf->compHeight = pic_config->y_crop_height;
@@ -6396,10 +6360,21 @@ static int recycle_mmu_buf_tail(struct AV1HW_s *hw,
 	if (check_dma)
 		hevc_mmu_dma_check(hw_to_vdec(hw));
 
-	decoder_mmu_box_free_idx_tail(
-			hw->mmu_box,
-			hw->buffer_wrap[cm->cur_fb_idx_mmu],
-			hw->used_4k_num);
+	if (hw->is_used_v4l) {
+		int index = cm->cur_fb_idx_mmu;
+		struct internal_comp_buf *ibuf =
+			index_to_icomp_buf(hw, index);
+
+		decoder_mmu_box_free_idx_tail(
+				ibuf->mmu_box,
+				ibuf->index,
+				hw->used_4k_num);
+	} else {
+		decoder_mmu_box_free_idx_tail(
+				hw->mmu_box,
+				hw->buffer_wrap[cm->cur_fb_idx_mmu],
+				hw->used_4k_num);
+	}
 
 	cm->cur_fb_idx_mmu = INVALID_IDX;
 	hw->used_4k_num = -1;
@@ -7824,14 +7799,29 @@ static int av1_postproc(struct AV1HW_s *hw)
 	return av1_bufmgr_postproc(hw->pbi, hw->frame_decoded);
 }
 
-static int vav1_get_ps_info(struct AV1HW_s *hw, struct aml_vdec_ps_infos *ps)
+static void vav1_get_comp_buf_info(struct AV1HW_s *hw,
+					struct vdec_comp_buf_info *info)
 {
-	int dw_mode = v4l_parser_get_double_write_mode(hw);
+	u16 bit_depth = hw->param.p.bit_depth;
 
-	ps->visible_width 	= hw->frame_width / get_double_write_ratio(hw, dw_mode);
-	ps->visible_height 	= hw->frame_height / get_double_write_ratio(hw, dw_mode);
-	ps->coded_width 	= ALIGN(hw->frame_width, 32) / get_double_write_ratio(hw, dw_mode);
-	ps->coded_height 	= ALIGN(hw->frame_height, 32) / get_double_write_ratio(hw, dw_mode);
+	info->max_size = av1_max_mmu_buf_size(
+			hw->max_pic_w,
+			hw->max_pic_h);
+	info->header_size = av1_get_header_size(
+			hw->frame_width,
+			hw->frame_height);
+	info->frame_buffer_size = av1_mmu_page_num(
+			hw, hw->frame_width,
+			hw->frame_height,
+			bit_depth == 0);
+}
+
+static int vav1_get_ps_info(struct AV1HW_s *hw, struct aml_vdec_ps_infos *ps)
+{
+	ps->visible_width 	= hw->frame_width;
+	ps->visible_height 	= hw->frame_height;
+	ps->coded_width 	= ALIGN(hw->frame_width, 32);
+	ps->coded_height 	= ALIGN(hw->frame_height, 32);
 	ps->dpb_size 		= hw->used_buf_num;
 
 	return 0;
@@ -7848,6 +7838,7 @@ static int v4l_res_change(struct AV1HW_s *hw)
 	if (ctx->param_sets_from_ucode &&
 		hw->res_ch_flag == 0) {
 		struct aml_vdec_ps_infos ps;
+		struct vdec_comp_buf_info comp;
 
 		if ((cm->width != 0 &&
 			cm->height != 0) &&
@@ -7858,6 +7849,11 @@ static int v4l_res_change(struct AV1HW_s *hw)
 				"%s (%d,%d)=>(%d,%d)\r\n", __func__, cm->width,
 				cm->height, hw->frame_width, hw->frame_height);
 
+			if (get_valid_double_write_mode(hw) != 16) {
+				vav1_get_comp_buf_info(hw, &comp);
+				vdec_v4l_set_comp_buf_info(ctx, &comp);
+			}
+
 			vav1_get_ps_info(hw, &ps);
 			vdec_v4l_set_ps_infos(ctx, &ps);
 			vdec_v4l_res_ch_event(ctx);
@@ -7964,8 +7960,19 @@ static irqreturn_t vav1_isr_thread_fn(int irq, void *data)
 
 					av1_print(hw, AOM_DEBUG_HW_MORE, "mmu free tail, index %d used_num 0x%lx\n",
 						cm->cur_frame->buf.index, used_4k_num);
-					decoder_mmu_box_free_idx_tail(hw->mmu_box,
-						hw->buffer_wrap[cm->cur_frame->buf.index], used_4k_num);
+					if (hw->is_used_v4l) {
+						int index = hw->buffer_wrap[cm->cur_fb_idx_mmu];
+						struct internal_comp_buf *ibuf =
+							index_to_icomp_buf(hw, index);
+
+						decoder_mmu_box_free_idx_tail(
+							ibuf->mmu_box,
+							ibuf->index,
+							used_4k_num);
+					} else {
+						decoder_mmu_box_free_idx_tail(hw->mmu_box,
+							hw->buffer_wrap[cm->cur_frame->buf.index], used_4k_num);
+					}
 #ifdef AOM_AV1_MMU_DW
 					if (hw->dw_mmu_enable) {
 						used_4k_num =
@@ -8221,8 +8228,14 @@ static irqreturn_t vav1_isr_thread_fn(int irq, void *data)
 		if (!v4l_res_change(hw)) {
 			if (ctx->param_sets_from_ucode && !hw->v4l_params_parsed) {
 				struct aml_vdec_ps_infos ps;
+				struct vdec_comp_buf_info comp;
 
 				pr_info("set ucode parse\n");
+				if (get_valid_double_write_mode(hw) != 16) {
+					vav1_get_comp_buf_info(hw, &comp);
+					vdec_v4l_set_comp_buf_info(ctx, &comp);
+				}
+
 				vav1_get_ps_info(hw, &ps);
 				/*notice the v4l2 codec.*/
 				vdec_v4l_set_ps_infos(ctx, &ps);
@@ -9033,7 +9046,7 @@ static int amvdec_av1_mmu_init(struct AV1HW_s *hw)
 	}
 	hw->need_cache_size = buf_size * SZ_1M;
 	hw->sc_start_time = get_jiffies_64();
-	if (hw->mmu_enable) {
+	if (hw->mmu_enable && !hw->is_used_v4l) {
 		int count = FRAME_BUFFERS;
 		hw->mmu_box = decoder_mmu_box_alloc_box(DRIVER_NAME,
 			hw->index /* * 2*/, count,
@@ -9554,8 +9567,17 @@ static unsigned long run_ready(struct vdec_s *vdec, unsigned long mask)
 		return ret;
 
 	if (!hw->first_sc_checked && hw->mmu_enable) {
-		int size = decoder_mmu_box_sc_check(hw->mmu_box, tvp);
+		int size;
+		void * mmu_box;
+
+		if (hw->is_used_v4l) {
+			struct aml_vcodec_ctx *ctx =
+				(struct aml_vcodec_ctx *)(hw->v4l2_ctx);
+			mmu_box = ctx->mmu_box;
+		} else
+			mmu_box = hw->mmu_box;
 
+		size = decoder_mmu_box_sc_check(mmu_box, tvp);
 		hw->first_sc_checked = 1;
 		av1_print(hw, 0, "av1 cached=%d  need_size=%d speed= %d ms\n",
 			size, (hw->need_cache_size >> PAGE_SHIFT),
@@ -9618,10 +9640,15 @@ static void av1_frame_mode_pts_save(struct AV1HW_s *hw)
 	/* no return when first pts is 0 */
 	if (hw->first_pts_index) {
 		/* filtration pts 0 and continuous same pts */
-		if ((hw->chunk->pts == 0) ||
-			(hw->frame_mode_pts_save[0] == hw->chunk->pts))
-		return;
-
+		if (hw->is_used_v4l) {
+			if ((hw->chunk->timestamp == 0) ||
+				(hw->frame_mode_timestamp_save[0] == hw->chunk->timestamp))
+				return;
+		} else {
+			if ((hw->chunk->pts == 0) ||
+				(hw->frame_mode_pts_save[0] == hw->chunk->pts))
+				return;
+		}
 		/* fps change, frame dur change to lower or higher,
 		 * can't find closed pts in saved pool */
 		if ((hw->dur_recalc_flag) ||
@@ -9692,7 +9719,7 @@ static void av1_frame_mode_pts_save(struct AV1HW_s *hw)
 		return;
 	}
 
-	calc_dur = PTS2DUR(pts_diff_sum / valid_pts_diff_cnt);
+	calc_dur = PTS2DUR_u64(div_u64(pts_diff_sum, valid_pts_diff_cnt));
 	if ((!close_to(calc_dur, hw->frame_dur, 10)) &&
 		(calc_dur < 9601) && (calc_dur > 800)) {
 		av1_print(hw, 0, "change to calc dur %lld, old dur %d\n", calc_dur, hw->frame_dur);
@@ -9705,7 +9732,7 @@ static void av1_frame_mode_pts_save(struct AV1HW_s *hw)
 
 	if (hw->is_used_v4l) {
 		hw->timestamp_duration =
-			pts_diff_sum / valid_pts_diff_cnt;
+			div_u64(pts_diff_sum, valid_pts_diff_cnt);
 	}
 }
 
diff --git a/drivers/frame_provider/decoder/vp9/vvp9.c b/drivers/frame_provider/decoder/vp9/vvp9.c
index d2f4478a..22be81ff 100644
--- a/drivers/frame_provider/decoder/vp9/vvp9.c
+++ b/drivers/frame_provider/decoder/vp9/vvp9.c
@@ -543,6 +543,8 @@ struct PIC_BUFFER_CONFIG_s {
 	 */
 	unsigned int dw_y_adr;
 	unsigned int dw_u_v_adr;
+	u32	luma_size;
+	u32	chroma_size;
 	int mc_canvas_y;
 	int mc_canvas_u_v;
 
@@ -597,7 +599,6 @@ struct PIC_BUFFER_CONFIG_s {
 
 	u32 hw_decode_time;
 	u32 frame_size2; // For frame base mode
-	bool vframe_bound;
 
 	/* vdec sync. */
 	struct fence *fence;
@@ -1634,49 +1635,22 @@ static u32 get_valid_double_write_mode(struct VP9Decoder_s *pbi)
 		(double_write_mode & 0x7fffffff);
 }
 
-static int v4l_parser_get_double_write_mode(struct VP9Decoder_s *pbi)
+static int get_double_write_mode(struct VP9Decoder_s *pbi)
 {
 	u32 valid_dw_mode = get_valid_double_write_mode(pbi);
 	u32 dw;
 	int w, h;
+	struct VP9_Common_s *cm = &pbi->common;
+	struct PIC_BUFFER_CONFIG_s *cur_pic_config;
 
-	/* mask for supporting double write value bigger than 0x100 */
-	if (valid_dw_mode & 0xffffff00) {
-		w = pbi->frame_width;
-		h = pbi->frame_height;
+	if (pbi->is_used_v4l) {
+		unsigned int out;
 
-		dw = 0x1; /*1:1*/
-		switch (valid_dw_mode) {
-		case 0x100:
-			if (w > 1920 && h > 1088)
-				dw = 0x4; /*1:2*/
-			break;
-		case 0x200:
-			if (w > 1920 && h > 1088)
-				dw = 0x2; /*1:4*/
-			break;
-		case 0x300:
-			if (w > 1280 && h > 720)
-				dw = 0x4; /*1:2*/
-			break;
-		default:
-			break;
-		}
+		vdec_v4l_get_dw_mode(pbi->v4l2_ctx, &out);
+		dw = out;
 		return dw;
 	}
 
-	return valid_dw_mode;
-}
-
-
-static int get_double_write_mode(struct VP9Decoder_s *pbi)
-{
-	u32 valid_dw_mode = get_valid_double_write_mode(pbi);
-	u32 dw;
-	int w, h;
-	struct VP9_Common_s *cm = &pbi->common;
-	struct PIC_BUFFER_CONFIG_s *cur_pic_config;
-
 	/* mask for supporting double write value bigger than 0x100 */
 	if (valid_dw_mode & 0xffffff00) {
 		if (!cm->cur_frame)
@@ -1738,19 +1712,55 @@ static int get_double_write_mode_init(struct VP9Decoder_s *pbi)
 }
 #endif
 
-static int get_double_write_ratio(struct VP9Decoder_s *pbi,
-	int dw_mode)
+//#define	MAX_4K_NUM		0x1200
+
+/* return page number */
+static int vp9_mmu_page_num(struct VP9Decoder_s *pbi,
+		int w, int h, int save_mode)
+{
+	int picture_size;
+	int cur_mmu_4k_number, max_frame_num;
+
+	picture_size = compute_losless_comp_body_size(w, h, save_mode);
+	cur_mmu_4k_number = ((picture_size + (PAGE_SIZE - 1)) >> PAGE_SHIFT);
+
+	if (get_cpu_major_id() >= AM_MESON_CPU_MAJOR_ID_SM1)
+		max_frame_num = MAX_FRAME_8K_NUM;
+	else
+		max_frame_num = MAX_FRAME_4K_NUM;
+
+	if (cur_mmu_4k_number > max_frame_num) {
+		pr_err("over max !! cur_mmu_4k_number 0x%x width %d height %d\n",
+			cur_mmu_4k_number, w, h);
+		return -1;
+	}
+
+	return cur_mmu_4k_number;
+}
+
+static struct internal_comp_buf* v4lfb_to_icomp_buf(
+		struct VP9Decoder_s *pbi,
+		struct vdec_v4l2_buffer *fb)
 {
-	int ratio = 1;
-	if ((dw_mode == 2) ||
-			(dw_mode == 3))
-		ratio = 4;
-	else if (dw_mode == 4)
-		ratio = 2;
-	return ratio;
+	struct aml_video_dec_buf *aml_fb = NULL;
+	struct aml_vcodec_ctx * v4l2_ctx = pbi->v4l2_ctx;
+
+	aml_fb = container_of(fb, struct aml_video_dec_buf, frame_buffer);
+	return &v4l2_ctx->comp_bufs[aml_fb->internal_index];
 }
 
-//#define	MAX_4K_NUM		0x1200
+static struct internal_comp_buf* index_to_icomp_buf(
+		struct VP9Decoder_s *pbi, int index)
+{
+	struct aml_video_dec_buf *aml_fb = NULL;
+	struct aml_vcodec_ctx * v4l2_ctx = pbi->v4l2_ctx;
+	struct vdec_v4l2_buffer *fb = NULL;
+
+	fb = (struct vdec_v4l2_buffer *)
+		pbi->m_BUF[index].v4l_ref_buf_addr;
+	aml_fb = container_of(fb, struct aml_video_dec_buf, frame_buffer);
+	return &v4l2_ctx->comp_bufs[aml_fb->internal_index];
+}
 
 int vp9_alloc_mmu(
 	struct VP9Decoder_s *pbi,
@@ -1760,43 +1770,46 @@ int vp9_alloc_mmu(
 	unsigned short bit_depth,
 	unsigned int *mmu_index_adr)
 {
+	int ret;
 	int bit_depth_10 = (bit_depth == VPX_BITS_10);
-	int picture_size;
-	int cur_mmu_4k_number, max_frame_num;
-	if (!pbi->mmu_box) {
-		pr_err("error no mmu box!\n");
-		return -1;
-	}
+	int cur_mmu_4k_number;
+
 	if (get_double_write_mode(pbi) == 0x10)
 		return 0;
+
 	if (bit_depth >= VPX_BITS_12) {
 		pbi->fatal_error = DECODER_FATAL_ERROR_SIZE_OVERFLOW;
 		pr_err("fatal_error, un support bit depth 12!\n\n");
 		return -1;
 	}
-	picture_size = compute_losless_comp_body_size(pic_width, pic_height,
-				   bit_depth_10);
-	cur_mmu_4k_number = ((picture_size + (1 << 12) - 1) >> 12);
-
-	if (get_cpu_major_id() >= AM_MESON_CPU_MAJOR_ID_SM1)
-		max_frame_num = MAX_FRAME_8K_NUM;
-	else
-		max_frame_num = MAX_FRAME_4K_NUM;
 
-	if (cur_mmu_4k_number > max_frame_num) {
-		pr_err("over max !! cur_mmu_4k_number 0x%x width %d height %d\n",
-			cur_mmu_4k_number, pic_width, pic_height);
+	cur_mmu_4k_number = vp9_mmu_page_num(pbi,
+				pic_width,
+				pic_height,
+				bit_depth_10);
+	if (cur_mmu_4k_number < 0)
 		return -1;
+
+	if (pbi->is_used_v4l) {
+		struct internal_comp_buf *ibuf =
+			index_to_icomp_buf(pbi, cur_buf_idx);
+
+		ret = decoder_mmu_box_alloc_idx(
+				ibuf->mmu_box,
+				ibuf->index,
+				ibuf->frame_buffer_size,
+				mmu_index_adr);
+	} else {
+		ret = decoder_mmu_box_alloc_idx(
+				pbi->mmu_box,
+				cur_buf_idx,
+				cur_mmu_4k_number,
+				mmu_index_adr);
 	}
 
-	return decoder_mmu_box_alloc_idx(
-		pbi->mmu_box,
-		cur_buf_idx,
-		cur_mmu_4k_number,
-		mmu_index_adr);
+	return ret;
 }
 
-
 #ifndef MV_USE_FIXED_BUF
 static void dealloc_mv_bufs(struct VP9Decoder_s *pbi)
 {
@@ -2264,8 +2277,9 @@ static int v4l_get_free_fb(struct VP9Decoder_s *pbi)
 	struct aml_vcodec_ctx * v4l = pbi->v4l2_ctx;
 	struct v4l_buff_pool *pool = &v4l->cap_pool;
 	struct PIC_BUFFER_CONFIG_s *pic = NULL;
-	int i, idx = INVALID_IDX;
+	struct PIC_BUFFER_CONFIG_s *free_pic = NULL;
 	ulong flags;
+	int i;
 
 	lock_buffer_pool(cm->buffer_pool, flags);
 
@@ -2280,7 +2294,7 @@ static int v4l_get_free_fb(struct VP9Decoder_s *pbi)
 				(pic->vf_ref == 0) &&
 				(pic->index != -1) &&
 				pic->cma_alloc_addr) {
-				idx = i;
+				free_pic = pic;
 			}
 			break;
 		case V4L_CAP_BUFF_IN_M2M:
@@ -2290,23 +2304,22 @@ static int v4l_get_free_fb(struct VP9Decoder_s *pbi)
 			if (!v4l_alloc_and_config_pic(pbi, pic)) {
 				set_canvas(pbi, pic);
 				init_pic_list_hw(pbi);
-				idx = index;
+				free_pic = pic;
 			}
 			break;
 		default:
-			pr_err("v4l buffer state err %d.\n", state);
 			break;
 		}
 
-		if (idx != INVALID_IDX) {
-			frame_bufs[idx].ref_count = 1;
+		if (free_pic) {
+			frame_bufs[i].ref_count = 1;
 			break;
 		}
 	}
 
 	unlock_buffer_pool(cm->buffer_pool, flags);
 
-	return idx;
+	return free_pic ? free_pic->index : INVALID_IDX;
 }
 
 static int get_free_buf_count(struct VP9Decoder_s *pbi)
@@ -4799,71 +4812,20 @@ void adapt_coef_probs(int pic_count, int prev_kf, int cur_kf, int pre_fc,
 
 }
 
-static bool v4l_is_there_vframe_bound(struct VP9Decoder_s *pbi)
-{
-	int i;
-	struct VP9_Common_s *const cm = &pbi->common;
-	struct RefCntBuffer_s *frame_bufs = cm->buffer_pool->frame_bufs;
-
-	for (i = 0; i < pbi->used_buf_num; ++i) {
-		if (frame_bufs[i].buf.vframe_bound)
-			return true;
-	}
-
-	return false;
-}
-
-static void v4l_mmu_buffer_release(struct VP9Decoder_s *pbi)
-{
-	struct VP9_Common_s *const cm = &pbi->common;
-	struct RefCntBuffer_s *frame_bufs = cm->buffer_pool->frame_bufs;
-	int i;
-
-	/* release workspace */
-	if (pbi->bmmu_box)
-		decoder_bmmu_box_free_idx(pbi->bmmu_box,
-			WORK_SPACE_BUF_ID);
-	/*
-	 * it's only when vframe get back to driver, right now we can be sure
-	 * that vframe and fd are related. if the playback exits, the capture
-	 * requires the upper app to release when the fd is closed, and others
-	 * buffers drivers are released by driver.
-	 */
-	for (i = 0; i < pbi->used_buf_num; ++i) {
-		if (!frame_bufs[i].buf.vframe_bound) {
-			if (pbi->bmmu_box)
-				decoder_bmmu_box_free_idx(pbi->bmmu_box,
-					HEADER_BUFFER_IDX(i));
-			if (pbi->mmu_box)
-				decoder_mmu_box_free_idx(pbi->mmu_box, i);
-
-			vp9_print(pbi, PRINT_FLAG_V4L_DETAIL,
-				"%s free buffer[%d], bmmu_box: %p, mmu_box: %p\n",
-				__func__, i, pbi->bmmu_box, pbi->mmu_box);
-		}
-	}
-}
-
 static void uninit_mmu_buffers(struct VP9Decoder_s *pbi)
 {
 #ifndef MV_USE_FIXED_BUF
 	dealloc_mv_bufs(pbi);
 #endif
-	if (pbi->is_used_v4l &&
-		v4l_is_there_vframe_bound(pbi)) {
-		if (get_double_write_mode(pbi) != 0x10) {
-			v4l_mmu_buffer_release(pbi);
-			return;
-		}
-	}
-
-	if (pbi->mmu_box)
+	if (pbi->mmu_box) {
 		decoder_mmu_box_free(pbi->mmu_box);
-	pbi->mmu_box = NULL;
+		pbi->mmu_box = NULL;
+	}
 
-	if (pbi->bmmu_box)
+	if (pbi->bmmu_box) {
 		decoder_bmmu_box_free(pbi->bmmu_box);
-	pbi->bmmu_box = NULL;
+		pbi->bmmu_box = NULL;
+	}
 }
 
 static int calc_luc_quantity(u32 w, u32 h)
@@ -4879,6 +4841,31 @@ static int calc_luc_quantity(u32 w, u32 h)
 	return pic_width_lcu * pic_height_lcu;
 }
 
+/* return in MB */
+static int vp9_max_mmu_buf_size(int max_w, int max_h)
+{
+	int buf_size = 48;
+
+	if ((max_w * max_h > 1280*736) &&
+		(max_w * max_h <= 1920*1088)) {
+		buf_size = 12;
+	} else if ((max_w * max_h > 0) &&
+		(max_w * max_h <= 1280*736)) {
+		buf_size = 4;
+	}
+
+	return buf_size;
+}
+
+static int vp9_get_header_size(int w, int h)
+{
+	if ((get_cpu_major_id() >= AM_MESON_CPU_MAJOR_ID_SM1) &&
+		IS_8K_SIZE(w, h))
+		return MMU_COMPRESS_8K_HEADER_SIZE;
+
+	return MMU_COMPRESS_HEADER_SIZE;
+}
+
 static int v4l_alloc_and_config_pic(struct VP9Decoder_s *pbi,
 	struct PIC_BUFFER_CONFIG_s *pic)
 {
@@ -4903,8 +4890,9 @@ static int v4l_alloc_and_config_pic(struct VP9Decoder_s *pbi,
 	}
 
 	if (pbi->mmu_enable) {
-		pbi->m_BUF[i].header_addr = decoder_bmmu_box_get_phy_addr(
-			pbi->bmmu_box, HEADER_BUFFER_IDX(i));
+		struct internal_comp_buf *ibuf = v4lfb_to_icomp_buf(pbi, fb);
+
+		pbi->m_BUF[i].header_addr = ibuf->header_addr;
 		if (debug & VP9_DEBUG_BUFMGR_MORE) {
 			pr_info("MMU header_adr %d: %ld\n",
 				i, pbi->m_BUF[i].header_addr);
@@ -4925,6 +4913,8 @@ static int v4l_alloc_and_config_pic(struct VP9Decoder_s *pbi,
 		fb->m.mem[0].bytes_used = fb->m.mem[0].size;
 		pic->dw_y_adr = pbi->m_BUF[i].start_adr;
 		pic->dw_u_v_adr = pic->dw_y_adr + pbi->m_BUF[i].luma_size;
+		pic->luma_size = fb->m.mem[0].offset;
+		pic->chroma_size = fb->m.mem[0].size - fb->m.mem[0].offset;
 	} else if (fb->num_planes == 2) {
 		pbi->m_BUF[i].start_adr = fb->m.mem[0].addr;
 		pbi->m_BUF[i].size = fb->m.mem[0].size;
@@ -4934,6 +4924,8 @@ static int v4l_alloc_and_config_pic(struct VP9Decoder_s *pbi,
 		fb->m.mem[1].bytes_used = fb->m.mem[1].size;
 		pic->dw_y_adr = pbi->m_BUF[i].start_adr;
 		pic->dw_u_v_adr = pbi->m_BUF[i].chroma_addr;
+		pic->luma_size = fb->m.mem[0].size;
+		pic->chroma_size = fb->m.mem[1].size;
 	}
 
 	/* config frame buffer */
@@ -5013,9 +5005,9 @@ static int config_pic(struct VP9Decoder_s *pbi,
 
 	if (dw_mode) {
 		int pic_width_dw = pic_width /
-			get_double_write_ratio(pbi, dw_mode);
+			get_double_write_ratio(dw_mode);
 		int pic_height_dw = pic_height /
-			get_double_write_ratio(pbi, dw_mode);
+			get_double_write_ratio(dw_mode);
 
 		int pic_width_64_dw = (pic_width_dw + 63) & (~0x3f);
 		int pic_height_32_dw = (pic_height_dw + 31) & (~0x1f);
@@ -5270,7 +5262,6 @@ static void init_pic_list_hw(struct VP9Decoder_s *pbi)
 		WRITE_VREG(HEVCD_MPP_ANC_CANVAS_DATA_ADDR, 0);
 }
 
-
 static void dump_pic_list(struct VP9Decoder_s *pbi)
 {
 	struct VP9_Common_s *const cm = &pbi->common;
@@ -5505,14 +5496,25 @@ static void config_sao_hw(struct VP9Decoder_s *pbi, union param_u *params)
 	if (pbi->mmu_enable)
 		WRITE_VREG(HEVC_CM_HEADER_START_ADDR, pic_config->header_adr);
 
-	data32 = (mc_buffer_size_u_v_h << 16) << 1;
-	/*pr_info("data32=%x,mc_buffer_size_u_v_h=%x,lcu_total=%x\n",
-	 *	data32, mc_buffer_size_u_v_h, pic_config->lcu_total);
-	 */
-	WRITE_VREG(HEVC_SAO_Y_LENGTH, data32);
+	if (pbi->is_used_v4l) {
+		WRITE_VREG(HEVC_SAO_Y_LENGTH, pic_config->luma_size);
+		WRITE_VREG(HEVC_SAO_C_LENGTH, pic_config->chroma_size);
+		if (debug & PRINT_FLAG_V4L_DETAIL) {
+			pr_info("[%d] config pic, id: %d, Y:(%x, %d) C:(%x, %d).\n",
+				v4l2_ctx->id, pic_config->index,
+				pic_config->dw_y_adr, pic_config->luma_size,
+				pic_config->dw_u_v_adr, pic_config->chroma_size);
+		}
+	} else {
+		data32 = (mc_buffer_size_u_v_h << 16) << 1;
+		/*pr_info("data32=%x,mc_buffer_size_u_v_h=%x,lcu_total=%x\n",
+			data32, mc_buffer_size_u_v_h, pic_config->lcu_total);*/
+
+		WRITE_VREG(HEVC_SAO_Y_LENGTH, data32);
 
-	data32 = (mc_buffer_size_u_v_h << 16);
-	WRITE_VREG(HEVC_SAO_C_LENGTH, data32);
+		data32 = (mc_buffer_size_u_v_h << 16);
+		WRITE_VREG(HEVC_SAO_C_LENGTH, data32);
+	}
 
 #ifdef VP9_10B_NV21
 #ifdef DOS_PROJECT
@@ -6811,10 +6813,10 @@ static void set_canvas(struct VP9Decoder_s *pbi,
 	/*CANVAS_BLKMODE_64X32*/
 	if	(pic_config->double_write_mode) {
 		canvas_w = pic_config->y_crop_width	/
-				get_double_write_ratio(pbi,
+				get_double_write_ratio(
 					pic_config->double_write_mode);
 		canvas_h = pic_config->y_crop_height /
-				get_double_write_ratio(pbi,
+				get_double_write_ratio(
 					pic_config->double_write_mode);
 
 		if (pbi->mem_map_mode == 0)
@@ -7036,9 +7038,6 @@ static void vvp9_vf_put(struct vframe_s *vf, void *op_arg)
 		if (pool->frame_bufs[index].buf.vf_ref > 0)
 			pool->frame_bufs[index].buf.vf_ref--;
 
-		if (pbi->is_used_v4l)
-			pool->frame_bufs[index].buf.vframe_bound = true;
-
 		if (pbi->wait_buf)
 			WRITE_VREG(HEVC_ASSIST_MBOX0_IRQ_REG,
 						0x1);
@@ -7167,11 +7166,15 @@ static int frame_duration_adapt(struct VP9Decoder_s *pbi, struct vframe_s *vf, u
 static void update_vf_memhandle(struct VP9Decoder_s *pbi,
 	struct vframe_s *vf, struct PIC_BUFFER_CONFIG_s *pic)
 {
-	if (pic->index < 0) {
-		vf->mem_handle = NULL;
-		vf->mem_head_handle = NULL;
-		vf->mem_dw_handle = NULL;
-	} else if (vf->type & VIDTYPE_SCATTER) {
+	vf->mem_handle = NULL;
+	vf->mem_head_handle = NULL;
+	vf->mem_dw_handle = NULL;
+
+	/* keeper not needed for v4l solution */
+	if (pbi->is_used_v4l)
+		return;
+
+	if (vf->type & VIDTYPE_SCATTER) {
 		vf->mem_handle =
 			decoder_mmu_box_get_mem_handle(
 				pbi->mmu_box, pic->index);
@@ -7431,6 +7434,8 @@ static int prepare_display_buf(struct VP9Decoder_s *pbi,
 				if (pbi->mmu_enable)
 					vf->type |= VIDTYPE_SCATTER;
 			}
+			if (pbi->is_used_v4l && pic_config->double_write_mode != 16)
+				vf->type |= VIDTYPE_COMPRESS | VIDTYPE_SCATTER;
 #ifdef MULTI_INSTANCE_SUPPORT
 			if (pbi->m_ins_flag) {
 				vf->canvas0Addr = vf->canvas1Addr = -1;
@@ -7483,10 +7488,10 @@ static int prepare_display_buf(struct VP9Decoder_s *pbi,
 		   vf->width,vf->height, pic_config->width,
 			pic_config->height); */
 		vf->width = pic_config->y_crop_width /
-			get_double_write_ratio(pbi,
+			get_double_write_ratio(
 				pic_config->double_write_mode);
 		vf->height = pic_config->y_crop_height /
-			get_double_write_ratio(pbi,
+			get_double_write_ratio(
 				pic_config->double_write_mode);
 		if (force_w_h != 0) {
 			vf->width = (force_w_h >> 16) & 0xffff;
@@ -7689,6 +7694,43 @@ static void debug_buffer_mgr_more(struct VP9Decoder_s *pbi)
 
 }
 
+static int recycle_mmu_buf_tail(struct VP9Decoder_s *pbi,
+		bool check_dma)
+{
+	struct VP9_Common_s *const cm = &pbi->common;
+
+	if (pbi->used_4k_num == -1) {
+		pbi->used_4k_num =
+			READ_VREG(HEVC_SAO_MMU_STATUS) >> 16;
+	}
+	vp9_print(pbi, VP9_DEBUG_BUFMGR_MORE,
+		"pic index %d page_start %d\n",
+		cm->cur_fb_idx_mmu, pbi->used_4k_num);
+
+	if (check_dma)
+		hevc_mmu_dma_check(hw_to_vdec(pbi));
+
+	if (pbi->is_used_v4l) {
+		int index = cm->cur_fb_idx_mmu;
+		struct internal_comp_buf *ibuf =
+			index_to_icomp_buf(pbi, index);
+
+		decoder_mmu_box_free_idx_tail(
+				ibuf->mmu_box,
+				ibuf->index,
+				pbi->used_4k_num);
+	} else {
+		decoder_mmu_box_free_idx_tail(
+				pbi->mmu_box,
+				cm->cur_fb_idx_mmu,
+				pbi->used_4k_num);
+	}
+
+	cm->cur_fb_idx_mmu = INVALID_IDX;
+	pbi->used_4k_num = -1;
+
+	return 0;
+}
 
 static void vp9_recycle_mmu_buf_tail(struct VP9Decoder_s *pbi)
 {
@@ -7696,16 +7738,9 @@ static void vp9_recycle_mmu_buf_tail(struct VP9Decoder_s *pbi)
 	if (pbi->double_write_mode & 0x10)
 		return;
 	if (cm->cur_fb_idx_mmu != INVALID_IDX) {
-		if (pbi->used_4k_num == -1) {
-			pbi->used_4k_num =
-			(READ_VREG(HEVC_SAO_MMU_STATUS) >> 16);
-			if (pbi->m_ins_flag)
-				hevc_mmu_dma_check(hw_to_vdec(pbi));
-		}
-		decoder_mmu_box_free_idx_tail(pbi->mmu_box,
-			cm->cur_fb_idx_mmu, pbi->used_4k_num);
-		cm->cur_fb_idx_mmu = INVALID_IDX;
-		pbi->used_4k_num = -1;
+		recycle_mmu_buf_tail(pbi,
+			((pbi->used_4k_num == -1) &&
+			pbi->m_ins_flag) ? 1 : 0);
 	}
 }
 
@@ -7713,6 +7748,10 @@ static void vp9_recycle_mmu_buf_tail(struct VP9Decoder_s *pbi)
 static void vp9_recycle_mmu_buf(struct VP9Decoder_s *pbi)
 {
 	struct VP9_Common_s *const cm = &pbi->common;
+
+	if (pbi->is_used_v4l)
+		return;
+
 	if (pbi->double_write_mode & 0x10)
 		return;
 	if (cm->cur_fb_idx_mmu != INVALID_IDX) {
@@ -7920,7 +7959,14 @@ int continue_decoding(struct VP9Decoder_s *pbi)
 			if ((frame_bufs[i].ref_count == 0) &&
 				(frame_bufs[i].buf.vf_ref == 0) &&
 				(frame_bufs[i].buf.index != -1)) {
-				decoder_mmu_box_free_idx(pbi->mmu_box, i);
+				if (pbi->is_used_v4l) {
+					struct internal_comp_buf *ibuf =
+						index_to_icomp_buf(pbi, i);
+
+					decoder_mmu_box_free_idx(ibuf->mmu_box, ibuf->index);
+				} else {
+					decoder_mmu_box_free_idx(pbi->mmu_box, i);
+				}
 			}
 			pbi->last_put_idx = -1;
 		}
@@ -8399,14 +8445,29 @@ static void get_picture_qos_info(struct VP9Decoder_s *pbi)
 	}
 }
 
-static int vvp9_get_ps_info(struct VP9Decoder_s *pbi, struct aml_vdec_ps_infos *ps)
+static void vvp9_get_comp_buf_info(struct VP9Decoder_s *pbi,
+					struct vdec_comp_buf_info *info)
 {
-	int dw_mode = v4l_parser_get_double_write_mode(pbi);
+	u16 bit_depth = pbi->param.p.bit_depth;
+
+	info->max_size = vp9_max_mmu_buf_size(
+			pbi->max_pic_w,
+			pbi->max_pic_h);
+	info->header_size = vp9_get_header_size(
+			pbi->frame_width,
+			pbi->frame_height);
+	info->frame_buffer_size = vp9_mmu_page_num(
+			pbi, pbi->frame_width,
+			pbi->frame_height,
+			bit_depth == 0);
+}
 
-	ps->visible_width 	= pbi->frame_width / get_double_write_ratio(pbi, dw_mode);
-	ps->visible_height 	= pbi->frame_height / get_double_write_ratio(pbi, dw_mode);
-	ps->coded_width 	= ALIGN(pbi->frame_width, 32) / get_double_write_ratio(pbi, dw_mode);
-	ps->coded_height 	= ALIGN(pbi->frame_height, 32) / get_double_write_ratio(pbi, dw_mode);
+static int vvp9_get_ps_info(struct VP9Decoder_s *pbi, struct aml_vdec_ps_infos *ps)
+{
+	ps->visible_width 	= pbi->frame_width;
+	ps->visible_height 	= pbi->frame_height;
+	ps->coded_width 	= ALIGN(pbi->frame_width, 32);
+	ps->coded_height 	= ALIGN(pbi->frame_height, 32);
 	ps->dpb_size 		= pbi->used_buf_num;
 
 	return 0;
@@ -8423,6 +8484,8 @@ static int v4l_res_change(struct VP9Decoder_s *pbi)
 	if (ctx->param_sets_from_ucode &&
 		pbi->res_ch_flag == 0) {
 		struct aml_vdec_ps_infos ps;
+		struct vdec_comp_buf_info comp;
+
 		if ((cm->width != 0 &&
 			cm->height != 0) &&
 			(pbi->frame_width != cm->width ||
@@ -8430,6 +8493,12 @@ static int v4l_res_change(struct VP9Decoder_s *pbi)
 
 			vp9_print(pbi, 0, "%s (%d,%d)=>(%d,%d)\r\n", __func__, cm->width,
 				cm->height, pbi->frame_width, pbi->frame_height);
+
+			if (get_valid_double_write_mode(pbi) != 16) {
+				vvp9_get_comp_buf_info(pbi, &comp);
+				vdec_v4l_set_comp_buf_info(ctx, &comp);
+			}
+
 			vvp9_get_ps_info(pbi, &ps);
 			vdec_v4l_set_ps_infos(ctx, &ps);
 			vdec_v4l_res_ch_event(ctx);
@@ -8688,8 +8757,14 @@ static irqreturn_t vvp9_isr_thread_fn(int irq, void *data)
 		if (!v4l_res_change(pbi)) {
 			if (ctx->param_sets_from_ucode && !pbi->v4l_params_parsed) {
 				struct aml_vdec_ps_infos ps;
+				struct vdec_comp_buf_info comp;
 
 				pr_debug("set ucode parse\n");
+				if (get_valid_double_write_mode(pbi) != 16) {
+					vvp9_get_comp_buf_info(pbi, &comp);
+					vdec_v4l_set_comp_buf_info(ctx, &comp);
+				}
+
 				vvp9_get_ps_info(pbi, &ps);
 				/*notice the v4l2 codec.*/
 				vdec_v4l_set_ps_infos(ctx, &ps);
@@ -9584,18 +9659,11 @@ static int amvdec_vp9_mmu_init(struct VP9Decoder_s *pbi)
 {
 	int tvp_flag = vdec_secure(hw_to_vdec(pbi)) ?
 		CODEC_MM_FLAGS_TVP : 0;
-	int buf_size = 48;
+	int buf_size = vp9_max_mmu_buf_size(pbi->max_pic_w, pbi->max_pic_h);
 
-	if ((pbi->max_pic_w * pbi->max_pic_h > 1280*736) &&
-		(pbi->max_pic_w * pbi->max_pic_h <= 1920*1088)) {
-		buf_size = 12;
-	} else if ((pbi->max_pic_w * pbi->max_pic_h > 0) &&
-		(pbi->max_pic_w * pbi->max_pic_h <= 1280*736)) {
-		buf_size = 4;
-	}
 	pbi->need_cache_size = buf_size * SZ_1M;
 	pbi->sc_start_time = get_jiffies_64();
-	if (pbi->mmu_enable && ((pbi->double_write_mode & 0x10) == 0)) {
+	if (pbi->mmu_enable && !pbi->is_used_v4l) {
 		pbi->mmu_box = decoder_mmu_box_alloc_box(DRIVER_NAME,
 			pbi->index, FRAME_BUFFERS,
 			pbi->need_cache_size,
@@ -9871,6 +9939,20 @@ static unsigned char get_data_check_sum
 	for (jj = 0; jj < size; jj++)
 		sum += data[jj];
 
+	vp9_print(pbi, PRINT_FLAG_VDEC_STATUS,
+		"%s: size 0x%x sum 0x%x %02x %02x %02x %02x %02x %02x .. %02x %02x %02x %02x\n",
+		__func__, size, sum,
+		(size < 1) ? 0 : data[0],
+		(size < 2) ? 0 : data[1],
+		(size < 3) ? 0 : data[2],
+		(size < 4) ? 0 : data[3],
+		(size < 5) ? 0 : data[4],
+		(size < 6) ? 0 : data[5],
+		(size < 4) ? 0 : data[size - 4],
+		(size < 3) ? 0 : data[size - 3],
+		(size < 2) ? 0 : data[size - 2],
+		(size < 1) ? 0 : data[size - 1]);
+
 	if (!pbi->chunk->block->is_mapped)
 		codec_mm_unmap_phyaddr(data);
 	return sum;
@@ -10169,7 +10251,17 @@ static unsigned long run_ready(struct vdec_s *vdec, unsigned long mask)
 	if (!(pbi->pic_list_init_done && pbi->pic_list_init_done2) || pbi->eos)
 		return ret;
 	if (!pbi->first_sc_checked && pbi->mmu_enable) {
-		int size = decoder_mmu_box_sc_check(pbi->mmu_box, tvp);
+		int size;
+		void * mmu_box;
+
+		if (pbi->is_used_v4l) {
+			struct aml_vcodec_ctx *ctx =
+				(struct aml_vcodec_ctx *)(pbi->v4l2_ctx);
+			mmu_box = ctx->mmu_box;
+		} else
+			mmu_box = pbi->mmu_box;
+
+		size = decoder_mmu_box_sc_check(mmu_box, tvp);
 		pbi->first_sc_checked = 1;
 		vp9_print(pbi, 0, "vp9 cached=%d  need_size=%d speed= %d ms\n",
 			size, (pbi->need_cache_size >> PAGE_SHIFT),
@@ -10581,20 +10673,29 @@ static void run(struct vdec_s *vdec, unsigned long mask,
 
 }
 
-static void  init_frame_bufs(struct VP9Decoder_s *pbi)
+static void  vp9_decoder_ctx_reset(struct VP9Decoder_s *pbi)
 {
 	struct vdec_s *vdec = hw_to_vdec(pbi);
 	struct VP9_Common_s *const cm = &pbi->common;
 	struct RefCntBuffer_s *const frame_bufs = cm->buffer_pool->frame_bufs;
+	struct BufferPool_s *buffer_pool = cm->buffer_pool;
 	int i;
 
-	for (i = 0; i < pbi->used_buf_num; ++i) {
-		frame_bufs[i].ref_count = 0;
-		frame_bufs[i].buf.vf_ref = 0;
-		frame_bufs[i].buf.decode_idx = 0;
+	memset(cm, 0, sizeof(*cm));
+	cm->buffer_pool = buffer_pool;
+
+	for (i = 0; i < FRAME_BUFFERS; ++i) {
+		frame_bufs[i].buf.index		= i;
+		frame_bufs[i].ref_count		= 0;
+		frame_bufs[i].buf.vf_ref	= 0;
+		frame_bufs[i].buf.decode_idx	= 0;
 		frame_bufs[i].buf.cma_alloc_addr = 0;
-		frame_bufs[i].buf.index = i;
-		frame_bufs[i].buf.vframe_bound = 0;
+		frame_bufs[i].buf.BUF_index	= -1;
+		frame_bufs[i].buf.slice_type	= 0;
+	}
+
+	for (i = 0; i < MV_BUFFER_NUM; ++i) {
+		pbi->m_mv_BUF[i].used_flag = 0;
 	}
 
 	if (vdec->parallel_dec == 1) {
@@ -10607,6 +10708,12 @@ static void  init_frame_bufs(struct VP9Decoder_s *pbi)
 				vdec->id);
 		}
 	}
+
+	pbi->init_flag		= 0;
+	pbi->first_sc_checked	= 0;
+	pbi->fatal_error	= 0;
+	pbi->show_frame_num	= 0;
+	pbi->eos		= 0;
 }
 
 static void reset(struct vdec_s *vdec)
@@ -10614,6 +10721,7 @@ static void reset(struct vdec_s *vdec)
 	struct VP9Decoder_s *pbi =
 		(struct VP9Decoder_s *)vdec->private;
 
+	cancel_work_sync(&pbi->set_clk_work);
 	cancel_work_sync(&pbi->work);
 	if (pbi->stat & STAT_VDEC_RUN) {
 		amhevc_stop();
@@ -10624,14 +10732,12 @@ static void reset(struct vdec_s *vdec)
 		del_timer_sync(&pbi->timer);
 		pbi->stat &= ~STAT_TIMER_ARM;
 	}
-	pbi->dec_result = DEC_RESULT_NONE;
 	reset_process_time(pbi);
 	vp9_local_uninit(pbi);
 	if (vvp9_local_init(pbi) < 0)
 		vp9_print(pbi, 0, "%s	local_init failed \r\n", __func__);
-	init_frame_bufs(pbi);
 
-	pbi->eos = 0;
+	vp9_decoder_ctx_reset(pbi);
 
 	vp9_print(pbi, PRINT_FLAG_VDEC_DETAIL, "%s\r\n", __func__);
 }
@@ -11046,7 +11152,12 @@ static int ammvdec_vp9_probe(struct platform_device *pdev)
 	if (pbi->enable_fence)
 		pdata->sync.usage = pbi->fence_usage;
 
-	pbi->mmu_enable = 1;
+	if (get_cpu_major_id() < AM_MESON_CPU_MAJOR_ID_GXL ||
+		pbi->double_write_mode == 0x10)
+		pbi->mmu_enable = 0;
+	else
+		pbi->mmu_enable = 1;
+
 	video_signal_type = pbi->video_signal_type;
 
 	if (pdata->sys_info) {
-- 
2.17.1

