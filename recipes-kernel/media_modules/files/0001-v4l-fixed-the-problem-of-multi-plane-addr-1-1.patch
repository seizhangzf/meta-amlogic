From f0c15c5bb79b0c12c28be67424e0d116622e54c1 Mon Sep 17 00:00:00 2001
From: Nanxin Qin <nanxin.qin@amlogic.com>
Date: Tue, 17 Dec 2019 17:04:06 +0800
Subject: [PATCH] v4l: fixed the problem of multi plane addr [1/1]

PD#SWPL-13705

Problem:
HEBC/VP9 doesn't support multi planar buffer

Solution:
Configure canvas correctly according to vdec_v4l2_buffer

Verify:
U212 with VP9/HEVC streamer playback

Change-Id: I0ba73005ae6e610d19eba7e8bed1b038022f7cd1
Signed-off-by: Nanxin Qin <nanxin.qin@amlogic.com>
---
 drivers/frame_provider/decoder/h265/vh265.c | 23 ++++++++++-----------
 drivers/frame_provider/decoder/vp9/vvp9.c   | 19 +++++++++--------
 2 files changed, 21 insertions(+), 21 deletions(-)

diff --git a/drivers/frame_provider/decoder/h265/vh265.c b/drivers/frame_provider/decoder/h265/vh265.c
index 170cc224..957e020b 100644
--- a/drivers/frame_provider/decoder/h265/vh265.c
+++ b/drivers/frame_provider/decoder/h265/vh265.c
@@ -1307,11 +1307,12 @@ enum SliceType {
 struct BUF_s {
 	ulong	start_adr;
 	u32	size;
-	u32	luma_size;
 	ulong	header_addr;
 	u32 	header_size;
 	int	used_flag;
 	ulong	v4l_ref_buf_addr;
+	ulong	chroma_addr;
+	u32	chroma_size;
 } /*BUF_t */;
 
 /* level 6, 6.1 maximum slice number is 800; other is 200 */
@@ -3097,14 +3098,18 @@ static int v4l_alloc_buf(struct hevc_state_s *hevc, struct PIC_s *pic)
 	if (fb->num_planes == 1) {
 		hevc->m_BUF[i].start_adr = fb->m.mem[0].addr;
 		hevc->m_BUF[i].size = fb->m.mem[0].size;
-		hevc->m_BUF[i].luma_size = fb->m.mem[0].offset;
 		fb->m.mem[0].bytes_used = fb->m.mem[0].size;
+		pic->dw_y_adr = hevc->m_BUF[i].start_adr;
+		pic->dw_u_v_adr = pic->dw_y_adr + hevc->m_BUF[i].size;
 	} else if (fb->num_planes == 2) {
 		hevc->m_BUF[i].start_adr = fb->m.mem[0].addr;
-		hevc->m_BUF[i].size = fb->m.mem[0].size + fb->m.mem[1].size;
-		hevc->m_BUF[i].luma_size = fb->m.mem[0].size;
+		hevc->m_BUF[i].size = fb->m.mem[0].size;
+		hevc->m_BUF[i].chroma_addr = fb->m.mem[1].addr;
+		hevc->m_BUF[i].chroma_size = fb->m.mem[1].size;
 		fb->m.mem[0].bytes_used = fb->m.mem[0].size;
 		fb->m.mem[1].bytes_used = fb->m.mem[1].size;
+		pic->dw_y_adr = hevc->m_BUF[i].start_adr;
+		pic->dw_u_v_adr = hevc->m_BUF[i].chroma_addr;
 	}
 
 	return ret;
@@ -3329,16 +3334,10 @@ static int v4l_config_pic(struct hevc_state_s *hevc, struct PIC_s *pic)
 	pic->mc_canvas_u_v	= pic->index;
 
 	if (dw_mode & 0x10) {
-		pic->mc_y_adr	= hevc->m_BUF[i].start_adr;
-		pic->mc_u_v_adr	= pic->mc_y_adr + hevc->m_BUF[i].luma_size;
 		pic->mc_canvas_y = (pic->index << 1);
 		pic->mc_canvas_u_v = (pic->index << 1) + 1;
-
-		pic->dw_y_adr	= pic->mc_y_adr;
-		pic->dw_u_v_adr	= pic->mc_u_v_adr;
-	} else if (dw_mode) {
-		pic->dw_y_adr	= hevc->m_BUF[i].start_adr;
-		pic->dw_u_v_adr	= pic->dw_y_adr + hevc->m_BUF[i].luma_size;
+		pic->mc_y_adr = pic->dw_y_adr;
+		pic->mc_u_v_adr = pic->dw_u_v_adr;
 	}
 
 	return 0;
diff --git a/drivers/frame_provider/decoder/vp9/vvp9.c b/drivers/frame_provider/decoder/vp9/vvp9.c
index 6db0aa30..60dc25c9 100644
--- a/drivers/frame_provider/decoder/vp9/vvp9.c
+++ b/drivers/frame_provider/decoder/vp9/vvp9.c
@@ -294,7 +294,8 @@ struct BUF_s {
 	ulong v4l_ref_buf_addr;
 	ulong	header_addr;
 	u32 	header_size;
-	u32	luma_size;
+	ulong	chroma_addr;
+	u32	chroma_size;
 } /*BUF_t */;
 
 struct MVBUF_s {
@@ -4805,14 +4806,19 @@ static int v4l_alloc_and_config_pic(struct VP9Decoder_s *pbi,
 	if (fb->num_planes == 1) {
 		pbi->m_BUF[i].start_adr = fb->m.mem[0].addr;
 		pbi->m_BUF[i].size = fb->m.mem[0].size;
-		pbi->m_BUF[i].luma_size = fb->m.mem[0].offset;
 		fb->m.mem[0].bytes_used = fb->m.mem[0].size;
+		pic->dw_y_adr	= pbi->m_BUF[i].start_adr;
+		pic->dw_u_v_adr	= pic->dw_y_adr + pbi->m_BUF[i].size;
+
 	} else if (fb->num_planes == 2) {
 		pbi->m_BUF[i].start_adr = fb->m.mem[0].addr;
-		pbi->m_BUF[i].size = fb->m.mem[0].size + fb->m.mem[1].size;
-		pbi->m_BUF[i].luma_size = fb->m.mem[0].size;
+		pbi->m_BUF[i].size = fb->m.mem[0].size;
+		pbi->m_BUF[i].chroma_addr = fb->m.mem[1].addr;
+		pbi->m_BUF[i].chroma_size = fb->m.mem[1].size;
 		fb->m.mem[0].bytes_used = fb->m.mem[0].size;
 		fb->m.mem[1].bytes_used = fb->m.mem[1].size;
+		pic->dw_y_adr	= pbi->m_BUF[i].start_adr;
+		pic->dw_u_v_adr	= pbi->m_BUF[i].chroma_addr;
 	}
 
 	/* config frame buffer */
@@ -4825,13 +4831,8 @@ static int v4l_alloc_and_config_pic(struct VP9Decoder_s *pbi,
 	pic->mc_canvas_u_v	= pic->index;
 
 	if (dw_mode & 0x10) {
-		pic->dw_y_adr	= pbi->m_BUF[i].start_adr;
-		pic->dw_u_v_adr	= pic->dw_y_adr + pbi->m_BUF[i].luma_size;
 		pic->mc_canvas_y = (pic->index << 1);
 		pic->mc_canvas_u_v = (pic->index << 1) + 1;
-	} else if (dw_mode) {
-		pic->dw_y_adr	= pbi->m_BUF[i].start_adr;
-		pic->dw_u_v_adr	= pic->dw_y_adr + pbi->m_BUF[i].luma_size;
 	}
 
 #ifdef MV_USE_FIXED_BUF
-- 
2.24.1

