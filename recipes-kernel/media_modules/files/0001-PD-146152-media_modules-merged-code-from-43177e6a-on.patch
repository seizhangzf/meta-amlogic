From f3d2d245e5e15fb86593f5808bdbb09b34788713 Mon Sep 17 00:00:00 2001
From: Nanxin Qin <nanxin.qin@amlogic.com>
Date: Mon, 19 Jun 2017 16:05:08 +0800
Subject: [PATCH] PD#146152: media_modules: merged code from 43177e6a on the
 amlogic-3.14-dev

Change-Id: Iff829f6e4058c7001901e65c03e283a82fd1ec4a
Signed-off-by: Nanxin Qin <nanxin.qin@amlogic.com>
---
 drivers/common/chips/chips.c                       |    3 +-
 drivers/common/firmware/firmware_drv.c             |    2 +-
 drivers/common/media_clock/clk/clk.c               |    2 +-
 drivers/common/media_clock/clk/clkgx.c             |    7 +-
 drivers/frame_provider/decoder/avs/avs.c           |  516 ++-
 drivers/frame_provider/decoder/avs/avsp_trans.c    |  111 +-
 drivers/frame_provider/decoder/h264/vh264.c        |  739 ++--
 drivers/frame_provider/decoder/h264/vh264.h        |    2 +
 drivers/frame_provider/decoder/h264/vh264_4k2k.c   |  364 +-
 drivers/frame_provider/decoder/h264/vh264_mvc.c    |  394 +-
 .../frame_provider/decoder/h264_multi/h264_dpb.c   |  675 ++--
 .../frame_provider/decoder/h264_multi/h264_dpb.h   |   80 +-
 drivers/frame_provider/decoder/h264_multi/vmh264.c | 4193 ++++++++++++++++----
 drivers/frame_provider/decoder/h265/vh265.c        | 4013 ++++++++++++-------
 drivers/frame_provider/decoder/mjpeg/vmjpeg.c      |  304 +-
 .../frame_provider/decoder/mjpeg/vmjpeg_multi.c    |   88 +-
 drivers/frame_provider/decoder/mpeg12/vmpeg12.c    |  395 +-
 drivers/frame_provider/decoder/mpeg4/vmpeg4.c      |  268 +-
 .../frame_provider/decoder/mpeg4/vmpeg4_multi.c    |   11 +-
 drivers/frame_provider/decoder/real/vreal.c        |  194 +-
 drivers/frame_provider/decoder/utils/Makefile      |    2 +-
 drivers/frame_provider/decoder/utils/amvdec.c      |   26 +-
 drivers/frame_provider/decoder/utils/amvdec.h      |    2 +
 .../frame_provider/decoder/utils/config_parser.c   |    2 +
 .../decoder/utils/decoder_bmmu_box.c               |  121 +-
 .../decoder/utils/decoder_bmmu_box.h               |    5 +
 .../frame_provider/decoder/utils/decoder_mmu_box.c |   40 +-
 .../frame_provider/decoder/utils/decoder_mmu_box.h |    3 +-
 drivers/frame_provider/decoder/utils/secprot.c     |   43 +
 drivers/frame_provider/decoder/utils/secprot.h     |   39 +
 drivers/frame_provider/decoder/utils/utils.c       |    5 +
 drivers/frame_provider/decoder/utils/vdec.c        | 1219 ++++--
 drivers/frame_provider/decoder/utils/vdec.h        |   80 +-
 drivers/frame_provider/decoder/utils/vdec_input.c  |  670 +++-
 drivers/frame_provider/decoder/utils/vdec_input.h  |   41 +-
 .../frame_provider/decoder/utils/vdec_profile.c    |  217 +
 .../frame_provider/decoder/utils/vdec_profile.h    |   39 +
 drivers/frame_provider/decoder/utils/vdec_trace.h  |  149 +
 drivers/frame_provider/decoder/vc1/vvc1.c          |  236 +-
 drivers/frame_provider/decoder/vp9/vvp9.c          | 2456 ++++++++----
 drivers/frame_provider/decoder/vp9/vvp9.h          |    2 -
 drivers/stream_input/amports/adec.c                |  108 +-
 drivers/stream_input/amports/amports_priv.h        |    5 +-
 drivers/stream_input/amports/amstream.c            |  520 ++-
 drivers/stream_input/parser/esparser.c             |  280 +-
 drivers/stream_input/parser/esparser.h             |   11 +-
 drivers/stream_input/parser/psparser.c             |  156 +-
 drivers/stream_input/parser/psparser.h             |    5 +-
 drivers/stream_input/parser/rmparser.c             |   96 +-
 drivers/stream_input/parser/streambuf.c            |  102 +-
 drivers/stream_input/parser/streambuf.h            |    9 +-
 drivers/stream_input/parser/streambuf_reg.h        |    5 +-
 drivers/stream_input/parser/tsdemux.c              |  254 +-
 firmware/video_ucode.bin                           |  Bin 420352 -> 424448 bytes
 54 files changed, 13497 insertions(+), 5812 deletions(-)
 create mode 100644 drivers/frame_provider/decoder/utils/secprot.c
 create mode 100644 drivers/frame_provider/decoder/utils/secprot.h
 create mode 100644 drivers/frame_provider/decoder/utils/vdec_profile.c
 create mode 100644 drivers/frame_provider/decoder/utils/vdec_profile.h
 create mode 100644 drivers/frame_provider/decoder/utils/vdec_trace.h

diff --git a/drivers/common/chips/chips.c b/drivers/common/chips/chips.c
index f2e7fa6..8eaaa0a 100644
--- a/drivers/common/chips/chips.c
+++ b/drivers/common/chips/chips.c
@@ -25,7 +25,7 @@
 #include <linux/mm.h>
 
 #include <linux/amlogic/media/utils/vformat.h>
-#include <linux/amlogic/media/old_cpu_version.h>
+#include <linux/amlogic/cpu_version.h>
 #include "../../stream_input/amports/amports_priv.h"
 #include "../../frame_provider/decoder/utils/vdec.h"
 #include "chips.h"
@@ -68,6 +68,7 @@ static const struct type_name cpu_type_name[] = {
 	{MESON_CPU_MAJOR_ID_GXL, "gxl"},
 	{MESON_CPU_MAJOR_ID_GXM, "gxm"},
 	{MESON_CPU_MAJOR_ID_TXL, "txl"},
+	{MESON_CPU_MAJOR_ID_TXLX, "txlx"},
 	{0, NULL},
 };
 
diff --git a/drivers/common/firmware/firmware_drv.c b/drivers/common/firmware/firmware_drv.c
index 56420e1..c80603f 100644
--- a/drivers/common/firmware/firmware_drv.c
+++ b/drivers/common/firmware/firmware_drv.c
@@ -26,7 +26,7 @@
 #include <linux/slab.h>
 
 #include <linux/amlogic/media/utils/vformat.h>
-#include <linux/amlogic/media/old_cpu_version.h>
+#include <linux/amlogic/cpu_version.h>
 #include "../../stream_input/amports/amports_priv.h"
 #include "../../frame_provider/decoder/utils/vdec.h"
 #include "firmware.h"
diff --git a/drivers/common/media_clock/clk/clk.c b/drivers/common/media_clock/clk/clk.c
index 18d308f..2713401 100644
--- a/drivers/common/media_clock/clk/clk.c
+++ b/drivers/common/media_clock/clk/clk.c
@@ -27,7 +27,7 @@
 #include <linux/slab.h>
 
 #include <linux/amlogic/media/utils/vformat.h>
-#include <linux/amlogic/media/old_cpu_version.h>
+#include <linux/amlogic/cpu_version.h>
 #include "../../../stream_input/amports/amports_priv.h"
 #include "../../../frame_provider/decoder/utils/vdec.h"
 #include "../../chips/chips.h"
diff --git a/drivers/common/media_clock/clk/clkgx.c b/drivers/common/media_clock/clk/clkgx.c
index 8520738..0c1e67c 100644
--- a/drivers/common/media_clock/clk/clkgx.c
+++ b/drivers/common/media_clock/clk/clkgx.c
@@ -504,7 +504,7 @@ static void vdec_clock_on(void)
 	spin_unlock_irqrestore(&gclk.vdec_mux_node->lock,
 		gclk.vdec_mux_node->flags);
 
-	pr_info("the %-15s clock off, ref cnt: %d\n",
+	pr_info("the %-15s clock on, ref cnt: %d\n",
 		gclk.vdec_mux_node->name,
 		gclk.vdec_mux_node->ref_count);
 }
@@ -537,7 +537,7 @@ static void hcodec_clock_on(void)
 	spin_unlock_irqrestore(&gclk.hcodec_mux_node->lock,
 		gclk.hcodec_mux_node->flags);
 
-	pr_info("the %-15s clock off, ref cnt: %d\n",
+	pr_info("the %-15s clock on, ref cnt: %d\n",
 		gclk.hcodec_mux_node->name,
 		gclk.hcodec_mux_node->ref_count);
 }
@@ -570,7 +570,7 @@ static void hevc_clock_on(void)
 	spin_unlock_irqrestore(&gclk.hevc_mux_node->lock,
 		gclk.hevc_mux_node->flags);
 
-	pr_info("the %-15s clock off, ref cnt: %d\n",
+	pr_info("the %-15s clock on, ref cnt: %d\n",
 		gclk.hevc_mux_node->name,
 		gclk.hevc_mux_node->ref_count);
 }
@@ -612,6 +612,7 @@ static int vdec_clock_get(enum vdec_type_e core)
 	MESON_CPU_MAJOR_ID_GXL,\
 	MESON_CPU_MAJOR_ID_GXM,\
 	MESON_CPU_MAJOR_ID_TXL,\
+	MESON_CPU_MAJOR_ID_TXLX,\
 	0}
 #include "clk.h"
 ARCH_VDEC_CLK_INIT();
diff --git a/drivers/frame_provider/decoder/avs/avs.c b/drivers/frame_provider/decoder/avs/avs.c
index aed8497..34dcca6 100644
--- a/drivers/frame_provider/decoder/avs/avs.c
+++ b/drivers/frame_provider/decoder/avs/avs.c
@@ -36,10 +36,15 @@
 #include <linux/amlogic/media/codec_mm/codec_mm.h>
 #include <linux/slab.h>
 #include "avs.h"
+#include <linux/amlogic/media/codec_mm/configs.h>
+#include "../utils/decoder_mmu_box.h"
+#include "../utils/decoder_bmmu_box.h"
 
 #define DRIVER_NAME "amvdec_avs"
 #define MODULE_NAME "amvdec_avs"
 
+#define ENABLE_USER_DATA
+
 #if 1/* MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6 */
 #define NV21
 #endif
@@ -88,7 +93,12 @@
 
 static int debug_flag;
 
-static int firmware_sel; /* 0, normal; 1, old ucode */
+/********************************
+firmware_sel
+    0: use avsp_trans long cabac ucode;
+    1: not use avsp_trans long cabac ucode
+********************************/
+static int firmware_sel;
 
 int avs_get_debug_flag(void)
 {
@@ -112,12 +122,22 @@ static const struct vframe_operations_s vavs_vf_provider = {
 	.put = vavs_vf_put,
 	.vf_states = vavs_vf_states,
 };
-
+static void *mm_blk_handle;
 static struct vframe_provider_s vavs_vf_prov;
 
-#define  VF_BUF_NUM_MAX 16
+#define VF_BUF_NUM_MAX 16
+#define WORKSPACE_SIZE		(4 * SZ_1M)
+
+#ifdef AVSP_LONG_CABAC
+#define MAX_BMMU_BUFFER_NUM	(VF_BUF_NUM_MAX + 2)
+#define WORKSPACE_SIZE_A		(MAX_CODED_FRAME_SIZE + LOCAL_HEAP_SIZE)
+#else
+#define MAX_BMMU_BUFFER_NUM	(VF_BUF_NUM_MAX + 1)
+#endif
+
+#define RV_AI_BUFF_START_ADDR	 0x01a00000
+#define LONG_CABAC_RV_AI_BUFF_START_ADDR	 0x00000000
 
-/*static u32 vf_buf_num = 4*/
 static u32 vf_buf_num = 4;
 static u32 vf_buf_num_used;
 static u32 canvas_base = 128;
@@ -126,7 +146,7 @@ static u32 canvas_base = 128;
 #else
 	int	canvas_num = 3;
 #endif
-static u32 work_buf_size;
+
 
 static struct vframe_s vfpool[VF_POOL_SIZE];
 /*static struct vframe_s vfpool2[VF_POOL_SIZE];*/
@@ -137,8 +157,8 @@ static u32 saved_resolution;
 static u32 frame_width, frame_height, frame_dur, frame_prog;
 static struct timer_list recycle_timer;
 static u32 stat;
-static unsigned long buf_start;
-static u32 buf_size, buf_offset;
+static u32 buf_size = 32 * 1024 * 1024;
+static u32 buf_offset;
 static u32 avi_flag;
 static u32 vavs_ratio;
 static u32 pic_type;
@@ -152,6 +172,9 @@ static u32 pts_hit, pts_missed, pts_i_hit, pts_i_missed;
 
 static u32 radr, rval;
 static struct dec_sysinfo vavs_amstream_dec_info;
+static struct vdec_info *gvs;
+static u32 fr_hint_status;
+static struct work_struct notify_work;
 
 #ifdef AVSP_LONG_CABAC
 static struct work_struct long_cabac_wd_work;
@@ -161,9 +184,13 @@ dma_addr_t es_write_addr_phy;
 void *bitstream_read_tmp;
 dma_addr_t bitstream_read_tmp_phy;
 void *avsp_heap_adr;
-
+static uint long_cabac_busy;
 #endif
 
+#ifdef ENABLE_USER_DATA
+static void *user_data_buffer;
+static dma_addr_t user_data_buffer_phys;
+#endif
 static DECLARE_KFIFO(newframe_q, struct vframe_s *, VF_POOL_SIZE);
 static DECLARE_KFIFO(display_q, struct vframe_s *, VF_POOL_SIZE);
 static DECLARE_KFIFO(recycle_q, struct vframe_s *, VF_POOL_SIZE);
@@ -190,13 +217,13 @@ static inline u32 index2canvas(u32 index)
 
 static const u32 frame_rate_tab[16] = {
 	96000 / 30,		/* forbidden */
-	96000 / 24,		/* 24000/1001 (23.967) */
+	96000000 / 23976,	/* 24000/1001 (23.967) */
 	96000 / 24,
 	96000 / 25,
-	96000 / 30,		/* 30000/1001 (29.97) */
+	9600000 / 2997,		/* 30000/1001 (29.97) */
 	96000 / 30,
 	96000 / 50,
-	96000 / 60,		/* 60000/1001 (59.94) */
+	9600000 / 5994,		/* 60000/1001 (59.94) */
 	96000 / 60,
 	/* > 8 reserved, use 24 */
 	96000 / 24, 96000 / 24, 96000 / 24, 96000 / 24,
@@ -232,6 +259,7 @@ static void set_frame_info(struct vframe_s *vf, unsigned *duration)
 		*duration = frame_rate_tab[READ_VREG(AVS_FRAME_RATE) & 0xf];
 		/* pr_info("%s: duration = %d\n", __func__, *duration); */
 		frame_dur = *duration;
+		schedule_work(&notify_work);
 	}
 
 	if (vavs_ratio == 0) {
@@ -267,6 +295,105 @@ static void set_frame_info(struct vframe_s *vf, unsigned *duration)
 	vf->flag = 0;
 }
 
+#ifdef ENABLE_USER_DATA
+
+static struct work_struct userdata_push_work;
+/*
+#define DUMP_LAST_REPORTED_USER_DATA
+*/
+static void userdata_push_do_work(struct work_struct *work)
+{
+	unsigned int user_data_flags;
+	unsigned int user_data_wp;
+	unsigned int user_data_length;
+	struct userdata_poc_info_t user_data_poc;
+#ifdef DUMP_LAST_REPORTED_USER_DATA
+	int user_data_len;
+	int wp_start;
+	unsigned char *pdata;
+	int nLeft;
+#endif
+
+	user_data_flags = READ_VREG(AV_SCRATCH_N);
+	user_data_wp = (user_data_flags >> 16) & 0xffff;
+	user_data_length = user_data_flags & 0x7fff;
+
+#ifdef DUMP_LAST_REPORTED_USER_DATA
+	dma_sync_single_for_cpu(amports_get_dma_device(),
+			user_data_buffer_phys, USER_DATA_SIZE,
+			DMA_FROM_DEVICE);
+
+	if (user_data_length & 0x07)
+		user_data_len = (user_data_length + 8) & 0xFFFFFFF8;
+	else
+		user_data_len = user_data_length;
+
+	if (user_data_wp >= user_data_len) {
+		wp_start = user_data_wp - user_data_len;
+
+		pdata = (unsigned char *)user_data_buffer;
+		pdata += wp_start;
+		nLeft = user_data_len;
+		while (nLeft >= 8) {
+			pr_info("%02x %02x %02x %02x %02x %02x %02x %02x\n",
+				pdata[0], pdata[1], pdata[2], pdata[3],
+				pdata[4], pdata[5], pdata[6], pdata[7]);
+			nLeft -= 8;
+			pdata += 8;
+		}
+	} else {
+		wp_start = user_data_wp +
+			USER_DATA_SIZE - user_data_len;
+
+		pdata = (unsigned char *)user_data_buffer;
+		pdata += wp_start;
+		nLeft = USER_DATA_SIZE - wp_start;
+
+		while (nLeft >= 8) {
+			pr_info("%02x %02x %02x %02x %02x %02x %02x %02x\n",
+				pdata[0], pdata[1], pdata[2], pdata[3],
+				pdata[4], pdata[5], pdata[6], pdata[7]);
+			nLeft -= 8;
+			pdata += 8;
+		}
+
+		pdata = (unsigned char *)user_data_buffer;
+		nLeft = user_data_wp;
+		while (nLeft >= 8) {
+			pr_info("%02x %02x %02x %02x %02x %02x %02x %02x\n",
+				pdata[0], pdata[1], pdata[2], pdata[3],
+				pdata[4], pdata[5], pdata[6], pdata[7]);
+			nLeft -= 8;
+			pdata += 8;
+		}
+	}
+#endif
+
+/*
+	pr_info("pocinfo 0x%x, poc %d, wp 0x%x, len %d\n",
+		   READ_VREG(AV_SCRATCH_L), READ_VREG(AV_SCRATCH_M),
+		   user_data_wp, user_data_length);
+*/
+	user_data_poc.poc_info = READ_VREG(AV_SCRATCH_L);
+	user_data_poc.poc_number = READ_VREG(AV_SCRATCH_M);
+
+	WRITE_VREG(AV_SCRATCH_N, 0);
+	wakeup_userdata_poll(user_data_poc, user_data_wp,
+				(unsigned long)user_data_buffer,
+				USER_DATA_SIZE, user_data_length);
+}
+
+static void UserDataHandler(void)
+{
+	unsigned int user_data_flags;
+
+	user_data_flags = READ_VREG(AV_SCRATCH_N);
+	if (user_data_flags & (1 << 15)) {	/* data ready */
+		schedule_work(&userdata_push_work);
+	}
+}
+#endif
+
 #ifdef HANDLE_AVS_IRQ
 static irqreturn_t vavs_isr(int irq, void *dev_id)
 #else
@@ -296,6 +423,10 @@ static void vavs_isr(void)
 		schedule_work(&long_cabac_wd_work);
 	}
 #endif
+
+#ifdef ENABLE_USER_DATA
+	UserDataHandler();
+#endif
 	reg = READ_VREG(AVS_BUFFEROUT);
 
 	if (reg) {
@@ -415,6 +546,10 @@ static void vavs_isr(void)
 			}
 
 			vfbuf_use[buffer_index]++;
+			vf->mem_handle =
+				decoder_bmmu_box_get_mem_handle(
+					mm_blk_handle,
+					buffer_index);
 
 			kfifo_put(&display_q,
 					  (const struct vframe_s *)vf);
@@ -459,6 +594,10 @@ static void vavs_isr(void)
 				index2canvas(buffer_index);
 			vf->type_original = vf->type;
 			vfbuf_use[buffer_index]++;
+			vf->mem_handle =
+				decoder_bmmu_box_get_mem_handle(
+					mm_blk_handle,
+					buffer_index);
 
 			kfifo_put(&display_q,
 					  (const struct vframe_s *)vf);
@@ -528,6 +667,10 @@ static void vavs_isr(void)
 			}
 
 			vfbuf_use[buffer_index]++;
+			vf->mem_handle =
+				decoder_bmmu_box_get_mem_handle(
+					mm_blk_handle,
+					buffer_index);
 			kfifo_put(&display_q,
 					  (const struct vframe_s *)vf);
 			vf_notify_receiver(PROVIDER_NAME,
@@ -536,6 +679,10 @@ static void vavs_isr(void)
 			total_frame++;
 		}
 
+		/*count info*/
+		gvs->frame_dur = frame_dur;
+		vdec_count_info(gvs, 0, offset);
+
 		/* pr_info("PicType = %d, PTS = 0x%x\n",
 		   picture_type, vf->pts); */
 		WRITE_VREG(AVS_BUFFEROUT, 0);
@@ -604,28 +751,50 @@ static void vavs_vf_put(struct vframe_s *vf, void *op_arg)
 
 }
 
-int vavs_dec_status(struct vdec_s *vdec, struct vdec_status *vstatus)
+int vavs_dec_status(struct vdec_s *vdec, struct vdec_info *vstatus)
 {
-	vstatus->width = frame_width;	/* vavs_amstream_dec_info.width; */
-	vstatus->height = frame_height;	/* vavs_amstream_dec_info.height; */
-	if (0 != frame_dur /*vavs_amstream_dec_info.rate */)
-		vstatus->fps = 96000 / frame_dur;
+	vstatus->frame_width = frame_width;
+	vstatus->frame_height = frame_height;
+	if (frame_dur != 0)
+		vstatus->frame_rate = 96000 / frame_dur;
 	else
-		vstatus->fps = 96000;
-	vstatus->error_count = READ_VREG(AVS_ERROR_COUNT);
+		vstatus->frame_rate = -1;
+	vstatus->error_count = READ_VREG(AV_SCRATCH_C);
 	vstatus->status = stat;
+	vstatus->bit_rate = gvs->bit_rate;
+	vstatus->frame_dur = frame_dur;
+	vstatus->frame_data = gvs->frame_data;
+	vstatus->total_data = gvs->total_data;
+	vstatus->frame_count = gvs->frame_count;
+	vstatus->error_frame_count = gvs->error_frame_count;
+	vstatus->drop_frame_count = gvs->drop_frame_count;
+	vstatus->total_data = gvs->total_data;
+	vstatus->samp_cnt = gvs->samp_cnt;
+	vstatus->offset = gvs->offset;
+	snprintf(vstatus->vdec_name, sizeof(vstatus->vdec_name),
+		"%s", DRIVER_NAME);
+
+	return 0;
+}
 
+static int vavs_vdec_info_init(void)
+{
+	gvs = kzalloc(sizeof(struct vdec_info), GFP_KERNEL);
+	if (NULL == gvs) {
+		pr_info("the struct of vdec status malloc failed.\n");
+		return -ENOMEM;
+	}
 	return 0;
 }
 
 /****************************************/
-static void vavs_canvas_init(void)
+static int vavs_canvas_init(void)
 {
-	int i;
+	int i, ret;
 	u32 canvas_width, canvas_height;
 	u32 decbuf_size, decbuf_y_size, decbuf_uv_size;
-	u32 disp_addr = 0xffffffff;
-	int vf_buf_num_avail = 0;
+	unsigned long buf_start;
+	int need_alloc_buf_num;
 	vf_buf_num_used = vf_buf_num;
 	if (buf_size <= 0x00400000) {
 		/* SD only */
@@ -634,12 +803,6 @@ static void vavs_canvas_init(void)
 		decbuf_y_size = 0x80000;
 		decbuf_uv_size = 0x20000;
 		decbuf_size = 0x100000;
-		vf_buf_num_avail =
-		((buf_size - work_buf_size) / decbuf_size) - 1;
-		pr_info
-		("avs(SD):buf_start %p, size %x, offset %x avail %d\n",
-		 (void *)buf_start, buf_size, buf_offset,
-		 vf_buf_num_avail);
 	} else {
 		/* HD & SD */
 		canvas_width = 1920;
@@ -647,95 +810,67 @@ static void vavs_canvas_init(void)
 		decbuf_y_size = 0x200000;
 		decbuf_uv_size = 0x80000;
 		decbuf_size = 0x300000;
-		vf_buf_num_avail =
-		((buf_size - work_buf_size) / decbuf_size) - 1;
-		pr_info("avs: buf_start %p, buf_size %x, buf_offset %x buf avail %d\n",
-			   (void *)buf_start, buf_size, buf_offset,
-			   vf_buf_num_avail);
 	}
-	if (vf_buf_num_used > vf_buf_num_avail)
-		vf_buf_num_used = vf_buf_num_avail;
 
-	if (firmware_sel == 0)
-		buf_offset = buf_offset + ((vf_buf_num_used + 1) * decbuf_size);
-
-	if (READ_MPEG_REG(VPP_MISC) & VPP_VD1_POSTBLEND) {
-		struct canvas_s cur_canvas;
-
-		canvas_read((READ_MPEG_REG(VD1_IF0_CANVAS0) & 0xff),
-					&cur_canvas);
-		disp_addr = (cur_canvas.addr + 7) >> 3;
-	}
-
-	for (i = 0; i < vf_buf_num_used; i++) {
-		if (((buf_start + i * decbuf_size + 7) >> 3) == disp_addr) {
-#ifdef NV21
-			canvas_config(canvas_base + canvas_num * i + 0,
-					buf_start +
-					vf_buf_num_used * decbuf_size,
-					canvas_width, canvas_height,
-					CANVAS_ADDR_NOWRAP,
-					CANVAS_BLKMODE_32X32);
-			canvas_config(canvas_base + canvas_num * i + 1,
-					buf_start +
-					vf_buf_num_used * decbuf_size +
-					decbuf_y_size, canvas_width,
-					canvas_height / 2,
-					CANVAS_ADDR_NOWRAP,
-					CANVAS_BLKMODE_32X32);
+#ifdef AVSP_LONG_CABAC
+	need_alloc_buf_num = vf_buf_num_used + 2;
 #else
-			canvas_config(canvas_num * i + 0,
-					buf_start + 4 * decbuf_size,
-					canvas_width, canvas_height,
-					CANVAS_ADDR_NOWRAP,
-					CANVAS_BLKMODE_32X32);
-			canvas_config(canvas_num * i + 1,
-					buf_start + 4 * decbuf_size +
-					decbuf_y_size, canvas_width / 2,
-					canvas_height / 2,
-					CANVAS_ADDR_NOWRAP,
-						  CANVAS_BLKMODE_32X32);
-			canvas_config(canvas_num * i + 2,
-					buf_start + 4 * decbuf_size +
-					decbuf_y_size + decbuf_uv_size,
-					canvas_width / 2, canvas_height / 2,
-					CANVAS_ADDR_NOWRAP,
-					CANVAS_BLKMODE_32X32);
+	need_alloc_buf_num = vf_buf_num_used + 1;
+#endif
+	for (i = 0; i < need_alloc_buf_num; i++) {
+
+		if (i == (need_alloc_buf_num - 1))
+			decbuf_size = WORKSPACE_SIZE;
+#ifdef AVSP_LONG_CABAC
+		else if (i == (need_alloc_buf_num - 2))
+			decbuf_size = WORKSPACE_SIZE_A;
+#endif
+		ret = decoder_bmmu_box_alloc_buf_phy(mm_blk_handle, i,
+				decbuf_size, DRIVER_NAME, &buf_start);
+		if (ret < 0)
+			return ret;
+		if (i == (need_alloc_buf_num - 1)) {
+			if (firmware_sel == 1)
+				buf_offset = buf_start -
+					RV_AI_BUFF_START_ADDR;
+			else
+				buf_offset = buf_start -
+					LONG_CABAC_RV_AI_BUFF_START_ADDR;
+			continue;
+		}
+#ifdef AVSP_LONG_CABAC
+		else if (i == (need_alloc_buf_num - 2)) {
+			avsp_heap_adr = codec_mm_phys_to_virt(buf_start);
+			continue;
+		}
 #endif
-			if (debug_flag & AVS_DEBUG_PRINT) {
-				pr_info("canvas config %d, addr %p\n",
-					vf_buf_num_used,
-					   (void *)(buf_start +
-					   vf_buf_num_used * decbuf_size));
-			}
 
-		} else {
 #ifdef NV21
 			canvas_config(canvas_base + canvas_num * i + 0,
-					buf_start + i * decbuf_size,
+					buf_start,
 					canvas_width, canvas_height,
 					CANVAS_ADDR_NOWRAP,
 					CANVAS_BLKMODE_32X32);
 			canvas_config(canvas_base + canvas_num * i + 1,
-					buf_start + i * decbuf_size +
+					buf_start +
 					decbuf_y_size, canvas_width,
 					canvas_height / 2,
 					CANVAS_ADDR_NOWRAP,
 					CANVAS_BLKMODE_32X32);
 #else
 			canvas_config(canvas_num * i + 0,
-					buf_start + i * decbuf_size,
+					buf_start,
 					canvas_width, canvas_height,
 					CANVAS_ADDR_NOWRAP,
 					CANVAS_BLKMODE_32X32);
 			canvas_config(canvas_num * i + 1,
-					buf_start + i * decbuf_size +
+					buf_start +
 					decbuf_y_size, canvas_width / 2,
 					canvas_height / 2,
 					CANVAS_ADDR_NOWRAP,
 					CANVAS_BLKMODE_32X32);
 			canvas_config(canvas_num * i + 2,
-					buf_start + i * decbuf_size +
+					buf_start +
 					decbuf_y_size + decbuf_uv_size,
 					canvas_width / 2, canvas_height / 2,
 					CANVAS_ADDR_NOWRAP,
@@ -743,15 +878,17 @@ static void vavs_canvas_init(void)
 #endif
 			if (debug_flag & AVS_DEBUG_PRINT) {
 				pr_info("canvas config %d, addr %p\n", i,
-					   (void *)(buf_start +
-					   i * decbuf_size));
+					   (void *)buf_start);
 			}
-		}
+
 	}
+	return 0;
 }
 
 void vavs_recover(void)
 {
+	vavs_canvas_init();
+
 	WRITE_VREG(DOS_SW_RESET0, (1 << 7) | (1 << 6) | (1 << 4));
 	WRITE_VREG(DOS_SW_RESET0, 0);
 
@@ -831,8 +968,9 @@ void vavs_recover(void)
 
 }
 
-static void vavs_prot_init(void)
+static int vavs_prot_init(void)
 {
+	int r;
 #if 1 /* MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6 */
 	WRITE_VREG(DOS_SW_RESET0, (1 << 7) | (1 << 6) | (1 << 4));
 	WRITE_VREG(DOS_SW_RESET0, 0);
@@ -846,13 +984,13 @@ static void vavs_prot_init(void)
 	WRITE_VREG(DOS_SW_RESET0, 0);
 
 #else
-	WRITE_MPEG_REG(RESET0_REGISTER,
+	WRITE_RESET_REG(RESET0_REGISTER,
 				   RESET_IQIDCT | RESET_MC | RESET_VLD_PART);
-	READ_MPEG_REG(RESET0_REGISTER);
-	WRITE_MPEG_REG(RESET0_REGISTER,
+	READ_RESET_REG(RESET0_REGISTER);
+	WRITE_RESET_REG(RESET0_REGISTER,
 				   RESET_IQIDCT | RESET_MC | RESET_VLD_PART);
 
-	WRITE_MPEG_REG(RESET2_REGISTER, RESET_PIC_DC | RESET_DBLK);
+	WRITE_RESET_REG(RESET2_REGISTER, RESET_PIC_DC | RESET_DBLK);
 #endif
 
 	/***************** reset vld   **********************************/
@@ -861,7 +999,7 @@ static void vavs_prot_init(void)
 	WRITE_VREG_BITS(VLD_MEM_VIFIFO_CONTROL,	8, MEM_LEVEL_CNT_BIT, 6);
 	/*************************************************************/
 
-	vavs_canvas_init();
+	r = vavs_canvas_init();
 	if (firmware_sel == 0)
 		WRITE_VREG(AV_SCRATCH_5, 0);
 #ifdef NV21
@@ -932,9 +1070,16 @@ static void vavs_prot_init(void)
 		WRITE_VREG(LONG_CABAC_SRC_ADDR, 0);
 	}
 #endif
+
+#ifdef ENABLE_USER_DATA
+	WRITE_VREG(AV_SCRATCH_N, (u32)(user_data_buffer_phys - buf_offset));
+	pr_info("AV_SCRATCH_N = 0x%x\n", READ_VREG(AV_SCRATCH_N));
+#endif
+
+	return r;
 }
 
-#if 0
+#if 0 //DEBUG_TMP
 #ifdef AVSP_LONG_CABAC
 static unsigned char es_write_addr[MAX_CODED_FRAME_SIZE]  __aligned(64);
 #endif
@@ -973,6 +1118,18 @@ static void vavs_local_init(void)
 		vfbuf_use[i] = 0;
 
 	cur_vfpool = vfpool;
+	if (mm_blk_handle) {
+		decoder_bmmu_box_free(mm_blk_handle);
+		mm_blk_handle = NULL;
+	}
+
+	mm_blk_handle = decoder_bmmu_box_alloc_box(
+		DRIVER_NAME,
+		0,
+		MAX_BMMU_BUFFER_NUM,
+		4 + PAGE_SHIFT,
+		CODEC_MM_FLAGS_CMA_CLEAR |
+		CODEC_MM_FLAGS_FOR_VDECODER);
 
 }
 
@@ -1019,9 +1176,51 @@ static void vavs_local_reset(void)
 		READ_VREG(VLD_MEM_VIFIFO_RP),
 		READ_VREG(VLD_MEM_VIFIFO_LEVEL));
 #endif
+
+#ifdef ENABLE_USER_DATA
+	reset_userdata_fifo(1);
+#endif
+
 	mutex_unlock(&vavs_mutex);
 }
 
+static struct work_struct fatal_error_wd_work;
+static struct work_struct notify_work;
+static atomic_t error_handler_run = ATOMIC_INIT(0);
+static void vavs_fatal_error_handler(struct work_struct *work)
+{
+	if (debug_flag & AVS_DEBUG_OLD_ERROR_HANDLE) {
+		mutex_lock(&vavs_mutex);
+		pr_info("vavs fatal error reset !\n");
+		amvdec_stop();
+#ifdef CONFIG_AMLOGIC_POST_PROCESS_MANAGER
+		vavs_ppmgr_reset();
+#else
+		vf_light_unreg_provider(&vavs_vf_prov);
+		vavs_local_init();
+		vf_reg_provider(&vavs_vf_prov);
+#endif
+		vavs_recover();
+		amvdec_start();
+		mutex_unlock(&vavs_mutex);
+	} else {
+		vavs_local_reset();
+	}
+	atomic_set(&error_handler_run, 0);
+}
+
+static void vavs_notify_work(struct work_struct *work)
+{
+	pr_info("frame duration changed %d\n", frame_dur);
+	if (fr_hint_status == VDEC_NEED_HINT) {
+		vf_notify_receiver(PROVIDER_NAME ,
+			VFRAME_EVENT_PROVIDER_FR_HINT ,
+			(void *)((unsigned long)frame_dur));
+		fr_hint_status = VDEC_HINTED;
+	}
+	return;
+}
+
 static void vavs_put_timer_func(unsigned long arg)
 {
 	struct timer_list *timer = (struct timer_list *)arg;
@@ -1032,6 +1231,7 @@ static void vavs_put_timer_func(unsigned long arg)
 
 	if (READ_VREG(AVS_SOS_COUNT)) {
 		if (!error_recovery_mode) {
+#if 0
 			if (debug_flag & AVS_DEBUG_OLD_ERROR_HANDLE) {
 				mutex_lock(&vavs_mutex);
 				pr_info("vavs fatal error reset !\n");
@@ -1049,6 +1249,12 @@ static void vavs_put_timer_func(unsigned long arg)
 			} else {
 				vavs_local_reset();
 			}
+#else
+			if (!atomic_read(&error_handler_run)) {
+				atomic_set(&error_handler_run, 1);
+				schedule_work(&fatal_error_wd_work);
+			}
+#endif
 		}
 	}
 #if 0
@@ -1227,11 +1433,11 @@ static void init_avsp_long_cabac_buf(void)
 #endif
 }
 #endif
-#endif
+#endif //DEBUG_TMP
 
 static s32 vavs_init(void)
 {
-	int size = -1;
+	int r, size = -1;
 	char *buf = vmalloc(0x1000 * 16);
 	if (IS_ERR_OR_NULL(buf))
 		return -ENOMEM;
@@ -1263,7 +1469,9 @@ static s32 vavs_init(void)
 	stat |= STAT_MC_LOAD;
 
 	/* enable AMRISC side protocol */
-	vavs_prot_init();
+	r = vavs_prot_init();
+	if (r < 0)
+		return r;
 
 #ifdef HANDLE_AVS_IRQ
 	if (vdec_request_irq(VDEC_IRQ_1, vavs_isr,
@@ -1285,9 +1493,14 @@ static s32 vavs_init(void)
 	vf_reg_provider(&vavs_vf_prov);
 #endif
 
-	vf_notify_receiver(PROVIDER_NAME, VFRAME_EVENT_PROVIDER_FR_HINT,
+	if (vavs_amstream_dec_info.rate != 0) {
+		vf_notify_receiver(PROVIDER_NAME,
+						VFRAME_EVENT_PROVIDER_FR_HINT,
 					   (void *)((unsigned long)
 					   vavs_amstream_dec_info.rate));
+		fr_hint_status = VDEC_HINTED;
+	} else
+		fr_hint_status = VDEC_NEED_HINT;
 
 	stat |= STAT_VF_HOOK;
 
@@ -1327,29 +1540,11 @@ static int amvdec_avs_probe(struct platform_device *pdev)
 		canvas_base = 0;
 		canvas_num = 3;
 	} else {
-		/*if(vf_buf_num <= 4)
-			canvas_base = 0;
-		else */
+
 		canvas_base = 128;
 		canvas_num = 2; /*NV21*/
 	}
 
-#ifdef AVSP_LONG_CABAC
-	buf_start = pdata->mem_start;
-	buf_size = pdata->mem_end - pdata->mem_start + 1
-		- (MAX_CODED_FRAME_SIZE * 2)
-		- LOCAL_HEAP_SIZE;
-	avsp_heap_adr = codec_mm_phys_to_virt(
-		pdata->mem_start + buf_size);
-#else
-	buf_start = pdata->mem_start;
-	buf_size = pdata->mem_end - pdata->mem_start + 1;
-#endif
-
-	if (buf_start > ORI_BUFFER_START_ADDR)
-		buf_offset = buf_start - ORI_BUFFER_START_ADDR;
-	else
-		buf_offset = buf_start;
 
 	if (pdata->sys_info)
 		vavs_amstream_dec_info = *pdata->sys_info;
@@ -1359,17 +1554,47 @@ static int amvdec_avs_probe(struct platform_device *pdev)
 
 	pdata->dec_status = vavs_dec_status;
 
+	vavs_vdec_info_init();
+
+#ifdef ENABLE_USER_DATA
+	if (NULL == user_data_buffer) {
+		user_data_buffer =
+			dma_alloc_coherent(amports_get_dma_device(),
+				USER_DATA_SIZE,
+				&user_data_buffer_phys, GFP_KERNEL);
+		if (!user_data_buffer) {
+			pr_info("%s: Can not allocate user_data_buffer\n",
+				   __func__);
+			return -ENOMEM;
+		}
+		pr_info("user_data_buffer = 0x%p, user_data_buffer_phys = 0x%x\n",
+			user_data_buffer, (u32)user_data_buffer_phys);
+	}
+#endif
 	if (vavs_init() < 0) {
 		pr_info("amvdec_avs init failed.\n");
+		kfree(gvs);
+		gvs = NULL;
 
 		return -ENODEV;
 	}
-
+	INIT_WORK(&fatal_error_wd_work, vavs_fatal_error_handler);
+	atomic_set(&error_handler_run, 0);
+#ifdef ENABLE_USER_DATA
+	INIT_WORK(&userdata_push_work, userdata_push_do_work);
+#endif
+	INIT_WORK(&notify_work, vavs_notify_work);
 	return 0;
 }
 
 static int amvdec_avs_remove(struct platform_device *pdev)
 {
+	cancel_work_sync(&fatal_error_wd_work);
+	atomic_set(&error_handler_run, 0);
+#ifdef ENABLE_USER_DATA
+	cancel_work_sync(&userdata_push_work);
+#endif
+	cancel_work_sync(&notify_work);
 	if (stat & STAT_VDEC_RUN) {
 		amvdec_stop();
 		stat &= ~STAT_VDEC_RUN;
@@ -1421,22 +1646,40 @@ static int amvdec_avs_remove(struct platform_device *pdev)
 	}
 #endif
 	if (stat & STAT_VF_HOOK) {
-		vf_notify_receiver(PROVIDER_NAME,
+		if (fr_hint_status == VDEC_HINTED)
+			vf_notify_receiver(PROVIDER_NAME,
 				VFRAME_EVENT_PROVIDER_FR_END_HINT, NULL);
-
+		fr_hint_status = VDEC_NO_NEED_HINT;
 		vf_unreg_provider(&vavs_vf_prov);
 		stat &= ~STAT_VF_HOOK;
 	}
 
+#ifdef ENABLE_USER_DATA
+	if (user_data_buffer != NULL) {
+		dma_free_coherent(
+			amports_get_dma_device(),
+			USER_DATA_SIZE,
+			user_data_buffer,
+			user_data_buffer_phys);
+		user_data_buffer = NULL;
+		user_data_buffer_phys = 0;
+	}
+#endif
 	amvdec_disable();
 
 	pic_type = 0;
+	if (mm_blk_handle) {
+		decoder_bmmu_box_free(mm_blk_handle);
+		mm_blk_handle = NULL;
+	}
 #ifdef DEBUG_PTS
 	pr_info("pts hit %d, pts missed %d, i hit %d, missed %d\n", pts_hit,
 		   pts_missed, pts_i_hit, pts_i_missed);
 	pr_info("total frame %d, avi_flag %d, rate %d\n", total_frame, avi_flag,
 		   vavs_amstream_dec_info.rate);
 #endif
+	kfree(gvs);
+	gvs = NULL;
 
 	return 0;
 }
@@ -1456,6 +1699,20 @@ static struct codec_profile_t amvdec_avs_profile = {
 	.profile = ""
 };
 
+static struct mconfig avs_configs[] = {
+	MC_PU32("stat", &stat),
+	MC_PU32("debug_flag", &debug_flag),
+	MC_PU32("error_recovery_mode", &error_recovery_mode),
+	MC_PU32("pic_type", &pic_type),
+	MC_PU32("radr", &radr),
+	MC_PU32("vf_buf_num", &vf_buf_num),
+	MC_PU32("vf_buf_num_used", &vf_buf_num_used),
+	MC_PU32("canvas_base", &canvas_base),
+	MC_PU32("firmware_sel", &firmware_sel),
+};
+static struct mconfig_node avs_node;
+
+
 static int __init amvdec_avs_driver_init_module(void)
 {
 	pr_debug("amvdec_avs module init\n");
@@ -1469,7 +1726,8 @@ static int __init amvdec_avs_driver_init_module(void)
 		amvdec_avs_profile.profile = "avs+";
 
 	vcodec_profile_register(&amvdec_avs_profile);
-
+	INIT_REG_NODE_CONFIGS("media.decoder", &avs_node,
+		"avs", avs_configs, CONFIG_FOR_RW);
 	return 0;
 }
 
@@ -1526,8 +1784,6 @@ MODULE_PARM_DESC(vf_buf_num_used, "\nvf_buf_num_used\n");
 module_param(canvas_base, uint, 0664);
 MODULE_PARM_DESC(canvas_base, "\ncanvas_base\n");
 
-module_param(work_buf_size, uint, 0664);
-MODULE_PARM_DESC(work_buf_size, "\nwork_buf_size\n");
 
 module_param(firmware_sel, uint, 0664);
 MODULE_PARM_DESC(firmware_sel, "\firmware_sel\n");
diff --git a/drivers/frame_provider/decoder/avs/avsp_trans.c b/drivers/frame_provider/decoder/avs/avsp_trans.c
index 3c7f3ab..c0a2d0e 100644
--- a/drivers/frame_provider/decoder/avs/avsp_trans.c
+++ b/drivers/frame_provider/decoder/avs/avsp_trans.c
@@ -877,13 +877,13 @@ void push_es(int value, int num)
 	}
 }
 
-#define MIN_QP          0
-#define MAX_QP          63
-
 #ifdef BLOCK_SIZE
 #undef BLOCK_SIZE
 #endif
 
+#define MIN_QP          0
+#define MAX_QP          63
+
 #define BLOCK_SIZE      4
 #define B8_SIZE         8
 #define MB_BLOCK_SIZE   16
@@ -1275,8 +1275,8 @@ struct macroblock {
 
 	struct macroblock *mb_available_up;
 	struct macroblock *mb_available_left;
-	int mbaddr_a, mbaddr_b, mbaddr_c, mbaddr_d;
-	int mbavail_a, mbavail_b, mbavail_c, mbavail_d;
+	unsigned int mbaddr_a, mbaddr_b, mbaddr_c, mbaddr_d;
+	unsigned int mbavail_a, mbavail_b, mbavail_c, mbavail_d;
 
 };
 
@@ -2879,6 +2879,7 @@ struct bitstream_s *alloc_bitstream(void)
 	if (bitstream == NULL) {
 		io_printf(
 			"AllocBitstream: Memory allocation for Bitstream failed");
+		return NULL;
 	}
 	bitstream->stream_buffer = (unsigned char *)local_alloc(
 			MAX_CODED_FRAME_SIZE,
@@ -2886,6 +2887,7 @@ struct bitstream_s *alloc_bitstream(void)
 	if (bitstream->stream_buffer == NULL) {
 		io_printf(
 				"AllocBitstream: Memory allocation for streamBuffer failed");
+		return NULL;
 	}
 
 	return bitstream;
@@ -3012,6 +3014,7 @@ struct datapartition *alloc_partition(int n)
 	if (part_arr == NULL) {
 		no_mem_exit(
 				"alloc_partition: Memory allocation for Data Partition failed");
+		return NULL;
 	}
 
 #if LIWR_FIX
@@ -3024,27 +3027,35 @@ struct datapartition *alloc_partition(int n)
 		if (datapart->bitstream == NULL) {
 			no_mem_exit(
 					"alloc_partition: Memory allocation for Bitstream failed");
+			return NULL;
 		}
 	}
 #endif
 	return part_arr;
 }
 
-void malloc_slice(struct img_par *img)
+int malloc_slice(struct img_par *img)
 {
 	struct slice_s *currslice;
 
 	img->current_slice =
 	(struct slice_s *)local_alloc(1, sizeof(struct slice_s));
 	currslice = img->current_slice;
-	if (currslice == NULL)
+	if (currslice == NULL) {
 		no_mem_exit(
 			"Memory allocation for struct slice_s datastruct Failed"
 			);
+		return 0;
+	}
 	if (1) {
 
 		currslice->mot_ctx = create_contexts_motioninfo();
+		if (currslice->mot_ctx == NULL)
+			return 0;
+
 		currslice->tex_ctx = create_contexts_textureinfo();
+		if (currslice->tex_ctx == NULL)
+			return 0;
 	}
 #if LIWR_FIX
 	currslice->max_part_nr = 1;
@@ -3052,6 +3063,9 @@ void malloc_slice(struct img_par *img)
 	currslice->max_part_nr = 3;
 #endif
 	currslice->part_arr = alloc_partition(currslice->max_part_nr);
+	if (currslice->part_arr == NULL)
+		return 0;
+	return 1;
 }
 
 void init(struct img_par *img)
@@ -3077,11 +3091,15 @@ int get_mem2Dint(int ***array2D, int rows, int columns)
 	int i;
 
 	*array2D = (int **)local_alloc(rows, sizeof(int *));
-	if (*array2D == NULL)
+	if (*array2D == NULL) {
 		no_mem_exit("get_mem2Dint: array2D");
+		return -1;
+	}
 	(*array2D)[0] = (int *)local_alloc(rows * columns, sizeof(int));
-	if ((*array2D)[0] == NULL)
+	if ((*array2D)[0] == NULL) {
 		no_mem_exit("get_mem2Dint: array2D");
+		return -1;
+	}
 
 	for (i = 1; i < rows; i++)
 		(*array2D)[i] = (*array2D)[i - 1] + columns;
@@ -3089,28 +3107,45 @@ int get_mem2Dint(int ***array2D, int rows, int columns)
 	return rows * columns * sizeof(int);
 }
 
-void initial_decode(void)
+int initial_decode(void)
 {
 	int i, j;
+	int ret;
 	int img_height = (vertical_size + img->auto_crop_bottom);
 	int memory_size = 0;
 
-	malloc_slice(img);
+	ret = malloc_slice(img);
+	if (ret == 0)
+		return 0;
+
 	mb_data = (struct macroblock *)local_alloc(
 			(img->width / MB_BLOCK_SIZE)
 			* (img_height /*vertical_size*/
 			/ MB_BLOCK_SIZE), sizeof(struct macroblock));
-	if (mb_data == NULL)
+	if (mb_data == NULL) {
 		no_mem_exit("init_global_buffers: mb_data");
+		return 0;
+	}
 
-	if (progressive_sequence)
-		memory_size += get_mem2Dint(&(img->ipredmode),
+	if (progressive_sequence) {
+		int size;
+		size = get_mem2Dint(&(img->ipredmode),
 				img->width / B8_SIZE * 2 + 4,
 				vertical_size / B8_SIZE * 2 + 4);
-	else
-		memory_size += get_mem2Dint(&(img->ipredmode),
+		if (size == -1)
+			return 0;
+
+		memory_size += size;
+	} else {
+		int size;
+		size = get_mem2Dint(&(img->ipredmode),
 				img->width / B8_SIZE * 2 + 4,
 				(vertical_size + 32) / (2 * B8_SIZE) * 4 + 4);
+		if (size == -1)
+			return 0;
+
+		memory_size += size;
+	}
 
 	for (i = 0; i < img->width / (B8_SIZE) * 2 + 4; i++) {
 		for (j = 0; j < img->height / (B8_SIZE) * 2 + 4; j++)
@@ -3126,6 +3161,7 @@ void initial_decode(void)
 	img->new_seq_header_flag = 1;
 	img->new_sequence_flag = 1;
 
+	return 1;
 }
 
 void aec_new_slice(void)
@@ -4760,6 +4796,7 @@ void main(void)
 	int current_header;
 	int i;
 	int tmp;
+	int ret;
 
 	int byte_startposition;
 	int aec_mb_stuffing_bit;
@@ -4768,20 +4805,34 @@ void main(void)
 	pr_info("enter %s\r\n", __func__);
 #endif
 	transcoding_error_flag = 0;
+	ret = 0;
 	es_buf = es_write_addr_virt;
 
-	if (local_heap_init(MAX_CODED_FRAME_SIZE * 4) < 0)
-		return -1;
+	if (local_heap_init(MAX_CODED_FRAME_SIZE * 4) < 0) {
+		ret = -1;
+		goto End;
+	}
 
 	img = (struct img_par *)local_alloc(1, sizeof(struct img_par));
-	if (img	== NULL)
+	if (img	== NULL) {
 		no_mem_exit("main: img");
+		ret = -1;
+		goto End;
+	}
 	stat_bits_ptr = (struct stat_bits *)local_alloc(1,
 			sizeof(struct stat_bits));
-	if (stat_bits_ptr == NULL)
+	if (stat_bits_ptr == NULL) {
 		no_mem_exit("main: stat_bits");
+		ret = -1;
+		goto End;
+	}
 
 	curr_stream = alloc_bitstream();
+	if (curr_stream == NULL) {
+		io_printf("alloc bitstream failed\n");
+		ret = -1;
+		goto End;
+	}
 
 	chroma_format = 1;
 	demulate_enable = 0;
@@ -4801,6 +4852,12 @@ void main(void)
 	data32 = READ_VREG(LONG_CABAC_PIC_SIZE);
 	horizontal_size = (data32 >> 0) & 0xffff;
 	vertical_size = (data32 >> 16) & 0xffff;
+	if (horizontal_size * vertical_size > 1920 * 1080) {
+		io_printf("pic size check failed: width = %d, height = %d\n",
+			horizontal_size, vertical_size);
+		ret = -1;
+		goto End;
+	}
 
 	vld_mem_start_addr = READ_VREG(VLD_MEM_VIFIFO_START_PTR);
 	vld_mem_end_addr = READ_VREG(VLD_MEM_VIFIFO_END_PTR);
@@ -4872,7 +4929,12 @@ void main(void)
 
 	open_irabs(p_irabs);
 
-	initial_decode();
+
+	if (initial_decode() == 0) {
+		io_printf("initial_decode failed\n");
+		ret = -1;
+		goto End;
+	}
 
 	init_es();
 
@@ -4929,16 +4991,19 @@ void main(void)
 
 		wmb(); /**/
 #endif
-		WRITE_VREG(LONG_CABAC_REQ, 0);
 	}
 #else
 	fclose(f_es);
 #endif
 
+End:
+#ifdef AVSP_LONG_CABAC
+	WRITE_VREG(LONG_CABAC_REQ, 0);
+#endif
 	local_heap_uninit();
 #ifdef PERFORMANCE_DEBUG
 	pr_info("exit %s\r\n", __func__);
 #endif
-	return (transcoding_error_flag == 0) ? 0 : -1;
+	return ret;
 }
 #endif
diff --git a/drivers/frame_provider/decoder/h264/vh264.c b/drivers/frame_provider/decoder/h264/vh264.c
index 732ee5b..70713db 100644
--- a/drivers/frame_provider/decoder/h264/vh264.c
+++ b/drivers/frame_provider/decoder/h264/vh264.c
@@ -37,18 +37,20 @@
 #include <linux/slab.h>
 #include "../../../stream_input/amports/amports_priv.h"
 #include <linux/amlogic/media/canvas/canvas.h>
-#include <linux/amlogic/media/codec_mm/codec_mm.h>
 
 #include "../utils/vdec.h"
 #include <linux/amlogic/media/utils/vdec_reg.h>
 #include "../utils/amvdec.h"
-#include "../utils/decoder_bmmu_box.h"
 #include "vh264.h"
 #include "../../../stream_input/parser/streambuf.h"
 #include <linux/delay.h>
 #include <linux/amlogic/media/video_sink/video.h>
 
 #include <linux/amlogic/media/ge2d/ge2d.h>
+#include "../utils/decoder_mmu_box.h"
+#include "../utils/decoder_bmmu_box.h"
+#include <linux/amlogic/media/codec_mm/codec_mm.h>
+#include <linux/amlogic/media/codec_mm/configs.h>
 
 #define DRIVER_NAME "amvdec_h264"
 #define MODULE_NAME "amvdec_h264"
@@ -74,11 +76,6 @@ static inline bool close_to(int a, int b, int m)
 }
 
 static DEFINE_MUTEX(vh264_mutex);
-/* 12M for L41 */
-#define MAX_DPB_BUFF_SIZE       (12*1024*1024)
-#define DEFAULT_MEM_SIZE        (32*1024*1024)
-#define AVIL_DPB_BUFF_SIZE      0x01ec2000
-
 #define DEF_BUF_START_ADDR            0x1000000
 #define V_BUF_ADDR_OFFSET_NEW         (0x1ee000)
 #define V_BUF_ADDR_OFFSET             (0x13e000)
@@ -96,6 +93,7 @@ static DEFINE_MUTEX(vh264_mutex);
 
 #define VF_POOL_SIZE        64
 #define VF_BUF_NUM          24
+#define WORKSPACE_BUF_NUM	2
 #define PUT_INTERVAL        (HZ/100)
 #define NO_DISP_WD_COUNT    (3 * HZ / PUT_INTERVAL)
 
@@ -148,7 +146,7 @@ static int vh264_vf_states(struct vframe_states *states, void *);
 static int vh264_event_cb(int type, void *data, void *private_data);
 
 static void vh264_prot_init(void);
-static void vh264_local_init(void);
+static int vh264_local_init(void);
 static void vh264_put_timer_func(unsigned long arg);
 static void stream_switching_done(void);
 
@@ -167,7 +165,6 @@ static const struct vframe_operations_s vh264_vf_provider_ops = {
 static struct vframe_provider_s vh264_vf_prov;
 /*TODO irq*/
 #if 1
-static u32 frame_buffer_size;
 static u32 frame_width, frame_height, frame_dur, frame_prog, frame_packing_type,
 	   last_duration;
 static u32 saved_resolution;
@@ -187,16 +184,18 @@ static struct vframe_s vfpool[VF_POOL_SIZE];
 static s32 vfbuf_use[VF_BUF_NUM];
 static struct buffer_spec_s buffer_spec[VF_BUF_NUM];
 static struct buffer_spec_s fense_buffer_spec[2];
-#define MAX_BLK_BUFFERS (VF_BUF_NUM + 3)
-#define FENSE_BUFFER_IDX(n) (VF_BUF_NUM + n)
+/* disp buf + keep buf+ fense buf + workspace  */
+
+#define MAX_BLK_BUFFERS (VF_BUF_NUM + 2 + WORKSPACE_BUF_NUM)
+#define VF_BUFFER_IDX(n) (WORKSPACE_BUF_NUM  + n)
+#define FENSE_BUFFER_IDX(n) (WORKSPACE_BUF_NUM + VF_BUF_NUM + n)
+
+#define USER_DATA_RUND_SIZE		(USER_DATA_SIZE + 4096)
 static struct vframe_s fense_vf[2];
 
 static struct timer_list recycle_timer;
 static u32 stat;
-static unsigned long buf_start, buf_end;
-static u32 buf_size;
 static s32 buf_offset;
-static u32 ucode_map_start;
 static u32 pts_outside;
 static u32 sync_outside;
 static u32 dec_control;
@@ -215,6 +214,7 @@ static u32 time_scale;
 static u32 h264_ar;
 static u32 decoder_debug_flag;
 static u32 dpb_size_adj = 6;
+static u32 fr_hint_status;
 
 #ifdef DROP_B_FRAME_FOR_1080P_50_60FPS
 static u32 last_interlaced;
@@ -243,6 +243,7 @@ static s32 vh264_eos;
 static struct vframe_s *p_last_vf;
 static s32 iponly_early_mode;
 static void *mm_blk_handle;
+static int tvp_flag;
 
 /*TODO irq*/
 #if 1
@@ -274,6 +275,11 @@ static int vh264_reset;
 static struct work_struct error_wd_work;
 static struct work_struct stream_switching_work;
 static struct work_struct set_parameter_work;
+static struct work_struct notify_work;
+
+static struct work_struct userdata_push_work;
+
+
 
 static struct dec_sysinfo vh264_amstream_dec_info;
 static dma_addr_t mc_dma_handle;
@@ -312,6 +318,8 @@ static bool pts_discontinue;
 
 static struct ge2d_context_s *ge2d_videoh264_context;
 
+static struct vdec_info *gvs;
+
 static int ge2d_videoh264task_init(void)
 {
 	if (ge2d_videoh264_context == NULL)
@@ -411,6 +419,16 @@ void spec_set_canvas(struct buffer_spec_s *spec,
 				  spec->u_addr,
 				  width, height / 2,
 				  CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_32X32);
+	return;
+}
+
+static void vh264_notify_work(struct work_struct *work)
+{
+	pr_info("frame duration changed %d\n", frame_dur);
+	vf_notify_receiver(PROVIDER_NAME, VFRAME_EVENT_PROVIDER_FR_HINT,
+		(void *)((unsigned long)frame_dur));
+
+	return;
 }
 
 static void prepare_display_q(void)
@@ -536,6 +554,227 @@ static tvin_trans_fmt_t convert_3d_format(u32 type)
 }
 #endif
 
+
+#ifdef DEBUG_CC_USER_DATA
+static int vbi_to_ascii(int c)
+{
+	if (c < 0)
+		return '?';
+
+	c &= 0x7F;
+
+	if (c < 0x20 || c >= 0x7F)
+		return '.';
+
+	return c;
+}
+
+static void dump_cc_ascii(const uint8_t *buf, int poc)
+{
+	int cc_flag;
+	int cc_count;
+	int i;
+	int szAscii[32];
+	int index = 0;
+
+	cc_flag = buf[1] & 0x40;
+	if (!cc_flag) {
+		pr_info("### cc_flag is invalid\n");
+		return;
+	}
+	cc_count = buf[1] & 0x1f;
+
+	for (i = 0; i < cc_count; ++i) {
+		unsigned int b0;
+		unsigned int cc_valid;
+		unsigned int cc_type;
+		unsigned char cc_data1;
+		unsigned char cc_data2;
+
+		b0 = buf[3 + i * 3];
+		cc_valid = b0 & 4;
+		cc_type = b0 & 3;
+		cc_data1 = buf[4 + i * 3];
+		cc_data2 = buf[5 + i * 3];
+
+
+		if (cc_type == 0) {
+			/* NTSC pair, Line 21 */
+			szAscii[index++] = vbi_to_ascii(cc_data1);
+			szAscii[index++] = vbi_to_ascii(cc_data2);
+			if ((!cc_valid) || (i >= 3))
+				break;
+		}
+	}
+	switch (index) {
+	case 8:
+		pr_info("push poc:%d : %c %c %c %c %c %c %c %c\n",
+			poc,
+			szAscii[0], szAscii[1], szAscii[2], szAscii[3],
+			szAscii[4], szAscii[5], szAscii[6], szAscii[7]);
+		break;
+	case 7:
+		pr_info("push poc:%d : %c %c %c %c %c %c %c\n",
+			poc,
+			szAscii[0], szAscii[1], szAscii[2], szAscii[3],
+			szAscii[4], szAscii[5], szAscii[6]);
+		break;
+	case 6:
+		pr_info("push poc:%d : %c %c %c %c %c %c\n", poc,
+			szAscii[0], szAscii[1], szAscii[2], szAscii[3],
+			szAscii[4], szAscii[5]);
+		break;
+	case 5:
+		pr_info("push poc:%d : %c %c %c %c %c\n", poc,
+			szAscii[0], szAscii[1], szAscii[2], szAscii[3],
+			szAscii[4]);
+		break;
+	case 4:
+		pr_info("push poc:%d : %c %c %c %c\n", poc,
+			szAscii[0], szAscii[1], szAscii[2], szAscii[3]);
+		break;
+	case 3:
+		pr_info("push poc:%d : %c %c %c\n", poc,
+			szAscii[0], szAscii[1], szAscii[2]);
+		break;
+	case 2:
+		pr_info("push poc:%d : %c %c\n", poc,
+			szAscii[0], szAscii[1]);
+		break;
+	case 1:
+		pr_info("push poc:%d : %c\n", poc, szAscii[0]);
+		break;
+	default:
+		pr_info("push poc:%d and no CC data: index = %d\n",
+			poc, index);
+		break;
+	}
+}
+
+/*
+#define DUMP_USER_DATA_HEX
+*/
+
+#ifdef DUMP_USER_DATA_HEX
+static void print_data(unsigned char *pdata, int len)
+{
+	int nLeft;
+
+	nLeft = len;
+
+	while (nLeft >= 8) {
+		pr_info("%02x %02x %02x %02x %02x %02x %02x %02x\n",
+			pdata[0], pdata[1], pdata[2], pdata[3],
+			pdata[4], pdata[5], pdata[6], pdata[7]);
+		nLeft -= 8;
+		pdata += 8;
+	}
+}
+#endif
+
+static void aml_swap_data(uint8_t *user_data, int ud_size)
+{
+	int swap_blocks, i, j, k, m;
+	unsigned char c_temp;
+
+	/* swap byte order */
+	swap_blocks = ud_size / 8;
+	for (i = 0; i < swap_blocks; i++) {
+		j = i * 8;
+		k = j + 7;
+		for (m = 0; m < 4; m++) {
+			c_temp = user_data[j];
+			user_data[j++] = user_data[k];
+			user_data[k--] = c_temp;
+		}
+	}
+}
+
+static void dump_data(unsigned int user_data_wp,
+						unsigned int user_data_length,
+						int poc)
+{
+	unsigned char *pdata;
+	int user_data_len;
+	int wp_start;
+	int nLeft;
+	unsigned char szBuf[256];
+	int nOffset;
+
+	dma_sync_single_for_cpu(amports_get_dma_device(),
+			sei_data_buffer_phys, USER_DATA_SIZE,
+			DMA_FROM_DEVICE);
+
+	if (user_data_length & 0x07)
+		user_data_len = (user_data_length + 8) & 0xFFFFFFF8;
+	else
+		user_data_len = user_data_length;
+
+	if (user_data_wp >= user_data_len) {
+		wp_start = user_data_wp - user_data_len;
+
+		pdata = (unsigned char *)sei_data_buffer;
+		pdata += wp_start;
+		nLeft = user_data_len;
+
+		memset(szBuf, 0, 256);
+		memcpy(szBuf, pdata, user_data_len);
+	} else {
+		wp_start = user_data_wp +
+			USER_DATA_SIZE - user_data_len;
+
+		pdata = (unsigned char *)sei_data_buffer;
+		pdata += wp_start;
+		nLeft = USER_DATA_SIZE - wp_start;
+
+		memset(szBuf, 0, 256);
+		memcpy(szBuf, pdata, nLeft);
+		nOffset = nLeft;
+
+		pdata = (unsigned char *)sei_data_buffer;
+		nLeft = user_data_wp;
+		memcpy(szBuf+nOffset, pdata, nLeft);
+	}
+
+	aml_swap_data(szBuf, user_data_len);
+#ifdef DUMP_USER_DATA_HEX
+	print_data(szBuf, user_data_len);
+#endif
+	dump_cc_ascii(szBuf+7, poc);
+}
+#endif
+
+
+static void userdata_push_do_work(struct work_struct *work)
+{
+	unsigned int sei_itu35_flags;
+	unsigned int sei_itu35_wp;
+	unsigned int sei_itu35_data_length;
+	struct userdata_poc_info_t user_data_poc;
+
+	sei_itu35_flags = READ_VREG(AV_SCRATCH_J);
+	sei_itu35_wp = (sei_itu35_flags >> 16) & 0xffff;
+	sei_itu35_data_length = sei_itu35_flags & 0x7fff;
+
+#if 0
+	pr_info("pocinfo 0x%x, top poc %d, wp 0x%x, length %d\n",
+				   READ_VREG(AV_SCRATCH_L),
+				   READ_VREG(AV_SCRATCH_M),
+				   sei_itu35_wp, sei_itu35_data_length);
+#endif
+	user_data_poc.poc_info = READ_VREG(AV_SCRATCH_L);
+	user_data_poc.poc_number = READ_VREG(AV_SCRATCH_M);
+#ifdef DEBUG_CC_USER_DATA
+	dump_data(sei_itu35_wp, sei_itu35_data_length,
+		user_data_poc.poc_number);
+#endif
+	WRITE_VREG(AV_SCRATCH_J, 0);
+	wakeup_userdata_poll(user_data_poc, sei_itu35_wp,
+					(unsigned long)sei_data_buffer,
+					USER_DATA_SIZE, sei_itu35_data_length);
+}
+
+
 static void set_frame_info(struct vframe_s *vf)
 {
 	vf->width = frame_width;
@@ -642,15 +881,12 @@ static void vh264_set_params(struct work_struct *work)
 {
 	int aspect_ratio_info_present_flag, aspect_ratio_idc;
 	int max_dpb_size, actual_dpb_size, max_reference_size;
-	int i, mb_mv_byte, start_addr;
+	int i, mb_mv_byte, ret;
 	unsigned long addr;
-	unsigned int post_canvas;
+	unsigned int post_canvas, buf_size;
 	unsigned int frame_mbs_only_flag;
 	unsigned int chroma_format_idc, chroma444, video_signal;
 	unsigned int crop_infor, crop_bottom, crop_right, level_idc;
-	u32 disp_addr = 0xffffffff;
-	struct canvas_s cur_canvas;
-
 	if (!atomic_read(&vh264_active))
 		return;
 	mutex_lock(&vh264_mutex);
@@ -776,82 +1012,44 @@ static void vh264_set_params(struct work_struct *work)
 	 /*max_reference_size <= max_dpb_size <= actual_dpb_size*/
 	 is_4k = (mb_total > 8160) ? true:false;
 
-	if (is_4k || dpb_size_adj) {
-		/*4k2k*/
-		if (get_cpu_type() >= MESON_CPU_MAJOR_ID_GXTVBB) {
-			max_dpb_size = get_max_dpb_size(
-					level_idc, mb_width, mb_height);
-			actual_dpb_size = max_dpb_size + 5;
-			if (dpb_size_adj)
+
+	max_dpb_size = get_max_dpb_size(level_idc, mb_width, mb_height);
+	if (max_dpb_size < max_reference_size)
+		max_dpb_size = max_reference_size;
+	if (max_dpb_size > 15
+		&& get_cpu_type() >= MESON_CPU_MAJOR_ID_GXTVBB
+		&& (codec_mm_get_total_size() < 80 * SZ_1M)) {
 				actual_dpb_size
 				= max_reference_size + dpb_size_adj;
 			if (actual_dpb_size > VF_BUF_NUM)
 				actual_dpb_size = VF_BUF_NUM;
-			pr_info
-			("actual_dpb_size %d max_ref_size %d\n",
-			actual_dpb_size, max_reference_size);
-		} else {
-			vh264_running = 0;
-			fatal_error_flag =
-			DECODER_FATAL_ERROR_SIZE_OVERFLOW;
-			mutex_unlock(&vh264_mutex);
-			pr_err("oversize ! mb_total %d,\n", mb_total);
-			return;
-		}
 	} else {
-		actual_dpb_size = (frame_buffer_size - mb_total * mb_mv_byte *
-				max_reference_size) / (mb_total * 384);
+		actual_dpb_size = max_dpb_size + dpb_size_adj;
 		actual_dpb_size = min(actual_dpb_size, VF_BUF_NUM);
-		max_dpb_size = get_max_dpb_size(level_idc, mb_width, mb_height);
-		if (max_reference_size > 1)
-			max_dpb_size = max_reference_size - 1;
-		else
-			max_dpb_size = max_reference_size;
-		if (actual_dpb_size < (max_dpb_size + 4)) {
-			actual_dpb_size = max_dpb_size + 4;
-			if (actual_dpb_size > VF_BUF_NUM)
-				actual_dpb_size = VF_BUF_NUM;
-		}
-		 pr_info("actual_dpb_size %d max_dpb_size %d\n",
-				 actual_dpb_size, max_dpb_size);
 	}
-	if (max_dpb_size == 0)
-		max_dpb_size = actual_dpb_size;
-	else
-	   max_dpb_size = min(max_dpb_size, actual_dpb_size);
-	max_reference_size = min(max_reference_size, actual_dpb_size-1);
-	max_dpb_size = max(max_reference_size, max_dpb_size);
 	max_reference_size++;
+	pr_info("actual_dpb_size %d max_dpb_size %d max_ref %d\n",
+				actual_dpb_size, max_dpb_size,
+				max_reference_size);
+	buf_size = mb_total * mb_mv_byte * max_reference_size;
 
-	start_addr = addr = buf_start;
-	if (is_4k)
-		addr += ((mb_total << 8) + (mb_total << 7));/*keep last frame */
-	WRITE_VREG(AV_SCRATCH_1, addr);
-	WRITE_VREG(AV_SCRATCH_3, post_canvas);	/* should be modified later */
-	canvas_read((READ_VCBUS_REG(VD1_IF0_CANVAS0) & 0xff), &cur_canvas);
-	disp_addr = (cur_canvas.addr + 7) >> 3;
-	if ((addr + mb_total * mb_mv_byte * max_reference_size)
-		>= buf_end) {
+	ret = decoder_bmmu_box_alloc_buf_phy(mm_blk_handle, 1,
+		buf_size, DRIVER_NAME, &addr);
+
+	if (ret < 0) {
 		fatal_error_flag =
 			DECODER_FATAL_ERROR_NO_MEM;
 		vh264_running = 0;
 		mutex_unlock(&vh264_mutex);
-		pr_err("mv buf not enough!\n");
 		return;
 	}
-	addr += mb_total * mb_mv_byte * max_reference_size;
-	WRITE_VREG(AV_SCRATCH_4, addr);
-	if (!(READ_VREG(AV_SCRATCH_F) & 0x1)) {
-		bool use_alloc = is_4k ? true:false;
-		int alloc_count = 0;
 
+	WRITE_VREG(AV_SCRATCH_1, addr);
+	WRITE_VREG(AV_SCRATCH_3, post_canvas);
+	WRITE_VREG(AV_SCRATCH_4, addr + buf_size);
+
+	if (!(READ_VREG(AV_SCRATCH_F) & 0x1)) {
 		for (i = 0; i < actual_dpb_size; i++) {
-			if (((addr + (mb_total << 8) + (mb_total << 7))
-					>= buf_end) && (!use_alloc)) {
-				pr_info("start alloc for %d\n", i);
-				use_alloc = true;
-			}
-			if (use_alloc) {
 #ifdef DOUBLE_WRITE
 				int page_count =
 				PAGE_ALIGN((mb_total << 8) + (mb_total
@@ -862,44 +1060,24 @@ static void vh264_set_params(struct work_struct *work)
 					PAGE_ALIGN((mb_total << 8) +
 						(mb_total << 7)) / PAGE_SIZE;
 #endif
-				buffer_spec[i].alloc_count = page_count;
-				if (!decoder_bmmu_box_alloc_idx_wait(
-					mm_blk_handle,
-					i,
-					page_count << PAGE_SHIFT,
-					-1,
-					-1,
-					BMMU_ALLOC_FLAGS_WAITCLEAR
-					)) {
-					buffer_spec[i].phy_addr =
-						decoder_bmmu_box_get_phy_addr(
-							mm_blk_handle,
-							i);
-					pr_info("CMA malloc ok  %d\n", i);
-					alloc_count++;
-				} else {
-					buffer_spec[i].alloc_count = 0;
-					fatal_error_flag =
-					DECODER_FATAL_ERROR_NO_MEM;
-					vh264_running = 0;
-					mutex_unlock(&vh264_mutex);
-					pr_err("CMA  not enough mem! %d\n",
-						i);
-					return;
-				}
-				addr = buffer_spec[i].phy_addr;
-			} else {
-					if (buffer_spec[i].phy_addr) {
-						decoder_bmmu_box_free_idx(
-							mm_blk_handle,
-							i);
-						buffer_spec[i].phy_addr = 0;
-						buffer_spec[i].alloc_count = 0;
-					}
+
+			ret = decoder_bmmu_box_alloc_buf_phy(mm_blk_handle,
+				VF_BUFFER_IDX(i),
+				page_count << PAGE_SHIFT,
+				DRIVER_NAME, &buffer_spec[i].phy_addr);
+
+			if (ret < 0) {
+				buffer_spec[i].alloc_count = 0;
+				fatal_error_flag =
+				DECODER_FATAL_ERROR_NO_MEM;
+				vh264_running = 0;
+				mutex_unlock(&vh264_mutex);
+				return;
 			}
-			/*4k keep last frame */
-			if (is_4k && ((addr + 7) >> 3) == disp_addr)
-				addr = start_addr;
+
+			addr = buffer_spec[i].phy_addr;
+			buffer_spec[i].alloc_count = page_count;
+
 			if (i <= 21) {
 				buffer_spec[i].y_addr = addr;
 				addr += mb_total << 8;
@@ -957,8 +1135,14 @@ static void vh264_set_params(struct work_struct *work)
 					, spec2canvas(&buffer_spec[i]));
 			}
 		}
-	} else
-		addr = buf_start + mb_total * 384 * actual_dpb_size;
+		} else {
+			fatal_error_flag =
+					DECODER_FATAL_ERROR_NO_MEM;
+			vh264_running = 0;
+			mutex_unlock(&vh264_mutex);
+			pr_err("never be here!!\n");
+			return;
+		}
 
 	timing_info_present_flag = seq_info & 0x2;
 	fixed_frame_rate_flag = 0;
@@ -987,8 +1171,13 @@ static void vh264_set_params(struct work_struct *work)
 				  * frame rate but the system side information
 				   *is more reliable
 				   */
-				if ((frame_dur * 2) != frame_dur_es)
+				if ((frame_dur * 2) != frame_dur_es) {
 					frame_dur = frame_dur_es;
+					if (fr_hint_status == VDEC_NEED_HINT) {
+						schedule_work(&notify_work);
+						fr_hint_status = VDEC_HINTED;
+					}
+				}
 			}
 		}
 	} else
@@ -1453,6 +1642,9 @@ static void vh264_isr(void)
 				break;
 			}
 
+			if (error)
+				gvs->drop_frame_count++;
+
 			/* add 64bit pts us ; */
 			if (unlikely
 				((b_offset == first_offset)
@@ -1613,6 +1805,11 @@ static void vh264_isr(void)
 			 * force no VPTS discontinue reporting if we saw
 			 *errors earlier but only once.
 			 */
+
+			/*count info*/
+			gvs->frame_dur = frame_dur;
+			vdec_count_info(gvs, error, b_offset);
+
 			if ((pts_valid) && (check_pts_discontinue)
 					&& (!error)) {
 				if (pts_discontinue) {
@@ -1684,7 +1881,7 @@ static void vh264_isr(void)
 				vf->mem_handle =
 					decoder_bmmu_box_get_mem_handle(
 						mm_blk_handle,
-						buffer_index);
+						VF_BUFFER_IDX(buffer_index));
 				if ((error_recovery_mode_use & 2) && error) {
 					kfifo_put(&recycle_q,
 						(const struct vframe_s *)vf);
@@ -1734,7 +1931,7 @@ static void vh264_isr(void)
 				vf->mem_handle =
 					decoder_bmmu_box_get_mem_handle(
 						mm_blk_handle,
-						buffer_index);
+						VF_BUFFER_IDX(buffer_index));
 				if ((error_recovery_mode_use & 2) && error) {
 					kfifo_put(&recycle_q,
 						(const struct vframe_s *)vf);
@@ -1788,7 +1985,7 @@ static void vh264_isr(void)
 				vf->mem_handle =
 					decoder_bmmu_box_get_mem_handle(
 						mm_blk_handle,
-						buffer_index);
+						VF_BUFFER_IDX(buffer_index));
 				kfifo_put(&delay_display_q,
 						(const struct vframe_s *)vf);
 			}
@@ -1814,7 +2011,11 @@ static void vh264_isr(void)
 		vh264_running = 0;
 		fatal_error_flag = DECODER_FATAL_ERROR_UNKNOWN;
 		/* this is fatal error, need restart */
-		pr_info("fatal error happened\n");
+		pr_info("fatal error happend\n");
+		vh264_stream_switching_state = SWITCHING_STATE_ON_CMD3;
+		amvdec_stop();
+		pr_info("fatal error  switching mode cmd3.\n");
+			schedule_work(&stream_switching_work);
 		if (!fatal_error_reset)
 			schedule_work(&error_wd_work);
 	} else if ((cpu_cmd & 0xff) == 7) {
@@ -1868,7 +2069,7 @@ static void vh264_isr(void)
 			vf->type_original = vf->type;
 			vf->mem_handle = decoder_bmmu_box_get_mem_handle(
 					mm_blk_handle,
-					buffer_index);
+					VF_BUFFER_IDX(buffer_index));
 			vfbuf_use[buffer_index]++;
 			p_last_vf = vf;
 			pts_discontinue = false;
@@ -1880,46 +2081,7 @@ static void vh264_isr(void)
 
 	sei_itu35_flags = READ_VREG(AV_SCRATCH_J);
 	if (sei_itu35_flags & (1 << 15)) {	/* data ready */
-		/* int ltemp; */
-		/* unsigned char *daddr; */
-		unsigned int sei_itu35_wp = (sei_itu35_flags >> 16) & 0xffff;
-		unsigned int sei_itu35_data_length = sei_itu35_flags & 0x7fff;
-		struct userdata_poc_info_t user_data_poc;
-
-#if 0
-		/* dump lmem for debug */
-		WRITE_VREG(0x301, 0x8000);
-		WRITE_VREG(0x31d, 0x2);
-		for (ltemp = 0; ltemp < 64; ltemp++) {
-			laddr = 0x20 + ltemp;
-			WRITE_VREG(0x31b, laddr);
-			pr_info("mem 0x%x data 0x%x\n", laddr,
-				   READ_VREG(0x31c) & 0xffff);
-		}
-#endif
-#if 0
-		for (ltemp = 0; ltemp < sei_itu35_wp; ltemp++) {
-			daddr =
-				(unsigned char *)phys_to_virt(
-						sei_data_buffer_phys +
-						ltemp);
-			/* daddr = (unsigned char *)(sei_data_buffer +
-			 *  ltemp);
-			 */
-			pr_info("0x%x\n", *daddr);
-		}
-#endif
-	/*	pr_info("pocinfo 0x%x, top poc %d, wp 0x%x, length %d\n",
-	*		   READ_VREG(AV_SCRATCH_L), READ_VREG(AV_SCRATCH_M),
-	*		   sei_itu35_wp, sei_itu35_data_length);
-	*/
-		user_data_poc.poc_info = READ_VREG(AV_SCRATCH_L);
-		user_data_poc.poc_number = READ_VREG(AV_SCRATCH_M);
-		set_userdata_poc(user_data_poc);
-		WRITE_VREG(AV_SCRATCH_J, 0);
-		wakeup_userdata_poll(sei_itu35_wp,
-				(unsigned long)sei_data_buffer,
-				USER_DATA_SIZE, sei_itu35_data_length);
+		schedule_work(&userdata_push_work);
 	}
 #ifdef HANDLE_H264_IRQ
 	return IRQ_HANDLED;
@@ -1976,31 +2138,14 @@ static void vh264_put_timer_func(unsigned long arg)
 				pr_info("$$$$decoder is waiting for buffer\n");
 				if (++wait_buffer_counter > 4) {
 					amvdec_stop();
-
-#ifdef CONFIG_AMLOGIC_POST_PROCESS_MANAGER
-					vh264_ppmgr_reset();
-#else
-					vf_light_unreg_provider(&vh264_vf_prov);
-					vh264_local_init();
-					vf_reg_provider(&vh264_vf_prov);
-#endif
-					vh264_prot_init();
-					amvdec_start();
+					schedule_work(&error_wd_work);
 				}
 			} else
 				wait_buffer_counter = 0;
 		} else if (wait_i_pass_frames > 1000) {
 			pr_info("i passed frames > 1000\n");
 			amvdec_stop();
-#ifdef CONFIG_AMLOGIC_POST_PROCESS_MANAGER
-			vh264_ppmgr_reset();
-#else
-			vf_light_unreg_provider(&vh264_vf_prov);
-			vh264_local_init();
-			vf_reg_provider(&vh264_vf_prov);
-#endif
-			vh264_prot_init();
-			amvdec_start();
+			schedule_work(&error_wd_work);
 		}
 	}
 
@@ -2089,18 +2234,41 @@ exit:
 	add_timer(timer);
 }
 
-int vh264_dec_status(struct vdec_s *vdec, struct vdec_status *vstatus)
+int vh264_dec_status(struct vdec_s *vdec, struct vdec_info *vstatus)
 {
-	vstatus->width = frame_width;
-	vstatus->height = frame_height;
+	vstatus->frame_width = frame_width;
+	vstatus->frame_height = frame_height;
 	if (frame_dur != 0)
-		vstatus->fps = 96000 / frame_dur;
+		vstatus->frame_rate = 96000 / frame_dur;
 	else
-		vstatus->fps = -1;
+		vstatus->frame_rate = -1;
 	vstatus->error_count = READ_VREG(AV_SCRATCH_D);
 	vstatus->status = stat;
 	if (fatal_error_reset)
 		vstatus->status |= fatal_error_flag;
+	vstatus->bit_rate = gvs->bit_rate;
+	vstatus->frame_dur = frame_dur;
+	vstatus->frame_data = gvs->frame_data;
+	vstatus->total_data = gvs->total_data;
+	vstatus->frame_count = gvs->frame_count;
+	vstatus->error_frame_count = gvs->error_frame_count;
+	vstatus->drop_frame_count = gvs->drop_frame_count;
+	vstatus->total_data = gvs->total_data;
+	vstatus->samp_cnt = gvs->samp_cnt;
+	vstatus->offset = gvs->offset;
+	snprintf(vstatus->vdec_name, sizeof(vstatus->vdec_name),
+		"%s", DRIVER_NAME);
+
+	return 0;
+}
+
+static int vh264_vdec_info_init(void)
+{
+	gvs = kzalloc(sizeof(struct vdec_info), GFP_KERNEL);
+	if (NULL == gvs) {
+		pr_info("the struct of vdec status malloc failed.\n");
+		return -ENOMEM;
+	}
 	return 0;
 }
 
@@ -2145,13 +2313,13 @@ static void vh264_prot_init(void)
 	READ_VREG(DOS_SW_RESET0);
 
 #else
-	WRITE_MPEG_REG(RESET0_REGISTER,
+	WRITE_RESET_REG(RESET0_REGISTER,
 				   RESET_IQIDCT | RESET_MC | RESET_VLD_PART);
-	READ_MPEG_REG(RESET0_REGISTER);
-	WRITE_MPEG_REG(RESET0_REGISTER,
+	READ_RESET_REG(RESET0_REGISTER);
+	WRITE_RESET_REG(RESET0_REGISTER,
 				   RESET_IQIDCT | RESET_MC | RESET_VLD_PART);
 
-	WRITE_MPEG_REG(RESET2_REGISTER, RESET_PIC_DC | RESET_DBLK);
+	WRITE_RESET_REG(RESET2_REGISTER, RESET_PIC_DC | RESET_DBLK);
 #endif
 
 	WRITE_VREG(POWER_CTL_VLD,
@@ -2200,17 +2368,17 @@ static void vh264_prot_init(void)
 	/* #endif */
 }
 
-static void vh264_local_init(void)
+static int vh264_local_init(void)
 {
-	int i;
-
+	int i, ret;
+	u32 size;
+	unsigned long buf_start;
 	vh264_ratio = vh264_amstream_dec_info.ratio;
 	/* vh264_ratio = 0x100; */
 
 	vh264_rotation = (((unsigned long) vh264_amstream_dec_info.param)
 				>> 16) & 0xffff;
 
-	frame_buffer_size = AVIL_DPB_BUFF_SIZE + buf_size - DEFAULT_MEM_SIZE;
 	frame_prog = 0;
 	frame_width = vh264_amstream_dec_info.width;
 	frame_height = vh264_amstream_dec_info.height;
@@ -2222,21 +2390,39 @@ static void vh264_local_init(void)
 				& 0x04) >> 2;
 	max_refer_buf = !(((unsigned long) vh264_amstream_dec_info.param
 				& 0x10) >> 4);
-	if (!mm_blk_handle)
+	if (!vh264_reset) {
+		if (mm_blk_handle) {
+			decoder_bmmu_box_free(mm_blk_handle);
+			mm_blk_handle = NULL;
+		}
+
 		mm_blk_handle = decoder_bmmu_box_alloc_box(
 			DRIVER_NAME,
 			0,
 			MAX_BLK_BUFFERS,
 			4 + PAGE_SHIFT,
 			CODEC_MM_FLAGS_CMA_CLEAR |
-			CODEC_MM_FLAGS_FOR_VDECODER);
-
+			CODEC_MM_FLAGS_FOR_VDECODER |
+			tvp_flag);
+	}
 	pr_info
 	("H264 sysinfo: %dx%d duration=%d, pts_outside=%d, ",
 	 frame_width, frame_height, frame_dur, pts_outside);
 	pr_debug("sync_outside=%d, use_idr_framerate=%d\n",
 	 sync_outside, use_idr_framerate);
 
+	if (get_cpu_type() >= MESON_CPU_MAJOR_ID_GXTVBB)
+		size = V_BUF_ADDR_OFFSET_NEW;
+	else
+		size = V_BUF_ADDR_OFFSET;
+
+	ret = decoder_bmmu_box_alloc_buf_phy(mm_blk_handle, 0,
+		size, DRIVER_NAME, &buf_start);
+	if (ret < 0)
+		return ret;
+
+	buf_offset = buf_start - DEF_BUF_START_ADDR;
+
 	if ((unsigned long) vh264_amstream_dec_info.param & 0x08)
 		ucode_type = UCODE_IP_ONLY_PARAM;
 	else
@@ -2293,13 +2479,36 @@ static void vh264_local_init(void)
 #endif
 	pts_discontinue = false;
 	no_idr_error_count = 0;
+
+	reset_userdata_fifo(1);
+
+	if (enable_switch_fense) {
+		for (i = 0; i < ARRAY_SIZE(fense_buffer_spec); i++) {
+			struct buffer_spec_s *s = &fense_buffer_spec[i];
+			s->alloc_count = 3 * SZ_1M / PAGE_SIZE;
+			ret = decoder_bmmu_box_alloc_buf_phy(mm_blk_handle,
+				FENSE_BUFFER_IDX(i),
+				3 * SZ_1M, DRIVER_NAME, &s->phy_addr);
+
+			if (ret < 0) {
+				fatal_error_flag =
+				DECODER_FATAL_ERROR_NO_MEM;
+				vh264_running = 0;
+				return ret;
+			}
+			s->y_canvas_index = 2 * i;
+			s->u_canvas_index = 2 * i + 1;
+			s->v_canvas_index = 2 * i + 1;
+		}
+	}
+	return 0;
 }
 
 static s32 vh264_init(void)
 {
+	int ret = 0;
 	int trickmode_fffb = 0;
 	int firmwareloaded = 0;
-	int i;
 
 	/* pr_info("\nvh264_init\n"); */
 	init_timer(&recycle_timer);
@@ -2314,23 +2523,22 @@ static s32 vh264_init(void)
 	first_offset = 0;
 	first_pts_cached = false;
 	fixed_frame_rate_check_count = 0;
+	fr_hint_status = VDEC_NO_NEED_HINT;
 	saved_resolution = 0;
 	iponly_early_mode = 0;
 	saved_idc_level = 0;
-	vh264_local_init();
 
-	query_video_status(0, &trickmode_fffb);
+	/*init vdec status*/
+	ret = vh264_vdec_info_init();
+	if (0 != ret)
+		return -ret;
+
 
-#if 0
-	if (!trickmode_fffb) {
-		void __iomem *p =
-			ioremap_nocache(ucode_map_start, V_BUF_ADDR_OFFSET);
-		if (p != NULL) {
-			memset(p, 0, V_BUF_ADDR_OFFSET);
-			iounmap(p);
-		}
-	}
-#endif
+
+	ret = vh264_local_init();
+	if (ret < 0)
+		return ret;
+	query_video_status(0, &trickmode_fffb);
 
 	amvdec_enable();
 
@@ -2340,7 +2548,7 @@ static s32 vh264_init(void)
 				&mc_dma_handle, GFP_KERNEL);
 	if (!mc_cpu_addr) {
 		amvdec_disable();
-
+		del_timer_sync(&recycle_timer);
 		pr_err("vh264_init: Can not allocate mc memory.\n");
 		return -ENOMEM;
 	}
@@ -2445,29 +2653,7 @@ static s32 vh264_init(void)
 	}
 
 	stat |= STAT_MC_LOAD;
-	if (enable_switch_fense) {
-		for (i = 0; i < ARRAY_SIZE(fense_buffer_spec); i++) {
-			struct buffer_spec_s *s = &fense_buffer_spec[i];
-			s->alloc_count = 3 * SZ_1M / PAGE_SIZE;
-			if (!decoder_bmmu_box_alloc_idx_wait(
-					mm_blk_handle,
-					FENSE_BUFFER_IDX(i),
-					3 * SZ_1M,
-					-1,
-					-1,
-					BMMU_ALLOC_FLAGS_WAITCLEAR
-					)) {
-				s->phy_addr = decoder_bmmu_box_get_phy_addr(
-					mm_blk_handle,
-					FENSE_BUFFER_IDX(i));
-			} else {
-				return -ENOMEM;
-			}
-			s->y_canvas_index = 2 * i;
-			s->u_canvas_index = 2 * i + 1;
-			s->v_canvas_index = 2 * i + 1;
-		}
-	}
+
 	/* enable AMRISC side protocol */
 	vh264_prot_init();
 
@@ -2495,8 +2681,13 @@ static s32 vh264_init(void)
 	vf_reg_provider(&vh264_vf_prov);
 #endif
 
-	vf_notify_receiver(PROVIDER_NAME, VFRAME_EVENT_PROVIDER_FR_HINT,
-					   (void *)((unsigned long)frame_dur));
+	if (frame_dur != 0) {
+		vf_notify_receiver(PROVIDER_NAME,
+				VFRAME_EVENT_PROVIDER_FR_HINT,
+				(void *)((unsigned long)frame_dur));
+		fr_hint_status = VDEC_HINTED;
+	} else
+		fr_hint_status = VDEC_NEED_HINT;
 
 	stat |= STAT_VF_HOOK;
 
@@ -2546,9 +2737,11 @@ static int vh264_stop(int mode)
 
 	if (stat & STAT_VF_HOOK) {
 		if (mode == MODE_FULL) {
-			vf_notify_receiver(PROVIDER_NAME,
+			if (fr_hint_status == VDEC_HINTED)
+				vf_notify_receiver(PROVIDER_NAME,
 					VFRAME_EVENT_PROVIDER_FR_END_HINT,
 					NULL);
+			fr_hint_status = VDEC_NO_NEED_HINT;
 		}
 
 		vf_unreg_provider(&vh264_vf_prov);
@@ -2566,7 +2759,7 @@ static int vh264_stop(int mode)
 	if (sei_data_buffer != NULL) {
 		dma_free_coherent(
 			amports_get_dma_device(),
-			USER_DATA_SIZE,
+			USER_DATA_RUND_SIZE,
 			sei_data_buffer,
 			sei_data_buffer_phys);
 		sei_data_buffer = NULL;
@@ -2593,7 +2786,10 @@ static void error_do_work(struct work_struct *work)
 	 * free_irq/deltimer/..and some other.
 	 */
 	if (atomic_read(&vh264_active)) {
-		amvdec_stop();
+
+		do {
+			msleep(20);
+		} while (vh264_stream_switching_state != SWITCHING_STATE_OFF);
 		vh264_reset  = 1;
 #ifdef CONFIG_AMLOGIC_POST_PROCESS_MANAGER
 		vh264_ppmgr_reset();
@@ -2605,7 +2801,6 @@ static void error_do_work(struct work_struct *work)
 		vf_reg_provider(&vh264_vf_prov);
 #endif
 		msleep(30);
-		vh264_local_init();
 		vh264_prot_init();
 
 		amvdec_start();
@@ -2690,7 +2885,9 @@ static void stream_switching_do(struct work_struct *work)
 		buffer_index = vf->index & 0xff;
 
 		/* construct a clone of the frame from last frame */
-#if 1
+
+#if 0
+
 		pr_info("src yaddr[0x%x] index[%d] width[%d] heigth[%d]\n",
 			buffer_spec[buffer_index].y_addr,
 			buffer_spec[buffer_index].y_canvas_index,
@@ -2782,27 +2979,13 @@ static int amvdec_h264_probe(struct platform_device *pdev)
 		mutex_unlock(&vh264_mutex);
 		return -EFAULT;
 	}
-
-	ucode_map_start = pdata->mem_start;
-	buf_size = pdata->mem_end - pdata->mem_start + 1;
-	if (buf_size < DEFAULT_MEM_SIZE) {
-		pr_info("\namvdec_h264 memory size not enough.\n");
-		mutex_unlock(&vh264_mutex);
-		return -ENOMEM;
-	}
-
-	buf_offset = pdata->mem_start - DEF_BUF_START_ADDR;
-	if (get_cpu_type() >= MESON_CPU_MAJOR_ID_GXTVBB)
-		buf_start = V_BUF_ADDR_OFFSET_NEW + pdata->mem_start;
-	else
-		buf_start = V_BUF_ADDR_OFFSET + pdata->mem_start;
-	buf_end = pdata->mem_end;
+	tvp_flag = vdec_secure(pdata) ? CODEC_MM_FLAGS_TVP : 0;
 	if (pdata->sys_info)
 		vh264_amstream_dec_info = *pdata->sys_info;
 	if (NULL == sei_data_buffer) {
 		sei_data_buffer =
 			dma_alloc_coherent(amports_get_dma_device(),
-				USER_DATA_SIZE,
+				USER_DATA_RUND_SIZE,
 				&sei_data_buffer_phys, GFP_KERNEL);
 		if (!sei_data_buffer) {
 			pr_info("%s: Can not allocate sei_data_buffer\n",
@@ -2815,13 +2998,13 @@ static int amvdec_h264_probe(struct platform_device *pdev)
 		  * (u32)sei_data_buffer_remap);
 		  */
 	}
-	pr_debug("amvdec_h264 mem-addr=%lx,buff_offset=%x,buf_start=%lx buf_size %x\n",
-		   pdata->mem_start, buf_offset, buf_start, buf_size);
 	pdata->dec_status = vh264_dec_status;
 	pdata->set_trickmode = vh264_set_trickmode;
 
 	if (vh264_init() < 0) {
 		pr_info("\namvdec_h264 init failed.\n");
+		kfree(gvs);
+		gvs = NULL;
 		mutex_unlock(&vh264_mutex);
 		return -ENODEV;
 	}
@@ -2829,6 +3012,11 @@ static int amvdec_h264_probe(struct platform_device *pdev)
 	INIT_WORK(&error_wd_work, error_do_work);
 	INIT_WORK(&stream_switching_work, stream_switching_do);
 	INIT_WORK(&set_parameter_work, vh264_set_params);
+	INIT_WORK(&notify_work, vh264_notify_work);
+
+	INIT_WORK(&userdata_push_work, userdata_push_do_work);
+
+
 
 	atomic_set(&vh264_active, 1);
 
@@ -2843,6 +3031,9 @@ static int amvdec_h264_remove(struct platform_device *pdev)
 	cancel_work_sync(&set_parameter_work);
 	cancel_work_sync(&error_wd_work);
 	cancel_work_sync(&stream_switching_work);
+	cancel_work_sync(&notify_work);
+	cancel_work_sync(&userdata_push_work);
+
 	mutex_lock(&vh264_mutex);
 	vh264_stop(MODE_FULL);
 	vdec_source_changed(VFORMAT_H264, 0, 0, 0);
@@ -2854,6 +3045,8 @@ static int amvdec_h264_remove(struct platform_device *pdev)
 	pr_info("sync_outside %d, use_idr_framerate %d\n",
 			sync_outside, use_idr_framerate);
 #endif
+	kfree(gvs);
+	gvs = NULL;
 	mutex_unlock(&vh264_mutex);
 	return 0;
 }
@@ -2877,6 +3070,26 @@ static struct codec_profile_t amvdec_h264_profile = {
 	.profile = ""
 };
 
+
+static struct mconfig h264_configs[] = {
+	MC_PU32("stat", &stat),
+	MC_PU32("error_recovery_mode", &error_recovery_mode),
+	MC_PU32("sync_outside", &sync_outside),
+	MC_PU32("dec_control", &dec_control),
+	MC_PU32("fatal_error_reset", &fatal_error_reset),
+	MC_PU32("max_refer_buf", &max_refer_buf),
+	MC_PU32("ucode_type", &ucode_type),
+	MC_PU32("debugfirmware", &debugfirmware),
+	MC_PU32("fixed_frame_rate_flag", &fixed_frame_rate_flag),
+	MC_PU32("decoder_debug_flag", &decoder_debug_flag),
+	MC_PU32("dpb_size_adj", &dpb_size_adj),
+	MC_PU32("decoder_force_reset", &decoder_force_reset),
+	MC_PU32("no_idr_error_max", &no_idr_error_max),
+	MC_PU32("enable_switch_fense", &enable_switch_fense),
+};
+static struct mconfig_node h264_node;
+
+
 static int __init amvdec_h264_driver_init_module(void)
 {
 	pr_debug("amvdec_h264 module init\n");
@@ -2890,12 +3103,10 @@ static int __init amvdec_h264_driver_init_module(void)
 	if (get_cpu_type() >= MESON_CPU_MAJOR_ID_GXTVBB
 		&& (codec_mm_get_total_size() > 80 * SZ_1M)) {
 		amvdec_h264_profile.profile = "4k";
-		dpb_size_adj = 0;
 	}
-	if (get_cpu_type() <= MESON_CPU_MAJOR_ID_GXBB)
-		dpb_size_adj = 0;
-
 	vcodec_profile_register(&amvdec_h264_profile);
+	INIT_REG_NODE_CONFIGS("media.decoder", &h264_node,
+		"h264", h264_configs, CONFIG_FOR_RW);
 	return 0;
 }
 
diff --git a/drivers/frame_provider/decoder/h264/vh264.h b/drivers/frame_provider/decoder/h264/vh264.h
index 45d2849..a8b0c62 100644
--- a/drivers/frame_provider/decoder/h264/vh264.h
+++ b/drivers/frame_provider/decoder/h264/vh264.h
@@ -18,6 +18,8 @@
 #ifndef VH264_H
 #define VH264_H
 
+extern int query_video_status(int type, int *value);
+
 /* extern s32 vh264_init(void); */
 
 extern s32 vh264_release(void);
diff --git a/drivers/frame_provider/decoder/h264/vh264_4k2k.c b/drivers/frame_provider/decoder/h264/vh264_4k2k.c
index 1c56b03..ed0a3ce 100644
--- a/drivers/frame_provider/decoder/h264/vh264_4k2k.c
+++ b/drivers/frame_provider/decoder/h264/vh264_4k2k.c
@@ -49,6 +49,10 @@
 #include "../../../stream_input/amports/amports_priv.h"
 #include "../utils/vdec.h"
 #include "../utils/amvdec.h"
+#include "../utils/decoder_mmu_box.h"
+#include "../utils/decoder_bmmu_box.h"
+#include <linux/amlogic/media/codec_mm/codec_mm.h>
+#include <linux/amlogic/media/codec_mm/configs.h>
 
 #if  0 /* MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6TVD */
 #define DOUBLE_WRITE
@@ -59,6 +63,12 @@
 
 #define PUT_INTERVAL        (HZ/100)
 #define ERROR_RESET_COUNT   500
+#define DECODE_BUFFER_NUM_MAX    32
+#define DISPLAY_BUFFER_NUM       6
+#define MAX_BMMU_BUFFER_NUM	(DECODE_BUFFER_NUM_MAX + DISPLAY_BUFFER_NUM)
+#define VF_BUFFER_IDX(n) (2  + n)
+#define DECODER_WORK_SPACE_SIZE 0x800000
+
 
 #if  1 /* MESON_CPU_TYPE == MESON_CPU_TYPE_MESONG9TV */
 #define H264_4K2K_SINGLE_CORE 1
@@ -75,7 +85,7 @@ static void vh264_4k2k_vf_put(struct vframe_s *, void *);
 static int vh264_4k2k_event_cb(int type, void *data, void *private_data);
 
 static void vh264_4k2k_prot_init(void);
-static void vh264_4k2k_local_init(void);
+static int vh264_4k2k_local_init(void);
 static void vh264_4k2k_put_timer_func(unsigned long arg);
 
 static const char vh264_4k2k_dec_id[] = "vh264_4k2k-dev";
@@ -90,7 +100,7 @@ static const struct vframe_operations_s vh264_4k2k_vf_provider = {
 	.event_cb = vh264_4k2k_event_cb,
 	.vf_states = vh264_4k2k_vf_states,
 };
-
+static void *mm_blk_handle;
 static struct vframe_provider_s vh264_4k2k_vf_prov;
 
 static u32 mb_width_old, mb_height_old;
@@ -225,14 +235,12 @@ static struct device *cma_dev;
 #define MC_TOTAL_SIZE           (28*SZ_1K)
 #define MC_SWAP_SIZE            (4*SZ_1K)
 
-static unsigned long work_space_adr, decoder_buffer_start, decoder_buffer_end;
+static unsigned long work_space_adr, ref_start_addr;
 static unsigned long reserved_buffer;
 
-#define DECODE_BUFFER_NUM_MAX    32
-#define DISPLAY_BUFFER_NUM       6
 
 #define video_domain_addr(adr) (adr&0x7fffffff)
-#define DECODER_WORK_SPACE_SIZE 0x400000
+
 
 struct buffer_spec_s {
 	unsigned int y_addr;
@@ -254,8 +262,7 @@ struct buffer_spec_s {
 	int alloc_count;
 };
 
-static struct buffer_spec_s buffer_spec[DECODE_BUFFER_NUM_MAX +
-					DISPLAY_BUFFER_NUM];
+static struct buffer_spec_s buffer_spec[MAX_BMMU_BUFFER_NUM];
 
 #ifdef DOUBLE_WRITE
 #define spec2canvas(x)  \
@@ -279,6 +286,7 @@ static s32 vfbuf_use[DECODE_BUFFER_NUM_MAX];
 static struct vframe_s vfpool[VF_POOL_SIZE];
 
 static struct work_struct alloc_work;
+static struct vdec_info *gvs;
 
 static void set_frame_info(struct vframe_s *vf)
 {
@@ -368,132 +376,61 @@ static int vh264_4k2k_event_cb(int type, void *data, void *private_data)
 	return 0;
 }
 
-int init_canvas(int start_addr, long dpb_size, int dpb_number, int mb_width,
-		int mb_height, struct buffer_spec_s *buffer_spec)
+static int init_canvas(int refbuf_size, long dpb_size, int dpb_number,
+		int mb_width, int mb_height,
+		struct buffer_spec_s *buffer_spec)
 {
-	unsigned long dpb_addr, addr;
-	int i;
+	unsigned long  addr;
+	int i, j, ret = -1;
 	int mb_total;
 	int canvas_addr = ANC0_CANVAS_ADDR;
 	int vdec2_canvas_addr = VDEC2_ANC0_CANVAS_ADDR;
 	int index = AMVDEC_H264_4K2K_CANVAS_INDEX;
-	u32 disp_addr = 0xffffffff;
-	bool use_alloc = false;
-	int alloc_count = 0;
-	struct canvas_s cur_canvas;
-
-	dpb_addr = start_addr + dpb_size;
 
 	mb_total = mb_width * mb_height;
-
-	canvas_read((READ_VCBUS_REG(VD1_IF0_CANVAS0) & 0xff), &cur_canvas);
-	disp_addr = (cur_canvas.addr + 7) >> 3;
-
 	mutex_lock(&vh264_4k2k_mutex);
 
-	for (i = 0; i < dpb_number; i++) {
-		WRITE_VREG(canvas_addr++,
-				   index | ((index + 1) << 8) |
-				   ((index + 1) << 16));
-		if (!H264_4K2K_SINGLE_CORE) {
-			WRITE_VREG(vdec2_canvas_addr++,
-					index | ((index + 1) << 8) |
-					((index + 1) << 16));
-		}
+	for (j = 0; j < (dpb_number + 1); j++) {
+		int page_count;
+		if (j == 0) {
+			ret = decoder_bmmu_box_alloc_buf_phy(mm_blk_handle, 1,
+				refbuf_size, DRIVER_NAME, &ref_start_addr);
+			if (ret < 0) {
+				mutex_unlock(&vh264_4k2k_mutex);
+				return ret;
+			}
+		continue;
+	}
 
-		if (((dpb_addr + (mb_total << 8) + (mb_total << 7)) >=
-			 decoder_buffer_end) && (!use_alloc)) {
-			pr_info("start alloc for %d/%d\n", i, dpb_number);
-			use_alloc = true;
-		}
+	WRITE_VREG(canvas_addr++, index | ((index + 1) << 8) |
+			((index + 1) << 16));
+	if (!H264_4K2K_SINGLE_CORE) {
+		WRITE_VREG(vdec2_canvas_addr++,
+			index | ((index + 1) << 8) |
+			((index + 1) << 16));
+	}
 
-		if (use_alloc) {
+	i = j - 1;
 #ifdef DOUBLE_WRITE
-			int page_count =
-				PAGE_ALIGN((mb_total << 8) + (mb_total << 7) +
-						   (mb_total << 6) +
-						   (mb_total << 5)) / PAGE_SIZE;
+	 page_count =
+		PAGE_ALIGN((mb_total << 8) + (mb_total << 7) +
+			   (mb_total << 6) + (mb_total << 5)) / PAGE_SIZE;
 #else
-			int page_count =
-				PAGE_ALIGN((mb_total << 8) +
-						(mb_total << 7)) / PAGE_SIZE;
+	 page_count =
+		PAGE_ALIGN((mb_total << 8) + (mb_total << 7)) / PAGE_SIZE;
 #endif
 
-			if (buffer_spec[i].phy_addr) {
-				if (page_count != buffer_spec[i].alloc_count) {
-					pr_info("Delay release CMA buffer%d\n",
-						   i);
-
-					/*dma_release_from_contiguous(cma_dev,
-							buffer_spec[i].
-							alloc_pages,
-							buffer_spec[i].
-							alloc_count);
-							*/
-					codec_mm_free_for_dma(MEM_NAME,
-						buffer_spec[i].phy_addr);
-					buffer_spec[i].phy_addr = 0;
-					buffer_spec[i].alloc_pages = NULL;
-					buffer_spec[i].alloc_count = 0;
-				} else
-					pr_info("Re-use CMA buffer %d\n", i);
-			}
+	ret = decoder_bmmu_box_alloc_buf_phy(mm_blk_handle,
+			VF_BUFFER_IDX(i), page_count << PAGE_SHIFT,
+				DRIVER_NAME, &buffer_spec[i].phy_addr);
 
-			if (!buffer_spec[i].phy_addr) {
-				if (codec_mm_get_free_size()
-					< (page_count * PAGE_SIZE)) {
-					pr_err
-					("CMA not enough free keep buf! %d\n",
-					i);
-					try_free_keep_video(1);
-				}
-				if (!codec_mm_enough_for_size(
-					page_count * PAGE_SIZE, 1)) {
-					buffer_spec[i].alloc_count = 0;
-					fatal_error =
-						DECODER_FATAL_ERROR_NO_MEM;
-					mutex_unlock(&vh264_4k2k_mutex);
-					return -1;
-				}
-				buffer_spec[i].alloc_count = page_count;
-				buffer_spec[i].phy_addr =
-					codec_mm_alloc_for_dma(
-					MEM_NAME, buffer_spec[i].alloc_count,
-					4 + PAGE_SHIFT,
-					CODEC_MM_FLAGS_CMA_CLEAR |
-					CODEC_MM_FLAGS_FOR_VDECODER);
-			}
-			alloc_count++;
-
-			if (!buffer_spec[i].phy_addr) {
+			if (ret < 0) {
 				buffer_spec[i].alloc_count = 0;
-				pr_info
-				("264 4K2K decoder memory alloc failed %d.\n",
-				 i);
 				mutex_unlock(&vh264_4k2k_mutex);
-				return -1;
-			}
-			addr = buffer_spec[i].phy_addr;
-			dpb_addr = addr;
-		} else {
-			if (buffer_spec[i].phy_addr) {
-				codec_mm_free_for_dma(MEM_NAME,
-					buffer_spec[i].phy_addr);
-				buffer_spec[i].phy_addr = 0;
-				buffer_spec[i].alloc_pages = NULL;
-				buffer_spec[i].alloc_count = 0;
+				return ret;
 			}
-
-			addr = dpb_addr;
-			dpb_addr += dpb_size;
-#ifdef DOUBLE_WRITE
-			dpb_addr += dpb_size / 4;
-#endif
-		}
-
-		if (((addr + 7) >> 3) == disp_addr)
-			addr = start_addr;
-
+		addr = buffer_spec[i].phy_addr;
+		buffer_spec[i].alloc_count = page_count;
 		buffer_spec[i].y_addr = addr;
 		buffer_spec[i].y_canvas_index = index;
 		canvas_config(index,
@@ -536,7 +473,6 @@ int init_canvas(int start_addr, long dpb_size, int dpb_number, int mb_width,
 				mb_height << 2,
 				CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_32X32);
 
-		addr += mb_total << 5;
 		index++;
 #endif
 	}
@@ -545,8 +481,6 @@ int init_canvas(int start_addr, long dpb_size, int dpb_number, int mb_width,
 
 	pr_info
 	("H264 4k2k decoder canvas allocation successful, ");
-	pr_info("%d CMA blocks allocated, canvas %d-%d\n",
-	 alloc_count, AMVDEC_H264_4K2K_CANVAS_INDEX, index - 1);
 
 	return 0;
 }
@@ -628,14 +562,14 @@ static void do_alloc_work(struct work_struct *work)
 {
 	int level_idc, max_reference_frame_num, mb_width, mb_height,
 		frame_mbs_only_flag;
-	int dpb_size, ref_size;
-	int dpb_start_addr, ref_start_addr, max_dec_frame_buffering,
+	int dpb_size, ref_size, refbuf_size;
+	int max_dec_frame_buffering,
 		total_dec_frame_buffering;
 	unsigned int chroma444;
 	unsigned int crop_infor, crop_bottom, crop_right;
 	int ret = READ_VREG(MAILBOX_COMMAND);
 
-	ref_start_addr = decoder_buffer_start;
+
 	ret = READ_VREG(MAILBOX_DATA_0);
 	/*  MAILBOX_DATA_1 :
 		bit15    : frame_mbs_only_flag
@@ -697,17 +631,13 @@ static void do_alloc_work(struct work_struct *work)
 
 	dpb_size = mb_width * mb_height * 384;
 	ref_size = mb_width * mb_height * 96;
-	dpb_start_addr =
-		ref_start_addr + (ref_size * (max_reference_frame_num + 1)) * 2;
-	/* dpb_start_addr = reserved_buffer + dpb_size; */
+	refbuf_size = ref_size * (max_reference_frame_num + 1) * 2;
+
 
-	pr_info
-	("dpb_start_addr=0x%x, dpb_size=%d, total_dec_frame_buffering=%d, ",
-	 dpb_start_addr, dpb_size, total_dec_frame_buffering);
 	pr_info("mb_width=%d, mb_height=%d\n",
 	 mb_width, mb_height);
 
-	ret = init_canvas(dpb_start_addr, dpb_size,
+	ret = init_canvas(refbuf_size,  dpb_size,
 			total_dec_frame_buffering, mb_width, mb_height,
 			buffer_spec);
 
@@ -734,27 +664,7 @@ static void do_alloc_work(struct work_struct *work)
 	WRITE_VREG(MAILBOX_COMMAND, CMD_FINISHED);
 
 	/* ///////////// FAKE FIRST PIC */
-#if 0
-
-	pr_info("Debug: send a fake picture to config VPP %dx%d\n", frame_width,
-		   frame_height);
-	WRITE_VREG(DOS_SCRATCH0, 4);
-	WRITE_VREG(DOS_SCRATCH1, 0x004c);
-
-	if (kfifo_get(&newframe_q, &vf)) {
-		vfbuf_use[0]++;
-		vf->index = 0;
-		vf->pts = 0;
-		vf->type = VIDTYPE_PROGRESSIVE | VIDTYPE_VIU_FIELD;
-		vf->canvas0Addr = vf->canvas1Addr =
-			spec2canvas(&buffer_spec[0]);
-		set_frame_info(vf);
-		kfifo_put(&display_q, (const struct vframe_s *)vf);
-		vf_notify_receiver(PROVIDER_NAME,
-				VFRAME_EVENT_PROVIDER_VFRAME_READY, NULL);
-	}
-	/* ///////////// FAKE END */
-#endif
+
 }
 
 static irqreturn_t vh264_4k2k_isr(int irq, void *dev_id)
@@ -822,6 +732,12 @@ static irqreturn_t vh264_4k2k_isr(int irq, void *dev_id)
 				spec2canvas(&buffer_spec[display_buff_id]);
 			set_frame_info(vf);
 
+			if (error)
+				gvs->drop_frame_count++;
+
+			gvs->frame_dur = frame_dur;
+			vdec_count_info(gvs, error, stream_offset);
+
 			if (((error_recovery_mode & 2) && error)
 				|| (!first_i_recieved
 					&& (slice_type != SLICE_TYPE_I))) {
@@ -830,6 +746,10 @@ static irqreturn_t vh264_4k2k_isr(int irq, void *dev_id)
 			} else {
 				p_last_vf = vf;
 				first_i_recieved = 1;
+				vf->mem_handle =
+				decoder_bmmu_box_get_mem_handle(
+					mm_blk_handle,
+					VF_BUFFER_IDX(display_buff_id));
 				kfifo_put(&display_q,
 						  (const struct vframe_s *)vf);
 
@@ -1020,16 +940,38 @@ static void vh264_4k2k_put_timer_func(unsigned long arg)
 	add_timer(timer);
 }
 
-int vh264_4k2k_dec_status(struct vdec_s *vdec, struct vdec_status *vstatus)
+int vh264_4k2k_dec_status(struct vdec_s *vdec, struct vdec_info *vstatus)
 {
-	vstatus->width = frame_width;
-	vstatus->height = frame_height;
+	vstatus->frame_width = frame_width;
+	vstatus->frame_height = frame_height;
 	if (frame_dur != 0)
-		vstatus->fps = 96000 / frame_dur;
+		vstatus->frame_rate = 96000 / frame_dur;
 	else
-		vstatus->fps = -1;
+		vstatus->frame_rate = -1;
 	vstatus->error_count = 0;
 	vstatus->status = stat | fatal_error;
+	vstatus->frame_dur = frame_dur;
+	vstatus->frame_data = gvs->frame_data;
+	vstatus->total_data = gvs->total_data;
+	vstatus->frame_count = gvs->frame_count;
+	vstatus->error_frame_count = gvs->error_frame_count;
+	vstatus->drop_frame_count = gvs->drop_frame_count;
+	vstatus->total_data = gvs->total_data;
+	vstatus->samp_cnt = gvs->samp_cnt;
+	vstatus->offset = gvs->offset;
+	snprintf(vstatus->vdec_name, sizeof(vstatus->vdec_name),
+		"%s", DRIVER_NAME);
+
+	return 0;
+}
+
+static int vh264_4k2k_vdec_info_init(void)
+{
+	gvs = kzalloc(sizeof(struct vdec_info), GFP_KERNEL);
+	if (NULL == gvs) {
+		pr_info("the struct of vdec status malloc failed.\n");
+		return -ENOMEM;
+	}
 	return 0;
 }
 
@@ -1279,8 +1221,6 @@ static void vh264_4k2k_prot_init(void)
 	WRITE_VREG(MDEC_PIC_DC_THRESH, 0x404038aa);
 	if (!H264_4K2K_SINGLE_CORE) {
 		WRITE_VREG(VDEC2_MDEC_PIC_DC_THRESH, 0x404038aa);
-		/*TODO for M8
-		amvenc_dos_top_reg_fix();*/
 	}
 #ifdef DOUBLE_WRITE
 	WRITE_VREG(MDEC_DOUBLEW_CFG0, (0 << 31) |	/* half y address */
@@ -1340,9 +1280,9 @@ static void vh264_4k2k_prot_init(void)
 #endif
 }
 
-static void vh264_4k2k_local_init(void)
+static int vh264_4k2k_local_init(void)
 {
-	int i;
+	int i, size, ret;
 
 #ifdef DEBUG_PTS
 	pts_missed = 0;
@@ -1390,7 +1330,23 @@ static void vh264_4k2k_local_init(void)
 	first_i_recieved = 0;
 	INIT_WORK(&alloc_work, do_alloc_work);
 
-	return;
+	if (mm_blk_handle) {
+		decoder_bmmu_box_free(mm_blk_handle);
+		mm_blk_handle = NULL;
+	}
+
+	mm_blk_handle = decoder_bmmu_box_alloc_box(
+		DRIVER_NAME,
+		0,
+		MAX_BMMU_BUFFER_NUM,
+		4 + PAGE_SHIFT,
+		CODEC_MM_FLAGS_CMA_CLEAR |
+		CODEC_MM_FLAGS_FOR_VDECODER);
+
+	size = DECODER_WORK_SPACE_SIZE;
+	ret = decoder_bmmu_box_alloc_buf_phy(mm_blk_handle, 0,
+		size, DRIVER_NAME, &work_space_adr);
+	return ret;
 }
 
 static s32 vh264_4k2k_init(void)
@@ -1534,14 +1490,15 @@ static s32 vh264_4k2k_init(void)
 
 	stat |= STAT_VDEC_RUN;
 
+	ret = vh264_4k2k_vdec_info_init();
+	if (0 != ret)
+		return -ret;
+
 	return 0;
 }
 
 static int vh264_4k2k_stop(void)
 {
-	int i;
-	u32 disp_addr = 0xffffffff;
-	struct canvas_s cur_canvas;
 
 	if (stat & STAT_VDEC_RUN) {
 		amvdec_stop();
@@ -1594,33 +1551,12 @@ static int vh264_4k2k_stop(void)
 	amvdec_disable();
 	if (!H264_4K2K_SINGLE_CORE)
 		amvdec2_disable();
-#ifdef CONFIG_VSYNC_RDMA
+#ifdef CONFIG_AMLOGIC_MEDIA_VSYNC_RDMA
 	msleep(100);
 #endif
-	if (!get_blackout_policy()) {
-		canvas_read((READ_VCBUS_REG(VD1_IF0_CANVAS0) & 0xff),
-			&cur_canvas);
-		disp_addr = cur_canvas.addr;
-	}
-
-	for (i = 0; i < ARRAY_SIZE(buffer_spec); i++) {
-		if (buffer_spec[i].phy_addr) {
-			if (disp_addr ==
-				(u32)buffer_spec[i].phy_addr)
-				pr_info("Skip releasing CMA buffer %d\n", i);
-			else {
-				codec_mm_free_for_dma(MEM_NAME,
-					buffer_spec[i].phy_addr);
-				buffer_spec[i].phy_addr = 0;
-				buffer_spec[i].alloc_pages = NULL;
-				buffer_spec[i].alloc_count = 0;
-			}
-		}
-
-		if (buffer_spec[i].y_addr == disp_addr) {
-			pr_info("4K2K dec stop, keeping buffer index = %d\n",
-				   i);
-		}
+	if (mm_blk_handle) {
+		decoder_bmmu_box_free(mm_blk_handle);
+		mm_blk_handle = NULL;
 	}
 
 	return 0;
@@ -1645,10 +1581,6 @@ void vh264_4k_free_cmabuf(void)
 	mutex_unlock(&vh264_4k2k_mutex);
 }
 
-#if 0 /* (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) && (HAS_HDEC) */
-/* extern void AbortEncodeWithVdec2(int abort); */
-#endif
-
 static int amvdec_h264_4k2k_probe(struct platform_device *pdev)
 {
 	struct vdec_s *pdata = *(struct vdec_s **)pdev->dev.platform_data;
@@ -1665,16 +1597,10 @@ static int amvdec_h264_4k2k_probe(struct platform_device *pdev)
 		return -EFAULT;
 	}
 
-	work_space_adr = pdata->mem_start;
-	decoder_buffer_start = pdata->mem_start + DECODER_WORK_SPACE_SIZE;
-	decoder_buffer_end = pdata->mem_end + 1;
-
 	if (pdata->sys_info)
 		vh264_4k2k_amstream_dec_info = *pdata->sys_info;
 	cma_dev = pdata->cma_dev;
 
-	pr_info("H.264 4k2k decoder mem resource 0x%x -- 0x%x\n",
-		   (u32)decoder_buffer_start, (u32)decoder_buffer_end);
 	pr_info("                   sysinfo: %dx%d, rate = %d, param = 0x%lx\n",
 		   vh264_4k2k_amstream_dec_info.width,
 		   vh264_4k2k_amstream_dec_info.height,
@@ -1682,31 +1608,10 @@ static int amvdec_h264_4k2k_probe(struct platform_device *pdev)
 		   (unsigned long) vh264_4k2k_amstream_dec_info.param);
 
 	if (!H264_4K2K_SINGLE_CORE) {
-#if 1 /* (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) && (has_hdec()) */
-		int count = 0;
-		if (get_vdec2_usage() != USAGE_NONE)
-			/* AbortEncodeWithVdec2(1); */ /*TODO*/
-		while ((get_vdec2_usage() != USAGE_NONE) && (count < 10)) {
-			msleep(50);
-			count++;
-		}
-
-		if (get_vdec2_usage() != USAGE_NONE) {
-			pr_info
-			("\namvdec_h264_4k2k - vdec2 is used by encode now.\n");
-			mutex_unlock(&vh264_4k2k_mutex);
-			return -EBUSY;
-		}
-#endif
-
 		if (vdec_on(VDEC_2)) {	/* ++++ */
 			vdec_poweroff(VDEC_2);	/* ++++ */
 			mdelay(10);
 		}
-#if 1 /* (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) && (has_hdec()) */
-		set_vdec2_usage(USAGE_DEC_4K2K);
-		/* AbortEncodeWithVdec2(0); */ /*TODO*/
-#endif
 		vdec_poweron(VDEC_2);
 	}
 
@@ -1720,13 +1625,10 @@ static int amvdec_h264_4k2k_probe(struct platform_device *pdev)
 
 	if (vh264_4k2k_init() < 0) {
 		pr_info("\namvdec_h264_4k2k init failed.\n");
-#if 1/* (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) && (has_hdec()) */
-		if (!H264_4K2K_SINGLE_CORE) {
-			set_vdec2_usage(USAGE_NONE);
-			/*AbortEncodeWithVdec2(0);*/ /*TODO*/
-		}
-#endif
 		mutex_unlock(&vh264_4k2k_mutex);
+		kfree(gvs);
+		gvs = NULL;
+
 		return -ENODEV;
 	}
 #if 1/*MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8*/
@@ -1757,9 +1659,6 @@ static int amvdec_h264_4k2k_remove(struct platform_device *pdev)
 
 	if (!H264_4K2K_SINGLE_CORE) {
 		vdec_poweroff(VDEC_2);
-#if 1/*(MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) && (has_hdec())*/
-		set_vdec2_usage(USAGE_NONE);
-#endif
 	}
 #ifdef DEBUG_PTS
 	pr_info("pts missed %ld, pts hit %ld, duration %d\n",
@@ -1771,6 +1670,9 @@ static int amvdec_h264_4k2k_remove(struct platform_device *pdev)
 
 	mutex_unlock(&vh264_4k2k_mutex);
 
+	kfree(gvs);
+	gvs = NULL;
+
 	pr_info("amvdec_h264_4k2k_remove\n");
 	return 0;
 }
@@ -1801,6 +1703,11 @@ static struct codec_profile_t amvdec_h264_4k2k_profile = {
 	.name = "h264_4k2k",
 	.profile = ""
 };
+static struct mconfig h264_4k2k_configs[] = {
+	MC_PU32("stat", &stat),
+	MC_PU32("error_recovery_mode", &error_recovery_mode),
+};
+static struct mconfig_node h264_4k2k_node;
 
 static int __init amvdec_h264_4k2k_driver_init_module(void)
 {
@@ -1812,7 +1719,8 @@ static int __init amvdec_h264_4k2k_driver_init_module(void)
 	}
 	if (get_cpu_type() < MESON_CPU_MAJOR_ID_GXTVBB)
 		vcodec_profile_register(&amvdec_h264_4k2k_profile);
-
+	INIT_REG_NODE_CONFIGS("media.decoder", &h264_4k2k_node,
+		"h264_4k2k", h264_4k2k_configs, CONFIG_FOR_RW);
 	return 0;
 }
 
diff --git a/drivers/frame_provider/decoder/h264/vh264_mvc.c b/drivers/frame_provider/decoder/h264/vh264_mvc.c
index 1683c31..73d8250 100644
--- a/drivers/frame_provider/decoder/h264/vh264_mvc.c
+++ b/drivers/frame_provider/decoder/h264/vh264_mvc.c
@@ -39,6 +39,10 @@
 #include "../../../stream_input/amports/amports_priv.h"
 #include "../utils/vdec.h"
 #include "../utils/amvdec.h"
+#include "../utils/decoder_mmu_box.h"
+#include "../utils/decoder_bmmu_box.h"
+#include <linux/amlogic/media/codec_mm/codec_mm.h>
+#include <linux/amlogic/media/codec_mm/configs.h>
 
 #define TIME_TASK_PRINT_ENABLE  0x100
 #define PUT_PRINT_ENABLE    0x200
@@ -73,13 +77,18 @@ static void vh264mvc_vf_put(struct vframe_s *, void *);
 static int vh264mvc_event_cb(int type, void *data, void *private_data);
 
 static void vh264mvc_prot_init(void);
-static void vh264mvc_local_init(void);
+static int vh264mvc_local_init(void);
 static void vh264mvc_put_timer_func(unsigned long arg);
 
 static const char vh264mvc_dec_id[] = "vh264mvc-dev";
 
 #define PROVIDER_NAME   "decoder.h264mvc"
 
+static struct vdec_info *gvs;
+static struct work_struct alloc_work;
+
+static DEFINE_MUTEX(vh264_mvc_mutex);
+
 static const struct vframe_operations_s vh264mvc_vf_provider = {
 	.peek = vh264mvc_vf_peek,
 	.get = vh264mvc_vf_get,
@@ -173,14 +182,19 @@ unsigned DECODE_BUFFER_END = 0x05000000;
 
 #define DECODE_BUFFER_NUM_MAX    16
 #define DISPLAY_BUFFER_NUM         4
+#define MAX_BMMU_BUFFER_NUM	(DECODE_BUFFER_NUM_MAX + DISPLAY_BUFFER_NUM)
+#define TOTAL_BMMU_BUFF_NUM     (MAX_BMMU_BUFFER_NUM * 2 + 3)
+#define VF_BUFFER_IDX(n) (2  + n)
+
+#define DECODER_WORK_SPACE_SIZE 0xa0000
+
 
 static unsigned int ANC_CANVAS_ADDR;
 static unsigned int index;
-static unsigned int dpb_start_addr[3];
-static unsigned int ref_start_addr[2];
+static unsigned long ref_start_addr[2];
 static unsigned int max_dec_frame_buffering[2];
 static unsigned int total_dec_frame_buffering[2];
-static unsigned int level_idc, max_reference_frame_num, mb_width, mb_height;
+
 static unsigned int dpb_size, ref_size;
 
 static int display_buff_id;
@@ -189,8 +203,7 @@ static int display_POC;
 static int stream_offset;
 
 #define video_domain_addr(adr) (adr&0x7fffffff)
-static unsigned work_space_adr;
-static unsigned work_space_size = 0xa0000;
+static unsigned long work_space_adr;
 
 struct buffer_spec_s {
 	unsigned int y_addr;
@@ -200,11 +213,14 @@ struct buffer_spec_s {
 	int y_canvas_index;
 	int u_canvas_index;
 	int v_canvas_index;
+
+	struct page *alloc_pages;
+	unsigned long phy_addr;
+	int alloc_count;
 };
-static struct buffer_spec_s buffer_spec0[DECODE_BUFFER_NUM_MAX +
-			DISPLAY_BUFFER_NUM];
-static struct buffer_spec_s buffer_spec1[DECODE_BUFFER_NUM_MAX +
-			DISPLAY_BUFFER_NUM];
+static struct buffer_spec_s buffer_spec0[MAX_BMMU_BUFFER_NUM];
+static struct buffer_spec_s buffer_spec1[MAX_BMMU_BUFFER_NUM];
+static void *mm_blk_handle;
 
 /*
     dbg_mode:
@@ -220,7 +236,7 @@ static int view_mode =
 static int drop_rate = 2;
 static int drop_thread_hold;
 /**/
-#define MVC_BUF_NUM     (DECODE_BUFFER_NUM_MAX+DISPLAY_BUFFER_NUM)
+
 struct mvc_buf_s {
 	struct list_head list;
 	struct vframe_s vframe;
@@ -518,65 +534,92 @@ static int vh264mvc_event_cb(int type, void *data, void *private_data)
 }
 
 /**/
-static long init_canvas(int start_addr, long dpb_size, int dpb_number,
-		int mb_width, int mb_height,
+static long init_canvas(int view_index, int refbuf_size, long dpb_size,
+		int dpb_number,	int mb_width, int mb_height,
 		struct buffer_spec_s *buffer_spec)
 {
 
-	int dpb_addr, addr;
-	int i;
-	int mb_total;
-
+	unsigned long addr;
+	int i, j, bmmu_index;
+	int mb_total, ret = -1;
 	/* cav_con canvas; */
+	mb_total = mb_width * mb_height;
+	mutex_lock(&vh264_mvc_mutex);
 
-	dpb_addr = start_addr;
+	for (j = 0; j < (dpb_number + 1); j++) {
+		int page_count;
+		if (j == 0) {
+			if (!view_index)
+				bmmu_index = 1;
+			else
+				bmmu_index =  dpb_number + 2;
 
-	mb_total = mb_width * mb_height;
+			ret = decoder_bmmu_box_alloc_buf_phy(mm_blk_handle,
+				bmmu_index, refbuf_size, DRIVER_NAME,
+				&ref_start_addr[view_index]);
+
+			if (ret < 0) {
+				mutex_unlock(&vh264_mvc_mutex);
+				return ret;
+			}
 
-	for (i = 0; i < dpb_number; i++) {
+			continue;
+		}
+		 /* canvas buf */
 		WRITE_VREG(ANC_CANVAS_ADDR,
 				index | ((index + 1) << 8) |
 				((index + 2) << 16));
 		ANC_CANVAS_ADDR++;
 
-		addr = dpb_addr;
+			i = j - 1;
+		if (!view_index)
+			bmmu_index = VF_BUFFER_IDX(i);
+		else
+			bmmu_index	= VF_BUFFER_IDX(i) + dpb_number + 1;
+#ifdef DOUBLE_WRITE
+		 page_count = PAGE_ALIGN((mb_total << 8) + (mb_total << 7) +
+				(mb_total << 6) + (mb_total << 5)) / PAGE_SIZE;
+#else
+		 page_count = PAGE_ALIGN((mb_total << 8) +
+				(mb_total << 7)) / PAGE_SIZE;
+#endif
+
+		ret = decoder_bmmu_box_alloc_buf_phy(mm_blk_handle,
+			bmmu_index, page_count << PAGE_SHIFT,
+			DRIVER_NAME, &buffer_spec[i].phy_addr);
+
+		if (ret < 0) {
+			buffer_spec[i].alloc_count = 0;
+			mutex_unlock(&vh264_mvc_mutex);
+			return ret;
+		}
+
+		addr = buffer_spec[i].phy_addr;
+		buffer_spec[i].alloc_count = page_count;
 		buffer_spec[i].y_addr = addr;
 		buffer_spec[i].y_canvas_index = index;
-		canvas_config(index,
-				addr,
-				mb_width << 4,
-				mb_height << 4,
-				CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_32X32);
+		canvas_config(index, addr,
+			mb_width << 4, mb_height << 4,
+			CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_32X32);
 
 		addr += mb_total << 8;
 		index++;
 		buffer_spec[i].u_addr = addr;
 		buffer_spec[i].u_canvas_index = index;
-		canvas_config(index,
-				addr,
-				mb_width << 3,
-				mb_height << 3,
+		canvas_config(index, addr, mb_width << 3, mb_height << 3,
 				CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_32X32);
 
 		addr += mb_total << 6;
 		index++;
 		buffer_spec[i].v_addr = addr;
 		buffer_spec[i].v_canvas_index = index;
-		canvas_config(index,
-				addr,
-				mb_width << 3,
-				mb_height << 3,
+		canvas_config(index, addr, mb_width << 3, mb_height << 3,
 				CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_32X32);
 
-		addr += mb_total << 6;
 		index++;
-
-		dpb_addr = dpb_addr + dpb_size;
-		if (dpb_addr >= DECODE_BUFFER_END)
-			return -1;
 	}
-
-	return dpb_addr;
+	mutex_unlock(&vh264_mvc_mutex);
+	return 0;
 }
 
 static int get_max_dec_frame_buf_size(int level_idc,
@@ -665,29 +708,19 @@ int check_in_list(int pos, int *slot)
 	return ret;
 }
 
-#ifdef HANDLE_h264mvc_IRQ
-static irqreturn_t vh264mvc_isr(int irq, void *dev_id)
-#else
-static void vh264mvc_isr(void)
-#endif
+static void do_alloc_work(struct work_struct *work)
 {
-	int drop_status;
-	struct vframe_s *vf;
-	unsigned int pts, pts_valid = 0;
-	u64 pts_us64;
+	int level_idc, max_reference_frame_num, mb_width, mb_height;
+	int refbuf_size;
 	int ret = READ_VREG(MAILBOX_COMMAND);
-	/* pr_info("vh264mvc_isr, cmd =%x\n", ret); */
+
 	switch (ret & 0xff) {
 	case CMD_ALLOC_VIEW_0:
 		if (dbg_mode & 0x1) {
 			pr_info
-			("Start H264 display buffer allocation for view 0\n");
-		}
-		if ((dpb_start_addr[0] != -1) | (dpb_start_addr[1] != -1)) {
-			dpb_start_addr[0] = -1;
-			dpb_start_addr[1] = -1;
+			("Start H264 display buffer for view 0\n");
 		}
-		dpb_start_addr[0] = DECODE_BUFFER_START;
+
 		ret = READ_VREG(MAILBOX_DATA_0);
 		level_idc = (ret >> 24) & 0xff;
 		max_reference_frame_num = (ret >> 16) & 0xff;
@@ -715,46 +748,33 @@ static void vh264mvc_isr(void)
 			pr_info("max_reference_frame_num: 0x%x\n",
 				   max_reference_frame_num);
 		}
-		ref_start_addr[0] = dpb_start_addr[0] +
-			(dpb_size * total_dec_frame_buffering[0]);
-		dpb_start_addr[1] = ref_start_addr[0] +
-			(ref_size * (max_reference_frame_num + 1));
-
-		if (dbg_mode & 0x1) {
-			pr_info("dpb_start_addr[0]: 0x%x\n", dpb_start_addr[0]);
-			pr_info("ref_start_addr[0]: 0x%x\n", ref_start_addr[0]);
-			pr_info("dpb_start_addr[1]: 0x%x\n", dpb_start_addr[1]);
-		}
-		if (dpb_start_addr[1] >= DECODE_BUFFER_END) {
-			pr_info(" No enough memory for alloc view 0\n");
-			goto exit;
-		}
+		refbuf_size
+			= ref_size * (max_reference_frame_num + 1) * 2;
 
 		index = CANVAS_INDEX_START;
 		ANC_CANVAS_ADDR = ANC0_CANVAS_ADDR;
 
 		ret =
-			init_canvas(dpb_start_addr[0], dpb_size,
-					total_dec_frame_buffering[0], mb_width,
-					mb_height, buffer_spec0);
+			init_canvas(0, refbuf_size, dpb_size,
+				total_dec_frame_buffering[0], mb_width,
+				mb_height, buffer_spec0);
 
-		if (ret == -1) {
+		if (ret < 0) {
 			pr_info(" Un-expected memory alloc problem\n");
-			goto exit;
+			return;
 		}
 
 		WRITE_VREG(REF_START_VIEW_0,
 				   video_domain_addr(ref_start_addr[0]));
 		WRITE_VREG(MAILBOX_DATA_0,
-				   (max_dec_frame_buffering[0] << 8) |
-				   (total_dec_frame_buffering[0] << 0)
-				  );
+			   (max_dec_frame_buffering[0] << 8) |
+			   (total_dec_frame_buffering[0] << 0));
 		WRITE_VREG(MAILBOX_DATA_1, ref_size);
 		WRITE_VREG(MAILBOX_COMMAND, CMD_FINISHED);
 
 		if (dbg_mode & 0x1) {
 			pr_info
-			("End H264 display buffer allocation for view 0\n");
+			("End H264 display buffer for view 0\n");
 		}
 		if (frame_width == 0) {
 			if (vh264mvc_amstream_dec_info.width)
@@ -771,12 +791,9 @@ static void vh264mvc_isr(void)
 	case CMD_ALLOC_VIEW_1:
 		if (dbg_mode & 0x1) {
 			pr_info
-			("Start H264 display buffer allocation for view 1\n");
-		}
-		if ((dpb_start_addr[0] == -1) | (dpb_start_addr[1] == -1)) {
-			pr_info("Error: allocation view 1 before view 0 !!!\n");
-			break;
+			("Start H264 display buffer for view 1\n");
 		}
+
 		ret = READ_VREG(MAILBOX_DATA_0);
 		level_idc = (ret >> 24) & 0xff;
 		max_reference_frame_num = (ret >> 16) & 0xff;
@@ -803,7 +820,7 @@ static void vh264mvc_isr(void)
 
 		dpb_size = mb_width * mb_height * 384;
 		ref_size = mb_width * mb_height * 96;
-
+		refbuf_size = ref_size * (max_reference_frame_num + 1) * 2;
 		if (dbg_mode & 0x1) {
 			pr_info("dpb_size: 0x%x\n", dpb_size);
 			pr_info("ref_size: 0x%x\n", ref_size);
@@ -812,47 +829,31 @@ static void vh264mvc_isr(void)
 			pr_info("max_reference_frame_num: 0x%x\n",
 				   max_reference_frame_num);
 		}
-		ref_start_addr[1] = dpb_start_addr[1] +
-			(dpb_size * total_dec_frame_buffering[1]);
-		dpb_start_addr[2] = ref_start_addr[1] +
-			(ref_size * (max_reference_frame_num + 1));
-
-		if (dbg_mode & 0x1) {
-			pr_info("dpb_start_addr[1]: 0x%x\n", dpb_start_addr[1]);
-			pr_info("ref_start_addr[1]: 0x%x\n", ref_start_addr[1]);
-			pr_info("dpb_start_addr[2]: 0x%x\n", dpb_start_addr[2]);
-		}
-		if (dpb_start_addr[2] >= DECODE_BUFFER_END) {
-			pr_info(" No enough memory for alloc view 1\n");
-			goto exit;
-		}
 
 		index = CANVAS_INDEX_START + total_dec_frame_buffering[0] * 3;
 		ANC_CANVAS_ADDR =
 			ANC0_CANVAS_ADDR + total_dec_frame_buffering[0];
 
-		ret =
-			init_canvas(dpb_start_addr[1], dpb_size,
-					total_dec_frame_buffering[1], mb_width,
-					mb_height, buffer_spec1);
+		ret = init_canvas(1, refbuf_size, dpb_size,
+				total_dec_frame_buffering[1], mb_width,
+				mb_height, buffer_spec1);
 
-		if (ret == -1) {
+		if (ret < 0) {
 			pr_info(" Un-expected memory alloc problem\n");
-			goto exit;
+			return;
 		}
 
 		WRITE_VREG(REF_START_VIEW_1,
 				   video_domain_addr(ref_start_addr[1]));
 		WRITE_VREG(MAILBOX_DATA_0,
-				   (max_dec_frame_buffering[1] << 8) |
-				   (total_dec_frame_buffering[1] << 0)
-				  );
+			   (max_dec_frame_buffering[1] << 8) |
+			   (total_dec_frame_buffering[1] << 0));
 		WRITE_VREG(MAILBOX_DATA_1, ref_size);
 		WRITE_VREG(MAILBOX_COMMAND, CMD_FINISHED);
 
 		if (dbg_mode & 0x1) {
 			pr_info
-			("End H264 display buffer allocation for view 1\n");
+			("End H264 buffer allocation for view 1\n");
 		}
 		if (frame_width == 0) {
 			if (vh264mvc_amstream_dec_info.width)
@@ -865,6 +866,28 @@ static void vh264mvc_isr(void)
 			if (frame_height == 1088)
 				frame_height = 1080;
 		}
+	break;
+	}
+
+}
+
+
+#ifdef HANDLE_h264mvc_IRQ
+static irqreturn_t vh264mvc_isr(int irq, void *dev_id)
+#else
+static void vh264mvc_isr(void)
+#endif
+{
+	int drop_status;
+	struct vframe_s *vf;
+	unsigned int pts, pts_valid = 0;
+	u64 pts_us64;
+	int ret = READ_VREG(MAILBOX_COMMAND);
+	/* pr_info("vh264mvc_isr, cmd =%x\n", ret); */
+	switch (ret & 0xff) {
+	case CMD_ALLOC_VIEW_0:
+	case CMD_ALLOC_VIEW_1:
+		schedule_work(&alloc_work);
 		break;
 	case CMD_FRAME_DISPLAY:
 		ret = READ_VREG(MAILBOX_DATA_0);
@@ -961,14 +984,24 @@ static void vh264mvc_isr(void)
 						drop_status;
 				}
 				vf = &vfpool[slot];
-#if 0
-				if (pts_lookup_offset
-					(PTS_TYPE_VIDEO,
-					 vfpool_idx[slot].stream_offset,
-					 &vf->pts,
-					 0) != 0)
-					vf->pts = 0;
-#endif
+
+				if (display_view_id == 0) {
+					vf->mem_handle =
+					decoder_bmmu_box_get_mem_handle(
+						mm_blk_handle,
+						VF_BUFFER_IDX(display_buff_id));
+
+				} else if (display_view_id == 1) {
+					vf->mem_handle =
+					decoder_bmmu_box_get_mem_handle(
+						mm_blk_handle,
+						VF_BUFFER_IDX(display_buff_id)
+						+ total_dec_frame_buffering[0]
+						+ 1);
+				}
+
+
+
 				if (vfpool_idx[slot].stream_offset == 0) {
 					pr_info
 					("error case, invalid stream offset\n");
@@ -990,6 +1023,11 @@ static void vh264mvc_isr(void)
 				vfpool_idx[slot].used = 1;
 				INCPTR(fill_ptr);
 				set_frame_info(vf);
+
+				gvs->frame_dur = frame_dur;
+				vdec_count_info(gvs, 0,
+						vfpool_idx[slot].stream_offset);
+
 				vf_notify_receiver(PROVIDER_NAME,
 					VFRAME_EVENT_PROVIDER_VFRAME_READY,
 					NULL);
@@ -1004,7 +1042,6 @@ static void vh264mvc_isr(void)
 	default:
 		break;
 	}
-exit:
 #ifdef HANDLE_h264mvc_IRQ
 	return IRQ_HANDLED;
 #else
@@ -1075,16 +1112,39 @@ static void vh264mvc_put_timer_func(unsigned long arg)
 	add_timer(timer);
 }
 
-int vh264mvc_dec_status(struct vdec_s *vdec, struct vdec_status *vstatus)
+int vh264mvc_dec_status(struct vdec_s *vdec, struct vdec_info *vstatus)
 {
-	vstatus->width = frame_width;
-	vstatus->height = frame_height;
+	vstatus->frame_width = frame_width;
+	vstatus->frame_height = frame_height;
 	if (frame_dur != 0)
-		vstatus->fps = 96000 / frame_dur;
+		vstatus->frame_rate = 96000 / frame_dur;
 	else
-		vstatus->fps = -1;
+		vstatus->frame_rate = -1;
 	vstatus->error_count = READ_VREG(AV_SCRATCH_D);
 	vstatus->status = stat;
+	vstatus->bit_rate = gvs->bit_rate;
+	vstatus->frame_dur = frame_dur;
+	vstatus->frame_data = gvs->frame_data;
+	vstatus->total_data = gvs->total_data;
+	vstatus->frame_count = gvs->frame_count;
+	vstatus->error_frame_count = gvs->error_frame_count;
+	vstatus->drop_frame_count = gvs->drop_frame_count;
+	vstatus->total_data = gvs->total_data;
+	vstatus->samp_cnt = gvs->samp_cnt;
+	vstatus->offset = gvs->offset;
+	snprintf(vstatus->vdec_name, sizeof(vstatus->vdec_name),
+		"%s", DRIVER_NAME);
+
+	return 0;
+}
+
+static int vh264mvc_vdec_info_init(void)
+{
+	gvs = kzalloc(sizeof(struct vdec_info), GFP_KERNEL);
+	if (NULL == gvs) {
+		pr_info("the struct of vdec status malloc failed.\n");
+		return -ENOMEM;
+	}
 	return 0;
 }
 
@@ -1126,12 +1186,12 @@ static void H264_DECODE_INIT(void)
 	READ_VREG(DOS_SW_RESET0);
 
 #else
-	WRITE_MPEG_REG(RESET0_REGISTER,
+	WRITE_RESET_REG(RESET0_REGISTER,
 				   RESET_IQIDCT | RESET_MC | RESET_VLD_PART);
-	READ_MPEG_REG(RESET0_REGISTER);
-	WRITE_MPEG_REG(RESET0_REGISTER,
+	READ_RESET_REG(RESET0_REGISTER);
+	WRITE_RESET_REG(RESET0_REGISTER,
 				   RESET_IQIDCT | RESET_MC | RESET_VLD_PART);
-	WRITE_MPEG_REG(RESET2_REGISTER, RESET_PIC_DC | RESET_DBLK);
+	WRITE_RESET_REG(RESET2_REGISTER, RESET_PIC_DC | RESET_DBLK);
 #endif
 
 	/* Wait for some time for RESET */
@@ -1231,7 +1291,7 @@ static void vh264mvc_prot_init(void)
 	READ_VREG(DOS_SW_RESET0);
 
 #else
-	WRITE_MPEG_REG(RESET0_REGISTER, 0x80);	/* RESET MCPU */
+	WRITE_RESET_REG(RESET0_REGISTER, 0x80);	/* RESET MCPU */
 #endif
 
 	WRITE_VREG(MAILBOX_COMMAND, 0);
@@ -1243,9 +1303,9 @@ static void vh264mvc_prot_init(void)
 #endif
 }
 
-static void vh264mvc_local_init(void)
+static int vh264mvc_local_init(void)
 {
-	int i;
+	int i, size, ret;
 	display_buff_id = -1;
 	display_view_id = -1;
 	display_POC = -1;
@@ -1277,9 +1337,8 @@ static void vh264mvc_local_init(void)
 	pts_outside = ((unsigned long) vh264mvc_amstream_dec_info.param) & 0x01;
 	sync_outside = ((unsigned long) vh264mvc_amstream_dec_info.param & 0x02)
 			>> 1;
+	INIT_WORK(&alloc_work, do_alloc_work);
 
-	/**/ dpb_start_addr[0] = -1;
-	dpb_start_addr[1] = -1;
 	max_dec_frame_buffering[0] = -1;
 	max_dec_frame_buffering[1] = -1;
 	fill_ptr = get_ptr = put_ptr = putting_ptr = 0;
@@ -1300,7 +1359,25 @@ static void vh264mvc_local_init(void)
 	for (i = 0; i < VF_POOL_SIZE; i++)
 		memset(&vfpool[i], 0, sizeof(struct vframe_s));
 	init_vf_buf();
-	return;
+
+	if (mm_blk_handle) {
+		decoder_bmmu_box_free(mm_blk_handle);
+		mm_blk_handle = NULL;
+	}
+
+	mm_blk_handle = decoder_bmmu_box_alloc_box(
+		DRIVER_NAME,
+		0,
+		TOTAL_BMMU_BUFF_NUM,
+		4 + PAGE_SHIFT,
+		CODEC_MM_FLAGS_CMA_CLEAR |
+		CODEC_MM_FLAGS_FOR_VDECODER);
+
+	size = DECODER_WORK_SPACE_SIZE;
+	ret = decoder_bmmu_box_alloc_buf_phy(mm_blk_handle, 0,
+		size, DRIVER_NAME, &work_space_adr);
+
+	return ret;
 }
 
 static s32 vh264mvc_init(void)
@@ -1315,7 +1392,13 @@ static s32 vh264mvc_init(void)
 
 	stat |= STAT_TIMER_INIT;
 
-	vh264mvc_local_init();
+	ret = vh264mvc_vdec_info_init();
+	if (0 != ret)
+		return -ret;
+
+	ret = vh264mvc_local_init();
+	if (ret < 0)
+		return ret;
 
 	amvdec_enable();
 
@@ -1436,6 +1519,10 @@ static int vh264mvc_stop(void)
 
 	amvdec_disable();
 
+	if (mm_blk_handle) {
+		decoder_bmmu_box_free(mm_blk_handle);
+		mm_blk_handle = NULL;
+	}
 	uninit_vf_buf();
 	return 0;
 }
@@ -1450,12 +1537,10 @@ static void error_do_work(struct work_struct *work)
 
 static int amvdec_h264mvc_probe(struct platform_device *pdev)
 {
-	struct resource mem;
-	int buf_size;
-
 	struct vdec_s *pdata = *(struct vdec_s **)pdev->dev.platform_data;
 
 	pr_info("amvdec_h264mvc probe start.\n");
+	mutex_lock(&vh264_mvc_mutex);
 
 #if 0
 	mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
@@ -1466,21 +1551,11 @@ static int amvdec_h264mvc_probe(struct platform_device *pdev)
 #endif
 
 	if (pdata == NULL) {
+		mutex_unlock(&vh264_mvc_mutex);
 		pr_info("\namvdec_h264mvc memory resource undefined.\n");
 		return -EFAULT;
 	}
-	mem.start = pdata->mem_start;
-	mem.end = pdata->mem_end;
 
-	buf_size = mem.end - mem.start + 1;
-	/* buf_offset = mem->start - DEF_BUF_START_ADDR; */
-	work_space_adr = mem.start;
-	DECODE_BUFFER_START = work_space_adr + work_space_size;
-	DECODE_BUFFER_END = mem.start + buf_size;
-
-	pr_info
-	("work_space_adr %x, DECODE_BUFFER_START %x, DECODE_BUFFER_END %x\n",
-	 work_space_adr, DECODE_BUFFER_START, DECODE_BUFFER_END);
 	if (pdata->sys_info)
 		vh264mvc_amstream_dec_info = *pdata->sys_info;
 
@@ -1489,7 +1564,9 @@ static int amvdec_h264mvc_probe(struct platform_device *pdev)
 
 	if (vh264mvc_init() < 0) {
 		pr_info("\namvdec_h264mvc init failed.\n");
-
+		kfree(gvs);
+		gvs = NULL;
+		mutex_unlock(&vh264_mvc_mutex);
 		return -ENODEV;
 	}
 
@@ -1497,6 +1574,8 @@ static int amvdec_h264mvc_probe(struct platform_device *pdev)
 
 	atomic_set(&vh264mvc_active, 1);
 
+	mutex_unlock(&vh264_mvc_mutex);
+
 	pr_info("amvdec_h264mvc probe end.\n");
 
 	return 0;
@@ -1505,6 +1584,7 @@ static int amvdec_h264mvc_probe(struct platform_device *pdev)
 static int amvdec_h264mvc_remove(struct platform_device *pdev)
 {
 	pr_info("amvdec_h264mvc_remove\n");
+	cancel_work_sync(&alloc_work);
 	cancel_work_sync(&error_wd_work);
 	vh264mvc_stop();
 	frame_width = 0;
@@ -1523,6 +1603,8 @@ static int amvdec_h264mvc_remove(struct platform_device *pdev)
 #ifdef DEBUG_SKIP
 	pr_info("view_total = %ld, dropped %ld\n", view_total, view_dropped);
 #endif
+	kfree(gvs);
+	gvs = NULL;
 
 	return 0;
 }
@@ -1545,6 +1627,15 @@ static struct codec_profile_t amvdec_hmvc_profile = {
 	.name = "hmvc",
 	.profile = ""
 };
+static struct mconfig h264mvc_configs[] = {
+	MC_PU32("stat", &stat),
+	MC_PU32("dbg_mode", &dbg_mode),
+	MC_PU32("view_mode", &view_mode),
+	MC_PU32("dbg_cmd", &dbg_cmd),
+	MC_PU32("drop_rate", &drop_rate),
+	MC_PU32("drop_thread_hold", &drop_thread_hold),
+};
+static struct mconfig_node h264mvc_node;
 
 static int __init amvdec_h264mvc_driver_init_module(void)
 {
@@ -1556,7 +1647,8 @@ static int __init amvdec_h264mvc_driver_init_module(void)
 	}
 
 	vcodec_profile_register(&amvdec_hmvc_profile);
-
+	INIT_REG_NODE_CONFIGS("media.decoder", &h264mvc_node,
+		"h264mvc", h264mvc_configs, CONFIG_FOR_RW);
 	return 0;
 }
 
diff --git a/drivers/frame_provider/decoder/h264_multi/h264_dpb.c b/drivers/frame_provider/decoder/h264_multi/h264_dpb.c
index b3e8f0f..f266d08 100644
--- a/drivers/frame_provider/decoder/h264_multi/h264_dpb.c
+++ b/drivers/frame_provider/decoder/h264_multi/h264_dpb.c
@@ -8,7 +8,6 @@
 
 #include "h264_dpb.h"
 
-/* #define OLD_OUTPUT_CODE */
 #undef pr_info
 #define pr_info printk
 int dpb_print(int index, int debug_flag, const char *fmt, ...)
@@ -20,8 +19,23 @@ int dpb_print(int index, int debug_flag, const char *fmt, ...)
 		int len = 0;
 		va_list args;
 		va_start(args, fmt);
-		if ((index & 0x100) == 0)
-			len = sprintf(buf, "%d: ", index);
+		len = sprintf(buf, "%d: ", index);
+		vsnprintf(buf + len, 512-len, fmt, args);
+		pr_info("%s", buf);
+		va_end(args);
+	}
+	return 0;
+}
+
+int dpb_print_cont(int index, int debug_flag, const char *fmt, ...)
+{
+	if (((h264_debug_flag & debug_flag) &&
+		((1 << index) & h264_debug_mask))
+		|| (debug_flag == PRINT_FLAG_ERROR)) {
+		unsigned char buf[512];
+		int len = 0;
+		va_list args;
+		va_start(args, fmt);
 		vsnprintf(buf + len, 512-len, fmt, args);
 		pr_info("%s", buf);
 		va_end(args);
@@ -55,7 +69,6 @@ static struct FrameStore dummy_fs;
 static struct StorablePicture *get_new_pic(
 	struct h264_dpb_stru *p_H264_Dpb,
 	enum PictureStructure structure, unsigned char is_output);
-static void dump_dpb(struct DecodedPictureBuffer *p_Dpb);
 
 static void init_dummy_fs(void)
 {
@@ -336,7 +349,7 @@ void slice_prepare(struct h264_dpb_stru *p_H264_Dpb,
 		FRAME : p_H264_Dpb->dpb_param.l.data[NEW_PICTURE_STRUCTURE];
 	sps->num_ref_frames = p_H264_Dpb->
 		dpb_param.l.data[MAX_REFERENCE_FRAME_NUM];
-	sps->max_dpb_size = p_H264_Dpb->dpb_param.l.data[MAX_DPB_SIZE];
+	/*sps->max_dpb_size = p_H264_Dpb->dpb_param.l.data[MAX_DPB_SIZE];*/
 	if (pSlice->idr_flag) {
 		pSlice->long_term_reference_flag = mmco_cmd[0] & 1;
 		pSlice->no_output_of_prior_pics_flag = (mmco_cmd[0] >> 1) & 1;
@@ -352,6 +365,11 @@ void slice_prepare(struct h264_dpb_stru *p_H264_Dpb,
 		p_Vid->pre_frame_num, pSlice->frame_num);
 
 		p_Vid->pre_frame_num = pSlice->frame_num;
+	} else if (p_H264_Dpb->mDPB.first_pic_done == 0) {
+		/* by rain
+		 handle the case when first slice is I instead of IDR
+		*/
+		p_Vid->pre_frame_num = pSlice->frame_num;
 	}
 	/* pSlice->adaptive_ref_pic_buffering_flag; */
 	sps->log2_max_frame_num_minus4 =
@@ -387,20 +405,22 @@ void slice_prepare(struct h264_dpb_stru *p_H264_Dpb,
 
 	pSlice->p_Vid = p_Vid;
 	pSlice->p_Dpb = p_Dpb;
-
+	/*
 	p_H264_Dpb->colocated_buf_size =
-		p_H264_Dpb->dpb_param.l.data[FRAME_SIZE_IN_MB] * 96;
+		p_H264_Dpb->dpb_param.l.data[FRAME_SIZE_IN_MB] * 96;*/
 	pSlice->first_mb_in_slice =
 		p_H264_Dpb->dpb_param.l.data[FIRST_MB_IN_SLICE];
 	pSlice->mode_8x8_flags = p_H264_Dpb->dpb_param.l.data[MODE_8X8_FLAGS];
 	pSlice->picture_structure_mmco =
 		p_H264_Dpb->dpb_param.dpb.picture_structure_mmco;
 	dpb_print(p_H264_Dpb->decoder_index, PRINT_FLAG_DPB_DETAIL,
-		  "%s slice_type is %d, num_ref_idx_active[0]=%d, num_ref_idx_active[1]=%d nal_reference_idc %d\n",
+	"%s slice_type is %d, num_ref_idx_active[0,1]=%d,%d nal_reference_idc %d pic struct 0x%x(mmco stru 0x%x)\n",
 		  __func__, pSlice->slice_type,
 		  pSlice->num_ref_idx_active[LIST_0],
 		  pSlice->num_ref_idx_active[LIST_1],
-		  pSlice->nal_reference_idc);
+		  pSlice->nal_reference_idc,
+		  pSlice->structure,
+		  pSlice->picture_structure_mmco);
 #ifdef ERROR_CHECK
 	if (pSlice->num_ref_idx_active[LIST_0] >= MAX_LIST_SIZE)
 		pSlice->num_ref_idx_active[LIST_0] = MAX_LIST_SIZE - 1;
@@ -457,6 +477,23 @@ void slice_prepare(struct h264_dpb_stru *p_H264_Dpb,
 
 	ref_pic_list_reordering(p_H264_Dpb, pSlice);
 #endif
+
+	/*VUI*/
+	p_H264_Dpb->vui_status = p_H264_Dpb->dpb_param.l.data[VUI_STATUS];
+	p_H264_Dpb->aspect_ratio_idc =
+		p_H264_Dpb->dpb_param.l.data[ASPECT_RATIO_IDC];
+	p_H264_Dpb->aspect_ratio_sar_width =
+		p_H264_Dpb->dpb_param.l.data[ASPECT_RATIO_SAR_WIDTH];
+	p_H264_Dpb->aspect_ratio_sar_height =
+		p_H264_Dpb->dpb_param.l.data[ASPECT_RATIO_SAR_HEIGHT];
+
+	p_H264_Dpb->fixed_frame_rate_flag = p_H264_Dpb->dpb_param.l.data[
+		FIXED_FRAME_RATE_FLAG];
+	p_H264_Dpb->num_units_in_tick =
+		p_H264_Dpb->dpb_param.l.data[NUM_UNITS_IN_TICK];
+	p_H264_Dpb->time_scale = p_H264_Dpb->dpb_param.l.data[TIME_SCALE] |
+		(p_H264_Dpb->dpb_param.l.data[TIME_SCALE + 1] << 16);
+	/**/
 	dpb_print(p_H264_Dpb->decoder_index, PRINT_FLAG_DPB_DETAIL,
 		"%s return\n", __func__);
 }
@@ -781,8 +818,8 @@ void fill_frame_num_gap(struct VideoParameters *p_Vid, struct Slice *currSlice)
 				PRINT_FLAG_ERROR,
 				"%s Error: get_new_pic return NULL\r\n",
 				__func__);
-			h264_debug_flag |= PRINT_FLAG_DUMP_DPB;
-			dump_dpb(p_Dpb);
+			/*h264_debug_flag |= PRINT_FLAG_DUMP_DPB;*/
+			dump_dpb(p_Dpb, 0);
 			return;
 		}
 
@@ -810,7 +847,7 @@ void fill_frame_num_gap(struct VideoParameters *p_Vid, struct Slice *currSlice)
 		picture->frame_poc  = currSlice->framepoc;
 		picture->poc        = currSlice->framepoc;
 
-		store_picture_in_dpb(p_H264_Dpb, picture);
+		store_picture_in_dpb(p_H264_Dpb, picture, 0);
 
 		picture = NULL;
 		p_Vid->pre_frame_num = UnusedShortTermFrameNum;
@@ -852,6 +889,7 @@ void dpb_init_global(struct h264_dpb_stru *p_H264_Dpb,
     (in DECODE_STATE_IDLE or DECODE_STATE_READY state) */
 	p_H264_Dpb->mDPB.size = actual_dpb_size;
 	p_H264_Dpb->max_reference_size = max_reference_size;
+	p_H264_Dpb->poc_even_odd_flag = 0;
 }
 
 static void init_picture(struct h264_dpb_stru *p_H264_Dpb,
@@ -1017,6 +1055,9 @@ static struct StorablePicture *get_new_pic(struct h264_dpb_stru *p_H264_Dpb,
 static void free_picture(struct h264_dpb_stru *p_H264_Dpb,
 			 struct StorablePicture *pic)
 {
+	if (pic == NULL || pic->index < 0 ||
+		pic->index >= MAX_PIC_BUF_NUM)
+		return;
 	dpb_print(p_H264_Dpb->decoder_index, PRINT_FLAG_DPB_DETAIL,
 			"%s %p %d\n", __func__, pic, pic->index);
 	/* assert(pic->index<MAX_PIC_BUF_NUM); */
@@ -1083,10 +1124,15 @@ static void init_dpb(struct h264_dpb_stru *p_H264_Dpb, int type)
 	p_Dpb->num_ref_frames = active_sps->num_ref_frames;
 	/* p_Dpb->num_ref_frames initialzie in vh264.c */
 	dpb_print(p_H264_Dpb->decoder_index, PRINT_FLAG_DPB_DETAIL,
-		  "%s dpb_size is %d (%d) num_ref_frames = %d (%d)\n",
-		  __func__, p_Dpb->size, active_sps->max_dpb_size,
+		  "%s dpb_size is %d  num_ref_frames = %d (%d)\n",
+		  __func__, p_Dpb->size,
 		  p_Dpb->num_ref_frames,
 		  active_sps->num_ref_frames);
+	if (active_sps->num_ref_frames == 0xffff) {
+		dpb_print(p_H264_Dpb->decoder_index, 0,
+		  "!!!Warning, num_ref_frames = %d is invalid\n",
+		  active_sps->num_ref_frames);
+	}
 
 #if 0
 	/* ??? */
@@ -1230,6 +1276,9 @@ static void dpb_split_field(struct h264_dpb_stru *p_H264_Dpb,
 
 		fs_top->colocated_buf_index = frame->colocated_buf_index;
 		fs_btm->colocated_buf_index = frame->colocated_buf_index;
+
+		fs_top->data_flag = frame->data_flag;
+		fs_btm->data_flag = frame->data_flag;
 #endif
 		fs_top->poc = frame->top_poc;
 		fs_btm->poc = frame->bottom_poc;
@@ -1307,6 +1356,9 @@ static void dpb_combine_field(struct h264_dpb_stru *p_H264_Dpb,
 /* rain */
 	fs->frame->buf_spec_num = fs->top_field->buf_spec_num;
 	fs->frame->colocated_buf_index = fs->top_field->colocated_buf_index;
+	fs->frame->data_flag = fs->top_field->data_flag;
+	if (fs->bottom_field)
+		fs->frame->data_flag |= (fs->bottom_field->data_flag & 0xf0);
 #endif
 
 
@@ -1383,7 +1435,8 @@ static void calculate_frame_no(struct VideoParameters *p_Vid,
 
 static void insert_picture_in_dpb(struct h264_dpb_stru *p_H264_Dpb,
 				  struct FrameStore *fs,
-				  struct StorablePicture *p)
+				  struct StorablePicture *p,
+				  unsigned char data_flag)
 {
 	struct VideoParameters *p_Vid = &p_H264_Dpb->mVideo;
 	/* InputParameters *p_Inp = p_Vid->p_Inp;
@@ -1399,6 +1452,8 @@ static void insert_picture_in_dpb(struct h264_dpb_stru *p_H264_Dpb,
 #if 1
 /* rain */
 /* p->buf_spec_num = fs->index; */
+	p->data_flag = data_flag;
+	fs->data_flag = data_flag;
 	fs->buf_spec_num = p->buf_spec_num;
 	fs->colocated_buf_index = p->colocated_buf_index;
 #endif
@@ -1590,6 +1645,11 @@ static void update_pic_num(struct Slice *currSlice)
 
 	if (currSlice->structure == FRAME) {
 		for (i = 0; i < p_Dpb->ref_frames_in_buffer; i++) {
+#ifdef ERROR_CHECK
+			if (p_Dpb->fs_ref[i] == NULL ||
+				p_Dpb->fs_ref[i]->frame == NULL)
+				continue;
+#endif
 			if (p_Dpb->fs_ref[i]->is_used == 3) {
 				if ((p_Dpb->fs_ref[i]->frame->
 					used_for_reference) &&
@@ -1613,6 +1673,11 @@ static void update_pic_num(struct Slice *currSlice)
 		}
 		/* update long_term_pic_num */
 		for (i = 0; i < p_Dpb->ltref_frames_in_buffer; i++) {
+#ifdef ERROR_CHECK
+			if (p_Dpb->fs_ltref[i] == NULL ||
+				p_Dpb->fs_ltref[i]->frame == NULL)
+				continue;
+#endif
 			if (p_Dpb->fs_ltref[i]->is_used == 3) {
 				if (p_Dpb->fs_ltref[i]->frame->is_long_term) {
 					p_Dpb->fs_ltref[i]->frame->
@@ -1632,6 +1697,10 @@ static void update_pic_num(struct Slice *currSlice)
 		}
 
 		for (i = 0; i < p_Dpb->ref_frames_in_buffer; i++) {
+#ifdef ERROR_CHECK
+			if (p_Dpb->fs_ref[i] == NULL)
+				continue;
+#endif
 			if (p_Dpb->fs_ref[i]->is_reference) {
 				if (p_Dpb->fs_ref[i]->frame_num > currSlice->
 					frame_num) {
@@ -1643,11 +1712,20 @@ static void update_pic_num(struct Slice *currSlice)
 					p_Dpb->fs_ref[i]->frame_num;
 				}
 				if (p_Dpb->fs_ref[i]->is_reference & 1) {
+#ifdef ERROR_CHECK
+					if (p_Dpb->fs_ref[i]->top_field == NULL)
+						continue;
+#endif
 					p_Dpb->fs_ref[i]->top_field->
 					pic_num = (2 * p_Dpb->fs_ref[i]->
 						frame_num_wrap) + add_top;
 				}
 				if (p_Dpb->fs_ref[i]->is_reference & 2) {
+#ifdef ERROR_CHECK
+					if (p_Dpb->fs_ref[i]->bottom_field
+						== NULL)
+						continue;
+#endif
 					p_Dpb->fs_ref[i]->bottom_field->
 					pic_num = (2 * p_Dpb->fs_ref[i]->
 						frame_num_wrap) + add_bottom;
@@ -1656,13 +1734,25 @@ static void update_pic_num(struct Slice *currSlice)
 		}
 		/* update long_term_pic_num */
 		for (i = 0; i < p_Dpb->ltref_frames_in_buffer; i++) {
+#ifdef ERROR_CHECK
+			if (p_Dpb->fs_ltref[i] == NULL)
+				continue;
+#endif
 			if (p_Dpb->fs_ltref[i]->is_long_term & 1) {
+#ifdef ERROR_CHECK
+				if (p_Dpb->fs_ltref[i]->top_field == NULL)
+					continue;
+#endif
 				p_Dpb->fs_ltref[i]->top_field->
 					long_term_pic_num = 2 *
 					p_Dpb->fs_ltref[i]->top_field->
 					long_term_frame_idx + add_top;
 			}
 			if (p_Dpb->fs_ltref[i]->is_long_term & 2) {
+#ifdef ERROR_CHECK
+				if (p_Dpb->fs_ltref[i]->bottom_field == NULL)
+					continue;
+#endif
 				p_Dpb->fs_ltref[i]->bottom_field->
 					long_term_pic_num = 2 *
 					p_Dpb->fs_ltref[i]->bottom_field->
@@ -1785,20 +1875,77 @@ static int remove_unused_frame_from_dpb(struct h264_dpb_stru *p_H264_Dpb)
 	return 0;
 }
 
-void bufmgr_h264_remove_unused_frame(struct h264_dpb_stru *p_H264_Dpb)
+
+static int unmark_one_error_out_frame(struct h264_dpb_stru *p_H264_Dpb)
+{
+	int ret = 0;
+	unsigned i;
+	struct DecodedPictureBuffer *p_Dpb = &p_H264_Dpb->mDPB;
+
+	for (i = 0; i < p_Dpb->used_size; i++) {
+		if (p_Dpb->fs[i]->is_output &&
+			((p_Dpb->fs[i]->data_flag & ERROR_FLAG) ||
+			(p_Dpb->fs[i]->data_flag & NULL_FLAG))
+			) {
+			unmark_for_reference(p_Dpb, p_Dpb->fs[i]);
+
+			ret = 1;
+		}
+	}
+	return ret;
+}
+
+static int unmark_one_out_frame(struct h264_dpb_stru *p_H264_Dpb)
+{
+	int ret = 0;
+	unsigned i;
+	struct DecodedPictureBuffer *p_Dpb = &p_H264_Dpb->mDPB;
+
+	for (i = 0; i < p_Dpb->used_size; i++) {
+		if (p_Dpb->fs[i]->is_output) {
+			unmark_for_reference(p_Dpb, p_Dpb->fs[i]);
+
+			ret = 1;
+		}
+	}
+	return ret;
+}
+/*
+	force_flag,
+		1, remove one error buf (is_out is 1) if there is no un-used buf
+		2, remove one buf (is_out is 1) if there is no un-used buf
+*/
+void bufmgr_h264_remove_unused_frame(struct h264_dpb_stru *p_H264_Dpb,
+	u8 force_flag)
 {
 	struct DecodedPictureBuffer *p_Dpb = &p_H264_Dpb->mDPB;
 	int ret = 0;
-	unsigned char print_flag = 0;
+	unsigned char removed_flag = 0;
 	do {
 		ret = remove_unused_frame_from_dpb(p_H264_Dpb);
 		if (ret != 0)
-			print_flag = 1;
+			removed_flag = 1;
 	} while (ret != 0);
-	if (print_flag) {
+	if (removed_flag) {
 		dpb_print(p_H264_Dpb->decoder_index,
 			PRINT_FLAG_DPB_DETAIL, "%s\r\n", __func__);
-		dump_dpb(p_Dpb);
+		dump_dpb(p_Dpb, 0);
+	} else if (force_flag == 2) {
+		if (unmark_one_out_frame(p_H264_Dpb)) {
+			dpb_print(p_H264_Dpb->decoder_index,
+				0, "%s, Warnning, force unmark one frame\r\n",
+				__func__);
+			remove_unused_frame_from_dpb(p_H264_Dpb);
+			dump_dpb(p_Dpb, 0);
+		}
+	} else if (force_flag == 1) {
+		if (unmark_one_error_out_frame(p_H264_Dpb)) {
+			dpb_print(p_H264_Dpb->decoder_index,
+				0, "%s, unmark error frame\r\n",
+				__func__);
+			remove_unused_frame_from_dpb(p_H264_Dpb);
+			dump_dpb(p_Dpb, 0);
+		}
 	}
 }
 
@@ -1850,115 +1997,46 @@ static void get_smallest_poc(struct DecodedPictureBuffer *p_Dpb, int *poc,
 	}
 }
 
-#ifdef OLD_OUTPUT_CODE
-static int output_one_frame_from_dpb(struct h264_dpb_stru *p_H264_Dpb)
-{
-	struct DecodedPictureBuffer *p_Dpb = &p_H264_Dpb->mDPB;
-	struct VideoParameters *p_Vid = &p_H264_Dpb->mVideo;
-	int poc, pos;
-	/* diagnostics */
-	dpb_print(p_H264_Dpb->decoder_index, PRINT_FLAG_DPB_DETAIL,
-		"%s\n", __func__);
-
-	if (p_Dpb->used_size < 1) {
-		dpb_print(p_H264_Dpb->decoder_index, PRINT_FLAG_DPB_DETAIL,
-			  "Cannot output frame, DPB empty. %d\n", 150);
-	}
-
-	/* find smallest POC */
-	get_smallest_poc(p_Dpb, &poc, &pos);
-
-	if (pos == -1)
-		return 0;
-
-	/* call the output function */
-	/*  dpb_print(p_H264_Dpb->decoder_index,
-	PRINT_FLAG_DPB_DETAIL,
-	"output frame with frame_num #%d, poc %d"
-	"(dpb. p_Dpb->size = %d, p_Dpb->used_size = %d)\n",
-	p_Dpb->fs[pos]->frame_num, p_Dpb->fs[pos]->frame->poc,
-	p_Dpb->size, p_Dpb->used_size);
-	*/
-
-#if 0
-	/* ??? */
-	/* picture error concealment */
-	if (p_Vid->conceal_mode != 0) {
-		if (p_Dpb->last_output_poc == 0)
-			write_lost_ref_after_idr(p_Dpb, pos);
-#if (MVC_EXTENSION_ENABLE)
-		write_lost_non_ref_pic(p_Dpb, poc,
-			p_Vid->p_out_mvc[p_Dpb->layer_id]);
-#else
-		write_lost_non_ref_pic(p_Dpb, poc, p_Vid->p_out);
-#endif
-	}
-#endif
-/* JVT-P072 ends */
-
-#if 0
-/* ??? */
-#if (MVC_EXTENSION_ENABLE)
-	write_stored_frame(p_Vid, p_Dpb->fs[pos],
-		p_Vid->p_out_mvc[p_Dpb->layer_id]);
-#else
-	write_stored_frame(p_Vid, p_Dpb->fs[pos], p_Vid->p_out);
-#endif
-#endif
-	/* picture error concealment */
-	if (p_Vid->conceal_mode == 0) {
-		if (p_Dpb->last_output_poc >= poc) {
-			dpb_print(p_H264_Dpb->decoder_index,
-				PRINT_FLAG_DPB_DETAIL,
-				"output POC must be in ascending order %d\n",
-				150);
-		}
-	}
-
-	p_Dpb->last_output_poc = poc;
-
-	/* free frame store and move empty store to end of buffer */
-/* #ifdef OUTPUT_BUFFER_IN_C */
-	if ((h264_debug_flag & OUTPUT_CURRENT_BUF) == 0) {
-		if (prepare_display_buf(p_H264_Dpb->vdec,
-			p_Dpb->fs[pos]) >= 0) {
-			p_Dpb->fs[pos]->pre_output = 1;
-		}
-	}
-/* #else */
-	else {
-		if (!is_used_for_reference(p_Dpb->fs[pos])) {
-			release_colocate_buf(p_H264_Dpb,
-				p_Dpb->fs[pos]->colocated_buf_index); /*rain*/
-				p_Dpb->fs[pos]->colocated_buf_index = -1;
-
-			release_buf_spec_num(p_H264_Dpb->vdec,
-				p_Dpb->fs[pos]->buf_spec_num);
-			p_Dpb->fs[pos]->buf_spec_num = -1;
-
-			remove_frame_from_dpb(p_H264_Dpb, pos);
-		}
-/* #endif */
-	}
-	return 1;
-}
-
-#else
-/* none OLD_OUTPUT_CODE */
-
 int output_frames(struct h264_dpb_stru *p_H264_Dpb, unsigned char flush_flag)
 {
 	int poc, pos;
 	struct DecodedPictureBuffer *p_Dpb = &p_H264_Dpb->mDPB;
 	int i;
 	int none_displayed_num = 0;
+	unsigned char fast_output_flag = 0;
 	if (!flush_flag) {
 		for (i = 0; i < p_Dpb->used_size; i++) {
 			if ((!p_Dpb->fs[i]->is_output) &&
-				(!p_Dpb->fs[i]->pre_output))
+				(!p_Dpb->fs[i]->pre_output)) {
 				none_displayed_num++;
+				/*check poc even/odd*/
+				if (p_H264_Dpb->poc_even_odd_flag == 0 &&
+					p_H264_Dpb->decode_pic_count >= 3)
+					p_H264_Dpb->poc_even_odd_flag = 2;
+				if (p_Dpb->fs[i]->poc & 0x1)
+					p_H264_Dpb->poc_even_odd_flag = 1;
+				/**/
+
+				if ((p_H264_Dpb->fast_output_enable & 0x1) &&
+					(p_Dpb->fs[i]->data_flag & IDR_FLAG))
+					fast_output_flag = 1;
+				if ((p_H264_Dpb->fast_output_enable & 0x2) &&
+					((p_Dpb->fs[i]->poc -
+						p_Dpb->last_output_poc)
+					== 1))
+					fast_output_flag = 1;
+				if ((p_H264_Dpb->fast_output_enable & 0x4) &&
+					(p_H264_Dpb->poc_even_odd_flag == 2) &&
+					((p_Dpb->fs[i]->poc -
+						p_Dpb->last_output_poc)
+					== 2))
+					fast_output_flag = 1;
+			}
 		}
-		if (none_displayed_num < p_H264_Dpb->reorder_pic_num)
+		if (fast_output_flag)
+			;
+		else if (none_displayed_num <
+			p_H264_Dpb->reorder_pic_num)
 			return 0;
 	}
 
@@ -1970,21 +2048,22 @@ int output_frames(struct h264_dpb_stru *p_H264_Dpb, unsigned char flush_flag)
 	if (is_used_for_reference(p_Dpb->fs[pos]))
 		return 0;
 #endif
-	p_Dpb->last_output_poc = poc;
-
 	if (prepare_display_buf(p_H264_Dpb->vdec, p_Dpb->fs[pos]) >= 0)
 		p_Dpb->fs[pos]->pre_output = 1;
 
 	dpb_print(p_H264_Dpb->decoder_index, PRINT_FLAG_DPB_DETAIL,
-		"%s[%d] poc %d\n", __func__, pos, poc);
+		"%s[%d] poc %d last_output_poc %d poc_even_odd_flag %d\n",
+		__func__, pos, poc,
+		p_Dpb->last_output_poc,
+		p_H264_Dpb->poc_even_odd_flag);
 
+	p_Dpb->last_output_poc = poc;
 	return 1;
 
 }
-#endif
 
 
-static void flush_dpb(struct h264_dpb_stru *p_H264_Dpb)
+void flush_dpb(struct h264_dpb_stru *p_H264_Dpb)
 {
 	/* struct VideoParameters *p_Vid = p_Dpb->p_Vid; */
 	struct DecodedPictureBuffer *p_Dpb = &p_H264_Dpb->mDPB;
@@ -2016,24 +2095,15 @@ static void flush_dpb(struct h264_dpb_stru *p_H264_Dpb)
 #endif
 		unmark_for_reference(p_Dpb, p_Dpb->fs[i]);
 
-		if (h264_debug_flag & OUTPUT_CURRENT_BUF)
-			set_frame_output_flag(p_H264_Dpb, i);
-
 	}
 
 	while (remove_unused_frame_from_dpb(p_H264_Dpb))
 		;
 
 	/* output frames in POC order */
-#ifndef OLD_OUTPUT_CODE
-	if ((h264_debug_flag & OUTPUT_CURRENT_BUF) == 0) {
-		while (output_frames(p_H264_Dpb, 1))
-			;
-	}
-#else
-	while (p_Dpb->used_size && output_one_frame_from_dpb(p_H264_Dpb))
+	while (output_frames(p_H264_Dpb, 1))
 		;
-#endif
+
 
 	p_Dpb->last_output_poc = INT_MIN;
 }
@@ -2185,7 +2255,8 @@ static void idr_memory_management(struct h264_dpb_stru *p_H264_Dpb,
 	struct DecodedPictureBuffer *p_Dpb = &p_H264_Dpb->mDPB;
 
 	dpb_print(p_H264_Dpb->decoder_index, PRINT_FLAG_DPB_DETAIL,
-	"%s %d %d\n", __func__, p_Dpb->ref_frames_in_buffer,
+	"%s ref_frames_in_buffer %d ltref_frames_in_buffer %d\n",
+	__func__, p_Dpb->ref_frames_in_buffer,
 	p_Dpb->ltref_frames_in_buffer);
 
 	if (p->no_output_of_prior_pics_flag) {
@@ -2237,15 +2308,23 @@ static void sliding_window_memory_management(
 	unsigned  i;
 	struct h264_dpb_stru *p_H264_Dpb = container_of(p_Dpb,
 		struct h264_dpb_stru, mDPB);
-
+	unsigned char slide_flag = 0;
+	unsigned int sliding_margin = imax(
+		1, p_Dpb->num_ref_frames) - p_Dpb->ltref_frames_in_buffer;
 	/* assert (!p->idr_flag); */
 	dpb_print(p_H264_Dpb->decoder_index, PRINT_FLAG_DPB_DETAIL,
-		"%s\n", __func__);
-
+	"%s ref_frames_in_buffer %d ltref_frames_in_buffer %d\n",
+	__func__, p_Dpb->ref_frames_in_buffer,
+	p_Dpb->ltref_frames_in_buffer);
 	/* if this is a reference pic with sliding window,
 	   unmark first ref frame */
-	if (p_Dpb->ref_frames_in_buffer == imax(
-		1, p_Dpb->num_ref_frames) - p_Dpb->ltref_frames_in_buffer) {
+	if (p_Dpb->ref_frames_in_buffer == sliding_margin)
+		slide_flag = 1;
+	/*else if ((h264_error_proc_policy & 0x8) &&
+		(p_Dpb->ref_frames_in_buffer > sliding_margin))
+		slide_flag = 1;*/
+
+	if (slide_flag) {
 		for (i = 0; i < p_Dpb->used_size; i++) {
 			if (p_Dpb->fs[i]->is_reference &&
 				(!(p_Dpb->fs[i]->is_long_term))) {
@@ -2276,83 +2355,91 @@ static void check_num_ref(struct DecodedPictureBuffer *p_Dpb)
 	}
 }
 
-static void dump_dpb(struct DecodedPictureBuffer *p_Dpb)
+void dump_dpb(struct DecodedPictureBuffer *p_Dpb, u8 force)
 {
 	unsigned i;
 	struct h264_dpb_stru *p_H264_Dpb =
 		container_of(p_Dpb, struct h264_dpb_stru, mDPB);
-	if ((h264_debug_flag & PRINT_FLAG_DUMP_DPB) == 0)
+	if ((h264_debug_flag & PRINT_FLAG_DUMP_DPB) == 0 &&
+		force == 0)
 		return;
 	for (i = 0; i < p_Dpb->used_size; i++) {
 		dpb_print(p_H264_Dpb->decoder_index,
-			PRINT_FLAG_DUMP_DPB,
+			0,
 			"(");
-		dpb_print(p_H264_Dpb->decoder_index,
-			PRINT_FLAG_DUMP_DPB | 0x100,
+		dpb_print_cont(p_H264_Dpb->decoder_index,
+			0,
 			"fn=%d  ", p_Dpb->fs[i]->frame_num);
 		if (p_Dpb->fs[i]->is_used & 1) {
 			if (p_Dpb->fs[i]->top_field)
-				dpb_print(p_H264_Dpb->decoder_index,
-				PRINT_FLAG_DUMP_DPB | 0x100,
+				dpb_print_cont(p_H264_Dpb->decoder_index,
+				0,
 				"T: poc=%d  ",
 				p_Dpb->fs[i]->top_field->poc);
 			else
-				dpb_print(p_H264_Dpb->decoder_index,
-				PRINT_FLAG_DUMP_DPB | 0x100,
+				dpb_print_cont(p_H264_Dpb->decoder_index,
+				0,
 				"T: poc=%d  ",
 				p_Dpb->fs[i]->frame->top_poc);
 		}
 		if (p_Dpb->fs[i]->is_used & 2) {
 			if (p_Dpb->fs[i]->bottom_field)
-				dpb_print(p_H264_Dpb->decoder_index,
-				PRINT_FLAG_DUMP_DPB | 0x100,
+				dpb_print_cont(p_H264_Dpb->decoder_index,
+				0,
 				"B: poc=%d  ",
 				p_Dpb->fs[i]->bottom_field->poc);
 			else
-				dpb_print(p_H264_Dpb->decoder_index,
-				PRINT_FLAG_DUMP_DPB | 0x100,
+				dpb_print_cont(p_H264_Dpb->decoder_index,
+				0,
 				"B: poc=%d  ",
 				p_Dpb->fs[i]->frame->bottom_poc);
 		}
 		if (p_Dpb->fs[i]->is_used == 3)
-			dpb_print(p_H264_Dpb->decoder_index,
-			PRINT_FLAG_DUMP_DPB | 0x100,
+			dpb_print_cont(p_H264_Dpb->decoder_index,
+			0,
 			"F: poc=%d  ",
 			p_Dpb->fs[i]->frame->poc);
-		dpb_print(p_H264_Dpb->decoder_index,
-			PRINT_FLAG_DUMP_DPB | 0x100,
+		dpb_print_cont(p_H264_Dpb->decoder_index,
+			0,
 			"G: poc=%d)  ", p_Dpb->fs[i]->poc);
 		if (p_Dpb->fs[i]->is_reference)
-			dpb_print(p_H264_Dpb->decoder_index,
-			PRINT_FLAG_DUMP_DPB | 0x100,
+			dpb_print_cont(p_H264_Dpb->decoder_index,
+			0,
 			"ref (%d) ", p_Dpb->fs[i]->is_reference);
 		if (p_Dpb->fs[i]->is_long_term)
-			dpb_print(p_H264_Dpb->decoder_index,
-			PRINT_FLAG_DUMP_DPB | 0x100,
+			dpb_print_cont(p_H264_Dpb->decoder_index,
+			0,
 			"lt_ref (%d) ", p_Dpb->fs[i]->is_reference);
 		if (p_Dpb->fs[i]->is_output)
-			dpb_print(p_H264_Dpb->decoder_index,
-			PRINT_FLAG_DUMP_DPB | 0x100,
-			"out  ");
+			dpb_print_cont(p_H264_Dpb->decoder_index,
+			0,
+			"out(displayed)  ");
 		if (p_Dpb->fs[i]->pre_output)
-			dpb_print(p_H264_Dpb->decoder_index,
-			PRINT_FLAG_DUMP_DPB | 0x100,
-			"for_out  ");
+			dpb_print_cont(p_H264_Dpb->decoder_index,
+			0,
+			"pre_output(in dispq or displaying)  ");
 		if (p_Dpb->fs[i]->is_used == 3) {
 			if (p_Dpb->fs[i]->frame->non_existing)
-				dpb_print(p_H264_Dpb->decoder_index,
-				PRINT_FLAG_DUMP_DPB | 0x100,
-				"ne  ");
+				dpb_print_cont(p_H264_Dpb->decoder_index,
+				0,
+				"non_existing  ");
 		}
 #if (MVC_EXTENSION_ENABLE)
 		if (p_Dpb->fs[i]->is_reference)
-			dpb_print(p_H264_Dpb->decoder_index,
-			PRINT_FLAG_DUMP_DPB | 0x100,
+			dpb_print_cont(p_H264_Dpb->decoder_index,
+			0,
 			"view_id (%d) ", p_Dpb->fs[i]->view_id);
 #endif
-		dpb_print(p_H264_Dpb->decoder_index,
-			PRINT_FLAG_DUMP_DPB | 0x100,
-			"\n");
+		if (p_Dpb->fs[i]->data_flag) {
+			dpb_print_cont(p_H264_Dpb->decoder_index,
+			0,
+			"data_flag(0x%x)",
+			p_Dpb->fs[i]->data_flag);
+		}
+		dpb_print_cont(p_H264_Dpb->decoder_index,
+			0,
+			" bufspec %d\n",
+			p_Dpb->fs[i]->buf_spec_num);
 	}
 }
 
@@ -2395,9 +2482,17 @@ static void mm_unmark_short_term_for_reference(struct DecodedPictureBuffer
 	picNumX = get_pic_num_x(p, difference_of_pic_nums_minus1);
 
 	for (i = 0; i < p_Dpb->ref_frames_in_buffer; i++) {
+#ifdef ERROR_CHECK
+		if (p_Dpb->fs_ref[i] == NULL)
+			continue;
+#endif
 		if (p->structure == FRAME) {
 			if ((p_Dpb->fs_ref[i]->is_reference == 3) &&
 			    (p_Dpb->fs_ref[i]->is_long_term == 0)) {
+#ifdef ERROR_CHECK
+				if (p_Dpb->fs_ref[i]->frame == NULL)
+					continue;
+#endif
 				if (p_Dpb->fs_ref[i]->frame->pic_num ==
 					picNumX) {
 					unmark_for_reference(p_Dpb,
@@ -2408,12 +2503,20 @@ static void mm_unmark_short_term_for_reference(struct DecodedPictureBuffer
 		} else {
 			if ((p_Dpb->fs_ref[i]->is_reference & 1) &&
 			    (!(p_Dpb->fs_ref[i]->is_long_term & 1))) {
+#ifdef ERROR_CHECK
+				if (p_Dpb->fs_ref[i]->top_field == NULL)
+					continue;
+#endif
 				if (p_Dpb->fs_ref[i]->top_field->pic_num ==
 					picNumX) {
 					p_Dpb->fs_ref[i]->
 					top_field->used_for_reference = 0;
 					p_Dpb->fs_ref[i]->is_reference &= 2;
-					if (p_Dpb->fs_ref[i]->is_used == 3) {
+					if ((p_Dpb->fs_ref[i]->is_used == 3)
+#ifdef ERROR_CHECK
+						&& p_Dpb->fs_ref[i]->frame
+#endif
+					) {
 						p_Dpb->fs_ref[i]->frame->
 							used_for_reference = 0;
 					}
@@ -2422,12 +2525,20 @@ static void mm_unmark_short_term_for_reference(struct DecodedPictureBuffer
 			}
 			if ((p_Dpb->fs_ref[i]->is_reference & 2) &&
 			    (!(p_Dpb->fs_ref[i]->is_long_term & 2))) {
+#ifdef ERROR_CHECK
+				if (p_Dpb->fs_ref[i]->bottom_field == NULL)
+					continue;
+#endif
 				if (p_Dpb->fs_ref[i]->bottom_field->pic_num ==
 					picNumX) {
 					p_Dpb->fs_ref[i]->bottom_field->
 					used_for_reference = 0;
 					p_Dpb->fs_ref[i]->is_reference &= 1;
-					if (p_Dpb->fs_ref[i]->is_used == 3) {
+					if ((p_Dpb->fs_ref[i]->is_used == 3)
+#ifdef ERROR_CHECK
+						&& p_Dpb->fs_ref[i]->frame
+#endif
+						) {
 						p_Dpb->fs_ref[i]->frame->
 						used_for_reference = 0;
 					}
@@ -2646,7 +2757,15 @@ static void mark_pic_long_term(struct DecodedPictureBuffer *p_Dpb,
 
 	if (p->structure == FRAME) {
 		for (i = 0; i < p_Dpb->ref_frames_in_buffer; i++) {
+#ifdef ERROR_CHECK
+			if (p_Dpb->fs_ref[i] == NULL)
+				continue;
+#endif
 			if (p_Dpb->fs_ref[i]->is_reference == 3) {
+#ifdef ERROR_CHECK
+				if (p_Dpb->fs_ref[i]->frame == NULL)
+					continue;
+#endif
 				if ((!p_Dpb->fs_ref[i]->frame->
 					is_long_term) &&
 				    (p_Dpb->fs_ref[i]->frame->pic_num ==
@@ -2702,7 +2821,15 @@ static void mark_pic_long_term(struct DecodedPictureBuffer *p_Dpb,
 			add_bottom = 1;
 		}
 		for (i = 0; i < p_Dpb->ref_frames_in_buffer; i++) {
+#ifdef ERROR_CHECK
+			if (p_Dpb->fs_ref[i] == NULL)
+				continue;
+#endif
 			if (p_Dpb->fs_ref[i]->is_reference & 1) {
+#ifdef ERROR_CHECK
+				if (p_Dpb->fs_ref[i]->top_field == NULL)
+					continue;
+#endif
 				if ((!p_Dpb->fs_ref[i]->top_field->
 					is_long_term) &&
 				    (p_Dpb->fs_ref[i]->top_field->pic_num ==
@@ -2730,8 +2857,12 @@ static void mark_pic_long_term(struct DecodedPictureBuffer *p_Dpb,
 					p_Dpb->fs_ref[i]->top_field->
 						is_long_term = 1;
 					p_Dpb->fs_ref[i]->is_long_term |= 1;
-					if (p_Dpb->fs_ref[i]->is_long_term ==
-						3) {
+					if ((p_Dpb->fs_ref[i]->is_long_term
+						== 3)
+#ifdef ERROR_CHECK
+						&& p_Dpb->fs_ref[i]->frame
+#endif
+						) {
 						p_Dpb->fs_ref[i]->frame->
 							is_long_term = 1;
 						p_Dpb->fs_ref[i]->frame->
@@ -2745,6 +2876,10 @@ static void mark_pic_long_term(struct DecodedPictureBuffer *p_Dpb,
 				}
 			}
 			if (p_Dpb->fs_ref[i]->is_reference & 2) {
+#ifdef ERROR_CHECK
+				if (p_Dpb->fs_ref[i]->bottom_field == NULL)
+					continue;
+#endif
 				if ((!p_Dpb->fs_ref[i]->bottom_field->
 					is_long_term) &&
 				    (p_Dpb->fs_ref[i]->bottom_field->pic_num
@@ -2772,8 +2907,12 @@ static void mark_pic_long_term(struct DecodedPictureBuffer *p_Dpb,
 					p_Dpb->fs_ref[i]->bottom_field->
 						is_long_term = 1;
 					p_Dpb->fs_ref[i]->is_long_term |= 2;
-					if (p_Dpb->fs_ref[i]->
-						is_long_term == 3) {
+					if ((p_Dpb->fs_ref[i]->
+						is_long_term == 3)
+#ifdef ERROR_CHECK
+						&& p_Dpb->fs_ref[i]->frame
+#endif
+						) {
 						p_Dpb->fs_ref[i]->frame->
 							is_long_term = 1;
 						p_Dpb->fs_ref[i]->frame->
@@ -2816,7 +2955,15 @@ static void mm_assign_long_term_frame_idx(struct DecodedPictureBuffer *p_Dpb,
 		enum PictureStructure structure = FRAME;
 
 		for (i = 0; i < p_Dpb->ref_frames_in_buffer; i++) {
+#ifdef ERROR_CHECK
+			if (p_Dpb->fs_ref[i] == NULL)
+				continue;
+#endif
 			if (p_Dpb->fs_ref[i]->is_reference & 1) {
+#ifdef ERROR_CHECK
+				if (p_Dpb->fs_ref[i]->top_field == NULL)
+					continue;
+#endif
 				if (p_Dpb->fs_ref[i]->top_field->
 					pic_num == picNumX) {
 					structure = TOP_FIELD;
@@ -2824,6 +2971,10 @@ static void mm_assign_long_term_frame_idx(struct DecodedPictureBuffer *p_Dpb,
 				}
 			}
 			if (p_Dpb->fs_ref[i]->is_reference & 2) {
+#ifdef ERROR_CHECK
+				if (p_Dpb->fs_ref[i]->bottom_field == NULL)
+					continue;
+#endif
 				if (p_Dpb->fs_ref[i]->bottom_field->
 					pic_num == picNumX) {
 					structure = BOTTOM_FIELD;
@@ -3024,7 +3175,8 @@ static void adaptive_memory_management(struct h264_dpb_stru *p_H264_Dpb,
 
 
 void store_picture_in_dpb(struct h264_dpb_stru *p_H264_Dpb,
-			  struct StorablePicture *p)
+			  struct StorablePicture *p,
+			  unsigned char data_flag)
 {
 	/* struct VideoParameters *p_Vid = p_Dpb->p_Vid; */
 	struct VideoParameters *p_Vid = &p_H264_Dpb->mVideo;
@@ -3084,10 +3236,10 @@ void store_picture_in_dpb(struct h264_dpb_stru *p_H264_Dpb,
 						insert_picture_in_dpb(
 							p_H264_Dpb,
 							p_Dpb->last_picture,
-							p);
+							p, data_flag);
 						update_ref_list(p_Dpb);
 						update_ltref_list(p_Dpb);
-						dump_dpb(p_Dpb);
+						dump_dpb(p_Dpb, 0);
 						p_Dpb->last_picture = NULL;
 						return;
 					}
@@ -3111,80 +3263,19 @@ void store_picture_in_dpb(struct h264_dpb_stru *p_H264_Dpb,
 				p_Dpb->fs[i]->concealment_reference = 1;
 	}
 
-#ifndef OLD_OUTPUT_CODE
 	while (remove_unused_frame_from_dpb(p_H264_Dpb))
 		;
 
-	if ((h264_debug_flag & OUTPUT_CURRENT_BUF) == 0) {
-		while (output_frames(p_H264_Dpb, 0))
-			;
-	}
-#else
-	/* OLD_OUTPUT_CODE */
-
-	/* first try to remove unused frames */
-	if (p_Dpb->used_size == p_Dpb->size) {
-#if 0
-		/* ??? */
-		/* picture error concealment */
-		if (p_Vid->conceal_mode != 0)
-			conceal_non_ref_pics(p_Dpb, 2);
-#endif
-		remove_unused_frame_from_dpb(p_H264_Dpb);
-
-#if 0
-		/* ??? */
-		if (p_Vid->conceal_mode != 0)
-			sliding_window_poc_management(p_Dpb, p);
-#endif
-	}
-
-	/* then output frames until one can be removed */
-/* #ifdef OUTPUT_BUFFER_IN_C */
-	if ((h264_debug_flag & OUTPUT_CURRENT_BUF) == 0) {
-		if (p_Dpb->used_size > (p_Dpb->size - 5))
-			output_one_frame_from_dpb(p_H264_Dpb);
-	} else {
-/* #else */
-		while (p_Dpb->used_size == p_Dpb->size) {
-#if 0
-			/* non-reference frames may be output directly */
-			if (!p->used_for_reference) {
-				get_smallest_poc(p_Dpb, &poc, &pos);
-				if ((-1 == pos) || (p->poc < poc)) {
-#if (MVC_EXTENSION_ENABLE)
-					if (p_Vid->profile_idc >= MVC_HIGH)
-						dpb_print(
-						p_H264_Dpb->decoder_index,
-						PRINT_FLAG_DPB_DETAIL,
-						"Display order might not be correct, %d, %d\n",
-						p->view_id, p->poc);
-#endif
-#if 0
-/* ??? */
-#if (MVC_EXTENSION_ENABLE)
-					direct_output(p_Vid, p, p_Vid->
-						p_out_mvc[p_Dpb->layer_id]);
-#else
-					direct_output(p_Vid, p, p_Vid->p_out);
-#endif
-#endif
-					return;
-				}
-			}
-#endif
-			/* flush a frame */
-			output_one_frame_from_dpb(p_H264_Dpb);
-		}
-
-	}
-/* #endif */
-	/* OLD_OUTPUT_CODE */
-#endif
+	while (output_frames(p_H264_Dpb, 0))
+		;
 
 	/* check for duplicate frame number in short term reference buffer */
 	if ((p->used_for_reference) && (!p->is_long_term)) {
 		for (i = 0; i < p_Dpb->ref_frames_in_buffer; i++) {
+#ifdef ERROR_CHECK
+			if (p_Dpb->fs_ref[i] == NULL)
+				continue;
+#endif
 			if (p_Dpb->fs_ref[i]->frame_num == p->frame_num) {
 				dpb_print(p_H264_Dpb->decoder_index,
 					  PRINT_FLAG_DPB_DETAIL,
@@ -3202,18 +3293,13 @@ void store_picture_in_dpb(struct h264_dpb_stru *p_H264_Dpb,
 			PRINT_FLAG_ERROR,
 			"%s Error: used_sizd %d is large than dpb size\r\n",
 			__func__, p_Dpb->used_size);
-		h264_debug_flag |= PRINT_FLAG_DUMP_DPB;
-		dump_dpb(p_Dpb);
+		/*h264_debug_flag |= PRINT_FLAG_DUMP_DPB;*/
+		dump_dpb(p_Dpb, 0);
 		return;
 	}
 
-	insert_picture_in_dpb(p_H264_Dpb, p_Dpb->fs[p_Dpb->used_size], p);
-	if (h264_debug_flag & OUTPUT_CURRENT_BUF) {
-		prepare_display_buf(p_H264_Dpb->vdec,
-			p_Dpb->fs[p_Dpb->used_size]);
-		set_frame_output_flag(p_H264_Dpb, p_Dpb->used_size);
-
-	}
+	insert_picture_in_dpb(p_H264_Dpb, p_Dpb->fs[p_Dpb->used_size],
+		p, data_flag);
 
 	/* picture error concealment */
 	if (p->idr_flag)
@@ -3235,7 +3321,8 @@ void store_picture_in_dpb(struct h264_dpb_stru *p_H264_Dpb,
 
 	check_num_ref(p_Dpb);
 
-	dump_dpb(p_Dpb);
+	dump_dpb(p_Dpb, 0);
+	p_Dpb->first_pic_done = 1; /*by rain*/
 }
 
 void bufmgr_post(struct h264_dpb_stru *p_H264_Dpb)
@@ -3833,6 +3920,11 @@ static void init_lists_p_slice(struct Slice *currSlice)
 
 	if (currSlice->structure == FRAME) {
 		for (i = 0; i < p_Dpb->ref_frames_in_buffer; i++) {
+#ifdef ERROR_CHECK
+			if (p_Dpb->fs_ref[i] == NULL ||
+				p_Dpb->fs_ref[i]->frame == NULL)
+				continue;
+#endif
 			if (p_Dpb->fs_ref[i]->is_used == 3) {
 				if ((p_Dpb->fs_ref[i]->frame->
 					used_for_reference) &&
@@ -3890,6 +3982,10 @@ static void init_lists_p_slice(struct Slice *currSlice)
 		fs_listlt = &(p_Dpb->fs_listlt[0]);
 #endif
 		for (i = 0; i < p_Dpb->ref_frames_in_buffer; i++) {
+#ifdef ERROR_CHECK
+			if (p_Dpb->fs_ref[i] == NULL)
+				continue;
+#endif
 			if (p_Dpb->fs_ref[i]->is_reference)
 				fs_list0[list0idx++] = p_Dpb->fs_ref[i];
 		}
@@ -4088,6 +4184,11 @@ static void init_lists_b_slice(struct Slice *currSlice)
 		/* B-Slice */
 		if (currSlice->structure == FRAME) {
 			for (i = 0; i < p_Dpb->ref_frames_in_buffer; i++) {
+#ifdef ERROR_CHECK
+				if (p_Dpb->fs_ref[i] == NULL ||
+					p_Dpb->fs_ref[i]->frame == NULL)
+					continue;
+#endif
 				if ((p_Dpb->fs_ref[i]->is_used == 3) &&
 					((p_Dpb->fs_ref[i]->frame->
 					used_for_reference) &&
@@ -4109,6 +4210,11 @@ static void init_lists_b_slice(struct Slice *currSlice)
 			   (POC>current POC) in list0; */
 			list0idx_1 = list0idx;
 			for (i = 0; i < p_Dpb->ref_frames_in_buffer; i++) {
+#ifdef ERROR_CHECK
+				if (p_Dpb->fs_ref[i] == NULL ||
+					p_Dpb->fs_ref[i]->frame == NULL)
+					continue;
+#endif
 				if ((p_Dpb->fs_ref[i]->is_used == 3) &&
 					((p_Dpb->fs_ref[i]->frame->
 					used_for_reference) &&
@@ -4237,6 +4343,10 @@ static void init_lists_b_slice(struct Slice *currSlice)
 			currSlice->listXsize[1] = 1;
 
 			for (i = 0; i < p_Dpb->ref_frames_in_buffer; i++) {
+#ifdef ERROR_CHECK
+				if (p_Dpb->fs_ref[i] == NULL)
+					continue;
+#endif
 				if (p_Dpb->fs_ref[i]->is_used) {
 					if (currSlice->ThisPOC >=
 						p_Dpb->fs_ref[i]->poc) {
@@ -4250,6 +4360,10 @@ static void init_lists_b_slice(struct Slice *currSlice)
 				compare_fs_by_poc_desc);
 			list0idx_1 = list0idx;
 			for (i = 0; i < p_Dpb->ref_frames_in_buffer; i++) {
+#ifdef ERROR_CHECK
+				if (p_Dpb->fs_ref[i] == NULL)
+					continue;
+#endif
 				if (p_Dpb->fs_ref[i]->is_used) {
 					if (currSlice->ThisPOC <
 						p_Dpb->fs_ref[i]->poc) {
@@ -4447,25 +4561,48 @@ static struct StorablePicture *get_short_term_pic(struct Slice *currSlice,
 
 	for (i = 0; i < p_Dpb->ref_frames_in_buffer; i++) {
 		if (currSlice->structure == FRAME) {
-			if (p_Dpb->fs_ref[i]->is_reference == 3)
+#ifdef ERROR_CHECK
+			if (p_Dpb->fs_ref[i] == NULL)
+				continue;
+#endif
+			if (p_Dpb->fs_ref[i]->is_reference == 3) {
+#ifdef ERROR_CHECK
+				if (p_Dpb->fs_ref[i]->frame == NULL)
+					continue;
+#endif
 				if ((!p_Dpb->fs_ref[i]->frame->
 					is_long_term) &&
 				    (p_Dpb->fs_ref[i]->frame->
 					pic_num == picNum))
 					return p_Dpb->fs_ref[i]->frame;
+			}
 		} else {
-			if (p_Dpb->fs_ref[i]->is_reference & 1)
+#ifdef ERROR_CHECK
+			if (p_Dpb->fs_ref[i] == NULL)
+				continue;
+#endif
+			if (p_Dpb->fs_ref[i]->is_reference & 1) {
+#ifdef ERROR_CHECK
+				if (p_Dpb->fs_ref[i]->top_field == NULL)
+					continue;
+#endif
 				if ((!p_Dpb->fs_ref[i]->top_field->
 					is_long_term) &&
 				    (p_Dpb->fs_ref[i]->top_field->
 					pic_num == picNum))
 					return p_Dpb->fs_ref[i]->top_field;
-			if (p_Dpb->fs_ref[i]->is_reference & 2)
+			}
+			if (p_Dpb->fs_ref[i]->is_reference & 2) {
+#ifdef ERROR_CHECK
+				if (p_Dpb->fs_ref[i]->bottom_field == NULL)
+					continue;
+#endif
 				if ((!p_Dpb->fs_ref[i]->bottom_field->
 					is_long_term) &&
 				    (p_Dpb->fs_ref[i]->bottom_field->
 					pic_num == picNum))
 					return p_Dpb->fs_ref[i]->bottom_field;
+			}
 		}
 	}
 
@@ -4910,7 +5047,7 @@ void set_frame_output_flag(struct h264_dpb_stru *p_H264_Dpb, int index)
 	struct DecodedPictureBuffer *p_Dpb = &p_H264_Dpb->mDPB;
 	p_H264_Dpb->mFrameStore[index].is_output = 1;
 	p_H264_Dpb->mFrameStore[index].pre_output = 0;
-	dump_dpb(p_Dpb);
+	dump_dpb(p_Dpb, 0);
 }
 
 #if 0
@@ -5107,6 +5244,8 @@ int h264_slice_header_process(struct h264_dpb_stru *p_H264_Dpb)
 	int new_pic_flag = 0;
 	struct Slice *currSlice = &p_H264_Dpb->mSlice;
 	struct VideoParameters *p_Vid = &p_H264_Dpb->mVideo;
+	struct DecodedPictureBuffer *p_Dpb =
+				&p_H264_Dpb->mDPB;
 #if 0
 	new_pic_flag = is_new_picture(p_H264_Dpb->mVideo.dec_picture,
 				      p_H264_Dpb,
@@ -5126,6 +5265,12 @@ int h264_slice_header_process(struct h264_dpb_stru *p_H264_Dpb)
 	slice_prepare(p_H264_Dpb, &p_H264_Dpb->mDPB, &p_H264_Dpb->mVideo,
 		      &p_H264_Dpb->mSPS, &p_H264_Dpb->mSlice);
 
+	if (p_Dpb->num_ref_frames != p_H264_Dpb->mSPS.num_ref_frames) {
+		dpb_print(p_H264_Dpb->decoder_index, 0,
+		"num_ref_frames change from %d to %d\r\n",
+			p_Dpb->num_ref_frames, p_H264_Dpb->mSPS.num_ref_frames);
+		p_Dpb->num_ref_frames = p_H264_Dpb->mSPS.num_ref_frames;
+	}
 	/* if (p_Vid->active_sps != sps) { */
 	if (p_H264_Dpb->mDPB.init_done == 0) {
 		/*init_global_buffers(p_Vid, 0);
diff --git a/drivers/frame_provider/decoder/h264_multi/h264_dpb.h b/drivers/frame_provider/decoder/h264_multi/h264_dpb.h
index e58f084..e8ffec8 100644
--- a/drivers/frame_provider/decoder/h264_multi/h264_dpb.h
+++ b/drivers/frame_provider/decoder/h264_multi/h264_dpb.h
@@ -6,23 +6,18 @@
 #define OUTPUT_BUFFER_IN_C
 
 #define PRINT_FLAG_ERROR              0x0
-#define PRINT_FLAG_DPB                0X0001
-#define PRINT_FLAG_DPB_DETAIL         0x0002
-#define PRINT_FLAG_DUMP_DPB           0x0004
-#define PRINT_FLAG_UCODE_EVT          0x0008
-#define PRINT_FLAG_VDEC_STATUS        0x0010
-#define PRINT_FLAG_VDEC_DETAIL        0x0020
-#define PRINT_FLAG_UCODE_DBG          0x0040
-#define PRINT_FLAG_TIME_STAMP         0x0080
-#define PRINT_FLAG_RUN_SCHEDULE       0x0100
+#define PRINT_FLAG_VDEC_STATUS        0X0001
+#define PRINT_FLAG_UCODE_EVT          0x0002
+#define PRINT_FLAG_MMU_DETAIL		0x0004
+#define PRINT_FLAG_DPB_DETAIL         0x0010
+#define PRINT_FLAG_DEC_DETAIL         0x0020
+#define PRINT_FLAG_VDEC_DETAIL        0x0040
+#define PRINT_FLAG_DUMP_DPB           0x0080
+#define PRINT_FRAMEBASE_DATA          0x0100
 #define PRINT_FLAG_DEBUG_POC          0x0200
-#define PRINT_FLAG_VDEC_DATA          0x0400
+#define RRINT_FLAG_RPM                0x0400
 #define DISABLE_ERROR_HANDLE          0x10000
-#define OUTPUT_CURRENT_BUF            0x20000
-#define ONLY_RESET_AT_START           0x40000
-#define LOAD_UCODE_ALWAYS             0x80000
-#define FORCE_NO_SLICE                0x100000
-#define REINIT_DPB_TEST               0x200000
+#define DEBUG_DUMP_STAT               0x80000
 
 
 #define MVC_EXTENSION_ENABLE 0
@@ -41,10 +36,18 @@
 
 #define H264_CONFIG_REQUEST         0x11
 #define H264_DATA_REQUEST           0x12
+#define H264_WRRSP_REQUEST          0x13
+#define H264_WRRSP_DONE             0x14
 
 #define H264_DECODE_BUFEMPTY        0x20
 #define H264_DECODE_TIMEOUT         0x21
 #define H264_SEARCH_BUFEMPTY        0x22
+#define H264_DECODE_OVER_SIZE       0x23
+
+#define H264_FIND_NEXT_PIC_NAL              0x50
+#define H264_FIND_NEXT_DVEL_NAL             0x51
+#define H264_AUX_DATA_READY					0x52
+
     /* 0x8x, search state*/
 #define H264_STATE_SEARCH_AFTER_SPS  0x80
 #define H264_STATE_SEARCH_AFTER_PPS  0x81
@@ -66,11 +69,13 @@
 #define DPB_OFFSET		0x100
 #define MMCO_OFFSET		0x200
 union param {
+#if 0
 #define H_TIME_STAMP_START	0X00
 #define H_TIME_STAMP_END	0X17
 #define PTS_ZERO_0		0X18
 #define PTS_ZERO_1		0X19
-#define FIXED_FRAME_RATE_FLAG                   0X1A
+#endif
+#define FIXED_FRAME_RATE_FLAG                   0X21
 
 #define OFFSET_DELIMITER_LO                     0x2f
 #define OFFSET_DELIMITER_HI                     0x30
@@ -212,7 +217,7 @@ union param {
 #define VPTS_MAP_ADDR							0XC4
 #define H_VPTS_MAP_ADDR							0XC5
 
-#define MAX_DPB_SIZE							0XC6
+/*#define MAX_DPB_SIZE							0XC6*/
 #define PIC_INSERT_FLAG							0XC7
 
 #define TIME_STAMP_START						0XC8
@@ -242,7 +247,7 @@ union param {
 #define FIRST_MB_IN_SLICE						0XF0
 #define PREV_MB_WIDTH							0XF1
 #define PREV_FRAME_SIZE_IN_MB						0XF2
-#define MAX_REFERENCE_FRAME_NUM_IN_MEM					0XF3
+/*#define MAX_REFERENCE_FRAME_NUM_IN_MEM		0XF3*/
 /* bit 0 - aspect_ratio_info_present_flag
  * bit 1 - timing_info_present_flag
  * bit 2 - nal_hrd_parameters_present_flag
@@ -622,6 +627,7 @@ struct StorablePicture {
 
 	u32         pts;
 	u64         pts64;
+	unsigned char data_flag;
 };
 
 struct FrameStore {
@@ -655,6 +661,12 @@ struct FrameStore {
 	int         pre_output;
 	/* index in gFrameStore */
 	int       index;
+#define I_FLAG			0x01
+#define IDR_FLAG		0x02
+#define ERROR_FLAG		0x10
+#define NULL_FLAG		0x20
+#define NODISP_FLAG		0x80
+	unsigned char data_flag;
 #endif
 	int       poc;
 
@@ -676,8 +688,6 @@ struct FrameStore {
 	u64       pts64;
 };
 
-int prepare_display_buf(struct vdec_s *vdec, struct FrameStore *frame);
-
 
 /* #define DPB_SIZE_MAX     16 */
 #define DPB_SIZE_MAX     32
@@ -707,6 +717,7 @@ struct DecodedPictureBuffer {
 
 
 	int           init_done;
+	int           first_pic_done; /*by rain*/
 	int           num_ref_frames;
 
 	struct FrameStore   *last_picture;
@@ -726,6 +737,11 @@ struct h264_dpb_stru {
 	int buf_num;
 	int curr_POC;
 	int reorder_pic_num;
+	u8 fast_output_enable;
+		/*poc_even_flag:
+		 0, init; 1, odd; 2, even*/
+	u8 poc_even_odd_flag;
+	u32 decode_pic_count;
 	/**/
 	unsigned int max_reference_size;
 
@@ -743,6 +759,16 @@ struct h264_dpb_stru {
 	struct StorablePicture m_PIC[MAX_PIC_BUF_NUM];
 	struct FrameStore mFrameStore[DPB_SIZE_MAX];
 
+	/*vui*/
+	unsigned int vui_status;
+	unsigned int num_units_in_tick;
+	unsigned int time_scale;
+	unsigned int fixed_frame_rate_flag;
+	unsigned int aspect_ratio_idc;
+	unsigned int aspect_ratio_sar_width;
+	unsigned int aspect_ratio_sar_height;
+
+	unsigned int dec_dpb_status;
 };
 
 
@@ -751,6 +777,8 @@ extern unsigned int h264_debug_mask;
 
 int dpb_print(int indext, int debug_flag, const char *fmt, ...);
 
+int dpb_print_cont(int index, int debug_flag, const char *fmt, ...);
+
 unsigned char dpb_is_debug(int index, int debug_flag);
 
 int prepare_display_buf(struct vdec_s *vdec, struct FrameStore *frame);
@@ -773,7 +801,7 @@ int release_colocate_buf(struct h264_dpb_stru *p_H264_Dpb, int index);
 int get_free_buf_idx(struct vdec_s *vdec);
 
 void store_picture_in_dpb(struct h264_dpb_stru *p_H264_Dpb,
-			struct StorablePicture *p);
+			struct StorablePicture *p, unsigned char data_flag);
 
 int remove_picture(struct h264_dpb_stru *p_H264_Dpb,
 			struct StorablePicture *pic);
@@ -783,6 +811,14 @@ void bufmgr_post(struct h264_dpb_stru *p_H264_Dpb);
 int get_long_term_flag_by_buf_spec_num(struct h264_dpb_stru *p_H264_Dpb,
 	int buf_spec_num);
 
-void bufmgr_h264_remove_unused_frame(struct h264_dpb_stru *p_H264_Dpb);
+void bufmgr_h264_remove_unused_frame(struct h264_dpb_stru *p_H264_Dpb,
+	u8 force_flag);
+
+void flush_dpb(struct h264_dpb_stru *p_H264_Dpb);
+
+void print_pic_info(int decindex, const char *info,
+			struct StorablePicture *pic,
+			int slice_type);
+void dump_dpb(struct DecodedPictureBuffer *p_Dpb, u8 force);
 
 #endif
diff --git a/drivers/frame_provider/decoder/h264_multi/vmh264.c b/drivers/frame_provider/decoder/h264_multi/vmh264.c
index 59b7457..a0125b5 100644
--- a/drivers/frame_provider/decoder/h264_multi/vmh264.c
+++ b/drivers/frame_provider/decoder/h264_multi/vmh264.c
@@ -49,12 +49,14 @@
 #include "../h264/vh264.h"
 #include "../../../stream_input/parser/streambuf.h"
 #include <linux/delay.h>
+#include <linux/amlogic/media/codec_mm/configs.h>
+#include "../utils/decoder_mmu_box.h"
+#include "../utils/decoder_bmmu_box.h"
 
 #undef pr_info
 #define pr_info printk
 
 #define DEBUG_UCODE
-#define USE_CMA
 #define MEM_NAME "codec_m264"
 #define MULTI_INSTANCE_FRAMEWORK
 /* #define ONE_COLOCATE_BUF_PER_DECODE_BUF */
@@ -63,9 +65,12 @@
 
 #define DRIVER_NAME "ammvdec_h264"
 #define MODULE_NAME "ammvdec_h264"
+#define DRIVER_HEADER_NAME "ammvdec_h264_header"
 
 #define CHECK_INTERVAL        (HZ/100)
 
+#define SEI_ITU_DATA_SIZE		(4*1024)
+
 #define RATE_MEASURE_NUM 8
 #define RATE_CORRECTION_THRESHOLD 5
 #define RATE_2397_FPS  4004   /* 23.97 */
@@ -85,6 +90,7 @@
 #define DEC_CONTROL_FLAG_FORCE_RATE_2397_FPS_FIX_FRAME_RATE  0x0010
 #define DEC_CONTROL_FLAG_FORCE_RATE_2997_FPS_FIX_FRAME_RATE  0x0020
 
+#define DECODE_ID(hw) (hw_to_vdec(hw)->id)
 
 #define RATE_MEASURE_NUM 8
 #define RATE_CORRECTION_THRESHOLD 5
@@ -95,8 +101,11 @@
 #define DUR2PTS_REM(x) (x*90 - DUR2PTS(x)*96)
 #define FIX_FRAME_RATE_CHECK_IDRFRAME_NUM 2
 
-#define H264_DEV_NUM        5
+#define H264_DEV_NUM        9
 
+#define H264_MMU
+static int mmu_enable;
+static int force_enable_mmu = 1;
 unsigned int h264_debug_flag; /* 0xa0000000; */
 unsigned int h264_debug_mask = 0xff;
 	/*
@@ -107,20 +116,59 @@ unsigned int h264_debug_cmd;
 static unsigned int dec_control;
 static unsigned int force_rate_streambase;
 static unsigned int force_rate_framebase;
+static unsigned int force_disp_bufspec_num;
 static unsigned int fixed_frame_rate_mode;
 static unsigned int error_recovery_mode_in;
-static unsigned int start_decode_buf_level = 0x8000;
+static int start_decode_buf_level = 0x8000;
 
+#ifdef CONFIG_AM_VDEC_DV
+/*to make reorder size difference of bl and el not too big*/
+static unsigned int reorder_dpb_size_margin_dv = 16;
+#endif
 static unsigned int reorder_dpb_size_margin = 6;
 static unsigned int reference_buf_margin = 4;
 
-static unsigned int decode_timeout_val = 50;
+static unsigned int max_alloc_buf_count;
+static unsigned int decode_timeout_val = 100;
+static unsigned int get_data_timeout_val = 2000;
+static unsigned int frame_max_data_packet = 8;
+
 static unsigned int radr;
 static unsigned int rval;
+
+/*
+	udebug_flag:
+	bit 0, enable ucode print
+	bit 1, enable ucode detail print
+	bit 3, disable ucode watchdog
+	bit [31:16] not 0, pos to dump lmem
+		bit 2, pop bits to lmem
+		bit [11:8], pre-pop bits for alignment (when bit 2 is 1)
+*/
+static u32 udebug_flag;
+/*
+	when udebug_flag[1:0] is not 0
+	udebug_pause_pos not 0,
+		pause position
+*/
+static u32 udebug_pause_pos;
+/*
+	when udebug_flag[1:0] is not 0
+	and udebug_pause_pos is not 0,
+		pause only when DEBUG_REG2 is equal to this val
+*/
+static u32 udebug_pause_val;
+
+static u32 udebug_pause_decode_idx;
+
 static unsigned int max_decode_instance_num = H264_DEV_NUM;
 static unsigned int decode_frame_count[H264_DEV_NUM];
+static unsigned int display_frame_count[H264_DEV_NUM];
 static unsigned int max_process_time[H264_DEV_NUM];
 static unsigned int max_get_frame_interval[H264_DEV_NUM];
+static unsigned int run_count[H264_DEV_NUM];
+static unsigned int input_empty[H264_DEV_NUM];
+static unsigned int not_run_ready[H264_DEV_NUM];
 		/* bit[3:0]:
 		0, run ; 1, pause; 3, step
 		bit[4]:
@@ -128,6 +176,73 @@ static unsigned int max_get_frame_interval[H264_DEV_NUM];
 		*/
 static unsigned int step[H264_DEV_NUM];
 
+#define AUX_BUF_ALIGN(adr) ((adr + 0xf) & (~0xf))
+static u32 prefix_aux_buf_size = (16 * 1024);
+static u32 suffix_aux_buf_size;
+
+#ifdef CONFIG_AM_VDEC_DV
+static u32 dv_toggle_prov_name;
+
+static u32 dolby_meta_with_el;
+#endif
+
+/*
+	bit[8]
+		0: use sys_info[bit 3]
+		not 0:use i_only_flag[7:0]
+			bit[7:0]:
+				bit 0, 1: only display I picture;
+				bit 1, 1: only decode I picture;
+*/
+static unsigned int i_only_flag;
+
+/*
+	error_proc_policy:
+	bit[0] send_error_frame_flag;
+		(valid when bit[31] is 1, otherwise use sysinfo)
+	bit[1] do not decode if config_decode_buf() fail
+	bit[2] force release buf if in deadlock
+	bit[3] force sliding window ref_frames_in_buffer > num_ref_frames
+	bit[4] check inactive of receiver
+	bit[5] reset buffmgr if in deadlock
+
+	bit[8] check total mbx/mby of decoded frame
+	bit[9] check ERROR_STATUS_REG
+
+	bit[12] i_only when error happen
+*/
+static unsigned int error_proc_policy = 0x1214; /*0xc;*/
+
+/*
+	error_skip_count:
+	bit[11:0] error skip frame count
+	bit[15:12] error skip i picture count
+*/
+static unsigned int error_skip_count = (0x2 << 12) | 0x40;
+
+static unsigned int force_sliding_margin;
+/*
+	bit[1:0]:
+	0, start playing from any frame
+	1, start playing from I frame
+		bit[15:8]: the count of skip frames after first I
+	2, start playing from second I frame (decode from the first I)
+		bit[15:8]: the max count of skip frames after first I
+	3, start playing from IDR
+*/
+static unsigned int first_i_policy = (15 << 8) | 2;
+
+/*
+	fast_output_enable:
+	bit [0], output frame if there is IDR in list
+	bit [1], output frame if the current poc is 1 big than the previous poc
+	bit [2], if even poc only, output frame ifthe cuurent poc
+			is 2 big than the previous poc
+*/
+static unsigned int fast_output_enable = 3;
+
+static unsigned int enable_itu_t35 = 1;
+
 #define is_in_parsing_state(status) \
 		((status == H264_ACTION_SEARCH_HEAD) || \
 			((status & 0xf0) == 0x80))
@@ -137,6 +252,14 @@ static inline bool close_to(int a, int b, int m)
 	return (abs(a - b) < m) ? true : false;
 }
 
+#if 0
+#define h264_alloc_hw_stru(dev, size, opt) devm_kzalloc(dev, size, opt)
+#define h264_free_hw_stru(dev, hw) devm_kfree(dev, hw)
+#else
+#define h264_alloc_hw_stru(dev, size, opt) vzalloc(size)
+#define h264_free_hw_stru(dev, hw) vfree(hw)
+#endif
+
 /* #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6 */
 #define NV21
 /* #endif */
@@ -146,9 +269,12 @@ static inline bool close_to(int a, int b, int m)
 #define DEFAULT_MEM_SIZE        (32*1024*1024)
 #define AVIL_DPB_BUFF_SIZE      0x01ec2000
 
-#define DEF_BUF_START_ADDR            0x1000000
-#define V_BUF_ADDR_OFFSET             (0x13e000)
-
+#define DEF_BUF_START_ADDR			0x01000000
+#define mem_sps_base				0x011c3c00
+#define mem_pps_base				0x011cbc00
+/*#define V_BUF_ADDR_OFFSET             (0x13e000)*/
+u32 V_BUF_ADDR_OFFSET = 0x200000;
+#define DCAC_READ_MARGIN	(64 * 1024)
 #define PIC_SINGLE_FRAME        0
 #define PIC_TOP_BOT_TOP         1
 #define PIC_BOT_TOP_BOT         2
@@ -160,11 +286,23 @@ static inline bool close_to(int a, int b, int m)
 
 #define EXTEND_SAR                      0xff
 
+#define BUFSPEC_POOL_SIZE		64
 #define VF_POOL_SIZE        64
-#define MAX_VF_BUF_NUM          28
+#define MAX_VF_BUF_NUM          27
+#define BMMU_MAX_BUFFERS	(BUFSPEC_POOL_SIZE + 3)
+#define BMMU_REF_IDX	(BUFSPEC_POOL_SIZE)
+#define BMMU_DPB_IDX	(BUFSPEC_POOL_SIZE + 1)
+#define BMMU_EXTIF_IDX	(BUFSPEC_POOL_SIZE + 2)
+#define EXTIF_BUF_SIZE   0x10000
+
+#define HEADER_BUFFER_IDX(n) (n)
+#define VF_BUFFER_IDX(n)	(n)
+
+
 #define PUT_INTERVAL        (HZ/100)
 #define NO_DISP_WD_COUNT    (3 * HZ / PUT_INTERVAL)
 
+#define MMU_MAX_BUFFERS	BUFSPEC_POOL_SIZE
 #define SWITCHING_STATE_OFF       0
 #define SWITCHING_STATE_ON_CMD3   1
 #define SWITCHING_STATE_ON_CMD1   2
@@ -181,11 +319,15 @@ static inline bool close_to(int a, int b, int m)
 struct buffer_spec_s {
 	/*
 	used:
-	0, free; 1, used by dpb; 2,
-	used for display;
-	3 isolated (do not use for dpb when vf_put)
+	-1, none allocated
+	0, allocated, free
+	1, used by dpb
+	2, in disp queue;
+	3, in disp queue, isolated,
+		do not use for dpb when vf_put;
+	4, to release
 	*/
-	unsigned int used;
+	int used;
 	unsigned int info0;
 	unsigned int info1;
 	unsigned int info2;
@@ -202,25 +344,41 @@ struct buffer_spec_s {
 #else
 	struct canvas_config_s canvas_config[3];
 #endif
-#ifdef USE_CMA
-	/* struct page *cma_alloc_pages; */
 	unsigned long cma_alloc_addr;
-	int cma_alloc_count;
-#endif
 	unsigned int buf_adr;
+#ifdef	H264_MMU
+	unsigned long alloc_header_addr;
+#endif
+	char *aux_data_buf;
+	int aux_data_size;
+#ifdef CONFIG_AM_VDEC_DV
+	unsigned char dv_enhance_exist;
+#endif
+	int canvas_pos;
+	int vf_ref;
 };
 
+#define AUX_DATA_SIZE(pic) (hw->buffer_spec[pic->buf_spec_num].aux_data_size)
+#define AUX_DATA_BUF(pic) (hw->buffer_spec[pic->buf_spec_num].aux_data_buf)
+#define DEL_EXIST(h, p) (h->buffer_spec[p->buf_spec_num].dv_enhance_exist)
+
 #define spec2canvas(x)  \
 	(((x)->v_canvas_index << 16) | \
 	 ((x)->u_canvas_index << 8)  | \
 	 ((x)->y_canvas_index << 0))
 
+#define FRAME_INDEX(vf_index) (vf_index & 0xff)
+#define BUFSPEC_INDEX(vf_index) ((vf_index >> 8) & 0xff)
+#define VF_INDEX(frm_idx, bufspec_idx) (frm_idx | (bufspec_idx << 8))
+
 static struct vframe_s *vh264_vf_peek(void *);
 static struct vframe_s *vh264_vf_get(void *);
 static void vh264_vf_put(struct vframe_s *, void *);
 static int vh264_vf_states(struct vframe_states *states, void *);
 static int vh264_event_cb(int type, void *data, void *private_data);
 static void vh264_work(struct work_struct *work);
+static void vh264_notify_work(struct work_struct *work);
+static void user_data_push_work(struct work_struct *work);
 
 static const char vh264_dec_id[] = "vh264-dev";
 
@@ -241,6 +399,8 @@ static const struct vframe_operations_s vf_provider_ops = {
 #define DEC_RESULT_GET_DATA         4
 #define DEC_RESULT_GET_DATA_RETRY   5
 #define DEC_RESULT_ERROR            6
+#define DEC_RESULT_EOS              7
+#define DEC_RESULT_FORCE_EXIT       8
 
 /*
 static const char *dec_result_str[] = {
@@ -280,38 +440,88 @@ static const char *dec_result_str[] = {
 #define FRAME_COUNTER_REG       AV_SCRATCH_I
 #define RPM_CMD_REG          AV_SCRATCH_A
 #define H264_DECODE_SIZE	AV_SCRATCH_E
+#define H264_DECODE_MODE    AV_SCRATCH_4
+#define H264_DECODE_SEQINFO	AV_SCRATCH_5
+#define H264_AUX_ADR            AV_SCRATCH_C
+#define H264_AUX_DATA_SIZE      AV_SCRATCH_H
+
 #define H264_DECODE_INFO          M4_CONTROL_REG /* 0xc29 */
 #define DPB_STATUS_REG       AV_SCRATCH_J
+#define ERROR_STATUS_REG	AV_SCRATCH_9
+	/*
+	NAL_SEARCH_CTL: bit 0, enable itu_t35
+	NAL_SEARCH_CTL: bit 1, enable mmu
+	*/
+#define NAL_SEARCH_CTL		AV_SCRATCH_9
 #define MBY_MBX                 MB_MOTION_MODE /*0xc07*/
 
+#define DECODE_MODE_SINGLE					0x0
+#define DECODE_MODE_MULTI_FRAMEBASE			0x1
+#define DECODE_MODE_MULTI_STREAMBASE		0x2
+#define DECODE_MODE_MULTI_DVBAL				0x3
+#define DECODE_MODE_MULTI_DVENL				0x4
+static DEFINE_MUTEX(vmh264_mutex);
+
 struct vdec_h264_hw_s {
 	spinlock_t lock;
-
+	spinlock_t bufspec_lock;
+	int id;
 	struct platform_device *platform_dev;
-	struct device *cma_dev;
-	/* struct page *cma_alloc_pages; */
 	unsigned long cma_alloc_addr;
-	int cma_alloc_count;
 	/* struct page *collocate_cma_alloc_pages; */
 	unsigned long collocate_cma_alloc_addr;
-	int collocate_cma_alloc_count;
+
+	u32 prefix_aux_size;
+	u32 suffix_aux_size;
+	void *aux_addr;
+	dma_addr_t aux_phy_addr;
+	/* buffer for storing one itu35 recored */
+	void *sei_itu_data_buf;
+	u32 sei_itu_data_len;
+
+	/* recycle buffer for user data storing all itu35 records */
+	void *sei_user_data_buffer;
+	u32 sei_user_data_wp;
+	int sei_poc;
+	struct work_struct user_data_work;
+	struct StorablePicture *last_dec_picture;
 
 	ulong lmem_addr;
 	dma_addr_t lmem_addr_remap;
 
+	void *bmmu_box;
+#ifdef H264_MMU
+	void *mmu_box;
+	void *frame_mmu_map_addr;
+	dma_addr_t frame_mmu_map_phy_addr;
+	u32	 hevc_cur_buf_idx;
+	u32 losless_comp_body_size;
+	u32 losless_comp_body_size_sao;
+	u32 losless_comp_header_size;
+	u32 mc_buffer_size_u_v;
+	u32 mc_buffer_size_u_v_h;
+	u32  is_idr_frame;
+	u32  is_new_pic;
+	u32  frame_done;
+	u32  frame_busy;
+	unsigned long extif_addr;
+
+#endif
+
 	DECLARE_KFIFO(newframe_q, struct vframe_s *, VF_POOL_SIZE);
 	DECLARE_KFIFO(display_q, struct vframe_s *, VF_POOL_SIZE);
 
 	struct vframe_s vfpool[VF_POOL_SIZE];
-	struct buffer_spec_s buffer_spec[MAX_VF_BUF_NUM];
-	int buffer_spec_num;
+	struct buffer_spec_s buffer_spec[BUFSPEC_POOL_SIZE];
 	struct vframe_s switching_fense_vf;
 	struct h264_dpb_stru dpb;
 	u8 init_flag;
-	u8 set_params_done;
+	u8 has_i_frame;
+	u8 config_bufmgr_done;
 	u32 max_reference_size;
 	u32 decode_pic_count;
 	int start_search_pos;
+	struct vframe_s vframe_dummy;
 
 	unsigned char buffer_empty_flag;
 
@@ -335,6 +545,8 @@ struct vdec_h264_hw_s {
 	u32 use_idr_framerate;
 
 	u32 seq_info;
+	u32 seq_info2;
+	u32 video_signal_from_vui; /*to do .. */
 	u32 timing_info_present_flag;
 	u32 fixed_frame_rate_flag;
 	u32 fixed_frame_rate_check_count;
@@ -352,7 +564,6 @@ struct vdec_h264_hw_s {
 	u32 pts_unstable;	u32 duration_on_correcting;
 	u32 last_checkout_pts;
 	u32 fatal_error_flag;
-	u32 fatal_error_reset;
 	u32 max_refer_buf;
 
 	s32 vh264_stream_switching_state;
@@ -370,15 +581,20 @@ struct vdec_h264_hw_s {
 	u64 first_pts64;
 	bool first_pts_cached;
 
+#if 0
 	void *sei_data_buffer;
 	dma_addr_t sei_data_buffer_phys;
+#endif
 
 	uint error_recovery_mode;
 	uint mb_total;
 	uint mb_width;
 	uint mb_height;
 
-	uint ucode_type;
+	uint i_only;
+	int skip_frame_count;
+	bool no_poc_reorder_flag;
+	bool send_error_frame_flag;
 	dma_addr_t mc_dma_handle;
 	void *mc_cpu_addr;
 	int vh264_reset;
@@ -387,10 +603,9 @@ struct vdec_h264_hw_s {
 
 	struct dec_sysinfo vh264_amstream_dec_info;
 
-	struct work_struct error_wd_work;
-
 	int dec_result;
 	struct work_struct work;
+	struct work_struct notify_work;
 
 	void (*vdec_cb)(struct vdec_s *, void *);
 	void *vdec_cb_arg;
@@ -399,6 +614,9 @@ struct vdec_h264_hw_s {
 
 	/**/
 	unsigned last_frame_time;
+	u32 vf_pre_count;
+	u32 vf_get_count;
+	u32 vf_put_count;
 
 	/* timeout handle */
 	unsigned long int start_process_time;
@@ -411,6 +629,8 @@ struct vdec_h264_hw_s {
 	unsigned decode_dataempty_num;
 	unsigned buffer_empty_recover_num;
 
+	unsigned get_data_count;
+	unsigned get_data_start_time;
 	/**/
 
 	/*log*/
@@ -421,79 +641,671 @@ struct vdec_h264_hw_s {
 	unsigned int total_read_size_pre;
 	unsigned int total_read_size;
 	unsigned int frame_count_pre;
+
+#ifdef CONFIG_AM_VDEC_DV
+	u8 switch_dvlayer_flag;
+	u8 got_valid_nal;
+#endif
+	u8 eos;
+	u8 data_flag;
+	u32 no_error_count;
+	u32 no_error_i_count;
+	/*
+	NODISP_FLAG
+	*/
+	u8 dec_flag;
+
+	u32 ucode_pause_pos;
+
+	u8 reset_bufmgr_flag;
 };
 
 
+static void h264_reconfig(struct vdec_h264_hw_s *hw);
+static void h264_reset_bufmgr(struct vdec_h264_hw_s *hw);
 static void vh264_local_init(struct vdec_h264_hw_s *hw);
 static int vh264_hw_ctx_restore(struct vdec_h264_hw_s *hw);
-static int vh264_stop(struct vdec_h264_hw_s *hw, int mode);
+static int vh264_stop(struct vdec_h264_hw_s *hw);
 static s32 vh264_init(struct vdec_h264_hw_s *hw);
 static void set_frame_info(struct vdec_h264_hw_s *hw, struct vframe_s *vf,
 			u32 index);
+static void release_aux_data(struct vdec_h264_hw_s *hw,
+	int buf_spec_num);
+
+#define		H265_PUT_SAO_4K_SET			0x03
+#define		H265_ABORT_SAO_4K_SET			0x04
+#define		H265_ABORT_SAO_4K_SET_DONE		0x05
+
+#define		SYS_COMMAND			HEVC_ASSIST_SCRATCH_0
+#define		H265_CHECK_AXI_INFO_BASE	HEVC_ASSIST_SCRATCH_8
+#define		H265_SAO_4K_SET_BASE	HEVC_ASSIST_SCRATCH_9
+#define		H265_SAO_4K_SET_COUNT	HEVC_ASSIST_SCRATCH_A
+#define		HEVC_SAO_MMU_STATUS			0x3639
+#define		HEVCD_MPP_ANC2AXI_TBL_DATA		0x3464
+
+#define		HEVC_CM_HEADER_START_ADDR		0x3628
+#define		HEVC_CM_BODY_START_ADDR			0x3626
+#define		HEVC_CM_BODY_LENGTH			0x3627
+#define		HEVC_CM_HEADER_LENGTH			0x3629
+#define		HEVC_CM_HEADER_OFFSET			0x362b
+#define		HEVC_SAO_CTRL9				0x362d
+#define		HEVCD_MPP_DECOMP_CTL3			0x34c4
+#define		HEVCD_MPP_VDEC_MCR_CTL			0x34c8
+
+
+#define H265_DW_NO_SCALE
+#define H265_MEM_MAP_MODE 0  /*0:linear 1:32x32 2:64x32*/
+#define H265_LOSLESS_COMPRESS_MODE
+#define MAX_FRAME_4K_NUM 0x1200
+#define FRAME_MMU_MAP_SIZE  (MAX_FRAME_4K_NUM * 4)
+
+static int  compute_losless_comp_body_size(int width,
+				int height, int bit_depth_10);
+static int  compute_losless_comp_header_size(int width, int height);
+
+
+
+static int hevc_alloc_mmu(struct vdec_h264_hw_s *hw, int pic_idx,
+		int pic_width, int pic_height, u16 bit_depth,
+		unsigned int *mmu_index_adr) {
+	int cur_buf_idx;
+	int bit_depth_10 = (bit_depth != 0x00);
+	int picture_size;
+	u32 cur_mmu_4k_number;
+
+	WRITE_VREG(CURR_CANVAS_CTRL, pic_idx<<24);
+	cur_buf_idx = READ_VREG(CURR_CANVAS_CTRL)&0xff;
+	picture_size = compute_losless_comp_body_size(pic_width,
+					pic_height, bit_depth_10);
+	cur_mmu_4k_number = ((picture_size+(1<<12)-1) >> 12);
+	dpb_print(DECODE_ID(hw),
+		PRINT_FLAG_MMU_DETAIL,
+		"alloc_mmu new_fb_idx %d picture_size %d cur_mmu_4k_number %d\n",
+		cur_buf_idx, picture_size, cur_mmu_4k_number);
+	return decoder_mmu_box_alloc_idx(
+	hw->mmu_box,
+	cur_buf_idx,
+	cur_mmu_4k_number,
+	mmu_index_adr);
 
-unsigned char have_free_buf_spec(struct vdec_s *vdec)
+}
+
+static int  compute_losless_comp_body_size(int width,
+					int height, int bit_depth_10)
 {
-	int i;
-	struct vdec_h264_hw_s *hw = (struct vdec_h264_hw_s *)vdec->private;
-	if ((h264_debug_flag&OUTPUT_CURRENT_BUF) == 0) {
-		for (i = 0; i < hw->buffer_spec_num; i++) {
-			if (hw->buffer_spec[i].used == 0)
-				return 1;
+	int    width_x64;
+	int    height_x32;
+	int    bsize;
+
+	width_x64 = width + 63;
+	width_x64 >>= 6;
+
+	height_x32 = height + 31;
+	height_x32 >>= 5;
+
+#ifdef H264_MMU
+	bsize = (bit_depth_10 ? 4096 : 3264) * width_x64*height_x32;
+#else
+	bsize = (bit_depth_10 ? 4096 : 3072) * width_x64*height_x32;
+#endif
+	return bsize;
+}
+
+static int  compute_losless_comp_header_size(int width, int height)
+{
+	int	width_x64;
+	int	width_x128;
+	int    height_x64;
+	int	hsize;
+
+	width_x64 = width + 63;
+	width_x64 >>= 6;
+
+	width_x128 = width + 127;
+	width_x128 >>= 7;
+
+	height_x64 = height + 63;
+	height_x64 >>= 6;
+
+#ifdef	H264_MMU
+	hsize = 128*width_x64*height_x64;
+#else
+	hsize = 32*width_x128*height_x64;
+#endif
+	return  hsize;
+}
+
+static void    hevc_mcr_config_canv2axitbl(struct vdec_h264_hw_s *hw)
+{
+	int i, size;
+	u32   canvas_addr;
+	unsigned long maddr;
+	int     num_buff = hw->dpb.mDPB.size;
+
+	canvas_addr = ANC0_CANVAS_ADDR;
+	for (i = 0; i < num_buff; i++)
+		WRITE_VREG((canvas_addr + i), i | (i << 8) | (i << 16));
+
+	WRITE_VREG(HEVCD_MPP_ANC2AXI_TBL_CONF_ADDR, (0x1 << 1) | (0x1 << 2));
+	size = hw->losless_comp_body_size + hw->losless_comp_header_size;
+	for (i = 0; i < num_buff; i++) {
+		if (decoder_bmmu_box_alloc_buf_phy(hw->bmmu_box,
+				HEADER_BUFFER_IDX(i), size,
+				DRIVER_HEADER_NAME, &maddr) < 0) {
+			dpb_print(DECODE_ID(hw), 0,
+				"%s malloc compress header failed %d\n",
+				DRIVER_HEADER_NAME, i);
+			/*hw->fatal_error |= DECODER_FATAL_ERROR_NO_MEM;*/
+			return;
 		}
-		return 0;
-	} else
-		return 1;
+		WRITE_VREG(HEVCD_MPP_ANC2AXI_TBL_DATA,  maddr >> 5);
+		hw->buffer_spec[i].alloc_header_addr = maddr;
+		dpb_print(DECODE_ID(hw), PRINT_FLAG_MMU_DETAIL,
+			"%s : canvas: %d  axiaddr:%x size 0x%x\n",
+			__func__, i, (u32)maddr, size);
+	}
+	WRITE_VREG(HEVCD_MPP_ANC2AXI_TBL_CONF_ADDR, 0x1);
+
+	WRITE_VREG(HEVCD_MPP_ANC_CANVAS_ACCCONFIG_ADDR, (0 << 8) | (0<<1) | 1);
+	for (i = 0; i < 32; i++)
+		WRITE_VREG(HEVCD_MPP_ANC_CANVAS_DATA_ADDR, 0);
+	return;
+}
+static void    hevc_mcr_config_mc_ref(struct vdec_h264_hw_s *hw)
+{
+	u32 i;
+	u32 ref_canv;
+	struct Slice *pSlice = &(hw->dpb.mSlice);
+	/*REFLIST[0]*/
+	for (i = 0; i < (unsigned int)(pSlice->listXsize[0]); i++) {
+		struct StorablePicture *ref = pSlice->listX[0][i];
+		WRITE_VREG(CURR_CANVAS_CTRL, ref->buf_spec_num<<24);
+		ref_canv = READ_VREG(CURR_CANVAS_CTRL)&0xffffff;
+		WRITE_VREG(HEVCD_MPP_ANC_CANVAS_ACCCONFIG_ADDR,
+					(ref->buf_spec_num & 0x3f) << 8);
+		WRITE_VREG(HEVCD_MPP_ANC_CANVAS_DATA_ADDR, ref_canv);
+	}
+	/*REFLIST[1]*/
+	for (i = 0; i < (unsigned int)(pSlice->listXsize[1]); i++) {
+		struct StorablePicture *ref = pSlice->listX[1][i];
+		WRITE_VREG(CURR_CANVAS_CTRL, ref->buf_spec_num<<24);
+		ref_canv = READ_VREG(CURR_CANVAS_CTRL)&0xffffff;
+		WRITE_VREG(HEVCD_MPP_ANC_CANVAS_ACCCONFIG_ADDR,
+					(ref->buf_spec_num & 0x3f) << 8);
+		WRITE_VREG(HEVCD_MPP_ANC_CANVAS_DATA_ADDR, ref_canv);
+	}
+	return;
 }
 
-#if 0
-static void buf_spec_recover(struct vdec_h264_hw_s *hw)
-{ /* do not clear buf_spec used by display */
+static void   hevc_mcr_config_mcrcc(struct vdec_h264_hw_s *hw)
+{
+	u32 rdata32;
+	u32 rdata32_2;
+	u32 slice_type;
+	struct StorablePicture *ref;
+	struct Slice *pSlice;
+	slice_type = hw->dpb.mSlice.slice_type;
+	pSlice = &(hw->dpb.mSlice);
+	WRITE_VREG(HEVCD_MCRCC_CTL1, 0x2);
+	if (slice_type == I_SLICE) {
+		WRITE_VREG(HEVCD_MCRCC_CTL1, 0x0);
+		return;
+	}
+	if (slice_type == B_SLICE) {
+		ref = pSlice->listX[0][0];
+		WRITE_VREG(HEVCD_MPP_ANC_CANVAS_ACCCONFIG_ADDR,
+				((ref->buf_spec_num & 0x3f) << 8));
+		rdata32 = READ_VREG(HEVCD_MPP_ANC_CANVAS_DATA_ADDR);
+		rdata32 = rdata32 & 0xffff;
+		rdata32 = rdata32 | (rdata32 << 16);
+		WRITE_VREG(HEVCD_MCRCC_CTL2, rdata32);
+
+		ref = pSlice->listX[1][0];
+		WRITE_VREG(HEVCD_MPP_ANC_CANVAS_ACCCONFIG_ADDR,
+			((ref->buf_spec_num & 0x3f) << 8));
+		rdata32_2 = READ_VREG(HEVCD_MPP_ANC_CANVAS_DATA_ADDR);
+		rdata32_2 = rdata32_2 & 0xffff;
+		rdata32_2 = rdata32_2 | (rdata32_2 << 16);
+		if (rdata32 == rdata32_2) {
+			ref = pSlice->listX[1][1];
+			WRITE_VREG(HEVCD_MPP_ANC_CANVAS_ACCCONFIG_ADDR,
+				((ref->buf_spec_num & 0x3f) << 8));
+			rdata32_2 = READ_VREG(HEVCD_MPP_ANC_CANVAS_DATA_ADDR);
+			rdata32_2 = rdata32_2 & 0xffff;
+			rdata32_2 = rdata32_2 | (rdata32_2 << 16);
+		}
+		WRITE_VREG(HEVCD_MCRCC_CTL3, rdata32_2);
+	} else { /*P-PIC*/
+		ref = pSlice->listX[0][0];
+		WRITE_VREG(HEVCD_MPP_ANC_CANVAS_ACCCONFIG_ADDR,
+				((ref->buf_spec_num & 0x3f) << 8));
+		rdata32 = READ_VREG(HEVCD_MPP_ANC_CANVAS_DATA_ADDR);
+		rdata32 = rdata32 & 0xffff;
+		rdata32 = rdata32 | (rdata32 << 16);
+		WRITE_VREG(HEVCD_MCRCC_CTL2, rdata32);
+
+		ref = pSlice->listX[0][1];
+		WRITE_VREG(HEVCD_MPP_ANC_CANVAS_ACCCONFIG_ADDR,
+				((ref->buf_spec_num & 0x3f) << 8));
+		rdata32 = READ_VREG(HEVCD_MPP_ANC_CANVAS_DATA_ADDR);
+		rdata32 = rdata32 & 0xffff;
+		rdata32 = rdata32 | (rdata32 << 16);
+		WRITE_VREG(HEVCD_MCRCC_CTL3, rdata32);
+	}
+	WRITE_VREG(HEVCD_MCRCC_CTL1, 0xff0);
+	return;
+}
+
+static void  hevc_mcr_sao_global_hw_init(struct vdec_h264_hw_s *hw,
+		u32 width, u32 height) {
+	u32 data32;
+	u32 lcu_x_num, lcu_y_num;
+	u32 lcu_total;
+	u32 mc_buffer_size_u_v;
+	u32 mc_buffer_size_u_v_h;
+
+	lcu_x_num = (width + 15) >> 4;
+	lcu_y_num = (height + 15) >> 4;
+	lcu_total = lcu_x_num * lcu_y_num;
+
+	hw->mc_buffer_size_u_v = mc_buffer_size_u_v = lcu_total*16*16/2;
+	hw->mc_buffer_size_u_v_h =
+		mc_buffer_size_u_v_h = (mc_buffer_size_u_v + 0xffff)>>16;
+
+	hw->losless_comp_body_size = 0;
+
+	hw->losless_comp_body_size_sao =
+			compute_losless_comp_body_size(width, height, 0);
+	hw->losless_comp_header_size =
+			compute_losless_comp_header_size(width, height);
+
+	WRITE_VREG(HEVCD_IPP_TOP_CNTL, 0x1); /*sw reset ipp10b_top*/
+	WRITE_VREG(HEVCD_IPP_TOP_CNTL, 0x0); /*sw reset ipp10b_top*/
+
+	/* setup lcu_size = 16*/
+	WRITE_VREG(HEVCD_IPP_TOP_LCUCONFIG, 16); /*set lcu size = 16*/
+	/*pic_width/pic_height*/
+	WRITE_VREG(HEVCD_IPP_TOP_FRMCONFIG,
+		(height & 0xffff) << 16 | (width & 0xffff));
+	/* bitdepth_luma = 8*/
+	/* bitdepth_chroma = 8*/
+	WRITE_VREG(HEVCD_IPP_BITDEPTH_CONFIG, 0x0);/*set bit-depth 8 */
+
+#ifdef	H265_LOSLESS_COMPRESS_MODE
+	WRITE_VREG(HEVCD_MPP_DECOMP_CTL1, (0x1 << 4));
+	WRITE_VREG(HEVCD_MPP_DECOMP_CTL2, 0x0);
+#else
+	WRITE_VREG(HEVCD_MPP_DECOMP_CTL1, 0x1 << 31);
+#endif
+	data32 = READ_VREG(HEVCD_IPP_AXIIF_CONFIG);
+	data32 &= (~0x30);
+	data32 |= (H265_MEM_MAP_MODE << 4);
+	WRITE_VREG(HEVCD_IPP_AXIIF_CONFIG, data32);
+
+	WRITE_VREG(HEVCD_MPP_DECOMP_CTL3,
+			(0x80 << 20) | (0x80 << 10) | (0xff));
+
+	WRITE_VREG(HEVCD_MPP_VDEC_MCR_CTL, 0x1 | (0x1 << 4));
+
+	/*comfig vdec:h264:mdec to use hevc mcr/mcrcc/decomp*/
+	WRITE_VREG(MDEC_PIC_DC_MUX_CTRL,
+			READ_VREG(MDEC_PIC_DC_MUX_CTRL) | 0x1 << 31);
+	/* ipp_enable*/
+	WRITE_VREG(HEVCD_IPP_TOP_CNTL, 0x1 << 1);
+
+	data32 = READ_VREG(HEVC_SAO_CTRL0);
+	data32 &= (~0xf);
+	data32 |= 0x4;
+	WRITE_VREG(HEVC_SAO_CTRL0, data32);
+	WRITE_VREG(HEVC_SAO_PIC_SIZE, (height & 0xffff) << 16 |
+			(width & 0xffff));
+	data32  = ((lcu_x_num-1) | (lcu_y_num-1) << 16);
+
+	WRITE_VREG(HEVC_SAO_PIC_SIZE_LCU, data32);
+	data32  =  (lcu_x_num  | lcu_y_num << 16);
+	WRITE_VREG(HEVC_SAO_TILE_SIZE_LCU, data32);
+	data32 = (mc_buffer_size_u_v_h << 16) << 1;
+	WRITE_VREG(HEVC_SAO_Y_LENGTH, data32);
+	data32 = (mc_buffer_size_u_v_h << 16);
+	WRITE_VREG(HEVC_SAO_C_LENGTH, data32);
+
+	data32 = READ_VREG(HEVC_SAO_CTRL1);
+	data32 &= (~0x3000);
+	data32 |= ((H265_MEM_MAP_MODE << 12) | 2);  /* bit1 : 1 .disable dw */
+	WRITE_VREG(HEVC_SAO_CTRL1, data32);
+
+#ifdef	H265_DW_NO_SCALE
+	WRITE_VREG(HEVC_SAO_CTRL5, READ_VREG(HEVC_SAO_CTRL5) & ~(0xff << 16));
+#endif
+
+
+#ifdef	H265_LOSLESS_COMPRESS_MODE
+	data32 = READ_VREG(HEVC_SAO_CTRL5);
+	data32 |= (1<<9); /*8-bit smem-mode*/
+	WRITE_VREG(HEVC_SAO_CTRL5, data32);
+
+	WRITE_VREG(HEVC_CM_BODY_LENGTH, hw->losless_comp_body_size_sao);
+	WRITE_VREG(HEVC_CM_HEADER_OFFSET, hw->losless_comp_body_size);
+	WRITE_VREG(HEVC_CM_HEADER_LENGTH, hw->losless_comp_header_size);
+#endif
+
+#ifdef	H265_LOSLESS_COMPRESS_MODE
+	WRITE_VREG(HEVC_SAO_CTRL9, READ_VREG(HEVC_SAO_CTRL9) | (0x1 << 1));
+	WRITE_VREG(HEVC_SAO_CTRL5, READ_VREG(HEVC_SAO_CTRL5) | (0x1 << 10));
+#endif
+
+	WRITE_VREG(HEVC_SAO_CTRL9, READ_VREG(HEVC_SAO_CTRL9) | 0x1 << 7);
+
+	memset(hw->frame_mmu_map_addr, 0, FRAME_MMU_MAP_SIZE);
+
+	WRITE_VREG(MDEC_EXTIF_CFG0, hw->extif_addr);
+	WRITE_VREG(MDEC_EXTIF_CFG1, 0x80000000);
+	return;
+}
+
+static void  hevc_sao_set_slice_type(struct vdec_h264_hw_s *hw,
+		u32 is_new_pic, u32 is_idr)
+{
+	hw->is_new_pic = is_new_pic;
+	hw->is_idr_frame = is_idr;
+	return;
+}
+
+static void  hevc_sao_set_pic_buffer(struct vdec_h264_hw_s *hw,
+			struct StorablePicture *pic) {
+	long used_4k_num;
+	u32 mc_y_adr;
+	u32 mc_u_v_adr;
+	/*u32 dw_y_adr;*/
+	/*u32 dw_u_v_adr;*/
+	u32 canvas_addr;
+	int ret;
+	if (hw->is_new_pic != 1)
+		return;
+
+	if (hw->is_idr_frame) {
+		/* William TBD */
+		memset(hw->frame_mmu_map_addr, 0, FRAME_MMU_MAP_SIZE);
+	}
+	if (hw->hevc_cur_buf_idx != 0xffff) {
+		used_4k_num = (READ_VREG(HEVC_SAO_MMU_STATUS) >> 16);
+		if (used_4k_num >= 0)
+			dpb_print(DECODE_ID(hw),
+			PRINT_FLAG_MMU_DETAIL,
+			"release unused buf , used_4k_num %ld index %d\n",
+			used_4k_num, hw->hevc_cur_buf_idx);
+		decoder_mmu_box_free_idx_tail(
+			hw->mmu_box,
+			hw->hevc_cur_buf_idx,
+			used_4k_num);
+	}
+
+	WRITE_VREG(CURR_CANVAS_CTRL, pic->buf_spec_num << 24);
+	canvas_addr = READ_VREG(CURR_CANVAS_CTRL)&0xffffff;
+	WRITE_VREG(HEVCD_MPP_ANC2AXI_TBL_CONF_ADDR, (0x0 << 1) |
+			(0x0 << 2) | ((canvas_addr & 0xff) << 8));
+	mc_y_adr = READ_VREG(HEVCD_MPP_ANC2AXI_TBL_DATA) << 5;
+	WRITE_VREG(HEVCD_MPP_ANC2AXI_TBL_CONF_ADDR, (0x0 << 1) |
+			(0x0 << 2) | (((canvas_addr >> 8) & 0xff) << 8));
+	mc_u_v_adr = READ_VREG(HEVCD_MPP_ANC2AXI_TBL_DATA) << 5;
+	WRITE_VREG(HEVCD_MPP_ANC2AXI_TBL_CONF_ADDR, 0x1);
+
+	/*dw_y_adr = H265_DOUBLE_WRITE_YSTART_TEMP;*/
+	/*dw_u_v_adr =  H265_DOUBLE_WRITE_CSTART_TEMP;*/
+#ifdef	H265_LOSLESS_COMPRESS_MODE
+	/*WRITE_VREG(HEVC_SAO_Y_START_ADDR, dw_y_adr);*/
+	WRITE_VREG(HEVC_CM_BODY_START_ADDR, mc_y_adr);
+#ifdef	H264_MMU
+	WRITE_VREG(HEVC_CM_HEADER_START_ADDR, mc_y_adr);
+#else
+	WRITE_VREG(HEVC_CM_HEADER_START_ADDR,
+			(mc_y_adr + hw->losless_comp_body_size));
+#endif
+#else
+	WRITE_VREG(HEVC_SAO_Y_START_ADDR, mc_y_adr);
+#endif
+
+#ifndef H265_LOSLESS_COMPRESS_MODE
+	WRITE_VREG(HEVC_SAO_C_START_ADDR, mc_u_v_adr);
+#else
+	/*WRITE_VREG(HEVC_SAO_C_START_ADDR, dw_u_v_adr);*/
+#endif
+
+#ifndef LOSLESS_COMPRESS_MODE
+/*	WRITE_VREG(HEVC_SAO_Y_WPTR, mc_y_adr);*/
+/*	WRITE_VREG(HEVC_SAO_C_WPTR, mc_u_v_adr); */
+#else
+	WRITE_VREG(HEVC_SAO_Y_WPTR, dw_y_adr);
+	WRITE_VREG(HEVC_SAO_C_WPTR, dw_u_v_adr);
+#endif
+
+	ret = hevc_alloc_mmu(hw, pic->buf_spec_num,
+			hw->frame_width, hw->frame_height, 0x0,
+			hw->frame_mmu_map_addr);
+	if (ret != 0) {
+		dpb_print(DECODE_ID(hw),
+		PRINT_FLAG_MMU_DETAIL, "can't alloc need mmu1,idx %d ret =%d\n",
+		pic->buf_spec_num,
+		ret);
+		return;
+	}
+
+	/*Reset SAO + Enable SAO slice_start*/
+	WRITE_VREG(HEVC_SAO_INT_STATUS,
+			READ_VREG(HEVC_SAO_INT_STATUS) | 0x1 << 28);
+	WRITE_VREG(HEVC_SAO_INT_STATUS,
+			READ_VREG(HEVC_SAO_INT_STATUS) | 0x1 << 31);
+	/*pr_info("hevc_sao_set_pic_buffer:mc_y_adr: %x\n", mc_y_adr);*/
+	/*Send coommand to hevc-code to supply 4k buffers to sao*/
+	WRITE_VREG(H265_SAO_4K_SET_BASE, (u32)hw->frame_mmu_map_phy_addr);
+	WRITE_VREG(H265_SAO_4K_SET_COUNT, MAX_FRAME_4K_NUM);
+	WRITE_VREG(SYS_COMMAND, H265_PUT_SAO_4K_SET);
+	hw->frame_busy = 1;
+	return;
+}
+
+
+static void  hevc_set_unused_4k_buff_idx(struct vdec_h264_hw_s *hw,
+		u32 buf_spec_num) {
+	WRITE_VREG(CURR_CANVAS_CTRL, buf_spec_num<<24);
+	hw->hevc_cur_buf_idx = READ_VREG(CURR_CANVAS_CTRL)&0xff;
+	dpb_print(DECODE_ID(hw),
+		PRINT_FLAG_MMU_DETAIL, " %s  cur_buf_idx %d  buf_spec_num %d\n",
+		__func__, hw->hevc_cur_buf_idx, buf_spec_num);
+	return;
+}
+
+
+static void  hevc_set_frame_done(struct vdec_h264_hw_s *hw)
+{
+	dpb_print(DECODE_ID(hw),
+		PRINT_FLAG_MMU_DETAIL, "hevc_frame_done...set\n");
+	while ((READ_VREG(HEVC_SAO_INT_STATUS) & 0x1) == 0) {
+		dpb_print(DECODE_ID(hw),
+		PRINT_FLAG_MMU_DETAIL, " %s...wait\n", __func__);
+	}
+	WRITE_VREG(HEVC_SAO_INT_STATUS, 0x1);
+	hw->frame_done = 1;
+	return;
+}
+
+static void  hevc_sao_wait_done(struct vdec_h264_hw_s *hw)
+{
+	dpb_print(DECODE_ID(hw),
+		PRINT_FLAG_MMU_DETAIL, "hevc_sao_wait_done...start\n");
+	while ((READ_VREG(HEVC_SAO_INT_STATUS) >> 31))
+		dpb_print(DECODE_ID(hw),
+		PRINT_FLAG_MMU_DETAIL, "hevc_sao_wait_done...wait\n");
+
+	if ((hw->frame_busy == 1) && (hw->frame_done == 1)) {
+		WRITE_VREG(SYS_COMMAND, H265_ABORT_SAO_4K_SET);
+		while ((READ_VREG(SYS_COMMAND) & 0xff) !=
+				H265_ABORT_SAO_4K_SET_DONE) {
+			dpb_print(DECODE_ID(hw),
+			PRINT_FLAG_MMU_DETAIL,
+			"hevc_sao_wait_done...wait h265_abort_sao_4k_set_done\n");
+		}
+		hw->frame_busy = 0;
+		hw->frame_done = 0;
+	}
+	return;
+}
+static void buf_spec_init(struct vdec_h264_hw_s *hw)
+{
 	int i;
-	dpb_print(hw->dpb.decoder_index,
-	PRINT_FLAG_DPB, "%s\n", __func__);
-	for (i = 0; i < hw->buffer_spec_num; i++) {
-		if (hw->buffer_spec[i].used == 2)
-			hw->buffer_spec[i].used = 3;
+	unsigned long flags;
+	spin_lock_irqsave(&hw->bufspec_lock, flags);
+	for (i = 0; i < BUFSPEC_POOL_SIZE; i++) {
+		hw->buffer_spec[i].used = -1;
+		hw->buffer_spec[i].canvas_pos = -1;
+	}
+	spin_unlock_irqrestore(&hw->bufspec_lock, flags);
+}
+
+/*is active in buf management */
+static unsigned char is_buf_spec_in_use(struct vdec_h264_hw_s *hw,
+	int buf_spec_num)
+{
+	unsigned char ret = 0;
+	if (hw->buffer_spec[buf_spec_num].used == 1 ||
+		hw->buffer_spec[buf_spec_num].used == 2 ||
+		hw->buffer_spec[buf_spec_num].used == 3 ||
+		hw->buffer_spec[buf_spec_num].used == 5)
+		ret = 1;
+	return ret;
+}
+
+static unsigned char is_buf_spec_in_disp_q(struct vdec_h264_hw_s *hw,
+	int buf_spec_num)
+{
+	unsigned char ret = 0;
+	if (hw->buffer_spec[buf_spec_num].used == 2 ||
+		hw->buffer_spec[buf_spec_num].used == 3 ||
+		hw->buffer_spec[buf_spec_num].used == 5)
+		ret = 1;
+	return ret;
+}
+
+static int alloc_one_buf_spec(struct vdec_h264_hw_s *hw, int i)
+{
+	if (mmu_enable) {
+		if (hw->buffer_spec[i].alloc_header_addr)
+			return 0;
 		else
-			hw->buffer_spec[i].used = 0;
+			return -1;
+	} else {
+
+		int	buf_size = (hw->mb_total << 8) + (hw->mb_total << 7);
+		int addr;
+		if (hw->buffer_spec[i].cma_alloc_addr)
+			return 0;
+
+	if (decoder_bmmu_box_alloc_buf_phy(hw->bmmu_box, i,
+		PAGE_ALIGN(buf_size), DRIVER_NAME,
+		&hw->buffer_spec[i].cma_alloc_addr) < 0) {
+		hw->buffer_spec[i].cma_alloc_addr = 0;
+		dpb_print(DECODE_ID(hw), 0,
+		"%s, fail to alloc buf for bufspec%d, try later\n",
+				__func__, i
+		);
+		return -1;
+	}
+	hw->buffer_spec[i].buf_adr =
+	hw->buffer_spec[i].cma_alloc_addr;
+	addr = hw->buffer_spec[i].buf_adr;
+
+
+	hw->buffer_spec[i].y_addr = addr;
+	addr += hw->mb_total << 8;
+
+	hw->buffer_spec[i].u_addr = addr;
+	hw->buffer_spec[i].v_addr = addr;
+	addr += hw->mb_total << 7;
+
+	hw->buffer_spec[i].canvas_config[0].phy_addr =
+			hw->buffer_spec[i].y_addr;
+	hw->buffer_spec[i].canvas_config[0].width =
+			hw->mb_width << 4;
+	hw->buffer_spec[i].canvas_config[0].height =
+			hw->mb_height << 4;
+	hw->buffer_spec[i].canvas_config[0].block_mode =
+			CANVAS_BLKMODE_32X32;
+
+		hw->buffer_spec[i].canvas_config[1].phy_addr =
+				hw->buffer_spec[i].u_addr;
+		hw->buffer_spec[i].canvas_config[1].width =
+				hw->mb_width << 4;
+		hw->buffer_spec[i].canvas_config[1].height =
+				hw->mb_height << 3;
+		hw->buffer_spec[i].canvas_config[1].block_mode =
+				CANVAS_BLKMODE_32X32;
+		dpb_print(DECODE_ID(hw), PRINT_FLAG_VDEC_STATUS,
+		"%s, alloc buf for bufspec%d\n",
+				__func__, i
+		);
 	}
+	return 0;
+}
+
+static void config_decode_canvas(struct vdec_h264_hw_s *hw, int i)
+{
+	canvas_config(hw->buffer_spec[i].
+		y_canvas_index,
+		hw->buffer_spec[i].y_addr,
+		hw->mb_width << 4,
+		hw->mb_height << 4,
+		CANVAS_ADDR_NOWRAP,
+		CANVAS_BLKMODE_32X32);
+
+	canvas_config(hw->buffer_spec[i].
+		u_canvas_index,
+		hw->buffer_spec[i].u_addr,
+		hw->mb_width << 4,
+		hw->mb_height << 3,
+		CANVAS_ADDR_NOWRAP,
+		CANVAS_BLKMODE_32X32);
+	WRITE_VREG(ANC0_CANVAS_ADDR + hw->buffer_spec[i].canvas_pos,
+		spec2canvas(&hw->buffer_spec[i]));
 }
-#endif
 
 int get_free_buf_idx(struct vdec_s *vdec)
 {
 	int i;
+	unsigned long addr, flags;
 	int index = -1;
 	struct vdec_h264_hw_s *hw = (struct vdec_h264_hw_s *)vdec->private;
-
-	if ((h264_debug_flag&OUTPUT_CURRENT_BUF) == 0) {
-		for (i = hw->start_search_pos; i < hw->buffer_spec_num; i++) {
-			if (hw->buffer_spec[i].used == 0) {
+	int buf_total = BUFSPEC_POOL_SIZE;
+	spin_lock_irqsave(&hw->bufspec_lock, flags);
+	for (i = hw->start_search_pos; i < buf_total; i++) {
+		if (mmu_enable)
+			addr = hw->buffer_spec[i].alloc_header_addr;
+		else
+			addr = hw->buffer_spec[i].cma_alloc_addr;
+		if (hw->buffer_spec[i].used == 0	&& addr) {
+			hw->buffer_spec[i].used = 1;
+			hw->start_search_pos = i+1;
+			index = i;
+			break;
+		}
+	}
+	if (index < 0) {
+		for (i = 0; i < hw->start_search_pos; i++) {
+			if (mmu_enable)
+				addr = hw->buffer_spec[i].alloc_header_addr;
+			else
+				addr = hw->buffer_spec[i].cma_alloc_addr;
+			if (hw->buffer_spec[i].used == 0 && addr) {
 				hw->buffer_spec[i].used = 1;
 				hw->start_search_pos = i+1;
 				index = i;
 				break;
 			}
 		}
-		if (index < 0) {
-			for (i = 0; i < hw->start_search_pos; i++) {
-				if (hw->buffer_spec[i].used == 0) {
-					hw->buffer_spec[i].used = 1;
-					hw->start_search_pos = i+1;
-					index = i;
-					break;
-				}
-			}
-		}
-	} else {
-		index = hw->start_search_pos;
-		hw->start_search_pos++;
 	}
-
-	if (hw->start_search_pos >= hw->buffer_spec_num)
+	spin_unlock_irqrestore(&hw->bufspec_lock, flags);
+	if (hw->start_search_pos >= buf_total)
 		hw->start_search_pos = 0;
-
-	dpb_print(hw->dpb.decoder_index, PRINT_FLAG_DPB_DETAIL,
+	dpb_print(DECODE_ID(hw), PRINT_FLAG_DPB_DETAIL,
 			"%s, buf_spec_num %d\n", __func__, index);
 
 	return index;
@@ -501,60 +1313,310 @@ int get_free_buf_idx(struct vdec_s *vdec)
 
 int release_buf_spec_num(struct vdec_s *vdec, int buf_spec_num)
 {
+	u32 cur_buf_idx;
+	unsigned long flags;
 	struct vdec_h264_hw_s *hw = (struct vdec_h264_hw_s *)vdec->private;
-	dpb_print(hw->dpb.decoder_index, PRINT_FLAG_DPB_DETAIL,
-		"%s buf_spec_num %d\n",
-		__func__, buf_spec_num);
-	if (buf_spec_num >= 0 && buf_spec_num < hw->buffer_spec_num)
+	dpb_print(DECODE_ID(hw), PRINT_FLAG_MMU_DETAIL,
+		"%s buf_spec_num %d used %d\n",
+		__func__, buf_spec_num,
+		hw->buffer_spec[buf_spec_num].used);
+	if (buf_spec_num >= 0 &&
+		buf_spec_num < BUFSPEC_POOL_SIZE
+		) {
+		spin_lock_irqsave(&hw->bufspec_lock, flags);
 		hw->buffer_spec[buf_spec_num].used = 0;
+		spin_unlock_irqrestore(&hw->bufspec_lock, flags);
+		if (mmu_enable) {
+			WRITE_VREG(CURR_CANVAS_CTRL, buf_spec_num<<24);
+			cur_buf_idx = READ_VREG(CURR_CANVAS_CTRL);
+			cur_buf_idx = cur_buf_idx&0xff;
+			decoder_mmu_box_free_idx(hw->mmu_box, cur_buf_idx);
+		}
+		release_aux_data(hw, buf_spec_num);
+	}
 	return 0;
 }
 
-static int get_buf_spec_idx_by_canvas_config(struct vdec_h264_hw_s *hw,
-	struct canvas_config_s *cfg)
+static void config_buf_specs(struct vdec_s *vdec)
+{
+	int i, j;
+	unsigned long flags;
+	struct vdec_h264_hw_s *hw = (struct vdec_h264_hw_s *)vdec->private;
+	spin_lock_irqsave(&hw->bufspec_lock, flags);
+	for (i = 0, j = 0;
+		j < hw->dpb.mDPB.size
+		&& i < BUFSPEC_POOL_SIZE;
+		i++) {
+		int canvas;
+		if (hw->buffer_spec[i].used != -1)
+			continue;
+		canvas = vdec->get_canvas(j, 2);
+		hw->buffer_spec[i].y_canvas_index = canvas_y(canvas);
+		hw->buffer_spec[i].u_canvas_index = canvas_u(canvas);
+		hw->buffer_spec[i].v_canvas_index = canvas_v(canvas);
+		hw->buffer_spec[i].used = 0;
+
+		hw->buffer_spec[i].canvas_pos = j;
+
+		/*pr_info("config canvas (%d) %x for bufspec %d\r\n",
+			j, canvas, i);*/
+		j++;
+	}
+	spin_unlock_irqrestore(&hw->bufspec_lock, flags);
+}
+
+void dealloc_buf_specs(struct vdec_h264_hw_s *hw)
 {
 	int i;
-	for (i = 0; i < hw->buffer_spec_num; i++) {
-		if (hw->buffer_spec[i].canvas_config[0].phy_addr
-			== cfg->phy_addr)
-			return i;
+	unsigned long flags;
+	for (i = 0; i < BUFSPEC_POOL_SIZE; i++) {
+		if (hw->buffer_spec[i].used == 4) {
+			dpb_print(DECODE_ID(hw),
+				PRINT_FLAG_DPB_DETAIL,
+				"%s buf_spec_num %d\n",
+				__func__, i
+				);
+			spin_lock_irqsave
+				(&hw->bufspec_lock, flags);
+			hw->buffer_spec[i].used = -1;
+			spin_unlock_irqrestore
+				(&hw->bufspec_lock, flags);
+			release_aux_data(hw, i);
+
+			if (!mmu_enable) {
+				if (hw->buffer_spec[i].cma_alloc_addr) {
+					decoder_bmmu_box_free_idx(
+						hw->bmmu_box,
+						i);
+					spin_lock_irqsave
+						(&hw->bufspec_lock, flags);
+					hw->buffer_spec[i].cma_alloc_addr = 0;
+					hw->buffer_spec[i].buf_adr = 0;
+					spin_unlock_irqrestore
+						(&hw->bufspec_lock, flags);
+				}
+			} else {
+				if (hw->buffer_spec[i].alloc_header_addr) {
+					decoder_mmu_box_free_idx(
+						hw->mmu_box,
+						i);
+					spin_lock_irqsave
+						(&hw->bufspec_lock, flags);
+					hw->buffer_spec[i].
+						alloc_header_addr = 0;
+					hw->buffer_spec[i].buf_adr = 0;
+					spin_unlock_irqrestore
+						(&hw->bufspec_lock, flags);
+				}
+			}
+		}
 	}
-	return -1;
+	return;
 }
 
-int prepare_display_buf(struct vdec_s *vdec, struct FrameStore *frame)
+unsigned char have_free_buf_spec(struct vdec_s *vdec)
 {
+	int i;
+	unsigned long addr;
 	struct vdec_h264_hw_s *hw = (struct vdec_h264_hw_s *)vdec->private;
-	struct vframe_s *vf = NULL;
+	int canvas_pos_min = BUFSPEC_POOL_SIZE;
+	int index = -1;
+	int ret = 0;
+	int allocated_count = 0;
+	for (i = 0; i < BUFSPEC_POOL_SIZE; i++) {
+		if (mmu_enable)
+			addr = hw->buffer_spec[i].alloc_header_addr;
+		else
+			addr = hw->buffer_spec[i].cma_alloc_addr;
+		if (hw->buffer_spec[i].used == 0) {
 
-	if (kfifo_get(&hw->newframe_q, &vf) == 0) {
-		dpb_print(hw->dpb.decoder_index, PRINT_FLAG_VDEC_STATUS,
-			"%s fatal error, no available buffer slot.\n",
-			__func__);
+			if (addr)
+				return 1;
+			if (hw->buffer_spec[i].canvas_pos < canvas_pos_min) {
+				canvas_pos_min = hw->buffer_spec[i].canvas_pos;
+				index = i;
+			}
+		}
+		if (addr)
+			allocated_count++;
+	}
+	if (index >= 0) {
+		mutex_lock(&vmh264_mutex);
+		dealloc_buf_specs(hw);
+		if (max_alloc_buf_count == 0 ||
+			allocated_count < max_alloc_buf_count) {
+			if (alloc_one_buf_spec(hw, index) >= 0)
+				ret = 1;
+		}
+		mutex_unlock(&vmh264_mutex);
+	}
+	return ret;
+}
+
+static int get_buf_spec_by_canvas_pos(struct vdec_h264_hw_s *hw,
+	int canvas_pos)
+{
+	int i;
+	int j = 0;
+	for (i = 0; i < BUFSPEC_POOL_SIZE; i++) {
+		if (hw->buffer_spec[i].canvas_pos >= 0) {
+			if (j == canvas_pos)
+				return i;
+			j++;
+		}
+	}
+	return -1;
+}
+static void update_vf_memhandle(struct vdec_h264_hw_s *hw,
+	struct vframe_s *vf, int index)
+{
+	if (index < 0) {
+		vf->mem_handle = NULL;
+		vf->mem_head_handle = NULL;
+	} else if (vf->type & VIDTYPE_SCATTER) {
+		vf->mem_handle =
+			decoder_mmu_box_get_mem_handle(
+				hw->mmu_box, index);
+		vf->mem_head_handle =
+			decoder_bmmu_box_get_mem_handle(
+				hw->bmmu_box, HEADER_BUFFER_IDX(index));
+	} else {
+		vf->mem_handle =
+			decoder_bmmu_box_get_mem_handle(
+				hw->bmmu_box, VF_BUFFER_IDX(index));
+	/*	vf->mem_head_handle =
+			decoder_bmmu_box_get_mem_handle(
+				hw->bmmu_box, HEADER_BUFFER_IDX(index));*/
+	}
+	return;
+}
+int prepare_display_buf(struct vdec_s *vdec, struct FrameStore *frame)
+{
+	struct vdec_h264_hw_s *hw = (struct vdec_h264_hw_s *)vdec->private;
+	struct vframe_s *vf = NULL;
+	int buffer_index = frame->buf_spec_num;
+	int vf_count = 1;
+	int i;
+	if (buffer_index < 0 || buffer_index >= BUFSPEC_POOL_SIZE) {
+		dpb_print(DECODE_ID(hw), 0,
+			"%s, buffer_index 0x%x is beyond range\n",
+			__func__, buffer_index);
+		return -1;
+	}
+	if (force_disp_bufspec_num & 0x100) {
+		/*recycle directly*/
+		if (hw->buffer_spec[frame->buf_spec_num].used != 3 &&
+			hw->buffer_spec[frame->buf_spec_num].used != 5)
+			set_frame_output_flag(&hw->dpb, frame->index);
+
+		/*make pre_output not set*/
+		return -1;
+	}
+	if (error_proc_policy & 0x1000) {
+		int error_skip_i_count = (error_skip_count >> 12) & 0xf;
+		int error_skip_frame_count = error_skip_count & 0xfff;
+		if (((hw->no_error_count < error_skip_frame_count)
+			&& (error_skip_i_count == 0 ||
+			hw->no_error_i_count < error_skip_i_count))
+			&& (!(frame->data_flag & I_FLAG)))
+			frame->data_flag |= ERROR_FLAG;
+	}
+	if ((frame->data_flag & NODISP_FLAG) ||
+		(frame->data_flag & NULL_FLAG) ||
+		((!hw->send_error_frame_flag) &&
+			(frame->data_flag & ERROR_FLAG)) ||
+		((hw->i_only & 0x1) &&
+		(!(frame->data_flag & I_FLAG)))
+			) {
+		set_frame_output_flag(&hw->dpb, frame->index);
 		return -1;
 	}
+	display_frame_count[DECODE_ID(hw)]++;
 
-	if (vf) {
-		int buffer_index = frame->buf_spec_num;
-		dpb_print(hw->dpb.decoder_index, PRINT_FLAG_DPB_DETAIL,
+	if (dpb_is_debug(DECODE_ID(hw),
+	 PRINT_FLAG_DPB_DETAIL)) {
+		dpb_print(DECODE_ID(hw), 0,
 			"%s, fs[%d] poc %d, buf_spec_num %d\n",
 			__func__, frame->index, frame->poc,
 			frame->buf_spec_num);
-		vf->index = frame->index;
-		vf->type = VIDTYPE_PROGRESSIVE | VIDTYPE_VIU_FIELD |
-				VIDTYPE_VIU_NV21;
+		print_pic_info(DECODE_ID(hw), "predis_frm",
+			frame->frame, -1);
+		print_pic_info(DECODE_ID(hw), "predis_top",
+			frame->top_field, -1);
+		print_pic_info(DECODE_ID(hw), "predis_bot",
+			frame->bottom_field, -1);
+	}
+
+	if (frame->frame == NULL ||
+		frame->top_field == NULL ||
+		frame->bottom_field == NULL ||
+		frame->frame->coded_frame)
+		vf_count = 1;
+	else
+		vf_count = 2;
+	hw->buffer_spec[buffer_index].vf_ref = 0;
+	for (i = 0; i < vf_count; i++) {
+		if (kfifo_get(&hw->newframe_q, &vf) == 0 ||
+			vf == NULL) {
+			dpb_print(DECODE_ID(hw), PRINT_FLAG_ERROR,
+				"%s fatal error, no available buffer slot.\n",
+				__func__);
+			return -1;
+		}
 		vf->duration_pulldown = 0;
 		vf->pts = frame->pts;
 		vf->pts_us64 = frame->pts64;
-		vf->canvas0Addr = vf->canvas1Addr =
+		vf->index = VF_INDEX(frame->index, buffer_index);
+		if (mmu_enable) {
+			vf->type = VIDTYPE_COMPRESS | VIDTYPE_VIU_FIELD;
+			vf->type |= VIDTYPE_SCATTER;
+			vf->bitdepth =
+				BITDEPTH_Y8 | BITDEPTH_U8 | BITDEPTH_V8;
+			vf->bitdepth |= BITDEPTH_SAVING_MODE;
+			vf->compWidth = hw->frame_width;
+			vf->compHeight = hw->frame_height;
+			vf->compHeadAddr =
+				hw->buffer_spec[buffer_index].alloc_header_addr;
+			vf->compBodyAddr = 0;
+			vf->canvas0Addr = vf->canvas1Addr = 0;
+		} else {
+			vf->type = VIDTYPE_PROGRESSIVE | VIDTYPE_VIU_FIELD |
+				VIDTYPE_VIU_NV21;
+			vf->canvas0Addr = vf->canvas1Addr =
 			spec2canvas(&hw->buffer_spec[buffer_index]);
+		}
 		set_frame_info(hw, vf, buffer_index);
-		kfifo_put(&hw->display_q, (const struct vframe_s *)vf);
+		vf->flag = 0;
+		if (frame->data_flag & I_FLAG)
+			vf->flag |= VFRAME_FLAG_SYNCFRAME;
+		if (frame->data_flag & ERROR_FLAG)
+			vf->flag |= VFRAME_FLAG_ERROR_RECOVERY;
+		update_vf_memhandle(hw, vf, buffer_index);
 		hw->buffer_spec[buffer_index].used = 2;
-
+		hw->buffer_spec[buffer_index].vf_ref++;
+
+		if (frame->frame &&
+			frame->top_field &&
+			frame->bottom_field &&
+			(!frame->frame->coded_frame)) {
+			vf->type =
+				VIDTYPE_INTERLACE_FIRST |
+				VIDTYPE_VIU_NV21;
+			if (frame->top_field->poc <=
+				frame->bottom_field->poc) /*top first*/
+				vf->type |= (i == 0 ?
+					VIDTYPE_INTERLACE_TOP :
+					VIDTYPE_INTERLACE_BOTTOM);
+			else
+				vf->type |= (i == 0 ?
+					VIDTYPE_INTERLACE_BOTTOM :
+					VIDTYPE_INTERLACE_TOP);
+			vf->duration = vf->duration/2;
+		}
+		kfifo_put(&hw->display_q, (const struct vframe_s *)vf);
+		hw->vf_pre_count++;
 		vf_notify_receiver(vdec->vf_provider_name,
 			VFRAME_EVENT_PROVIDER_VFRAME_READY, NULL);
-		decode_frame_count[hw->dpb.decoder_index]++;
 	}
 
 	return 0;
@@ -581,8 +1643,9 @@ void print_pic_info(int decindex, const char *info,
 			struct StorablePicture *pic,
 			int slice_type)
 {
-	dpb_print(decindex, PRINT_FLAG_UCODE_EVT,
-		"%s: %s (original %s), %s, mb_aff_frame_flag %d  poc %d, pic_num %d, buf_spec_num %d\n",
+	if (pic)
+		dpb_print(decindex, PRINT_FLAG_DEC_DETAIL,
+		"%s: %s (original %s), %s, mb_aff_frame_flag %d  poc %d, pic_num %d, buf_spec_num %d data_flag 0x%x\n",
 		info,
 		picture_structure_name[pic->structure],
 		pic->coded_frame ? "Frame" : "Field",
@@ -590,7 +1653,8 @@ void print_pic_info(int decindex, const char *info,
 		pic->mb_aff_frame_flag,
 		pic->poc,
 		pic->pic_num,
-		pic->buf_spec_num);
+		pic->buf_spec_num,
+		pic->data_flag);
 }
 
 static void reset_process_time(struct vdec_h264_hw_s *hw)
@@ -599,19 +1663,284 @@ static void reset_process_time(struct vdec_h264_hw_s *hw)
 		unsigned process_time =
 			1000 * (jiffies - hw->start_process_time) / HZ;
 		hw->start_process_time = 0;
-		if (process_time > max_process_time[hw->dpb.decoder_index])
-			max_process_time[hw->dpb.decoder_index] = process_time;
+		if (process_time > max_process_time[DECODE_ID(hw)])
+			max_process_time[DECODE_ID(hw)] = process_time;
+	}
+}
+
+static void start_process_time(struct vdec_h264_hw_s *hw)
+{
+	hw->decode_timeout_count = 2;
+	hw->start_process_time = jiffies;
+}
+
+static void config_aux_buf(struct vdec_h264_hw_s *hw)
+{
+	WRITE_VREG(H264_AUX_ADR, hw->aux_phy_addr);
+	WRITE_VREG(H264_AUX_DATA_SIZE,
+		((hw->prefix_aux_size >> 4) << 16) |
+		(hw->suffix_aux_size >> 4)
+		);
+}
+
+/*
+* dv_meta_flag: 1, dolby meta only; 2, not include dolby meta
+*/
+static void set_aux_data(struct vdec_h264_hw_s *hw,
+	struct StorablePicture *pic, unsigned char suffix_flag,
+	unsigned char dv_meta_flag, struct vdec_h264_hw_s *hw_b)
+{
+	int i;
+	unsigned short *aux_adr;
+	unsigned size_reg_val =
+		READ_VREG(H264_AUX_DATA_SIZE);
+	unsigned aux_count = 0;
+	int aux_size = 0;
+	struct vdec_h264_hw_s *hw_buf = hw_b ? hw_b : hw;
+	if (pic->buf_spec_num < 0 || pic->buf_spec_num >= BUFSPEC_POOL_SIZE
+		|| (!is_buf_spec_in_use(hw, pic->buf_spec_num)))
+		return;
+
+	if (suffix_flag) {
+		aux_adr = (unsigned short *)
+			(hw_buf->aux_addr +
+			hw_buf->prefix_aux_size);
+		aux_count =
+		((size_reg_val & 0xffff) << 4)
+			>> 1;
+		aux_size =
+			hw_buf->suffix_aux_size;
+	} else {
+		aux_adr =
+		(unsigned short *)hw_buf->aux_addr;
+		aux_count =
+		((size_reg_val >> 16) << 4)
+			>> 1;
+		aux_size =
+			hw_buf->prefix_aux_size;
+	}
+	if (dpb_is_debug(DECODE_ID(hw),
+		 PRINT_FLAG_DPB_DETAIL)) {
+		dpb_print(DECODE_ID(hw), 0,
+			"%s:old size %d count %d,suf %d dv_flag %d\r\n",
+			__func__, AUX_DATA_SIZE(pic),
+			aux_count, suffix_flag, dv_meta_flag);
+	}
+	if (aux_size > 0 && aux_count > 0) {
+		int heads_size = 0;
+		int new_size;
+		char *new_buf;
+		for (i = 0; i < aux_count; i++) {
+			unsigned char tag = aux_adr[i] >> 8;
+			if (tag != 0 && tag != 0xff) {
+				if (dv_meta_flag == 0)
+					heads_size += 8;
+				else if (dv_meta_flag == 1 && tag == 0x1)
+					heads_size += 8;
+				else if (dv_meta_flag == 2 && tag != 0x1)
+					heads_size += 8;
+			}
+		}
+		new_size = AUX_DATA_SIZE(pic) + aux_count + heads_size;
+		new_buf = krealloc(AUX_DATA_BUF(pic),
+			new_size,
+			GFP_KERNEL);
+		if (new_buf) {
+			unsigned char valid_tag = 0;
+			unsigned char *h =
+				new_buf +
+				AUX_DATA_SIZE(pic);
+			unsigned char *p = h + 8;
+			int len = 0;
+			int padding_len = 0;
+			AUX_DATA_BUF(pic) = new_buf;
+			for (i = 0; i < aux_count; i += 4) {
+				int ii;
+				unsigned char tag = aux_adr[i + 3] >> 8;
+				if (tag != 0 && tag != 0xff) {
+					if (dv_meta_flag == 0)
+						valid_tag = 1;
+					else if (dv_meta_flag == 1
+						&& tag == 0x1)
+						valid_tag = 1;
+					else if (dv_meta_flag == 2
+						&& tag != 0x1)
+						valid_tag = 1;
+					else
+						valid_tag = 0;
+					if (valid_tag && len > 0) {
+						AUX_DATA_SIZE(pic) +=
+						(len + 8);
+						h[0] =
+						(len >> 24) & 0xff;
+						h[1] =
+						(len >> 16) & 0xff;
+						h[2] =
+						(len >> 8) & 0xff;
+						h[3] =
+						(len >> 0) & 0xff;
+						h[6] =
+						(padding_len >> 8)
+						& 0xff;
+						h[7] =
+						(padding_len) & 0xff;
+						h += (len + 8);
+						p += 8;
+						len = 0;
+						padding_len = 0;
+					}
+					if (valid_tag) {
+						h[4] = tag;
+						h[5] = 0;
+						h[6] = 0;
+						h[7] = 0;
+					}
+				}
+				if (valid_tag) {
+					for (ii = 0; ii < 4; ii++) {
+						unsigned short aa =
+							aux_adr[i + 3
+							- ii];
+						*p = aa & 0xff;
+						p++;
+						len++;
+						/*if ((aa >> 8) == 0xff)
+							padding_len++;*/
+					}
+				}
+			}
+			if (len > 0) {
+				AUX_DATA_SIZE(pic) += (len + 8);
+				h[0] = (len >> 24) & 0xff;
+				h[1] = (len >> 16) & 0xff;
+				h[2] = (len >> 8) & 0xff;
+				h[3] = (len >> 0) & 0xff;
+				h[6] = (padding_len >> 8) & 0xff;
+				h[7] = (padding_len) & 0xff;
+			}
+			if (dpb_is_debug(DECODE_ID(hw),
+				PRINT_FLAG_DPB_DETAIL)) {
+				dpb_print(DECODE_ID(hw), 0,
+					"aux: (size %d) suffix_flag %d\n",
+					AUX_DATA_SIZE(pic), suffix_flag);
+				for (i = 0; i < AUX_DATA_SIZE(pic); i++) {
+					dpb_print_cont(DECODE_ID(hw), 0,
+						"%02x ", AUX_DATA_BUF(pic)[i]);
+					if (((i + 1) & 0xf) == 0)
+						dpb_print_cont(
+						DECODE_ID(hw),
+							0, "\n");
+				}
+				dpb_print_cont(DECODE_ID(hw),
+					0, "\n");
+			}
+
+		}
+	}
+
+}
+
+static void release_aux_data(struct vdec_h264_hw_s *hw,
+	int buf_spec_num)
+{
+	kfree(hw->buffer_spec[buf_spec_num].aux_data_buf);
+	hw->buffer_spec[buf_spec_num].aux_data_buf = NULL;
+	hw->buffer_spec[buf_spec_num].aux_data_size = 0;
+}
+
+static void dump_aux_buf(struct vdec_h264_hw_s *hw)
+{
+	int i;
+	unsigned short *aux_adr =
+		(unsigned short *)
+		hw->aux_addr;
+	unsigned aux_size =
+		(READ_VREG(H264_AUX_DATA_SIZE)
+		>> 16) << 4;
+
+	if (hw->prefix_aux_size > 0) {
+		dpb_print(DECODE_ID(hw),
+			0,
+			"prefix aux: (size %d)\n",
+			aux_size);
+		for (i = 0; i <
+		(aux_size >> 1); i++) {
+			dpb_print_cont(DECODE_ID(hw),
+				0,
+				"%04x ",
+				*(aux_adr + i));
+			if (((i + 1) & 0xf)
+				== 0)
+				dpb_print_cont(
+				DECODE_ID(hw),
+				0, "\n");
+		}
+	}
+	if (hw->suffix_aux_size > 0) {
+		aux_adr = (unsigned short *)
+			(hw->aux_addr +
+			hw->prefix_aux_size);
+		aux_size =
+		(READ_VREG(H264_AUX_DATA_SIZE) & 0xffff)
+			<< 4;
+		dpb_print(DECODE_ID(hw),
+			0,
+			"suffix aux: (size %d)\n",
+			aux_size);
+		for (i = 0; i <
+		(aux_size >> 1); i++) {
+			dpb_print_cont(DECODE_ID(hw),
+				0,
+				"%04x ", *(aux_adr + i));
+			if (((i + 1) & 0xf) == 0)
+				dpb_print_cont(DECODE_ID(hw),
+				0, "\n");
+		}
 	}
 }
 
-void config_decode_buf(struct vdec_h264_hw_s *hw, struct StorablePicture *pic)
+static void config_decode_mode(struct vdec_h264_hw_s *hw)
+{
+#ifdef CONFIG_AM_VDEC_DV
+	struct vdec_s *vdec = hw_to_vdec(hw);
+#endif
+	if (input_frame_based(hw_to_vdec(hw)))
+		WRITE_VREG(H264_DECODE_MODE,
+			DECODE_MODE_MULTI_FRAMEBASE);
+#ifdef CONFIG_AM_VDEC_DV
+	else if (vdec->slave)
+		WRITE_VREG(H264_DECODE_MODE,
+			(hw->got_valid_nal << 8) |
+			DECODE_MODE_MULTI_DVBAL);
+	else if (vdec->master)
+		WRITE_VREG(H264_DECODE_MODE,
+			(hw->got_valid_nal << 8) |
+			DECODE_MODE_MULTI_DVENL);
+#endif
+	else
+		WRITE_VREG(H264_DECODE_MODE,
+			DECODE_MODE_MULTI_STREAMBASE);
+	WRITE_VREG(H264_DECODE_SEQINFO,
+		hw->seq_info2);
+	WRITE_VREG(HEAD_PADING_REG, 0);
+
+	if (hw->init_flag == 0)
+		WRITE_VREG(INIT_FLAG_REG, 0);
+	else
+		WRITE_VREG(INIT_FLAG_REG, 1);
+}
+
+int config_decode_buf(struct vdec_h264_hw_s *hw, struct StorablePicture *pic)
 {
 	/* static int count = 0; */
+	int ret = 0;
 	struct h264_dpb_stru *p_H264_Dpb = &hw->dpb;
 	struct Slice *pSlice = &(p_H264_Dpb->mSlice);
 	unsigned int colocate_adr_offset;
 	unsigned int val;
-
+#ifdef ONE_COLOCATE_BUF_PER_DECODE_BUF
+	int colocate_buf_index;
+#endif
 #define H264_BUFFER_INFO_INDEX    PMV3_X /* 0xc24 */
 #define H264_BUFFER_INFO_DATA   PMV2_X  /* 0xc22 */
 #define H264_CURRENT_POC_IDX_RESET LAST_SLICE_MV_ADDR /* 0xc30 */
@@ -645,25 +1974,28 @@ void config_decode_buf(struct vdec_h264_hw_s *hw, struct StorablePicture *pic)
 	unsigned colocate_wr_adr;
 	unsigned colocate_rd_adr;
 	unsigned char use_direct_8x8;
-
+	int canvas_pos;
+	canvas_pos = hw->buffer_spec[pic->buf_spec_num].canvas_pos;
 	WRITE_VREG(H264_CURRENT_POC_IDX_RESET, 0);
 	WRITE_VREG(H264_CURRENT_POC, pic->frame_poc);
 	WRITE_VREG(H264_CURRENT_POC, pic->top_poc);
 	WRITE_VREG(H264_CURRENT_POC, pic->bottom_poc);
 
-	dpb_print(hw->dpb.decoder_index, PRINT_FLAG_UCODE_EVT,
-		"%s: pic_num is %d, poc is %d (%d, %d, %d), buf_spec_num %d\n",
+	dpb_print(DECODE_ID(hw), PRINT_FLAG_DEC_DETAIL,
+		"%s: pic_num is %d, poc is %d (%d, %d, %d), buf_spec_num %d canvas_pos %d\n",
 		__func__, pic->pic_num, pic->poc, pic->frame_poc,
-		pic->top_poc, pic->bottom_poc, pic->buf_spec_num);
-	print_pic_info(hw->dpb.decoder_index, "cur", pic, pSlice->slice_type);
-
-	WRITE_VREG(CURR_CANVAS_CTRL, pic->buf_spec_num << 24);
-
-	canvas_adr = READ_VREG(CURR_CANVAS_CTRL) & 0xffffff;
-
-	WRITE_VREG(REC_CANVAS_ADDR, canvas_adr);
-	WRITE_VREG(DBKR_CANVAS_ADDR, canvas_adr);
-	WRITE_VREG(DBKW_CANVAS_ADDR, canvas_adr);
+		pic->top_poc, pic->bottom_poc, pic->buf_spec_num,
+		canvas_pos);
+	print_pic_info(DECODE_ID(hw), "cur", pic, pSlice->slice_type);
+
+	WRITE_VREG(CURR_CANVAS_CTRL, canvas_pos << 24);
+	if (!mmu_enable) {
+		canvas_adr = READ_VREG(CURR_CANVAS_CTRL) & 0xffffff;
+		WRITE_VREG(REC_CANVAS_ADDR, canvas_adr);
+		WRITE_VREG(DBKR_CANVAS_ADDR, canvas_adr);
+		WRITE_VREG(DBKW_CANVAS_ADDR, canvas_adr);
+	} else
+		hevc_sao_set_pic_buffer(hw, pic);
 
 	if (pic->mb_aff_frame_flag)
 		hw->buffer_spec[pic->buf_spec_num].info0 = 0xf4c0;
@@ -681,8 +2013,12 @@ void config_decode_buf(struct vdec_h264_hw_s *hw, struct StorablePicture *pic)
 	hw->buffer_spec[pic->buf_spec_num].info2 = pic->bottom_poc;
 	WRITE_VREG(H264_BUFFER_INFO_INDEX, 16);
 
-	for (i = 0; i < hw->buffer_spec_num; i++) {
-		int long_term_flag =
+	for (j = 0; j < hw->dpb.mDPB.size; j++) {
+		int long_term_flag;
+		i = get_buf_spec_by_canvas_pos(hw, j);
+		if (i < 0)
+			break;
+		long_term_flag =
 			get_long_term_flag_by_buf_spec_num(p_H264_Dpb, i);
 		if (long_term_flag > 0) {
 			if (long_term_flag & 0x1)
@@ -707,7 +2043,12 @@ void config_decode_buf(struct vdec_h264_hw_s *hw, struct StorablePicture *pic)
 	}
 
 	/* config reference buffer */
-	dpb_print(hw->dpb.decoder_index, PRINT_FLAG_UCODE_EVT,
+	if (mmu_enable) {
+		hevc_mcr_config_mc_ref(hw);
+		hevc_mcr_config_mcrcc(hw);
+	}
+
+	dpb_print(DECODE_ID(hw), PRINT_FLAG_DEC_DETAIL,
 		"list0 size %d\n", pSlice->listXsize[0]);
 	WRITE_VREG(H264_BUFFER_INFO_INDEX, 0);
 	ref_reg_val = 0;
@@ -722,28 +2063,36 @@ void config_decode_buf(struct vdec_h264_hw_s *hw, struct StorablePicture *pic)
 		 * 01 - top, 10 - bottom, 11 - frame
 		 */
 #ifdef ERROR_CHECK
-		if (ref == NULL)
-			return;
+		if (ref == NULL) {
+			hw->data_flag |= ERROR_FLAG;
+			return -1;
+		}
+		if (ref->data_flag & ERROR_FLAG)
+			hw->data_flag |= ERROR_FLAG;
+		if (ref->data_flag & NULL_FLAG)
+			hw->data_flag |= NULL_FLAG;
 #endif
+		canvas_pos = hw->buffer_spec[ref->buf_spec_num].canvas_pos;
+
 		if (ref->structure == TOP_FIELD)
 			cfg = 0x1;
 		else if (ref->structure == BOTTOM_FIELD)
 			cfg = 0x2;
 		else /* FRAME */
 			cfg = 0x3;
-		one_ref_cfg = (ref->buf_spec_num & 0x1f) | (cfg << 5);
+		one_ref_cfg = (canvas_pos & 0x1f) | (cfg << 5);
 		ref_reg_val <<= 8;
 		ref_reg_val |= one_ref_cfg;
 		j++;
 
 		if (j == 4) {
-			dpb_print(hw->dpb.decoder_index, PRINT_FLAG_UCODE_EVT,
+			dpb_print(DECODE_ID(hw), PRINT_FLAG_DEC_DETAIL,
 				"H264_BUFFER_INFO_DATA: %x\n", ref_reg_val);
 			WRITE_VREG(H264_BUFFER_INFO_DATA, ref_reg_val);
 			h264_buffer_info_data_write_count++;
 			j = 0;
 		}
-		print_pic_info(hw->dpb.decoder_index, "list0",
+		print_pic_info(DECODE_ID(hw), "list0",
 			pSlice->listX[0][i], -1);
 	}
 	if (j != 0) {
@@ -752,7 +2101,7 @@ void config_decode_buf(struct vdec_h264_hw_s *hw, struct StorablePicture *pic)
 			ref_reg_val |= one_ref_cfg;
 			j++;
 		}
-		dpb_print(hw->dpb.decoder_index, PRINT_FLAG_UCODE_EVT,
+		dpb_print(DECODE_ID(hw), PRINT_FLAG_DEC_DETAIL,
 			"H264_BUFFER_INFO_DATA: %x\n",
 					ref_reg_val);
 		WRITE_VREG(H264_BUFFER_INFO_DATA, ref_reg_val);
@@ -763,7 +2112,7 @@ void config_decode_buf(struct vdec_h264_hw_s *hw, struct StorablePicture *pic)
 	for (i = h264_buffer_info_data_write_count; i < 8; i++)
 		WRITE_VREG(H264_BUFFER_INFO_DATA, ref_reg_val);
 
-	dpb_print(hw->dpb.decoder_index, PRINT_FLAG_UCODE_EVT,
+	dpb_print(DECODE_ID(hw), PRINT_FLAG_DEC_DETAIL,
 		"list1 size %d\n", pSlice->listXsize[1]);
 	WRITE_VREG(H264_BUFFER_INFO_INDEX, 8);
 	ref_reg_val = 0;
@@ -777,28 +2126,35 @@ void config_decode_buf(struct vdec_h264_hw_s *hw, struct StorablePicture *pic)
 		 * 01 - top, 10 - bottom, 11 - frame
 		 */
 #ifdef ERROR_CHECK
-		if (ref == NULL)
-			return;
+		if (ref == NULL) {
+			hw->data_flag |= ERROR_FLAG;
+			return -2;
+		}
+		if (ref->data_flag & ERROR_FLAG)
+			hw->data_flag |= ERROR_FLAG;
+		if (ref->data_flag & NULL_FLAG)
+			hw->data_flag |= NULL_FLAG;
 #endif
+		canvas_pos = hw->buffer_spec[ref->buf_spec_num].canvas_pos;
 		if (ref->structure == TOP_FIELD)
 			cfg = 0x1;
 		else if (ref->structure == BOTTOM_FIELD)
 			cfg = 0x2;
 		else /* FRAME */
 			cfg = 0x3;
-		one_ref_cfg = (ref->buf_spec_num & 0x1f) | (cfg << 5);
+		one_ref_cfg = (canvas_pos & 0x1f) | (cfg << 5);
 		ref_reg_val <<= 8;
 		ref_reg_val |= one_ref_cfg;
 		j++;
 
 		if (j == 4) {
-			dpb_print(hw->dpb.decoder_index, PRINT_FLAG_UCODE_EVT,
+			dpb_print(DECODE_ID(hw), PRINT_FLAG_DEC_DETAIL,
 				"H264_BUFFER_INFO_DATA: %x\n",
 				ref_reg_val);
 			WRITE_VREG(H264_BUFFER_INFO_DATA, ref_reg_val);
 			j = 0;
 		}
-		print_pic_info(hw->dpb.decoder_index, "list1",
+		print_pic_info(DECODE_ID(hw), "list1",
 			pSlice->listX[1][i], -1);
 	}
 	if (j != 0) {
@@ -807,7 +2163,7 @@ void config_decode_buf(struct vdec_h264_hw_s *hw, struct StorablePicture *pic)
 			ref_reg_val |= one_ref_cfg;
 			j++;
 		}
-		dpb_print(hw->dpb.decoder_index, PRINT_FLAG_UCODE_EVT,
+		dpb_print(DECODE_ID(hw), PRINT_FLAG_DEC_DETAIL,
 		"H264_BUFFER_INFO_DATA: %x\n", ref_reg_val);
 		WRITE_VREG(H264_BUFFER_INFO_DATA, ref_reg_val);
 	}
@@ -828,7 +2184,7 @@ void config_decode_buf(struct vdec_h264_hw_s *hw, struct StorablePicture *pic)
 	if (use_direct_8x8)
 		colocate_adr_offset >>= 2;
 
-	dpb_print(hw->dpb.decoder_index, PRINT_FLAG_UCODE_EVT,
+	dpb_print(DECODE_ID(hw), PRINT_FLAG_DEC_DETAIL,
 		"colocate buf size of each mb 0x%x first_mb_in_slice 0x%x colocate_adr_offset 0x%x\r\n",
 		colocate_adr_offset, pSlice->first_mb_in_slice,
 		colocate_adr_offset * pSlice->first_mb_in_slice);
@@ -842,29 +2198,32 @@ void config_decode_buf(struct vdec_h264_hw_s *hw, struct StorablePicture *pic)
 			pic->colocated_buf_index)
 			>> (use_direct_8x8 ? 2 : 0));
 		if ((colocate_wr_adr + p_H264_Dpb->colocated_buf_size) >
-			p_H264_Dpb->colocated_mv_addr_end)
-			dpb_print(hw->dpb.decoder_index, PRINT_FLAG_ERROR,
+			p_H264_Dpb->colocated_mv_addr_end) {
+			dpb_print(DECODE_ID(hw), PRINT_FLAG_ERROR,
 				"Error, colocate buf is not enough, index is %d\n",
 			pic->colocated_buf_index);
+			ret = -3;
+		}
 		val = colocate_wr_adr + colocate_adr_offset;
 		WRITE_VREG(H264_CO_MB_WR_ADDR, val);
-		dpb_print(hw->dpb.decoder_index, PRINT_FLAG_UCODE_EVT,
+		dpb_print(DECODE_ID(hw), PRINT_FLAG_DEC_DETAIL,
 			"WRITE_VREG(H264_CO_MB_WR_ADDR) = %x, first_mb_in_slice %x pic_structure %x  colocate_adr_offset %x mode_8x8_flags %x colocated_buf_size %x\n",
 			val, pSlice->first_mb_in_slice, pic->structure,
 			colocate_adr_offset, pSlice->mode_8x8_flags,
 			p_H264_Dpb->colocated_buf_size);
 	} else {
 		WRITE_VREG(H264_CO_MB_WR_ADDR, 0xffffffff);
-		dpb_print(hw->dpb.decoder_index, PRINT_FLAG_UCODE_EVT,
+		dpb_print(DECODE_ID(hw), PRINT_FLAG_DEC_DETAIL,
 			"WRITE_VREG(H264_CO_MB_WR_ADDR) = 0xffffffff\n");
 	}
 #else
+	colocate_buf_index = hw->buffer_spec[pic->buf_spec_num].canvas_pos;
 	colocate_adr_offset =
 	((pic->structure == FRAME && pic->mb_aff_frame_flag == 0) ? 1 : 2) * 96;
 	if (use_direct_8x8)
 		colocate_adr_offset >>= 2;
 
-	dpb_print(hw->dpb.decoder_index, PRINT_FLAG_UCODE_EVT,
+	dpb_print(DECODE_ID(hw), PRINT_FLAG_DEC_DETAIL,
 		"colocate buf size of each mb 0x%x first_mb_in_slice 0x%x colocate_adr_offset 0x%x\r\n",
 		colocate_adr_offset, pSlice->first_mb_in_slice,
 		colocate_adr_offset * pSlice->first_mb_in_slice);
@@ -872,17 +2231,19 @@ void config_decode_buf(struct vdec_h264_hw_s *hw, struct StorablePicture *pic)
 	colocate_adr_offset *= pSlice->first_mb_in_slice;
 
 	colocate_wr_adr = p_H264_Dpb->colocated_mv_addr_start +
-		((p_H264_Dpb->colocated_buf_size * pic->buf_spec_num) >>
+		((p_H264_Dpb->colocated_buf_size * colocate_buf_index) >>
 			(use_direct_8x8 ? 2 : 0));
 
 	if ((colocate_wr_adr + p_H264_Dpb->colocated_buf_size) >
-		p_H264_Dpb->colocated_mv_addr_end)
-		dpb_print(hw->dpb.decoder_index, PRINT_FLAG_ERROR,
-		"Error, colocate buf is not enough, pic index is %d\n",
-				pic->buf_spec_num);
+		p_H264_Dpb->colocated_mv_addr_end) {
+		dpb_print(DECODE_ID(hw), PRINT_FLAG_ERROR,
+		"Error, colocate buf is not enough, col buf index is %d\n",
+				colocate_buf_index);
+		ret = -4;
+	}
 	val = colocate_wr_adr + colocate_adr_offset;
 	WRITE_VREG(H264_CO_MB_WR_ADDR, val);
-	dpb_print(hw->dpb.decoder_index, PRINT_FLAG_UCODE_EVT,
+	dpb_print(DECODE_ID(hw), PRINT_FLAG_DEC_DETAIL,
 		"WRITE_VREG(H264_CO_MB_WR_ADDR) = %x, first_mb_in_slice %x pic_structure %x colocate_adr_offset %x mode_8x8_flags %x colocated_buf_size %x\n",
 		val, pSlice->first_mb_in_slice, pic->structure,
 		colocate_adr_offset, pSlice->mode_8x8_flags,
@@ -902,8 +2263,14 @@ void config_decode_buf(struct vdec_h264_hw_s *hw, struct StorablePicture *pic)
 		 */
 		unsigned int val;
 #ifdef ERROR_CHECK
-		if (colocate_pic == NULL)
-			return;
+		if (colocate_pic == NULL) {
+			hw->data_flag |= ERROR_FLAG;
+			return -5;
+		}
+		if (colocate_pic->data_flag & ERROR_FLAG)
+			hw->data_flag |= ERROR_FLAG;
+		if (colocate_pic->data_flag & NULL_FLAG)
+			hw->data_flag |= NULL_FLAG;
 #endif
 
 		if (colocate_pic->mb_aff_frame_flag)
@@ -926,12 +2293,12 @@ void config_decode_buf(struct vdec_h264_hw_s *hw, struct StorablePicture *pic)
 		else
 			cur_colocate_ref_type = 0;
 #else
-		dpb_print(hw->dpb.decoder_index, PRINT_FLAG_UCODE_EVT,
+		dpb_print(DECODE_ID(hw), PRINT_FLAG_DEC_DETAIL,
 			" CUR TMP DEBUG : mb_aff_frame_flag : %d, structure : %d coded_frame %d\n",
 			pic->mb_aff_frame_flag,
 			pic->structure,
 			pic->coded_frame);
-		dpb_print(hw->dpb.decoder_index, PRINT_FLAG_UCODE_EVT,
+		dpb_print(DECODE_ID(hw), PRINT_FLAG_DEC_DETAIL,
 			" COL TMP DEBUG : mb_aff_frame_flag : %d, structure : %d coded_frame %d\n",
 			colocate_pic->mb_aff_frame_flag,
 				colocate_pic->structure,
@@ -956,11 +2323,13 @@ void config_decode_buf(struct vdec_h264_hw_s *hw, struct StorablePicture *pic)
 				colocate_pic->colocated_buf_index)
 				>> (use_direct_8x8 ? 2 : 0));
 			if ((colocate_rd_adr + p_H264_Dpb->colocated_buf_size) >
-				p_H264_Dpb->colocated_mv_addr_end)
-				dpb_print(hw->dpb.decoder_index,
+				p_H264_Dpb->colocated_mv_addr_end) {
+				dpb_print(DECODE_ID(hw),
 					PRINT_FLAG_ERROR,
 				"Error, colocate buf is not enough, index is %d\n",
 					colocate_pic->colocated_buf_index);
+				ret = -6;
+			}
 			/* bit 31:30 -- L1[0] picture coding structure,
 			 * 00 - top field, 01 - bottom field,
 			 * 10 - frame, 11 - mbaff frame
@@ -975,25 +2344,31 @@ void config_decode_buf(struct vdec_h264_hw_s *hw, struct StorablePicture *pic)
 				(l10_structure << 30) |
 				(cur_colocate_ref_type << 29);
 			WRITE_VREG(H264_CO_MB_RD_ADDR, val);
-			dpb_print(hw->dpb.decoder_index, PRINT_FLAG_UCODE_EVT,
+			dpb_print(DECODE_ID(hw), PRINT_FLAG_DEC_DETAIL,
 				"co idx %d, WRITE_VREG(H264_CO_MB_RD_ADDR) = %x, addr %x L1(0) pic_structure %d mbaff %d\n",
 				colocate_pic->colocated_buf_index,
 				val, colocate_rd_adr + colocate_adr_offset,
 				colocate_pic->structure,
 				colocate_pic->mb_aff_frame_flag);
-		} else
-			dpb_print(hw->dpb.decoder_index, PRINT_FLAG_ERROR,
+		} else {
+			dpb_print(DECODE_ID(hw), PRINT_FLAG_ERROR,
 			"Error, reference pic has no colocated buf\n");
+			ret = -7;
+		}
 #else
+		colocate_buf_index =
+			hw->buffer_spec[colocate_pic->buf_spec_num].canvas_pos;
 		colocate_rd_adr = p_H264_Dpb->colocated_mv_addr_start +
 			((p_H264_Dpb->colocated_buf_size *
-				colocate_pic->buf_spec_num)
+				colocate_buf_index)
 				>> (use_direct_8x8 ? 2 : 0));
 		if ((colocate_rd_adr + p_H264_Dpb->colocated_buf_size) >
-			p_H264_Dpb->colocated_mv_addr_end)
-			dpb_print(hw->dpb.decoder_index, PRINT_FLAG_ERROR,
-				"Error, colocate buf is not enough, pic index is %d\n",
-				colocate_pic->buf_spec_num);
+			p_H264_Dpb->colocated_mv_addr_end) {
+			dpb_print(DECODE_ID(hw), PRINT_FLAG_ERROR,
+				"Error, colocate buf is not enough, col buf index is %d\n",
+				colocate_buf_index);
+			ret = -8;
+		}
 		/* bit 31:30 -- L1[0] picture coding structure,
 		 * 00 - top field, 01 - bottom field,
 		 * 10 - frame, 11 - mbaff frame
@@ -1007,12 +2382,13 @@ void config_decode_buf(struct vdec_h264_hw_s *hw, struct StorablePicture *pic)
 		val = ((colocate_rd_adr+colocate_adr_offset)>>3) |
 			(l10_structure << 30) | (cur_colocate_ref_type << 29);
 		WRITE_VREG(H264_CO_MB_RD_ADDR, val);
-		dpb_print(hw->dpb.decoder_index, PRINT_FLAG_UCODE_EVT,
+		dpb_print(DECODE_ID(hw), PRINT_FLAG_DEC_DETAIL,
 			"WRITE_VREG(H264_CO_MB_RD_ADDR) = %x, L1(0) pic_structure %d mbaff %d\n",
 			val, colocate_pic->structure,
 			colocate_pic->mb_aff_frame_flag);
 #endif
 	}
+	return ret;
 }
 
 static int vh264_vf_states(struct vframe_states *states, void *op_arg)
@@ -1041,6 +2417,12 @@ static struct vframe_s *vh264_vf_peek(void *op_arg)
 	if (!hw)
 		return NULL;
 
+	if (force_disp_bufspec_num & 0x100) {
+		if (force_disp_bufspec_num & 0x200)
+			return NULL;
+		return &hw->vframe_dummy;
+	}
+
 	if (kfifo_peek(&hw->display_q, &vf))
 		return vf;
 
@@ -1056,30 +2438,61 @@ static struct vframe_s *vh264_vf_get(void *op_arg)
 	if (!hw)
 		return NULL;
 
+	if (force_disp_bufspec_num & 0x100) {
+		int buffer_index = force_disp_bufspec_num & 0xff;
+		if (force_disp_bufspec_num & 0x200)
+			return NULL;
+
+		vf = &hw->vframe_dummy;
+		vf->duration_pulldown = 0;
+		vf->pts = 0;
+		vf->pts_us64 = 0;
+		set_frame_info(hw, vf, buffer_index);
+		vf->flag = 0;
+		if (mmu_enable) {
+			vf->type = VIDTYPE_COMPRESS | VIDTYPE_VIU_FIELD;
+			vf->type |= VIDTYPE_SCATTER;
+			vf->bitdepth =
+				BITDEPTH_Y8 | BITDEPTH_U8 | BITDEPTH_V8;
+			vf->compWidth = hw->frame_width;
+			vf->compHeight = hw->frame_height;
+			vf->compHeadAddr =
+				hw->buffer_spec[buffer_index].alloc_header_addr;
+			vf->compBodyAddr = 0;
+			vf->canvas0Addr = vf->canvas1Addr = 0;
+		} else {
+			vf->type = VIDTYPE_PROGRESSIVE | VIDTYPE_VIU_FIELD |
+				VIDTYPE_VIU_NV21;
+			vf->canvas0Addr = vf->canvas1Addr =
+			spec2canvas(&hw->buffer_spec[buffer_index]);
+		}
+
+		/*vf->mem_handle = decoder_bmmu_box_get_mem_handle(
+			hw->bmmu_box, buffer_index);*/
+		update_vf_memhandle(hw, vf, buffer_index);
+		force_disp_bufspec_num |= 0x200;
+		return vf;
+	}
+
 	if (kfifo_get(&hw->display_q, &vf)) {
 		int time = jiffies;
 		unsigned int frame_interval =
 			1000*(time - hw->last_frame_time)/HZ;
-		if ((h264_debug_flag & OUTPUT_CURRENT_BUF) == 0) {
-			struct h264_dpb_stru *p_H264_Dpb = &hw->dpb;
-			dpb_print(hw->dpb.decoder_index, PRINT_FLAG_UCODE_EVT,
-				"%s from fs[%d], poc %d buf_spec_num %d vf %p\n",
-				__func__, vf->index,
-				p_H264_Dpb->mFrameStore[vf->index].poc,
-				p_H264_Dpb->mFrameStore[vf->index]
-						.buf_spec_num, vf);
+		if (dpb_is_debug(DECODE_ID(hw),
+			PRINT_FLAG_VDEC_STATUS)) {
+			dpb_print(DECODE_ID(hw), PRINT_FLAG_VDEC_STATUS,
+			"%s buf_spec_num %d vf %p dur %d pts %d interval %dms\n",
+			__func__, BUFSPEC_INDEX(vf->index), vf,
+			vf->duration, vf->pts, frame_interval);
 		}
 		if (hw->last_frame_time > 0) {
-			dpb_print(hw->dpb.decoder_index,
-			PRINT_FLAG_TIME_STAMP,
-			"%s duration %d pts %d interval %dms\r\n",
-			__func__, vf->duration, vf->pts, frame_interval);
 			if (frame_interval >
-				max_get_frame_interval[hw->dpb.decoder_index])
-				max_get_frame_interval[hw->dpb.decoder_index]
+				max_get_frame_interval[DECODE_ID(hw)])
+				max_get_frame_interval[DECODE_ID(hw)]
 				= frame_interval;
 		}
 		hw->last_frame_time = time;
+		hw->vf_get_count++;
 		return vf;
 	}
 
@@ -1090,24 +2503,55 @@ static void vh264_vf_put(struct vframe_s *vf, void *op_arg)
 {
 	struct vdec_s *vdec = op_arg;
 	struct vdec_h264_hw_s *hw = (struct vdec_h264_hw_s *)vdec->private;
-	struct h264_dpb_stru *p_H264_Dpb = &hw->dpb;
 	int buf_spec_num;
+	int frame_index;
+	if (vf == (&hw->vframe_dummy))
+		return;
 
-	if ((h264_debug_flag & OUTPUT_CURRENT_BUF) == 0) {
-		buf_spec_num =
-			get_buf_spec_idx_by_canvas_config(hw,
-				&vf->canvas0_config[0]);
-		dpb_print(hw->dpb.decoder_index, PRINT_FLAG_UCODE_EVT,
-			"%s to fs[%d], poc %d buf_spec_num %d used %d\n",
-			__func__, vf->index,
-			p_H264_Dpb->mFrameStore[vf->index].poc,
-			buf_spec_num,
-			hw->buffer_spec[buf_spec_num].used);
-
-		if (hw->buffer_spec[buf_spec_num].used != 3)
-			set_frame_output_flag(&hw->dpb, vf->index);
+	frame_index = FRAME_INDEX(vf->index);
+	buf_spec_num = BUFSPEC_INDEX(vf->index);
+	if (frame_index < 0 ||
+		frame_index >= DPB_SIZE_MAX ||
+		buf_spec_num < 0 ||
+		buf_spec_num >= BUFSPEC_POOL_SIZE) {
+		dpb_print(DECODE_ID(hw), 0,
+			"%s vf index 0x%x error\r\n",
+			__func__, vf->index);
+		return;
+	}
+		/*get_buf_spec_idx_by_canvas_config(hw,
+			&vf->canvas0_config[0]);*/
+	if (hw->buffer_spec[buf_spec_num].used == 2) {
+		struct h264_dpb_stru *p_H264_Dpb = &hw->dpb;
+		dpb_print(DECODE_ID(hw), PRINT_FLAG_VDEC_STATUS,
+		"%s to fs[%d], poc %d buf_spec_num %d used %d vf_ref %d\n",
+		__func__, frame_index,
+		p_H264_Dpb->mFrameStore[frame_index].poc,
+		buf_spec_num,
+		hw->buffer_spec[buf_spec_num].used,
+		hw->buffer_spec[buf_spec_num].vf_ref);
+		hw->buffer_spec[buf_spec_num].vf_ref--;
+		if (hw->buffer_spec[buf_spec_num].vf_ref <= 0)
+			set_frame_output_flag(&hw->dpb, frame_index);
+	} else {
+		unsigned long flags;
+		dpb_print(DECODE_ID(hw), PRINT_FLAG_VDEC_STATUS,
+		"%s isolated vf, buf_spec_num %d used %d vf_ref %d\n",
+		__func__, buf_spec_num,
+		hw->buffer_spec[buf_spec_num].used,
+		hw->buffer_spec[buf_spec_num].vf_ref);
+		spin_lock_irqsave(&hw->bufspec_lock, flags);
+		hw->buffer_spec[buf_spec_num].vf_ref--;
+		if (hw->buffer_spec[buf_spec_num].vf_ref <= 0) {
+			if (hw->buffer_spec[buf_spec_num].used == 3)
+				hw->buffer_spec[buf_spec_num].used = 4;
+			else if (hw->buffer_spec[buf_spec_num].used == 5)
+				hw->buffer_spec[buf_spec_num].used = 0;
+		}
+		spin_unlock_irqrestore(&hw->bufspec_lock, flags);
 	}
 
+	hw->vf_put_count++;
 	kfifo_put(&hw->newframe_q, (const struct vframe_s *)vf);
 
 #define ASSIST_MBOX1_IRQ_REG    VDEC_ASSIST_MBOX1_IRQ_REG
@@ -1115,8 +2559,41 @@ static void vh264_vf_put(struct vframe_s *vf, void *op_arg)
 		WRITE_VREG(ASSIST_MBOX1_IRQ_REG, 0x1);
 }
 
-static int vh264_event_cb(int type, void *data,	void *private_data)
+static int vh264_event_cb(int type, void *data, void *op_arg)
 {
+	unsigned long flags;
+	struct vdec_s *vdec = op_arg;
+	struct vdec_h264_hw_s *hw = (struct vdec_h264_hw_s *)vdec->private;
+
+	if (type & VFRAME_EVENT_RECEIVER_GET_AUX_DATA) {
+		struct provider_aux_req_s *req =
+			(struct provider_aux_req_s *)data;
+		int buf_spec_num = BUFSPEC_INDEX(req->vf->index);
+		spin_lock_irqsave(&hw->lock, flags);
+		req->aux_buf = NULL;
+		req->aux_size = 0;
+		if (buf_spec_num >= 0 &&
+			buf_spec_num < BUFSPEC_POOL_SIZE &&
+			is_buf_spec_in_disp_q(hw, buf_spec_num)
+			) {
+			req->aux_buf =
+				hw->buffer_spec[buf_spec_num].aux_data_buf;
+			req->aux_size =
+				hw->buffer_spec[buf_spec_num].aux_data_size;
+#ifdef CONFIG_AM_VDEC_DV
+			req->dv_enhance_exist =
+				hw->buffer_spec[buf_spec_num].dv_enhance_exist;
+#else
+			req->dv_enhance_exist = 0;
+#endif
+		}
+		spin_unlock_irqrestore(&hw->lock, flags);
+
+		dpb_print(DECODE_ID(hw), PRINT_FLAG_VDEC_STATUS,
+		"%s(type 0x%x vf buf_spec_num 0x%x)=>size 0x%x\n",
+		__func__, type, buf_spec_num, req->aux_size);
+	}
+
 	return 0;
 }
 
@@ -1125,7 +2602,7 @@ static void set_frame_info(struct vdec_h264_hw_s *hw, struct vframe_s *vf,
 {
 	int force_rate = input_frame_based(hw_to_vdec(hw)) ?
 		force_rate_framebase : force_rate_streambase;
-	dpb_print(hw->dpb.decoder_index, PRINT_FLAG_UCODE_EVT,
+	dpb_print(DECODE_ID(hw), PRINT_FLAG_DPB_DETAIL,
 		"%s (%d,%d) dur %d, vf %p, index %d\n", __func__,
 		hw->frame_width, hw->frame_height, hw->frame_dur, vf, index);
 
@@ -1142,8 +2619,8 @@ static void set_frame_info(struct vdec_h264_hw_s *hw, struct vframe_s *vf,
 		(min(hw->h264_ar, (u32) DISP_RATIO_ASPECT_RATIO_MAX)) <<
 		DISP_RATIO_ASPECT_RATIO_BIT;
 	vf->orientation = hw->vh264_rotation;
-	vf->flag = 0;
-
+	if (mmu_enable)
+		return;
 	vf->canvas0Addr = vf->canvas1Addr = -1;
 #ifdef NV21
 	vf->plane_num = 2;
@@ -1236,217 +2713,272 @@ static int get_max_dec_frame_buf_size(int level_idc,
 
 static int vh264_set_params(struct vdec_h264_hw_s *hw)
 {
+	int i, j;
 	int mb_width, mb_total;
 	int max_reference_size, level_idc;
-	int i, mb_height, addr;
-	int mb_mv_byte;
+	int mb_height;
+	unsigned long flags;
+	/*int mb_mv_byte;*/
 	struct vdec_s *vdec = hw_to_vdec(hw);
-	int reg_val;
+	u32 seq_info2;
 	int ret = 0;
-#ifdef USE_CMA
+	int active_buffer_spec_num;
 	unsigned int buf_size;
+	unsigned int frame_mbs_only_flag;
+	unsigned int chroma_format_idc, chroma444;
+	unsigned int crop_infor, crop_bottom, crop_right;
+	unsigned int used_reorder_dpb_size_margin
+		= reorder_dpb_size_margin;
+#ifdef CONFIG_AM_VDEC_DV
+	if (vdec->master || vdec->slave)
+		used_reorder_dpb_size_margin =
+			reorder_dpb_size_margin_dv;
 #endif
-
-	if (hw->set_params_done) {
-		WRITE_VREG(AV_SCRATCH_0,
-			(hw->max_reference_size << 24) |
-			(hw->buffer_spec_num << 16) |
-			(hw->buffer_spec_num << 8));
-		return 0;
-	}
-	dpb_print(hw->dpb.decoder_index, PRINT_FLAG_UCODE_EVT, "%s\n",
-		__func__);
-
-#ifndef USE_CMA
-	addr = hw->buf_start;
-#endif
-
-	/* Read AV_SCRATCH_1 */
-	reg_val = READ_VREG(AV_SCRATCH_1);
+	seq_info2 = READ_VREG(AV_SCRATCH_1);
 	hw->seq_info = READ_VREG(AV_SCRATCH_2);
-	hw->num_units_in_tick = READ_VREG(AV_SCRATCH_4);
-	hw->time_scale = READ_VREG(AV_SCRATCH_5);
-	dpb_print(hw->dpb.decoder_index, PRINT_FLAG_UCODE_EVT, "get %x\n",
-		reg_val);
-	mb_mv_byte = (reg_val & 0x80000000) ? 24 : 96;
-
-	mb_width = reg_val & 0xff;
-	mb_total = (reg_val >> 8) & 0xffff;
+
+	mb_width = seq_info2 & 0xff;
+	mb_total = (seq_info2 >> 8) & 0xffff;
 	if (!mb_width && mb_total) /*for 4k2k*/
 		mb_width = 256;
-
 	mb_height = mb_total/mb_width;
-#if 1
-	/* if (hw->frame_width == 0 || hw->frame_height == 0) { */
-	hw->frame_width = mb_width * 16;
-	hw->frame_height = mb_height * 16;
-	/* } */
-
-	if (hw->frame_dur == 0)
-		hw->frame_dur = 96000 / 30;
-#endif
-
-	mb_width = (mb_width+3) & 0xfffffffc;
-	mb_height = (mb_height+3) & 0xfffffffc;
-	mb_total = mb_width * mb_height;
-
-	reg_val = READ_VREG(AV_SCRATCH_B);
-	level_idc = reg_val & 0xff;
-	max_reference_size = (reg_val >> 8) & 0xff;
-	dpb_print(hw->dpb.decoder_index, PRINT_FLAG_UCODE_EVT,
-		"mb height/widht/total: %x/%x/%x level_idc %x max_ref_num %x\n",
-		mb_height, mb_width, mb_total, level_idc, max_reference_size);
-
+	if (mb_width > 0x110 ||
+		mb_height > 0xa0) {
+		dpb_print(DECODE_ID(hw), 0,
+			"!!!wrong seq_info2 0x%x mb_width/mb_height (0x%x/0x%x) %x\r\n",
+			seq_info2,
+			mb_width,
+			mb_height);
+		WRITE_VREG(AV_SCRATCH_0, (hw->max_reference_size<<24) |
+			(hw->dpb.mDPB.size<<16) |
+			(hw->dpb.mDPB.size<<8));
+		return 0;
+	}
 
-	hw->mb_total = mb_total;
-	hw->mb_width = mb_width;
-	hw->mb_height = mb_height;
+	if (seq_info2 != 0 &&
+		hw->seq_info2 != (seq_info2 & (~0x80000000)) &&
+		hw->seq_info2 != 0
+		) /*picture size changed*/
+		h264_reconfig(hw);
 
-	hw->dpb.reorder_pic_num =
-		get_max_dec_frame_buf_size(level_idc,
-		max_reference_size, mb_width, mb_height);
-	hw->buffer_spec_num =
-		hw->dpb.reorder_pic_num
-		+ reorder_dpb_size_margin;
-	hw->max_reference_size = max_reference_size + reference_buf_margin;
+	if (hw->config_bufmgr_done == 0) {
+		struct h264_dpb_stru *p_H264_Dpb = &hw->dpb;
+		u32 reg_val;
+		hw->seq_info2 = seq_info2 & (~0x80000000);
+		dpb_print(DECODE_ID(hw), 0,
+			"AV_SCRATCH_1 = %x, AV_SCRATCH_2 %x\r\n",
+			seq_info2, hw->seq_info);
 
-	if (hw->buffer_spec_num > MAX_VF_BUF_NUM) {
-		hw->buffer_spec_num = MAX_VF_BUF_NUM;
-		hw->dpb.reorder_pic_num = hw->buffer_spec_num
-			- reorder_dpb_size_margin;
-	}
-	hw->dpb.mDPB.size = hw->buffer_spec_num;
-	hw->dpb.max_reference_size = hw->max_reference_size;
+		dpb_init_global(&hw->dpb,
+			DECODE_ID(hw), 0, 0);
 
-	pr_info("%s buf_spec_num %d reorder_pic_num %d collocate_buf_num %d\r\n",
-		__func__, hw->buffer_spec_num,
-		hw->dpb.reorder_pic_num,
-		hw->max_reference_size);
+		p_H264_Dpb->fast_output_enable = fast_output_enable;
+		/*mb_mv_byte = (seq_info2 & 0x80000000) ? 24 : 96;*/
 
-#ifdef USE_CMA
-	buf_size = (hw->mb_total << 8) + (hw->mb_total << 7);
-#endif
-	for (i = 0; i < hw->buffer_spec_num; i++) {
-		int canvas = vdec->get_canvas(i, 2);
-
-#ifdef USE_CMA
-		if (hw->buffer_spec[i].cma_alloc_count == 0) {
-			hw->buffer_spec[i].cma_alloc_count =
-				PAGE_ALIGN(buf_size) / PAGE_SIZE;
-			hw->buffer_spec[i].cma_alloc_addr =
-				codec_mm_alloc_for_dma(MEM_NAME,
-					hw->buffer_spec[i].cma_alloc_count,
-					16, CODEC_MM_FLAGS_FOR_VDECODER);
-		}
-
-		if (!hw->buffer_spec[i].cma_alloc_addr) {
-			dpb_print(hw->dpb.decoder_index, PRINT_FLAG_ERROR,
-			"CMA alloc failed, request buf size 0x%lx\n",
-				hw->buffer_spec[i].cma_alloc_count * PAGE_SIZE);
-			hw->buffer_spec[i].cma_alloc_count = 0;
-			ret = -1;
-			break;
+#if 1
+		/*crop*/
+		/* AV_SCRATCH_2
+		   bit 15: frame_mbs_only_flag
+		   bit 13-14: chroma_format_idc */
+		frame_mbs_only_flag = (hw->seq_info >> 15) & 0x01;
+		chroma_format_idc = (hw->seq_info >> 13) & 0x03;
+		chroma444 = (chroma_format_idc == 3) ? 1 : 0;
+
+		/* @AV_SCRATCH_6.31-16 =  (left  << 8 | right ) << 1
+		   @AV_SCRATCH_6.15-0   =  (top << 8  | bottom ) <<
+		   (2 - frame_mbs_only_flag) */
+		crop_infor = READ_VREG(AV_SCRATCH_6);
+		crop_bottom = (crop_infor & 0xff) >> (2 - frame_mbs_only_flag);
+		crop_right = ((crop_infor >> 16) & 0xff)
+			>> (2 - frame_mbs_only_flag);
+
+		hw->frame_width = mb_width << 4;
+		hw->frame_height = mb_height << 4;
+		if (frame_mbs_only_flag) {
+			hw->frame_height =
+				hw->frame_height - (2 >> chroma444) *
+				min(crop_bottom,
+					(unsigned int)((8 << chroma444) - 1));
+			hw->frame_width =
+				hw->frame_width -
+					(2 >> chroma444) * min(crop_right,
+						(unsigned
+						 int)((8 << chroma444) - 1));
+		} else {
+			hw->frame_height =
+				hw->frame_height - (4 >> chroma444) *
+				min(crop_bottom,
+					(unsigned int)((8 << chroma444)
+							  - 1));
+			hw->frame_width =
+				hw->frame_width -
+				(4 >> chroma444) * min(crop_right,
+				(unsigned int)((8 << chroma444) - 1));
 		}
-		hw->buffer_spec[i].buf_adr =
-		hw->buffer_spec[i].cma_alloc_addr;
-		addr = hw->buffer_spec[i].buf_adr;
-#else
-		hw->buffer_spec[i].buf_adr = addr;
+		dpb_print(DECODE_ID(hw), 0,
+			"frame_mbs_only_flag %d, crop_bottom %d,  frame_height %d, ",
+			frame_mbs_only_flag, crop_bottom, hw->frame_height);
+		dpb_print(DECODE_ID(hw), 0,
+			"mb_height %d,crop_right %d, frame_width %d, mb_width %d\n",
+			mb_height, crop_right,
+			hw->frame_width, mb_width);
+
+		if (hw->frame_height == 1088)
+			hw->frame_height = 1080;
 #endif
 
-		hw->buffer_spec[i].used = 0;
-		hw->buffer_spec[i].y_addr = addr;
-		addr += hw->mb_total << 8;
-
-		hw->buffer_spec[i].u_addr = addr;
-		hw->buffer_spec[i].v_addr = addr;
-		addr += hw->mb_total << 7;
-
-		hw->buffer_spec[i].y_canvas_index = canvas_y(canvas);
-		hw->buffer_spec[i].u_canvas_index = canvas_u(canvas);
-		hw->buffer_spec[i].v_canvas_index = canvas_v(canvas);
-
-		canvas_config(hw->buffer_spec[i].y_canvas_index,
-			hw->buffer_spec[i].y_addr,
-			hw->mb_width << 4,
-			hw->mb_height << 4,
-			CANVAS_ADDR_NOWRAP,
-			CANVAS_BLKMODE_32X32);
-
-		hw->buffer_spec[i].canvas_config[0].phy_addr =
-				hw->buffer_spec[i].y_addr;
-		hw->buffer_spec[i].canvas_config[0].width =
-				hw->mb_width << 4;
-		hw->buffer_spec[i].canvas_config[0].height =
-				hw->mb_height << 4;
-		hw->buffer_spec[i].canvas_config[0].block_mode =
-				CANVAS_BLKMODE_32X32;
-
-		canvas_config(hw->buffer_spec[i].u_canvas_index,
-			hw->buffer_spec[i].u_addr,
-			hw->mb_width << 4,
-			hw->mb_height << 3,
-			CANVAS_ADDR_NOWRAP,
-			CANVAS_BLKMODE_32X32);
-
-		hw->buffer_spec[i].canvas_config[1].phy_addr =
-				hw->buffer_spec[i].u_addr;
-		hw->buffer_spec[i].canvas_config[1].width =
-				hw->mb_width << 4;
-		hw->buffer_spec[i].canvas_config[1].height =
-				hw->mb_height << 3;
-		hw->buffer_spec[i].canvas_config[1].block_mode =
-				CANVAS_BLKMODE_32X32;
-
-		WRITE_VREG(ANC0_CANVAS_ADDR + i,
-				spec2canvas(&hw->buffer_spec[i]));
-
-		pr_info("config canvas (%d)\r\n", i);
-	}
+		mb_width = (mb_width+3) & 0xfffffffc;
+		mb_height = (mb_height+3) & 0xfffffffc;
+		mb_total = mb_width * mb_height;
+		if (mmu_enable)
+			hevc_mcr_sao_global_hw_init(hw,
+				hw->frame_width, hw->frame_height);
+
+		reg_val = READ_VREG(AV_SCRATCH_B);
+		level_idc = reg_val & 0xff;
+		max_reference_size = (reg_val >> 8) & 0xff;
+		dpb_print(DECODE_ID(hw), 0,
+			"mb height/widht/total: %x/%x/%x level_idc %x max_ref_num %x\n",
+			mb_height, mb_width, mb_total,
+			level_idc, max_reference_size);
+
+		p_H264_Dpb->colocated_buf_size = mb_total * 96;
+		hw->mb_total = mb_total;
+		hw->mb_width = mb_width;
+		hw->mb_height = mb_height;
+
+		hw->dpb.reorder_pic_num =
+			get_max_dec_frame_buf_size(level_idc,
+			max_reference_size, mb_width, mb_height);
+		active_buffer_spec_num =
+			hw->dpb.reorder_pic_num
+			+ used_reorder_dpb_size_margin;
+		hw->max_reference_size =
+			max_reference_size + reference_buf_margin;
+
+		if (active_buffer_spec_num > MAX_VF_BUF_NUM) {
+			active_buffer_spec_num = MAX_VF_BUF_NUM;
+			hw->dpb.reorder_pic_num = active_buffer_spec_num
+				- used_reorder_dpb_size_margin;
+		}
+		hw->dpb.mDPB.size = active_buffer_spec_num;
+		if (hw->max_reference_size > MAX_VF_BUF_NUM)
+			hw->max_reference_size = MAX_VF_BUF_NUM;
+		hw->dpb.max_reference_size = hw->max_reference_size;
+
+		if (hw->no_poc_reorder_flag)
+			hw->dpb.reorder_pic_num = 1;
+		dpb_print(DECODE_ID(hw), 0,
+			"%s active_buf_spec_num %d reorder_pic_num %d collocate_buf_num %d\r\n",
+			__func__, active_buffer_spec_num,
+			hw->dpb.reorder_pic_num,
+			hw->max_reference_size);
+
+		buf_size = (hw->mb_total << 8) + (hw->mb_total << 7);
+
+		mutex_lock(&vmh264_mutex);
+		if (!mmu_enable) {
+			config_buf_specs(vdec);
+			i = get_buf_spec_by_canvas_pos(hw, 0);
+			if (alloc_one_buf_spec(hw, i) >= 0)
+				config_decode_canvas(hw, i);
+			else
+				ret = -1;
+		} else {
+			spin_lock_irqsave(&hw->bufspec_lock, flags);
+			for (i = 0, j = 0;
+				j < active_buffer_spec_num
+				&& i < BUFSPEC_POOL_SIZE;
+				i++) {
+				if (hw->buffer_spec[i].used != -1)
+					continue;
+				hw->buffer_spec[i].used = 0;
+				hw->buffer_spec[i].alloc_header_addr = 0;
+				hw->buffer_spec[i].canvas_pos = j;
+				j++;
+			}
+			spin_unlock_irqrestore(&hw->bufspec_lock, flags);
+			hevc_mcr_config_canv2axitbl(hw);
+		}
+		mutex_unlock(&vmh264_mutex);
 
+#ifdef ONE_COLOCATE_BUF_PER_DECODE_BUF
+		buf_size = PAGE_ALIGN(
+			p_H264_Dpb->colocated_buf_size *
+					active_buffer_spec_num);
+#else
+		buf_size = PAGE_ALIGN(
+			p_H264_Dpb->colocated_buf_size *
+					hw->max_reference_size);
+#endif
 
-#ifdef USE_CMA
-	if (hw->collocate_cma_alloc_count == 0) {
-		hw->collocate_cma_alloc_count =
-			PAGE_ALIGN(hw->mb_total * mb_mv_byte *
-				hw->max_reference_size) / PAGE_SIZE;
-		hw->collocate_cma_alloc_addr =
-			codec_mm_alloc_for_dma(MEM_NAME,
-				hw->collocate_cma_alloc_count,
-				16, CODEC_MM_FLAGS_FOR_VDECODER);
-	}
+		if (decoder_bmmu_box_alloc_buf_phy(hw->bmmu_box, BMMU_REF_IDX,
+			buf_size, DRIVER_NAME,
+			&hw->collocate_cma_alloc_addr) < 0)
+			return -1;
 
-	if (!hw->collocate_cma_alloc_addr) {
-		dpb_print(hw->dpb.decoder_index, PRINT_FLAG_ERROR,
-		"codec_mm alloc failed, request buf size 0x%lx\n",
-			hw->collocate_cma_alloc_count * PAGE_SIZE);
-		hw->collocate_cma_alloc_count = 0;
-		ret = -1;
-	} else {
 		hw->dpb.colocated_mv_addr_start =
 			hw->collocate_cma_alloc_addr;
+#ifdef ONE_COLOCATE_BUF_PER_DECODE_BUF
+		hw->dpb.colocated_mv_addr_end  =
+			hw->dpb.colocated_mv_addr_start +
+			(p_H264_Dpb->colocated_buf_size *
+			active_buffer_spec_num);
+#else
 		hw->dpb.colocated_mv_addr_end  =
 			hw->dpb.colocated_mv_addr_start +
-			(hw->mb_total * mb_mv_byte * hw->max_reference_size);
-		pr_info("callocate cma %d, %lx, %x\n",
-			hw->collocate_cma_alloc_count,
+			(p_H264_Dpb->colocated_buf_size *
+			hw->max_reference_size);
+#endif
+		dpb_print(DECODE_ID(hw), PRINT_FLAG_DEC_DETAIL,
+			"callocate cma, %lx, %x\n",
 			hw->collocate_cma_alloc_addr,
 			hw->dpb.colocated_mv_addr_start);
+
+		dpb_print(DECODE_ID(hw), PRINT_FLAG_DEC_DETAIL,
+			"colocated_mv_addr_start %x colocated_mv_addr_end %x\n",
+			hw->dpb.colocated_mv_addr_start,
+			hw->dpb.colocated_mv_addr_end);
+		if (!mmu_enable) {
+			mutex_lock(&vmh264_mutex);
+			if (ret >= 0 && hw->decode_pic_count == 0) {
+				/* h264_reconfig: alloc later*/
+				for (j = 1; j < hw->dpb.mDPB.size; j++) {
+					i = get_buf_spec_by_canvas_pos(hw, j);
+					if (alloc_one_buf_spec(hw, i) < 0)
+						break;
+					config_decode_canvas(hw, i);
+				}
+			}
+			mutex_unlock(&vmh264_mutex);
+		}
+
+		hw->config_bufmgr_done = 1;
+
+	/*end of  config_bufmgr_done */
 	}
-#else
-	hw->dpb.colocated_mv_addr_start  = addr;
-	hw->dpb.colocated_mv_addr_end  = addr + (hw->mb_total * mb_mv_byte
-			* hw->max_reference_size);
-#endif
-	dpb_print(hw->dpb.decoder_index, PRINT_FLAG_UCODE_EVT,
-		"colocated_mv_addr_start %x colocated_mv_addr_end %x\n",
-		hw->dpb.colocated_mv_addr_start,
-		hw->dpb.colocated_mv_addr_end);
 
-	hw->timing_info_present_flag = hw->seq_info & 0x2;
+
+	WRITE_VREG(AV_SCRATCH_0, (hw->max_reference_size<<24) |
+		(hw->dpb.mDPB.size<<16) |
+		(hw->dpb.mDPB.size<<8));
+
+	return ret;
+}
+
+static void vui_config(struct vdec_h264_hw_s *hw)
+{
+	struct h264_dpb_stru *p_H264_Dpb = &hw->dpb;
+	int aspect_ratio_info_present_flag, aspect_ratio_idc;
+	/*time*/
+	hw->num_units_in_tick = p_H264_Dpb->num_units_in_tick;
+	hw->time_scale = p_H264_Dpb->time_scale;
+	hw->timing_info_present_flag = p_H264_Dpb->vui_status & 0x2;
+
 	hw->fixed_frame_rate_flag = 0;
 	if (hw->timing_info_present_flag) {
-		hw->fixed_frame_rate_flag = hw->seq_info & 0x40;
+		hw->fixed_frame_rate_flag =
+			p_H264_Dpb->fixed_frame_rate_flag;
 
 		if (((hw->num_units_in_tick * 120) >= hw->time_scale &&
 			((!hw->sync_outside) ||
@@ -1470,7 +3002,10 @@ static int vh264_set_params(struct vdec_h264_hw_s *hw)
 						FIX_FRAME_RATE_OFF;
 					hw->pts_duration = 0;
 					hw->frame_dur = frame_dur_es;
-					pr_info("frame_dur %d from timing_info\n",
+					schedule_work(&hw->notify_work);
+					dpb_print(DECODE_ID(hw),
+						PRINT_FLAG_DEC_DETAIL,
+						"frame_dur %d from timing_info\n",
 						hw->frame_dur);
 				}
 
@@ -1485,31 +3020,148 @@ static int vh264_set_params(struct vdec_h264_hw_s *hw)
 			}
 		}
 	} else {
-		dpb_print(hw->dpb.decoder_index, PRINT_FLAG_UCODE_EVT,
+		dpb_print(DECODE_ID(hw), PRINT_FLAG_DEC_DETAIL,
 			"H.264: timing_info not present\n");
 	}
 
-	if (hw->pts_unstable && (hw->fixed_frame_rate_flag == 0)) {
-		if (((RATE_2397_FPS == hw->frame_dur)
-		&& (dec_control
-		& DEC_CONTROL_FLAG_FORCE_RATE_2397_FPS_FIX_FRAME_RATE))
-			|| ((RATE_2997_FPS ==
-			hw->frame_dur) &&
-		(dec_control &
-			DEC_CONTROL_FLAG_FORCE_RATE_2997_FPS_FIX_FRAME_RATE))) {
-			dpb_print(hw->dpb.decoder_index, PRINT_FLAG_UCODE_EVT,
-				"force fix frame rate\n");
-			hw->fixed_frame_rate_flag = 0x40;
-		}
-	}
-
-	hw->set_params_done = 1;
+	/*aspect ratio*/
+	aspect_ratio_info_present_flag =
+		p_H264_Dpb->vui_status & 0x1;
+	aspect_ratio_idc = p_H264_Dpb->aspect_ratio_idc;
+
+	if (aspect_ratio_info_present_flag) {
+		if (aspect_ratio_idc == EXTEND_SAR) {
+			hw->h264_ar =
+				div_u64(256ULL *
+					p_H264_Dpb->aspect_ratio_sar_height *
+					hw->frame_height,
+					p_H264_Dpb->aspect_ratio_sar_width *
+					hw->frame_width);
+		} else {
+			/* pr_info("v264dec: aspect_ratio_idc = %d\n",
+			   aspect_ratio_idc); */
 
-	WRITE_VREG(AV_SCRATCH_0, (hw->max_reference_size<<24) |
-		(hw->buffer_spec_num<<16) |
-		(hw->buffer_spec_num<<8));
+			switch (aspect_ratio_idc) {
+			case 1:
+				hw->h264_ar = 0x100 * hw->frame_height /
+					hw->frame_width;
+				break;
+			case 2:
+				hw->h264_ar = 0x100 * hw->frame_height * 11 /
+					(hw->frame_width * 12);
+				break;
+			case 3:
+				hw->h264_ar = 0x100 * hw->frame_height * 11 /
+					(hw->frame_width * 10);
+				break;
+			case 4:
+				hw->h264_ar = 0x100 * hw->frame_height * 11 /
+					(hw->frame_width * 16);
+				break;
+			case 5:
+				hw->h264_ar = 0x100 * hw->frame_height * 33 /
+					(hw->frame_width * 40);
+				break;
+			case 6:
+				hw->h264_ar = 0x100 * hw->frame_height * 11 /
+					(hw->frame_width * 24);
+				break;
+			case 7:
+				hw->h264_ar = 0x100 * hw->frame_height * 11 /
+					(hw->frame_width * 20);
+				break;
+			case 8:
+				hw->h264_ar = 0x100 * hw->frame_height * 11 /
+					(hw->frame_width * 32);
+				break;
+			case 9:
+				hw->h264_ar = 0x100 * hw->frame_height * 33 /
+					(hw->frame_width * 80);
+				break;
+			case 10:
+				hw->h264_ar = 0x100 * hw->frame_height * 11 /
+					(hw->frame_width * 18);
+				break;
+			case 11:
+				hw->h264_ar = 0x100 * hw->frame_height * 11 /
+					(hw->frame_width * 15);
+				break;
+			case 12:
+				hw->h264_ar = 0x100 * hw->frame_height * 33 /
+					(hw->frame_width * 64);
+				break;
+			case 13:
+				hw->h264_ar = 0x100 * hw->frame_height * 99 /
+					(hw->frame_width * 160);
+				break;
+			case 14:
+				hw->h264_ar = 0x100 * hw->frame_height * 3 /
+					(hw->frame_width * 4);
+				break;
+			case 15:
+				hw->h264_ar = 0x100 * hw->frame_height * 2 /
+					(hw->frame_width * 3);
+				break;
+			case 16:
+				hw->h264_ar = 0x100 * hw->frame_height * 1 /
+					(hw->frame_width * 2);
+				break;
+			default:
+				if (hw->vh264_ratio >> 16) {
+					hw->h264_ar = (hw->frame_height *
+						(hw->vh264_ratio & 0xffff) *
+						0x100 +
+						((hw->vh264_ratio >> 16) *
+						 hw->frame_width / 2)) /
+						((hw->vh264_ratio >> 16) *
+						 hw->frame_width);
+				} else {
+					hw->h264_ar = hw->frame_height * 0x100 /
+						hw->frame_width;
+				}
+				break;
+			}
+		}
+	} else {
+		dpb_print(DECODE_ID(hw), PRINT_FLAG_DEC_DETAIL,
+			"v264dec: aspect_ratio not available from source\n");
+		if (hw->vh264_ratio >> 16) {
+			/* high 16 bit is width, low 16 bit is height */
+			hw->h264_ar =
+				((hw->vh264_ratio & 0xffff) *
+					hw->frame_height * 0x100 +
+				 (hw->vh264_ratio >> 16) *
+				 hw->frame_width / 2) /
+				((hw->vh264_ratio >> 16) *
+					hw->frame_width);
+		} else
+			hw->h264_ar = hw->frame_height * 0x100 /
+				hw->frame_width;
+	}
 
-	return ret;
+	if (hw->pts_unstable && (hw->fixed_frame_rate_flag == 0)) {
+		if (((RATE_2397_FPS == hw->frame_dur)
+		&& (dec_control
+		& DEC_CONTROL_FLAG_FORCE_RATE_2397_FPS_FIX_FRAME_RATE))
+			|| ((RATE_2997_FPS ==
+			hw->frame_dur) &&
+		(dec_control &
+			DEC_CONTROL_FLAG_FORCE_RATE_2997_FPS_FIX_FRAME_RATE))) {
+			dpb_print(DECODE_ID(hw), PRINT_FLAG_DEC_DETAIL,
+				"force fix frame rate\n");
+			hw->fixed_frame_rate_flag = 0x40;
+		}
+	}
+
+	/*video_signal_from_vui: to do .. */
+}
+
+static void bufmgr_recover(struct vdec_h264_hw_s *hw)
+{
+	struct h264_dpb_stru *p_H264_Dpb = &hw->dpb;
+	bufmgr_h264_remove_unused_frame(p_H264_Dpb, 2);
+	if (error_proc_policy & 0x20)
+		hw->reset_bufmgr_flag = 1;
 }
 
 static bool is_buffer_available(struct vdec_s *vdec)
@@ -1517,13 +3169,13 @@ static bool is_buffer_available(struct vdec_s *vdec)
 	bool buffer_available = 1;
 	struct vdec_h264_hw_s *hw = (struct vdec_h264_hw_s *)(vdec->private);
 	struct h264_dpb_stru *p_H264_Dpb = &hw->dpb;
-
+	struct DecodedPictureBuffer *p_Dpb = &p_H264_Dpb->mDPB;
 	if ((kfifo_len(&hw->newframe_q) <= 0) ||
-	    ((hw->set_params_done) && (!have_free_buf_spec(vdec))) ||
+	    ((hw->config_bufmgr_done) && (!have_free_buf_spec(vdec))) ||
 	    ((p_H264_Dpb->mDPB.init_done) &&
 	     (p_H264_Dpb->mDPB.used_size == p_H264_Dpb->mDPB.size) &&
 	     (is_there_unused_frame_from_dpb(&p_H264_Dpb->mDPB) == 0))) {
-		dpb_print(hw->dpb.decoder_index, PRINT_FLAG_UCODE_EVT,
+		dpb_print(DECODE_ID(hw), PRINT_FLAG_VDEC_DETAIL,
 		"%s, empty, newq(%d), free_spec(%d), initdon(%d), used_size(%d/%d), unused_fr_dpb(%d)\n",
 		__func__,
 		kfifo_len(&hw->newframe_q),
@@ -1533,63 +3185,100 @@ static bool is_buffer_available(struct vdec_s *vdec)
 		is_there_unused_frame_from_dpb(&p_H264_Dpb->mDPB)
 		);
 		buffer_available = 0;
-
-		bufmgr_h264_remove_unused_frame(p_H264_Dpb);
+		if ((error_proc_policy & 0x4) &&
+			(error_proc_policy & 0x8)) {
+			if ((kfifo_len(&hw->display_q) <= 0) &&
+			(p_H264_Dpb->mDPB.used_size ==
+				p_H264_Dpb->mDPB.size) &&
+				(p_Dpb->ref_frames_in_buffer >
+				(imax(
+				1, p_Dpb->num_ref_frames)
+				- p_Dpb->ltref_frames_in_buffer +
+				force_sliding_margin)))
+				bufmgr_recover(hw);
+			else
+				bufmgr_h264_remove_unused_frame(p_H264_Dpb, 1);
+		} else if ((error_proc_policy & 0x4) &&
+			(kfifo_len(&hw->display_q) <= 0) &&
+			((p_H264_Dpb->mDPB.used_size ==
+				p_H264_Dpb->mDPB.size) ||
+			(!have_free_buf_spec(vdec)))) {
+			enum receviver_start_e state = RECEIVER_INACTIVE;
+			if ((error_proc_policy & 0x10) &&
+				vf_get_receiver(vdec->vf_provider_name)) {
+				state =
+				vf_notify_receiver(vdec->vf_provider_name,
+					VFRAME_EVENT_PROVIDER_QUREY_STATE,
+					NULL);
+				if ((state == RECEIVER_STATE_NULL)
+					|| (state == RECEIVER_STATE_NONE))
+					state = RECEIVER_INACTIVE;
+			}
+			if (state == RECEIVER_INACTIVE)
+				bufmgr_recover(hw);
+			else
+				bufmgr_h264_remove_unused_frame(p_H264_Dpb, 1);
+		} else if ((error_proc_policy & 0x8) &&
+			(p_Dpb->ref_frames_in_buffer >
+			(imax(
+			1, p_Dpb->num_ref_frames)
+			- p_Dpb->ltref_frames_in_buffer +
+			force_sliding_margin)))
+			bufmgr_recover(hw);
+		else
+			bufmgr_h264_remove_unused_frame(p_H264_Dpb, 1);
 	}
 
 	return buffer_available;
 }
 
-static irqreturn_t vh264_isr(struct vdec_s *vdec)
+static void check_decoded_pic_error(struct vdec_h264_hw_s *hw)
 {
-	unsigned int dec_dpb_status;
-	struct vdec_h264_hw_s *hw = (struct vdec_h264_hw_s *)(vdec->private);
-	struct h264_dpb_stru *p_H264_Dpb = &hw->dpb;
-	int i;
-
-	WRITE_VREG(ASSIST_MBOX1_CLR_REG, 1);
+	unsigned mby_mbx = READ_VREG(MBY_MBX);
+	unsigned mb_total = (hw->seq_info2 >> 8) & 0xffff;
+	unsigned decode_mb_count =
+		(((mby_mbx & 0xff) + 1) *
+		(((mby_mbx >> 8) & 0xff) + 1));
+	if ((error_proc_policy & 0x100) &&
+		decode_mb_count != mb_total)
+		hw->data_flag |= ERROR_FLAG;
+
+	if ((error_proc_policy & 0x200) &&
+		READ_VREG(ERROR_STATUS_REG) != 0)
+		hw->data_flag |= ERROR_FLAG;
+
+	if (hw->data_flag & ERROR_FLAG) {
+		dpb_print(DECODE_ID(hw), 0,
+			"%s: decode error, seq_info2 0x%x, mby_mbx 0x%x, mb_total %d decoded mb_count %d ERROR_STATUS_REG 0x%x\n",
+			__func__,
+			hw->seq_info2,
+			mby_mbx,
+			mb_total,
+			decode_mb_count,
+			READ_VREG(ERROR_STATUS_REG)
+			);
 
-	if (!hw) {
-		dpb_print(hw->dpb.decoder_index, PRINT_FLAG_VDEC_STATUS,
-			"decoder is not running\n");
-		return IRQ_HANDLED;
 	}
+}
 
-	p_H264_Dpb->vdec = vdec;
-	dec_dpb_status = READ_VREG(DPB_STATUS_REG);
-
-	dpb_print(hw->dpb.decoder_index, PRINT_FLAG_UCODE_EVT,
-			"%s DPB_STATUS_REG: %x, sb (%x %x %x) bitcnt %x\n",
-			__func__,
-			dec_dpb_status,
-			READ_VREG(VLD_MEM_VIFIFO_LEVEL),
-			READ_VREG(VLD_MEM_VIFIFO_WP),
-			READ_VREG(VLD_MEM_VIFIFO_RP),
-			READ_VREG(VIFF_BIT_CNT));
+static irqreturn_t vh264_isr_thread_fn(struct vdec_s *vdec)
+{
+	int i;
+	struct vdec_h264_hw_s *hw = (struct vdec_h264_hw_s *)(vdec->private);
+	struct h264_dpb_stru *p_H264_Dpb = &hw->dpb;
+	unsigned int dec_dpb_status = p_H264_Dpb->dec_dpb_status;
+	u32 debug_tag;
 
 	if (dec_dpb_status == H264_CONFIG_REQUEST) {
 		WRITE_VREG(DPB_STATUS_REG, H264_ACTION_CONFIG_DONE);
-#ifdef USE_CMA
-		if (hw->set_params_done) {
-			WRITE_VREG(AV_SCRATCH_0,
-				(hw->max_reference_size<<24) |
-				(hw->buffer_spec_num<<16) |
-				(hw->buffer_spec_num<<8));
-		} else {
-			hw->dec_result = DEC_RESULT_CONFIG_PARAM;
-			schedule_work(&hw->work);
-		}
-#else
-		if (vh264_set_params(hw) < 0) {
-			hw->fatal_error_flag = DECODER_FATAL_ERROR_UNKNOW;
-			if (!hw->fatal_error_reset)
-				schedule_work(&hw->error_wd_work);
-		}
-#endif
+		reset_process_time(hw);
+		hw->dec_result = DEC_RESULT_CONFIG_PARAM;
+		vdec_schedule_work(&hw->work);
 	} else if (dec_dpb_status == H264_SLICE_HEAD_DONE) {
 		int slice_header_process_status = 0;
+		/*unsigned char is_idr;*/
 		unsigned short *p = (unsigned short *)hw->lmem_addr;
-
+		reset_process_time(hw);
 		dma_sync_single_for_cpu(
 			amports_get_dma_device(),
 			hw->lmem_addr_remap,
@@ -1599,7 +3288,7 @@ static irqreturn_t vh264_isr(struct vdec_s *vdec)
 		if (p_H264_Dpb->mVideo.dec_picture == NULL) {
 			if (!is_buffer_available(vdec)) {
 				hw->buffer_empty_flag = 1;
-				dpb_print(hw->dpb.decoder_index,
+				dpb_print(DECODE_ID(hw),
 				PRINT_FLAG_UCODE_EVT,
 				"%s, buffer_empty, newframe_q(%d), have_free_buf_spec(%d), init_done(%d), used_size(%d/%d), is_there_unused_frame_from_dpb(%d)\n",
 					__func__,
@@ -1633,42 +3322,171 @@ static irqreturn_t vh264_isr(struct vdec_s *vdec)
 			for (ii = 0; ii < 4; ii++) {
 				p_H264_Dpb->dpb_param.l.data[i+ii] =
 					p[i+3-ii];
+				if (dpb_is_debug(DECODE_ID(hw),
+					RRINT_FLAG_RPM)) {
+					if (((i + ii) & 0xf) == 0)
+						dpb_print(DECODE_ID(hw),
+							0, "%04x:",
+							i);
+					dpb_print_cont(DECODE_ID(hw),
+						0, "%04x ",
+						p[i+3-ii]);
+					if (((i + ii + 1) & 0xf) == 0)
+						dpb_print_cont(
+						DECODE_ID(hw),
+							0, "\r\n");
+				}
 			}
 		}
 #endif
-		dpb_print(hw->dpb.decoder_index, PRINT_FLAG_UCODE_EVT,
+		if ((first_i_policy & 0x3) != 0) {
+			unsigned char is_i_slice =
+				(p_H264_Dpb->dpb_param.l.data[SLICE_TYPE]
+					== I_Slice)
+				? 1 : 0;
+
+			if ((first_i_policy & 0x3) == 0x3)
+				is_i_slice =
+				(p_H264_Dpb->dpb_param.dpb.NAL_info_mmco & 0x1f)
+				== 5 ? 1 : 0;
+			if (!is_i_slice) {
+				if (hw->has_i_frame == 0) {
+					hw->dec_result = DEC_RESULT_DONE;
+					vdec_schedule_work(&hw->work);
+					dpb_print(DECODE_ID(hw),
+						PRINT_FLAG_UCODE_EVT,
+						"has_i_frame is 0, discard none I(DR) frame\n");
+					return IRQ_HANDLED;
+				}
+			} else {
+				if (hw->skip_frame_count < 0) {
+					/* second I */
+					hw->dec_flag &= (~NODISP_FLAG);
+					hw->skip_frame_count = 0;
+				}
+				if (hw->has_i_frame == 0 &&
+					(p_H264_Dpb->
+					dpb_param.dpb.NAL_info_mmco & 0x1f)
+					!= 5) {
+					int skip_count =
+						(first_i_policy >> 8) & 0xff;
+					/* first I (not IDR) */
+					if ((first_i_policy & 0x3) == 2)
+						hw->skip_frame_count =
+							-1 - skip_count;
+					else
+						hw->skip_frame_count =
+							skip_count;
+					if (hw->skip_frame_count != 0)
+						hw->dec_flag |= NODISP_FLAG;
+				}
+			}
+		}
+		dpb_print(DECODE_ID(hw), PRINT_FLAG_UCODE_EVT,
 			"current dpb index %d, poc %d, top/bot poc (%d,%d)\n",
 			p_H264_Dpb->dpb_param.dpb.current_dpb_index,
 			val(p_H264_Dpb->dpb_param.dpb.frame_pic_order_cnt),
 			val(p_H264_Dpb->dpb_param.dpb.top_field_pic_order_cnt),
 			val(p_H264_Dpb->dpb_param.dpb.top_field_pic_order_cnt));
 
+		if (hw->reset_bufmgr_flag) {
+			h264_reset_bufmgr(hw);
+			hw->reset_bufmgr_flag = 0;
+		}
+
 		slice_header_process_status =
 			h264_slice_header_process(p_H264_Dpb);
+		if (mmu_enable)
+			hevc_sao_set_slice_type(hw,
+				slice_header_process_status,
+					hw->dpb.mSlice.idr_flag);
+		vui_config(hw);
 
 		if (p_H264_Dpb->mVideo.dec_picture) {
+			int cfg_ret = 0;
+			if (hw->sei_itu_data_len) {
+				hw->sei_poc =
+					p_H264_Dpb->mVideo.dec_picture->poc;
+				schedule_work(&hw->user_data_work);
+			}
 			if (slice_header_process_status == 1) {
-				dpb_print(hw->dpb.decoder_index,
-				PRINT_FLAG_UCODE_EVT,
-				"==================> frame count %d\n",
-				hw->decode_pic_count+1);
+				hw->data_flag =
+					(p_H264_Dpb->
+						dpb_param.l.data[SLICE_TYPE]
+						== I_Slice)
+					? I_FLAG : 0;
+				if ((hw->i_only & 0x2) &&
+					(!(hw->data_flag & I_FLAG))) {
+					hw->data_flag =	NULL_FLAG;
+					goto pic_done_proc;
+				}
+				if ((p_H264_Dpb->
+					dpb_param.dpb.NAL_info_mmco & 0x1f)
+					== 5)
+					hw->data_flag |= IDR_FLAG;
+				dpb_print(DECODE_ID(hw),
+				PRINT_FLAG_VDEC_STATUS,
+				"==================> frame count %d to skip %d\n",
+				hw->decode_pic_count+1,
+				hw->skip_frame_count);
+			}
+			cfg_ret = config_decode_buf(hw,
+				p_H264_Dpb->mVideo.dec_picture);
+			if (cfg_ret < 0) {
+				dpb_print(DECODE_ID(hw), PRINT_FLAG_ERROR,
+					"config_decode_buf fail (%d)\n",
+					cfg_ret);
+				if (error_proc_policy & 0x2) {
+					remove_picture(p_H264_Dpb,
+						p_H264_Dpb->mVideo.dec_picture);
+					p_H264_Dpb->mVideo.dec_picture = NULL;
+					/*hw->data_flag |= ERROR_FLAG;*/
+					hw->dec_result = DEC_RESULT_DONE;
+					vdec_schedule_work(&hw->work);
+					return IRQ_HANDLED;
+				} else
+					hw->data_flag |= ERROR_FLAG;
 			}
-			config_decode_buf(hw, p_H264_Dpb->mVideo.dec_picture);
 		}
+
 		if (slice_header_process_status == 1)
 			WRITE_VREG(DPB_STATUS_REG, H264_ACTION_DECODE_NEWPIC);
 		else
 			WRITE_VREG(DPB_STATUS_REG, H264_ACTION_DECODE_SLICE);
 		hw->last_mby_mbx = 0;
 		hw->last_ucode_watchdog_reg_val = 0;
-		hw->decode_timeout_count = 2;
+		start_process_time(hw);
 	} else if (dec_dpb_status == H264_PIC_DATA_DONE) {
+pic_done_proc:
+		reset_process_time(hw);
 		if (p_H264_Dpb->mVideo.dec_picture) {
+#ifdef CONFIG_AM_VDEC_DV
+			DEL_EXIST(hw,
+				p_H264_Dpb->mVideo.dec_picture) = 0;
+			if (vdec->master) {
+				struct vdec_h264_hw_s *hw_ba =
+				(struct vdec_h264_hw_s *)
+					vdec->master->private;
+				if (hw_ba->last_dec_picture)
+					DEL_EXIST(hw_ba,
+						hw_ba->last_dec_picture)
+						= 1;
+			}
+#endif
 			if (hw->chunk) {
 				p_H264_Dpb->mVideo.dec_picture->pts =
 					hw->chunk->pts;
 				p_H264_Dpb->mVideo.dec_picture->pts64 =
 					hw->chunk->pts64;
+#ifdef CONFIG_AM_VDEC_DV
+			} else if (vdec->master) {
+				/*dv enhance layer,
+				do not checkout pts*/
+				struct StorablePicture *pic =
+					p_H264_Dpb->mVideo.dec_picture;
+				pic->pts = 0;
+				pic->pts64 = 0;
+#endif
 			} else {
 				struct StorablePicture *pic =
 					p_H264_Dpb->mVideo.dec_picture;
@@ -1680,31 +3498,130 @@ static irqreturn_t vh264_isr(struct vdec_s *vdec)
 					pic->pts64 = 0;
 				}
 			}
-			store_picture_in_dpb(p_H264_Dpb,
-				p_H264_Dpb->mVideo.dec_picture);
+			check_decoded_pic_error(hw);
 
+			store_picture_in_dpb(p_H264_Dpb,
+				p_H264_Dpb->mVideo.dec_picture,
+				hw->data_flag | hw->dec_flag);
+			if (hw->data_flag & ERROR_FLAG) {
+				hw->no_error_count = 0;
+				hw->no_error_i_count = 0;
+			} else {
+				hw->no_error_count++;
+				if (hw->data_flag & I_FLAG)
+					hw->no_error_i_count++;
+			}
+			if (mmu_enable)
+				hevc_set_unused_4k_buff_idx(hw,
+					p_H264_Dpb->mVideo.
+						dec_picture->buf_spec_num);
 			bufmgr_post(p_H264_Dpb);
-
+			hw->last_dec_picture = p_H264_Dpb->mVideo.dec_picture;
 			p_H264_Dpb->mVideo.dec_picture = NULL;
 			/* dump_dpb(&p_H264_Dpb->mDPB); */
+			hw->has_i_frame = 1;
+			if (mmu_enable)
+				hevc_set_frame_done(hw);
+			hw->decode_pic_count++;
+			p_H264_Dpb->decode_pic_count = hw->decode_pic_count;
+			if (hw->skip_frame_count > 0) {
+				/*skip n frame after first I */
+				hw->skip_frame_count--;
+				if (hw->skip_frame_count == 0)
+					hw->dec_flag &= (~NODISP_FLAG);
+			} else if (hw->skip_frame_count < -1) {
+				/*skip n frame after first I until second I */
+				hw->skip_frame_count++;
+				if (hw->skip_frame_count == -1)
+					hw->dec_flag &= (~NODISP_FLAG);
+			}
 		}
 
-		if ((h264_debug_flag&ONLY_RESET_AT_START) == 0)
-			amvdec_stop();
-		hw->decode_pic_count++,
-		dpb_print(hw->dpb.decoder_index, PRINT_FLAG_VDEC_STATUS,
-			"%s H264_PIC_DATA_DONE decode slice count %d\n",
+		amvdec_stop();
+		dpb_print(DECODE_ID(hw), PRINT_FLAG_VDEC_STATUS,
+			"%s %s decode slice count %d\n",
 			__func__,
+			(dec_dpb_status == H264_PIC_DATA_DONE) ?
+			"H264_PIC_DATA_DONE" :
+			(dec_dpb_status == H264_FIND_NEXT_PIC_NAL) ?
+			"H264_FIND_NEXT_PIC_NAL" : "H264_FIND_NEXT_DVEL_NAL",
 			hw->decode_pic_count);
 		/* WRITE_VREG(DPB_STATUS_REG, H264_ACTION_SEARCH_HEAD); */
 		hw->dec_result = DEC_RESULT_DONE;
+#ifdef CONFIG_AM_VDEC_DV
+		if (vdec->slave &&
+			dec_dpb_status == H264_FIND_NEXT_DVEL_NAL) {
+			struct vdec_h264_hw_s *hw_el =
+			 (struct vdec_h264_hw_s *)(vdec->slave->private);
+			hw_el->got_valid_nal = 0;
+			hw->switch_dvlayer_flag = 1;
+		} else if (vdec->master &&
+			dec_dpb_status == H264_FIND_NEXT_PIC_NAL) {
+			struct vdec_h264_hw_s *hw_bl =
+			 (struct vdec_h264_hw_s *)(vdec->master->private);
+			hw_bl->got_valid_nal = 0;
+			hw->switch_dvlayer_flag = 1;
+		} else {
+			hw->switch_dvlayer_flag = 0;
+			hw->got_valid_nal = 1;
+		}
+#endif
+		vdec_schedule_work(&hw->work);
+#ifdef CONFIG_AM_VDEC_DV
+	} else if (
+			(dec_dpb_status == H264_FIND_NEXT_PIC_NAL) ||
+			(dec_dpb_status == H264_FIND_NEXT_DVEL_NAL)) {
+		goto pic_done_proc;
+#endif
+	} else if (dec_dpb_status == H264_AUX_DATA_READY) {
 		reset_process_time(hw);
-		schedule_work(&hw->work);
+		if (READ_VREG(H264_AUX_DATA_SIZE) != 0) {
+			dma_sync_single_for_cpu(
+			amports_get_dma_device(),
+			hw->aux_phy_addr,
+			hw->prefix_aux_size + hw->suffix_aux_size,
+			DMA_FROM_DEVICE);
+			if (dpb_is_debug(DECODE_ID(hw),
+				PRINT_FLAG_DPB_DETAIL))
+				dump_aux_buf(hw);
+#ifdef CONFIG_AM_VDEC_DV
+			if (dolby_meta_with_el || vdec->slave) {
+				if (hw->last_dec_picture)
+					set_aux_data(hw, hw->last_dec_picture,
+						0, 0, NULL);
+			} else {
+				if (vdec->master) {
+						struct vdec_h264_hw_s *hw_bl =
+						(struct vdec_h264_hw_s *)
+						(vdec->master->private);
+					if (hw_bl->last_dec_picture != NULL) {
+						set_aux_data(hw_bl,
+							hw_bl->last_dec_picture,
+							0, 1, hw);
+					}
+					set_aux_data(hw,
+						hw->last_dec_picture,
+						0, 2, NULL);
+				}
+			}
+#else
+			if (hw->last_dec_picture)
+				set_aux_data(hw,
+					hw->last_dec_picture, 0, 0, NULL);
+#endif
+		}
+#ifdef CONFIG_AM_VDEC_DV
+		hw->switch_dvlayer_flag = 0;
+		hw->got_valid_nal = 1;
+#endif
+		hw->dec_result = DEC_RESULT_DONE;
+		vdec_schedule_work(&hw->work);
 	} else if (/*(dec_dpb_status == H264_DATA_REQUEST) ||*/
 			(dec_dpb_status == H264_SEARCH_BUFEMPTY) ||
 			(dec_dpb_status == H264_DECODE_BUFEMPTY) ||
 			(dec_dpb_status == H264_DECODE_TIMEOUT)) {
 empty_proc:
+		reset_process_time(hw);
 		if (p_H264_Dpb->mVideo.dec_picture) {
 			remove_picture(p_H264_Dpb,
 				p_H264_Dpb->mVideo.dec_picture);
@@ -1715,21 +3632,23 @@ empty_proc:
 			(READ_VREG(VLD_MEM_VIFIFO_LEVEL) > 0x200)) {
 			if (h264_debug_flag &
 				DISABLE_ERROR_HANDLE) {
-				dpb_print(hw->dpb.decoder_index,
+				dpb_print(DECODE_ID(hw),
 				PRINT_FLAG_ERROR,
 					"%s decoding error, level 0x%x\n",
 					__func__,
 					READ_VREG(VLD_MEM_VIFIFO_LEVEL));
 				goto send_again;
 			}
-			if ((h264_debug_flag & ONLY_RESET_AT_START) == 0)
-				amvdec_stop();
-			dpb_print(hw->dpb.decoder_index, PRINT_FLAG_UCODE_EVT,
+			amvdec_stop();
+			dpb_print(DECODE_ID(hw), PRINT_FLAG_VDEC_STATUS,
 				"%s %s\n", __func__,
 				(dec_dpb_status == H264_SEARCH_BUFEMPTY) ?
 				"H264_SEARCH_BUFEMPTY" :
 				(dec_dpb_status == H264_DECODE_BUFEMPTY) ?
-				"H264_DECODE_BUFEMPTY" : "H264_DECODE_TIMEOUT");
+				"H264_DECODE_BUFEMPTY" :
+				(dec_dpb_status == H264_DECODE_TIMEOUT) ?
+				"H264_DECODE_TIMEOUT" :
+				"OTHER");
 			hw->dec_result = DEC_RESULT_DONE;
 
 			if (dec_dpb_status == H264_SEARCH_BUFEMPTY)
@@ -1739,31 +3658,87 @@ empty_proc:
 			else if (dec_dpb_status == H264_DECODE_BUFEMPTY)
 				hw->decode_dataempty_num++;
 
+			hw->data_flag |= ERROR_FLAG;
 
-			reset_process_time(hw);
-			schedule_work(&hw->work);
+			vdec_schedule_work(&hw->work);
 		} else {
 			/* WRITE_VREG(DPB_STATUS_REG, H264_ACTION_INIT); */
-			dpb_print(hw->dpb.decoder_index, PRINT_FLAG_VDEC_STATUS,
+			dpb_print(DECODE_ID(hw), PRINT_FLAG_VDEC_STATUS,
 				"%s DEC_RESULT_AGAIN\n", __func__);
 send_again:
 			hw->dec_result = DEC_RESULT_AGAIN;
-			schedule_work(&hw->work);
+			vdec_schedule_work(&hw->work);
 		}
 	} else if (dec_dpb_status == H264_DATA_REQUEST) {
+		reset_process_time(hw);
 		if (input_frame_based(vdec)) {
-			dpb_print(hw->dpb.decoder_index,
+			dpb_print(DECODE_ID(hw),
 			PRINT_FLAG_VDEC_STATUS,
-			"%s H264_DATA_REQUEST\n", __func__);
+			"%s H264_DATA_REQUEST (%d)\n",
+			__func__, hw->get_data_count);
 			hw->dec_result = DEC_RESULT_GET_DATA;
-			schedule_work(&hw->work);
+			hw->get_data_start_time = jiffies;
+			hw->get_data_count++;
+			if (hw->get_data_count >= frame_max_data_packet)
+				goto empty_proc;
+			vdec_schedule_work(&hw->work);
 		} else
 			goto empty_proc;
+	} else if (dec_dpb_status == H264_DECODE_OVER_SIZE) {
+			dpb_print(DECODE_ID(hw), 0,
+				"vmh264 decode oversize !!\n");
+			hw->data_flag |= ERROR_FLAG;
+			hw->stat |= DECODER_FATAL_ERROR_SIZE_OVERFLOW;
+			reset_process_time(hw);
+			return IRQ_HANDLED;
+		}
+
+	if (READ_VREG(AV_SCRATCH_G) == 1) {
+		hw->sei_itu_data_len =
+			(READ_VREG(H264_AUX_DATA_SIZE) >> 16) << 4;
+		if (hw->sei_itu_data_len > SEI_ITU_DATA_SIZE * 2) {
+				dpb_print(DECODE_ID(hw), PRINT_FLAG_ERROR,
+					"itu data size more than 4K: %d, discarded it\n",
+					hw->sei_itu_data_len);
+				hw->sei_itu_data_len = 0;
+		}
+
+		if (hw->sei_itu_data_len != 0) {
+			u8 *trans_data_buf;
+			u8 *sei_data_buf;
+			u32 temp;
+			u32 *pswap_data;
+
+			dma_sync_single_for_cpu(
+			amports_get_dma_device(),
+			hw->aux_phy_addr,
+			hw->prefix_aux_size + hw->suffix_aux_size,
+			DMA_FROM_DEVICE);
+#if 0
+			dump_aux_buf(hw);
+#endif
+
+			trans_data_buf = (u8 *)hw->aux_addr;
+			sei_data_buf = (u8 *)hw->sei_itu_data_buf;
+			for (i = 0; i < hw->sei_itu_data_len/2; i++)
+				sei_data_buf[i] = trans_data_buf[i*2];
+			hw->sei_itu_data_len = hw->sei_itu_data_len / 2;
+
+			pswap_data = (u32 *)hw->sei_itu_data_buf;
+			for (i = 0; i < hw->sei_itu_data_len/4; i = i+2) {
+				temp = pswap_data[i];
+				pswap_data[i] = pswap_data[i+1];
+				pswap_data[i+1] = temp;
+			}
+		}
+		WRITE_VREG(AV_SCRATCH_G, 0);
+		return IRQ_HANDLED;
 	}
 
+
 	/* ucode debug */
-	if (READ_VREG(DEBUG_REG1) & 0x10000) {
-		int i;
+	debug_tag = READ_VREG(DEBUG_REG1);
+	if (debug_tag & 0x10000) {
 		unsigned short *p = (unsigned short *)hw->lmem_addr;
 
 		dma_sync_single_for_cpu(
@@ -1772,56 +3747,262 @@ send_again:
 			PAGE_SIZE,
 			DMA_FROM_DEVICE);
 
-		pr_info("LMEM<tag %x>:\n", READ_VREG(DEBUG_REG1));
+		dpb_print(DECODE_ID(hw), 0,
+			"LMEM<tag %x>:\n", debug_tag);
 		for (i = 0; i < 0x400; i += 4) {
 			int ii;
 			if ((i & 0xf) == 0)
-				pr_info("%03x: ", i);
+				dpb_print_cont(DECODE_ID(hw), 0,
+					"%03x: ", i);
 			for (ii = 0; ii < 4; ii++)
-				pr_info("%04x ", p[i+3-ii]);
+				dpb_print_cont(DECODE_ID(hw), 0,
+					"%04x ", p[i+3-ii]);
 			if (((i+ii) & 0xf) == 0)
-				pr_info("\n");
+				dpb_print_cont(DECODE_ID(hw), 0,
+					"\n");
 		}
-		WRITE_VREG(DEBUG_REG1, 0);
-	} else if (READ_VREG(DEBUG_REG1) != 0) {
-		pr_info("dbg%x: %x\n", READ_VREG(DEBUG_REG1),
+		if ((udebug_pause_pos == (debug_tag & 0xffff)) &&
+			(udebug_pause_decode_idx == 0 ||
+			udebug_pause_decode_idx ==
+			hw->decode_pic_count) &&
+			(udebug_pause_val == 0 ||
+			udebug_pause_val == READ_VREG(DEBUG_REG2)))
+			hw->ucode_pause_pos = udebug_pause_pos;
+		else if (debug_tag & 0x20000)
+			hw->ucode_pause_pos = 0xffffffff;
+		if (hw->ucode_pause_pos)
+			reset_process_time(hw);
+		else
+			WRITE_VREG(DEBUG_REG1, 0);
+	} else if (debug_tag != 0) {
+		dpb_print(DECODE_ID(hw), 0,
+			"dbg%x: %x\n", debug_tag,
 			READ_VREG(DEBUG_REG2));
-		WRITE_VREG(DEBUG_REG1, 0);
+		if ((udebug_pause_pos == (debug_tag & 0xffff)) &&
+			(udebug_pause_decode_idx == 0 ||
+			udebug_pause_decode_idx ==
+			hw->decode_pic_count) &&
+			(udebug_pause_val == 0 ||
+			udebug_pause_val == READ_VREG(DEBUG_REG2)))
+			hw->ucode_pause_pos = udebug_pause_pos;
+		if (hw->ucode_pause_pos)
+			reset_process_time(hw);
+		else
+			WRITE_VREG(DEBUG_REG1, 0);
 	}
 	/**/
-
 	return IRQ_HANDLED;
 }
+static irqreturn_t vh264_isr(struct vdec_s *vdec)
+{
+	struct vdec_h264_hw_s *hw = (struct vdec_h264_hw_s *)(vdec->private);
+	struct h264_dpb_stru *p_H264_Dpb = &hw->dpb;
+
+
+	WRITE_VREG(ASSIST_MBOX1_CLR_REG, 1);
+
+	if (!hw) {
+		dpb_print(DECODE_ID(hw), PRINT_FLAG_ERROR,
+			"decoder is not running\n");
+		return IRQ_HANDLED;
+	}
+	if (hw->eos)
+		return IRQ_HANDLED;
+
+	p_H264_Dpb->vdec = vdec;
+	p_H264_Dpb->dec_dpb_status = READ_VREG(DPB_STATUS_REG);
+
+	dpb_print(DECODE_ID(hw), PRINT_FLAG_UCODE_EVT,
+			"%s DPB_STATUS_REG: 0x%x, ERROR_STATUS_REG 0x%x, sb (0x%x 0x%x 0x%x) bitcnt 0x%x mby_mbx 0x%x\n",
+			__func__,
+			p_H264_Dpb->dec_dpb_status,
+			READ_VREG(ERROR_STATUS_REG),
+			READ_VREG(VLD_MEM_VIFIFO_LEVEL),
+			READ_VREG(VLD_MEM_VIFIFO_WP),
+			READ_VREG(VLD_MEM_VIFIFO_RP),
+			READ_VREG(VIFF_BIT_CNT),
+			READ_VREG(MBY_MBX));
+
+	if (p_H264_Dpb->dec_dpb_status == H264_WRRSP_REQUEST) {
+		if (mmu_enable)
+			hevc_sao_wait_done(hw);
+		WRITE_VREG(DPB_STATUS_REG, H264_WRRSP_DONE);
+		return IRQ_HANDLED;
+	}
+	return IRQ_WAKE_THREAD;
+
+}
 
 static void timeout_process(struct vdec_h264_hw_s *hw)
 {
 	hw->timeout_num++;
-	if ((h264_debug_flag & ONLY_RESET_AT_START) == 0)
-		amvdec_stop();
-	dpb_print(hw->dpb.decoder_index,
+	amvdec_stop();
+	dpb_print(DECODE_ID(hw),
 		PRINT_FLAG_ERROR, "%s decoder timeout\n", __func__);
 	hw->dec_result = DEC_RESULT_DONE;
+	hw->data_flag |= ERROR_FLAG;
 	reset_process_time(hw);
-	schedule_work(&hw->work);
+	vdec_schedule_work(&hw->work);
+}
+
+static void vmh264_dump_state(struct vdec_s *vdec)
+{
+	struct vdec_h264_hw_s *hw =
+		(struct vdec_h264_hw_s *)(vdec->private);
+	struct h264_dpb_stru *p_H264_Dpb = &hw->dpb;
+	int i;
+	dpb_print(DECODE_ID(hw), 0,
+		"====== %s\n", __func__);
+	dpb_print(DECODE_ID(hw), 0,
+		"width/height (%d/%d), reorder_pic_num %d dpb size(bufspec count) %d max_reference_size(collocate count) %d\n",
+		hw->frame_width,
+		hw->frame_height,
+		hw->dpb.reorder_pic_num,
+		hw->dpb.mDPB.size,
+		hw->max_reference_size
+		);
+
+	dpb_print(DECODE_ID(hw), 0,
+		"is_framebase(%d), eos %d, state 0x%x, dec_result 0x%x dec_frm %d disp_frm %d run %d not_run_ready %d input_empty %d\n",
+		input_frame_based(vdec),
+		hw->eos,
+		hw->stat,
+		hw->dec_result,
+		decode_frame_count[DECODE_ID(hw)],
+		display_frame_count[DECODE_ID(hw)],
+		run_count[DECODE_ID(hw)],
+		not_run_ready[DECODE_ID(hw)],
+		input_empty[DECODE_ID(hw)]
+		);
+
+	if (vf_get_receiver(vdec->vf_provider_name)) {
+		enum receviver_start_e state =
+		vf_notify_receiver(vdec->vf_provider_name,
+			VFRAME_EVENT_PROVIDER_QUREY_STATE,
+			NULL);
+		dpb_print(DECODE_ID(hw), 0,
+			"\nreceiver(%s) state %d\n",
+			vdec->vf_provider_name,
+			state);
+	}
+
+	dpb_print(DECODE_ID(hw), 0,
+	"%s, newq(%d/%d), dispq(%d/%d) vf prepare/get/put (%d/%d/%d), free_spec(%d), initdon(%d), used_size(%d/%d), unused_fr_dpb(%d)\n",
+	__func__,
+	kfifo_len(&hw->newframe_q),
+	VF_POOL_SIZE,
+	kfifo_len(&hw->display_q),
+	VF_POOL_SIZE,
+	hw->vf_pre_count,
+	hw->vf_get_count,
+	hw->vf_put_count,
+	have_free_buf_spec(vdec),
+	p_H264_Dpb->mDPB.init_done,
+	p_H264_Dpb->mDPB.used_size, p_H264_Dpb->mDPB.size,
+	is_there_unused_frame_from_dpb(&p_H264_Dpb->mDPB)
+	);
+
+	dump_dpb(&p_H264_Dpb->mDPB, 1);
+	for (i = 0; i < BUFSPEC_POOL_SIZE; i++) {
+		dpb_print(DECODE_ID(hw), 0,
+			"bufspec (%d): used %d adr 0x%x canvas(%d) vf_ref(%d) ",
+			i, hw->buffer_spec[i].used,
+			hw->buffer_spec[i].buf_adr,
+			hw->buffer_spec[i].canvas_pos,
+			hw->buffer_spec[i].vf_ref
+			);
+#ifdef CONFIG_AM_VDEC_DV
+		dpb_print_cont(DECODE_ID(hw), 0,
+			"dv_el_exist %d",
+			hw->buffer_spec[i].dv_enhance_exist
+		);
+#endif
+		dpb_print_cont(DECODE_ID(hw), 0, "\n");
+	}
+
+	dpb_print(DECODE_ID(hw), 0,
+		"DPB_STATUS_REG=0x%x\n",
+		READ_VREG(DPB_STATUS_REG));
+	dpb_print(DECODE_ID(hw), 0,
+		"MPC_E=0x%x\n",
+		READ_VREG(MPC_E));
+	dpb_print(DECODE_ID(hw), 0,
+		"H264_DECODE_MODE=0x%x\n",
+		READ_VREG(H264_DECODE_MODE));
+	dpb_print(DECODE_ID(hw), 0,
+		"MBY_MBX=0x%x\n",
+		READ_VREG(MBY_MBX));
+	dpb_print(DECODE_ID(hw), 0,
+		"H264_DECODE_SIZE=0x%x\n",
+		READ_VREG(H264_DECODE_SIZE));
+	dpb_print(DECODE_ID(hw), 0,
+		"VIFF_BIT_CNT=0x%x\n",
+		READ_VREG(VIFF_BIT_CNT));
+	dpb_print(DECODE_ID(hw), 0,
+		"VLD_MEM_VIFIFO_LEVEL=0x%x\n",
+		READ_VREG(VLD_MEM_VIFIFO_LEVEL));
+	dpb_print(DECODE_ID(hw), 0,
+		"VLD_MEM_VIFIFO_WP=0x%x\n",
+		READ_VREG(VLD_MEM_VIFIFO_WP));
+	dpb_print(DECODE_ID(hw), 0,
+		"VLD_MEM_VIFIFO_RP=0x%x\n",
+		READ_VREG(VLD_MEM_VIFIFO_RP));
+	dpb_print(DECODE_ID(hw), 0,
+		"PARSER_VIDEO_RP=0x%x\n",
+		READ_PARSER_REG(PARSER_VIDEO_RP));
+	dpb_print(DECODE_ID(hw), 0,
+		"PARSER_VIDEO_WP=0x%x\n",
+		READ_PARSER_REG(PARSER_VIDEO_WP));
+
+	if (input_frame_based(vdec) &&
+		dpb_is_debug(DECODE_ID(hw),
+		PRINT_FRAMEBASE_DATA)
+		) {
+		int jj;
+		if (hw->chunk && hw->chunk->block &&
+			hw->chunk->size > 0) {
+			u8 *data =
+			((u8 *)hw->chunk->block->start_virt) +
+				hw->chunk->offset;
+			dpb_print(DECODE_ID(hw), 0,
+				"frame data size 0x%x\n",
+				hw->chunk->size);
+			for (jj = 0; jj < hw->chunk->size; jj++) {
+				if ((jj & 0xf) == 0)
+					dpb_print(DECODE_ID(hw),
+					PRINT_FRAMEBASE_DATA,
+						"%06x:", jj);
+				dpb_print_cont(DECODE_ID(hw),
+				PRINT_FRAMEBASE_DATA,
+					"%02x ", data[jj]);
+				if (((jj + 1) & 0xf) == 0)
+					dpb_print_cont(DECODE_ID(hw),
+					PRINT_FRAMEBASE_DATA,
+						"\n");
+			}
+		}
+	}
 }
 
+
 static void check_timer_func(unsigned long arg)
 {
 	struct vdec_h264_hw_s *hw = (struct vdec_h264_hw_s *)arg;
+	struct vdec_s *vdec = hw_to_vdec(hw);
 
 	if ((h264_debug_cmd & 0x100) != 0 &&
-		hw_to_vdec(hw)->id == (h264_debug_cmd & 0xff)) {
+		DECODE_ID(hw) == (h264_debug_cmd & 0xff)) {
 		hw->dec_result = DEC_RESULT_DONE;
-		schedule_work(&hw->work);
+		vdec_schedule_work(&hw->work);
 		pr_info("vdec %d is forced to be disconnected\n",
 			h264_debug_cmd & 0xff);
 		h264_debug_cmd = 0;
 		return;
 	}
 
-	if (hw_to_vdec(hw)->next_status == VDEC_STATUS_DISCONNECTED) {
-		hw->dec_result = DEC_RESULT_DONE;
-		schedule_work(&hw->work);
+	if (vdec->next_status == VDEC_STATUS_DISCONNECTED) {
+		hw->dec_result = DEC_RESULT_FORCE_EXIT;
+		vdec_schedule_work(&hw->work);
 		pr_info("vdec requested to be disconnected\n");
 		return;
 	}
@@ -1836,7 +4017,7 @@ static void check_timer_func(unsigned long arg)
 		radr = 0;
 	}
 
-	if ((input_frame_based(hw_to_vdec(hw)) ||
+	if ((input_frame_based(vdec) ||
 		(READ_VREG(VLD_MEM_VIFIFO_LEVEL) > 0x200)) &&
 		((h264_debug_flag & DISABLE_ERROR_HANDLE) == 0) &&
 		(decode_timeout_val > 0) &&
@@ -1853,7 +4034,8 @@ static void check_timer_func(unsigned long arg)
 					hw->decode_timeout_count--;
 				if (hw->decode_timeout_count == 0)
 					timeout_process(hw);
-			}
+			} else
+				start_process_time(hw);
 		} else if (is_in_parsing_state(dpb_status)) {
 			if (hw->last_ucode_watchdog_reg_val ==
 				READ_VREG(UCODE_WATCHDOG_REG)) {
@@ -1868,35 +4050,43 @@ static void check_timer_func(unsigned long arg)
 		hw->last_mby_mbx = mby_mbx;
 	}
 
+	if ((hw->ucode_pause_pos != 0) &&
+		(hw->ucode_pause_pos != 0xffffffff) &&
+		udebug_pause_pos != hw->ucode_pause_pos) {
+		hw->ucode_pause_pos = 0;
+		WRITE_VREG(DEBUG_REG1, 0);
+	}
+
 	hw->check_timer.expires = jiffies + CHECK_INTERVAL;
 
 	add_timer(&hw->check_timer);
 }
 
-static int dec_status(struct vdec_s *vdec, struct vdec_status *vstatus)
+static int dec_status(struct vdec_s *vdec, struct vdec_info *vstatus)
 {
 	struct vdec_h264_hw_s *hw = (struct vdec_h264_hw_s *)vdec->private;
-	vstatus->width = hw->frame_width;
-	vstatus->height = hw->frame_height;
+	vstatus->frame_width = hw->frame_width;
+	vstatus->frame_height = hw->frame_height;
 	if (hw->frame_dur != 0)
-		vstatus->fps = 96000 / hw->frame_dur;
+		vstatus->frame_rate = 96000 / hw->frame_dur;
 	else
-		vstatus->fps = -1;
-	vstatus->error_count = READ_VREG(AV_SCRATCH_D);
+		vstatus->frame_rate = -1;
+	vstatus->error_count = 0;
 	vstatus->status = hw->stat;
-	/* if (fatal_error_reset)
-		vstatus->status |= hw->fatal_error_flag; */
+	snprintf(vstatus->vdec_name, sizeof(vstatus->vdec_name),
+		"%s-%02d", DRIVER_NAME, hw->id);
+
 	return 0;
 }
 
 static int vh264_hw_ctx_restore(struct vdec_h264_hw_s *hw)
 {
-	int i;
+	int i, j;
 
 	/* if (hw->init_flag == 0) { */
 	if (h264_debug_flag & 0x40000000) {
 		/* if (1) */
-		dpb_print(hw->dpb.decoder_index, PRINT_FLAG_VDEC_STATUS,
+		dpb_print(DECODE_ID(hw), PRINT_FLAG_VDEC_STATUS,
 		"%s, reset register\n", __func__);
 
 		while (READ_VREG(DCAC_DMA_CTRL) & 0x8000)
@@ -1923,13 +4113,13 @@ static int vh264_hw_ctx_restore(struct vdec_h264_hw_s *hw)
 		READ_VREG(DOS_SW_RESET0);
 
 #else
-		WRITE_MPEG_REG(RESET0_REGISTER,
+		WRITE_RESET_REG(RESET0_REGISTER,
 			RESET_IQIDCT | RESET_MC | RESET_VLD_PART);
-		READ_MPEG_REG(RESET0_REGISTER);
-			WRITE_MPEG_REG(RESET0_REGISTER,
+		READ_RESET_REG(RESET0_REGISTER);
+			WRITE_RESET_REG(RESET0_REGISTER,
 			RESET_IQIDCT | RESET_MC | RESET_VLD_PART);
 
-		WRITE_MPEG_REG(RESET2_REGISTER, RESET_PIC_DC | RESET_DBLK);
+		WRITE_RESET_REG(RESET2_REGISTER, RESET_PIC_DC | RESET_DBLK);
 #endif
 		WRITE_VREG(POWER_CTL_VLD,
 			READ_VREG(POWER_CTL_VLD) | (0 << 10) |
@@ -1958,27 +4148,19 @@ static int vh264_hw_ctx_restore(struct vdec_h264_hw_s *hw)
 	/* pr_info("vh264 meson8 prot init\n"); */
 	WRITE_VREG(MDEC_PIC_DC_THRESH, 0x404038aa);
 #endif
-	if (hw->decode_pic_count > 0) {
+	if (hw->dpb.mDPB.size > 0) {
 		WRITE_VREG(AV_SCRATCH_7, (hw->max_reference_size << 24) |
-			(hw->buffer_spec_num << 16) |
-			(hw->buffer_spec_num << 8));
-		for (i = 0; i < hw->buffer_spec_num; i++) {
-			canvas_config(hw->buffer_spec[i].y_canvas_index,
-				hw->buffer_spec[i].y_addr,
-				hw->mb_width << 4,
-				hw->mb_height << 4,
-				CANVAS_ADDR_NOWRAP,
-				CANVAS_BLKMODE_32X32);
-
-			canvas_config(hw->buffer_spec[i].u_canvas_index,
-				hw->buffer_spec[i].u_addr,
-				hw->mb_width << 4,
-				hw->mb_height << 3,
-				CANVAS_ADDR_NOWRAP,
-				CANVAS_BLKMODE_32X32);
-
-			WRITE_VREG(ANC0_CANVAS_ADDR + i,
-				spec2canvas(&hw->buffer_spec[i]));
+			(hw->dpb.mDPB.size << 16) |
+			(hw->dpb.mDPB.size << 8));
+
+		for (j = 0; j < hw->dpb.mDPB.size; j++) {
+			i = get_buf_spec_by_canvas_pos(hw, j);
+			if (i < 0)
+				break;
+
+			if (!mmu_enable &&
+				hw->buffer_spec[i].cma_alloc_addr)
+				config_decode_canvas(hw, i);
 		}
 	} else {
 		WRITE_VREG(AV_SCRATCH_0, 0);
@@ -2000,9 +4182,9 @@ static int vh264_hw_ctx_restore(struct vdec_h264_hw_s *hw)
 		(READ_VREG(AV_SCRATCH_F) & 0xffffffc3) ); */
 	WRITE_VREG(AV_SCRATCH_F, (READ_VREG(AV_SCRATCH_F) & 0xffffffc3) |
 		((error_recovery_mode_in & 0x1) << 4));
-	if (hw->ucode_type == UCODE_IP_ONLY_PARAM)
+	/*if (hw->ucode_type == UCODE_IP_ONLY_PARAM)
 		SET_VREG_MASK(AV_SCRATCH_F, 1 << 6);
-	else
+	else*/
 		CLEAR_VREG_MASK(AV_SCRATCH_F, 1 << 6);
 
 	WRITE_VREG(LMEM_DUMP_ADR, (u32)hw->lmem_addr_remap);
@@ -2015,6 +4197,19 @@ static int vh264_hw_ctx_restore(struct vdec_h264_hw_s *hw)
 	return 0;
 }
 
+static int vmh264_set_trickmode(struct vdec_s *vdec, unsigned long trickmode)
+{
+	struct vdec_h264_hw_s *hw =
+		(struct vdec_h264_hw_s *)vdec->private;
+	if (i_only_flag & 0x100)
+		return 0;
+	if (trickmode == TRICKMODE_I)
+		hw->i_only = 0x3;
+	else if (trickmode == TRICKMODE_NONE)
+		hw->i_only = 0x0;
+	return 0;
+}
+
 static unsigned char amvdec_enable_flag;
 static void vh264_local_init(struct vdec_h264_hw_s *hw)
 {
@@ -2050,16 +4245,18 @@ static void vh264_local_init(struct vdec_h264_hw_s *hw)
 	 hw->frame_width, hw->frame_height, hw->frame_dur, hw->pts_outside);
 	pr_info("sync_outside=%d, use_idr_framerate=%d\n",
 	 hw->sync_outside, hw->use_idr_framerate);
+	if (i_only_flag & 0x100)
+		hw->i_only = i_only_flag & 0xff;
 
-	if ((unsigned long) hw->vh264_amstream_dec_info.param & 0x08)
-		hw->ucode_type = UCODE_IP_ONLY_PARAM;
-	else
-		hw->ucode_type = 0;
+	if ((unsigned long) hw->vh264_amstream_dec_info.param
+		& 0x08)
+		hw->no_poc_reorder_flag = 1;
 
-	if ((unsigned long) hw->vh264_amstream_dec_info.param & 0x20)
-		error_recovery_mode_in = 1;
-	else
-		error_recovery_mode_in = 3;
+	error_recovery_mode_in = 1; /*ucode control?*/
+	if (error_proc_policy & 0x80000000)
+		hw->send_error_frame_flag = error_proc_policy & 0x1;
+	else if ((unsigned long) hw->vh264_amstream_dec_info.param & 0x20)
+		hw->send_error_frame_flag = 1;
 
 	INIT_KFIFO(hw->display_q);
 	INIT_KFIFO(hw->newframe_q);
@@ -2074,10 +4271,12 @@ static void vh264_local_init(struct vdec_h264_hw_s *hw)
 	hw->duration_from_pts_done = 0;
 
 	hw->p_last_vf = NULL;
-	hw->fatal_error_flag = 0;
 	hw->vh264_stream_switching_state = SWITCHING_STATE_OFF;
+	hw->hevc_cur_buf_idx = 0xffff;
 
 	INIT_WORK(&hw->work, vh264_work);
+	INIT_WORK(&hw->notify_work, vh264_notify_work);
+	INIT_WORK(&hw->user_data_work, user_data_push_work);
 
 	return;
 }
@@ -2088,8 +4287,10 @@ static s32 vh264_init(struct vdec_h264_hw_s *hw)
 	int firmwareloaded = 0;
 
 	hw->init_flag = 0;
-	hw->set_params_done = 0;
+	hw->eos = 0;
+	hw->config_bufmgr_done = 0;
 	hw->start_process_time = 0;
+	hw->has_i_frame = 0;
 
 	/* pr_info("\nvh264_init\n"); */
 	/* init_timer(&hw->recycle_timer); */
@@ -2103,16 +4304,29 @@ static s32 vh264_init(struct vdec_h264_hw_s *hw)
 
 	/* add_timer(&hw->check_timer); */
 	hw->stat |= STAT_TIMER_ARM;
+	hw->stat |= STAT_ISR_REG;
 
 	hw->duration_on_correcting = 0;
 	hw->fixed_frame_rate_check_count = 0;
 	hw->saved_resolution = 0;
 
 	vh264_local_init(hw);
-
 	if (!amvdec_enable_flag) {
 		amvdec_enable_flag = true;
 		amvdec_enable();
+		if (mmu_enable)
+			amhevc_enable();
+	}
+	if (mmu_enable) {
+
+		hw->frame_mmu_map_addr =
+				dma_alloc_coherent(amports_get_dma_device(),
+				FRAME_MMU_MAP_SIZE,
+				&hw->frame_mmu_map_phy_addr, GFP_KERNEL);
+		if (hw->frame_mmu_map_addr == NULL) {
+			pr_err("%s: failed to alloc count_buffer\n", __func__);
+			return -ENOMEM;
+		}
 	}
 
 	/* -- ucode loading (amrisc and swap code) */
@@ -2122,13 +4336,15 @@ static s32 vh264_init(struct vdec_h264_hw_s *hw)
 	if (!hw->mc_cpu_addr) {
 		amvdec_enable_flag = false;
 		amvdec_disable();
-
+		if (mmu_enable)
+			amhevc_disable();
 		pr_info("vh264_init: Can not allocate mc memory.\n");
 		return -ENOMEM;
 	}
 
-	pr_info("264 ucode swap area: phyaddr %p, cpu vaddr %p\n",
+	/*pr_info("264 ucode swap area: phyaddr %p, cpu vaddr %p\n",
 		(void *)hw->mc_dma_handle, hw->mc_cpu_addr);
+	*/
 	if (!firmwareloaded) {
 		int ret = 0, size = -1;
 		char *buf = vmalloc(0x1000 * 16);
@@ -2174,7 +4390,7 @@ static s32 vh264_init(struct vdec_h264_hw_s *hw)
 		vfree(buf);
 
 		if (ret < 0) {
-			dpb_print(hw->dpb.decoder_index, PRINT_FLAG_ERROR,
+			dpb_print(DECODE_ID(hw), PRINT_FLAG_ERROR,
 			"264 load orignal firmware error.\n");
 			amvdec_disable();
 			if (hw->mc_cpu_addr) {
@@ -2188,8 +4404,6 @@ static s32 vh264_init(struct vdec_h264_hw_s *hw)
 	}
 
 #if 1 /* #ifdef  BUFFER_MGR_IN_C */
-	dpb_init_global(&hw->dpb,
-		hw_to_vdec(hw)->id, 0, 0);
 	hw->lmem_addr = __get_free_page(GFP_KERNEL);
 	if (!hw->lmem_addr) {
 		pr_info("%s: failed to alloc lmem_addr\n", __func__);
@@ -2201,7 +4415,7 @@ static s32 vh264_init(struct vdec_h264_hw_s *hw)
 				PAGE_SIZE, DMA_FROM_DEVICE);
 		if (dma_mapping_error(amports_get_dma_device(),
 			hw->lmem_addr_remap)) {
-			dpb_print(hw->dpb.decoder_index, PRINT_FLAG_ERROR,
+			dpb_print(DECODE_ID(hw), PRINT_FLAG_ERROR,
 			"%s: failed to map lmem_addr\n", __func__);
 			free_page(hw->lmem_addr);
 			hw->lmem_addr = 0;
@@ -2212,19 +4426,64 @@ static s32 vh264_init(struct vdec_h264_hw_s *hw)
 		pr_info("%s, vaddr=%lx phy_addr=%p\n",
 			__func__, hw->lmem_addr, (void *)hw->lmem_addr_remap);
 	}
-	/* BUFFER_MGR_IN_C */
+
+	if (prefix_aux_buf_size > 0 ||
+		suffix_aux_buf_size > 0) {
+		u32 aux_buf_size;
+		hw->prefix_aux_size = AUX_BUF_ALIGN(prefix_aux_buf_size);
+		hw->suffix_aux_size = AUX_BUF_ALIGN(suffix_aux_buf_size);
+		aux_buf_size = hw->prefix_aux_size + hw->suffix_aux_size;
+		hw->aux_addr = kmalloc(aux_buf_size, GFP_KERNEL);
+		if (hw->aux_addr == NULL) {
+			pr_err("%s: failed to alloc rpm buffer\n", __func__);
+			return -1;
+		}
+
+		hw->aux_phy_addr = dma_map_single(amports_get_dma_device(),
+			hw->aux_addr, aux_buf_size, DMA_FROM_DEVICE);
+		if (dma_mapping_error(amports_get_dma_device(),
+			hw->aux_phy_addr)) {
+			pr_err("%s: failed to map rpm buffer\n", __func__);
+			kfree(hw->aux_addr);
+			hw->aux_addr = NULL;
+			return -1;
+		}
+		hw->sei_itu_data_buf = kmalloc(SEI_ITU_DATA_SIZE, GFP_KERNEL);
+		if (hw->sei_itu_data_buf == NULL) {
+			pr_err("%s: failed to alloc sei itu data buffer\n",
+				__func__);
+			return -1;
+		}
+
+		if (NULL == hw->sei_user_data_buffer) {
+			hw->sei_user_data_buffer = kmalloc(USER_DATA_SIZE,
+								GFP_KERNEL);
+			if (!hw->sei_user_data_buffer) {
+				pr_info("%s: Can not allocate sei_data_buffer\n",
+					   __func__);
+				return -1;
+			}
+			hw->sei_user_data_wp = 0;
+		}
+	}
+/* BUFFER_MGR_IN_C */
 #endif
 	hw->stat |= STAT_MC_LOAD;
-
+	if (mmu_enable) {
+		WRITE_VREG(HEVC_ASSIST_SCRATCH_0, 0x0);
+		amhevc_start();
+	}
 	/* add memory barrier */
 	wmb();
 
 	return 0;
 }
 
-static int vh264_stop(struct vdec_h264_hw_s *hw, int mode)
+static int vh264_stop(struct vdec_h264_hw_s *hw)
 {
-	int i;
+	cancel_work_sync(&hw->work);
+	cancel_work_sync(&hw->notify_work);
+	cancel_work_sync(&hw->user_data_work);
 
 	if (hw->stat & STAT_MC_LOAD) {
 		if (hw->mc_cpu_addr != NULL) {
@@ -2233,34 +4492,18 @@ static int vh264_stop(struct vdec_h264_hw_s *hw, int mode)
 					hw->mc_dma_handle);
 			hw->mc_cpu_addr = NULL;
 		}
-	}
-#ifdef USE_CMA
-	if (hw->cma_alloc_addr) {
-		pr_info("codec_mm release buffer 0x%lx\n", hw->cma_alloc_addr);
-		codec_mm_free_for_dma(MEM_NAME, hw->cma_alloc_addr);
-		 hw->cma_alloc_count = 0;
-	}
+		if (hw->frame_mmu_map_addr != NULL) {
+			dma_free_coherent(amports_get_dma_device(),
+				FRAME_MMU_MAP_SIZE, hw->frame_mmu_map_addr,
+					hw->frame_mmu_map_phy_addr);
+			hw->frame_mmu_map_addr = NULL;
+		}
 
-	if (hw->collocate_cma_alloc_addr) {
-		dpb_print(hw->dpb.decoder_index, PRINT_FLAG_ERROR,
-			"codec_mm release collocate buffer 0x%lx\n",
-			hw->collocate_cma_alloc_addr);
-		codec_mm_free_for_dma(MEM_NAME, hw->collocate_cma_alloc_addr);
-		hw->collocate_cma_alloc_count = 0;
 	}
-
-	for (i = 0; i < hw->buffer_spec_num; i++) {
-		if (hw->buffer_spec[i].cma_alloc_addr) {
-			pr_info("codec_mm release buffer_spec[%d], 0x%lx\n", i,
-				hw->buffer_spec[i].cma_alloc_addr);
-			codec_mm_free_for_dma(MEM_NAME,
-				hw->buffer_spec[i].cma_alloc_addr);
-			hw->buffer_spec[i].cma_alloc_count = 0;
-		}
+	if (hw->stat & STAT_ISR_REG) {
+		vdec_free_irq(VDEC_IRQ_1, (void *)hw);
+		hw->stat &= ~STAT_ISR_REG;
 	}
-
-#endif
-
 	if (hw->lmem_addr_remap) {
 		dma_unmap_single(amports_get_dma_device(),
 			hw->lmem_addr_remap,
@@ -2271,13 +4514,79 @@ static int vh264_stop(struct vdec_h264_hw_s *hw, int mode)
 		free_page(hw->lmem_addr);
 		hw->lmem_addr = 0;
 	}
-	cancel_work_sync(&hw->work);
-
+	if (hw->aux_addr) {
+		dma_unmap_single(amports_get_dma_device(),
+			hw->aux_phy_addr,
+			hw->prefix_aux_size + hw->suffix_aux_size,
+			DMA_FROM_DEVICE);
+		kfree(hw->aux_addr);
+		hw->aux_addr = NULL;
+	}
+	if (hw->sei_itu_data_buf != NULL) {
+		kfree(hw->sei_itu_data_buf);
+		hw->sei_itu_data_buf = NULL;
+	}
+	if (hw->sei_user_data_buffer != NULL) {
+		kfree(hw->sei_user_data_buffer);
+		hw->sei_user_data_buffer = NULL;
+	}
 	/* amvdec_disable(); */
 
+	dpb_print(DECODE_ID(hw), 0,
+		"%s\n",
+		__func__);
 	return 0;
 }
 
+static void vh264_notify_work(struct work_struct *work)
+{
+	struct vdec_h264_hw_s *hw = container_of(work,
+					struct vdec_h264_hw_s, notify_work);
+	struct vdec_s *vdec = hw_to_vdec(hw);
+	if (vdec->fr_hint_state == VDEC_NEED_HINT) {
+		vf_notify_receiver(vdec->vf_provider_name,
+				VFRAME_EVENT_PROVIDER_FR_HINT,
+				(void *)((unsigned long)hw->frame_dur));
+		vdec->fr_hint_state = VDEC_HINTED;
+	}
+
+	return;
+}
+
+static void user_data_push_work(struct work_struct *work)
+{
+	struct vdec_h264_hw_s *hw = container_of(work,
+		struct vdec_h264_hw_s, user_data_work);
+
+	struct userdata_poc_info_t user_data_poc;
+	unsigned char *pdata;
+	u8 *pmax_sei_data_buffer;
+	u8 *sei_data_buf;
+	int i;
+
+	pdata = (u8 *)hw->sei_user_data_buffer + hw->sei_user_data_wp;
+	pmax_sei_data_buffer = (u8 *)hw->sei_user_data_buffer + USER_DATA_SIZE;
+	sei_data_buf = (u8 *)hw->sei_itu_data_buf;
+	for (i = 0; i < hw->sei_itu_data_len; i++) {
+		*pdata++ = sei_data_buf[i];
+		if (pdata >= pmax_sei_data_buffer)
+			pdata = (u8 *)hw->sei_user_data_buffer;
+	}
+
+	hw->sei_user_data_wp = (hw->sei_user_data_wp
+		+ hw->sei_itu_data_len) % USER_DATA_SIZE;
+	user_data_poc.poc_number = hw->sei_poc;
+
+	wakeup_userdata_poll(user_data_poc, hw->sei_user_data_wp,
+					(unsigned long)hw->sei_user_data_buffer,
+					USER_DATA_SIZE, hw->sei_itu_data_len);
+	hw->sei_itu_data_len = 0;
+/*
+	pr_info("sei_itu35_wp = %d, poc = %d\n",
+		hw->sei_user_data_wp, hw->sei_poc);
+*/
+}
+
 static void vh264_work(struct work_struct *work)
 {
 	struct vdec_h264_hw_s *hw = container_of(work,
@@ -2287,24 +4596,36 @@ static void vh264_work(struct work_struct *work)
 	/* finished decoding one frame or error,
 	 * notify vdec core to switch context
 	 */
-	dpb_print(hw->dpb.decoder_index, PRINT_FLAG_VDEC_DETAIL,
-		"%s  %x %x %x\n", __func__,
-		READ_VREG(0xc47), READ_VREG(0xc45), READ_VREG(0xc46));
-
-#ifdef USE_CMA
-	if (hw->dec_result == DEC_RESULT_CONFIG_PARAM) {
-		if (vh264_set_params(hw) < 0) {
-			hw->fatal_error_flag = DECODER_FATAL_ERROR_UNKNOWN;
-			if (!hw->fatal_error_reset)
-				schedule_work(&hw->error_wd_work);
+	dpb_print(DECODE_ID(hw), PRINT_FLAG_VDEC_DETAIL,
+		"%s dec_result %d %x %x %x\n",
+		__func__,
+		hw->dec_result,
+		READ_VREG(VLD_MEM_VIFIFO_LEVEL),
+		READ_VREG(VLD_MEM_VIFIFO_WP),
+		READ_VREG(VLD_MEM_VIFIFO_RP));
+		if (!mmu_enable) {
+			mutex_lock(&vmh264_mutex);
+			dealloc_buf_specs(hw);
+			mutex_unlock(&vmh264_mutex);
 		}
+	if (hw->dec_result == DEC_RESULT_CONFIG_PARAM) {
+		if (vh264_set_params(hw) < 0)
+			hw->stat |= DECODER_FATAL_ERROR_SIZE_OVERFLOW;
+		start_process_time(hw);
 		return;
 	} else
-#endif
-	if ((hw->dec_result == DEC_RESULT_GET_DATA) ||
-		(hw->dec_result == DEC_RESULT_GET_DATA_RETRY)) {
+	if (((hw->dec_result == DEC_RESULT_GET_DATA) ||
+		(hw->dec_result == DEC_RESULT_GET_DATA_RETRY))
+		&& (hw_to_vdec(hw)->next_status !=
+		VDEC_STATUS_DISCONNECTED)) {
+		if (!vdec_has_more_input(vdec)) {
+			hw->dec_result = DEC_RESULT_EOS;
+			vdec_schedule_work(&hw->work);
+			return;
+		}
+
 		if (hw->dec_result == DEC_RESULT_GET_DATA) {
-			dpb_print(hw->dpb.decoder_index, PRINT_FLAG_VDEC_STATUS,
+			dpb_print(DECODE_ID(hw), PRINT_FLAG_VDEC_STATUS,
 				"%s DEC_RESULT_GET_DATA %x %x %x\n",
 				__func__,
 				READ_VREG(VLD_MEM_VIFIFO_LEVEL),
@@ -2313,46 +4634,76 @@ static void vh264_work(struct work_struct *work)
 			vdec_vframe_dirty(vdec, hw->chunk);
 			vdec_clean_input(vdec);
 		}
-
+		if ((hw->dec_result == DEC_RESULT_GET_DATA_RETRY) &&
+			((1000 * (jiffies - hw->get_data_start_time) / HZ)
+			> get_data_timeout_val)) {
+			dpb_print(DECODE_ID(hw), PRINT_FLAG_VDEC_STATUS,
+				"%s DEC_RESULT_GET_DATA_RETRY timeout\n",
+				__func__);
+			goto result_done;
+		}
 		if (is_buffer_available(vdec)) {
 			int r;
+			int decode_size;
 			r = vdec_prepare_input(vdec, &hw->chunk);
 			if (r < 0) {
 				hw->dec_result = DEC_RESULT_GET_DATA_RETRY;
 
-				dpb_print(hw->dpb.decoder_index,
+				dpb_print(DECODE_ID(hw),
 					PRINT_FLAG_VDEC_DETAIL,
-					"ammvdec_vh264: Insufficient data\n");
+					"vdec_prepare_input: Insufficient data\n");
 
-				schedule_work(&hw->work);
+				vdec_schedule_work(&hw->work);
 				return;
 			}
 			hw->dec_result = DEC_RESULT_NONE;
-			dpb_print(hw->dpb.decoder_index, PRINT_FLAG_VDEC_STATUS,
+			dpb_print(DECODE_ID(hw), PRINT_FLAG_VDEC_STATUS,
 				"%s: chunk size 0x%x\n",
 				__func__, hw->chunk->size);
+
+			if (dpb_is_debug(DECODE_ID(hw),
+				PRINT_FRAMEBASE_DATA)) {
+				int jj;
+				u8 *data =
+				((u8 *)hw->chunk->block->start_virt) +
+					hw->chunk->offset;
+				for (jj = 0; jj < r; jj++) {
+					if ((jj & 0xf) == 0)
+						dpb_print(DECODE_ID(hw),
+						PRINT_FRAMEBASE_DATA,
+							"%06x:", jj);
+					dpb_print_cont(DECODE_ID(hw),
+					PRINT_FRAMEBASE_DATA,
+						"%02x ", data[jj]);
+					if (((jj + 1) & 0xf) == 0)
+						dpb_print_cont(DECODE_ID(hw),
+						PRINT_FRAMEBASE_DATA,
+							"\n");
+				}
+			}
 			WRITE_VREG(POWER_CTL_VLD,
 				READ_VREG(POWER_CTL_VLD) |
 					(0 << 10) | (1 << 9) | (1 << 6));
 			WRITE_VREG(H264_DECODE_INFO, (1<<13));
-			WRITE_VREG(H264_DECODE_SIZE, hw->chunk->size);
-			WRITE_VREG(VIFF_BIT_CNT, (hw->chunk->size * 8));
+			decode_size = hw->chunk->size +
+				(hw->chunk->offset & (VDEC_FIFO_ALIGN - 1));
+			WRITE_VREG(H264_DECODE_SIZE, decode_size);
+			WRITE_VREG(VIFF_BIT_CNT, decode_size * 8);
 			vdec_enable_input(vdec);
 
 			WRITE_VREG(DPB_STATUS_REG, H264_ACTION_SEARCH_HEAD);
+			start_process_time(hw);
 		} else{
 			hw->dec_result = DEC_RESULT_GET_DATA_RETRY;
-
-			dpb_print(hw->dpb.decoder_index, PRINT_FLAG_VDEC_DETAIL,
-				"ammvdec_vh264: Insufficient data\n");
-
-			schedule_work(&hw->work);
+			vdec_schedule_work(&hw->work);
 		}
 		return;
 	} else if (hw->dec_result == DEC_RESULT_DONE) {
 		/* if (!hw->ctx_valid)
 			hw->ctx_valid = 1; */
-		dpb_print(hw->dpb.decoder_index, PRINT_FLAG_VDEC_STATUS,
+result_done:
+		decode_frame_count[DECODE_ID(hw)]++;
+		dpb_print(DECODE_ID(hw), PRINT_FLAG_VDEC_STATUS,
 			"%s dec_result %d %x %x %x\n",
 			__func__,
 			hw->dec_result,
@@ -2360,14 +4711,35 @@ static void vh264_work(struct work_struct *work)
 			READ_VREG(VLD_MEM_VIFIFO_WP),
 			READ_VREG(VLD_MEM_VIFIFO_RP));
 		vdec_vframe_dirty(hw_to_vdec(hw), hw->chunk);
-	} else {
-		dpb_print(hw->dpb.decoder_index, PRINT_FLAG_VDEC_DETAIL,
-			"%s dec_result %d %x %x %x\n",
-			__func__,
-			hw->dec_result,
-			READ_VREG(VLD_MEM_VIFIFO_LEVEL),
-			READ_VREG(VLD_MEM_VIFIFO_WP),
-			READ_VREG(VLD_MEM_VIFIFO_RP));
+	} else if (hw->dec_result == DEC_RESULT_AGAIN) {
+		/*
+			stream base: stream buf empty or timeout
+			frame base: vdec_prepare_input fail
+		*/
+		if (!vdec_has_more_input(vdec)) {
+			hw->dec_result = DEC_RESULT_EOS;
+			vdec_schedule_work(&hw->work);
+			return;
+		}
+
+	} else if (hw->dec_result == DEC_RESULT_EOS) {
+		struct h264_dpb_stru *p_H264_Dpb = &hw->dpb;
+		dpb_print(DECODE_ID(hw), PRINT_FLAG_VDEC_STATUS,
+			"%s: end of stream\n",
+			__func__);
+
+		hw->eos = 1;
+		flush_dpb(p_H264_Dpb);
+		vdec_vframe_dirty(hw_to_vdec(hw), hw->chunk);
+	} else if (hw->dec_result == DEC_RESULT_FORCE_EXIT) {
+		dpb_print(DECODE_ID(hw), PRINT_FLAG_VDEC_STATUS,
+			"%s: force exit\n",
+			__func__);
+		amvdec_stop();
+		if (hw->stat & STAT_ISR_REG) {
+			vdec_free_irq(VDEC_IRQ_1, (void *)hw);
+			hw->stat &= ~STAT_ISR_REG;
+		}
 	}
 
 	del_timer_sync(&hw->check_timer);
@@ -2376,47 +4748,56 @@ static void vh264_work(struct work_struct *work)
 	/* mark itself has all HW resource released and input released */
 	vdec_set_status(hw_to_vdec(hw), VDEC_STATUS_CONNECTED);
 
+#ifdef CONFIG_AM_VDEC_DV
+	if (hw->switch_dvlayer_flag) {
+		if (vdec->slave)
+			vdec_set_next_sched(vdec, vdec->slave);
+		else if (vdec->master)
+			vdec_set_next_sched(vdec, vdec->master);
+	} else if (vdec->slave || vdec->master)
+		vdec_set_next_sched(vdec, vdec);
+#endif
+
 	if (hw->vdec_cb)
 		hw->vdec_cb(hw_to_vdec(hw), hw->vdec_cb_arg);
 }
 
 static bool run_ready(struct vdec_s *vdec)
 {
+	bool ret = 0;
+	struct vdec_h264_hw_s *hw =
+		(struct vdec_h264_hw_s *)vdec->private;
+
+#ifndef CONFIG_AM_VDEC_DV
 	if (vdec->master)
 		return false;
-
-	if ((!input_frame_based(vdec)) && (start_decode_buf_level > 0)) {
-		u32 rp, wp;
-		u32 level;
-
-		rp = READ_MPEG_REG(PARSER_VIDEO_RP);
-		wp = READ_MPEG_REG(PARSER_VIDEO_WP);
-
-		if (wp < rp)
-			level = vdec->input.size + wp - rp;
-		else
-			level = wp - rp;
-
-		if (level < start_decode_buf_level) {
-			struct vdec_h264_hw_s *hw =
-				(struct vdec_h264_hw_s *)vdec->private;
-			dpb_print(hw->dpb.decoder_index, PRINT_FLAG_VDEC_DETAIL,
-				"%s vififo level low %x(<%x) (lev%x wp%x rp%x)\n",
-				__func__, level,
-				start_decode_buf_level,
-				READ_VREG(VLD_MEM_VIFIFO_LEVEL),
-				READ_VREG(VLD_MEM_VIFIFO_WP),
-				READ_VREG(VLD_MEM_VIFIFO_RP));
-			return 0;
-		}
-	}
+#endif
+	if (hw->eos)
+		return 0;
 
 	if (h264_debug_flag & 0x20000000) {
 		/* pr_info("%s, a\n", __func__); */
-		return 1;
-	} else {
-		return is_buffer_available(vdec);
-	}
+		ret = 1;
+	} else
+		ret = is_buffer_available(vdec);
+
+	if (ret)
+		not_run_ready[DECODE_ID(hw)] = 0;
+	else
+		not_run_ready[DECODE_ID(hw)]++;
+	return ret;
+}
+
+static unsigned char get_data_check_sum
+	(struct vdec_h264_hw_s *hw, int size)
+{
+	int jj;
+	int sum = 0;
+	u8 *data = ((u8 *)hw->chunk->block->start_virt) +
+		hw->chunk->offset;
+	for (jj = 0; jj < size; jj++)
+		sum += data[jj];
+	return sum;
 }
 
 static void run(struct vdec_s *vdec,
@@ -2425,159 +4806,341 @@ static void run(struct vdec_s *vdec,
 	struct vdec_h264_hw_s *hw =
 		(struct vdec_h264_hw_s *)vdec->private;
 	int size;
+	run_count[DECODE_ID(hw)]++;
 
 	hw->vdec_cb_arg = arg;
 	hw->vdec_cb = callback;
 
+	if (h264_debug_cmd & 0xf000) {
+		h264_reconfig(hw);
+		h264_debug_cmd &= (~0xf000);
+	}
 	/* hw->chunk = vdec_prepare_input(vdec); */
+#ifdef CONFIG_AM_VDEC_DV
+	if (vdec->slave || vdec->master)
+		vdec_set_flag(vdec, VDEC_FLAG_SELF_INPUT_CONTEXT);
+#endif
 	size = vdec_prepare_input(vdec, &hw->chunk);
 	if ((size < 0) ||
 		(input_frame_based(vdec) && hw->chunk == NULL)) {
+		input_empty[DECODE_ID(hw)]++;
 		hw->dec_result = DEC_RESULT_AGAIN;
 
-		dpb_print(hw->dpb.decoder_index, PRINT_FLAG_VDEC_DETAIL,
-			"ammvdec_vh264: Insufficient data\n");
+		dpb_print(DECODE_ID(hw), PRINT_FLAG_VDEC_DETAIL,
+			"vdec_prepare_input: Insufficient data\n");
 
-		schedule_work(&hw->work);
+		vdec_schedule_work(&hw->work);
 		return;
 	}
+	input_empty[DECODE_ID(hw)] = 0;
 
 	hw->dec_result = DEC_RESULT_NONE;
+	hw->get_data_count = 0;
 #if 0
-	if ((!input_frame_based(vdec)) && (start_decode_buf_level > 0)) {
-		if (READ_VREG(VLD_MEM_VIFIFO_LEVEL) <
-			start_decode_buf_level) {
-			dpb_print(hw->dpb.decoder_index,
-				PRINT_FLAG_VDEC_DETAIL,
-				"%s: VIFIFO_LEVEL %x is low (<%x)\n",
-				__func__,
-				READ_VREG(VLD_MEM_VIFIFO_LEVEL),
-				start_decode_buf_level);
-
-			hw->dec_result = DEC_RESULT_AGAIN;
-			schedule_work(&hw->work);
-			return;
-		}
-	}
+	pr_info("VLD_MEM_VIFIFO_LEVEL = 0x%x, rp = 0x%x, wp = 0x%x\n",
+		READ_VREG(VLD_MEM_VIFIFO_LEVEL),
+		READ_VREG(VLD_MEM_VIFIFO_RP),
+		READ_VREG(VLD_MEM_VIFIFO_WP));
 #endif
 
 	if (input_frame_based(vdec)) {
 		u8 *data = ((u8 *)hw->chunk->block->start_virt) +
 			hw->chunk->offset;
-
-		dpb_print(hw->dpb.decoder_index, PRINT_FLAG_VDEC_STATUS,
-			"%s: size 0x%x %02x %02x %02x %02x %02x %02x .. %02x %02x %02x %02x\n",
-			__func__, size,
+		if (dpb_is_debug(DECODE_ID(hw),
+			PRINT_FLAG_VDEC_STATUS)
+			) {
+			dpb_print(DECODE_ID(hw), 0,
+			"%s: size 0x%x sum 0x%x %02x %02x %02x %02x %02x %02x .. %02x %02x %02x %02x\n",
+			__func__, size, get_data_check_sum(hw, size),
 			data[0], data[1], data[2], data[3],
 			data[4], data[5], data[size - 4],
 			data[size - 3],	data[size - 2],
 			data[size - 1]);
+		}
+		if (dpb_is_debug(DECODE_ID(hw),
+			PRINT_FRAMEBASE_DATA)
+			) {
+			int jj;
+			u8 *data =
+			((u8 *)hw->chunk->block->start_virt) +
+				hw->chunk->offset;
+			for (jj = 0; jj < size; jj++) {
+				if ((jj & 0xf) == 0)
+					dpb_print(DECODE_ID(hw),
+					PRINT_FRAMEBASE_DATA,
+						"%06x:", jj);
+				dpb_print_cont(DECODE_ID(hw),
+				PRINT_FRAMEBASE_DATA,
+					"%02x ", data[jj]);
+				if (((jj + 1) & 0xf) == 0)
+					dpb_print_cont(DECODE_ID(hw),
+					PRINT_FRAMEBASE_DATA,
+						"\n");
+			}
+		}
+
 	} else
-		dpb_print(hw->dpb.decoder_index, PRINT_FLAG_VDEC_STATUS,
-			"%s: %x %x %x size 0x%x\n",
+		dpb_print(DECODE_ID(hw), PRINT_FLAG_VDEC_STATUS,
+			"%s: %x %x %x %x %x size 0x%x\n",
 			__func__,
 			READ_VREG(VLD_MEM_VIFIFO_LEVEL),
 			READ_VREG(VLD_MEM_VIFIFO_WP),
-			READ_VREG(VLD_MEM_VIFIFO_RP), size);
+			READ_VREG(VLD_MEM_VIFIFO_RP),
+			READ_PARSER_REG(PARSER_VIDEO_RP),
+			READ_PARSER_REG(PARSER_VIDEO_WP),
+			size);
 
-	hw->start_process_time = jiffies;
+	start_process_time(hw);
 
-	if (((h264_debug_flag & ONLY_RESET_AT_START) == 0) ||
-		(hw->init_flag == 0)) {
-		if (amvdec_vdec_loadmc_ex(vdec, "vmh264_mc") < 0) {
-			amvdec_enable_flag = false;
-			amvdec_disable();
-			pr_info("%s: Error amvdec_vdec_loadmc fail\n",
-				__func__);
-			return;
-		}
+	if (amvdec_vdec_loadmc_ex(vdec, "vmh264_mc") < 0) {
+		amvdec_enable_flag = false;
+		amvdec_disable();
+			if (mmu_enable)
+				amhevc_disable();
+		pr_info("%s: Error amvdec_vdec_loadmc fail\n",
+			__func__);
+		return;
+	}
 
-		if (vh264_hw_ctx_restore(hw) < 0) {
-			schedule_work(&hw->work);
-			return;
-		}
-		if (input_frame_based(vdec)) {
-			WRITE_VREG(H264_DECODE_INFO, (1<<13));
-			WRITE_VREG(H264_DECODE_SIZE, hw->chunk->size);
-			WRITE_VREG(VIFF_BIT_CNT, (hw->chunk->size * 8));
-		} else {
-			if (size <= 0)
-				size = 0x7fffffff; /*error happen*/
-			WRITE_VREG(H264_DECODE_INFO, (1<<13));
-			WRITE_VREG(H264_DECODE_SIZE, size);
-			WRITE_VREG(VIFF_BIT_CNT, size * 8);
-		}
+	if (vh264_hw_ctx_restore(hw) < 0) {
+		vdec_schedule_work(&hw->work);
+		return;
+	}
+	if (input_frame_based(vdec)) {
+		int decode_size = hw->chunk->size +
+			(hw->chunk->offset & (VDEC_FIFO_ALIGN - 1));
+		WRITE_VREG(H264_DECODE_INFO, (1<<13));
+		WRITE_VREG(H264_DECODE_SIZE, decode_size);
+		WRITE_VREG(VIFF_BIT_CNT, decode_size * 8);
+	} else {
+		if (size <= 0)
+			size = 0x7fffffff; /*error happen*/
+		WRITE_VREG(H264_DECODE_INFO, (1<<13));
+		WRITE_VREG(H264_DECODE_SIZE, size);
+		WRITE_VREG(VIFF_BIT_CNT, size * 8);
+	}
+	config_aux_buf(hw);
+	config_decode_mode(hw);
+	vdec_enable_input(vdec);
+	WRITE_VREG(NAL_SEARCH_CTL, 0);
+	if (enable_itu_t35)
+		WRITE_VREG(NAL_SEARCH_CTL, READ_VREG(NAL_SEARCH_CTL) | 0x1);
+	if (mmu_enable)
+		WRITE_VREG(NAL_SEARCH_CTL, READ_VREG(NAL_SEARCH_CTL) | 0x2);
+	if (udebug_flag)
+		WRITE_VREG(AV_SCRATCH_K, udebug_flag);
+	add_timer(&hw->check_timer);
 
-		vdec_enable_input(vdec);
+	amvdec_start();
 
-		add_timer(&hw->check_timer);
+	/* if (hw->init_flag) { */
+		WRITE_VREG(DPB_STATUS_REG, H264_ACTION_SEARCH_HEAD);
+	/* } */
 
-		amvdec_start();
+	hw->init_flag = 1;
+}
 
-		/* if (hw->init_flag) { */
-			WRITE_VREG(DPB_STATUS_REG, H264_ACTION_SEARCH_HEAD);
-		/* } */
+static void reset(struct vdec_s *vdec)
+{
+	pr_info("ammvdec_h264: reset.\n");
+}
 
-		hw->init_flag = 1;
-	} else {
-		WRITE_VREG(H264_DECODE_INFO, (1 << 13));
-		vdec_enable_input(vdec);
+static void h264_reconfig(struct vdec_h264_hw_s *hw)
+{
+	int i;
+	unsigned long flags;
+	struct h264_dpb_stru *p_H264_Dpb = &hw->dpb;
+	dpb_print(DECODE_ID(hw), 0,
+	"%s\n", __func__);
+	/* after calling flush_dpb() and bufmgr_h264_remove_unused_frame(),
+		all buffers are in display queue (used == 2),
+			or free (used == 0)
+	*/
+	flush_dpb(p_H264_Dpb);
+	bufmgr_h264_remove_unused_frame(p_H264_Dpb, 0);
 
-		WRITE_VREG(DPB_STATUS_REG, H264_ACTION_SEARCH_HEAD);
+	if (hw->collocate_cma_alloc_addr) {
+		decoder_bmmu_box_free_idx(
+			hw->bmmu_box,
+			BMMU_REF_IDX);
+		hw->collocate_cma_alloc_addr = 0;
+		hw->dpb.colocated_mv_addr_start = 0;
+		hw->dpb.colocated_mv_addr_end = 0;
 	}
+	spin_lock_irqsave(&hw->bufspec_lock, flags);
+	for (i = 0; i < BUFSPEC_POOL_SIZE; i++) {
+		/*make sure buffers not put back to bufmgr when
+			vf_put is called*/
+		if (hw->buffer_spec[i].used == 2)
+			hw->buffer_spec[i].used = 3;
+
+		/* ready to release "free buffers"
+		*/
+		if (hw->buffer_spec[i].used == 0)
+			hw->buffer_spec[i].used = 4;
+
+		hw->buffer_spec[i].canvas_pos = -1;
+	}
+	spin_unlock_irqrestore(&hw->bufspec_lock, flags);
+	hw->has_i_frame = 0;
+	hw->config_bufmgr_done = 0;
+
 }
 
-static void reset(struct vdec_s *vdec)
+static void h264_reset_bufmgr(struct vdec_h264_hw_s *hw)
 {
-	pr_info("ammvdec_h264: reset.\n");
+	int i;
+	struct h264_dpb_stru *p_H264_Dpb = &hw->dpb;
+	int actual_dpb_size, max_reference_size;
+	int reorder_pic_num;
+	unsigned int colocated_buf_size;
+	unsigned int colocated_mv_addr_start;
+	unsigned int colocated_mv_addr_end;
+	dpb_print(DECODE_ID(hw), 0,
+	"%s\n", __func__);
+	/* after calling flush_dpb() and bufmgr_h264_remove_unused_frame(),
+		all buffers are in display queue (used == 2),
+			or free (used == 0)
+	*/
+	flush_dpb(p_H264_Dpb);
+	bufmgr_h264_remove_unused_frame(p_H264_Dpb, 0);
 
-#if 0
-	struct vdec_h264_hw_s *hw = (struct vdec_h264_hw_s *)vdec->private;
+	for (i = 0; i < BUFSPEC_POOL_SIZE; i++) {
+		/*make sure buffers not put back to bufmgr when
+			vf_put is called*/
+		if (hw->buffer_spec[i].used == 2)
+			hw->buffer_spec[i].used = 5;
+	}
 
-	hw->init_flag = 0;
-	hw->set_params_done = 0;
+	actual_dpb_size = p_H264_Dpb->mDPB.size;
+	max_reference_size = p_H264_Dpb->max_reference_size;
+	reorder_pic_num = p_H264_Dpb->reorder_pic_num;
 
-	vh264_local_init(hw);
+	colocated_buf_size = p_H264_Dpb->colocated_buf_size;
+	colocated_mv_addr_start = p_H264_Dpb->colocated_mv_addr_start;
+	colocated_mv_addr_end  = p_H264_Dpb->colocated_mv_addr_end;
 
-	dpb_init_global(&hw->dpb);
-#endif
+	dpb_init_global(&hw->dpb,
+		DECODE_ID(hw), 0, 0);
+	p_H264_Dpb->mDPB.size = actual_dpb_size;
+	p_H264_Dpb->max_reference_size = max_reference_size;
+	p_H264_Dpb->reorder_pic_num = reorder_pic_num;
+
+	p_H264_Dpb->colocated_buf_size = colocated_buf_size;
+	p_H264_Dpb->colocated_mv_addr_start = colocated_mv_addr_start;
+	p_H264_Dpb->colocated_mv_addr_end  = colocated_mv_addr_end;
+
+	p_H264_Dpb->fast_output_enable = fast_output_enable;
+}
+
+int ammvdec_h264_mmu_init(struct vdec_h264_hw_s *hw)
+{
+	int ret = -1;
+	int tvp_flag = vdec_secure(hw_to_vdec(hw)) ?
+		CODEC_MM_FLAGS_TVP : 0;
+
+	pr_info("ammvdec_h264_mmu_init tvp = 0x%x mmu_enable %d\n",
+			tvp_flag, mmu_enable);
+	if (mmu_enable && !hw->mmu_box) {
+		hw->mmu_box = decoder_mmu_box_alloc_box(DRIVER_NAME,
+				hw->id,
+				MMU_MAX_BUFFERS,
+				64 * SZ_1M,
+				tvp_flag);
+		if (!hw->mmu_box) {
+			pr_err("h264 4k alloc mmu box failed!!\n");
+			return -1;
+		}
+		ret = 0;
+	}
+	if (!hw->bmmu_box) {
+		hw->bmmu_box = decoder_bmmu_box_alloc_box(
+			DRIVER_NAME,
+			hw->id,
+			BMMU_MAX_BUFFERS,
+			4 + PAGE_SHIFT,
+			CODEC_MM_FLAGS_CMA_CLEAR |
+			CODEC_MM_FLAGS_FOR_VDECODER |
+			tvp_flag);
+		if (hw->bmmu_box)
+			ret = 0;
+	}
+	return ret;
+}
+int ammvdec_h264_mmu_release(struct vdec_h264_hw_s *hw)
+{
+	if (hw->mmu_box) {
+		decoder_mmu_box_free(hw->mmu_box);
+		hw->mmu_box = NULL;
+	}
+	if (hw->bmmu_box) {
+		decoder_bmmu_box_free(hw->bmmu_box);
+		hw->bmmu_box = NULL;
+	}
+	return 0;
 }
 
 static int ammvdec_h264_probe(struct platform_device *pdev)
 {
 	struct vdec_s *pdata = *(struct vdec_s **)pdev->dev.platform_data;
 	struct vdec_h264_hw_s *hw = NULL;
+	char *tmpbuf;
 
 	if (pdata == NULL) {
 		pr_info("\nammvdec_h264 memory resource undefined.\n");
 		return -EFAULT;
 	}
 
-	hw = (struct vdec_h264_hw_s *)devm_kzalloc(&pdev->dev,
+	hw = (struct vdec_h264_hw_s *)h264_alloc_hw_stru(&pdev->dev,
 		sizeof(struct vdec_h264_hw_s), GFP_KERNEL);
 	if (hw == NULL) {
 		pr_info("\nammvdec_h264 device data allocation failed\n");
 		return -ENOMEM;
 	}
+	hw->id = pdev->id;
+	hw->platform_dev = pdev;
+	platform_set_drvdata(pdev, pdata);
 
+	mmu_enable = 0;
+	if (force_enable_mmu && pdata->sys_info &&
+		    (get_cpu_type() >= MESON_CPU_MAJOR_ID_TXLX) &&
+			(pdata->sys_info->height * pdata->sys_info->width
+			> 1920 * 1088))
+			mmu_enable = 1;
+	if (ammvdec_h264_mmu_init(hw)) {
+		h264_free_hw_stru(&pdev->dev, (void *)hw);
+		pr_info("\nammvdec_h264 mmu alloc failed!\n");
+		return -ENOMEM;
+	}
 	pdata->private = hw;
 	pdata->dec_status = dec_status;
-	/* pdata->set_trickmode = set_trickmode; */
+	pdata->set_trickmode = vmh264_set_trickmode;
 	pdata->run_ready = run_ready;
 	pdata->run = run;
 	pdata->reset = reset;
 	pdata->irq_handler = vh264_isr;
+	pdata->threaded_irq_handler = vh264_isr_thread_fn;
+	pdata->dump_state = vmh264_dump_state;
 
-	pdata->id = pdev->id;
 
 	if (pdata->use_vfm_path)
 		snprintf(pdata->vf_provider_name, VDEC_PROVIDER_NAME_SIZE,
 			VFM_DEC_PROVIDER_NAME);
+#ifdef CONFIG_AM_VDEC_DV
 	else if (vdec_dual(pdata)) {
-		snprintf(pdata->vf_provider_name, VDEC_PROVIDER_NAME_SIZE,
-			(pdata->master) ? VFM_DEC_DVEL_PROVIDER_NAME :
-			VFM_DEC_DVBL_PROVIDER_NAME);
-	} else
+		if (dv_toggle_prov_name) /*debug purpose*/
+			snprintf(pdata->vf_provider_name,
+			VDEC_PROVIDER_NAME_SIZE,
+				(pdata->master) ? VFM_DEC_DVBL_PROVIDER_NAME :
+				VFM_DEC_DVEL_PROVIDER_NAME);
+		else
+			snprintf(pdata->vf_provider_name,
+			VDEC_PROVIDER_NAME_SIZE,
+				(pdata->master) ? VFM_DEC_DVEL_PROVIDER_NAME :
+				VFM_DEC_DVBL_PROVIDER_NAME);
+	}
+#endif
+	else
 		snprintf(pdata->vf_provider_name, VDEC_PROVIDER_NAME_SIZE,
 			PROVIDER_NAME ".%02x", pdev->id & 0xff);
 
@@ -2586,40 +5149,49 @@ static int ammvdec_h264_probe(struct platform_device *pdev)
 
 	platform_set_drvdata(pdev, pdata);
 
+	buf_spec_init(hw);
+
 	hw->platform_dev = pdev;
-#ifndef USE_CMA
-	hw->buf_start = pdata->mem_start;
-	hw->buf_size = pdata->mem_end - pdata->mem_start + 1;
-	/* hw->ucode_map_start = pdata->mem_start; */
-	if (hw->buf_size < DEFAULT_MEM_SIZE) {
-		pr_info("\nammvdec_h264 memory size not enough.\n");
-		return -ENOMEM;
-	}
-#endif
 
-#ifdef USE_CMA
-	hw->cma_dev = pdata->cma_dev;
-	if (hw->cma_alloc_count == 0) {
-		hw->cma_alloc_count = PAGE_ALIGN(V_BUF_ADDR_OFFSET) / PAGE_SIZE;
-		hw->cma_alloc_addr = codec_mm_alloc_for_dma(MEM_NAME,
-					hw->cma_alloc_count,
-					4, CODEC_MM_FLAGS_FOR_VDECODER);
-	}
-	if (!hw->cma_alloc_addr) {
-		dpb_print(hw->dpb.decoder_index, PRINT_FLAG_ERROR,
-			"codec_mm alloc failed, request buf size 0x%lx\n",
-				hw->cma_alloc_count * PAGE_SIZE);
-		hw->cma_alloc_count = 0;
+
+	if (decoder_bmmu_box_alloc_buf_phy(hw->bmmu_box, BMMU_DPB_IDX,
+		V_BUF_ADDR_OFFSET, DRIVER_NAME, &hw->cma_alloc_addr) < 0) {
+		h264_free_hw_stru(&pdev->dev, (void *)hw);
 		return -ENOMEM;
 	}
-	hw->buf_offset = hw->cma_alloc_addr - DEF_BUF_START_ADDR;
+
+	hw->buf_offset = hw->cma_alloc_addr - DEF_BUF_START_ADDR +
+			DCAC_READ_MARGIN;
+	if (mmu_enable)
+		if (decoder_bmmu_box_alloc_buf_phy(hw->bmmu_box, BMMU_EXTIF_IDX,
+			EXTIF_BUF_SIZE, DRIVER_NAME, &hw->extif_addr) < 0) {
+			h264_free_hw_stru(&pdev->dev, (void *)hw);
+			return -ENOMEM;
+		}
+	if (!vdec_secure(pdata)) {
+#if 1
+		/*init internal buf*/
+		tmpbuf = (char *)codec_mm_phys_to_virt(hw->cma_alloc_addr);
+		memset(tmpbuf, 0, V_BUF_ADDR_OFFSET);
+		dma_sync_single_for_device(amports_get_dma_device(),
+			hw->cma_alloc_addr,
+			V_BUF_ADDR_OFFSET, DMA_TO_DEVICE);
 #else
-	hw->buf_offset = pdata->mem_start - DEF_BUF_START_ADDR;
-	hw->buf_start = V_BUF_ADDR_OFFSET + pdata->mem_start;
+		/*init sps/pps internal buf 64k*/
+		tmpbuf = (char *)codec_mm_phys_to_virt(hw->cma_alloc_addr
+			+ (mem_sps_base - DEF_BUF_START_ADDR));
+		memset(tmpbuf, 0, 0x10000);
+		dma_sync_single_for_device(amports_get_dma_device(),
+			hw->cma_alloc_addr +
+			(mem_sps_base - DEF_BUF_START_ADDR),
+			0x10000, DMA_TO_DEVICE);
 #endif
+	}
+	/**/
 
 	if (pdata->sys_info)
 		hw->vh264_amstream_dec_info = *pdata->sys_info;
+#if 0
 	if (NULL == hw->sei_data_buffer) {
 		hw->sei_data_buffer =
 			dma_alloc_coherent(amports_get_dma_device(),
@@ -2628,26 +5200,30 @@ static int ammvdec_h264_probe(struct platform_device *pdev)
 		if (!hw->sei_data_buffer) {
 			pr_info("%s: Can not allocate sei_data_buffer\n",
 				   __func__);
+			ammvdec_h264_mmu_release(hw);
+			h264_free_hw_stru(&pdev->dev, (void *)hw);
 			return -ENOMEM;
 		}
 		/* pr_info("buffer 0x%x, phys 0x%x, remap 0x%x\n",
 		   sei_data_buffer, sei_data_buffer_phys,
 		   (u32)sei_data_buffer_remap); */
 	}
-#ifdef USE_CMA
+#endif
 	pr_info("ammvdec_h264 mem-addr=%lx,buff_offset=%x,buf_start=%lx\n",
 		pdata->mem_start, hw->buf_offset, hw->cma_alloc_addr);
-#else
-	pr_info("ammvdec_h264 mem-addr=%lx,buff_offset=%x,buf_start=%lx\n",
-		pdata->mem_start, hw->buf_offset, hw->buf_start);
-#endif
+
 
 	vdec_source_changed(VFORMAT_H264, 3840, 2160, 60);
 
 	if (vh264_init(hw) < 0) {
 		pr_info("\nammvdec_h264 init failed.\n");
+		ammvdec_h264_mmu_release(hw);
+		h264_free_hw_stru(&pdev->dev, (void *)hw);
 		return -ENODEV;
 	}
+
+	vdec_set_prepare_level(pdata, start_decode_buf_level);
+
 	atomic_set(&hw->vh264_active, 1);
 
 	return 0;
@@ -2658,6 +5234,10 @@ static int ammvdec_h264_remove(struct platform_device *pdev)
 	struct vdec_h264_hw_s *hw =
 		(struct vdec_h264_hw_s *)
 		(((struct vdec_s *)(platform_get_drvdata(pdev)))->private);
+	int i;
+
+	for (i = 0; i < BUFSPEC_POOL_SIZE; i++)
+		release_aux_data(hw, i);
 
 	atomic_set(&hw->vh264_active, 0);
 
@@ -2666,14 +5246,15 @@ static int ammvdec_h264_remove(struct platform_device *pdev)
 		hw->stat &= ~STAT_TIMER_ARM;
 	}
 
-	vh264_stop(hw, MODE_FULL);
+	vh264_stop(hw);
 
 	/* vdec_source_changed(VFORMAT_H264, 0, 0, 0); */
 
 	atomic_set(&hw->vh264_active, 0);
 
 	vdec_set_status(hw_to_vdec(hw), VDEC_STATUS_DISCONNECTED);
-
+	ammvdec_h264_mmu_release(hw);
+	h264_free_hw_stru(&pdev->dev, (void *)hw);
 	return 0;
 }
 
@@ -2696,6 +5277,34 @@ static struct codec_profile_t ammvdec_h264_profile = {
 	.profile = ""
 };
 
+static struct mconfig hm264_configs[] = {
+	MC_PU32("h264_debug_flag", &h264_debug_flag),
+	MC_PI32("start_decode_buf_level", &start_decode_buf_level),
+	MC_PU32("fixed_frame_rate_mode", &fixed_frame_rate_mode),
+	MC_PU32("decode_timeout_val", &decode_timeout_val),
+	MC_PU32("reorder_dpb_size_margin", &reorder_dpb_size_margin),
+	MC_PU32("reference_buf_margin", &reference_buf_margin),
+	MC_PU32("radr", &radr),
+	MC_PU32("rval", &rval),
+	MC_PU32("h264_debug_mask", &h264_debug_mask),
+	MC_PU32("h264_debug_cmd", &h264_debug_cmd),
+	MC_PI32("force_rate_streambase", &force_rate_streambase),
+	MC_PI32("dec_control", &dec_control),
+	MC_PI32("force_rate_framebase", &force_rate_framebase),
+	MC_PI32("force_disp_bufspec_num", &force_disp_bufspec_num),
+	MC_PU32("prefix_aux_buf_size", &prefix_aux_buf_size),
+	MC_PU32("suffix_aux_buf_size", &suffix_aux_buf_size),
+#ifdef CONFIG_AM_VDEC_DV
+	MC_PU32("reorder_dpb_size_margin_dv", &reorder_dpb_size_margin_dv),
+	MC_PU32("dv_toggle_prov_name", &dv_toggle_prov_name),
+	MC_PU32("dolby_meta_with_el", &dolby_meta_with_el),
+#endif
+	MC_PU32("i_only_flag", &i_only_flag),
+	MC_PU32("force_rate_streambase", &force_rate_streambase),
+};
+static struct mconfig_node hm264_node;
+
+
 static int __init ammvdec_h264_driver_init_module(void)
 {
 	pr_info("ammvdec_h264 module init\n");
@@ -2704,6 +5313,8 @@ static int __init ammvdec_h264_driver_init_module(void)
 		return -ENODEV;
 	}
 	vcodec_profile_register(&ammvdec_h264_profile);
+	INIT_REG_NODE_CONFIGS("media.decoder", &hm264_node,
+	"mh264", hm264_configs, CONFIG_FOR_RW);
 	return 0;
 }
 
@@ -2719,7 +5330,7 @@ static void __exit ammvdec_h264_driver_remove_module(void)
 module_param(h264_debug_flag, uint, 0664);
 MODULE_PARM_DESC(h264_debug_flag, "\n ammvdec_h264 h264_debug_flag\n");
 
-module_param(start_decode_buf_level, uint, 0664);
+module_param(start_decode_buf_level, int, 0664);
 MODULE_PARM_DESC(start_decode_buf_level,
 		"\n ammvdec_h264 start_decode_buf_level\n");
 
@@ -2729,9 +5340,21 @@ MODULE_PARM_DESC(fixed_frame_rate_mode, "\namvdec_h264 fixed_frame_rate_mode\n")
 module_param(decode_timeout_val, uint, 0664);
 MODULE_PARM_DESC(decode_timeout_val, "\n amvdec_h264 decode_timeout_val\n");
 
+module_param(get_data_timeout_val, uint, 0664);
+MODULE_PARM_DESC(get_data_timeout_val, "\n amvdec_h264 get_data_timeout_val\n");
+
+module_param(frame_max_data_packet, uint, 0664);
+MODULE_PARM_DESC(frame_max_data_packet, "\n amvdec_h264 frame_max_data_packet\n");
+
 module_param(reorder_dpb_size_margin, uint, 0664);
 MODULE_PARM_DESC(reorder_dpb_size_margin, "\n ammvdec_h264 reorder_dpb_size_margin\n");
 
+#ifdef CONFIG_AM_VDEC_DV
+module_param(reorder_dpb_size_margin_dv, uint, 0664);
+MODULE_PARM_DESC(reorder_dpb_size_margin_dv,
+	"\n ammvdec_h264 reorder_dpb_size_margin_dv\n");
+#endif
+
 module_param(reference_buf_margin, uint, 0664);
 MODULE_PARM_DESC(reference_buf_margin, "\n ammvdec_h264 reference_buf_margin\n");
 
@@ -2756,14 +5379,88 @@ MODULE_PARM_DESC(dec_control, "\n amvdec_h264 dec_control\n");
 module_param(force_rate_framebase, int, 0664);
 MODULE_PARM_DESC(force_rate_framebase, "\n amvdec_h264 force_rate_framebase\n");
 
+module_param(force_disp_bufspec_num, int, 0664);
+MODULE_PARM_DESC(force_disp_bufspec_num, "\n amvdec_h264 force_disp_bufspec_num\n");
+
+module_param(V_BUF_ADDR_OFFSET, int, 0664);
+MODULE_PARM_DESC(V_BUF_ADDR_OFFSET, "\n amvdec_h264 V_BUF_ADDR_OFFSET\n");
+
+module_param(prefix_aux_buf_size, uint, 0664);
+MODULE_PARM_DESC(prefix_aux_buf_size, "\n prefix_aux_buf_size\n");
+
+module_param(suffix_aux_buf_size, uint, 0664);
+MODULE_PARM_DESC(suffix_aux_buf_size, "\n suffix_aux_buf_size\n");
+
+#ifdef CONFIG_AM_VDEC_DV
+module_param(dv_toggle_prov_name, uint, 0664);
+MODULE_PARM_DESC(dv_toggle_prov_name, "\n dv_toggle_prov_name\n");
+
+module_param(dolby_meta_with_el, uint, 0664);
+MODULE_PARM_DESC(dolby_meta_with_el, "\n dolby_meta_with_el\n");
+
+#endif
+
+module_param(fast_output_enable, uint, 0664);
+MODULE_PARM_DESC(fast_output_enable, "\n amvdec_h264 fast_output_enable\n");
+
+module_param(error_proc_policy, uint, 0664);
+MODULE_PARM_DESC(error_proc_policy, "\n amvdec_h264 error_proc_policy\n");
+
+module_param(error_skip_count, uint, 0664);
+MODULE_PARM_DESC(error_skip_count, "\n amvdec_h264 error_skip_count\n");
+
+module_param(force_sliding_margin, uint, 0664);
+MODULE_PARM_DESC(force_sliding_margin, "\n amvdec_h264 force_sliding_margin\n");
+
+module_param(i_only_flag, uint, 0664);
+MODULE_PARM_DESC(i_only_flag, "\n amvdec_h264 i_only_flag\n");
+
+module_param(first_i_policy, uint, 0664);
+MODULE_PARM_DESC(first_i_policy, "\n amvdec_h264 first_i_policy\n");
+
+module_param(udebug_flag, uint, 0664);
+MODULE_PARM_DESC(udebug_flag, "\n amvdec_h265 udebug_flag\n");
+
+module_param(udebug_pause_pos, uint, 0664);
+MODULE_PARM_DESC(udebug_pause_pos, "\n udebug_pause_pos\n");
+
+module_param(udebug_pause_val, uint, 0664);
+MODULE_PARM_DESC(udebug_pause_val, "\n udebug_pause_val\n");
+
+module_param(udebug_pause_decode_idx, uint, 0664);
+MODULE_PARM_DESC(udebug_pause_decode_idx, "\n udebug_pause_decode_idx\n");
+
+module_param(max_alloc_buf_count, uint, 0664);
+MODULE_PARM_DESC(max_alloc_buf_count, "\n amvdec_h264 max_alloc_buf_count\n");
+
+module_param(enable_itu_t35, uint, 0664);
+MODULE_PARM_DESC(enable_itu_t35, "\n amvdec_h264 enable_itu_t35\n");
+
+module_param(mmu_enable, uint, 0664);
+MODULE_PARM_DESC(mmu_enable, "\n mmu_enable\n");
+
+module_param(force_enable_mmu, uint, 0664);
+MODULE_PARM_DESC(force_enable_mmu, "\n force_enable_mmu\n");
+
 /*
 module_param(trigger_task, uint, 0664);
 MODULE_PARM_DESC(trigger_task, "\n amvdec_h264 trigger_task\n");
 */
 module_param_array(decode_frame_count, uint, &max_decode_instance_num, 0664);
 
+module_param_array(display_frame_count, uint, &max_decode_instance_num, 0664);
+
 module_param_array(max_process_time, uint, &max_decode_instance_num, 0664);
 
+module_param_array(run_count, uint,
+	&max_decode_instance_num, 0664);
+
+module_param_array(not_run_ready, uint,
+	&max_decode_instance_num, 0664);
+
+module_param_array(input_empty, uint,
+	&max_decode_instance_num, 0664);
+
 module_param_array(max_get_frame_interval, uint,
 	&max_decode_instance_num, 0664);
 
diff --git a/drivers/frame_provider/decoder/h265/vh265.c b/drivers/frame_provider/decoder/h265/vh265.c
index 7e09b7b..72679c7 100644
--- a/drivers/frame_provider/decoder/h265/vh265.c
+++ b/drivers/frame_provider/decoder/h265/vh265.c
@@ -37,16 +37,21 @@
 #include <linux/dma-mapping.h>
 #include <linux/dma-contiguous.h>
 #include <linux/slab.h>
+#include <linux/mm.h>
 #include "../../../stream_input/amports/amports_priv.h"
 #include <linux/amlogic/media/codec_mm/codec_mm.h>
 #include "../utils/decoder_mmu_box.h"
 #include "../utils/decoder_bmmu_box.h"
 #include "../utils/config_parser.h"
 
+/*#define TEST_NO_BUF*/
 /*#define HEVC_PIC_STRUCT_SUPPORT*/
 #define MULTI_INSTANCE_SUPPORT
 
-
+			/* .buf_size = 0x100000*16,
+			//4k2k , 0x100000 per buffer */
+			/* 4096x2304 , 0x120000 per buffer */
+#define MPRED_MV_BUF_SIZE		0x120000
 
 #define MMU_COMPRESS_HEADER_SIZE  0x48000
 #define MAX_FRAME_4K_NUM 0x1200
@@ -66,6 +71,7 @@
 #include "../utils/vdec.h"
 #include "../utils/amvdec.h"
 #include <linux/amlogic/media/video_sink/video.h>
+#include <linux/amlogic/media/codec_mm/configs.h>
 
 #define SUPPORT_10BIT
 /* #define ERROR_HANDLE_DEBUG */
@@ -85,6 +91,7 @@
 #endif
 #define DRIVER_NAME "amvdec_h265"
 #define MODULE_NAME "amvdec_h265"
+#define DRIVER_HEADER_NAME "amvdec_h265_header"
 
 #define PUT_INTERVAL        (HZ/100)
 #define ERROR_SYSTEM_RESET_COUNT   200
@@ -98,6 +105,8 @@
 #define DUR2PTS(x) ((x)*90/96)
 #define HEVC_SIZE (4096*2304)
 
+static struct semaphore h265_sema;
+
 struct hevc_state_s;
 static int hevc_print(struct hevc_state_s *hevc,
 	int debug_flag, const char *fmt, ...);
@@ -116,6 +125,7 @@ static s32 vh265_init(struct vdec_s *vdec);
 static bool run_ready(struct vdec_s *vdec);
 static void reset_process_time(struct hevc_state_s *hevc);
 static void start_process_time(struct hevc_state_s *hevc);
+static void restart_process_time(struct hevc_state_s *hevc);
 static void timeout_process(struct hevc_state_s *hevc);
 #else
 static s32 vh265_init(struct hevc_state_s *hevc);
@@ -144,9 +154,15 @@ static u32 bit_depth_luma;
 static u32 bit_depth_chroma;
 static u32 video_signal_type;
 
-static unsigned int start_decode_buf_level = 0x8000;
+static int start_decode_buf_level = 0x8000;
+
+static unsigned int decode_timeout_val = 200;
+
+/*data_resend_policy:
+	bit 0, stream base resend data when decoding buf empty
+*/
+static u32 data_resend_policy = 1;
 
-static unsigned int decode_timeout_val;
 #define VIDEO_SIGNAL_TYPE_AVAILABLE_MASK	0x20000000
 
 static const char * const video_format_names[] = {
@@ -202,7 +218,6 @@ static u32 force_fps;
 static u32 pts_unstable;
 #define H265_DEBUG_BUFMGR                   0x01
 #define H265_DEBUG_BUFMGR_MORE              0x02
-#define H265_DEBUG_UCODE                    0x04
 #define H265_DEBUG_REG                      0x08
 #define H265_DEBUG_MAN_SEARCH_NAL           0x10
 #define H265_DEBUG_MAN_SKIP_NAL             0x20
@@ -212,16 +227,17 @@ static u32 pts_unstable;
 #define H265_DEBUG_NO_DISPLAY               0x200
 #define H265_DEBUG_DISCARD_NAL              0x400
 #define H265_DEBUG_OUT_PTS                  0x800
-#define H265_DEBUG_PRINT_SEI		      0x2000
+#define H265_DEBUG_PRINT_SEI		        0x2000
 #define H265_DEBUG_PIC_STRUCT				0x4000
 #define H265_DEBUG_DIS_LOC_ERROR_PROC       0x10000
-#define H265_DEBUG_DIS_SYS_ERROR_PROC   0x20000
-#define H265_DEBUG_DUMP_PIC_LIST       0x40000
-#define H265_DEBUG_TRIG_SLICE_SEGMENT_PROC 0x80000
-#define H265_DEBUG_HW_RESET               0x100000
-#define H265_DEBUG_ERROR_TRIG             0x400000
-#define H265_DEBUG_NO_EOS_SEARCH_DONE     0x800000
-#define H265_DEBUG_NOT_USE_LAST_DISPBUF   0x1000000
+#define H265_DEBUG_DIS_SYS_ERROR_PROC       0x20000
+#define H265_DEBUG_DUMP_PIC_LIST            0x40000
+#define H265_DEBUG_TRIG_SLICE_SEGMENT_PROC  0x80000
+#define H265_DEBUG_HW_RESET                 0x100000
+#define H265_CFG_CANVAS_IN_DECODE           0x200000
+#define H265_DEBUG_ERROR_TRIG               0x400000
+#define H265_DEBUG_NO_EOS_SEARCH_DONE       0x800000
+#define H265_DEBUG_NOT_USE_LAST_DISPBUF     0x1000000
 #define H265_DEBUG_IGNORE_CONFORMANCE_WINDOW	0x2000000
 #define H265_DEBUG_WAIT_DECODE_DONE_WHEN_STOP   0x4000000
 #ifdef MULTI_INSTANCE_SUPPORT
@@ -230,19 +246,30 @@ static u32 pts_unstable;
 #define PRINT_FLAG_VDEC_STATUS             0x20000000
 #define PRINT_FLAG_VDEC_DETAIL             0x40000000
 #endif
+#define BUF_POOL_SIZE	32
 #define MAX_BUF_NUM 24
 #define MAX_REF_PIC_NUM 24
 #define MAX_REF_ACTIVE  16
 
-#define BMMU_MAX_BUFFERS (MAX_BUF_NUM + 1)
-#define BMMU_WORKSPACE_ID (MAX_BUF_NUM)
+#ifdef MV_USE_FIXED_BUF
+#define BMMU_MAX_BUFFERS (BUF_POOL_SIZE + 1)
+#define VF_BUFFER_IDX(n)	(n)
+#define BMMU_WORKSPACE_ID	(BUF_POOL_SIZE)
+#else
+#define BMMU_MAX_BUFFERS (BUF_POOL_SIZE + 1 + MAX_REF_PIC_NUM)
+#define VF_BUFFER_IDX(n)	(n)
+#define BMMU_WORKSPACE_ID	(BUF_POOL_SIZE)
+#define MV_BUFFER_IDX(n) (BUF_POOL_SIZE + 1 + n)
+#endif
 
 const u32 h265_version = 201602101;
 static u32 debug_mask = 0xffffffff;
+static u32 log_mask;
 static u32 debug;
 static u32 radr;
 static u32 rval;
 static u32 dbg_cmd;
+static u32 dump_nal;
 static u32 dbg_skip_decode_index;
 static u32 endian = 0xff0;
 #ifdef ERROR_HANDLE_DEBUG
@@ -251,28 +278,41 @@ static u32 dbg_nal_skip_flag;
 static u32 dbg_nal_skip_count;
 #endif
 /*for debug*/
-static u32 decode_stop_pos;
-static u32 decode_stop_pos_pre;
+/*
+	udebug_flag:
+	bit 0, enable ucode print
+	bit 1, enable ucode detail print
+	bit [31:16] not 0, pos to dump lmem
+		bit 2, pop bits to lmem
+		bit [11:8], pre-pop bits for alignment (when bit 2 is 1)
+*/
+static u32 udebug_flag;
+/*
+	when udebug_flag[1:0] is not 0
+	udebug_pause_pos not 0,
+		pause position
+*/
+static u32 udebug_pause_pos;
+/*
+	when udebug_flag[1:0] is not 0
+	and udebug_pause_pos is not 0,
+		pause only when DEBUG_REG2 is equal to this val
+*/
+static u32 udebug_pause_val;
+
+static u32 udebug_pause_decode_idx;
+
 static u32 decode_pic_begin;
 static uint slice_parse_begin;
 static u32 step;
-#ifdef MIX_STREAM_SUPPORT
-#ifdef SUPPORT_4K2K
-static u32 buf_alloc_width = 4096;
-static u32 buf_alloc_height = 2304;
-#else
-static u32 buf_alloc_width = 1920;
-static u32 buf_alloc_height = 1088;
-#endif
-static u32 dynamic_buf_num_margin;
-#else
+
+static u32 dynamic_buf_num_margin = 8;
 static u32 buf_alloc_width;
 static u32 buf_alloc_height;
-static u32 dynamic_buf_num_margin = 8;
-#endif
+
 static u32 max_buf_num = 16;
 static u32 buf_alloc_size;
-static u32 re_config_pic_flag;
+/*static u32 re_config_pic_flag;*/
 /*
 bit[0]: 0,
 bit[1]: 0, always release cma buffer when stop
@@ -318,7 +358,7 @@ use_cma: 1, use both reserver memory and cma for buffers
 static u32 use_cma = 2;
 
 #define AUX_BUF_ALIGN(adr) ((adr + 0xf) & (~0xf))
-static u32 prefix_aux_buf_size;
+static u32 prefix_aux_buf_size = (16 * 1024);
 static u32 suffix_aux_buf_size;
 
 static u32 max_decoding_time;
@@ -348,6 +388,8 @@ static u32 error_handle_threshold = 30;
 static u32 error_handle_nal_skip_threshold = 10;
 static u32 error_handle_system_threshold = 30;
 static u32 interlace_enable = 1;
+static u32 fr_hint_status;
+
 	/*
 	parser_sei_enable:
 	  bit 0, sei;
@@ -357,23 +399,26 @@ static u32 interlace_enable = 1;
 	*/
 static u32 parser_sei_enable;
 #ifdef CONFIG_AM_VDEC_DV
-static u32 parser_dolby_vision_enable;
+static u32 parser_dolby_vision_enable = 1;
+static u32 dolby_meta_with_el;
 #endif
 /* this is only for h265 mmu enable */
 
-#ifdef CONFIG_MULTI_DEC
-static u32 mmu_enable;
-#else
 static u32 mmu_enable = 1;
-#endif
+static u32 mmu_enable_force;
+static u32 work_buf_size;
+static unsigned int force_disp_pic_index;
 
 #ifdef MULTI_INSTANCE_SUPPORT
-static u32 work_buf_size = 48 * 1024 * 1024;
 static unsigned int max_decode_instance_num
 				= MAX_DECODE_INSTANCE_NUM;
 static unsigned int decode_frame_count[MAX_DECODE_INSTANCE_NUM];
+static unsigned int display_frame_count[MAX_DECODE_INSTANCE_NUM];
 static unsigned int max_process_time[MAX_DECODE_INSTANCE_NUM];
 static unsigned int max_get_frame_interval[MAX_DECODE_INSTANCE_NUM];
+static unsigned int run_count[MAX_DECODE_INSTANCE_NUM];
+static unsigned int input_empty[MAX_DECODE_INSTANCE_NUM];
+static unsigned int not_run_ready[MAX_DECODE_INSTANCE_NUM];
 
 #ifdef CONFIG_MULTI_DEC
 static unsigned char get_idx(struct hevc_state_s *hevc);
@@ -390,9 +435,11 @@ static u32 dv_debug;
 #ifdef CONFIG_MULTI_DEC
 #define get_dbg_flag(hevc) ((debug_mask & (1 << hevc->index)) ? debug : 0)
 #define get_dbg_flag2(hevc) ((debug_mask & (1 << get_idx(hevc))) ? debug : 0)
+#define is_log_enable(hevc) ((log_mask & (1 << hevc->index)) ? 1 : 0)
 #else
 #define get_dbg_flag(hevc) debug
 #define get_dbg_flag2(hevc) debug
+#define is_log_enable(hevc) (log_mask ? 1 : 0)
 #define get_double_write_mode(hevc) double_write_mode
 #define get_buf_alloc_width(hevc) buf_alloc_width
 #define get_buf_alloc_height(hevc) buf_alloc_height
@@ -416,6 +463,9 @@ void WRITE_VREG_DBG(unsigned adr, unsigned val)
 
 static DEFINE_MUTEX(vh265_mutex);
 
+static DEFINE_MUTEX(vh265_log_mutex);
+
+static struct vdec_info *gvs;
 
 /**************************************************
 
@@ -535,7 +585,8 @@ enum NalUnitType {
 #define HEVC_DECODE_BUFEMPTY        0x20
 #define HEVC_DECODE_TIMEOUT         0x21
 #define HEVC_SEARCH_BUFEMPTY        0x22
-
+#define HEVC_DECODE_OVER_SIZE       0x23
+#define HEVC_DECODE_BUFEMPTY2       0x24
 #define HEVC_FIND_NEXT_PIC_NAL				0x50
 #define HEVC_FIND_NEXT_DVEL_NAL				0x51
 
@@ -543,6 +594,7 @@ enum NalUnitType {
 
 #define HEVC_4k2k_60HZ_NOT_SUPPORT	0x80
 #define HEVC_DISCARD_NAL         0xf0
+#define HEVC_ACTION_DEC_CONT     0xfd
 #define HEVC_ACTION_ERROR        0xfe
 #define HEVC_ACTION_DONE         0xff
 
@@ -668,8 +720,14 @@ bit [20]: for DOLBY_VISION_META
 #define NAL_SEARCH_CTL            HEVC_ASSIST_SCRATCH_I
 	/*read only*/
 #define CUR_NAL_UNIT_TYPE       HEVC_ASSIST_SCRATCH_J
+	/*
+	[15 : 8] rps_set_id
+	[7 : 0] start_decoding_flag
+	*/
+#define HEVC_DECODE_INFO       HEVC_ASSIST_SCRATCH_1
 	/*set before start decoder*/
 #define HEVC_DECODE_MODE		HEVC_ASSIST_SCRATCH_J
+#define HEVC_DECODE_MODE2		HEVC_ASSIST_SCRATCH_H
 #define DECODE_STOP_POS         HEVC_ASSIST_SCRATCH_K
 
 #define DECODE_MODE_SINGLE					0x0
@@ -756,6 +814,9 @@ union param_u {
 		unsigned short conf_win_bottom_offset;
 		unsigned short chroma_format_idc;
 		unsigned short color_description;
+		unsigned short aspect_ratio_idc;
+		unsigned short sar_width;
+		unsigned short sar_height;
 	} p;
 };
 
@@ -790,7 +851,9 @@ struct BuffInfo_s {
 	struct buff_s mmu_vbh;
 	struct buff_s cm_header;
 	struct buff_s mpred_above;
+#ifdef MV_USE_FIXED_BUF
 	struct buff_s mpred_mv;
+#endif
 	struct buff_s rpm;
 	struct buff_s lmem;
 };
@@ -864,15 +927,20 @@ static struct BuffInfo_s amvh265_workbuff_spec[WORK_BUF_SPEC_NUM] = {
 		.mmu_vbh = {
 			.buf_size = 0x5000, /*2*16*2304/4, 4K*/
 		},
+#if 0
 		.cm_header = {/* 0x44000 = ((1088*2*1024*4)/32/4)*(32/8)*/
-			.buf_size = MMU_COMPRESS_HEADER_SIZE*(16+1),
+			.buf_size = MMU_COMPRESS_HEADER_SIZE *
+			(MAX_REF_PIC_NUM + 1),
 		},
+#endif
 		.mpred_above = {
 			.buf_size = 0x8000,
 		},
+#ifdef MV_USE_FIXED_BUF
 		.mpred_mv = {/* 1080p, 0x40000 per buffer */
 			.buf_size = 0x40000 * MAX_REF_PIC_NUM,
 		},
+#endif
 		.rpm = {
 			.buf_size = RPM_BUF_SIZE,
 		},
@@ -944,18 +1012,23 @@ static struct BuffInfo_s amvh265_workbuff_spec[WORK_BUF_SPEC_NUM] = {
 		.mmu_vbh = {
 			.buf_size = 0x5000, /*2*16*2304/4, 4K*/
 		},
+#if 0
 		.cm_header = {/*0x44000 = ((1088*2*1024*4)/32/4)*(32/8)*/
-			.buf_size = MMU_COMPRESS_HEADER_SIZE * (16+1),
+			.buf_size = MMU_COMPRESS_HEADER_SIZE *
+			(MAX_REF_PIC_NUM + 1),
 		},
+#endif
 		.mpred_above = {
 			.buf_size = 0x8000,
 		},
+#ifdef MV_USE_FIXED_BUF
 		.mpred_mv = {
 			/* .buf_size = 0x100000*16,
 			//4k2k , 0x100000 per buffer */
 			/* 4096x2304 , 0x120000 per buffer */
-			.buf_size = 0x120000 * MAX_REF_PIC_NUM,
+			.buf_size = MPRED_MV_BUF_SIZE * MAX_REF_PIC_NUM,
 		},
+#endif
 		.rpm = {
 			.buf_size = RPM_BUF_SIZE,
 		},
@@ -965,55 +1038,6 @@ static struct BuffInfo_s amvh265_workbuff_spec[WORK_BUF_SPEC_NUM] = {
 	}
 };
 
-unsigned int get_mmu_mode(void)
-{
-	return mmu_enable;
-}
-
-#ifdef SUPPORT_10BIT
-/* Losless compression body buffer size 4K per 64x32 (jt) */
-static  int  compute_losless_comp_body_size(int width, int height,
-	int mem_saving_mode)
-{
-	int width_x64;
-	int     height_x32;
-	int     bsize;
-
-	width_x64 = width + 63;
-	width_x64 >>= 6;
-
-	height_x32 = height + 31;
-	height_x32 >>= 5;
-	if (mem_saving_mode == 1 && mmu_enable)
-		bsize = 3200 * width_x64 * height_x32;
-	else if (mem_saving_mode == 1)
-		bsize = 3072 * width_x64 * height_x32;
-	else
-		bsize = 4096 * width_x64 * height_x32;
-
-	return  bsize;
-}
-
-/* Losless compression header buffer size 32bytes per 128x64 (jt) */
-static  int  compute_losless_comp_header_size(int width, int height)
-{
-	int     width_x128;
-	int     height_x64;
-	int     hsize;
-
-	width_x128 = width + 127;
-	width_x128 >>= 7;
-
-	height_x64 = height + 63;
-	height_x64 >>= 6;
-
-	hsize = 32*width_x128*height_x64;
-
-	return  hsize;
-}
-
-#endif
-
 static void init_buff_spec(struct hevc_state_s *hevc,
 	struct BuffInfo_s *buf_spec)
 {
@@ -1046,42 +1070,34 @@ static void init_buff_spec(struct hevc_state_s *hevc,
 		buf_spec->dblk_para.buf_start + buf_spec->dblk_para.buf_size;
 	buf_spec->mmu_vbh.buf_start  =
 		buf_spec->dblk_data.buf_start + buf_spec->dblk_data.buf_size;
-	buf_spec->cm_header.buf_start =
-		buf_spec->mmu_vbh.buf_start + buf_spec->mmu_vbh.buf_size;
 	buf_spec->mpred_above.buf_start =
-		buf_spec->cm_header.buf_start + buf_spec->cm_header.buf_size;
+		buf_spec->mmu_vbh.buf_start + buf_spec->mmu_vbh.buf_size;
+#ifdef MV_USE_FIXED_BUF
 	buf_spec->mpred_mv.buf_start =
 		buf_spec->mpred_above.buf_start +
 		buf_spec->mpred_above.buf_size;
-	if (get_dbg_flag2(hevc) & H265_DEBUG_SEND_PARAM_WITH_REG) {
-		buf_spec->end_adr =
-			buf_spec->mpred_mv.buf_start +
-			buf_spec->mpred_mv.buf_size;
-	} else {
-		buf_spec->rpm.buf_start =
-			buf_spec->mpred_mv.buf_start +
-			buf_spec->mpred_mv.buf_size;
-		if (get_dbg_flag2(hevc) & H265_DEBUG_UCODE) {
-			buf_spec->lmem.buf_start =
-				buf_spec->rpm.buf_start +
-				buf_spec->rpm.buf_size;
-			buf_spec->end_adr =
-				buf_spec->lmem.buf_start +
-				buf_spec->lmem.buf_size;
-		} else {
-			buf_spec->end_adr =
-				buf_spec->rpm.buf_start +
-				buf_spec->rpm.buf_size;
-		}
-	}
 
-	if (get_dbg_flag2(hevc)) {
+	buf_spec->rpm.buf_start =
+		buf_spec->mpred_mv.buf_start +
+		buf_spec->mpred_mv.buf_size;
+#else
+	buf_spec->rpm.buf_start =
+		buf_spec->mpred_above.buf_start +
+		buf_spec->mpred_above.buf_size;
+#endif
+	buf_spec->lmem.buf_start =
+		buf_spec->rpm.buf_start +
+		buf_spec->rpm.buf_size;
+	buf_spec->end_adr =
+		buf_spec->lmem.buf_start +
+		buf_spec->lmem.buf_size;
+
+	if (hevc && get_dbg_flag2(hevc)) {
 		hevc_print(hevc, 0,
 				"%s workspace (%x %x) size = %x\n", __func__,
 			   buf_spec->start_adr, buf_spec->end_adr,
 			   buf_spec->end_adr - buf_spec->start_adr);
-	}
-	if (get_dbg_flag2(hevc)) {
+
 		hevc_print(hevc, 0,
 			"ipp.buf_start             :%x\n",
 			buf_spec->ipp.buf_start);
@@ -1124,9 +1140,11 @@ static void init_buff_spec(struct hevc_state_s *hevc,
 		hevc_print(hevc, 0,
 			"mpred_above.buf_start     :%x\n",
 			buf_spec->mpred_above.buf_start);
+#ifdef MV_USE_FIXED_BUF
 		hevc_print(hevc, 0,
 			"mpred_mv.buf_start        :%x\n",
 			  buf_spec->mpred_mv.buf_start);
+#endif
 		if ((get_dbg_flag2(hevc)
 			&
 			H265_DEBUG_SEND_PARAM_WITH_REG)
@@ -1147,19 +1165,18 @@ enum SliceType {
 
 /*USE_BUF_BLOCK*/
 struct BUF_s {
-	int index;
-	/*buffer */
 	unsigned long start_adr;
 	unsigned int size;
-
-	unsigned int free_start_adr;
+	int used_flag;
 } /*BUF_t */;
 
 /* level 6, 6.1 maximum slice number is 800; other is 200 */
 #define MAX_SLICE_NUM 800
 struct PIC_s {
 	int index;
+	int scatter_alloc;
 	int BUF_index;
+	int mv_buf_index;
 	int POC;
 	int decode_idx;
 	int slice_type;
@@ -1172,7 +1189,6 @@ struct PIC_s {
 	unsigned char recon_mark;
 	unsigned char output_ready;
 	unsigned char error_mark;
-	unsigned char used_by_display;
 	/**/ int slice_idx;
 	int m_aiRefPOCList0[MAX_SLICE_NUM][16];
 	int m_aiRefPOCList1[MAX_SLICE_NUM][16];
@@ -1189,11 +1205,10 @@ struct PIC_s {
 	unsigned int mc_y_adr;
 	unsigned int mc_u_v_adr;
 #ifdef SUPPORT_10BIT
-	unsigned int comp_body_size;
+	/*unsigned int comp_body_size;*/
 	unsigned int dw_y_adr;
 	unsigned int dw_u_v_adr;
 #endif
-	unsigned int buf_size;
 	int mc_canvas_y;
 	int mc_canvas_u_v;
 	int width;
@@ -1204,6 +1219,11 @@ struct PIC_s {
 #ifdef MULTI_INSTANCE_SUPPORT
 	struct canvas_config_s canvas_config[2];
 #endif
+#ifdef SUPPORT_10BIT
+	int mem_saving_mode;
+	u32 bit_depth_luma;
+	u32 bit_depth_chroma;
+#endif
 #ifdef LOSLESS_COMPRESS_MODE
 	unsigned int losless_comp_body_size;
 #endif
@@ -1212,6 +1232,10 @@ struct PIC_s {
 
 	u32 pts;
 	u64 pts64;
+
+	u32 aspect_ratio_idc;
+	u32 sar_width;
+	u32 sar_height;
 } /*PIC_t */;
 
 #define MAX_TILE_COL_NUM    5
@@ -1241,9 +1265,19 @@ struct tile_s {
 #define DEC_UNINIT_PICLIST			6
 #define DEC_RESULT_GET_DATA         7
 #define DEC_RESULT_GET_DATA_RETRY   8
+#define DEC_RESULT_EOS              9
+#define DEC_RESULT_FORCE_EXIT       10
 
 static void vh265_work(struct work_struct *work);
+static void vh265_notify_work(struct work_struct *work);
+
 #endif
+
+struct debug_log_s {
+	struct list_head list;
+	uint8_t data; /*will alloc more size*/
+};
+
 struct hevc_state_s {
 #ifdef MULTI_INSTANCE_SUPPORT
 	struct platform_device *platform_dev;
@@ -1252,6 +1286,7 @@ struct hevc_state_s {
 	struct vframe_chunk_s *chunk;
 	int dec_result;
 	struct work_struct work;
+	struct work_struct notify_work;
 	/* timeout handle */
 	unsigned long int start_process_time;
 	unsigned last_lcu_idx;
@@ -1260,8 +1295,15 @@ struct hevc_state_s {
 #ifdef CONFIG_AM_VDEC_DV
 	unsigned char switch_dvlayer_flag;
 #endif
-	unsigned start_parser_type;
+	unsigned char start_parser_type;
+	/*start_decoding_flag:
+	vps/pps/sps/idr info from ucode*/
+	unsigned char start_decoding_flag;
+	unsigned char rps_set_id;
+	unsigned char eos;
+	int pic_decoded_lcu_idx;
 #endif
+	struct vframe_s vframe_dummy;
 	char *provider_name;
 	int index;
 	struct device *cma_dev;
@@ -1269,10 +1311,10 @@ struct hevc_state_s {
 	unsigned char dolby_enhance_flag;
 	unsigned long buf_start;
 	u32 buf_size;
+	u32 mv_buf_size;
 
 	struct BuffInfo_s work_space_buf_store;
 	struct BuffInfo_s *work_space_buf;
-	struct buff_s *mc_buf;
 
 	u32 prefix_aux_size;
 	u32 suffix_aux_size;
@@ -1334,6 +1376,10 @@ struct hevc_state_s {
 	int new_tile;
 	int curr_POC;
 	int iPrevPOC;
+#ifdef MULTI_INSTANCE_SUPPORT
+	int decoded_poc;
+	struct PIC_s *decoding_pic;
+#endif
 	int iPrevTid0POC;
 	int list_no;
 	int RefNum_L0;
@@ -1343,7 +1389,17 @@ struct hevc_state_s {
 	int LongTerm_Col;
 	int Col_POC;
 	int LongTerm_Ref;
-
+#ifdef MULTI_INSTANCE_SUPPORT
+	int m_pocRandomAccess_bak;
+	int curr_POC_bak;
+	int iPrevPOC_bak;
+	int iPrevTid0POC_bak;
+	unsigned char start_parser_type_bak;
+	unsigned char start_decoding_flag_bak;
+	unsigned char rps_set_id_bak;
+	int pic_decoded_lcu_idx_bak;
+	int decode_idx_bak;
+#endif
 	struct PIC_s *cur_pic;
 	struct PIC_s *col_pic;
 	int skip_flag;
@@ -1356,9 +1412,12 @@ struct hevc_state_s {
 	unsigned char wait_buf;
 	unsigned char error_flag;
 	unsigned int error_skip_nal_count;
+	long used_4k_num;
 
 	unsigned char
-	ignore_bufmgr_error;	/* bit 0, for decoding; bit 1, for displaying */
+	ignore_bufmgr_error;	/* bit 0, for decoding;
+			bit 1, for displaying
+			bit 1 must be set if bit 0 is 1*/
 	int PB_skip_mode;
 	int PB_skip_count_after_decoding;
 #ifdef SUPPORT_10BIT
@@ -1377,18 +1436,16 @@ struct hevc_state_s {
 	int pts_mode_switching_count;
 	int pts_mode_recovery_count;
 
-	int buf_num;
 	int pic_num;
 
 	/**/
-	struct buff_s mc_buf_spec;
 	union param_u param;
 
 	struct tile_s m_tile[MAX_TILE_ROW_NUM][MAX_TILE_COL_NUM];
 
 	struct timer_list timer;
-	struct BUF_s m_BUF[MAX_BUF_NUM];
-	u32 used_buf_num;
+	struct BUF_s m_BUF[BUF_POOL_SIZE];
+	struct BUF_s m_mv_BUF[MAX_REF_PIC_NUM];
 	struct PIC_s *m_PIC[MAX_REF_PIC_NUM];
 
 	DECLARE_KFIFO(newframe_q, struct vframe_s *, VF_POOL_SIZE);
@@ -1420,7 +1477,6 @@ struct hevc_state_s {
 	u32 start_decoding_time;
 
 	int show_frame_num;
-	struct semaphore h265_sema;
 #ifdef USE_UNINIT_SEMA
 	struct semaphore h265_uninit_done_sema;
 #endif
@@ -1435,9 +1491,7 @@ struct hevc_state_s {
 	unsigned int mmu_mc_start_4k_adr;
 	void *mmu_box;
 	void *bmmu_box;
-
-	unsigned int last_put_idx_a;
-	unsigned int last_put_idx_b;
+	int mmu_enable;
 
 	unsigned int dec_status;
 
@@ -1454,32 +1508,140 @@ struct hevc_state_s {
 
 #ifdef MULTI_INSTANCE_SUPPORT
 	int double_write_mode;
-	int buf_alloc_width;
-	int buf_alloc_height;
 	int dynamic_buf_num_margin;
 	int start_action;
 #endif
+	u32 i_only;
+	struct list_head log_list;
+	u32 ucode_pause_pos;
+	u32 start_shift_bytes;
+
+	u32 vf_pre_count;
+	u32 vf_get_count;
+	u32 vf_put_count;
 } /*hevc_stru_t */;
 
-#ifdef CONFIG_MULTI_DEC
-static int get_double_write_mode(struct hevc_state_s *hevc)
+#ifdef SUPPORT_10BIT
+/* Losless compression body buffer size 4K per 64x32 (jt) */
+static  int  compute_losless_comp_body_size(struct hevc_state_s *hevc,
+	int width, int height, int mem_saving_mode)
+{
+	int width_x64;
+	int     height_x32;
+	int     bsize;
+
+	width_x64 = width + 63;
+	width_x64 >>= 6;
+
+	height_x32 = height + 31;
+	height_x32 >>= 5;
+	if (mem_saving_mode == 1 && hevc->mmu_enable)
+		bsize = 3200 * width_x64 * height_x32;
+	else if (mem_saving_mode == 1)
+		bsize = 3072 * width_x64 * height_x32;
+	else
+		bsize = 4096 * width_x64 * height_x32;
+
+	return  bsize;
+}
+
+/* Losless compression header buffer size 32bytes per 128x64 (jt) */
+static  int  compute_losless_comp_header_size(int width, int height)
+{
+	int     width_x128;
+	int     height_x64;
+	int     hsize;
+
+	width_x128 = width + 127;
+	width_x128 >>= 7;
+
+	height_x64 = height + 63;
+	height_x64 >>= 6;
+
+	hsize = 32*width_x128*height_x64;
+
+	return  hsize;
+}
+#endif
+
+static int add_log(struct hevc_state_s *hevc,
+	const char *fmt, ...)
+{
+#define HEVC_LOG_BUF		196
+	struct debug_log_s *log_item;
+	unsigned char buf[HEVC_LOG_BUF];
+	int len = 0;
+	va_list args;
+	mutex_lock(&vh265_log_mutex);
+	va_start(args, fmt);
+	len = sprintf(buf, "<%ld>   <%05d> ",
+		jiffies, hevc->decode_idx);
+	len += vsnprintf(buf + len,
+		HEVC_LOG_BUF - len, fmt, args);
+	va_end(args);
+	log_item = kmalloc(
+		sizeof(struct debug_log_s) + len,
+		GFP_KERNEL);
+	if (log_item) {
+		INIT_LIST_HEAD(&log_item->list);
+		strcpy(&log_item->data, buf);
+		list_add_tail(&log_item->list,
+			&hevc->log_list);
+	}
+	mutex_unlock(&vh265_log_mutex);
+	return 0;
+}
+
+static void dump_log(struct hevc_state_s *hevc)
+{
+	int i = 0;
+	struct debug_log_s *log_item, *tmp;
+	mutex_lock(&vh265_log_mutex);
+	list_for_each_entry_safe(log_item, tmp, &hevc->log_list, list) {
+		hevc_print(hevc, 0,
+			"[LOG%04d]%s\n",
+			i++,
+			&log_item->data);
+		list_del(&log_item->list);
+		kfree(log_item);
+	}
+	mutex_unlock(&vh265_log_mutex);
+}
+
+static unsigned char is_skip_decoding(struct hevc_state_s *hevc,
+		struct PIC_s *pic)
 {
-	return hevc->double_write_mode;
+	if (pic->error_mark
+		&& ((hevc->ignore_bufmgr_error & 0x1) == 0))
+		return 1;
+	return 0;
 }
 
-static int get_buf_alloc_width(struct hevc_state_s *hevc)
+static int get_pic_poc(struct hevc_state_s *hevc,
+		unsigned int idx)
 {
-	return hevc->buf_alloc_width;
+	if (idx != 0xff && idx >= 0
+		&& idx < MAX_REF_PIC_NUM
+		&& hevc->m_PIC[idx])
+		return hevc->m_PIC[idx]->POC;
+	return INVALID_POC;
 }
 
-static int get_buf_alloc_height(struct hevc_state_s *hevc)
+#ifdef CONFIG_MULTI_DEC
+static int get_double_write_mode(struct hevc_state_s *hevc)
 {
-	return hevc->buf_alloc_height;
+	return (hevc->m_ins_flag &&
+		((double_write_mode & 0x80000000) == 0)) ?
+		hevc->double_write_mode :
+		(double_write_mode & 0x7fffffff);
 }
 
 static int get_dynamic_buf_num_margin(struct hevc_state_s *hevc)
 {
-	return hevc->dynamic_buf_num_margin;
+	return (hevc->m_ins_flag &&
+		((dynamic_buf_num_margin & 0x80000000) == 0)) ?
+		hevc->dynamic_buf_num_margin :
+		(dynamic_buf_num_margin & 0x7fffffff);
 }
 #endif
 
@@ -1495,7 +1657,7 @@ static unsigned char get_idx(struct hevc_state_s *hevc)
 static int hevc_print(struct hevc_state_s *hevc,
 	int flag, const char *fmt, ...)
 {
-#define HEVC_PRINT_BUF		128
+#define HEVC_PRINT_BUF		256
 	unsigned char buf[HEVC_PRINT_BUF];
 	int len = 0;
 #ifdef CONFIG_MULTI_DEC
@@ -1522,7 +1684,6 @@ static int hevc_print(struct hevc_state_s *hevc,
 static int hevc_print_cont(struct hevc_state_s *hevc,
 	int flag, const char *fmt, ...)
 {
-#define HEVC_PRINT_BUF		128
 	unsigned char buf[HEVC_PRINT_BUF];
 	int len = 0;
 #ifdef CONFIG_MULTI_DEC
@@ -1543,19 +1704,79 @@ static int hevc_print_cont(struct hevc_state_s *hevc,
 	return 0;
 }
 
+static void put_mv_buf(struct hevc_state_s *hevc,
+	struct PIC_s *pic);
+
+static void update_vf_memhandle(struct hevc_state_s *hevc,
+	struct vframe_s *vf, struct PIC_s *pic);
+
 static void set_canvas(struct hevc_state_s *hevc, struct PIC_s *pic);
 
 static void release_aux_data(struct hevc_state_s *hevc,
 	struct PIC_s *pic);
+static void release_pic_mmu_buf(struct hevc_state_s *hevc, struct PIC_s *pic);
+
+#ifdef MULTI_INSTANCE_SUPPORT
+static void backup_decode_state(struct hevc_state_s *hevc)
+{
+	hevc->m_pocRandomAccess_bak = hevc->m_pocRandomAccess;
+	hevc->curr_POC_bak = hevc->curr_POC;
+	hevc->iPrevPOC_bak = hevc->iPrevPOC;
+	hevc->iPrevTid0POC_bak = hevc->iPrevTid0POC;
+	hevc->start_parser_type_bak = hevc->start_parser_type;
+	hevc->start_decoding_flag_bak = hevc->start_decoding_flag;
+	hevc->rps_set_id_bak = hevc->rps_set_id;
+	hevc->pic_decoded_lcu_idx_bak = hevc->pic_decoded_lcu_idx;
+	hevc->decode_idx_bak = hevc->decode_idx;
+
+}
+
+static void restore_decode_state(struct hevc_state_s *hevc)
+{
+	struct vdec_s *vdec = hw_to_vdec(hevc);
+	if (!vdec_has_more_input(vdec))
+		return;
+	hevc_print(hevc, PRINT_FLAG_VDEC_STATUS,
+		"%s: discard pic index 0x%x\n",
+		__func__, hevc->decoding_pic ?
+		hevc->decoding_pic->index : 0xff);
+	if (hevc->decoding_pic) {
+		hevc->decoding_pic->error_mark = 0;
+		hevc->decoding_pic->output_ready = 0;
+		hevc->decoding_pic->output_mark = 0;
+		hevc->decoding_pic->referenced = 0;
+		hevc->decoding_pic->POC = INVALID_POC;
+		put_mv_buf(hevc, hevc->decoding_pic);
+		release_pic_mmu_buf(hevc, hevc->decoding_pic);
+		release_aux_data(hevc, hevc->decoding_pic);
+		hevc->decoding_pic = NULL;
+	}
+	hevc->decode_idx = hevc->decode_idx_bak;
+	hevc->m_pocRandomAccess = hevc->m_pocRandomAccess_bak;
+	hevc->curr_POC = hevc->curr_POC_bak;
+	hevc->iPrevPOC = hevc->iPrevPOC_bak;
+	hevc->iPrevTid0POC = hevc->iPrevTid0POC_bak;
+	hevc->start_parser_type = hevc->start_parser_type_bak;
+	hevc->start_decoding_flag = hevc->start_decoding_flag_bak;
+	hevc->rps_set_id = hevc->rps_set_id_bak;
+	hevc->pic_decoded_lcu_idx = hevc->pic_decoded_lcu_idx_bak;
+
+	if (hevc->pic_list_init_flag == 1)
+		hevc->pic_list_init_flag = 0;
+	/*if (hevc->decode_idx == 0)
+		hevc->start_decoding_flag = 0;*/
+
+	hevc->slice_idx = 0;
+	hevc->used_4k_num = -1;
+}
+#endif
 
 static void hevc_init_stru(struct hevc_state_s *hevc,
-		struct BuffInfo_s *buf_spec_i,
-		struct buff_s *mc_buf_i)
+		struct BuffInfo_s *buf_spec_i)
 {
 	int i;
-
+	INIT_LIST_HEAD(&hevc->log_list);
 	hevc->work_space_buf = buf_spec_i;
-	hevc->mc_buf = mc_buf_i;
 	hevc->prefix_aux_size = 0;
 	hevc->suffix_aux_size = 0;
 	hevc->aux_addr = NULL;
@@ -1599,8 +1820,6 @@ static void hevc_init_stru(struct hevc_state_s *hevc,
 	hevc->last_lookup_pts = 0;
 	hevc->last_pts_us64 = 0;
 	hevc->last_lookup_pts_us64 = 0;
-	hevc->shift_byte_count_lo = 0;
-	hevc->shift_byte_count_hi = 0;
 	hevc->pts_mode_switching_count = 0;
 	hevc->pts_mode_recovery_count = 0;
 
@@ -1613,7 +1832,6 @@ static void hevc_init_stru(struct hevc_state_s *hevc,
 
 	for (i = 0; i < MAX_REF_PIC_NUM; i++)
 		hevc->m_PIC[i] = NULL;
-	hevc->buf_num = 0;
 	hevc->pic_num = 0;
 	hevc->lcu_x_num_pre = 0;
 	hevc->lcu_y_num_pre = 0;
@@ -1624,10 +1842,17 @@ static void hevc_init_stru(struct hevc_state_s *hevc,
 
 	hevc->sei_present_flag = 0;
 #ifdef MULTI_INSTANCE_SUPPORT
+	hevc->decoded_poc = INVALID_POC;
 	hevc->start_process_time = 0;
 	hevc->last_lcu_idx = 0;
 	hevc->decode_timeout_count = 0;
 	hevc->timeout_num = 0;
+	hevc->eos = 0;
+	hevc->pic_decoded_lcu_idx = -1;
+	hevc->used_4k_num = -1;
+	hevc->start_decoding_flag = 0;
+	hevc->rps_set_id = 0;
+	backup_decode_state(hevc);
 #endif
 }
 
@@ -1657,10 +1882,12 @@ static struct PIC_s *get_pic_by_POC(struct hevc_state_s *hevc, int POC)
 	int i;
 	struct PIC_s *pic;
 	struct PIC_s *ret_pic = NULL;
-
+	if (POC == INVALID_POC)
+		return NULL;
 	for (i = 0; i < MAX_REF_PIC_NUM; i++) {
 		pic = hevc->m_PIC[i];
-		if (pic == NULL || pic->index == -1)
+		if (pic == NULL || pic->index == -1 ||
+			pic->BUF_index == -1)
 			continue;
 		if (pic->POC == POC) {
 			if (ret_pic == NULL)
@@ -1682,7 +1909,8 @@ static struct PIC_s *get_ref_pic_by_POC(struct hevc_state_s *hevc, int POC)
 
 	for (i = 0; i < MAX_REF_PIC_NUM; i++) {
 		pic = hevc->m_PIC[i];
-		if (pic == NULL || pic->index == -1)
+		if (pic == NULL || pic->index == -1 ||
+			pic->BUF_index == -1)
 			continue;
 		if ((pic->POC == POC) && (pic->referenced)) {
 			if (ret_pic == NULL)
@@ -1731,11 +1959,15 @@ static void uninit_mmu_buffers(struct hevc_state_s *hevc)
 }
 static int init_mmu_buffers(struct hevc_state_s *hevc)
 {
-	if (mmu_enable) {
+	int tvp_flag = vdec_secure(hw_to_vdec(hevc)) ?
+		CODEC_MM_FLAGS_TVP : 0;
+
+	if (hevc->mmu_enable) {
 		hevc->mmu_box = decoder_mmu_box_alloc_box(DRIVER_NAME,
 			hevc->index,
 			MAX_REF_PIC_NUM,
-			64 * SZ_1M
+			64 * SZ_1M,
+			tvp_flag
 			);
 		if (!hevc->mmu_box) {
 			pr_err("h265 alloc mmu box failed!!\n");
@@ -1747,7 +1979,8 @@ static int init_mmu_buffers(struct hevc_state_s *hevc)
 			BMMU_MAX_BUFFERS,
 			4 + PAGE_SHIFT,
 			CODEC_MM_FLAGS_CMA_CLEAR |
-			CODEC_MM_FLAGS_FOR_VDECODER);
+			CODEC_MM_FLAGS_FOR_VDECODER |
+			tvp_flag);
 	if (!hevc->bmmu_box) {
 		if (hevc->mmu_box)
 			decoder_mmu_box_free(hevc->mmu_box);
@@ -1758,215 +1991,176 @@ static int init_mmu_buffers(struct hevc_state_s *hevc)
 	return 0;
 }
 
-static void init_buf_list(struct hevc_state_s *hevc)
+struct buf_stru_s
 {
-	int i;
-	int buf_size;
-	int mc_buffer_end = hevc->mc_buf->buf_start + hevc->mc_buf->buf_size;
-
-	if (get_dynamic_buf_num_margin(hevc) > 0)
-		hevc->used_buf_num = hevc->sps_num_reorder_pics_0
-			+ get_dynamic_buf_num_margin(hevc);
-	else
-		hevc->used_buf_num = max_buf_num;
-
-	if (hevc->used_buf_num > MAX_BUF_NUM)
-		hevc->used_buf_num = MAX_BUF_NUM;
-	if (buf_alloc_size > 0) {
-		buf_size = buf_alloc_size;
-		if (get_dbg_flag(hevc))
-			hevc_print(hevc, 0,
-				"[Buffer Management] init_buf_list:\n");
-	} else {
-		int pic_width = get_buf_alloc_width(hevc)
-		? get_buf_alloc_width(hevc) : hevc->pic_w;
-		int pic_height =
-			get_buf_alloc_height(hevc)
-			? get_buf_alloc_height(hevc) : hevc->pic_h;
-#ifdef LOSLESS_COMPRESS_MODE
-/*SUPPORT_10BIT*/
-	int losless_comp_header_size = compute_losless_comp_header_size
-			(pic_width, pic_height);
-	int losless_comp_body_size = compute_losless_comp_body_size
-			(pic_width, pic_height, hevc->mem_saving_mode);
-	int mc_buffer_size = losless_comp_header_size
-		+ losless_comp_body_size;
-	int mc_buffer_size_h = (mc_buffer_size + 0xffff)>>16;
-	if (get_double_write_mode(hevc)) {
-		int pic_width_dw = ((get_double_write_mode(hevc) == 2) ||
-			(get_double_write_mode(hevc) == 3)) ?
-			pic_width / 4 : pic_width;
-		int pic_height_dw = ((get_double_write_mode(hevc) == 2) ||
-			(get_double_write_mode(hevc) == 3)) ?
-			pic_height / 4 : pic_height;
-		int lcu_size = hevc->lcu_size;
-		int pic_width_lcu  = (pic_width_dw % lcu_size)
-			? pic_width_dw / lcu_size
-			+ 1 : pic_width_dw / lcu_size;
-		int pic_height_lcu = (pic_height_dw % lcu_size)
-			? pic_height_dw / lcu_size
-				+ 1 : pic_height_dw / lcu_size;
-		int lcu_total = pic_width_lcu * pic_height_lcu;
-		int mc_buffer_size_u_v = lcu_total * lcu_size * lcu_size / 2;
-		int mc_buffer_size_u_v_h = (mc_buffer_size_u_v + 0xffff) >> 16;
-			/*64k alignment*/
-		buf_size = ((mc_buffer_size_u_v_h << 16) * 3);
-	} else
-		buf_size = 0;
+	int lcu_total;
+	int mc_buffer_size_h;
+	int mc_buffer_size_u_v_h;
+};
 
-	if (mc_buffer_size & 0xffff) { /*64k alignment*/
-		mc_buffer_size_h += 1;
+#ifndef MV_USE_FIXED_BUF
+static void dealloc_mv_bufs(struct hevc_state_s *hevc)
+{
+	int i;
+	for (i = 0; i < MAX_REF_PIC_NUM; i++) {
+		if (hevc->m_mv_BUF[i].start_adr) {
+			if (get_dbg_flag(hevc) & H265_DEBUG_BUFMGR)
+				hevc_print(hevc, 0,
+				"dealloc mv buf(%d) adr 0x%p size 0x%x used_flag %d\n",
+				i, hevc->m_mv_BUF[i].start_adr,
+				hevc->m_mv_BUF[i].size,
+				hevc->m_mv_BUF[i].used_flag);
+			decoder_bmmu_box_free_idx(
+				hevc->bmmu_box,
+				MV_BUFFER_IDX(i));
+			hevc->m_mv_BUF[i].start_adr = 0;
+			hevc->m_mv_BUF[i].size = 0;
+			hevc->m_mv_BUF[i].used_flag = 0;
+		}
 	}
-	if (mmu_enable) {
-		if (get_double_write_mode(hevc) == 1)
-			buf_size += (mc_buffer_size_h << 16);
+}
+
+static int alloc_mv_buf(struct hevc_state_s *hevc, int i)
+{
+	int ret = 0;
+	/*get_cma_alloc_ref();*/ /*DEBUG_TMP*/
+	if (decoder_bmmu_box_alloc_buf_phy
+		(hevc->bmmu_box,
+		MV_BUFFER_IDX(i), hevc->mv_buf_size,
+		DRIVER_NAME,
+		&hevc->m_mv_BUF[i].start_adr) < 0) {
+		hevc->m_mv_BUF[i].start_adr = 0;
+		ret = -1;
 	} else {
-	if ((get_double_write_mode(hevc) & 0x10) == 0)
-		buf_size += (mc_buffer_size_h << 16);
-	}
-#else
-		int lcu_size = hevc->lcu_size;
-		int pic_width_lcu =
-			(pic_width % lcu_size) ? pic_width / lcu_size
-				+ 1 : pic_width / lcu_size;
-		int pic_height_lcu =
-			(pic_height % lcu_size) ? pic_height / lcu_size
-				+ 1 : pic_height / lcu_size;
-		int lcu_total = pic_width_lcu * pic_height_lcu;
-		int mc_buffer_size_u_v = lcu_total * lcu_size * lcu_size / 2;
-			int mc_buffer_size_u_v_h =
-				(mc_buffer_size_u_v + 0xffff) >> 16;
-					/*64k alignment*/
-		buf_size = (mc_buffer_size_u_v_h << 16) * 3;
-#endif
-		if (get_dbg_flag(hevc)) {
+		hevc->m_mv_BUF[i].size = hevc->mv_buf_size;
+		hevc->m_mv_BUF[i].used_flag = 0;
+		ret = 0;
+		if (get_dbg_flag(hevc) & H265_DEBUG_BUFMGR) {
 			hevc_print(hevc, 0,
-			"init_buf_list num %d (width %d height %d):\n",
-			 hevc->used_buf_num, pic_width, pic_height);
+			"MV Buffer %d: start_adr %p size %x\n",
+			i,
+			(void *)hevc->m_mv_BUF[i].start_adr,
+			hevc->m_mv_BUF[i].size);
 		}
 	}
+	/*put_cma_alloc_ref();*/ /*DEBUG_TMP*/
+	return ret;
+}
+#endif
 
-	hevc_print(hevc, 0, "allocate begin\n");
-	//get_cma_alloc_ref();//DEBUG_TMP
-	for (i = 0; i < hevc->used_buf_num; i++) {
-		if (((i + 1) * buf_size) > hevc->mc_buf->buf_size) {
-			if (use_cma)
-				hevc->use_cma_flag = 1;
-			else {
-				if (get_dbg_flag(hevc)) {
-					hevc_print(hevc, 0,
-						"%s maximum buf size is used\n",
-						   __func__);
-				}
-				break;
-			}
+static int get_mv_buf(struct hevc_state_s *hevc, struct PIC_s *pic)
+{
+#ifdef MV_USE_FIXED_BUF
+	if (pic && pic->index >= 0)
+		pic->mpred_mv_wr_start_addr =
+			hevc->work_space_buf->mpred_mv.buf_start
+			+ (pic->index * MPRED_MV_BUF_SIZE);
+	return 0;
+#else
+	int i;
+	int ret = -1;
+	int new_size;
+	if (pic->width > 1920 || pic->height > 1088)
+		new_size = MPRED_MV_BUF_SIZE + 0x10000; /*0x120000*/
+	else
+		new_size = 0x40000 + 0x10000;
+	if (new_size != hevc->mv_buf_size) {
+		dealloc_mv_bufs(hevc);
+		hevc->mv_buf_size = new_size;
+	}
+	for (i = 0; i < MAX_REF_PIC_NUM; i++) {
+		if (hevc->m_mv_BUF[i].start_adr &&
+			hevc->m_mv_BUF[i].used_flag == 0) {
+			hevc->m_mv_BUF[i].used_flag = 1;
+			ret = i;
+			break;
 		}
-
-
-		if (!mmu_enable) {
-			hevc->m_BUF[i].index = i;
-
-			if (use_cma == 2)
-				hevc->use_cma_flag = 1;
-			if (hevc->use_cma_flag) {
-				if (decoder_bmmu_box_alloc_idx_wait(
-				hevc->bmmu_box,
-				i,
-				buf_size,
-				-1,
-				-1,
-				BMMU_ALLOC_FLAGS_WAITCLEAR
-				) < 0) {
-					/*
-					not enough mem for buffer.
-					*/
-					hevc_print(hevc, 0,
-						"not enought buffer for [%d],%d\n",
-						i, buf_size);
-					hevc->m_BUF[i].start_adr = 0;
-					if (i <= 8) {
-						/*if alloced (i+1)>=9
-						don't send errors.*/
-						hevc->fatal_error |=
-						DECODER_FATAL_ERROR_NO_MEM;
-					}
-					break;
-				}
-				hevc->m_BUF[i].start_adr =
-					decoder_bmmu_box_get_phy_addr(
-						hevc->bmmu_box,
-						i);
-				pr_debug("allocate cma buffer[%d] %ld\n",
-					i,
-					hevc->m_BUF[i].start_adr);
-			} else {
-				hevc->m_BUF[i].start_adr =
-					hevc->mc_buf->buf_start + i * buf_size;
-				if (((hevc->m_BUF[i].start_adr + buf_size) >
-						mc_buffer_end)) {
-					if (get_dbg_flag(hevc)) {
-						hevc_print(hevc, 0,
-						"Max mc buffer or mpred_mv buffer is used\n");
-					}
-					break;
+	}
+	if (ret < 0) {
+		for (i = 0; i < MAX_REF_PIC_NUM; i++) {
+			if (hevc->m_mv_BUF[i].start_adr == 0) {
+				if (alloc_mv_buf(hevc, i) >= 0) {
+					hevc->m_mv_BUF[i].used_flag = 1;
+					ret = i;
 				}
-			}
-			hevc->m_BUF[i].size = buf_size;
-			hevc->m_BUF[i].free_start_adr =
-					hevc->m_BUF[i].start_adr;
-
-			if (get_dbg_flag(hevc)) {
-				hevc_print(hevc, 0,
-					"Buffer %d: start_adr %p size %x\n", i,
-					   (void *)hevc->m_BUF[i].start_adr,
-					   hevc->m_BUF[i].size);
+				break;
 			}
 		}
 	}
-	//put_cma_alloc_ref();//DEBUG_TMP
-	hevc_print(hevc, 0, "allocate end\n");
 
-	hevc->buf_num = i;
+	if (ret >= 0) {
+		pic->mv_buf_index = ret;
+		pic->mpred_mv_wr_start_addr =
+			(hevc->m_mv_BUF[ret].start_adr + 0xffff) &
+			(~0xffff);
+		hevc_print(hevc, H265_DEBUG_BUFMGR_MORE,
+		"%s => %d (0x%x) size 0x%x\n",
+		__func__, ret,
+		pic->mpred_mv_wr_start_addr,
+		hevc->m_mv_BUF[ret].size);
+
+	} else {
+		hevc_print(hevc, 0,
+		"%s: Error, mv buf is not enough\n",
+		__func__);
+	}
+	return ret;
+
+#endif
+}
+
+static void put_mv_buf(struct hevc_state_s *hevc,
+	struct PIC_s *pic)
+{
+#ifndef MV_USE_FIXED_BUF
+	int i = pic->mv_buf_index;
+	if (i < 0 || i >= MAX_REF_PIC_NUM) {
+		hevc_print(hevc, H265_DEBUG_BUFMGR_MORE,
+		"%s: index %d beyond range\n",
+		__func__, i);
+		return;
+	}
+	hevc_print(hevc, H265_DEBUG_BUFMGR_MORE,
+	"%s(%d): used_flag(%d)\n",
+	__func__, i,
+	hevc->m_mv_BUF[i].used_flag);
 
+	if (hevc->m_mv_BUF[i].start_adr &&
+		hevc->m_mv_BUF[i].used_flag)
+		hevc->m_mv_BUF[i].used_flag = 0;
+#endif
 }
 
-static int config_pic(struct hevc_state_s *hevc, struct PIC_s *pic,
-						unsigned int last_disp_addr)
+static int cal_current_buf_size(struct hevc_state_s *hevc,
+	struct buf_stru_s *buf_stru)
 {
-	int ret = -1;
-	int i;
-	int pic_width = ((re_config_pic_flag == 0) &&
-		get_buf_alloc_width(hevc)) ?
-		get_buf_alloc_width(hevc) : hevc->pic_w;
-	int pic_height = ((re_config_pic_flag == 0) &&
-		get_buf_alloc_height(hevc)) ?
-		get_buf_alloc_height(hevc) : hevc->pic_h;
+
+	int buf_size;
+	int pic_width = hevc->pic_w;
+	int pic_height = hevc->pic_h;
 	int lcu_size = hevc->lcu_size;
 	int pic_width_lcu = (pic_width % lcu_size) ? pic_width / lcu_size +
 				 1 : pic_width / lcu_size;
 	int pic_height_lcu = (pic_height % lcu_size) ? pic_height / lcu_size +
 				 1 : pic_height / lcu_size;
-	int lcu_total = pic_width_lcu * pic_height_lcu;
-	int lcu_size_log2 = hevc->lcu_size_log2;
-	/*int MV_MEM_UNIT=lcu_size_log2==
-		6 ? 0x100 : lcu_size_log2==5 ? 0x40 : 0x10;*/
-	int MV_MEM_UNIT = lcu_size_log2 == 6 ? 0x200 : lcu_size_log2 ==
-					 5 ? 0x80 : 0x20;
-	int mpred_mv_end = hevc->work_space_buf->mpred_mv.buf_start +
-				 hevc->work_space_buf->mpred_mv.buf_size;
-	unsigned int y_adr = 0;
-	int buf_size = 0;
-#ifdef LOSLESS_COMPRESS_MODE
-/*SUPPORT_10BIT*/
-	int losless_comp_header_size =
-		compute_losless_comp_header_size(pic_width,
-				 pic_height);
-	int losless_comp_body_size = compute_losless_comp_body_size(pic_width,
-			 pic_height, hevc->mem_saving_mode);
-	int mc_buffer_size = losless_comp_header_size + losless_comp_body_size;
-	int mc_buffer_size_h = (mc_buffer_size + 0xffff)>>16;
-	int mc_buffer_size_u_v = 0;
+	/*SUPPORT_10BIT*/
+	int losless_comp_header_size = compute_losless_comp_header_size
+		(pic_width, pic_height);
+		/*always alloc buf for 10bit*/
+	int losless_comp_body_size = compute_losless_comp_body_size
+		(hevc, pic_width, pic_height, 0);
+	int mc_buffer_size = losless_comp_header_size
+		+ losless_comp_body_size;
+	int mc_buffer_size_h = (mc_buffer_size + 0xffff) >> 16;
 	int mc_buffer_size_u_v_h = 0;
+
+	if (hevc->mmu_enable)
+		buf_size =
+		((MMU_COMPRESS_HEADER_SIZE + 0xffff) >> 16)
+			<< 16;
+	else
+		buf_size = 0;
+
 	if (get_double_write_mode(hevc)) {
 		int pic_width_dw = ((get_double_write_mode(hevc) == 2) ||
 			(get_double_write_mode(hevc) == 3)) ?
@@ -1974,6 +2168,7 @@ static int config_pic(struct hevc_state_s *hevc, struct PIC_s *pic,
 		int pic_height_dw = ((get_double_write_mode(hevc) == 2) ||
 			(get_double_write_mode(hevc) == 3)) ?
 			pic_height / 4 : pic_height;
+
 		int pic_width_lcu_dw = (pic_width_dw % lcu_size) ?
 			pic_width_dw / lcu_size + 1 :
 			pic_width_dw / lcu_size;
@@ -1982,263 +2177,287 @@ static int config_pic(struct hevc_state_s *hevc, struct PIC_s *pic,
 			pic_height_dw / lcu_size;
 		int lcu_total_dw = pic_width_lcu_dw * pic_height_lcu_dw;
 
-		mc_buffer_size_u_v = lcu_total_dw * lcu_size * lcu_size / 2;
+		int mc_buffer_size_u_v = lcu_total_dw * lcu_size * lcu_size / 2;
 		mc_buffer_size_u_v_h = (mc_buffer_size_u_v + 0xffff) >> 16;
 			/*64k alignment*/
-		buf_size = ((mc_buffer_size_u_v_h << 16) * 3);
-	}
-	if (mc_buffer_size & 0xffff) { /*64k alignment*/
-		mc_buffer_size_h += 1;
+		buf_size += ((mc_buffer_size_u_v_h << 16) * 3);
 	}
-	if (mmu_enable) {
-		if (get_double_write_mode(hevc) == 1)
-			buf_size += (mc_buffer_size_h << 16);
-	} else {
-	if ((get_double_write_mode(hevc) & 0x10) == 0)
+
+	if ((!hevc->mmu_enable) &&
+		((get_double_write_mode(hevc) & 0x10) == 0)) {
+		/* use compress mode without mmu,
+		need buf for compress decoding*/
 		buf_size += (mc_buffer_size_h << 16);
 	}
-#else
-	int mc_buffer_size_u_v = lcu_total * lcu_size * lcu_size / 2;
-	int mc_buffer_size_u_v_h = (mc_buffer_size_u_v + 0xffff) >> 16;
-			/*64k alignment*/
-	buf_size = ((mc_buffer_size_u_v_h << 16) * 3);
-#endif
-
 
-		if (mmu_enable) {
-			if ((hevc->work_space_buf->cm_header.buf_start +
-			   ((pic->index + 1)
-			   * MMU_COMPRESS_HEADER_SIZE))
-			   > (hevc->work_space_buf->cm_header.buf_start +
-			   hevc->work_space_buf->cm_header.buf_size)) {
-				hevc_print(hevc, 0,
-					"MMU header_adr allocate fail\n");
-				return -1;
-		}
+	/*in case start adr is not 64k alignment*/
+	if (buf_size > 0)
+		buf_size += 0x10000;
 
-		   pic->header_adr = hevc->work_space_buf->cm_header.buf_start +
-				(pic->index * MMU_COMPRESS_HEADER_SIZE);
-	if (last_disp_addr && pic->header_adr == last_disp_addr) {
-		/*if same as disp add used last one.*/
-		pr_info("same as disp %d: %d\n",
-			pic->index, pic->header_adr);
-		pic->header_adr =
-			hevc->work_space_buf->cm_header.buf_start +
-			(16 * MMU_COMPRESS_HEADER_SIZE);
+	if (buf_stru) {
+		buf_stru->lcu_total = pic_width_lcu * pic_height_lcu;
+		buf_stru->mc_buffer_size_h = mc_buffer_size_h;
+		buf_stru->mc_buffer_size_u_v_h = mc_buffer_size_u_v_h;
 	}
-			if (get_dbg_flag(hevc)&H265_DEBUG_BUFMGR) {
-				hevc_print(hevc, 0,
-					"MMU header_adr %d: %x\n",
-					pic->index, pic->header_adr);
-			}
-		}
-
-
-	if ((hevc->work_space_buf->mpred_mv.buf_start + (((pic->index + 1)
-					* lcu_total) * MV_MEM_UNIT))
-						<= mpred_mv_end) {
-
-		if (!mmu_enable) {
-			for (i = 0; i < hevc->buf_num; i++) {
-				y_adr = ((hevc->m_BUF[i].free_start_adr
-					+ 0xffff) >> 16) << 16;
-					/*64k alignment*/
-				if ((y_adr+buf_size) <=
-						(hevc->m_BUF[i].start_adr+
-						hevc->m_BUF[i].size)) {
-					hevc->m_BUF[i].free_start_adr =
-						y_adr + buf_size;
-					break;
-				}
-		}
-	} else
-		i = pic->index;
-
-	if (i < hevc->buf_num) {
-			pic->POC = INVALID_POC;
-			/*ensure get_pic_by_POC()
-			not get the buffer not decoded*/
-			pic->BUF_index = i;
-#ifdef LOSLESS_COMPRESS_MODE
-/*SUPPORT_10BIT*/
-			pic->comp_body_size = losless_comp_body_size;
-			pic->buf_size = buf_size;
-
-			if (!mmu_enable)
-				pic->mc_y_adr = y_adr;
-			else if (get_double_write_mode(hevc)) {
-				if ((hevc->mc_buf->buf_start
-					+ (i + 1) * buf_size)
-					< hevc->mc_buf->buf_end)
-					y_adr = hevc->mc_buf->buf_start
-							+ i * buf_size;
-				else {
-					if (decoder_bmmu_box_alloc_idx_wait(
-						hevc->bmmu_box,
-						pic->BUF_index,
-						buf_size,
-						-1,
-						-1,
-						BMMU_ALLOC_FLAGS_WAITCLEAR
-						) < 0) {
-						return -1;
-					}
-					pic->cma_alloc_addr =
-						decoder_bmmu_box_get_phy_addr(
-							hevc->bmmu_box,
-							pic->BUF_index);
-					if (pic->cma_alloc_addr)
-						y_adr = pic->cma_alloc_addr;
-					else
-						return -1;
-				}
-			}
-			pic->mc_canvas_y = pic->index;
-			pic->mc_canvas_u_v = pic->index;
-			if (!mmu_enable && get_double_write_mode(hevc) & 0x10) {
-				pic->mc_u_v_adr = y_adr +
-					((mc_buffer_size_u_v_h << 16) << 1);
-
-				pic->mc_canvas_y = (pic->index << 1);
-				pic->mc_canvas_u_v = (pic->index << 1) + 1;
-
-				pic->dw_y_adr = y_adr;
-				pic->dw_u_v_adr = pic->mc_u_v_adr;
-			} else if (get_double_write_mode(hevc)) {
-					if (mmu_enable)
-						pic->dw_y_adr = y_adr;
-					else
-						pic->dw_y_adr = y_adr +
-						(mc_buffer_size_h << 16);
-					pic->dw_u_v_adr = pic->dw_y_adr +
-					((mc_buffer_size_u_v_h << 16) << 1);
-			}
-#else
-			pic->buf_size = (mc_buffer_size_u_v_h << 16) * 3;
-			pic->mc_y_adr = y_adr;
-			pic->mc_u_v_adr = y_adr +
-				((mc_buffer_size_u_v_h << 16) << 1);
+	return buf_size;
+}
 
-			pic->mc_canvas_y = (pic->index << 1);
-			pic->mc_canvas_u_v = (pic->index << 1) + 1;
-#endif
-			pic->mpred_mv_wr_start_addr =
-				hevc->work_space_buf->mpred_mv.buf_start +
-						((pic->index * lcu_total)
-						* MV_MEM_UNIT);
+static int alloc_buf(struct hevc_state_s *hevc)
+{
+	int i;
+	int ret = -1;
+	int buf_size = cal_current_buf_size(hevc, NULL);
 
-			if (get_dbg_flag(hevc)) {
-				hevc_print(hevc, 0,
-				"%s index %d BUF_index %d mc_y_adr %x ",
-				 __func__, pic->index,
-				 pic->BUF_index, pic->mc_y_adr);
-#ifdef LOSLESS_COMPRESS_MODE
-				hevc_print_cont(hevc, 0,
-				"comp_body_size %x comp_buf_size %x ",
-				 pic->comp_body_size, pic->buf_size);
-				hevc_print_cont(hevc, 0,
-				"mpred_mv_wr_start_adr %x\n",
-				 pic->mpred_mv_wr_start_addr);
-				if (mmu_enable && get_double_write_mode(hevc))
+	for (i = 0; i < BUF_POOL_SIZE; i++) {
+		if (hevc->m_BUF[i].start_adr == 0)
+			break;
+	}
+	if (i < BUF_POOL_SIZE) {
+		if (buf_size > 0) {
+			/*get_cma_alloc_ref();*/ /*DEBUG_TMP*/
+			/*alloc compress header first*/
+
+			if (decoder_bmmu_box_alloc_buf_phy
+				(hevc->bmmu_box,
+				VF_BUFFER_IDX(i), buf_size,
+				DRIVER_NAME,
+				&hevc->m_BUF[i].start_adr) < 0)
+				hevc->m_BUF[i].start_adr = 0;
+			else {
+				hevc->m_BUF[i].size = buf_size;
+				hevc->m_BUF[i].used_flag = 0;
+				ret = 0;
+				if (get_dbg_flag(hevc) & H265_DEBUG_BUFMGR) {
 					hevc_print(hevc, 0,
-					"mmu double write  adr %ld\n",
-					 pic->cma_alloc_addr);
-
-#else
-				hevc_print(hevc, 0,
-				("mc_u_v_adr %x mpred_mv_wr_start_adr %x\n",
-				 pic->mc_u_v_adr, pic->mpred_mv_wr_start_addr);
-#endif
+					"Buffer %d: start_adr %p size %x\n",
+					i,
+					(void *)hevc->m_BUF[i].start_adr,
+					hevc->m_BUF[i].size);
+				}
 			}
+			/*put_cma_alloc_ref();*/ /*DEBUG_TMP*/
+		} else
 			ret = 0;
+	}
+	if (ret >= 0) {
+		if (get_dbg_flag(hevc) & H265_DEBUG_BUFMGR) {
+			hevc_print(hevc, 0,
+			"alloc buf(%d) for %d/%d size 0x%x) => %p\n",
+			i, hevc->pic_w, hevc->pic_h,
+			buf_size,
+			hevc->m_BUF[i].start_adr);
+		}
+	} else {
+		if (get_dbg_flag(hevc) & H265_DEBUG_BUFMGR) {
+			hevc_print(hevc, 0,
+			"alloc buf(%d) for %d/%d size 0x%x) => Fail!!!\n",
+			i, hevc->pic_w, hevc->pic_h,
+			buf_size);
 		}
 	}
 	return ret;
 }
 
-/*
-*free hevc->m_BUF[..] for all free hevc->m_PIC[..]
-* with the different size of hevc->pic_w,hevc->pic_h
-*/
-static int recycle_buf(struct hevc_state_s *hevc)
+static void set_buf_unused(struct hevc_state_s *hevc, int i)
 {
-	int i, j;
+	if (i >= 0 && i < BUF_POOL_SIZE)
+		hevc->m_BUF[i].used_flag = 0;
+}
 
-	for (i = 0; i < MAX_REF_PIC_NUM; i++) {
-		struct PIC_s *pic = hevc->m_PIC[i];
-		if (pic == NULL || pic->index == -1)
-			continue;
-		if (pic->width != hevc->pic_w || pic->height != hevc->pic_h) {
-			if (pic->output_mark == 0 && pic->referenced == 0
-				&& pic->output_ready == 0) {
-				if (mmu_enable) {
-					decoder_mmu_box_free_idx(hevc->mmu_box,
-						pic->index);
-				}
-				pic->BUF_index = -1;
-				if (get_dbg_flag(hevc)) {
-					hevc_print(hevc, 0,
-						"%s: %d\n", __func__,
-						   pic->index);
-				}
+static void dealloc_unused_buf(struct hevc_state_s *hevc)
+{
+	int i;
+	for (i = 0; i < BUF_POOL_SIZE; i++) {
+		if (hevc->m_BUF[i].start_adr &&
+			hevc->m_BUF[i].used_flag == 0) {
+			if (get_dbg_flag(hevc) & H265_DEBUG_BUFMGR) {
+				hevc_print(hevc, 0,
+					"dealloc buf(%d) adr 0x%p size 0x%x\n",
+					i, hevc->m_BUF[i].start_adr,
+					hevc->m_BUF[i].size);
 			}
+			decoder_bmmu_box_free_idx(
+				hevc->bmmu_box,
+				VF_BUFFER_IDX(i));
+			hevc->m_BUF[i].start_adr = 0;
+			hevc->m_BUF[i].size = 0;
 		}
 	}
 
-	for (i = 0; i < hevc->buf_num; i++) {
-		if (hevc->m_BUF[i].free_start_adr !=
-			hevc->m_BUF[i].start_adr) {
-			for (j = 0; j < MAX_REF_PIC_NUM; j++) {
-				struct PIC_s *pic = hevc->m_PIC[j];
-				if (pic == NULL || pic->index == -1)
-					continue;
-				if (pic->BUF_index == i)
-					break;
-			}
-			if (j == MAX_REF_PIC_NUM)
-				hevc->m_BUF[i].free_start_adr =
-				    hevc->m_BUF[i].start_adr;
+}
+
+static void dealloc_pic_buf(struct hevc_state_s *hevc,
+	struct PIC_s *pic)
+{
+	int i = pic->BUF_index;
+	pic->BUF_index = -1;
+	if (i >= 0 &&
+		i < BUF_POOL_SIZE &&
+		hevc->m_BUF[i].start_adr) {
+		if (get_dbg_flag(hevc) & H265_DEBUG_BUFMGR) {
+			hevc_print(hevc, 0,
+				"dealloc buf(%d) adr 0x%p size 0x%x\n",
+				i, hevc->m_BUF[i].start_adr,
+				hevc->m_BUF[i].size);
 		}
+		decoder_bmmu_box_free_idx(
+			hevc->bmmu_box,
+			VF_BUFFER_IDX(i));
+		hevc->m_BUF[i].used_flag = 0;
+		hevc->m_BUF[i].start_adr = 0;
+		hevc->m_BUF[i].size = 0;
 	}
-	return 0;
 }
 
-static void init_pic_list(struct hevc_state_s *hevc)
+static int get_work_pic_num(struct hevc_state_s *hevc)
+{
+	int used_buf_num = 0;
+	if (get_dynamic_buf_num_margin(hevc) > 0) {
+		used_buf_num = hevc->sps_num_reorder_pics_0
+			+ get_dynamic_buf_num_margin(hevc);
+#ifdef MULTI_INSTANCE_SUPPORT
+		/*
+		need one more for multi instance, as
+		apply_ref_pic_set() has no chanch to run to
+		to clear referenced flag in some case
+		*/
+		if (hevc->m_ins_flag)
+			used_buf_num++;
+#endif
+	} else
+		used_buf_num = max_buf_num;
+
+	if (used_buf_num > MAX_BUF_NUM)
+		used_buf_num = MAX_BUF_NUM;
+	return used_buf_num;
+}
+
+static int get_alloc_pic_count(struct hevc_state_s *hevc)
 {
+	int alloc_pic_count = 0;
 	int i;
-	struct vframe_s vf;
-	unsigned long flags;
-	unsigned long disp_addr = 0;
+	struct PIC_s *pic;
+	for (i = 0; i < MAX_REF_PIC_NUM; i++) {
+		pic = hevc->m_PIC[i];
+		if (pic && pic->index >= 0)
+			alloc_pic_count++;
+	}
+	return alloc_pic_count;
+}
 
-	if (!get_video0_frame_info(&vf)) {
-		spin_lock_irqsave(&lock, flags);
-		if (vf.type & VIDTYPE_SCATTER) {
-			/*sc only used header.*/
-			disp_addr = (VSYNC_RD_MPEG_REG(AFBC_HEAD_BADDR) << 4);
-		} else if (vf.type & VIDTYPE_COMPRESS) {
-			/*sc checked body.*/
-			disp_addr = (VSYNC_RD_MPEG_REG(AFBC_BODY_BADDR) << 4);
-		} else {
-			struct canvas_s cur_canvas;
+static int config_pic(struct hevc_state_s *hevc, struct PIC_s *pic)
+{
+	int ret = -1;
+	int i;
+	/*int lcu_size_log2 = hevc->lcu_size_log2;
+	int MV_MEM_UNIT=lcu_size_log2==
+		6 ? 0x100 : lcu_size_log2==5 ? 0x40 : 0x10;*/
+	/*int MV_MEM_UNIT = lcu_size_log2 == 6 ? 0x200 : lcu_size_log2 ==
+					 5 ? 0x80 : 0x20;
+	int mpred_mv_end = hevc->work_space_buf->mpred_mv.buf_start +
+				 hevc->work_space_buf->mpred_mv.buf_size;*/
+	unsigned int y_adr = 0;
+	struct buf_stru_s buf_stru;
+	int buf_size = cal_current_buf_size(hevc, &buf_stru);
+
+	for (i = 0; i < BUF_POOL_SIZE; i++) {
+		if (hevc->m_BUF[i].start_adr != 0 &&
+			hevc->m_BUF[i].used_flag == 0 &&
+			buf_size <= hevc->m_BUF[i].size) {
+			hevc->m_BUF[i].used_flag = 1;
+			break;
+		}
+	}
+	if (i >= BUF_POOL_SIZE)
+		return -1;
+
+	if (hevc->mmu_enable) {
+		pic->header_adr = hevc->m_BUF[i].start_adr;
+		y_adr = hevc->m_BUF[i].start_adr + MMU_COMPRESS_HEADER_SIZE;
+	} else
+		y_adr = hevc->m_BUF[i].start_adr;
+
+	y_adr = ((y_adr + 0xffff) >> 16) << 16; /*64k alignment*/
+	pic->POC = INVALID_POC;
+	/*ensure get_pic_by_POC()
+	not get the buffer not decoded*/
+	pic->BUF_index = i;
+
+	if ((!hevc->mmu_enable) &&
+		((get_double_write_mode(hevc) & 0x10) == 0)
+		) {
+		pic->mc_y_adr = y_adr;
+		y_adr += (buf_stru.mc_buffer_size_h << 16);
+	}
+	pic->mc_canvas_y = pic->index;
+	pic->mc_canvas_u_v = pic->index;
+	if (get_double_write_mode(hevc) & 0x10) {
+		pic->mc_y_adr = y_adr;
+		pic->mc_u_v_adr = y_adr +
+			((buf_stru.mc_buffer_size_u_v_h << 16) << 1);
+
+		pic->mc_canvas_y = (pic->index << 1);
+		pic->mc_canvas_u_v = (pic->index << 1) + 1;
+
+		pic->dw_y_adr = pic->mc_y_adr;
+		pic->dw_u_v_adr = pic->mc_u_v_adr;
+	} else if (get_double_write_mode(hevc)) {
+		pic->dw_y_adr = y_adr;
+		pic->dw_u_v_adr = pic->dw_y_adr +
+		((buf_stru.mc_buffer_size_u_v_h << 16) << 1);
+	}
 
-			canvas_read(vf.canvas0Addr & 0xff, &cur_canvas);
-			disp_addr = cur_canvas.addr;
+
+	if (get_dbg_flag(hevc) & H265_DEBUG_BUFMGR) {
+		hevc_print(hevc, 0,
+		"%s index %d BUF_index %d mc_y_adr %x\n",
+		 __func__, pic->index,
+		 pic->BUF_index, pic->mc_y_adr);
+		if (hevc->mmu_enable &&
+			get_double_write_mode(hevc))
+			hevc_print(hevc, 0,
+			"mmu double write  adr %ld\n",
+			 pic->cma_alloc_addr);
+
+
+	}
+	ret = 0;
+
+	return ret;
+}
+
+static void init_pic_list(struct hevc_state_s *hevc)
+{
+	int i;
+	int init_buf_num = get_work_pic_num(hevc);
+
+	/*alloc decoder buf*/
+	for (i = 0; i < init_buf_num; i++) {
+		if (alloc_buf(hevc) < 0) {
+			if (i <= 8) {
+				/*if alloced (i+1)>=9
+				don't send errors.*/
+				hevc->fatal_error |=
+				DECODER_FATAL_ERROR_NO_MEM;
+			}
+			break;
 		}
-		spin_unlock_irqrestore(&lock, flags);
 	}
-	for (i = 0; i < MAX_REF_PIC_NUM; i++) {
+
+	for (i = 0; i < init_buf_num; i++) {
 		struct PIC_s *pic =
 			vmalloc(sizeof(struct PIC_s));
 		if (pic == NULL) {
 			hevc_print(hevc, 0,
-				"alloc pic %d fail\n", i);
+				"%s: alloc pic %d fail!!!\n",
+				__func__, i);
 			break;
 		}
 		memset(pic, 0, sizeof(struct PIC_s));
 		hevc->m_PIC[i] = pic;
 		pic->index = i;
 		pic->BUF_index = -1;
-		if (config_pic(hevc, pic, disp_addr) < 0) {
+		if (config_pic(hevc, pic) < 0) {
 			if (get_dbg_flag(hevc))
 				hevc_print(hevc, 0,
 					"Config_pic %d fail\n", pic->index);
@@ -2257,7 +2476,8 @@ static void init_pic_list(struct hevc_state_s *hevc)
 			vmalloc(sizeof(struct PIC_s));
 		if (pic == NULL) {
 			hevc_print(hevc, 0,
-				"alloc pic %d fail\n", i);
+				"%s: alloc pic %d fail!!!\n",
+				__func__, i);
 			break;
 		}
 		memset(pic, 0, sizeof(struct PIC_s));
@@ -2271,6 +2491,9 @@ static void init_pic_list(struct hevc_state_s *hevc)
 static void uninit_pic_list(struct hevc_state_s *hevc)
 {
 	int i;
+#ifndef MV_USE_FIXED_BUF
+	dealloc_mv_bufs(hevc);
+#endif
 	for (i = 0; i < MAX_REF_PIC_NUM; i++) {
 		struct PIC_s *pic = hevc->m_PIC[i];
 		if (pic) {
@@ -2291,13 +2514,13 @@ static void init_decode_head_hw(struct hevc_state_s *hevc)
 	int losless_comp_header_size =
 		compute_losless_comp_header_size(hevc->pic_w,
 			 hevc->pic_h);
-	int losless_comp_body_size = compute_losless_comp_body_size(hevc->pic_w,
-		 hevc->pic_h, hevc->mem_saving_mode);
+	int losless_comp_body_size = compute_losless_comp_body_size(hevc,
+		hevc->pic_w, hevc->pic_h, hevc->mem_saving_mode);
 
 	hevc->losless_comp_body_size = losless_comp_body_size;
 
 
-	if (mmu_enable) {
+	if (hevc->mmu_enable) {
 		WRITE_VREG(HEVCD_MPP_DECOMP_CTL1, (0x1 << 4));
 		WRITE_VREG(HEVCD_MPP_DECOMP_CTL2, 0x0);
 	} else {
@@ -2317,7 +2540,7 @@ static void init_decode_head_hw(struct hevc_state_s *hevc)
 	WRITE_VREG(HEVC_CM_HEADER_OFFSET, losless_comp_body_size);
 	WRITE_VREG(HEVC_CM_HEADER_LENGTH, losless_comp_header_size);
 
-	if (mmu_enable) {
+	if (hevc->mmu_enable) {
 		WRITE_VREG(HEVC_SAO_MMU_VH0_ADDR, buf_spec->mmu_vbh.buf_start);
 		WRITE_VREG(HEVC_SAO_MMU_VH1_ADDR,
 			buf_spec->mmu_vbh.buf_start +
@@ -2360,7 +2583,7 @@ static void init_pic_list_hw(struct hevc_state_s *hevc)
 			break;
 		}
 		if (get_cpu_type() >= MESON_CPU_MAJOR_ID_GXL) {
-			if (mmu_enable)
+			if (hevc->mmu_enable)
 				WRITE_VREG(HEVCD_MPP_ANC2AXI_TBL_DATA,
 					hevc->m_PIC[i]->header_adr>>5);
 			else
@@ -2372,7 +2595,7 @@ static void init_pic_list_hw(struct hevc_state_s *hevc)
 				(hevc->m_PIC[i]->mc_canvas_y << 8) | 0x1);
 		if (get_double_write_mode(hevc) & 0x10) {
 			if (get_cpu_type() >= MESON_CPU_MAJOR_ID_GXL) {
-				if (mmu_enable)
+				if (hevc->mmu_enable)
 					WRITE_VREG(HEVCD_MPP_ANC2AXI_TBL_DATA,
 						hevc->m_PIC[i]->header_adr>>5);
 				else
@@ -2390,7 +2613,7 @@ static void init_pic_list_hw(struct hevc_state_s *hevc)
 		return;
 	for (; i < MAX_REF_PIC_NUM; i++) {
 		if (get_cpu_type() >= MESON_CPU_MAJOR_ID_GXL) {
-			if (mmu_enable)
+			if (hevc->mmu_enable)
 				WRITE_VREG(HEVCD_MPP_ANC2AXI_TBL_DATA,
 				hevc->m_PIC[cur_pic_num-1]->header_adr>>5);
 			else
@@ -2441,8 +2664,14 @@ static void dump_pic_list(struct hevc_state_s *hevc)
 		if (pic == NULL || pic->index == -1)
 			continue;
 		hevc_print_cont(hevc, 0,
-		"index %d decode_idx:%d,	POC:%d,	referenced:%d,	",
-		 pic->index, pic->decode_idx, pic->POC, pic->referenced);
+		"index %d buf_idx %d mv_idx %d decode_idx:%d,	POC:%d,	referenced:%d,	",
+		 pic->index, pic->BUF_index,
+#ifndef MV_USE_FIXED_BUF
+		pic->mv_buf_index,
+#else
+		 -1,
+#endif
+		 pic->decode_idx, pic->POC, pic->referenced);
 		hevc_print_cont(hevc, 0,
 			"num_reorder_pic:%d, output_mark:%d, w/h %d,%d",
 				pic->num_reorder_pic, pic->output_mark,
@@ -2462,11 +2691,13 @@ static struct PIC_s *output_pic(struct hevc_state_s *hevc,
 	struct PIC_s *pic;
 	struct PIC_s *pic_display = NULL;
 
-	if (i_only_flag & 0x4) {
+	if (hevc->i_only & 0x4) {
 		for (i = 0; i < MAX_REF_PIC_NUM; i++) {
 			pic = hevc->m_PIC[i];
 			if (pic == NULL ||
-				(pic->index == -1) || (pic->POC == INVALID_POC))
+				(pic->index == -1) ||
+				(pic->BUF_index == -1) ||
+				(pic->POC == INVALID_POC))
 				continue;
 			if (pic->output_mark) {
 				if (pic_display) {
@@ -2484,12 +2715,15 @@ static struct PIC_s *output_pic(struct hevc_state_s *hevc,
 			pic_display->recon_mark = 0;
 			pic_display->output_ready = 1;
 			pic_display->referenced = 0;
+			put_mv_buf(hevc, pic_display);
 		}
 	} else {
 		for (i = 0; i < MAX_REF_PIC_NUM; i++) {
 			pic = hevc->m_PIC[i];
 			if (pic == NULL ||
-				(pic->index == -1) || (pic->POC == INVALID_POC))
+				(pic->index == -1) ||
+				(pic->BUF_index == -1) ||
+				(pic->POC == INVALID_POC))
 				continue;
 			if (pic->output_mark)
 				num_pic_not_yet_display++;
@@ -2498,7 +2732,9 @@ static struct PIC_s *output_pic(struct hevc_state_s *hevc,
 		for (i = 0; i < MAX_REF_PIC_NUM; i++) {
 			pic = hevc->m_PIC[i];
 			if (pic == NULL ||
-				(pic->index == -1) || (pic->POC == INVALID_POC))
+				(pic->index == -1) ||
+				(pic->BUF_index == -1) ||
+				(pic->POC == INVALID_POC))
 				continue;
 			if (pic->output_mark) {
 				if (pic_display) {
@@ -2568,18 +2804,17 @@ static int config_mc_buffer(struct hevc_state_s *hevc, struct PIC_s *cur_pic)
 						" mc_canvas_y %x\n",
 					 pic->mc_canvas_y);
 				}
-			} else {
-				if (get_dbg_flag(hevc)) {
-					hevc_print_cont(hevc, 0,
-					"Error %s, %dth poc (%d)",
-					 __func__, i,
-					 cur_pic->m_aiRefPOCList0[cur_pic->
-					 slice_idx][i]);
-					hevc_print_cont(hevc, 0,
-					" of RPS is not in the pic list0\n");
-				}
+			} else
 				cur_pic->error_mark = 1;
-				/* dump_lmem(); */
+
+			if (pic == NULL || pic->error_mark) {
+				hevc_print(hevc, 0,
+				"Error %s, %dth poc (%d) %s",
+				 __func__, i,
+				 cur_pic->m_aiRefPOCList0[cur_pic->
+				 slice_idx][i],
+				 pic ? "has error" :
+				 "not in list0");
 			}
 		}
 	}
@@ -2611,18 +2846,17 @@ static int config_mc_buffer(struct hevc_state_s *hevc, struct PIC_s *cur_pic)
 						" mc_canvas_y %x\n",
 					 pic->mc_canvas_y);
 				}
-			} else {
-				if (get_dbg_flag(hevc)) {
-					hevc_print_cont(hevc, 0,
-					"Error %s, %dth poc (%d)",
-					 __func__, i,
-					 cur_pic->m_aiRefPOCList1[cur_pic->
-					 slice_idx][i]);
-					hevc_print_cont(hevc, 0,
-					" of RPS is not in the pic list1\n");
-				}
+			} else
 				cur_pic->error_mark = 1;
-				/* dump_lmem(); */
+
+			if (pic == NULL || pic->error_mark) {
+				hevc_print(hevc, 0,
+				"Error %s, %dth poc (%d) %s",
+				 __func__, i,
+				 cur_pic->m_aiRefPOCList1[cur_pic->
+				 slice_idx][i],
+				 pic ? "has error" :
+				 "not in list1");
 			}
 		}
 	}
@@ -2636,12 +2870,14 @@ static void apply_ref_pic_set(struct hevc_state_s *hevc, int cur_poc,
 	int poc_tmp;
 	struct PIC_s *pic;
 	unsigned char is_referenced;
-
-	/* pr_info("%s cur_poc %d\n", __func__, cur_poc); */
+	/* hevc_print(hevc, 0,
+	"%s cur_poc %d\n", __func__, cur_poc); */
 	for (ii = 0; ii < MAX_REF_PIC_NUM; ii++) {
 		pic = hevc->m_PIC[ii];
 		if (pic == NULL ||
-			pic->index == -1)
+			pic->index == -1 ||
+			pic->BUF_index == -1
+			)
 			continue;
 
 		if ((pic->referenced == 0 || pic->POC == cur_poc))
@@ -2663,13 +2899,15 @@ static void apply_ref_pic_set(struct hevc_state_s *hevc, int cur_poc,
 				poc_tmp = cur_poc + delt;
 			if (poc_tmp == pic->POC) {
 				is_referenced = 1;
-				/* pr_info("i is %d\n", i); */
+				/* hevc_print(hevc, 0, "i is %d\n", i); */
 				break;
 			}
 		}
 		if (is_referenced == 0) {
 			pic->referenced = 0;
-			/* pr_info("set poc %d reference to 0\n", pic->POC); */
+			put_mv_buf(hevc, pic);
+			/* hevc_print(hevc, 0,
+			"set poc %d reference to 0\n", pic->POC); */
 		}
 	}
 
@@ -3098,7 +3336,7 @@ static void hevc_config_work_space_hw(struct hevc_state_s *hevc)
 	WRITE_VREG(HEVC_SPS_BUFFER, buf_spec->sps.buf_start);
 	WRITE_VREG(HEVC_PPS_BUFFER, buf_spec->pps.buf_start);
 	WRITE_VREG(HEVC_SAO_UP, buf_spec->sao_up.buf_start);
-	if (mmu_enable)
+	if (hevc->mmu_enable)
 		WRITE_VREG(H265_MMU_MAP_BUFFER, hevc->frame_mmu_map_phy_addr);
 	else
 		WRITE_VREG(HEVC_STREAM_SWAP_BUFFER,
@@ -3110,8 +3348,7 @@ static void hevc_config_work_space_hw(struct hevc_state_s *hevc)
 	/* cfg_d_addr */
 	WRITE_VREG(HEVC_DBLK_CFG5, buf_spec->dblk_data.buf_start);
 
-	if (get_dbg_flag(hevc) & H265_DEBUG_UCODE)
-		WRITE_VREG(LMEM_DUMP_ADR, (u32)hevc->lmem_phy_addr);
+	WRITE_VREG(LMEM_DUMP_ADR, (u32)hevc->lmem_phy_addr);
 
 }
 
@@ -3125,7 +3362,7 @@ static void hevc_init_decoder_hw(struct hevc_state_s *hevc,
 	/* m8baby test1902 */
 	if (get_dbg_flag(hevc) & H265_DEBUG_BUFMGR)
 		hevc_print(hevc, 0,
-			"[test.c] Test Parser Register Read/Write\n");
+			"%s\n", __func__);
 	data32 = READ_VREG(HEVC_PARSER_VERSION);
 	if (data32 != 0x00010001) {
 		print_scratch_error(25);
@@ -3156,11 +3393,6 @@ static void hevc_init_decoder_hw(struct hevc_state_s *hevc,
 	CLEAR_VREG_MASK(HEVC_PARSER_CORE_CONTROL, 1);
 
 #endif
-
-	if (get_dbg_flag(hevc) & H265_DEBUG_BUFMGR)
-		hevc_print(hevc, 0,
-			"[test.c] Enable BitStream Fetch\n");
-			 ;
 	if (!hevc->m_ins_flag) {
 		data32 = READ_VREG(HEVC_STREAM_CONTROL);
 		data32 = data32 | (1 << 0);      /* stream_fetch_enable */
@@ -3191,9 +3423,6 @@ static void hevc_init_decoder_hw(struct hevc_state_s *hevc,
 	WRITE_VREG(HEVC_SHIFT_STARTCODE, 0x00000100);
 	WRITE_VREG(HEVC_SHIFT_EMULATECODE, 0x00000300);
 
-	if (get_dbg_flag(hevc) & H265_DEBUG_BUFMGR)
-		hevc_print(hevc, 0,
-			"[test.c] Enable HEVC Parser Interrupt\n");
 	data32 = READ_VREG(HEVC_PARSER_INT_CONTROL);
 	data32 &= 0x03ffffff;
 	data32 = data32 | (3 << 29) | (2 << 26) | (1 << 24)
@@ -3206,10 +3435,6 @@ static void hevc_init_decoder_hw(struct hevc_state_s *hevc,
 			 ;
 	WRITE_VREG(HEVC_PARSER_INT_CONTROL, data32);
 
-	if (get_dbg_flag(hevc) & H265_DEBUG_BUFMGR)
-		hevc_print(hevc, 0,
-			"[test.c] Enable HEVC Parser Shift\n");
-
 	data32 = READ_VREG(HEVC_SHIFT_STATUS);
 	data32 = data32 | (1 << 1) |	/* emulation_check_on */
 			 (1 << 0)		/* startcode_check_on */
@@ -3231,12 +3456,6 @@ static void hevc_init_decoder_hw(struct hevc_state_s *hevc,
 	WRITE_VREG(HEVC_DEC_STATUS_REG, 0);
 
 	/* Initial IQIT_SCALELUT memory -- just to avoid X in simulation */
-	if (get_dbg_flag(hevc) & H265_DEBUG_BUFMGR) {
-		hevc_print(hevc, 0,
-		"[test.c] Initial IQIT_SCALELUT memory --");
-		hevc_print_cont(hevc, 0,
-		" just to avoid X in simulation...\n");
-	}
 	WRITE_VREG(HEVC_IQIT_SCALELUT_WR_ADDR, 0);	/* cfg_p_addr */
 	for (i = 0; i < 1024; i++)
 		WRITE_VREG(HEVC_IQIT_SCALELUT_DATA, 0);
@@ -3250,9 +3469,6 @@ static void hevc_init_decoder_hw(struct hevc_state_s *hevc,
 	WRITE_VREG(HEVC_DECODE_SIZE, 0);
 	/*WRITE_VREG(HEVC_DECODE_COUNT, 0);*/
 	/* Send parser_cmd */
-	if (get_dbg_flag(hevc))
-		hevc_print(hevc, 0,
-			"[test.c] SEND Parser Command ...\n");
 	WRITE_VREG(HEVC_PARSER_CMD_WRITE, (1 << 16) | (0 << 0));
 	for (i = 0; i < PARSER_CMD_NUMBER; i++)
 		WRITE_VREG(HEVC_PARSER_CMD_WRITE, parser_cmd[i]);
@@ -3276,9 +3492,6 @@ static void hevc_init_decoder_hw(struct hevc_state_s *hevc,
 	   );
 	 */
 
-	if (get_dbg_flag(hevc))
-		hevc_print(hevc, 0,
-			"[test.c] Reset IPP\n");
 	WRITE_VREG(HEVCD_IPP_TOP_CNTL, (0 << 1) |	/* enable ipp */
 			   (1 << 0)	/* software reset ipp and mpp */
 			  );
@@ -3777,7 +3990,7 @@ static void config_sao_hw(struct hevc_state_s *hevc, union param_u *params)
 	if ((get_double_write_mode(hevc) & 0x10) == 0)
 		WRITE_VREG(HEVC_CM_BODY_START_ADDR, data32);
 
-	if (mmu_enable)
+	if (hevc->mmu_enable)
 		WRITE_VREG(HEVC_CM_HEADER_START_ADDR, cur_pic->header_adr);
 #else
 	data32 = cur_pic->mc_y_adr;
@@ -3861,7 +4074,7 @@ static void config_sao_hw(struct hevc_state_s *hevc, union param_u *params)
 	data32 &= (~0x3); /*[1]:dw_disable [0]:cm_disable*/
 	if (get_double_write_mode(hevc) == 0)
 		data32 |= 0x2; /*disable double write*/
-	else if (!mmu_enable && (get_double_write_mode(hevc) & 0x10))
+	else if (!hevc->mmu_enable && (get_double_write_mode(hevc) & 0x10))
 		data32 |= 0x1; /*disable cm*/
 	WRITE_VREG(HEVC_SAO_CTRL1, data32);
 
@@ -3970,18 +4183,83 @@ static void config_sao_hw(struct hevc_state_s *hevc, union param_u *params)
 	WRITE_VREG(HEVC_SAO_CTRL0, data32_2);
 }
 
-static void clear_used_by_display_flag(struct hevc_state_s *hevc)
+#ifdef TEST_NO_BUF
+static unsigned char test_flag = 1;
+#endif
+
+static void pic_list_process(struct hevc_state_s *hevc)
 {
-	struct PIC_s *pic;
+	int work_pic_num = get_work_pic_num(hevc);
+	int alloc_pic_count = 0;
 	int i;
-	if (get_dbg_flag(hevc) & H265_DEBUG_NOT_USE_LAST_DISPBUF)
-		return;
-
+	struct PIC_s *pic;
+	for (i = 0; i < MAX_REF_PIC_NUM; i++) {
+		pic = hevc->m_PIC[i];
+		if (pic == NULL || pic->index == -1)
+			continue;
+		alloc_pic_count++;
+		if (pic->output_mark == 0 && pic->referenced == 0
+			&& pic->output_ready == 0
+			&& (pic->width != hevc->pic_w ||
+				pic->height != hevc->pic_h)
+			) {
+			set_buf_unused(hevc, pic->BUF_index);
+			pic->BUF_index = -1;
+			if (alloc_pic_count > work_pic_num) {
+				pic->width = 0;
+				pic->height = 0;
+				pic->index = -1;
+			} else {
+				pic->width = hevc->pic_w;
+				pic->height = hevc->pic_h;
+			}
+		}
+	}
+	if (alloc_pic_count < work_pic_num) {
+		int new_count = alloc_pic_count;
+		for (i = 0; i < MAX_REF_PIC_NUM; i++) {
+			pic = hevc->m_PIC[i];
+			if (pic && pic->index == -1) {
+				pic->index = i;
+				pic->BUF_index = -1;
+				pic->width = hevc->pic_w;
+				pic->height = hevc->pic_h;
+				new_count++;
+				if (new_count >=
+					work_pic_num)
+					break;
+			}
+		}
+
+	}
+	dealloc_unused_buf(hevc);
+	if (get_alloc_pic_count(hevc)
+		!= alloc_pic_count) {
+		hevc_print_cont(hevc, 0,
+		"%s: work_pic_num is %d, Change alloc_pic_count from %d to %d\n",
+		__func__,
+		work_pic_num,
+		alloc_pic_count,
+		get_alloc_pic_count(hevc));
+	}
+}
+
+static void recycle_mmu_bufs(struct hevc_state_s *hevc)
+{
+	int i;
+	struct PIC_s *pic;
 	for (i = 0; i < MAX_REF_PIC_NUM; i++) {
 		pic = hevc->m_PIC[i];
-		if (pic)
-			pic->used_by_display = 0;
+		if (pic == NULL || pic->index == -1)
+			continue;
+
+		if (pic->output_mark == 0 && pic->referenced == 0
+			&& pic->output_ready == 0
+			&& pic->scatter_alloc
+			)
+			release_pic_mmu_buf(hevc, pic);
 	}
+
 }
 
 static struct PIC_s *get_new_pic(struct hevc_state_s *hevc,
@@ -3989,7 +4267,6 @@ static struct PIC_s *get_new_pic(struct hevc_state_s *hevc,
 {
 	struct PIC_s *new_pic = NULL;
 	struct PIC_s *pic;
-	/* recycle un-used pic */
 	int i;
 	int ret;
 
@@ -3997,73 +4274,66 @@ static struct PIC_s *get_new_pic(struct hevc_state_s *hevc,
 		pic = hevc->m_PIC[i];
 		if (pic == NULL || pic->index == -1)
 			continue;
-		if ((pic->used_by_display) && !mmu_enable
-			&& ((READ_VCBUS_REG(AFBC_BODY_BADDR) << 4) !=
-				pic->mc_y_adr))
-			pic->used_by_display = 0;
+
 		if (pic->output_mark == 0 && pic->referenced == 0
 			&& pic->output_ready == 0
-			&& pic->used_by_display == 0) {
+			&& pic->width == hevc->pic_w
+			&& pic->height == hevc->pic_h
+			) {
 			if (new_pic) {
-				if (pic->POC < new_pic->POC)
-					new_pic = pic;
+				if (new_pic->POC != INVALID_POC) {
+					if (pic->POC == INVALID_POC ||
+						pic->POC < new_pic->POC)
+						new_pic = pic;
+				}
 			} else
 				new_pic = pic;
 		}
 	}
 
-	/*try to allocate more pic for new resolution*/
-	if (re_config_pic_flag && new_pic == NULL) {
-		int ii;
+	if (new_pic == NULL)
+		return NULL;
 
-		for (ii = 0; ii < MAX_REF_PIC_NUM; ii++) {
-			if (hevc->m_PIC[ii] == NULL ||
-				hevc->m_PIC[ii]->index == -1)
-				break;
-		}
-		if (ii < MAX_REF_PIC_NUM) {
-			new_pic = hevc->m_PIC[ii];
-			if (new_pic) {
-				memset(new_pic, 0, sizeof(struct PIC_s));
-				new_pic->index = ii;
-				new_pic->BUF_index = -1;
+	if (new_pic->BUF_index < 0) {
+		if (alloc_buf(hevc) < 0)
+			return NULL;
+		else {
+			if (config_pic(hevc, new_pic) < 0) {
+				dealloc_pic_buf(hevc, new_pic);
+				return NULL;
 			}
 		}
-	}
-	/**/
+		new_pic->width = hevc->pic_w;
+		new_pic->height = hevc->pic_h;
+		set_canvas(hevc, new_pic);
 
-	if (new_pic == NULL) {
-		/* pr_info("Error: Buffer management, no free buffer\n"); */
-		return new_pic;
+		init_pic_list_hw(hevc);
 	}
 
-	new_pic->referenced = 1;
-	if (new_pic->width != hevc->pic_w ||
-		new_pic->height != hevc->pic_h) {
-		if (re_config_pic_flag) {
-			/* re config pic for new resolution */
-			recycle_buf(hevc);
-			/* if(new_pic->BUF_index == -1){ */
-			if (config_pic(hevc, new_pic, 0) < 0) {
-				if (get_dbg_flag(hevc) &
-					H265_DEBUG_BUFMGR_MORE) {
-					hevc_print(hevc, 0,
-					"Config_pic %d fail\n",
-					new_pic->index);
-					dump_pic_list(hevc);
-				}
-				new_pic->index = -1;
-				new_pic = NULL;
-			} else
-				init_pic_list_hw(hevc);
-		}
-		if (new_pic) {
-			new_pic->width = hevc->pic_w;
-			new_pic->height = hevc->pic_h;
-			set_canvas(hevc, new_pic);
-		}
-	}
 	if (new_pic) {
+#ifdef TEST_NO_BUF
+		if (test_flag) {
+			test_flag = 0;
+			return NULL;
+		} else
+			test_flag = 1;
+#endif
+		if (get_mv_buf(hevc, new_pic) < 0)
+			return NULL;
+
+		if (hevc->mmu_enable) {
+			ret = H265_alloc_mmu(hevc, new_pic,
+				rpm_param->p.bit_depth,
+				hevc->frame_mmu_map_addr);
+			if (ret != 0) {
+				hevc_print(hevc, 0,
+				"can't alloc need mmu1,idx %d ret =%d\n",
+				new_pic->decode_idx,
+				ret);
+				return NULL;
+			}
+		}
+		new_pic->referenced = 1;
 		new_pic->decode_idx = hevc->decode_idx;
 		new_pic->slice_idx = 0;
 		new_pic->referenced = 1;
@@ -4077,18 +4347,18 @@ static struct PIC_s *get_new_pic(struct hevc_state_s *hevc,
 		new_pic->pic_struct = hevc->curr_pic_struct;
 		if (new_pic->aux_data_buf)
 			release_aux_data(hevc, new_pic);
-	}
+		new_pic->mem_saving_mode =
+			hevc->mem_saving_mode;
+		new_pic->bit_depth_luma =
+			hevc->bit_depth_luma;
+		new_pic->bit_depth_chroma =
+			hevc->bit_depth_chroma;
 
-	if (mmu_enable) {
-		ret = H265_alloc_mmu(hevc, new_pic, rpm_param->p.bit_depth,
-			hevc->frame_mmu_map_addr);
-			/*pr_info("get pic index %x\n",new_pic->index);*/
-		if (ret != 0) {
-			pr_err("can't alloc need mmu1,idx %d ret =%d\n",
-			new_pic->decode_idx,
-			ret);
-		return NULL;
-		}
+		hevc_print(hevc, H265_DEBUG_BUFMGR_MORE,
+			"%s: index %d, buf_idx %d, decode_idx %d, POC %d\n",
+			__func__, new_pic->index,
+			new_pic->BUF_index, new_pic->decode_idx,
+			new_pic->POC);
 
 	}
 
@@ -4143,6 +4413,7 @@ static void flush_output(struct hevc_state_s *hevc, struct PIC_s *pic)
 
 		if (pic_display) {
 			pic_display->referenced = 0;
+			put_mv_buf(hevc, pic_display);
 			if ((pic_display->error_mark
 				 && ((hevc->ignore_bufmgr_error & 0x2) == 0))
 				|| (get_dbg_flag(hevc) &
@@ -4161,10 +4432,10 @@ static void flush_output(struct hevc_state_s *hevc, struct PIC_s *pic)
 					"Debug mode or error, recycle it\n");
 				}
 			} else {
-				if (i_only_flag & 0x1
-					&& pic_display->slice_type != 2)
+				if (hevc->i_only & 0x1
+					&& pic_display->slice_type != 2) {
 					pic_display->output_ready = 0;
-				else {
+				} else {
 					prepare_display_buf(hevc, pic_display);
 					if (get_dbg_flag(hevc)
 						& H265_DEBUG_BUFMGR) {
@@ -4181,8 +4452,12 @@ static void flush_output(struct hevc_state_s *hevc, struct PIC_s *pic)
 	} while (pic_display);
 }
 
+/*
+* dv_meta_flag: 1, dolby meta only; 2, not include dolby meta
+*/
 static void set_aux_data(struct hevc_state_s *hevc,
-	struct PIC_s *pic, unsigned char suffix_flag)
+	struct PIC_s *pic, unsigned char suffix_flag,
+	unsigned char dv_meta_flag)
 {
 	int i;
 	unsigned short *aux_adr;
@@ -4190,6 +4465,8 @@ static void set_aux_data(struct hevc_state_s *hevc,
 		READ_VREG(HEVC_AUX_DATA_SIZE);
 	unsigned aux_count = 0;
 	int aux_size = 0;
+	if (pic == NULL)
+		return;
 	if (suffix_flag) {
 		aux_adr = (unsigned short *)
 			(hevc->aux_addr +
@@ -4209,8 +4486,10 @@ static void set_aux_data(struct hevc_state_s *hevc,
 			hevc->prefix_aux_size;
 	}
 	if (get_dbg_flag(hevc) & H265_DEBUG_BUFMGR_MORE) {
-		hevc_print(hevc, 0, "%s:old size %d count %d,suf %d\r\n",
-			__func__, pic->aux_data_size, aux_count, suffix_flag);
+		hevc_print(hevc, 0,
+			"%s:old size %d count %d,suf %d dv_flag %d\r\n",
+			__func__, pic->aux_data_size,
+			aux_count, suffix_flag, dv_meta_flag);
 	}
 	if (aux_size > 0 && aux_count > 0) {
 		int heads_size = 0;
@@ -4218,62 +4497,92 @@ static void set_aux_data(struct hevc_state_s *hevc,
 		char *new_buf;
 		for (i = 0; i < aux_count; i++) {
 			unsigned char tag = aux_adr[i] >> 8;
-			if (tag != 0 && tag != 0xff)
-				heads_size += 8;
+			if (tag != 0 && tag != 0xff) {
+				if (dv_meta_flag == 0)
+					heads_size += 8;
+				else if (dv_meta_flag == 1 && tag == 0x1)
+					heads_size += 8;
+				else if (dv_meta_flag == 2 && tag != 0x1)
+					heads_size += 8;
+			}
 		}
 		new_size = pic->aux_data_size + aux_count + heads_size;
 		new_buf = krealloc(pic->aux_data_buf,
 			new_size,
 			GFP_KERNEL);
 		if (new_buf) {
-			unsigned char *p =
+			unsigned char valid_tag = 0;
+			unsigned char *h =
 				new_buf +
 				pic->aux_data_size;
-			unsigned char *h = p;
-			int h_bytes = 8;
+			unsigned char *p = h + 8;
 			int len = 0;
 			int padding_len = 0;
 			pic->aux_data_buf = new_buf;
-			pic->aux_data_size += (aux_count + heads_size);
 			for (i = 0; i < aux_count; i += 4) {
 				int ii;
 				unsigned char tag = aux_adr[i + 3] >> 8;
 				if (tag != 0 && tag != 0xff) {
-					if (i > 0) {
-						h[0] = (len >> 24) & 0xff;
-						h[1] = (len >> 16) & 0xff;
-						h[2] = (len >> 8) & 0xff;
-						h[3] = (len >> 0) & 0xff;
-						h[6] = (padding_len >> 8)
+					if (dv_meta_flag == 0)
+						valid_tag = 1;
+					else if (dv_meta_flag == 1
+						&& tag == 0x1)
+						valid_tag = 1;
+					else if (dv_meta_flag == 2
+						&& tag != 0x1)
+						valid_tag = 1;
+					else
+						valid_tag = 0;
+					if (valid_tag && len > 0) {
+						pic->aux_data_size +=
+						(len + 8);
+						h[0] = (len >> 24)
+						& 0xff;
+						h[1] = (len >> 16)
+						& 0xff;
+						h[2] = (len >> 8)
+						& 0xff;
+						h[3] = (len >> 0)
+						& 0xff;
+						h[6] =
+						(padding_len >> 8)
+						& 0xff;
+						h[7] = (padding_len)
 						& 0xff;
-						h[7] = (padding_len) & 0xff;
 						h += (len + 8);
-						h_bytes += 8;
+						p += 8;
 						len = 0;
 						padding_len = 0;
 					}
-					h[4] = tag;
-					h[5] = 0;
-					h[6] = 0;
-					h[7] = 0;
+					if (valid_tag) {
+						h[4] = tag;
+						h[5] = 0;
+						h[6] = 0;
+						h[7] = 0;
+					}
 				}
-				for (ii = 0; ii < 4; ii++) {
-					unsigned short aa =
-						aux_adr[i + 3
-						- ii];
-						p[h_bytes + i + ii] =
-							aa & 0xff;
-					len++;
-					if ((aa >> 8) == 0xff)
-						padding_len++;
+				if (valid_tag) {
+					for (ii = 0; ii < 4; ii++) {
+						unsigned short aa =
+							aux_adr[i + 3
+							- ii];
+						*p = aa & 0xff;
+						p++;
+						len++;
+						/*if ((aa >> 8) == 0xff)
+							padding_len++;*/
+					}
 				}
 			}
-			h[0] = (len >> 24) & 0xff;
-			h[1] = (len >> 16) & 0xff;
-			h[2] = (len >> 8) & 0xff;
-			h[3] = (len >> 0) & 0xff;
-			h[6] = (padding_len >> 8) & 0xff;
-			h[7] = (padding_len) & 0xff;
+			if (len > 0) {
+				pic->aux_data_size += (len + 8);
+				h[0] = (len >> 24) & 0xff;
+				h[1] = (len >> 16) & 0xff;
+				h[2] = (len >> 8) & 0xff;
+				h[3] = (len >> 0) & 0xff;
+				h[6] = (padding_len >> 8) & 0xff;
+				h[7] = (padding_len) & 0xff;
+			}
 			if (get_dbg_flag(hevc) & H265_DEBUG_BUFMGR_MORE) {
 				hevc_print(hevc, 0,
 					"aux: (size %d) suffix_flag %d\n",
@@ -4306,12 +4615,19 @@ static inline void hevc_pre_pic(struct hevc_state_s *hevc,
 
 	/* prev pic */
 	/*if (hevc->curr_POC != 0) {*/
+	int decoded_poc = hevc->iPrevPOC;
+#ifdef MULTI_INSTANCE_SUPPORT
+	if (hevc->m_ins_flag) {
+		decoded_poc = hevc->decoded_poc;
+		hevc->decoded_poc = INVALID_POC;
+	}
+#endif
 	if (hevc->m_nalUnitType != NAL_UNIT_CODED_SLICE_IDR
 			&& hevc->m_nalUnitType !=
 			NAL_UNIT_CODED_SLICE_IDR_N_LP) {
 		struct PIC_s *pic_display;
 
-		pic = get_pic_by_POC(hevc, hevc->iPrevPOC);
+		pic = get_pic_by_POC(hevc, decoded_poc);
 		if (pic && (pic->POC != INVALID_POC)) {
 			/*PB skip control */
 			if (pic->error_mark == 0
@@ -4328,6 +4644,33 @@ static inline void hevc_pre_pic(struct hevc_state_s *hevc,
 					hevc->ignore_bufmgr_error |= 0x2;
 				}
 			}
+			if (hevc->mmu_enable) {
+				if (!hevc->m_ins_flag) {
+					hevc->used_4k_num =
+					READ_VREG(HEVC_SAO_MMU_STATUS) >> 16;
+
+					if ((!is_skip_decoding(hevc, pic)) &&
+						(hevc->used_4k_num >= 0) &&
+						(hevc->cur_pic->scatter_alloc
+						== 1)) {
+						hevc_print(hevc,
+						H265_DEBUG_BUFMGR_MORE,
+						"%s pic index %d scatter_alloc %d page_start %d\n",
+						"decoder_mmu_box_free_idx_tail",
+						hevc->cur_pic->index,
+						hevc->cur_pic->scatter_alloc,
+						hevc->used_4k_num);
+						decoder_mmu_box_free_idx_tail(
+						hevc->mmu_box,
+						hevc->cur_pic->index,
+						hevc->used_4k_num);
+						hevc->cur_pic->scatter_alloc
+							= 2;
+					}
+					hevc->used_4k_num = -1;
+				}
+			}
+
 			pic->output_mark = 1;
 			pic->recon_mark = 1;
 		}
@@ -4356,7 +4699,7 @@ static inline void hevc_pre_pic(struct hevc_state_s *hevc,
 						"Debug or err,recycle it\n");
 					}
 				} else {
-					if (i_only_flag & 0x1
+					if (hevc->i_only & 0x1
 						&& pic_display->
 						slice_type != 2) {
 						pic_display->output_ready = 0;
@@ -4387,15 +4730,19 @@ static inline void hevc_pre_pic(struct hevc_state_s *hevc,
 		}
 		if (get_dbg_flag(hevc) & H265_DEBUG_BUFMGR)
 			dump_pic_list(hevc);
-		pic = get_pic_by_POC(hevc, hevc->iPrevPOC);
+		pic = get_pic_by_POC(hevc, decoded_poc);
 		flush_output(hevc, pic);
 	}
 
 }
 
-static void check_pic_decoded_lcu_count(struct hevc_state_s *hevc)
+static void check_pic_decoded_lcu_count_pre(struct hevc_state_s *hevc,
+	int decoded_lcu)
 {
-	int current_lcu_idx = READ_VREG(HEVC_PARSER_LCU_START)&0xffffff;
+	int current_lcu_idx = decoded_lcu;
+	if (decoded_lcu < 0)
+		return;
+
 	if (get_dbg_flag(hevc) & H265_DEBUG_BUFMGR) {
 		hevc_print(hevc, 0,
 			"cur lcu idx = %d, (total %d)\n",
@@ -4414,17 +4761,61 @@ static void check_pic_decoded_lcu_count(struct hevc_state_s *hevc)
 			 ((hevc->lcu_x_num_pre*hevc->lcu_y_num_pre) - 1))
 				hevc->cur_pic->error_mark = 1;
 		}
-		if (hevc->cur_pic->error_mark)
+		if (hevc->cur_pic->error_mark) {
 			hevc_print(hevc, 0,
 				"cur lcu idx = %d, (total %d), set error_mark\n",
 				current_lcu_idx,
 				hevc->lcu_x_num_pre*hevc->lcu_y_num_pre);
+			if (is_log_enable(hevc))
+				add_log(hevc,
+					"cur lcu idx = %d, (total %d), set error_mark",
+					current_lcu_idx,
+					hevc->lcu_x_num_pre *
+					    hevc->lcu_y_num_pre);
+
+		}
 
 	}
 	hevc->lcu_x_num_pre = hevc->lcu_x_num;
 	hevc->lcu_y_num_pre = hevc->lcu_y_num;
 }
 
+static void check_pic_decoded_lcu_count(struct hevc_state_s *hevc,
+	int decoded_lcu)
+{
+	int current_lcu_idx = decoded_lcu;
+	if (decoded_lcu < 0)
+		return;
+
+	if (get_dbg_flag(hevc) & H265_DEBUG_BUFMGR) {
+		hevc_print(hevc, 0,
+			"cur lcu idx = %d, (total %d)\n",
+			current_lcu_idx, hevc->lcu_total);
+	}
+	if ((error_handle_policy & 0x20) == 0 && hevc->cur_pic != NULL) {
+		if (hevc->lcu_x_num != 0
+		 && hevc->lcu_y_num != 0
+		 && current_lcu_idx != 0
+		 && current_lcu_idx <
+		 ((hevc->lcu_x_num*hevc->lcu_y_num) - 1))
+			hevc->cur_pic->error_mark = 1;
+		if (hevc->cur_pic->error_mark) {
+			hevc_print(hevc, 0,
+				"cur lcu idx = %d, (total %d), set error_mark\n",
+				current_lcu_idx,
+				hevc->lcu_x_num*hevc->lcu_y_num);
+			if (is_log_enable(hevc))
+				add_log(hevc,
+					"cur lcu idx = %d, (total %d), set error_mark",
+					current_lcu_idx,
+					hevc->lcu_x_num *
+					    hevc->lcu_y_num);
+
+		}
+
+	}
+}
+
 static int hevc_slice_segment_header_process(struct hevc_state_s *hevc,
 		union param_u *rpm_param,
 		int decode_pic_begin)
@@ -4448,7 +4839,7 @@ static int hevc_slice_segment_header_process(struct hevc_state_s *hevc,
 		hevc->curr_pic_struct =
 			(rpm_param->p.sei_frame_field_info >> 3) & 0xf;
 
-		if (interlace_enable == 0)
+		if (interlace_enable == 0 || hevc->m_ins_flag)
 			hevc->interlace_flag = 0;
 		if (interlace_enable & 0x100)
 			hevc->interlace_flag = interlace_enable & 0x1;
@@ -4495,7 +4886,7 @@ static int hevc_slice_segment_header_process(struct hevc_state_s *hevc,
 			hevc->frame_width = hevc->pic_w;
 			hevc->frame_height = hevc->pic_h;
 #ifdef LOSLESS_COMPRESS_MODE
-			if (re_config_pic_flag == 0 &&
+			if (/*re_config_pic_flag == 0 &&*/
 				(get_double_write_mode(hevc) & 0x10) == 0)
 				init_decode_head_hw(hevc);
 #endif
@@ -4508,7 +4899,7 @@ static int hevc_slice_segment_header_process(struct hevc_state_s *hevc,
 				debug |= (H265_DEBUG_DIS_LOC_ERROR_PROC |
 				H265_DEBUG_DIS_SYS_ERROR_PROC);
 			hevc->fatal_error |= DECODER_FATAL_ERROR_SIZE_OVERFLOW;
-			return -1;
+			return 3;
 		}
 
 		/* it will cause divide 0 error */
@@ -4520,6 +4911,8 @@ static int hevc_slice_segment_header_process(struct hevc_state_s *hevc,
 			}
 			return 3;
 		}
+		pic_list_process(hevc);
+
 		hevc->lcu_size =
 			1 << (rpm_param->p.log2_min_coding_block_size_minus3 +
 					3 + rpm_param->
@@ -4655,12 +5048,14 @@ static int hevc_slice_segment_header_process(struct hevc_state_s *hevc,
 			struct PIC_s *pic;
 
 			hevc->new_pic = 1;
-			check_pic_decoded_lcu_count(hevc);
+#ifdef MULTI_INSTANCE_SUPPORT
+			if (!hevc->m_ins_flag)
+#endif
+				check_pic_decoded_lcu_count_pre(hevc,
+					READ_VREG(HEVC_PARSER_LCU_START)
+					& 0xffffff);
 			/**/ if (use_cma == 0) {
 				if (hevc->pic_list_init_flag == 0) {
-					/*USE_BUF_BLOCK*/
-					init_buf_list(hevc);
-					/**/
 					init_pic_list(hevc);
 					init_pic_list_hw(hevc);
 					init_buf_spec(hevc);
@@ -4678,16 +5073,10 @@ static int hevc_slice_segment_header_process(struct hevc_state_s *hevc,
 			   */
 			apply_ref_pic_set(hevc, hevc->curr_POC,
 							  rpm_param);
-		if (mmu_enable && hevc->cur_pic != NULL) {
-			if (!(hevc->cur_pic->error_mark
-				&& ((hevc->ignore_bufmgr_error & 0x1) == 0))) {
-				long used_4k_num =
-					(READ_VREG(HEVC_SAO_MMU_STATUS) >> 16);
-				decoder_mmu_box_free_idx_tail(hevc->mmu_box,
-				hevc->cur_pic->index, used_4k_num);
-				}
 
-			}
+			if (hevc->mmu_enable)
+				recycle_mmu_bufs(hevc);
+
 #ifdef CONFIG_AM_VDEC_DV
 			if (vdec->master) {
 				struct hevc_state_s *hevc_ba =
@@ -4697,13 +5086,10 @@ static int hevc_slice_segment_header_process(struct hevc_state_s *hevc,
 					hevc_ba->cur_pic->dv_enhance_exist = 1;
 			}
 			if (vdec->master == NULL &&
-				vdec->slave == NULL) {
-				if (hevc->cur_pic != NULL)
-					set_aux_data(hevc, hevc->cur_pic, 1);
-			}
+				vdec->slave == NULL)
+				set_aux_data(hevc, hevc->cur_pic, 1, 0);
 #else
-			if (hevc->cur_pic != NULL)
-				set_aux_data(hevc, hevc->cur_pic, 1);
+			set_aux_data(hevc, hevc->cur_pic, 1, 0);
 #endif
 			/* new pic */
 			hevc->cur_pic = get_new_pic(hevc, rpm_param);
@@ -4713,13 +5099,16 @@ static int hevc_slice_segment_header_process(struct hevc_state_s *hevc,
 				hevc->wait_buf = 1;
 				return -1;
 			}
+#ifdef MULTI_INSTANCE_SUPPORT
+			hevc->decoding_pic = hevc->cur_pic;
+#endif
 #ifdef CONFIG_AM_VDEC_DV
 			hevc->cur_pic->dv_enhance_exist = 0;
 			if (vdec->master == NULL &&
 				vdec->slave == NULL)
-				set_aux_data(hevc, hevc->cur_pic, 0);
+				set_aux_data(hevc, hevc->cur_pic, 0, 0);
 #else
-			set_aux_data(hevc, hevc->cur_pic, 0);
+			set_aux_data(hevc, hevc->cur_pic, 0, 0);
 #endif
 			if (get_dbg_flag(hevc) & H265_DEBUG_DISPLAY_CUR_FRAME) {
 				hevc->cur_pic->output_ready = 1;
@@ -4733,16 +5122,12 @@ static int hevc_slice_segment_header_process(struct hevc_state_s *hevc,
 #ifdef CONFIG_AM_VDEC_DV
 			if (vdec->master == NULL &&
 				vdec->slave == NULL) {
-				if (hevc->cur_pic != NULL) {
-					set_aux_data(hevc, hevc->cur_pic, 1);
-					set_aux_data(hevc, hevc->cur_pic, 0);
-				}
+				set_aux_data(hevc, hevc->cur_pic, 1, 0);
+				set_aux_data(hevc, hevc->cur_pic, 0, 0);
 			}
 #else
-			if (hevc->cur_pic != NULL) {
-				set_aux_data(hevc, hevc->cur_pic, 1);
-				set_aux_data(hevc, hevc->cur_pic, 0);
-			}
+			set_aux_data(hevc, hevc->cur_pic, 1, 0);
+			set_aux_data(hevc, hevc->cur_pic, 0, 0);
 #endif
 			if (hevc->pic_list_init_flag != 3
 				|| hevc->cur_pic == NULL) {
@@ -4753,16 +5138,7 @@ static int hevc_slice_segment_header_process(struct hevc_state_s *hevc,
 			hevc->new_pic = 0;
 		}
 	} else {
-		if (hevc->wait_buf == 1) {
-			/*
-			*if (mmu_enable && hevc->cur_pic != NULL) {
-			*	long used_4k_num =
-			*		(READ_VREG(HEVC_SAO_MMU_STATUS) >> 16);
-			*	decoder_mmu_box_free_idx_tail(hevc->mmu_box,
-			*		hevc->cur_pic->index, used_4k_num);
-			*
-			*	}
-			*/
+	if (hevc->wait_buf == 1) {
 			hevc->cur_pic = get_new_pic(hevc, rpm_param);
 			if (hevc->cur_pic == NULL)
 				return -1;
@@ -4771,9 +5147,9 @@ static int hevc_slice_segment_header_process(struct hevc_state_s *hevc,
 			hevc->cur_pic->dv_enhance_exist = 0;
 			if (vdec->master == NULL &&
 				vdec->slave == NULL)
-				set_aux_data(hevc, hevc->cur_pic, 0);
+				set_aux_data(hevc, hevc->cur_pic, 0, 0);
 #else
-			set_aux_data(hevc, hevc->cur_pic, 0);
+			set_aux_data(hevc, hevc->cur_pic, 0, 0);
 #endif
 			hevc->wait_buf = 0;
 		} else if (hevc->wait_buf ==
@@ -4806,11 +5182,12 @@ static int hevc_slice_segment_header_process(struct hevc_state_s *hevc,
 		/* int sao_abv_size = sao_mem_unit*pic_width_cu; */
 		if (get_dbg_flag(hevc) & H265_DEBUG_BUFMGR) {
 			hevc_print(hevc, 0,
-				"==>%s dec idx %d, struct %d interlace %d\n",
+				"==>%s dec idx %d, struct %d interlace %d pic idx %d\n",
 				__func__,
 				hevc->decode_idx,
 				hevc->curr_pic_struct,
-				hevc->interlace_flag);
+				hevc->interlace_flag,
+				hevc->cur_pic->index);
 		}
 		if (dbg_skip_decode_index != 0 &&
 			hevc->decode_idx == dbg_skip_decode_index)
@@ -4926,7 +5303,7 @@ static int hevc_slice_segment_header_process(struct hevc_state_s *hevc,
 	hevc->LongTerm_Ref = 0;	/* to do ... */
 
 	if (hevc->slice_type != 2) {
-		/* if(i_only_flag==1){ */
+		/* if(hevc->i_only==1){ */
 		/* return 0xf; */
 		/* } */
 
@@ -4938,16 +5315,31 @@ static int hevc_slice_segment_header_process(struct hevc_state_s *hevc,
 					hevc_print(hevc, 0,
 					"WRONG,fail to get the pic Col_POC\n");
 				}
+				if (is_log_enable(hevc))
+					add_log(hevc,
+					"WRONG,fail to get the pic Col_POC");
 			} else if (hevc->col_pic->error_mark) {
 				hevc->cur_pic->error_mark = 1;
 				if (get_dbg_flag(hevc)) {
 					hevc_print(hevc, 0,
 					"WRONG, Col_POC error_mark is 1\n");
 				}
+				if (is_log_enable(hevc))
+					add_log(hevc,
+					"WRONG, Col_POC error_mark is 1");
 			}
 
 			if (hevc->cur_pic->error_mark
 				&& ((hevc->ignore_bufmgr_error & 0x1) == 0)) {
+#ifndef CONFIG_MULTI_DEC
+				/*count info*/
+				vdec_count_info(gvs, hevc->cur_pic->error_mark,
+					hevc->cur_pic->stream_offset);
+#endif
+			}
+
+			if (is_skip_decoding(hevc,
+				hevc->cur_pic)) {
 				return 2;
 			}
 		} else
@@ -4965,12 +5357,17 @@ static int hevc_slice_segment_header_process(struct hevc_state_s *hevc,
 
 	config_mc_buffer(hevc, hevc->cur_pic);
 
-	if (hevc->cur_pic->error_mark
-		&& ((hevc->ignore_bufmgr_error & 0x1) == 0)) {
+	if (is_skip_decoding(hevc,
+			hevc->cur_pic)) {
 		if (get_dbg_flag(hevc))
 			hevc_print(hevc, 0,
 			"Discard this picture index %d\n",
 					hevc->cur_pic->index);
+#ifndef CONFIG_MULTI_DEC
+		/*count info*/
+		vdec_count_info(gvs, hevc->cur_pic->error_mark,
+			hevc->cur_pic->stream_offset);
+#endif
 		return 2;
 	}
 #ifdef MCRCC_ENABLE
@@ -4980,7 +5377,7 @@ static int hevc_slice_segment_header_process(struct hevc_state_s *hevc,
 
 	config_sao_hw(hevc, rpm_param);
 
-	if ((hevc->slice_type != 2) && (i_only_flag & 0x2))
+	if ((hevc->slice_type != 2) && (hevc->i_only & 0x2))
 		return 0xf;
 
 	return 0;
@@ -4994,26 +5391,46 @@ static int H265_alloc_mmu(struct hevc_state_s *hevc, struct PIC_s *new_pic,
 	int bit_depth_10 = (bit_depth != 0x00);
 	int picture_size;
 	int cur_mmu_4k_number;
-
-	picture_size = compute_losless_comp_body_size(new_pic->width,
+	int ret;
+	picture_size = compute_losless_comp_body_size(hevc, new_pic->width,
 				new_pic->height, !bit_depth_10);
 	cur_mmu_4k_number = ((picture_size+(1<<12)-1) >> 12);
 
- /*
- *pr_info("alloc_mmu cur_idx : %d picture_size : %d mmu_4k_number : %d\r\n",
-*		cur_buf_idx, picture_size, cur_mmu_4k_number);
-*/
-	return decoder_mmu_box_alloc_idx(
+	/*hevc_print(hevc, 0,
+	"alloc_mmu cur_idx : %d picture_size : %d mmu_4k_number : %d\r\n",
+	cur_buf_idx, picture_size, cur_mmu_4k_number);*/
+	if (new_pic->scatter_alloc) {
+		decoder_mmu_box_free_idx(hevc->mmu_box, new_pic->index);
+		new_pic->scatter_alloc = 0;
+	}
+	ret = decoder_mmu_box_alloc_idx(
 	  hevc->mmu_box,
 	  cur_buf_idx,
 	  cur_mmu_4k_number,
 	  mmu_index_adr);
+	if (ret == 0)
+		new_pic->scatter_alloc = 1;
+	hevc_print(hevc, H265_DEBUG_BUFMGR_MORE,
+	"%s pic index %d page count(%d) ret =%d\n",
+	__func__, cur_buf_idx,
+	cur_mmu_4k_number,
+	ret);
+	return ret;
 }
 
 
-
-
-
+static void release_pic_mmu_buf(struct hevc_state_s *hevc,
+	struct PIC_s *pic)
+{
+	hevc_print(hevc, H265_DEBUG_BUFMGR_MORE,
+	"%s pic index %d scatter_alloc %d\n",
+	__func__, pic->index,
+	pic->scatter_alloc);
+
+	if (hevc->mmu_enable && pic->scatter_alloc)
+		decoder_mmu_box_free_idx(hevc->mmu_box, pic->index);
+	pic->scatter_alloc = 0;
+}
 
 /*
 *************************************************
@@ -5050,7 +5467,7 @@ static void hevc_local_uninit(struct hevc_state_s *hevc)
 		hevc->lmem_addr = NULL;
 	}
 
-	if (mmu_enable && hevc->frame_mmu_map_addr) {
+	if (hevc->mmu_enable && hevc->frame_mmu_map_addr) {
 		if (hevc->frame_mmu_map_phy_addr)
 			dma_free_coherent(amports_get_dma_device(),
 				FRAME_MMU_MAP_SIZE, hevc->frame_mmu_map_addr,
@@ -5059,7 +5476,8 @@ static void hevc_local_uninit(struct hevc_state_s *hevc)
 		hevc->frame_mmu_map_addr = NULL;
 	}
 
-
+	kfree(gvs);
+	gvs = NULL;
 }
 
 static int hevc_local_init(struct hevc_state_s *hevc)
@@ -5078,17 +5496,9 @@ static int hevc_local_init(struct hevc_state_s *hevc)
 		sizeof(struct BuffInfo_s));
 #endif
 	cur_buf_info->start_adr = hevc->buf_start;
-	hevc->mc_buf_spec.buf_end = hevc->buf_start + hevc->buf_size;
 	init_buff_spec(hevc, cur_buf_info);
 
-
-
-	hevc->mc_buf_spec.buf_start = (cur_buf_info->end_adr + 0xffff)
-	    & (~0xffff);
-	hevc->mc_buf_spec.buf_size = (hevc->mc_buf_spec.buf_end
-	    - hevc->mc_buf_spec.buf_start);
-
-	hevc_init_stru(hevc, cur_buf_info, &hevc->mc_buf_spec);
+	hevc_init_stru(hevc, cur_buf_info);
 
 	hevc->bit_depth_luma = 8;
 	hevc->bit_depth_chroma = 8;
@@ -5140,27 +5550,23 @@ static int hevc_local_init(struct hevc_state_s *hevc)
 		}
 	}
 
-	if (get_dbg_flag(hevc) & H265_DEBUG_UCODE) {
-		hevc->lmem_addr = kmalloc(LMEM_BUF_SIZE, GFP_KERNEL);
-		if (hevc->lmem_addr == NULL) {
-			pr_err("%s: failed to alloc lmem buffer\n", __func__);
-			return -1;
-		}
-
-		hevc->lmem_phy_addr = dma_map_single(amports_get_dma_device(),
-			hevc->lmem_addr, LMEM_BUF_SIZE, DMA_FROM_DEVICE);
-		if (dma_mapping_error(amports_get_dma_device(),
-			hevc->lmem_phy_addr)) {
-			pr_err("%s: failed to map lmem buffer\n", __func__);
-			kfree(hevc->lmem_addr);
-			hevc->lmem_addr = NULL;
-			return -1;
-		}
-
-		hevc->lmem_ptr = hevc->lmem_addr;
+	hevc->lmem_addr = kmalloc(LMEM_BUF_SIZE, GFP_KERNEL);
+	if (hevc->lmem_addr == NULL) {
+		pr_err("%s: failed to alloc lmem buffer\n", __func__);
+		return -1;
+	}
+	hevc->lmem_phy_addr = dma_map_single(amports_get_dma_device(),
+		hevc->lmem_addr, LMEM_BUF_SIZE, DMA_FROM_DEVICE);
+	if (dma_mapping_error(amports_get_dma_device(),
+		hevc->lmem_phy_addr)) {
+		pr_err("%s: failed to map lmem buffer\n", __func__);
+		kfree(hevc->lmem_addr);
+		hevc->lmem_addr = NULL;
+		return -1;
 	}
+	hevc->lmem_ptr = hevc->lmem_addr;
 
-	if (mmu_enable) {
+	if (hevc->mmu_enable) {
 		hevc->frame_mmu_map_addr =
 				dma_alloc_coherent(amports_get_dma_device(),
 				FRAME_MMU_MAP_SIZE,
@@ -5252,7 +5658,7 @@ static void set_canvas(struct hevc_state_s *hevc, struct PIC_s *pic)
 		pic->canvas_config[1].endian = 7;
 #endif
 	} else {
-		if (!mmu_enable) {
+		if (!hevc->mmu_enable) {
 			/* to change after 10bit VPU is ready ... */
 			pic->y_canvas_index = 128 + pic->index;
 			pic->uv_canvas_index = 128 + pic->index;
@@ -5322,10 +5728,10 @@ static int parse_sei(struct hevc_state_s *hevc, char *sei_buf, uint32_t size)
 		if (p+payload_size <= sei_buf+size) {
 			switch (payload_type) {
 			case SEI_MasteringDisplayColorVolume:
-				hevc_print(hevc, 0,
+				/*hevc_print(hevc, 0,
 					"sei type: primary display color volume %d, size %d\n",
 					payload_type,
-					payload_size);
+					payload_size);*/
 				/* master_display_colour */
 				p_sei = p;
 				for (i = 0; i < 3; i++) {
@@ -5352,7 +5758,7 @@ static int parse_sei(struct hevc_state_s *hevc, char *sei_buf, uint32_t size)
 				}
 				hevc->sei_present_flag |=
 					SEI_MASTER_DISPLAY_COLOR_MASK;
-				for (i = 0; i < 3; i++)
+				/*for (i = 0; i < 3; i++)
 					for (j = 0; j < 2; j++)
 						hevc_print(hevc, 0,
 						"\tprimaries[%1d][%1d] = %04x\n",
@@ -5365,7 +5771,7 @@ static int parse_sei(struct hevc_state_s *hevc, char *sei_buf, uint32_t size)
 				hevc_print(hevc, 0,
 					"\tmax,min luminance = %08x, %08x\n",
 					hevc->luminance[0],
-					hevc->luminance[1]);
+					hevc->luminance[1]);*/
 				break;
 			case SEI_ContentLightLevel:
 				hevc_print(hevc, 0,
@@ -5395,11 +5801,78 @@ static int parse_sei(struct hevc_state_s *hevc, char *sei_buf, uint32_t size)
 	return 0;
 }
 
-static void set_frame_info(struct hevc_state_s *hevc, struct vframe_s *vf)
+static unsigned calc_ar(unsigned idc, unsigned sar_w, unsigned sar_h,
+			unsigned w, unsigned h)
+{
+	unsigned ar;
+
+	if (idc	== 255) {
+		ar = div_u64(256ULL * sar_h * h,
+				sar_w * w);
+	} else {
+		switch (idc) {
+		case 1:
+			ar = 0x100 * h / w;
+			break;
+		case 2:
+			ar = 0x100 * h * 11 / (w * 12);
+			break;
+		case 3:
+			ar = 0x100 * h * 11 / (w * 10);
+			break;
+		case 4:
+			ar = 0x100 * h * 11 / (w * 16);
+			break;
+		case 5:
+			ar = 0x100 * h * 33 / (w * 40);
+			break;
+		case 6:
+			ar = 0x100 * h * 11 / (w * 24);
+			break;
+		case 7:
+			ar = 0x100 * h * 11 / (w * 20);
+			break;
+		case 8:
+			ar = 0x100 * h * 11 / (w * 32);
+			break;
+		case 9:
+			ar = 0x100 * h * 33 / (w * 80);
+			break;
+		case 10:
+			ar = 0x100 * h * 11 / (w * 18);
+			break;
+		case 11:
+			ar = 0x100 * h * 11 / (w * 15);
+			break;
+		case 12:
+			ar = 0x100 * h * 33 / (w * 64);
+			break;
+		case 13:
+			ar = 0x100 * h * 99 / (w * 160);
+			break;
+		case 14:
+			ar = 0x100 * h * 3 / (w * 4);
+			break;
+		case 15:
+			ar = 0x100 * h * 2 / (w * 3);
+			break;
+		case 16:
+			ar = 0x100 * h * 1 / (w * 2);
+			break;
+		default:
+			ar = h * 0x100 / w;
+			break;
+		}
+	}
+
+	return ar;
+}
+
+static void set_frame_info(struct hevc_state_s *hevc, struct vframe_s *vf,
+			struct PIC_s *pic)
 {
 	unsigned int ar;
 	int i, j;
-	unsigned char index;
 	char *p;
 	unsigned size = 0;
 	unsigned type = 0;
@@ -5408,11 +5881,11 @@ static void set_frame_info(struct hevc_state_s *hevc, struct vframe_s *vf)
 
 	if ((get_double_write_mode(hevc) == 2) ||
 		(get_double_write_mode(hevc) == 3)) {
-		vf->width = hevc->frame_width/4;
-		vf->height = hevc->frame_height/4;
+		vf->width = pic->width/4;
+		vf->height = pic->height/4;
 	} else {
-		vf->width = hevc->frame_width;
-		vf->height = hevc->frame_height;
+		vf->width = pic->width;
+		vf->height = pic->height;
 	}
 	vf->duration = hevc->frame_dur;
 	vf->duration_pulldown = 0;
@@ -5427,16 +5900,26 @@ static void set_frame_info(struct hevc_state_s *hevc, struct vframe_s *vf)
 	else
 		vf->signal_type = 0;
 
-	/* parser sei */
-	index = vf->index & 0xff;
-	if (index != 0xff && index >= 0
-		&& index < MAX_REF_PIC_NUM
-		&& hevc->m_PIC[index]
-		&& hevc->m_PIC[index]->aux_data_buf
-		&& hevc->m_PIC[index]->aux_data_size) {
-		p = hevc->m_PIC[index]->aux_data_buf;
-		while (p < hevc->m_PIC[index]->aux_data_buf
-			+ hevc->m_PIC[index]->aux_data_size - 8) {
+	if (((pic->aspect_ratio_idc == 255) &&
+		pic->sar_width &&
+		pic->sar_height) ||
+		((pic->aspect_ratio_idc != 255) &&
+		(pic->width))) {
+		ar = min_t(u32,
+			calc_ar(pic->aspect_ratio_idc,
+			pic->sar_width,
+			pic->sar_height,
+			pic->width,
+			pic->height),
+			DISP_RATIO_ASPECT_RATIO_MAX);
+		vf->ratio_control = (ar << DISP_RATIO_ASPECT_RATIO_BIT);
+	}
+	if (pic->aux_data_buf
+		&& pic->aux_data_size) {
+		/* parser sei */
+		p = pic->aux_data_buf;
+		while (p < pic->aux_data_buf
+			+ pic->aux_data_size - 8) {
 			size = *p++;
 			size = (size << 8) | *p++;
 			size = (size << 8) | *p++;
@@ -5446,7 +5929,8 @@ static void set_frame_info(struct hevc_state_s *hevc, struct vframe_s *vf)
 			type = (type << 8) | *p++;
 			type = (type << 8) | *p++;
 			if (type == 0x02000000) {
-				/* hevc_print(hevc, 0, "sei(%d)\n", size); */
+				/* hevc_print(hevc, 0,
+				"sei(%d)\n", size); */
 				parse_sei(hevc, p, size);
 			}
 			p += size;
@@ -5514,6 +5998,12 @@ static struct vframe_s *vh265_vf_peek(void *op_arg)
 	if (step == 2)
 		return NULL;
 
+	if (force_disp_pic_index & 0x100) {
+		if (force_disp_pic_index & 0x200)
+			return NULL;
+		return &hevc->vframe_dummy;
+	}
+
 	if (kfifo_peek(&hevc->display_q, &vf))
 		return vf;
 
@@ -5535,13 +6025,94 @@ static struct vframe_s *vh265_vf_get(void *op_arg)
 	else if (step == 1)
 		step = 2;
 
+#if 0
+	if (force_disp_pic_index & 0x100) {
+		int buffer_index = force_disp_pic_index & 0xff;
+		struct PIC_s *pic = NULL;
+		if (buffer_index >= 0
+			&& buffer_index < MAX_REF_PIC_NUM)
+			pic = hevc->m_PIC[buffer_index];
+		if (pic == NULL)
+			return NULL;
+		if (force_disp_pic_index & 0x200)
+			return NULL;
+
+		vf = &hevc->vframe_dummy;
+		if (get_double_write_mode(hevc)) {
+			vf->type = VIDTYPE_PROGRESSIVE | VIDTYPE_VIU_FIELD |
+				VIDTYPE_VIU_NV21;
+			if (hevc->m_ins_flag) {
+				vf->canvas0Addr = vf->canvas1Addr = -1;
+				vf->plane_num = 2;
+				vf->canvas0_config[0] =
+					pic->canvas_config[0];
+				vf->canvas0_config[1] =
+					pic->canvas_config[1];
+
+				vf->canvas1_config[0] =
+					pic->canvas_config[0];
+				vf->canvas1_config[1] =
+					pic->canvas_config[1];
+			} else {
+				vf->canvas0Addr = vf->canvas1Addr
+				= spec2canvas(pic);
+			}
+		} else {
+			vf->canvas0Addr = vf->canvas1Addr = 0;
+			vf->type = VIDTYPE_COMPRESS | VIDTYPE_VIU_FIELD;
+			if (hevc->mmu_enable)
+				vf->type |= VIDTYPE_SCATTER;
+		}
+		vf->compWidth = pic->width;
+		vf->compHeight = pic->height;
+		update_vf_memhandle(hevc, vf, pic);
+		switch (hevc->bit_depth_luma) {
+		case 9:
+			vf->bitdepth = BITDEPTH_Y9 | BITDEPTH_U9 | BITDEPTH_V9;
+			break;
+		case 10:
+			vf->bitdepth = BITDEPTH_Y10 | BITDEPTH_U10
+				| BITDEPTH_V10;
+			break;
+		default:
+			vf->bitdepth = BITDEPTH_Y8 | BITDEPTH_U8 | BITDEPTH_V8;
+			break;
+		}
+		if ((vf->type & VIDTYPE_COMPRESS) == 0)
+			vf->bitdepth =
+				BITDEPTH_Y8 | BITDEPTH_U8 | BITDEPTH_V8;
+		if (hevc->mem_saving_mode == 1)
+			vf->bitdepth |= BITDEPTH_SAVING_MODE;
+		vf->duration_pulldown = 0;
+		vf->pts = 0;
+		vf->pts_us64 = 0;
+		set_frame_info(hevc, vf);
+		if ((get_double_write_mode(hevc) == 2) ||
+			(get_double_write_mode(hevc) == 3)) {
+			vf->width = pic->width/4;
+			vf->height = pic->height/4;
+		}	else {
+			vf->width = pic->width;
+			vf->height = pic->height;
+		}
+
+		force_disp_pic_index |= 0x200;
+		return vf;
+	}
+#endif
+
 	if (kfifo_get(&hevc->display_q, &vf)) {
 		if (get_dbg_flag(hevc) & H265_DEBUG_PIC_STRUCT)
 			hevc_print(hevc, 0,
-				"%s(type %d index 0x%x)\n",
-				__func__, vf->type, vf->index);
+				"%s(type %d index 0x%x poc %d/%d) pts(%d,%d) dur %d\n",
+				__func__, vf->type, vf->index,
+				get_pic_poc(hevc, vf->index & 0xff),
+				get_pic_poc(hevc, (vf->index >> 8) & 0xff),
+				vf->pts, vf->pts_us64,
+				vf->duration);
 
 		hevc->show_frame_num++;
+		hevc->vf_get_count++;
 		return vf;
 	}
 
@@ -5559,11 +6130,13 @@ static void vh265_vf_put(struct vframe_s *vf, void *op_arg)
 #endif
 	unsigned char index_top = vf->index & 0xff;
 	unsigned char index_bot = (vf->index >> 8) & 0xff;
+	if (vf == (&hevc->vframe_dummy))
+		return;
 	if (get_dbg_flag(hevc) & H265_DEBUG_PIC_STRUCT)
 		hevc_print(hevc, 0,
 			"%s(type %d index 0x%x)\n",
 			__func__, vf->type, vf->index);
-
+	hevc->vf_put_count++;
 	kfifo_put(&hevc->newframe_q, (const struct vframe_s *)vf);
 	spin_lock_irqsave(&lock, flags);
 
@@ -5575,10 +6148,7 @@ static void vh265_vf_put(struct vframe_s *vf, void *op_arg)
 
 			if (hevc->m_PIC[index_top]->vf_ref == 0) {
 				hevc->m_PIC[index_top]->output_ready = 0;
-				if (mmu_enable)
-					hevc->m_PIC[index_top]->
-						used_by_display	= 0;
-				hevc->last_put_idx_a = index_top;
+
 				if (hevc->wait_buf != 0)
 					WRITE_VREG(HEVC_ASSIST_MBOX1_IRQ_REG,
 						0x1);
@@ -5593,9 +6163,7 @@ static void vh265_vf_put(struct vframe_s *vf, void *op_arg)
 			hevc->m_PIC[index_bot]->vf_ref--;
 
 			if (hevc->m_PIC[index_bot]->vf_ref == 0) {
-				clear_used_by_display_flag(hevc);
 				hevc->m_PIC[index_bot]->output_ready = 0;
-				hevc->last_put_idx_b = index_bot;
 				if (hevc->wait_buf != 0)
 					WRITE_VREG(HEVC_ASSIST_MBOX1_IRQ_REG,
 						0x1);
@@ -5685,6 +6253,7 @@ static int process_pending_vframe(struct hevc_state_s *hevc,
 			hevc_print(hevc, 0,
 			"%s warning(1), vf=>display_q: (index 0x%x)\n",
 				__func__, vf->index);
+		hevc->vf_pre_count++;
 		kfifo_put(&hevc->display_q, (const struct vframe_s *)vf);
 	}
 
@@ -5703,9 +6272,11 @@ static int process_pending_vframe(struct hevc_state_s *hevc,
 				hevc_print(hevc, 0,
 				"%s warning(2), vf=>display_q: (index 0x%x)\n",
 				__func__, vf->index);
-			if (vf)
+			if (vf) {
+				hevc->vf_pre_count++;
 				kfifo_put(&hevc->display_q,
 				(const struct vframe_s *)vf);
+			}
 		} else if ((!pair_frame_top_flag) &&
 			(((vf->index >> 8) & 0xff) == 0xff)) {
 			if (kfifo_get(&hevc->pending_q, &vf) == 0) {
@@ -5722,6 +6293,7 @@ static int process_pending_vframe(struct hevc_state_s *hevc,
 				pair_pic->vf_ref++;
 				kfifo_put(&hevc->display_q,
 				(const struct vframe_s *)vf);
+				hevc->vf_pre_count++;
 				if (get_dbg_flag(hevc) & H265_DEBUG_PIC_STRUCT)
 					hevc_print(hevc, 0,
 					"%s vf => display_q: (index 0x%x)\n",
@@ -5743,6 +6315,7 @@ static int process_pending_vframe(struct hevc_state_s *hevc,
 				pair_pic->vf_ref++;
 				kfifo_put(&hevc->display_q,
 				(const struct vframe_s *)vf);
+				hevc->vf_pre_count++;
 				if (get_dbg_flag(hevc) & H265_DEBUG_PIC_STRUCT)
 					hevc_print(hevc, 0,
 					"%s vf => display_q: (index 0x%x)\n",
@@ -5754,40 +6327,70 @@ static int process_pending_vframe(struct hevc_state_s *hevc,
 }
 #endif
 static void update_vf_memhandle(struct hevc_state_s *hevc,
-	struct vframe_s *vf, int index)
+	struct vframe_s *vf, struct PIC_s *pic)
 {
-	if (index < 0)
+	if (pic->index < 0) {
 		vf->mem_handle = NULL;
-	else if (vf->type & VIDTYPE_SCATTER)
+		vf->mem_head_handle = NULL;
+	} else if (vf->type & VIDTYPE_SCATTER) {
 		vf->mem_handle =
 			decoder_mmu_box_get_mem_handle(
-				hevc->mmu_box, index);
-	else
+				hevc->mmu_box, pic->index);
+		vf->mem_head_handle =
+			decoder_bmmu_box_get_mem_handle(
+				hevc->bmmu_box, VF_BUFFER_IDX(pic->BUF_index));
+	} else {
 		vf->mem_handle =
 			decoder_bmmu_box_get_mem_handle(
-				hevc->bmmu_box, index);
+				hevc->bmmu_box, VF_BUFFER_IDX(pic->BUF_index));
+		vf->mem_head_handle = NULL;
+		/*vf->mem_head_handle =
+			decoder_bmmu_box_get_mem_handle(
+				hevc->bmmu_box, VF_BUFFER_IDX(BUF_index));*/
+	}
 	return;
 }
 static int prepare_display_buf(struct hevc_state_s *hevc, struct PIC_s *pic)
 {
+#ifdef CONFIG_AM_VDEC_DV
+	struct vdec_s *vdec = hw_to_vdec(hevc);
+#endif
 	struct vframe_s *vf = NULL;
 	int stream_offset = pic->stream_offset;
 	unsigned short slice_type = pic->slice_type;
-
+	if (force_disp_pic_index & 0x100) {
+		/*recycle directly*/
+		pic->output_ready = 0;
+		return -1;
+	}
 	if (kfifo_get(&hevc->newframe_q, &vf) == 0) {
 		hevc_print(hevc, 0,
 			"fatal error, no available buffer slot.");
 		return -1;
 	}
-
+	display_frame_count[hevc->index]++;
 	if (vf) {
-		if (hevc->m_ins_flag) {
+		/*hevc_print(hevc, PRINT_FLAG_VDEC_STATUS,
+			"%s: pic index 0x%x\n",
+			__func__, pic->index);*/
+
+#ifdef MULTI_INSTANCE_SUPPORT
+		if (vdec_frame_based(hw_to_vdec(hevc))) {
 			vf->pts = pic->pts;
 			vf->pts_us64 = pic->pts64;
 		}
 		/* if (pts_lookup_offset(PTS_TYPE_VIDEO,
 		   stream_offset, &vf->pts, 0) != 0) { */
-		else if (pts_lookup_offset_us64
+#ifdef CONFIG_AM_VDEC_DV
+		else if (vdec->master == NULL) {
+#else
+		else {
+#endif
+#endif
+		hevc_print(hevc, H265_DEBUG_OUT_PTS,
+			"call pts_lookup_offset_us64(0x%x)\n",
+			stream_offset);
+		if (pts_lookup_offset_us64
 			(PTS_TYPE_VIDEO, stream_offset, &vf->pts, 0,
 			 &vf->pts_us64) != 0) {
 #ifdef DEBUG_PTS
@@ -5800,6 +6403,16 @@ static int prepare_display_buf(struct hevc_state_s *hevc, struct PIC_s *pic)
 		else
 			hevc->pts_hit++;
 #endif
+#ifdef MULTI_INSTANCE_SUPPORT
+#ifdef CONFIG_AM_VDEC_DV
+		} else {
+			vf->pts = 0;
+			vf->pts_us64 = 0;
+		}
+#else
+		}
+#endif
+#endif
 		if (pts_unstable && (hevc->frame_dur > 0))
 			hevc->pts_mode = PTS_NONE_REF_USE_DURATION;
 
@@ -5873,13 +6486,14 @@ static int prepare_display_buf(struct hevc_state_s *hevc, struct PIC_s *pic)
 			vf->compHeadAddr = 0;
 		} else {
 
-		if (mmu_enable) {
+		if (hevc->mmu_enable) {
 			vf->compBodyAddr = 0;
 			vf->compHeadAddr = pic->header_adr;
 		} else {
 			vf->compBodyAddr = pic->mc_y_adr; /*body adr*/
 			vf->compHeadAddr = pic->mc_y_adr +
 						pic->losless_comp_body_size;
+			vf->mem_head_handle = NULL;
 		}
 
 					/*head adr*/
@@ -5888,12 +6502,15 @@ static int prepare_display_buf(struct hevc_state_s *hevc, struct PIC_s *pic)
 		if (get_double_write_mode(hevc)) {
 			vf->type = VIDTYPE_PROGRESSIVE | VIDTYPE_VIU_FIELD;
 			vf->type |= VIDTYPE_VIU_NV21;
-			if (get_double_write_mode(hevc) == 3)
+			if (get_double_write_mode(hevc) == 3) {
 				vf->type |= VIDTYPE_COMPRESS;
-			if (mmu_enable)
-				vf->type |= VIDTYPE_SCATTER;
+				if (hevc->mmu_enable)
+					vf->type |= VIDTYPE_SCATTER;
+			}
 #ifdef MULTI_INSTANCE_SUPPORT
-			if (hevc->m_ins_flag) {
+			if (hevc->m_ins_flag &&
+				(get_dbg_flag(hevc)
+				& H265_CFG_CANVAS_IN_DECODE) == 0) {
 					vf->canvas0Addr = vf->canvas1Addr = -1;
 					vf->plane_num = 2;
 					vf->canvas0_config[0] =
@@ -5901,26 +6518,25 @@ static int prepare_display_buf(struct hevc_state_s *hevc, struct PIC_s *pic)
 					vf->canvas0_config[1] =
 						pic->canvas_config[1];
 
-				vf->canvas1_config[0] =
-					pic->canvas_config[0];
-				vf->canvas1_config[1] =
-					pic->canvas_config[1];
+					vf->canvas1_config[0] =
+						pic->canvas_config[0];
+					vf->canvas1_config[1] =
+						pic->canvas_config[1];
 
 			} else
 #endif
-			vf->canvas0Addr = vf->canvas1Addr
-			= spec2canvas(pic);
+				vf->canvas0Addr = vf->canvas1Addr
+				= spec2canvas(pic);
 		} else {
 			vf->canvas0Addr = vf->canvas1Addr = 0;
 			vf->type = VIDTYPE_COMPRESS | VIDTYPE_VIU_FIELD;
-		if (mmu_enable)
-			vf->type |= VIDTYPE_SCATTER;
-
+			if (hevc->mmu_enable)
+				vf->type |= VIDTYPE_SCATTER;
 		}
 		vf->compWidth = pic->width;
 		vf->compHeight = pic->height;
-		update_vf_memhandle(hevc, vf, pic->index);
-		switch (hevc->bit_depth_luma) {
+		update_vf_memhandle(hevc, vf, pic);
+		switch (pic->bit_depth_luma) {
 		case 9:
 			vf->bitdepth = BITDEPTH_Y9;
 			break;
@@ -5931,7 +6547,7 @@ static int prepare_display_buf(struct hevc_state_s *hevc, struct PIC_s *pic)
 			vf->bitdepth = BITDEPTH_Y8;
 			break;
 		}
-		switch (hevc->bit_depth_chroma) {
+		switch (pic->bit_depth_chroma) {
 		case 9:
 			vf->bitdepth |= (BITDEPTH_U9 | BITDEPTH_V9);
 			break;
@@ -5942,14 +6558,17 @@ static int prepare_display_buf(struct hevc_state_s *hevc, struct PIC_s *pic)
 			vf->bitdepth |= (BITDEPTH_U8 | BITDEPTH_V8);
 			break;
 		}
-		if (hevc->mem_saving_mode == 1)
+		if ((vf->type & VIDTYPE_COMPRESS) == 0)
+			vf->bitdepth =
+				BITDEPTH_Y8 | BITDEPTH_U8 | BITDEPTH_V8;
+		if (pic->mem_saving_mode == 1)
 			vf->bitdepth |= BITDEPTH_SAVING_MODE;
 #else
 		vf->type = VIDTYPE_PROGRESSIVE | VIDTYPE_VIU_FIELD;
 		vf->type |= VIDTYPE_VIU_NV21;
 		vf->canvas0Addr = vf->canvas1Addr = spec2canvas(pic);
 #endif
-		set_frame_info(hevc, vf);
+		set_frame_info(hevc, vf, pic);
 		/* if((vf->width!=pic->width)||(vf->height!=pic->height)) */
 		/* hevc_print(hevc, 0,
 			"aaa: %d/%d, %d/%d\n",
@@ -5974,7 +6593,10 @@ static int prepare_display_buf(struct hevc_state_s *hevc, struct PIC_s *pic)
 			else
 				vf->duration = 0;
 		}
-
+		if (force_fps & 0x200) {
+			vf->pts = 0;
+			vf->pts_us64 = 0;
+		}
 		/*
 		*	!!! to do ...
 		*	need move below code to get_new_pic(),
@@ -6045,8 +6667,10 @@ static int prepare_display_buf(struct hevc_state_s *hevc, struct PIC_s *pic)
 				vf2->type = VIDTYPE_INTERLACE_TOP
 				| VIDTYPE_VIU_NV21;
 			}
+			hevc->vf_pre_count++;
 			kfifo_put(&hevc->display_q,
 			(const struct vframe_s *)vf);
+			hevc->vf_pre_count++;
 			kfifo_put(&hevc->display_q,
 			(const struct vframe_s *)vf2);
 		} else if (pic->pic_struct == 5
@@ -6088,10 +6712,13 @@ static int prepare_display_buf(struct hevc_state_s *hevc, struct PIC_s *pic)
 				vf3->type = VIDTYPE_INTERLACE_BOTTOM
 				| VIDTYPE_VIU_NV21;
 			}
+			hevc->vf_pre_count++;
 			kfifo_put(&hevc->display_q,
 			(const struct vframe_s *)vf);
+			hevc->vf_pre_count++;
 			kfifo_put(&hevc->display_q,
 			(const struct vframe_s *)vf2);
+			hevc->vf_pre_count++;
 			kfifo_put(&hevc->display_q,
 			(const struct vframe_s *)vf3);
 
@@ -6194,15 +6821,29 @@ static int prepare_display_buf(struct hevc_state_s *hevc, struct PIC_s *pic)
 				hevc->pre_bot_pic = pic;
 				break;
 			}
+			hevc->vf_pre_count++;
 			kfifo_put(&hevc->display_q,
 			(const struct vframe_s *)vf);
 		}
 #else
 		vf->type_original = vf->type;
 		pic->vf_ref = 1;
+		hevc->vf_pre_count++;
 		kfifo_put(&hevc->display_q, (const struct vframe_s *)vf);
-#endif
 
+		if (get_dbg_flag(hevc) & H265_DEBUG_PIC_STRUCT)
+			hevc_print(hevc, 0,
+				"%s(type %d index 0x%x poc %d/%d) pts(%d,%d) dur %d\n",
+				__func__, vf->type, vf->index,
+				get_pic_poc(hevc, vf->index & 0xff),
+				get_pic_poc(hevc, (vf->index >> 8) & 0xff),
+				vf->pts, vf->pts_us64,
+				vf->duration);
+#endif
+#ifndef CONFIG_MULTI_DEC
+		/*count info*/
+		vdec_count_info(gvs, 0, stream_offset);
+#endif
 		vf_notify_receiver(hevc->provider_name,
 				VFRAME_EVENT_PROVIDER_VFRAME_READY, NULL);
 	}
@@ -6310,10 +6951,11 @@ static int hevc_recover(struct hevc_state_s *hevc)
 		return ret;
 	}
 	amhevc_stop();
+	msleep(20);
 	ret = 0;
 	/* reset */
-	WRITE_MPEG_REG(PARSER_VIDEO_RP, READ_VREG(HEVC_STREAM_RD_PTR));
-	SET_MPEG_REG_MASK(PARSER_ES_CONTROL, ES_VID_MAN_RD_PTR);
+	WRITE_PARSER_REG(PARSER_VIDEO_RP, READ_VREG(HEVC_STREAM_RD_PTR));
+	SET_PARSER_REG_MASK(PARSER_ES_CONTROL, ES_VID_MAN_RD_PTR);
 
 	hevc_stream_start_addr = READ_VREG(HEVC_STREAM_START_ADDR);
 	hevc_stream_end_addr = READ_VREG(HEVC_STREAM_END_ADDR);
@@ -6381,12 +7023,9 @@ static int hevc_recover(struct hevc_state_s *hevc)
 	/* disable PSCALE for hardware sharing */
 	WRITE_VREG(HEVC_PSCALE_CTRL, 0);
 
-	CLEAR_MPEG_REG_MASK(PARSER_ES_CONTROL, ES_VID_MAN_RD_PTR);
+	CLEAR_PARSER_REG_MASK(PARSER_ES_CONTROL, ES_VID_MAN_RD_PTR);
 
-	if (get_dbg_flag(hevc) & H265_DEBUG_UCODE)
-		WRITE_VREG(DEBUG_REG1, 0x1);
-	else
-		WRITE_VREG(DEBUG_REG1, 0x0);
+	WRITE_VREG(DEBUG_REG1, 0x0);
 
 	if ((error_handle_policy & 1) == 0) {
 		if ((error_handle_policy & 4) == 0) {
@@ -6411,7 +7050,7 @@ static int hevc_recover(struct hevc_state_s *hevc)
 		((parser_dolby_vision_enable & 0x1) << 20));
 #endif
 	config_decode_mode(hevc);
-	WRITE_VREG(DECODE_STOP_POS, decode_stop_pos);
+	WRITE_VREG(DECODE_STOP_POS, udebug_flag);
 
 	/* if (amhevc_loadmc(vh265_mc) < 0) { */
 	/* amhevc_disable(); */
@@ -6432,7 +7071,7 @@ static int hevc_recover(struct hevc_state_s *hevc)
 #endif
 	init_pic_list_hw(hevc);
 
-	hevc_print(hevc, 0, "%s HEVC_SHIFT_BYTE_COUNT=%x\n", __func__,
+	hevc_print(hevc, 0, "%s HEVC_SHIFT_BYTE_COUNT=0x%x\n", __func__,
 		   READ_VREG(HEVC_SHIFT_BYTE_COUNT));
 
 	amhevc_start();
@@ -6503,6 +7142,44 @@ static void dump_aux_buf(struct hevc_state_s *hevc)
 	}
 }
 
+#ifdef CONFIG_AM_VDEC_DV
+static void dolby_get_meta(struct hevc_state_s *hevc)
+{
+	struct vdec_s *vdec = hw_to_vdec(hevc);
+	dma_sync_single_for_cpu(
+	amports_get_dma_device(),
+	hevc->aux_phy_addr,
+	hevc->prefix_aux_size + hevc->suffix_aux_size,
+	DMA_FROM_DEVICE);
+	if (get_dbg_flag(hevc) &
+		H265_DEBUG_BUFMGR_MORE)
+		dump_aux_buf(hevc);
+	if (dolby_meta_with_el || vdec->slave) {
+		set_aux_data(hevc,
+		hevc->cur_pic, 0, 0);
+	} else if (vdec->master) {
+		struct hevc_state_s *hevc_ba =
+		(struct hevc_state_s *)
+			vdec->master->private;
+		/*do not use hevc_ba*/
+		set_aux_data(hevc,
+		hevc_ba->cur_pic,
+			0, 1);
+		set_aux_data(hevc,
+		hevc->cur_pic, 0, 2);
+	}
+}
+#endif
+
+static void read_decode_info(struct hevc_state_s *hevc)
+{
+	uint32_t decode_info =
+		READ_HREG(HEVC_DECODE_INFO);
+	hevc->start_decoding_flag =
+		decode_info & 0xff;
+	hevc->rps_set_id = (decode_info >> 8) & 0xff;
+}
+
 static irqreturn_t vh265_isr_thread_fn(int irq, void *data)
 {
 	struct hevc_state_s *hevc = (struct hevc_state_s *) data;
@@ -6511,7 +7188,13 @@ static irqreturn_t vh265_isr_thread_fn(int irq, void *data)
 #ifdef CONFIG_AM_VDEC_DV
 	struct vdec_s *vdec = hw_to_vdec(hevc);
 #endif
-	if (hevc->error_flag == 1) {
+	if (hevc->eos)
+		return IRQ_HANDLED;
+	if (
+#ifdef MULTI_INSTANCE_SUPPORT
+		(!hevc->m_ins_flag) &&
+#endif
+		hevc->error_flag == 1) {
 		if ((error_handle_policy & 0x10) == 0) {
 			if (hevc->cur_pic) {
 				int current_lcu_idx =
@@ -6533,7 +7216,12 @@ static irqreturn_t vh265_isr_thread_fn(int irq, void *data)
 			hevc->error_skip_nal_count = error_skip_nal_count;
 			WRITE_VREG(NAL_SEARCH_CTL, 0x1);/* manual parser NAL */
 		}
-		if (get_dbg_flag(hevc) & H265_DEBUG_NO_EOS_SEARCH_DONE) {
+		if ((get_dbg_flag(hevc) & H265_DEBUG_NO_EOS_SEARCH_DONE)
+#ifdef CONFIG_AM_VDEC_DV
+			|| vdec->master
+			|| vdec->slave
+#endif
+			) {
 			WRITE_VREG(NAL_SEARCH_CTL,
 					   READ_VREG(NAL_SEARCH_CTL) | 0x10000);
 		}
@@ -6555,7 +7243,11 @@ static irqreturn_t vh265_isr_thread_fn(int irq, void *data)
 		"%s: error handle\n", __func__); */
 		hevc->error_flag = 2;
 		return IRQ_HANDLED;
-	} else if (hevc->error_flag == 3) {
+	} else if (
+#ifdef MULTI_INSTANCE_SUPPORT
+		(!hevc->m_ins_flag) &&
+#endif
+		hevc->error_flag == 3) {
 		hevc_print(hevc, 0, "error_flag=3, hevc_recover\n");
 		hevc_recover(hevc);
 		hevc->error_flag = 0;
@@ -6590,64 +7282,76 @@ static irqreturn_t vh265_isr_thread_fn(int irq, void *data)
 		}
 		return IRQ_HANDLED;
 	}
-
-	i = READ_VREG(HEVC_SHIFT_BYTE_COUNT);
-	if ((hevc->shift_byte_count_lo & (1 << 31)) && ((i & (1 << 31)) == 0))
-		hevc->shift_byte_count_hi++;
-	hevc->shift_byte_count_lo = i;
-
+	if (!hevc->m_ins_flag) {
+		i = READ_VREG(HEVC_SHIFT_BYTE_COUNT);
+		if ((hevc->shift_byte_count_lo & (1 << 31))
+			&& ((i & (1 << 31)) == 0))
+			hevc->shift_byte_count_hi++;
+		hevc->shift_byte_count_lo = i;
+	}
 #ifdef MULTI_INSTANCE_SUPPORT
 	if ((dec_status == HEVC_DECPIC_DATA_DONE ||
 		dec_status == HEVC_FIND_NEXT_PIC_NAL ||
 		dec_status == HEVC_FIND_NEXT_DVEL_NAL)
-		&& (hevc->m_ins_flag)) {
-		if (hevc->chunk) {
-			hevc->cur_pic->pts = hevc->chunk->pts;
-			hevc->cur_pic->pts64 = hevc->chunk->pts64;
-		} else if (pts_lookup_offset_us64
-			(PTS_TYPE_VIDEO,
-			hevc->cur_pic->stream_offset,
-			&hevc->cur_pic->pts,
-			0,
-			&hevc->cur_pic->pts64) != 0) {
-#ifdef DEBUG_PTS
-			hevc->pts_missed++;
-#endif
-			hevc->cur_pic->pts = 0;
-			hevc->cur_pic->pts64 = 0;
-		}
+		&& (hevc->chunk)) {
+		hevc->cur_pic->pts = hevc->chunk->pts;
+		hevc->cur_pic->pts64 = hevc->chunk->pts64;
 	}
 
-	if ((dec_status == HEVC_SEARCH_BUFEMPTY) ||
-		(dec_status == HEVC_DECODE_BUFEMPTY) ||
+	if (dec_status == HEVC_DECODE_BUFEMPTY ||
+		dec_status == HEVC_DECODE_BUFEMPTY2) {
+		if (hevc->m_ins_flag) {
+			read_decode_info(hevc);
+			if (vdec_frame_based(hw_to_vdec(hevc))) {
+				goto pic_done;
+			} else {
+				if (
+#ifdef CONFIG_AM_VDEC_DV
+					vdec->master ||
+					vdec->slave ||
+#endif
+					(data_resend_policy & 0x1)) {
+					hevc->dec_result = DEC_RESULT_AGAIN;
+					amhevc_stop();
+					restore_decode_state(hevc);
+				} else
+					hevc->dec_result = DEC_RESULT_GET_DATA;
+			}
+			reset_process_time(hevc);
+			vdec_schedule_work(&hevc->work);
+		}
+		return IRQ_HANDLED;
+	} else if ((dec_status == HEVC_SEARCH_BUFEMPTY) ||
 		(dec_status == HEVC_NAL_DECODE_DONE)
 		) {
 		if (hevc->m_ins_flag) {
-#if 1
-			if (!vdec_frame_based(hw_to_vdec(hevc))) {
+			read_decode_info(hevc);
+			if (vdec_frame_based(hw_to_vdec(hevc))) {
+				/*hevc->dec_result = DEC_RESULT_GET_DATA;*/
+				goto pic_done;
+			} else {
 				hevc->dec_result = DEC_RESULT_AGAIN;
 				amhevc_stop();
-			} else
-				hevc->dec_result = DEC_RESULT_GET_DATA;
-#else
-			if (!vdec_frame_based(hw_to_vdec(hevc)))
-				hevc->dec_result = DEC_RESULT_AGAIN;
-			else
-				hevc->dec_result = DEC_RESULT_DONE;
-			amhevc_stop();
-#endif
+				restore_decode_state(hevc);
+			}
+
 			reset_process_time(hevc);
-			schedule_work(&hevc->work);
+			vdec_schedule_work(&hevc->work);
 		}
 
 		return IRQ_HANDLED;
 	} else if (dec_status == HEVC_DECPIC_DATA_DONE) {
 		if (hevc->m_ins_flag) {
+pic_done:
+			read_decode_info(hevc);
+
+			hevc->decoded_poc = hevc->curr_POC;
+			hevc->decoding_pic = NULL;
 			hevc->dec_result = DEC_RESULT_DONE;
 			amhevc_stop();
 
 			reset_process_time(hevc);
-			schedule_work(&hevc->work);
+			vdec_schedule_work(&hevc->work);
 		}
 
 		return IRQ_HANDLED;
@@ -6655,8 +7359,10 @@ static irqreturn_t vh265_isr_thread_fn(int irq, void *data)
 	} else if (dec_status == HEVC_FIND_NEXT_PIC_NAL ||
 		dec_status == HEVC_FIND_NEXT_DVEL_NAL) {
 		if (hevc->m_ins_flag) {
-			unsigned next_parser_type =
-					READ_HREG(CUR_NAL_UNIT_TYPE);
+			unsigned char next_parser_type =
+					READ_HREG(CUR_NAL_UNIT_TYPE) & 0xff;
+			read_decode_info(hevc);
+
 			if (vdec->slave &&
 				dec_status == HEVC_FIND_NEXT_DVEL_NAL) {
 				/*cur is base, found enhance*/
@@ -6680,68 +7386,32 @@ static irqreturn_t vh265_isr_thread_fn(int irq, void *data)
 				hevc->start_parser_type =
 					next_parser_type;
 			}
+			hevc->decoded_poc = hevc->curr_POC;
+			hevc->decoding_pic = NULL;
 			hevc->dec_result = DEC_RESULT_DONE;
 			amhevc_stop();
 			reset_process_time(hevc);
-			if (READ_VREG(HEVC_AUX_DATA_SIZE) != 0) {
-				dma_sync_single_for_cpu(
-				amports_get_dma_device(),
-				hevc->aux_phy_addr,
-				hevc->prefix_aux_size + hevc->suffix_aux_size,
-				DMA_FROM_DEVICE);
-				if (get_dbg_flag(hevc) &
-					H265_DEBUG_BUFMGR_MORE)
-					dump_aux_buf(hevc);
-				if (hevc->cur_pic)
-					set_aux_data(hevc, hevc->cur_pic, 0);
-			}
+			if (READ_VREG(HEVC_AUX_DATA_SIZE) != 0)
+				dolby_get_meta(hevc);
 
-			schedule_work(&hevc->work);
+			vdec_schedule_work(&hevc->work);
 		}
 
 		return IRQ_HANDLED;
 #endif
-	} else if (dec_status == HEVC_DECODE_TIMEOUT) {
-		if (vdec_frame_based(hw_to_vdec(hevc)) ||
-			(READ_VREG(HEVC_STREAM_LEVEL) > 0x200)) {
-			if ((get_dbg_flag(hevc)
-				& H265_DEBUG_DIS_LOC_ERROR_PROC)) {
-				hevc_print(hevc, 0,
-					"%s decoding error, level 0x%x\n",
-					__func__, READ_VREG(HEVC_STREAM_LEVEL));
-				goto send_again;
-			}
-			amhevc_stop();
-			hevc_print(hevc, PRINT_FLAG_VDEC_STATUS,
-				"%s %s\n", __func__,
-				(dec_status == HEVC_SEARCH_BUFEMPTY) ?
-				"HEVC_SEARCH_BUFEMPTY" :
-				(dec_status == HEVC_DECODE_BUFEMPTY) ?
-				"HEVC_DECODE_BUFEMPTY" : "HEVC_DECODE_TIMEOUT");
-			hevc->dec_result = DEC_RESULT_DONE;
-
-			reset_process_time(hevc);
-			schedule_work(&hevc->work);
-		} else {
-			/* WRITE_VREG(dec_status_REG, H264_ACTION_INIT); */
-			hevc_print(hevc, PRINT_FLAG_VDEC_STATUS,
-				"%s DEC_RESULT_AGAIN\n", __func__);
-send_again:
-			hevc->dec_result = DEC_RESULT_AGAIN;
-			reset_process_time(hevc);
-			schedule_work(&hevc->work);
-		}
-		return IRQ_HANDLED;
 	}
 
 #endif
 
 	if (dec_status == HEVC_SEI_DAT) {
-		int payload_type = READ_HREG(CUR_NAL_UNIT_TYPE) & 0xffff;
-		int payload_size =
-			(READ_HREG(CUR_NAL_UNIT_TYPE) >> 16) & 0xffff;
-			process_nal_sei(hevc, payload_type, payload_size);
-
+		if (!hevc->m_ins_flag) {
+			int payload_type =
+				READ_HREG(CUR_NAL_UNIT_TYPE) & 0xffff;
+			int payload_size =
+				(READ_HREG(CUR_NAL_UNIT_TYPE) >> 16) & 0xffff;
+				process_nal_sei(hevc,
+					payload_type, payload_size);
+		}
 		WRITE_VREG(HEVC_DEC_STATUS_REG, HEVC_SEI_DAT_DONE);
 	} else if (dec_status == HEVC_NAL_SEARCH_DONE) {
 		int naltype = READ_HREG(CUR_NAL_UNIT_TYPE);
@@ -6749,6 +7419,10 @@ send_again:
 
 		hevc->error_watchdog_count = 0;
 		hevc->error_skip_nal_wt_cnt = 0;
+#ifdef MULTI_INSTANCE_SUPPORT
+		if (hevc->m_ins_flag)
+			reset_process_time(hevc);
+#endif
 		if (slice_parse_begin > 0 &&
 			get_dbg_flag(hevc) & H265_DEBUG_DISCARD_NAL) {
 			hevc_print(hevc, 0,
@@ -6760,6 +7434,15 @@ send_again:
 		if (naltype == NAL_UNIT_EOS) {
 			struct PIC_s *pic;
 			hevc_print(hevc, 0, "get NAL_UNIT_EOS, flush output\n");
+#ifdef CONFIG_AM_VDEC_DV
+			if ((vdec->master || vdec->slave) &&
+				READ_VREG(HEVC_AUX_DATA_SIZE) != 0) {
+				if (hevc->decoding_pic)
+					dolby_get_meta(hevc);
+			}
+#endif
+			check_pic_decoded_lcu_count(hevc,
+				hevc->pic_decoded_lcu_idx);
 			pic = get_pic_by_POC(hevc, hevc->curr_POC);
 			hevc->curr_POC = INVALID_POC;
 			/* add to fix RAP_B_Bossen_1 */
@@ -6768,10 +7451,25 @@ send_again:
 			WRITE_VREG(HEVC_DEC_STATUS_REG, HEVC_DISCARD_NAL);
 			/* Interrupt Amrisc to excute */
 			WRITE_VREG(HEVC_MCPU_INTR_REQ, AMRISC_MAIN_REQ);
+#ifdef MULTI_INSTANCE_SUPPORT
+			if (hevc->m_ins_flag) {
+				hevc->decoded_poc = INVALID_POC; /*
+					already call flush_output*/
+				hevc->decoding_pic = NULL;
+				hevc->dec_result = DEC_RESULT_DONE;
+				amhevc_stop();
+
+				vdec_schedule_work(&hevc->work);
+			}
+#endif
 			return IRQ_HANDLED;
 		}
 
-		if (hevc->error_skip_nal_count > 0) {
+		if (
+#ifdef MULTI_INSTANCE_SUPPORT
+			(!hevc->m_ins_flag) &&
+#endif
+			hevc->error_skip_nal_count > 0) {
 			hevc_print(hevc, 0,
 				"nal type %d, discard %d\n", naltype,
 				hevc->error_skip_nal_count);
@@ -6787,8 +7485,8 @@ send_again:
 				return IRQ_HANDLED;
 			}
 		} else if (naltype == NAL_UNIT_VPS) {
-			parse_type = HEVC_NAL_UNIT_VPS;
-			hevc->have_vps = 1;
+				parse_type = HEVC_NAL_UNIT_VPS;
+				hevc->have_vps = 1;
 #ifdef ERROR_HANDLE_DEBUG
 				if (dbg_nal_skip_flag & 1)
 					parse_type = HEVC_DISCARD_NAL;
@@ -6858,8 +7556,13 @@ send_again:
 				WRITE_VREG(NAL_SEARCH_CTL, 0x2);
 			}
 
-			if (get_dbg_flag(hevc) &
-				H265_DEBUG_NO_EOS_SEARCH_DONE) {
+			if ((get_dbg_flag(hevc) &
+				H265_DEBUG_NO_EOS_SEARCH_DONE)
+#ifdef CONFIG_AM_VDEC_DV
+				|| vdec->master
+				|| vdec->slave
+#endif
+				) {
 				WRITE_VREG(NAL_SEARCH_CTL,
 						READ_VREG(NAL_SEARCH_CTL) |
 						0x10000);
@@ -6886,8 +7589,18 @@ send_again:
 		WRITE_VREG(HEVC_DEC_STATUS_REG, parse_type);
 		/* Interrupt Amrisc to excute */
 		WRITE_VREG(HEVC_MCPU_INTR_REQ, AMRISC_MAIN_REQ);
-
+#ifdef MULTI_INSTANCE_SUPPORT
+		if (hevc->m_ins_flag)
+			start_process_time(hevc);
+#endif
 	} else if (dec_status == HEVC_SLICE_SEGMENT_DONE) {
+#ifdef MULTI_INSTANCE_SUPPORT
+		if (hevc->m_ins_flag) {
+			reset_process_time(hevc);
+			read_decode_info(hevc);
+
+		}
+#endif
 		if (hevc->start_decoding_time > 0) {
 			u32 process_time = 1000*
 				(jiffies - hevc->start_decoding_time)/HZ;
@@ -6902,6 +7615,7 @@ send_again:
 		} else if (hevc->wait_buf == 0) {
 			u32 vui_time_scale;
 			u32 vui_num_units_in_tick;
+			unsigned char reconfig_flag = 0;
 
 			if (get_dbg_flag(hevc) & H265_DEBUG_SEND_PARAM_WITH_REG)
 				get_rpm_param(&hevc->param);
@@ -6967,11 +7681,13 @@ send_again:
 				p.vui_num_units_in_tick_lo;
 			if (hevc->bit_depth_luma !=
 				((hevc->param.p.bit_depth & 0xf) + 8)) {
+				reconfig_flag = 1;
 				hevc_print(hevc, 0, "Bit depth luma = %d\n",
 					(hevc->param.p.bit_depth & 0xf) + 8);
 			}
 			if (hevc->bit_depth_chroma !=
 				(((hevc->param.p.bit_depth >> 4) & 0xf) + 8)) {
+				reconfig_flag = 1;
 				hevc_print(hevc, 0, "Bit depth chroma = %d\n",
 					((hevc->param.p.bit_depth >> 4) &
 					0xf) + 8);
@@ -6990,13 +7706,24 @@ send_again:
 			else
 				hevc->mem_saving_mode = 0;
 #endif
+			if (reconfig_flag &&
+				(get_double_write_mode(hevc) & 0x10) == 0)
+				init_decode_head_hw(hevc);
+
 			if ((vui_time_scale != 0)
 				&& (vui_num_units_in_tick != 0)) {
 				hevc->frame_dur =
 					div_u64(96000ULL *
 						vui_num_units_in_tick,
 						vui_time_scale);
+					if (hevc->get_frame_dur != true)
+						schedule_work(
+						&hevc->notify_work);
+
 				hevc->get_frame_dur = true;
+#ifndef CONFIG_MULTI_DEC
+				gvs->frame_dur = hevc->frame_dur;
+#endif
 			}
 
 			if (hevc->video_signal_type !=
@@ -7052,18 +7779,20 @@ send_again:
 			WRITE_VREG(HEVC_DEC_STATUS_REG,	HEVC_ACTION_DONE);
 			/* Interrupt Amrisc to excute */
 			WRITE_VREG(HEVC_MCPU_INTR_REQ,	AMRISC_MAIN_REQ);
-
+#ifdef MULTI_INSTANCE_SUPPORT
+			if (hevc->m_ins_flag)
+				start_process_time(hevc);
+#endif
 		} else {
 			hevc->sps_num_reorder_pics_0 =
 			hevc->param.p.sps_num_reorder_pics_0;
 			hevc->pic_list_init_flag = 1;
 #ifdef MULTI_INSTANCE_SUPPORT
 			if (hevc->m_ins_flag) {
-				reset_process_time(hevc);
-				schedule_work(&hevc->work);
+				vdec_schedule_work(&hevc->work);
 			} else
 #endif
-				up(&hevc->h265_sema);
+				up(&h265_sema);
 			hevc_print(hevc, 0, "set pic_list_init_flag 1\n");
 		}
 		return IRQ_HANDLED;
@@ -7073,12 +7802,33 @@ send_again:
 	ret =
 		hevc_slice_segment_header_process(hevc,
 			&hevc->param, decode_pic_begin);
-	if (ret < 0)
+	if (ret < 0) {
+#ifdef MULTI_INSTANCE_SUPPORT
+		if (hevc->m_ins_flag) {
+			hevc->wait_buf = 0;
+			hevc->dec_result = DEC_RESULT_AGAIN;
+			amhevc_stop();
+			restore_decode_state(hevc);
+			reset_process_time(hevc);
+			vdec_schedule_work(&hevc->work);
+			return IRQ_HANDLED;
+		}
+#else
 		;
-	else if (ret == 0) {
+#endif
+	} else if (ret == 0) {
 		if ((hevc->new_pic) && (hevc->cur_pic)) {
 			hevc->cur_pic->stream_offset =
 			READ_VREG(HEVC_SHIFT_BYTE_COUNT);
+			hevc_print(hevc, H265_DEBUG_OUT_PTS,
+				"read stream_offset = 0x%x\n",
+				hevc->cur_pic->stream_offset);
+			hevc->cur_pic->aspect_ratio_idc =
+				hevc->param.p.aspect_ratio_idc;
+			hevc->cur_pic->sar_width =
+				hevc->param.p.sar_width;
+			hevc->cur_pic->sar_height =
+				hevc->param.p.sar_height;
 		}
 
 		WRITE_VREG(HEVC_DEC_STATUS_REG,
@@ -7087,6 +7837,10 @@ send_again:
 		WRITE_VREG(HEVC_MCPU_INTR_REQ, AMRISC_MAIN_REQ);
 
 		hevc->start_decoding_time = jiffies;
+#ifdef MULTI_INSTANCE_SUPPORT
+		if (hevc->m_ins_flag)
+			start_process_time(hevc);
+#endif
 #if 1
 		/*to do..., copy aux data to hevc->cur_pic*/
 #endif
@@ -7095,13 +7849,18 @@ send_again:
 		hevc_print(hevc, PRINT_FLAG_VDEC_STATUS,
 			"%s, bufmgr ret %d skip, DEC_RESULT_DONE\n",
 			__func__, ret);
+		hevc->decoded_poc = INVALID_POC;
+		hevc->decoding_pic = NULL;
 		hevc->dec_result = DEC_RESULT_DONE;
 		amhevc_stop();
 		reset_process_time(hevc);
-		schedule_work(&hevc->work);
+		vdec_schedule_work(&hevc->work);
 #endif
 	} else {
 		/* skip, search next start code */
+#ifndef CONFIG_MULTI_DEC
+		gvs->drop_frame_count++;
+#endif
 		WRITE_VREG(HEVC_WAIT_FLAG, READ_VREG(HEVC_WAIT_FLAG) & (~0x2));
 			hevc->skip_flag = 1;
 		WRITE_VREG(HEVC_DEC_STATUS_REG,	HEVC_ACTION_DONE);
@@ -7109,42 +7868,17 @@ send_again:
 		WRITE_VREG(HEVC_MCPU_INTR_REQ, AMRISC_MAIN_REQ);
 	}
 
+	} else if (dec_status == HEVC_DECODE_OVER_SIZE) {
+		hevc_print(hevc, 0 , "hevc  decode oversize !!\n");
+		debug |= (H265_DEBUG_DIS_LOC_ERROR_PROC |
+			H265_DEBUG_DIS_SYS_ERROR_PROC);
+		hevc->fatal_error |= DECODER_FATAL_ERROR_SIZE_OVERFLOW;
+#ifdef MULTI_INSTANCE_SUPPORT
+	if (hevc->m_ins_flag)
+		reset_process_time(hevc);
+#endif
+		return IRQ_HANDLED;
 	}
-
-	if (mmu_enable) {
-		if (hevc->last_put_idx_a >= 0
-			&& hevc->last_put_idx_a < MAX_REF_PIC_NUM) {
-			int i = hevc->last_put_idx_a;
-			struct PIC_s *pic = hevc->m_PIC[i];
-
-			/*free not used buffers.*/
-			if (pic &&
-				pic->output_mark == 0 && pic->referenced == 0
-				&& pic->output_ready == 0
-				&& pic->used_by_display == 0
-				&& (pic->index != -1)) {
-				decoder_mmu_box_free_idx(hevc->mmu_box, i);
-				hevc->last_put_idx_a = -1;
-			/*	hevc_print(hevc, 0, "release pic buf %x\n",i);*/
-				}
-		}
-		if (hevc->last_put_idx_b >= 0
-			&& hevc->last_put_idx_b < MAX_REF_PIC_NUM) {
-			int i = hevc->last_put_idx_b;
-			struct PIC_s *pic = hevc->m_PIC[i];
-
-			/*free not used buffers.*/
-			if (pic &&
-				pic->output_mark == 0 && pic->referenced == 0
-				&& pic->output_ready == 0
-				&& pic->used_by_display == 0
-				&& (pic->index != -1)) {
-				decoder_mmu_box_free_idx(hevc->mmu_box, i);
-				hevc->last_put_idx_b = -1;
-				}
-		}
-	}
-
 	return IRQ_HANDLED;
 }
 
@@ -7153,53 +7887,82 @@ static irqreturn_t vh265_isr(int irq, void *data)
 	int i, temp;
 	unsigned int dec_status;
 	struct hevc_state_s *hevc = (struct hevc_state_s *)data;
-
+	u32 debug_tag;
 	dec_status = READ_VREG(HEVC_DEC_STATUS_REG);
 	if (hevc->init_flag == 0)
 		return IRQ_HANDLED;
 	hevc->dec_status = dec_status;
+	if (is_log_enable(hevc))
+		add_log(hevc,
+			"isr: status = 0x%x dec info 0x%x lcu 0x%x shiftbyte 0x%x",
+			dec_status, READ_HREG(HEVC_DECODE_INFO),
+			READ_VREG(HEVC_MPRED_CURR_LCU),
+			READ_VREG(HEVC_SHIFT_BYTE_COUNT));
+
 	if (get_dbg_flag(hevc) & H265_DEBUG_BUFMGR)
 		hevc_print(hevc, 0,
-			"265 isr dec status = 0x%x\n", dec_status);
-
-	if (get_dbg_flag(hevc) & H265_DEBUG_UCODE) {
-		if (READ_HREG(DEBUG_REG1) & 0x10000) {
-			dma_sync_single_for_cpu(
-				amports_get_dma_device(),
-				hevc->lmem_phy_addr,
-				LMEM_BUF_SIZE,
-				DMA_FROM_DEVICE);
-
-			hevc_print(hevc, 0,
-				"LMEM<tag %x>:\n", READ_HREG(DEBUG_REG1));
+			"265 isr dec status = 0x%x dec info 0x%x shiftbyte 0x%x\n",
+			dec_status, READ_HREG(HEVC_DECODE_INFO),
+			READ_VREG(HEVC_SHIFT_BYTE_COUNT));
+
+	debug_tag = READ_HREG(DEBUG_REG1);
+	if (debug_tag & 0x10000) {
+		dma_sync_single_for_cpu(
+			amports_get_dma_device(),
+			hevc->lmem_phy_addr,
+			LMEM_BUF_SIZE,
+			DMA_FROM_DEVICE);
 
-			if (mmu_enable)
-				temp = 0x500;
-			else
-				temp = 0x400;
-			for (i = 0; i < temp; i += 4) {
-				int ii;
+		hevc_print(hevc, 0,
+			"LMEM<tag %x>:\n", READ_HREG(DEBUG_REG1));
 
-				if ((i & 0xf) == 0)
-					hevc_print_cont(hevc, 0, "%03x: ", i);
-				for (ii = 0; ii < 4; ii++) {
-					hevc_print_cont(hevc, 0, "%04x ",
-						   hevc->lmem_ptr[i + 3 - ii]);
-				}
-				if (((i + ii) & 0xf) == 0)
-					hevc_print_cont(hevc, 0, "\n");
+		if (hevc->mmu_enable)
+			temp = 0x500;
+		else
+			temp = 0x400;
+		for (i = 0; i < temp; i += 4) {
+			int ii;
+			if ((i & 0xf) == 0)
+				hevc_print_cont(hevc, 0, "%03x: ", i);
+			for (ii = 0; ii < 4; ii++) {
+				hevc_print_cont(hevc, 0, "%04x ",
+					   hevc->lmem_ptr[i + 3 - ii]);
 			}
-			WRITE_HREG(DEBUG_REG1, 0);
-		} else if (READ_HREG(DEBUG_REG1) != 0) {
-			hevc_print(hevc, 0,
-				"dbg%x: %x\n", READ_HREG(DEBUG_REG1),
-				   READ_HREG(DEBUG_REG2));
-			WRITE_HREG(DEBUG_REG1, 0);
-			return IRQ_HANDLED;
+			if (((i + ii) & 0xf) == 0)
+				hevc_print_cont(hevc, 0, "\n");
 		}
 
+		if ((udebug_pause_pos == (debug_tag & 0xffff)) &&
+			(udebug_pause_decode_idx == 0 ||
+			udebug_pause_decode_idx == hevc->decode_idx) &&
+			(udebug_pause_val == 0 ||
+			udebug_pause_val == READ_HREG(DEBUG_REG2)))
+			hevc->ucode_pause_pos = udebug_pause_pos;
+		else if (debug_tag & 0x20000)
+			hevc->ucode_pause_pos = 0xffffffff;
+		if (hevc->ucode_pause_pos)
+			reset_process_time(hevc);
+		else
+			WRITE_HREG(DEBUG_REG1, 0);
+	} else if (debug_tag != 0) {
+		hevc_print(hevc, 0,
+			"dbg%x: %x lcu %x\n", READ_HREG(DEBUG_REG1),
+			   READ_HREG(DEBUG_REG2),
+			   READ_VREG(HEVC_PARSER_LCU_START));
+		if ((udebug_pause_pos == (debug_tag & 0xffff)) &&
+			(udebug_pause_decode_idx == 0 ||
+			udebug_pause_decode_idx == hevc->decode_idx) &&
+			(udebug_pause_val == 0 ||
+			udebug_pause_val == READ_HREG(DEBUG_REG2)))
+			hevc->ucode_pause_pos = udebug_pause_pos;
+		if (hevc->ucode_pause_pos)
+			reset_process_time(hevc);
+		else
+			WRITE_HREG(DEBUG_REG1, 0);
+		return IRQ_HANDLED;
 	}
 
+
 	if (hevc->pic_list_init_flag == 1)
 		return IRQ_HANDLED;
 
@@ -7217,17 +7980,18 @@ static void vh265_check_timer_func(unsigned long arg)
 	enum receviver_start_e state = RECEIVER_INACTIVE;
 	if (hevc->init_flag == 0) {
 		if (hevc->stat & STAT_TIMER_ARM) {
-			timer->expires = jiffies + PUT_INTERVAL;
-			add_timer(&hevc->timer);
+			mod_timer(&hevc->timer, jiffies + PUT_INTERVAL);
 		}
 		return;
 	}
 #ifdef MULTI_INSTANCE_SUPPORT
 	if (hevc->m_ins_flag &&
+		(get_dbg_flag(hevc) &
+		H265_DEBUG_WAIT_DECODE_DONE_WHEN_STOP) == 0 &&
 		hw_to_vdec(hevc)->next_status ==
 		VDEC_STATUS_DISCONNECTED) {
-		hevc->dec_result = DEC_RESULT_DONE;
-		schedule_work(&hevc->work);
+		hevc->dec_result = DEC_RESULT_FORCE_EXIT;
+		vdec_schedule_work(&hevc->work);
 		hevc_print(hevc,
 			0, "vdec requested to be disconnected\n");
 		return;
@@ -7252,10 +8016,13 @@ static void vh265_check_timer_func(unsigned long arg)
 						hevc->decode_timeout_count--;
 					if (hevc->decode_timeout_count == 0)
 						timeout_process(hevc);
-				}
+				} else
+					restart_process_time(hevc);
 				hevc->last_lcu_idx = current_lcu_idx;
-			} else
+			} else {
+				hevc->pic_decoded_lcu_idx = current_lcu_idx;
 				timeout_process(hevc);
+			}
 		}
 	} else {
 #endif
@@ -7331,7 +8098,8 @@ static void vh265_check_timer_func(unsigned long arg)
 					H265_DEBUG_DIS_LOC_ERROR_PROC) !=
 					0)
 					hevc->error_system_watchdog_count++;
-				if (hevc->error_system_watchdog_count ==
+				if (hevc->error_system_watchdog_count
+					==
 					error_handle_system_threshold) {
 					/* and it lasts for a while */
 					hevc_print(hevc, 0,
@@ -7349,9 +8117,11 @@ static void vh265_check_timer_func(unsigned long arg)
 #ifdef MULTI_INSTANCE_SUPPORT
 	}
 #endif
-	if (decode_stop_pos != decode_stop_pos_pre) {
-		WRITE_VREG(DECODE_STOP_POS, decode_stop_pos);
-		decode_stop_pos_pre = decode_stop_pos;
+	if ((hevc->ucode_pause_pos != 0) &&
+		(hevc->ucode_pause_pos != 0xffffffff) &&
+		udebug_pause_pos != hevc->ucode_pause_pos) {
+		hevc->ucode_pause_pos = 0;
+		WRITE_HREG(DEBUG_REG1, 0);
 	}
 
 	if (get_dbg_flag(hevc) & H265_DEBUG_DUMP_PIC_LIST) {
@@ -7362,16 +8132,17 @@ static void vh265_check_timer_func(unsigned long arg)
 		WRITE_VREG(HEVC_ASSIST_MBOX1_IRQ_REG, 0x1);
 		debug &= ~H265_DEBUG_TRIG_SLICE_SEGMENT_PROC;
 	}
+#ifdef TEST_NO_BUF
+	if (hevc->wait_buf)
+		WRITE_VREG(HEVC_ASSIST_MBOX1_IRQ_REG, 0x1);
+#endif
 	if (get_dbg_flag(hevc) & H265_DEBUG_HW_RESET) {
 		hevc->error_skip_nal_count = error_skip_nal_count;
 		WRITE_VREG(HEVC_DEC_STATUS_REG, HEVC_ACTION_DONE);
 
 		debug &= ~H265_DEBUG_HW_RESET;
 	}
-	if (get_dbg_flag(hevc) & H265_DEBUG_ERROR_TRIG) {
-		WRITE_VREG(DECODE_STOP_POS, 1);
-		debug &= ~H265_DEBUG_ERROR_TRIG;
-	}
+
 #ifdef ERROR_HANDLE_DEBUG
 	if ((dbg_nal_skip_count > 0) && ((dbg_nal_skip_count & 0x10000) != 0)) {
 		hevc->error_skip_nal_count = dbg_nal_skip_count & 0xffff;
@@ -7426,9 +8197,7 @@ static void vh265_check_timer_func(unsigned long arg)
 			hevc->frame_height * fps;
 	}
 
-
-	timer->expires = jiffies + PUT_INTERVAL;
-	add_timer(timer);
+	mod_timer(timer, jiffies + PUT_INTERVAL);
 }
 
 static int h265_task_handle(void *data)
@@ -7442,11 +8211,8 @@ static int h265_task_handle(void *data)
 			hevc_print(hevc, 0,
 			"ERROR: use_cma can not be changed dynamically\n");
 		}
-		ret = down_interruptible(&hevc->h265_sema);
+		ret = down_interruptible(&h265_sema);
 		if ((hevc->init_flag != 0) && (hevc->pic_list_init_flag == 1)) {
-			/*USE_BUF_BLOCK*/
-			init_buf_list(hevc);
-			/**/
 			init_pic_list(hevc);
 			init_pic_list_hw(hevc);
 			init_buf_spec(hevc);
@@ -7488,21 +8254,47 @@ void vh265_free_cmabuf(void)
 }
 
 #ifdef MULTI_INSTANCE_SUPPORT
-int vh265_dec_status(struct vdec_s *vdec, struct vdec_status *vstatus)
+int vh265_dec_status(struct vdec_s *vdec, struct vdec_info *vstatus)
 #else
-int vh265_dec_status(struct vdec_status *vstatus)
+int vh265_dec_status(struct vdec_info *vstatus)
 #endif
 {
 	struct hevc_state_s *hevc = &gHevc;
-
-	vstatus->width = hevc->frame_width;
-	vstatus->height = hevc->frame_height;
+	vstatus->frame_width = hevc->frame_width;
+	vstatus->frame_height = hevc->frame_height;
 	if (hevc->frame_dur != 0)
-		vstatus->fps = 96000 / hevc->frame_dur;
+		vstatus->frame_rate = 96000 / hevc->frame_dur;
 	else
-		vstatus->fps = -1;
+		vstatus->frame_rate = -1;
 	vstatus->error_count = 0;
 	vstatus->status = hevc->stat | hevc->fatal_error;
+#ifndef CONFIG_MULTI_DEC
+	vstatus->bit_rate = gvs->bit_rate;
+	vstatus->frame_dur = hevc->frame_dur;
+	if (gvs) {
+		vstatus->bit_rate = gvs->bit_rate;
+		vstatus->frame_data = gvs->frame_data;
+		vstatus->total_data = gvs->total_data;
+		vstatus->frame_count = gvs->frame_count;
+		vstatus->error_frame_count = gvs->error_frame_count;
+		vstatus->drop_frame_count = gvs->drop_frame_count;
+		vstatus->total_data = gvs->total_data;
+		vstatus->samp_cnt = gvs->samp_cnt;
+		vstatus->offset = gvs->offset;
+	}
+	snprintf(vstatus->vdec_name, sizeof(vstatus->vdec_name),
+		"%s", DRIVER_NAME);
+#endif
+	return 0;
+}
+
+static int vh265_vdec_info_init(void)
+{
+	gvs = kzalloc(sizeof(struct vdec_info), GFP_KERNEL);
+	if (NULL == gvs) {
+		pr_info("the struct of vdec status malloc failed.\n");
+		return -ENOMEM;
+	}
 	return 0;
 }
 
@@ -7532,29 +8324,39 @@ static void config_decode_mode(struct hevc_state_s *hevc)
 #ifdef CONFIG_AM_VDEC_DV
 	struct vdec_s *vdec = hw_to_vdec(hevc);
 #endif
+	unsigned decode_mode;
 	if (!hevc->m_ins_flag)
-		WRITE_VREG(HEVC_DECODE_MODE,
-			DECODE_MODE_SINGLE);
+		decode_mode = DECODE_MODE_SINGLE;
 	else if (vdec_frame_based(hw_to_vdec(hevc)))
-		WRITE_VREG(HEVC_DECODE_MODE,
-			DECODE_MODE_MULTI_FRAMEBASE);
+		decode_mode =
+			DECODE_MODE_MULTI_FRAMEBASE;
 #ifdef CONFIG_AM_VDEC_DV
 	else if (vdec->slave)
-		WRITE_VREG(HEVC_DECODE_MODE,
+		decode_mode =
 			(hevc->start_parser_type << 8)
-			| DECODE_MODE_MULTI_DVBAL);
+			| DECODE_MODE_MULTI_DVBAL;
 	else if (vdec->master)
-		WRITE_VREG(HEVC_DECODE_MODE,
+		decode_mode =
 			(hevc->start_parser_type << 8)
-			| DECODE_MODE_MULTI_DVENL);
+			| DECODE_MODE_MULTI_DVENL;
 #endif
 	else
-		WRITE_VREG(HEVC_DECODE_MODE,
-			DECODE_MODE_MULTI_STREAMBASE);
+		decode_mode =
+			DECODE_MODE_MULTI_STREAMBASE;
+
+	if (hevc->m_ins_flag)
+		decode_mode |=
+			(hevc->start_decoding_flag << 16);
+	WRITE_VREG(HEVC_DECODE_MODE, decode_mode);
+	WRITE_VREG(HEVC_DECODE_MODE2,
+		hevc->rps_set_id);
 }
 
 static void vh265_prot_init(struct hevc_state_s *hevc)
 {
+#ifdef CONFIG_AM_VDEC_DV
+	struct vdec_s *vdec = hw_to_vdec(hevc);
+#endif
 	/* H265_DECODE_INIT(); */
 
 	hevc_config_work_space_hw(hevc);
@@ -7574,10 +8376,7 @@ static void vh265_prot_init(struct hevc_state_s *hevc)
 	/* disable PSCALE for hardware sharing */
 	WRITE_VREG(HEVC_PSCALE_CTRL, 0);
 
-	if (get_dbg_flag(hevc) & H265_DEBUG_UCODE)
-		WRITE_VREG(DEBUG_REG1, 0x1);
-	else
-		WRITE_VREG(DEBUG_REG1, 0x0);
+	WRITE_VREG(DEBUG_REG1, 0x0 | (dump_nal << 8));
 
 	if ((get_dbg_flag(hevc) &
 		(H265_DEBUG_MAN_SKIP_NAL |
@@ -7587,21 +8386,18 @@ static void vh265_prot_init(struct hevc_state_s *hevc)
 	} else {
 		/* check vps/sps/pps/i-slice in ucode */
 		unsigned ctl_val = 0x8;
-#ifdef MULTI_INSTANCE_SUPPORT
-		if (hevc->m_ins_flag &&
-			hevc->init_flag) {
-			/* do not check vps/sps/pps/i-slice in ucode
-			from the 2nd picture*/
-			ctl_val = 0x2;
-		} else
-#endif
 		if (hevc->PB_skip_mode == 0)
 			ctl_val = 0x4;	/* check vps/sps/pps only in ucode */
 		else if (hevc->PB_skip_mode == 3)
 			ctl_val = 0x0;	/* check vps/sps/pps/idr in ucode */
 		WRITE_VREG(NAL_SEARCH_CTL, ctl_val);
 	}
-	if (get_dbg_flag(hevc) & H265_DEBUG_NO_EOS_SEARCH_DONE)
+	if ((get_dbg_flag(hevc) & H265_DEBUG_NO_EOS_SEARCH_DONE)
+#ifdef CONFIG_AM_VDEC_DV
+		|| vdec->master
+		|| vdec->slave
+#endif
+		)
 		WRITE_VREG(NAL_SEARCH_CTL, READ_VREG(NAL_SEARCH_CTL) | 0x10000);
 
 	WRITE_VREG(NAL_SEARCH_CTL,
@@ -7612,7 +8408,7 @@ static void vh265_prot_init(struct hevc_state_s *hevc)
 		READ_VREG(NAL_SEARCH_CTL) |
 		((parser_dolby_vision_enable & 0x1) << 20));
 #endif
-	WRITE_VREG(DECODE_STOP_POS, decode_stop_pos);
+	WRITE_VREG(DECODE_STOP_POS, udebug_flag);
 
 	config_decode_mode(hevc);
 	config_aux_buf(hevc);
@@ -7628,8 +8424,6 @@ static int vh265_local_init(struct hevc_state_s *hevc)
 	hevc->pts_hit = 0;
 #endif
 
-	hevc->last_put_idx_a = -1;
-	hevc->last_put_idx_b = -1;
 	hevc->saved_resolution = 0;
 	hevc->get_frame_dur = false;
 	hevc->frame_width = hevc->vh265_amstream_dec_info.width;
@@ -7643,8 +8437,19 @@ static int vh265_local_init(struct hevc_state_s *hevc)
 	hevc->frame_dur =
 		(hevc->vh265_amstream_dec_info.rate ==
 		 0) ? 3600 : hevc->vh265_amstream_dec_info.rate;
+#ifndef CONFIG_MULTI_DEC
+	gvs->frame_dur = hevc->frame_dur;
+#endif
 	if (hevc->frame_width && hevc->frame_height)
 		hevc->frame_ar = hevc->frame_height * 0x100 / hevc->frame_width;
+
+	if (i_only_flag)
+		hevc->i_only = i_only_flag & 0xff;
+	else if ((unsigned long) hevc->vh265_amstream_dec_info.param
+		& 0x08)
+		hevc->i_only = 0x7;
+	else
+		hevc->i_only = 0x0;
 	hevc->error_watchdog_count = 0;
 	hevc->sei_present_flag = 0;
 	pts_unstable = ((unsigned long)hevc->vh265_amstream_dec_info.param
@@ -7698,7 +8503,7 @@ static s32 vh265_init(struct hevc_state_s *hevc)
 		vfree(buf);
 		return -EBUSY;
 	}
-
+	INIT_WORK(&hevc->notify_work, vh265_notify_work);
 #ifdef MULTI_INSTANCE_SUPPORT
 	if (hevc->m_ins_flag) {
 		hevc->timer.data = (ulong) hevc;
@@ -7759,15 +8564,27 @@ static s32 vh265_init(struct hevc_state_s *hevc)
 	vf_reg_provider(&vh265_vf_prov);
 	vf_notify_receiver(hevc->provider_name, VFRAME_EVENT_PROVIDER_START,
 				NULL);
-	vf_notify_receiver(hevc->provider_name, VFRAME_EVENT_PROVIDER_FR_HINT,
-				(void *)((unsigned long)hevc->frame_dur));
+	if (hevc->frame_dur != 0) {
+		vf_notify_receiver(hevc->provider_name,
+				VFRAME_EVENT_PROVIDER_FR_HINT,
+				(void *)
+				((unsigned long)hevc->frame_dur));
+		fr_hint_status = VDEC_HINTED;
+	} else
+		fr_hint_status = VDEC_NEED_HINT;
 #else
 	vf_provider_init(&vh265_vf_prov, PROVIDER_NAME, &vh265_vf_provider,
 					 hevc);
 	vf_reg_provider(&vh265_vf_prov);
 	vf_notify_receiver(PROVIDER_NAME, VFRAME_EVENT_PROVIDER_START, NULL);
-	vf_notify_receiver(PROVIDER_NAME, VFRAME_EVENT_PROVIDER_FR_HINT,
-				(void *)((unsigned long)hevc->frame_dur));
+	if (hevc->frame_dur != 0) {
+		vf_notify_receiver(PROVIDER_NAME,
+				VFRAME_EVENT_PROVIDER_FR_HINT,
+				(void *)
+				((unsigned long)hevc->frame_dur));
+		fr_hint_status = VDEC_HINTED;
+	} else
+		fr_hint_status = VDEC_NEED_HINT;
 #endif
 	hevc->stat |= STAT_VF_HOOK;
 
@@ -7781,7 +8598,7 @@ static s32 vh265_init(struct hevc_state_s *hevc)
 
 	if (use_cma) {
 		if (h265_task == NULL) {
-			sema_init(&hevc->h265_sema, 1);
+			sema_init(&h265_sema, 1);
 #ifdef USE_UNINIT_SEMA
 			sema_init(
 			&hevc->h265_uninit_done_sema, 0);
@@ -7833,7 +8650,7 @@ static s32 vh265_init(struct hevc_state_s *hevc)
 	set_vdec_func(&vh265_dec_status);
 #endif
 	hevc->init_flag = 1;
-	if (mmu_enable)
+	if (hevc->mmu_enable)
 		error_handle_threshold = 300;
 	else
 		error_handle_threshold = 30;
@@ -7865,7 +8682,10 @@ static int vh265_stop(struct hevc_state_s *hevc)
 	}
 
 	if (hevc->stat & STAT_ISR_REG) {
-		WRITE_VREG(HEVC_ASSIST_MBOX1_MASK, 0);
+#ifdef MULTI_INSTANCE_SUPPORT
+		if (!hevc->m_ins_flag)
+#endif
+			WRITE_VREG(HEVC_ASSIST_MBOX1_MASK, 0);
 		vdec_free_irq(VDEC_IRQ_1, (void *)hevc);
 		hevc->stat &= ~STAT_ISR_REG;
 	}
@@ -7877,9 +8697,11 @@ static int vh265_stop(struct hevc_state_s *hevc)
 	}
 
 	if (hevc->stat & STAT_VF_HOOK) {
-		vf_notify_receiver(hevc->provider_name,
-				VFRAME_EVENT_PROVIDER_FR_END_HINT, NULL);
-
+		if (fr_hint_status == VDEC_HINTED)
+			vf_notify_receiver(hevc->provider_name,
+					VFRAME_EVENT_PROVIDER_FR_END_HINT,
+					NULL);
+		fr_hint_status = VDEC_NO_NEED_HINT;
 		vf_unreg_provider(&vh265_vf_prov);
 		hevc->stat &= ~STAT_VF_HOOK;
 	}
@@ -7891,7 +8713,7 @@ static int vh265_stop(struct hevc_state_s *hevc)
 		int ret;
 #endif
 		hevc->uninit_list = 1;
-		up(&hevc->h265_sema);
+		up(&h265_sema);
 #ifdef USE_UNINIT_SEMA
 		ret = down_interruptible(
 			&hevc->h265_uninit_done_sema);
@@ -7904,6 +8726,9 @@ static int vh265_stop(struct hevc_state_s *hevc)
 	uninit_mmu_buffers(hevc);
 	amhevc_disable();
 
+	kfree(gvs);
+	gvs = NULL;
+
 	return 0;
 }
 
@@ -7926,13 +8751,24 @@ static void start_process_time(struct hevc_state_s *hevc)
 	hevc->last_lcu_idx = 0;
 }
 
+static void restart_process_time(struct hevc_state_s *hevc)
+{
+	hevc->start_process_time = jiffies;
+	hevc->decode_timeout_count = 2;
+}
+
 static void timeout_process(struct hevc_state_s *hevc)
 {
 	hevc->timeout_num++;
 	amhevc_stop();
+	read_decode_info(hevc);
+
 	hevc_print(hevc,
 		0, "%s decoder timeout\n", __func__);
-
+	check_pic_decoded_lcu_count(hevc,
+				hevc->pic_decoded_lcu_idx);
+	hevc->decoded_poc = hevc->curr_POC;
+	hevc->decoding_pic = NULL;
 	hevc->dec_result = DEC_RESULT_DONE;
 	reset_process_time(hevc);
 	schedule_work(&hevc->work);
@@ -7952,13 +8788,9 @@ static unsigned char is_new_pic_available(struct hevc_state_s *hevc)
 		pic = hevc->m_PIC[i];
 		if (pic == NULL || pic->index == -1)
 			continue;
-		if ((pic->used_by_display)
-			&& ((READ_VCBUS_REG(AFBC_BODY_BADDR) << 4) !=
-				pic->mc_y_adr))
-			pic->used_by_display = 0;
 		if (pic->output_mark == 0 && pic->referenced == 0
 			&& pic->output_ready == 0
-			&& pic->used_by_display == 0) {
+			) {
 			if (new_pic) {
 				if (pic->POC < new_pic->POC)
 					new_pic = pic;
@@ -7979,9 +8811,11 @@ static int vmh265_stop(struct hevc_state_s *hevc)
 	}
 
 	if (hevc->stat & STAT_VF_HOOK) {
-		vf_notify_receiver(hevc->provider_name,
-				VFRAME_EVENT_PROVIDER_FR_END_HINT, NULL);
-
+		if (fr_hint_status == VDEC_HINTED)
+			vf_notify_receiver(hevc->provider_name,
+					VFRAME_EVENT_PROVIDER_FR_END_HINT,
+					NULL);
+		fr_hint_status = VDEC_NO_NEED_HINT;
 		vf_unreg_provider(&vh265_vf_prov);
 		hevc->stat &= ~STAT_VF_HOOK;
 	}
@@ -7994,7 +8828,7 @@ static int vmh265_stop(struct hevc_state_s *hevc)
 #endif
 		hevc->uninit_list = 1;
 		reset_process_time(hevc);
-		schedule_work(&hevc->work);
+		vdec_schedule_work(&hevc->work);
 #ifdef USE_UNINIT_SEMA
 		ret = down_interruptible(
 			&hevc->h265_uninit_done_sema);
@@ -8004,12 +8838,12 @@ static int vmh265_stop(struct hevc_state_s *hevc)
 #endif
 	}
 	cancel_work_sync(&hevc->work);
+	cancel_work_sync(&hevc->notify_work);
 	uninit_mmu_buffers(hevc);
+	dump_log(hevc);
 	return 0;
 }
 
-static unsigned int start_decode_buf_level; /* = 0x80000;*/
-
 static unsigned char get_data_check_sum
 	(struct hevc_state_s *hevc, int size)
 {
@@ -8022,6 +8856,40 @@ static unsigned char get_data_check_sum
 	return sum;
 }
 
+static void vh265_notify_work(struct work_struct *work)
+{
+	struct hevc_state_s *hevc =
+						container_of(work,
+						struct hevc_state_s,
+						notify_work);
+	struct vdec_s *vdec = hw_to_vdec(hevc);
+#ifdef MULTI_INSTANCE_SUPPORT
+	if (vdec->fr_hint_state == VDEC_NEED_HINT) {
+		vf_notify_receiver(hevc->provider_name,
+					VFRAME_EVENT_PROVIDER_FR_HINT,
+					(void *)
+					((unsigned long)hevc->frame_dur));
+		vdec->fr_hint_state = VDEC_HINTED;
+	} else if (fr_hint_status == VDEC_NEED_HINT) {
+		vf_notify_receiver(hevc->provider_name,
+					VFRAME_EVENT_PROVIDER_FR_HINT,
+					(void *)
+					((unsigned long)hevc->frame_dur));
+		fr_hint_status = VDEC_HINTED;
+	}
+#else
+	if (fr_hint_status == VDEC_NEED_HINT)
+		vf_notify_receiver(PROVIDER_NAME,
+					VFRAME_EVENT_PROVIDER_FR_HINT,
+					(void *)
+					((unsigned long)hevc->frame_dur));
+		fr_hint_status = VDEC_HINTED;
+	}
+#endif
+
+	return;
+}
+
 static void vh265_work(struct work_struct *work)
 {
 	struct hevc_state_s *hevc = container_of(work,
@@ -8030,18 +8898,14 @@ static void vh265_work(struct work_struct *work)
 	/* finished decoding one frame or error,
 	 * notify vdec core to switch context
 	 */
-	if ((hevc->init_flag != 0) && (hevc->pic_list_init_flag == 1)) {
-		/*USE_BUF_BLOCK*/
-		init_buf_list(hevc);
-		/**/
+	if (hevc->pic_list_init_flag == 1) {
+		hevc->pic_list_init_flag = 2;
 		init_pic_list(hevc);
 		init_pic_list_hw(hevc);
 		init_buf_spec(hevc);
-		hevc->pic_list_init_flag = 2;
 		hevc_print(hevc, 0,
 			"set pic_list_init_flag to 2\n");
 
-		start_process_time(hevc);
 		WRITE_VREG(HEVC_ASSIST_MBOX1_IRQ_REG, 0x1);
 		return;
 	}
@@ -8057,8 +8921,53 @@ static void vh265_work(struct work_struct *work)
 		return;
 	}
 
-	if ((hevc->dec_result == DEC_RESULT_GET_DATA) ||
-		(hevc->dec_result == DEC_RESULT_GET_DATA_RETRY)) {
+	hevc_print(hevc, PRINT_FLAG_VDEC_DETAIL,
+		"%s dec_result %d %x %x %x\n",
+		__func__,
+		hevc->dec_result,
+		READ_VREG(HEVC_STREAM_LEVEL),
+		READ_VREG(HEVC_STREAM_WR_PTR),
+		READ_VREG(HEVC_STREAM_RD_PTR));
+
+	if (((hevc->dec_result == DEC_RESULT_GET_DATA) ||
+		(hevc->dec_result == DEC_RESULT_GET_DATA_RETRY))
+		&& (hw_to_vdec(hevc)->next_status !=
+		VDEC_STATUS_DISCONNECTED)) {
+		if (!vdec_has_more_input(vdec)) {
+			hevc->dec_result = DEC_RESULT_EOS;
+			vdec_schedule_work(&hevc->work);
+			return;
+		}
+		if (!input_frame_based(vdec)) {
+			int r = vdec_sync_input(vdec);
+			if (r >= 0x200) {
+				WRITE_VREG(HEVC_DECODE_SIZE,
+					READ_VREG(HEVC_DECODE_SIZE) + r);
+
+				hevc_print(hevc, PRINT_FLAG_VDEC_STATUS,
+					"%s DEC_RESULT_GET_DATA %x %x %x mpc %x size 0x%x\n",
+					__func__,
+					READ_VREG(HEVC_STREAM_LEVEL),
+					READ_VREG(HEVC_STREAM_WR_PTR),
+					READ_VREG(HEVC_STREAM_RD_PTR),
+					READ_VREG(HEVC_MPC_E), r);
+
+				start_process_time(hevc);
+				if (READ_VREG(HEVC_DEC_STATUS_REG)
+				 == HEVC_DECODE_BUFEMPTY2)
+					WRITE_VREG(HEVC_DEC_STATUS_REG,
+						HEVC_ACTION_DONE);
+				else
+					WRITE_VREG(HEVC_DEC_STATUS_REG,
+						HEVC_ACTION_DEC_CONT);
+			} else {
+				hevc->dec_result = DEC_RESULT_GET_DATA_RETRY;
+				vdec_schedule_work(&hevc->work);
+			}
+			return;
+		}
+
+		/*below for frame_base*/
 		if (hevc->dec_result == DEC_RESULT_GET_DATA) {
 			hevc_print(hevc, PRINT_FLAG_VDEC_STATUS,
 				"%s DEC_RESULT_GET_DATA %x %x %x mpc %x\n",
@@ -8074,6 +8983,7 @@ static void vh265_work(struct work_struct *work)
 		/*if (is_new_pic_available(hevc)) {*/
 		if (run_ready(vdec)) {
 			int r;
+			int decode_size;
 			r = vdec_prepare_input(vdec, &hevc->chunk);
 			if (r < 0) {
 				hevc->dec_result = DEC_RESULT_GET_DATA_RETRY;
@@ -8082,7 +8992,7 @@ static void vh265_work(struct work_struct *work)
 					PRINT_FLAG_VDEC_DETAIL,
 					"amvdec_vh265: Insufficient data\n");
 
-				schedule_work(&hevc->work);
+				vdec_schedule_work(&hevc->work);
 				return;
 			}
 			hevc->dec_result = DEC_RESULT_NONE;
@@ -8092,8 +9002,8 @@ static void vh265_work(struct work_struct *work)
 				(get_dbg_flag(hevc) & PRINT_FLAG_VDEC_STATUS) ?
 				get_data_check_sum(hevc, r) : 0,
 				READ_VREG(HEVC_MPC_E));
-			if ((get_dbg_flag(hevc) & PRINT_FRAMEBASE_DATA) &&
-				input_frame_based(vdec)) {
+
+			if (get_dbg_flag(hevc) & PRINT_FRAMEBASE_DATA) {
 				int jj;
 				u8 *data =
 				((u8 *)hevc->chunk->block->start_virt) +
@@ -8113,7 +9023,10 @@ static void vh265_work(struct work_struct *work)
 				}
 			}
 
-			WRITE_VREG(HEVC_DECODE_SIZE, r);
+			decode_size = hevc->chunk->size +
+				(hevc->chunk->offset & (VDEC_FIFO_ALIGN - 1));
+			WRITE_VREG(HEVC_DECODE_SIZE,
+				READ_VREG(HEVC_DECODE_SIZE) + decode_size);
 
 			vdec_enable_input(vdec);
 
@@ -8130,27 +9043,76 @@ static void vh265_work(struct work_struct *work)
 				"amvdec_vh265: Insufficient data\n");
 			*/
 
-			schedule_work(&hevc->work);
+			vdec_schedule_work(&hevc->work);
 		}
 		return;
 	} else if (hevc->dec_result == DEC_RESULT_DONE) {
 		/* if (!hevc->ctx_valid)
 			hevc->ctx_valid = 1; */
+		decode_frame_count[hevc->index]++;
+		if (hevc->mmu_enable) {
+			hevc->used_4k_num =
+				READ_VREG(HEVC_SAO_MMU_STATUS) >> 16;
+			if (hevc->used_4k_num >= 0 &&
+				hevc->cur_pic &&
+				hevc->cur_pic->scatter_alloc
+				== 1) {
+				hevc_print(hevc, H265_DEBUG_BUFMGR_MORE,
+				"%s pic index %d scatter_alloc %d page_start %d\n",
+				"decoder_mmu_box_free_idx_tail",
+				hevc->cur_pic->index,
+				hevc->cur_pic->scatter_alloc,
+				hevc->used_4k_num);
+				decoder_mmu_box_free_idx_tail(
+				hevc->mmu_box,
+				hevc->cur_pic->index,
+				hevc->used_4k_num);
+				hevc->cur_pic->scatter_alloc = 2;
+			}
+		}
+		hevc->pic_decoded_lcu_idx =
+			READ_VREG(HEVC_PARSER_LCU_START)
+			& 0xffffff;
+
+		if (is_log_enable(hevc))
+			add_log(hevc,
+				"%s dec_result %d lcu %d used_mmu %d shiftbyte 0x%x decbytes 0x%x",
+				__func__,
+				hevc->dec_result,
+				hevc->pic_decoded_lcu_idx,
+				hevc->used_4k_num,
+				READ_VREG(HEVC_SHIFT_BYTE_COUNT),
+				READ_VREG(HEVC_SHIFT_BYTE_COUNT) -
+				hevc->start_shift_bytes
+				);
+
 		hevc_print(hevc, PRINT_FLAG_VDEC_STATUS,
-			"%s dec_result %d %x %x %x\n",
+			"%s dec_result %d (%x %x %x) lcu %d used_mmu %d shiftbyte 0x%x decbytes 0x%x\n",
 			__func__,
 			hevc->dec_result,
 			READ_VREG(HEVC_STREAM_LEVEL),
 			READ_VREG(HEVC_STREAM_WR_PTR),
-			READ_VREG(HEVC_STREAM_RD_PTR));
+			READ_VREG(HEVC_STREAM_RD_PTR),
+			hevc->pic_decoded_lcu_idx,
+			hevc->used_4k_num,
+			READ_VREG(HEVC_SHIFT_BYTE_COUNT),
+			READ_VREG(HEVC_SHIFT_BYTE_COUNT) -
+			hevc->start_shift_bytes
+			);
+
+		hevc->used_4k_num = -1;
+
+		check_pic_decoded_lcu_count(hevc,
+			hevc->pic_decoded_lcu_idx);
 #ifdef CONFIG_AM_VDEC_DV
 #if 1
 		if (vdec->slave) {
 			if (dv_debug & 0x1)
-				vdec_set_flag(vdec->slave, 0);
+				vdec_set_flag(vdec->slave,
+					VDEC_FLAG_SELF_INPUT_CONTEXT);
 			else
 				vdec_set_flag(vdec->slave,
-				VDEC_FLAG_INPUT_KEEP_CONTEXT);
+					VDEC_FLAG_OTHER_INPUT_CONTEXT);
 		}
 #else
 		if (vdec->slave) {
@@ -8167,15 +9129,92 @@ static void vh265_work(struct work_struct *work)
 		}
 #endif
 #endif
+#ifdef CONFIG_AM_VDEC_DV
+		hevc->shift_byte_count_lo
+			= READ_VREG(HEVC_SHIFT_BYTE_COUNT);
+		if (vdec->slave) {
+			/*cur is base, found enhance*/
+			struct hevc_state_s *hevc_el =
+			(struct hevc_state_s *)
+				vdec->slave->private;
+			if (hevc_el)
+				hevc_el->shift_byte_count_lo =
+				hevc->shift_byte_count_lo;
+		} else if (vdec->master) {
+			/*cur is enhance, found base*/
+			struct hevc_state_s *hevc_ba =
+			(struct hevc_state_s *)
+				vdec->master->private;
+			if (hevc_ba)
+				hevc_ba->shift_byte_count_lo =
+				hevc->shift_byte_count_lo;
+		}
+#endif
 		vdec_vframe_dirty(hw_to_vdec(hevc), hevc->chunk);
-	} else {
-		hevc_print(hevc, PRINT_FLAG_VDEC_DETAIL,
-			"%s dec_result %d %x %x %x\n",
-			__func__,
-			hevc->dec_result,
-			READ_VREG(HEVC_STREAM_LEVEL),
-			READ_VREG(HEVC_STREAM_WR_PTR),
-			READ_VREG(HEVC_STREAM_RD_PTR));
+	} else if (hevc->dec_result == DEC_RESULT_AGAIN) {
+		/*
+			stream base: stream buf empty or timeout
+			frame base: vdec_prepare_input fail
+		*/
+		if (!vdec_has_more_input(vdec)) {
+			hevc->dec_result = DEC_RESULT_EOS;
+			vdec_schedule_work(&hevc->work);
+			return;
+		}
+
+	} else if (hevc->dec_result == DEC_RESULT_EOS) {
+		struct PIC_s *pic;
+		hevc->eos = 1;
+#ifdef CONFIG_AM_VDEC_DV
+		if ((vdec->master || vdec->slave) &&
+			READ_VREG(HEVC_AUX_DATA_SIZE) != 0)
+			dolby_get_meta(hevc);
+#endif
+		check_pic_decoded_lcu_count(hevc,
+			hevc->pic_decoded_lcu_idx);
+		pic = get_pic_by_POC(hevc, hevc->curr_POC);
+		hevc_print(hevc, PRINT_FLAG_VDEC_STATUS,
+			"%s: end of stream, last dec poc %d => 0x%pf\n",
+			__func__, hevc->curr_POC, pic);
+		flush_output(hevc, pic);
+#ifdef CONFIG_AM_VDEC_DV
+		hevc->shift_byte_count_lo
+			= READ_VREG(HEVC_SHIFT_BYTE_COUNT);
+		if (vdec->slave) {
+			/*cur is base, found enhance*/
+			struct hevc_state_s *hevc_el =
+			(struct hevc_state_s *)
+				vdec->slave->private;
+			if (hevc_el)
+				hevc_el->shift_byte_count_lo =
+				hevc->shift_byte_count_lo;
+		} else if (vdec->master) {
+			/*cur is enhance, found base*/
+			struct hevc_state_s *hevc_ba =
+			(struct hevc_state_s *)
+				vdec->master->private;
+			if (hevc_ba)
+				hevc_ba->shift_byte_count_lo =
+				hevc->shift_byte_count_lo;
+		}
+#endif
+		vdec_vframe_dirty(hw_to_vdec(hevc), hevc->chunk);
+	} else if (hevc->dec_result == DEC_RESULT_FORCE_EXIT) {
+		hevc_print(hevc, PRINT_FLAG_VDEC_STATUS,
+			"%s: force exit\n",
+			__func__);
+		if (hevc->stat & STAT_VDEC_RUN) {
+			amhevc_stop();
+			hevc->stat &= ~STAT_VDEC_RUN;
+		}
+		if (hevc->stat & STAT_ISR_REG) {
+#ifdef MULTI_INSTANCE_SUPPORT
+			if (!hevc->m_ins_flag)
+#endif
+				WRITE_VREG(HEVC_ASSIST_MBOX1_MASK, 0);
+			vdec_free_irq(VDEC_IRQ_1, (void *)hevc);
+			hevc->stat &= ~STAT_ISR_REG;
+		}
 	}
 
 	if (hevc->stat & STAT_TIMER_ARM) {
@@ -8210,59 +9249,22 @@ static bool run_ready(struct vdec_s *vdec)
 {
 	struct hevc_state_s *hevc =
 		(struct hevc_state_s *)vdec->private;
+	bool ret = 0;
 
-	/*hevc_print(hevc,
-		PRINT_FLAG_VDEC_DETAIL, "%s\r\n", __func__);
-	*/
-	if ((!vdec_frame_based(vdec)) && (start_decode_buf_level > 0)) {
-		u32 rp, wp;
-		u32 level;
-
-		rp = READ_MPEG_REG(PARSER_VIDEO_RP);
-		wp = READ_MPEG_REG(PARSER_VIDEO_WP);
-
-		if (wp < rp)
-			level = vdec->input.size + wp - rp;
-		else
-			level = wp - rp;
+	if (hevc->eos)
+		return 0;
 
-		if (level < start_decode_buf_level) {
-			hevc_print(hevc, 0,
-				"level %d not run_ready\n", level);
-			return false;
-		}
-	} else if (vdec_frame_based(vdec)) {
-		if (!vdec_input_next_input_chunk(&vdec->input))
-			return false;
+	ret = is_new_pic_available(hevc);
+	if (!ret) {
+		hevc_print(hevc,
+		PRINT_FLAG_VDEC_DETAIL, "%s=>%d\r\n",
+		__func__, ret);
 	}
-
-	return is_new_pic_available(hevc);
-}
-
-static void reset_dec_hw(struct vdec_s *vdec)
-{
-	if (input_frame_based(vdec))
-		WRITE_VREG(HEVC_STREAM_CONTROL, 0);
-
-		/*
-	 * 2: assist
-	 * 3: parser
-	 * 4: parser_state
-	 * 8: dblk
-	 * 11:mcpu
-	 * 12:ccpu
-	 * 13:ddr
-	 * 14:iqit
-	 * 15:ipp
-	 * 17:qdct
-	 * 18:mpred
-	 * 19:sao
-	 * 24:hevc_afifo
-	 */
-	WRITE_VREG(DOS_SW_RESET3,
-		(1<<3)|(1<<4)|(1<<8)|(1<<11)|(1<<12)|(1<<14)|(1<<15)|
-		(1<<17)|(1<<18)|(1<<19));
-	WRITE_VREG(DOS_SW_RESET3, 0);
+	if (ret)
+		not_run_ready[hevc->index] = 0;
+	else
+		not_run_ready[hevc->index]++;
+	return ret;
 }
 
 static void run(struct vdec_s *vdec,
@@ -8271,34 +9273,51 @@ static void run(struct vdec_s *vdec,
 	struct hevc_state_s *hevc =
 		(struct hevc_state_s *)vdec->private;
 	int r;
-
+	unsigned char check_sum = 0;
+	run_count[hevc->index]++;
 	hevc->vdec_cb_arg = arg;
 	hevc->vdec_cb = callback;
 
-	reset_dec_hw(vdec);
+	hevc_reset_core(vdec);
 
 	r = vdec_prepare_input(vdec, &hevc->chunk);
 	if (r < 0) {
+		input_empty[hevc->index]++;
 		hevc->dec_result = DEC_RESULT_AGAIN;
 
 		hevc_print(hevc, PRINT_FLAG_VDEC_DETAIL,
 			"ammvdec_vh265: Insufficient data\n");
 
-		schedule_work(&hevc->work);
+		vdec_schedule_work(&hevc->work);
 		return;
 	}
-
+	input_empty[hevc->index] = 0;
 	hevc->dec_result = DEC_RESULT_NONE;
 
+	if (vdec_frame_based(vdec) &&
+		((get_dbg_flag(hevc) & PRINT_FLAG_VDEC_STATUS)
+		|| is_log_enable(hevc)))
+		check_sum = get_data_check_sum(hevc, r);
+
+	if (is_log_enable(hevc))
+		add_log(hevc,
+			"%s: size 0x%x sum 0x%x shiftbyte 0x%x",
+			__func__, r,
+			check_sum,
+			READ_VREG(HEVC_SHIFT_BYTE_COUNT)
+			);
+	hevc->start_shift_bytes = READ_VREG(HEVC_SHIFT_BYTE_COUNT);
 	hevc_print(hevc, PRINT_FLAG_VDEC_STATUS,
-		"%s: size 0x%x sum 0x%x (%x %x %x)\n",
+		"%s: size 0x%x sum 0x%x (%x %x %x %x %x) byte count %x\n",
 		__func__, r,
-		(vdec_frame_based(vdec) &&
-		(get_dbg_flag(hevc) & PRINT_FLAG_VDEC_STATUS)) ?
-		get_data_check_sum(hevc, r) : 0,
+		check_sum,
 		READ_VREG(HEVC_STREAM_LEVEL),
 		READ_VREG(HEVC_STREAM_WR_PTR),
-		READ_VREG(HEVC_STREAM_RD_PTR));
+		READ_VREG(HEVC_STREAM_RD_PTR),
+		READ_PARSER_REG(PARSER_VIDEO_RP),
+		READ_PARSER_REG(PARSER_VIDEO_WP),
+		hevc->start_shift_bytes
+		);
 	if ((get_dbg_flag(hevc) & PRINT_FRAMEBASE_DATA) &&
 		input_frame_based(vdec)) {
 		int jj;
@@ -8315,16 +9334,27 @@ static void run(struct vdec_s *vdec,
 					"\n");
 		}
 	}
-	if (hevc->init_flag == 0) {
-		if (amhevc_vdec_loadmc_ex(vdec, "vh265_mc") < 0) {
+	if (hevc->mmu_enable &&
+		(get_cpu_type() >= MESON_CPU_MAJOR_ID_GXL)) {
+		if (amhevc_vdec_loadmc_ex(vdec, "vh265_mc_mmu") < 0) {
+			amhevc_disable();
+			hevc_print(hevc, 0,
+				"%s: Error amvdec_loadmc fail\n",
+				__func__);
+			return;
+		}
+	} else {
+		if (amhevc_vdec_loadmc_ex
+			(vdec, "vh265_mc") < 0) {
 			amhevc_disable();
 			hevc_print(hevc, 0,
-				"%s: Error amvdec_loadmc fail\n", __func__);
+				"%s: Error amvdec_loadmc fail\n",
+				__func__);
 			return;
 		}
 	}
 	if (vh265_hw_ctx_restore(hevc) < 0) {
-		schedule_work(&hevc->work);
+		vdec_schedule_work(&hevc->work);
 		return;
 	}
 
@@ -8332,9 +9362,18 @@ static void run(struct vdec_s *vdec,
 
 	WRITE_VREG(HEVC_DEC_STATUS_REG, HEVC_ACTION_DONE);
 
-	if (vdec_frame_based(vdec))
+	if (vdec_frame_based(vdec)) {
 		WRITE_VREG(HEVC_SHIFT_BYTE_COUNT, 0);
-
+		r = hevc->chunk->size +
+			(hevc->chunk->offset & (VDEC_FIFO_ALIGN - 1));
+	}
+#ifdef CONFIG_AM_VDEC_DV
+	else {
+		if (vdec->master || vdec->slave)
+			WRITE_VREG(HEVC_SHIFT_BYTE_COUNT,
+				hevc->shift_byte_count_lo);
+	}
+#endif
 	WRITE_VREG(HEVC_DECODE_SIZE, r);
 	/*WRITE_VREG(HEVC_DECODE_COUNT, hevc->decode_idx);*/
 	hevc->init_flag = 1;
@@ -8342,11 +9381,14 @@ static void run(struct vdec_s *vdec,
 	if (hevc->pic_list_init_flag == 3)
 		init_pic_list_hw(hevc);
 
+	backup_decode_state(hevc);
+
 	start_process_time(hevc);
-	add_timer(&hevc->timer);
+	mod_timer(&hevc->timer, jiffies);
 	hevc->stat |= STAT_TIMER_ARM;
+	hevc->stat |= STAT_ISR_REG;
 	amhevc_start();
-
+	hevc->stat |= STAT_VDEC_RUN;
 }
 
 static void reset(struct vdec_s *vdec)
@@ -8386,50 +9428,60 @@ static int amvdec_h265_probe(struct platform_device *pdev)
 		(struct vdec_dev_reg_s *)pdev->dev.platform_data;
 #endif
 	struct hevc_state_s *hevc = &gHevc;
+	int ret;
 
+	memset(hevc, 0, sizeof(struct hevc_state_s));
 	if (get_dbg_flag(hevc))
 		hevc_print(hevc, 0, "%s\r\n", __func__);
 	mutex_lock(&vh265_mutex);
 
 	if ((get_cpu_type() >= MESON_CPU_MAJOR_ID_GXTVBB) &&
 		(parser_sei_enable & 0x100) == 0)
-		parser_sei_enable = 1;
+		parser_sei_enable = 7; /*old 1*/
 	hevc->m_ins_flag = 0;
 	hevc->init_flag = 0;
 	hevc->uninit_list = 0;
 	hevc->fatal_error = 0;
 	hevc->show_frame_num = 0;
+#ifdef MULTI_INSTANCE_SUPPORT
+	hevc->platform_dev = pdev;
+	platform_set_drvdata(pdev, pdata);
+#endif
+
 	if (pdata == NULL) {
 		hevc_print(hevc, 0,
 			"\namvdec_h265 memory resource undefined.\n");
 		mutex_unlock(&vh265_mutex);
 		return -EFAULT;
 	}
-#ifndef CONFIG_MULTI_DEC
-	if (get_cpu_type() < MESON_CPU_MAJOR_ID_GXL
-		|| double_write_mode == 0x10)
-		mmu_enable = 0;
-	else
-		mmu_enable = 1;
-#endif
+	if (mmu_enable_force == 0) {
+		if (get_cpu_type() < MESON_CPU_MAJOR_ID_GXL
+			|| double_write_mode == 0x10)
+			hevc->mmu_enable = 0;
+		else
+			hevc->mmu_enable = 1;
+	}
 	if (init_mmu_buffers(hevc)) {
 		hevc_print(hevc, 0,
 			"\n 265 mmu init failed!\n");
 		mutex_unlock(&vh265_mutex);
 		return -EFAULT;
 	}
-	hevc->buf_start = pdata->mem_start;
-	hevc->buf_size = pdata->mem_end - pdata->mem_start + 1;
-	/*
-	hevc->mc_buf_spec.buf_end = pdata->mem_end + 1;
-	for (i = 0; i < WORK_BUF_SPEC_NUM; i++)
-		amvh265_workbuff_spec[i].start_adr = pdata->mem_start;
-	*/
+
+	ret = decoder_bmmu_box_alloc_buf_phy(hevc->bmmu_box, BMMU_WORKSPACE_ID,
+			work_buf_size, DRIVER_NAME, &hevc->buf_start);
+	if (ret < 0) {
+		uninit_mmu_buffers(hevc);
+		devm_kfree(&pdev->dev, (void *)hevc);
+		mutex_unlock(&vh265_mutex);
+		return ret;
+	}
+	hevc->buf_size = work_buf_size;
 
 	if (get_dbg_flag(hevc)) {
 		hevc_print(hevc, 0,
-			"===H.265 decoder mem resource 0x%lx -- 0x%lx\n",
-			pdata->mem_start, pdata->mem_end + 1);
+			"===H.265 decoder mem resource 0x%lx size 0x%x\n",
+			hevc->buf_start, hevc->buf_size);
 	}
 
 	if (pdata->sys_info)
@@ -8448,6 +9500,8 @@ static int amvdec_h265_probe(struct platform_device *pdev)
 		workaround_enable &= ~3;
 #endif
 	hevc->cma_dev = pdata->cma_dev;
+	vh265_vdec_info_init();
+
 #ifdef MULTI_INSTANCE_SUPPORT
 	pdata->private = hevc;
 	pdata->dec_status = vh265_dec_status;
@@ -8509,11 +9563,161 @@ static struct platform_driver amvdec_h265_driver = {
 };
 
 #ifdef MULTI_INSTANCE_SUPPORT
+static void vh265_dump_state(struct vdec_s *vdec)
+{
+	int i;
+	struct hevc_state_s *hevc =
+		(struct hevc_state_s *)vdec->private;
+	hevc_print(hevc, 0,
+		"====== %s\n", __func__);
+
+	hevc_print(hevc, 0,
+		"width/height (%d/%d), reorder_pic_num %d buf count(bufspec size) %d\n",
+		hevc->frame_width,
+		hevc->frame_height,
+		hevc->sps_num_reorder_pics_0,
+		get_work_pic_num(hevc)
+		);
+
+	hevc_print(hevc, 0,
+		"is_framebase(%d), eos %d, dec_result 0x%x dec_frm %d disp_frm %d run %d not_run_ready %d input_empty %d\n",
+		input_frame_based(vdec),
+		hevc->eos,
+		hevc->dec_result,
+		decode_frame_count[hevc->index],
+		display_frame_count[hevc->index],
+		run_count[hevc->index],
+		not_run_ready[hevc->index],
+		input_empty[hevc->index]
+		);
+
+	if (vf_get_receiver(vdec->vf_provider_name)) {
+		enum receviver_start_e state =
+		vf_notify_receiver(vdec->vf_provider_name,
+			VFRAME_EVENT_PROVIDER_QUREY_STATE,
+			NULL);
+		hevc_print(hevc, 0,
+			"\nreceiver(%s) state %d\n",
+			vdec->vf_provider_name,
+			state);
+	}
+
+	hevc_print(hevc, 0,
+	"%s, newq(%d/%d), dispq(%d/%d), vf prepare/get/put (%d/%d/%d), pic_list_init_flag(%d), is_new_pic_available(%d)\n",
+	__func__,
+	kfifo_len(&hevc->newframe_q),
+	VF_POOL_SIZE,
+	kfifo_len(&hevc->display_q),
+	VF_POOL_SIZE,
+	hevc->vf_pre_count,
+	hevc->vf_get_count,
+	hevc->vf_put_count,
+	hevc->pic_list_init_flag,
+	is_new_pic_available(hevc)
+	);
+
+	dump_pic_list(hevc);
+
+	for (i = 0; i < BUF_POOL_SIZE; i++) {
+		hevc_print(hevc, 0,
+			"Buf(%d) start_adr 0x%x size 0x%x used %d\n",
+			i,
+			hevc->m_BUF[i].start_adr,
+			hevc->m_BUF[i].size,
+			hevc->m_BUF[i].used_flag);
+	}
+
+	for (i = 0; i < MAX_REF_PIC_NUM; i++) {
+		hevc_print(hevc, 0,
+			"mv_Buf(%d) start_adr 0x%x size 0x%x used %d\n",
+			i,
+			hevc->m_mv_BUF[i].start_adr,
+			hevc->m_mv_BUF[i].size,
+			hevc->m_mv_BUF[i].used_flag);
+	}
+
+	hevc_print(hevc, 0,
+		"HEVC_DEC_STATUS_REG=0x%x\n",
+		READ_VREG(HEVC_DEC_STATUS_REG));
+	hevc_print(hevc, 0,
+		"HEVC_MPC_E=0x%x\n",
+		READ_VREG(HEVC_MPC_E));
+	hevc_print(hevc, 0,
+		"HEVC_DECODE_MODE=0x%x\n",
+		READ_VREG(HEVC_DECODE_MODE));
+	hevc_print(hevc, 0,
+		"HEVC_DECODE_MODE2=0x%x\n",
+		READ_VREG(HEVC_DECODE_MODE2));
+	hevc_print(hevc, 0,
+		"NAL_SEARCH_CTL=0x%x\n",
+		READ_VREG(NAL_SEARCH_CTL));
+	hevc_print(hevc, 0,
+		"HEVC_PARSER_LCU_START=0x%x\n",
+		READ_VREG(HEVC_PARSER_LCU_START));
+	hevc_print(hevc, 0,
+		"HEVC_DECODE_SIZE=0x%x\n",
+		READ_VREG(HEVC_DECODE_SIZE));
+	hevc_print(hevc, 0,
+		"HEVC_SHIFT_BYTE_COUNT=0x%x\n",
+		READ_VREG(HEVC_SHIFT_BYTE_COUNT));
+	hevc_print(hevc, 0,
+		"HEVC_STREAM_START_ADDR=0x%x\n",
+		READ_VREG(HEVC_STREAM_START_ADDR));
+	hevc_print(hevc, 0,
+		"HEVC_STREAM_END_ADDR=0x%x\n",
+		READ_VREG(HEVC_STREAM_END_ADDR));
+	hevc_print(hevc, 0,
+		"HEVC_STREAM_LEVEL=0x%x\n",
+		READ_VREG(HEVC_STREAM_LEVEL));
+	hevc_print(hevc, 0,
+		"HEVC_STREAM_WR_PTR=0x%x\n",
+		READ_VREG(HEVC_STREAM_WR_PTR));
+	hevc_print(hevc, 0,
+		"HEVC_STREAM_RD_PTR=0x%x\n",
+		READ_VREG(HEVC_STREAM_RD_PTR));
+	hevc_print(hevc, 0,
+		"PARSER_VIDEO_RP=0x%x\n",
+		READ_PARSER_REG(PARSER_VIDEO_RP));
+	hevc_print(hevc, 0,
+		"PARSER_VIDEO_WP=0x%x\n",
+		READ_PARSER_REG(PARSER_VIDEO_WP));
+
+	if (input_frame_based(vdec) &&
+		(get_dbg_flag(hevc) & PRINT_FRAMEBASE_DATA)
+		) {
+		int jj;
+		if (hevc->chunk && hevc->chunk->block &&
+			hevc->chunk->size > 0) {
+			u8 *data =
+			((u8 *)hevc->chunk->block->start_virt) +
+				hevc->chunk->offset;
+			hevc_print(hevc, 0,
+				"frame data size 0x%x\n",
+				hevc->chunk->size);
+			for (jj = 0; jj < hevc->chunk->size; jj++) {
+				if ((jj & 0xf) == 0)
+					hevc_print(hevc,
+					PRINT_FRAMEBASE_DATA,
+						"%06x:", jj);
+				hevc_print_cont(hevc,
+				PRINT_FRAMEBASE_DATA,
+					"%02x ", data[jj]);
+				if (((jj + 1) & 0xf) == 0)
+					hevc_print_cont(hevc,
+					PRINT_FRAMEBASE_DATA,
+						"\n");
+			}
+		}
+	}
+
+}
+
 static int ammvdec_h265_probe(struct platform_device *pdev)
 {
 
 	struct vdec_s *pdata = *(struct vdec_s **)pdev->dev.platform_data;
 	struct hevc_state_s *hevc = NULL;
+	int ret;
 #ifdef CONFIG_MULTI_DEC
 	int config_val;
 #endif
@@ -8522,8 +9726,10 @@ static int ammvdec_h265_probe(struct platform_device *pdev)
 		return -EFAULT;
 	}
 
-	hevc = (struct hevc_state_s *)devm_kzalloc(&pdev->dev,
-		sizeof(struct hevc_state_s), GFP_KERNEL);
+	/* hevc = (struct hevc_state_s *)devm_kzalloc(&pdev->dev,
+		sizeof(struct hevc_state_s), GFP_KERNEL); */
+	hevc = vmalloc(sizeof(struct hevc_state_s));
+	memset(hevc, 0, sizeof(struct hevc_state_s));
 	if (hevc == NULL) {
 		pr_info("\nammvdec_h265 device data allocation failed\n");
 		return -ENOMEM;
@@ -8536,8 +9742,8 @@ static int ammvdec_h265_probe(struct platform_device *pdev)
 	pdata->reset = reset;
 	pdata->irq_handler = vh265_irq_cb;
 	pdata->threaded_irq_handler = vh265_threaded_irq_cb;
+	pdata->dump_state = vh265_dump_state;
 
-	pdata->id = pdev->id;
 	hevc->index = pdev->id;
 
 	if (pdata->use_vfm_path)
@@ -8546,6 +9752,8 @@ static int ammvdec_h265_probe(struct platform_device *pdev)
 			VFM_DEC_PROVIDER_NAME);
 #ifdef CONFIG_AM_VDEC_DV
 	else if (vdec_dual(pdata)) {
+		struct hevc_state_s *hevc_pair = NULL;
+
 		if (dv_toggle_prov_name) /*debug purpose*/
 			snprintf(pdata->vf_provider_name,
 			VDEC_PROVIDER_NAME_SIZE,
@@ -8557,6 +9765,15 @@ static int ammvdec_h265_probe(struct platform_device *pdev)
 				(pdata->master) ? VFM_DEC_DVEL_PROVIDER_NAME :
 				VFM_DEC_DVBL_PROVIDER_NAME);
 		hevc->dolby_enhance_flag = pdata->master ? 1 : 0;
+		if (pdata->master)
+			hevc_pair = (struct hevc_state_s *)
+				pdata->master->private;
+		else if (pdata->slave)
+			hevc_pair = (struct hevc_state_s *)
+				pdata->slave->private;
+		if (hevc_pair)
+			hevc->shift_byte_count_lo =
+			hevc_pair->shift_byte_count_lo;
 	}
 #endif
 	else
@@ -8570,11 +9787,47 @@ static int ammvdec_h265_probe(struct platform_device *pdev)
 	platform_set_drvdata(pdev, pdata);
 
 	hevc->platform_dev = pdev;
+
+	if (((get_dbg_flag(hevc) & IGNORE_PARAM_FROM_CONFIG) == 0) &&
+			pdata->config && pdata->config_len) {
+#ifdef CONFIG_MULTI_DEC
+		/*use ptr config for doubel_write_mode, etc*/
+		hevc_print(hevc, 0, "pdata->config=%s\n", pdata->config);
+
+		if (get_config_int(pdata->config, "hevc_buf_margin",
+				&config_val) == 0)
+			hevc->dynamic_buf_num_margin = config_val;
+		else
+			hevc->dynamic_buf_num_margin = dynamic_buf_num_margin;
+
+		if (get_config_int(pdata->config, "hevc_double_write_mode",
+				&config_val) == 0)
+			hevc->double_write_mode = config_val;
+		else
+			hevc->double_write_mode = double_write_mode;
+#endif
+	} else {
+		hevc->vh265_amstream_dec_info.width = 0;
+		hevc->vh265_amstream_dec_info.height = 0;
+		hevc->vh265_amstream_dec_info.rate = 30;
+		hevc->dynamic_buf_num_margin = dynamic_buf_num_margin;
+		hevc->double_write_mode = double_write_mode;
+	}
+
+	if (mmu_enable_force == 0) {
+		if (get_cpu_type() < MESON_CPU_MAJOR_ID_GXL
+			|| hevc->double_write_mode == 0x10)
+			hevc->mmu_enable = 0;
+		else
+			hevc->mmu_enable = 1;
+	}
+
 	if (init_mmu_buffers(hevc) < 0) {
 		hevc_print(hevc, 0,
 			"\n 265 mmu init failed!\n");
 		mutex_unlock(&vh265_mutex);
-		devm_kfree(&pdev->dev, (void *)hevc);
+		/* devm_kfree(&pdev->dev, (void *)hevc);*/
+		vfree((void *)hevc);
 		return -EFAULT;
 	}
 #if 0
@@ -8582,28 +9835,21 @@ static int ammvdec_h265_probe(struct platform_device *pdev)
 	hevc->buf_size = pdata->mem_end - pdata->mem_start + 1;
 #else
 
-	if (decoder_bmmu_box_alloc_idx_wait(
-		hevc->bmmu_box,
-		BMMU_WORKSPACE_ID,
-		work_buf_size,
-		-1,
-		-1,
-		BMMU_ALLOC_FLAGS_WAITCLEAR) < 0) {
-		hevc_print(hevc, 0,
-			"workbuf alloc failed, request buf size 0x%lx\n",
-				work_buf_size);
+	ret = decoder_bmmu_box_alloc_buf_phy(hevc->bmmu_box,
+			BMMU_WORKSPACE_ID, work_buf_size,
+			DRIVER_NAME, &hevc->buf_start);
+	if (ret < 0) {
 		uninit_mmu_buffers(hevc);
-		devm_kfree(&pdev->dev, (void *)hevc);
-		return -ENOMEM;
+		/* devm_kfree(&pdev->dev, (void *)hevc); */
+		vfree((void *)hevc);
+		mutex_unlock(&vh265_mutex);
+		return ret;
 	}
-	hevc->buf_start = decoder_bmmu_box_get_phy_addr(
-		hevc->bmmu_box,
-		BMMU_WORKSPACE_ID);
 	hevc->buf_size = work_buf_size;
 #endif
 	if ((get_cpu_type() >= MESON_CPU_MAJOR_ID_GXTVBB) &&
 		(parser_sei_enable & 0x100) == 0)
-		parser_sei_enable = 1;
+		parser_sei_enable = 7;
 	hevc->m_ins_flag = 1;
 	hevc->init_flag = 0;
 	hevc->uninit_list = 0;
@@ -8613,7 +9859,8 @@ static int ammvdec_h265_probe(struct platform_device *pdev)
 		hevc_print(hevc, 0,
 			"\namvdec_h265 memory resource undefined.\n");
 		uninit_mmu_buffers(hevc);
-		devm_kfree(&pdev->dev, (void *)hevc);
+		/* devm_kfree(&pdev->dev, (void *)hevc); */
+		vfree((void *)hevc);
 		return -EFAULT;
 	}
 	/*
@@ -8623,54 +9870,10 @@ static int ammvdec_h265_probe(struct platform_device *pdev)
 	*/
 	if (get_dbg_flag(hevc)) {
 		hevc_print(hevc, 0,
-			"===H.265 decoder mem resource 0x%lx -- 0x%lx\n",
-			   hevc->buf_start, hevc->buf_start + hevc->buf_size);
+			"===H.265 decoder mem resource 0x%lx size 0x%x\n",
+			   hevc->buf_start, hevc->buf_size);
 	}
 
-	if (((get_dbg_flag(hevc) & IGNORE_PARAM_FROM_CONFIG) == 0) &&
-			pdata->config && pdata->config_len) {
-#ifdef CONFIG_MULTI_DEC
-		/*use ptr config for doubel_write_mode, etc*/
-		hevc_print(hevc, 0, "pdata->config=%s\n", pdata->config);
-		if (get_config_int(pdata->config, "hevc_buf_width",
-				&config_val) == 0)
-			hevc->buf_alloc_width = config_val;
-		else
-			hevc->buf_alloc_width = buf_alloc_width;
-
-		if (get_config_int(pdata->config, "hevc_buf_height",
-				&config_val) == 0)
-			hevc->buf_alloc_height = config_val;
-		else
-			hevc->buf_alloc_height = buf_alloc_height;
-
-		if (get_config_int(pdata->config, "hevc_buf_margin",
-				&config_val) == 0)
-			hevc->dynamic_buf_num_margin = config_val;
-		else
-			hevc->dynamic_buf_num_margin = dynamic_buf_num_margin;
-
-		if (get_config_int(pdata->config, "hevc_double_write_mode",
-				&config_val) == 0)
-			hevc->double_write_mode = config_val;
-		else
-			hevc->double_write_mode = double_write_mode;
-#endif
-	} else {
-		hevc->vh265_amstream_dec_info.width = 0;
-		hevc->vh265_amstream_dec_info.height = 0;
-		hevc->vh265_amstream_dec_info.rate = 30;
-		hevc->buf_alloc_width = buf_alloc_width;
-		hevc->buf_alloc_height = buf_alloc_height;
-		hevc->dynamic_buf_num_margin = dynamic_buf_num_margin;
-		hevc->double_write_mode = double_write_mode;
-	}
-	hevc_print(hevc, 0,
-		"buf_alloc_width=%d\n",
-		hevc->buf_alloc_width);
-	hevc_print(hevc, 0,
-		"buf_alloc_height=%d\n",
-		hevc->buf_alloc_height);
 	hevc_print(hevc, 0,
 		"dynamic_buf_num_margin=%d\n",
 		hevc->dynamic_buf_num_margin);
@@ -8685,10 +9888,13 @@ static int ammvdec_h265_probe(struct platform_device *pdev)
 			"\namvdec_h265 init failed.\n");
 		hevc_local_uninit(hevc);
 		uninit_mmu_buffers(hevc);
-		devm_kfree(&pdev->dev, (void *)hevc);
+		/* devm_kfree(&pdev->dev, (void *)hevc); */
+		vfree((void *)hevc);
 		return -ENODEV;
 	}
 
+	vdec_set_prepare_level(pdata, start_decode_buf_level);
+
 	/*set the max clk for smooth playing...*/
 	hevc_source_changed(VFORMAT_HEVC,
 			3840, 2160, 60);
@@ -8711,6 +9917,7 @@ static int ammvdec_h265_remove(struct platform_device *pdev)
 
 	vdec_set_status(hw_to_vdec(hevc), VDEC_STATUS_DISCONNECTED);
 
+	vfree((void *)hevc);
 	return 0;
 }
 
@@ -8731,9 +9938,76 @@ static struct codec_profile_t amvdec_h265_profile = {
 	.name = "hevc",
 	.profile = ""
 };
+static struct mconfig h265_configs[] = {
+	MC_PU32("use_cma", &use_cma),
+	MC_PU32("bit_depth_luma", &bit_depth_luma),
+	MC_PU32("bit_depth_chroma", &bit_depth_chroma),
+	MC_PU32("video_signal_type", &video_signal_type),
+#ifdef ERROR_HANDLE_DEBUG
+	MC_PU32("dbg_nal_skip_flag", &dbg_nal_skip_flag),
+	MC_PU32("dbg_nal_skip_count", &dbg_nal_skip_count),
+#endif
+	MC_PU32("radr", &radr),
+	MC_PU32("rval", &rval),
+	MC_PU32("dbg_cmd", &dbg_cmd),
+	MC_PU32("dbg_skip_decode_index", &dbg_skip_decode_index),
+	MC_PU32("endian", &endian),
+	MC_PU32("step", &step),
+	MC_PU32("udebug_flag", &udebug_flag),
+	MC_PU32("decode_pic_begin", &decode_pic_begin),
+	MC_PU32("slice_parse_begin", &slice_parse_begin),
+	MC_PU32("nal_skip_policy", &nal_skip_policy),
+	MC_PU32("i_only_flag", &i_only_flag),
+	MC_PU32("error_handle_policy", &error_handle_policy),
+	MC_PU32("error_handle_threshold", &error_handle_threshold),
+	MC_PU32("error_handle_nal_skip_threshold",
+		&error_handle_nal_skip_threshold),
+	MC_PU32("error_handle_system_threshold",
+		&error_handle_system_threshold),
+	MC_PU32("error_skip_nal_count", &error_skip_nal_count),
+	MC_PU32("debug", &debug),
+	MC_PU32("debug_mask", &debug_mask),
+	MC_PU32("buffer_mode", &buffer_mode),
+	MC_PU32("double_write_mode", &double_write_mode),
+	MC_PU32("buf_alloc_width", &buf_alloc_width),
+	MC_PU32("buf_alloc_height", &buf_alloc_height),
+	MC_PU32("dynamic_buf_num_margin", &dynamic_buf_num_margin),
+	MC_PU32("max_buf_num", &max_buf_num),
+	MC_PU32("buf_alloc_size", &buf_alloc_size),
+	MC_PU32("buffer_mode_dbg", &buffer_mode_dbg),
+	MC_PU32("mem_map_mode", &mem_map_mode),
+	MC_PU32("enable_mem_saving", &enable_mem_saving),
+	MC_PU32("force_w_h", &force_w_h),
+	MC_PU32("force_fps", &force_fps),
+	MC_PU32("max_decoding_time", &max_decoding_time),
+	MC_PU32("prefix_aux_buf_size", &prefix_aux_buf_size),
+	MC_PU32("suffix_aux_buf_size", &suffix_aux_buf_size),
+	MC_PU32("interlace_enable", &interlace_enable),
+	MC_PU32("pts_unstable", &pts_unstable),
+	MC_PU32("parser_sei_enable", &parser_sei_enable),
+	MC_PU32("start_decode_buf_level", &start_decode_buf_level),
+	MC_PU32("decode_timeout_val", &decode_timeout_val),
+#ifdef CONFIG_AM_VDEC_DV
+	MC_PU32("parser_dolby_vision_enable", &parser_dolby_vision_enable),
+	MC_PU32("dv_toggle_prov_name", &dv_toggle_prov_name),
+	MC_PU32("dv_debug", &dv_debug),
+#endif
+};
+static struct mconfig_node decoder_265_node;
 
 static int __init amvdec_h265_driver_init_module(void)
 {
+	struct BuffInfo_s *p_buf_info;
+#ifdef SUPPORT_4K2K
+	p_buf_info = &amvh265_workbuff_spec[1];
+#else
+	p_buf_info = &amvh265_workbuff_spec[0];
+#endif
+	init_buff_spec(NULL, p_buf_info);
+	work_buf_size =
+		(p_buf_info->end_adr - p_buf_info->start_adr
+		 + 0xffff) & (~0xffff);
+
 	pr_debug("amvdec_h265 module init\n");
 	error_handle_policy = 0;
 
@@ -8741,8 +10015,7 @@ static int __init amvdec_h265_driver_init_module(void)
 	dbg_nal_skip_flag = 0;
 	dbg_nal_skip_count = 0;
 #endif
-	decode_stop_pos = 0;
-	decode_stop_pos_pre = 0;
+	udebug_flag = 0;
 	decode_pic_begin = 0;
 	slice_parse_begin = 0;
 	step = 0;
@@ -8776,7 +10049,8 @@ static int __init amvdec_h265_driver_init_module(void)
 	}
 
 	vcodec_profile_register(&amvdec_h265_profile);
-
+	INIT_REG_NODE_CONFIGS("media.decoder", &decoder_265_node,
+		"h265", h265_configs, CONFIG_FOR_RW);
 	return 0;
 }
 
@@ -8816,26 +10090,26 @@ MODULE_PARM_DESC(dbg_nal_skip_count, "\n amvdec_h265 dbg_nal_skip_count\n");
 #endif
 
 module_param(radr, uint, 0664);
-MODULE_PARM_DESC(radr, "\nradr\n");
+MODULE_PARM_DESC(radr, "\n radr\n");
 
 module_param(rval, uint, 0664);
-MODULE_PARM_DESC(rval, "\nrval\n");
+MODULE_PARM_DESC(rval, "\n rval\n");
 
 module_param(dbg_cmd, uint, 0664);
-MODULE_PARM_DESC(dbg_cmd, "\ndbg_cmd\n");
+MODULE_PARM_DESC(dbg_cmd, "\n dbg_cmd\n");
+
+module_param(dump_nal, uint, 0664);
+MODULE_PARM_DESC(dump_nal, "\n dump_nal\n");
 
 module_param(dbg_skip_decode_index, uint, 0664);
-MODULE_PARM_DESC(dbg_skip_decode_index, "\ndbg_skip_decode_index\n");
+MODULE_PARM_DESC(dbg_skip_decode_index, "\n dbg_skip_decode_index\n");
 
 module_param(endian, uint, 0664);
-MODULE_PARM_DESC(endian, "\nrval\n");
+MODULE_PARM_DESC(endian, "\n rval\n");
 
 module_param(step, uint, 0664);
 MODULE_PARM_DESC(step, "\n amvdec_h265 step\n");
 
-module_param(decode_stop_pos, uint, 0664);
-MODULE_PARM_DESC(decode_stop_pos, "\n amvdec_h265 decode_stop_pos\n");
-
 module_param(decode_pic_begin, uint, 0664);
 MODULE_PARM_DESC(decode_pic_begin, "\n amvdec_h265 decode_pic_begin\n");
 
@@ -8873,6 +10147,9 @@ MODULE_PARM_DESC(debug, "\n amvdec_h265 debug\n");
 module_param(debug_mask, uint, 0664);
 MODULE_PARM_DESC(debug_mask, "\n amvdec_h265 debug mask\n");
 
+module_param(log_mask, uint, 0664);
+MODULE_PARM_DESC(log_mask, "\n amvdec_h265 log_mask\n");
+
 module_param(buffer_mode, uint, 0664);
 MODULE_PARM_DESC(buffer_mode, "\n buffer_mode\n");
 
@@ -8894,8 +10171,10 @@ MODULE_PARM_DESC(max_buf_num, "\n max_buf_num\n");
 module_param(buf_alloc_size, uint, 0664);
 MODULE_PARM_DESC(buf_alloc_size, "\n buf_alloc_size\n");
 
+#if 0
 module_param(re_config_pic_flag, uint, 0664);
 MODULE_PARM_DESC(re_config_pic_flag, "\n re_config_pic_flag\n");
+#endif
 
 module_param(buffer_mode_dbg, uint, 0664);
 MODULE_PARM_DESC(buffer_mode_dbg, "\n buffer_mode_dbg\n");
@@ -8932,10 +10211,19 @@ MODULE_PARM_DESC(parser_sei_enable, "\n parser_sei_enable\n");
 module_param(parser_dolby_vision_enable, uint, 0664);
 MODULE_PARM_DESC(parser_dolby_vision_enable,
 	"\n parser_dolby_vision_enable\n");
+
+module_param(dolby_meta_with_el, uint, 0664);
+MODULE_PARM_DESC(dolby_meta_with_el,
+	"\n dolby_meta_with_el\n");
 #endif
+module_param(mmu_enable, uint, 0664);
+MODULE_PARM_DESC(mmu_enable, "\n mmu_enable\n");
+
+module_param(mmu_enable_force, uint, 0664);
+MODULE_PARM_DESC(mmu_enable_force, "\n mmu_enable_force\n");
 
 #ifdef MULTI_INSTANCE_SUPPORT
-module_param(start_decode_buf_level, uint, 0664);
+module_param(start_decode_buf_level, int, 0664);
 MODULE_PARM_DESC(start_decode_buf_level,
 		"\n h265 start_decode_buf_level\n");
 
@@ -8943,15 +10231,30 @@ module_param(decode_timeout_val, uint, 0664);
 MODULE_PARM_DESC(decode_timeout_val,
 	"\n h265 decode_timeout_val\n");
 
+module_param(data_resend_policy, uint, 0664);
+MODULE_PARM_DESC(data_resend_policy,
+	"\n h265 data_resend_policy\n");
+
 module_param_array(decode_frame_count, uint,
 	&max_decode_instance_num, 0664);
 
+module_param_array(display_frame_count, uint,
+	&max_decode_instance_num, 0664);
+
 module_param_array(max_process_time, uint,
 	&max_decode_instance_num, 0664);
 
 module_param_array(max_get_frame_interval,
 	uint, &max_decode_instance_num, 0664);
 
+module_param_array(run_count, uint,
+	&max_decode_instance_num, 0664);
+
+module_param_array(input_empty, uint,
+	&max_decode_instance_num, 0664);
+
+module_param_array(not_run_ready, uint,
+	&max_decode_instance_num, 0664);
 #endif
 #ifdef CONFIG_AM_VDEC_DV
 module_param(dv_toggle_prov_name, uint, 0664);
@@ -8961,6 +10264,22 @@ module_param(dv_debug, uint, 0664);
 MODULE_PARM_DESC(dv_debug, "\n dv_debug\n");
 #endif
 
+module_param(force_disp_pic_index, int, 0664);
+MODULE_PARM_DESC(force_disp_pic_index,
+	"\n amvdec_h265 force_disp_pic_index\n");
+
+module_param(udebug_flag, uint, 0664);
+MODULE_PARM_DESC(udebug_flag, "\n amvdec_h265 udebug_flag\n");
+
+module_param(udebug_pause_pos, uint, 0664);
+MODULE_PARM_DESC(udebug_pause_pos, "\n udebug_pause_pos\n");
+
+module_param(udebug_pause_val, uint, 0664);
+MODULE_PARM_DESC(udebug_pause_val, "\n udebug_pause_val\n");
+
+module_param(udebug_pause_decode_idx, uint, 0664);
+MODULE_PARM_DESC(udebug_pause_decode_idx, "\n udebug_pause_decode_idx\n");
+
 module_init(amvdec_h265_driver_init_module);
 module_exit(amvdec_h265_driver_remove_module);
 
diff --git a/drivers/frame_provider/decoder/mjpeg/vmjpeg.c b/drivers/frame_provider/decoder/mjpeg/vmjpeg.c
index db27382..6b2d45d 100644
--- a/drivers/frame_provider/decoder/mjpeg/vmjpeg.c
+++ b/drivers/frame_provider/decoder/mjpeg/vmjpeg.c
@@ -32,6 +32,10 @@
 #include <linux/amlogic/media/utils/vdec_reg.h>
 #include "../../../stream_input/amports/amports_priv.h"
 #include <linux/amlogic/media/registers/register.h>
+#include "../utils/decoder_mmu_box.h"
+#include "../utils/decoder_bmmu_box.h"
+#include <linux/amlogic/media/codec_mm/codec_mm.h>
+#include <linux/amlogic/media/codec_mm/configs.h>
 
 #ifdef CONFIG_AM_VDEC_MJPEG_LOG
 #define AMLOG
@@ -70,7 +74,8 @@ MODULE_AMLOG(LOG_LEVEL_ERROR, 0, LOG_LEVEL_DESC, LOG_DEFAULT_MASK_DESC);
 #define PICINFO_INTERLACE_FIRST     0x0010
 
 #define VF_POOL_SIZE          16
-#define DECODE_BUFFER_NUM_MAX 4
+#define DECODE_BUFFER_NUM_MAX		4
+#define MAX_BMMU_BUFFER_NUM		DECODE_BUFFER_NUM_MAX
 #define PUT_INTERVAL        (HZ/100)
 
 #if 1/*MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6*/
@@ -86,10 +91,11 @@ static void vmjpeg_vf_put(struct vframe_s *, void *);
 static int vmjpeg_vf_states(struct vframe_states *states, void *);
 static int vmjpeg_event_cb(int type, void *data, void *private_data);
 
-static void vmjpeg_prot_init(void);
+static int vmjpeg_prot_init(void);
 static void vmjpeg_local_init(void);
 
 static const char vmjpeg_dec_id[] = "vmjpeg-dev";
+static struct vdec_info *gvs;
 
 #define PROVIDER_NAME   "decoder.mjpeg"
 static const struct vframe_operations_s vmjpeg_vf_provider = {
@@ -99,7 +105,7 @@ static const struct vframe_operations_s vmjpeg_vf_provider = {
 	.event_cb = vmjpeg_event_cb,
 	.vf_states = vmjpeg_vf_states,
 };
-
+static void *mm_blk_handle;
 static struct vframe_provider_s vmjpeg_vf_prov;
 
 static DECLARE_KFIFO(newframe_q, struct vframe_s *, VF_POOL_SIZE);
@@ -113,8 +119,7 @@ static u32 frame_width, frame_height, frame_dur;
 static u32 saved_resolution;
 static struct timer_list recycle_timer;
 static u32 stat;
-static unsigned long buf_start;
-static u32 buf_size;
+static u32 buf_size = 32 * 1024 * 1024;
 static DEFINE_SPINLOCK(lock);
 
 static inline u32 index2canvas0(u32 index)
@@ -201,6 +206,13 @@ static irqreturn_t vmjpeg_isr(int irq, void *dev_id)
 			vf->orientation = 0;
 			vf->type_original = vf->type;
 			vfbuf_use[index]++;
+			vf->mem_handle =
+				decoder_bmmu_box_get_mem_handle(
+					mm_blk_handle,
+					index);
+
+			gvs->frame_dur = frame_dur;
+			vdec_count_info(gvs, 0, offset);
 
 			kfifo_put(&display_q, (const struct vframe_s *)vf);
 
@@ -279,6 +291,13 @@ static irqreturn_t vmjpeg_isr(int irq, void *dev_id)
 			}
 			vf->type_original = vf->type;
 			vfbuf_use[index]++;
+			vf->mem_handle =
+				decoder_bmmu_box_get_mem_handle(
+					mm_blk_handle,
+					index);
+
+			gvs->frame_dur = frame_dur;
+			vdec_count_info(gvs, 0, offset);
 
 			kfifo_put(&display_q, (const struct vframe_s *)vf);
 
@@ -384,27 +403,39 @@ static void vmjpeg_put_timer_func(unsigned long arg)
 	add_timer(timer);
 }
 
-int vmjpeg_dec_status(struct vdec_s *vdec, struct vdec_status *vstatus)
+int vmjpeg_dec_status(struct vdec_s *vdec, struct vdec_info *vstatus)
 {
-	vstatus->width = frame_width;
-	vstatus->height = frame_height;
+	vstatus->frame_width = frame_width;
+	vstatus->frame_height = frame_height;
 	if (0 != frame_dur)
-		vstatus->fps = 96000 / frame_dur;
+		vstatus->frame_rate = 96000 / frame_dur;
 	else
-		vstatus->fps = 96000;
+		vstatus->frame_rate = 96000;
 	vstatus->error_count = 0;
 	vstatus->status = stat;
+	vstatus->bit_rate = gvs->bit_rate;
+	vstatus->frame_dur = frame_dur;
+	vstatus->frame_data = gvs->frame_data;
+	vstatus->total_data = gvs->total_data;
+	vstatus->frame_count = gvs->frame_count;
+	vstatus->error_frame_count = gvs->error_frame_count;
+	vstatus->drop_frame_count = gvs->drop_frame_count;
+	vstatus->total_data = gvs->total_data;
+	vstatus->samp_cnt = gvs->samp_cnt;
+	vstatus->offset = gvs->offset;
+	snprintf(vstatus->vdec_name, sizeof(vstatus->vdec_name),
+		"%s", DRIVER_NAME);
 
 	return 0;
 }
 
 /****************************************/
-static void vmjpeg_canvas_init(void)
+static int vmjpeg_canvas_init(void)
 {
-	int i;
+	int i, ret;
 	u32 canvas_width, canvas_height;
 	u32 decbuf_size, decbuf_y_size, decbuf_uv_size;
-	u32 disp_addr = 0xffffffff;
+	unsigned long buf_start;
 
 	if (buf_size <= 0x00400000) {
 		/* SD only */
@@ -422,133 +453,72 @@ static void vmjpeg_canvas_init(void)
 		decbuf_size = 0x300000;
 	}
 
-	if (is_vpp_postblend()) {
-		struct canvas_s cur_canvas;
+	for (i = 0; i < MAX_BMMU_BUFFER_NUM; i++) {
 
-		canvas_read((READ_VCBUS_REG(VD1_IF0_CANVAS0) & 0xff),
-					&cur_canvas);
-		disp_addr = (cur_canvas.addr + 7) >> 3;
-	}
-
-	for (i = 0; i < 4; i++) {
-		if (((buf_start + i * decbuf_size + 7) >> 3) == disp_addr) {
-#ifdef NV21
-			canvas_config(index2canvas0(i) & 0xff,
-					buf_start + 4 * decbuf_size,
-					canvas_width, canvas_height,
-					CANVAS_ADDR_NOWRAP,
-					CANVAS_BLKMODE_LINEAR);
-			canvas_config((index2canvas0(i) >> 8) & 0xff,
-					buf_start + 4 * decbuf_size +
-					decbuf_y_size, canvas_width,
-					canvas_height / 2, CANVAS_ADDR_NOWRAP,
-					CANVAS_BLKMODE_LINEAR);
-			canvas_config(index2canvas1(i) & 0xff,
-					buf_start + 4 * decbuf_size +
-					decbuf_size / 2, canvas_width,
-					canvas_height, CANVAS_ADDR_NOWRAP,
-					CANVAS_BLKMODE_LINEAR);
-			canvas_config((index2canvas1(i) >> 8) & 0xff,
-					buf_start + 4 * decbuf_size +
-					decbuf_y_size + decbuf_uv_size / 2,
-					canvas_width, canvas_height / 2,
-					CANVAS_ADDR_NOWRAP,
-					CANVAS_BLKMODE_LINEAR);
-#else
-			canvas_config(index2canvas0(i) & 0xff,
-					buf_start + 4 * decbuf_size,
-					canvas_width, canvas_height,
-					CANVAS_ADDR_NOWRAP,
-					CANVAS_BLKMODE_LINEAR);
-			canvas_config((index2canvas0(i) >> 8) & 0xff,
-					buf_start + 4 * decbuf_size +
-					decbuf_y_size, canvas_width / 2,
-					canvas_height / 2, CANVAS_ADDR_NOWRAP,
-					CANVAS_BLKMODE_LINEAR);
-			canvas_config((index2canvas0(i) >> 16) & 0xff,
-					buf_start + 4 * decbuf_size +
-					decbuf_y_size + decbuf_uv_size,
-					canvas_width / 2, canvas_height / 2,
-					CANVAS_ADDR_NOWRAP,
-					CANVAS_BLKMODE_LINEAR);
-			canvas_config(index2canvas1(i) & 0xff,
-					buf_start + 4 * decbuf_size +
-					decbuf_size / 2, canvas_width,
-					canvas_height, CANVAS_ADDR_NOWRAP,
-					CANVAS_BLKMODE_LINEAR);
-			canvas_config((index2canvas1(i) >> 8) & 0xff,
-					buf_start + 4 * decbuf_size +
-					decbuf_y_size + decbuf_uv_size / 2,
-					canvas_width / 2, canvas_height / 2,
-					CANVAS_ADDR_NOWRAP,
-					CANVAS_BLKMODE_LINEAR);
-			canvas_config((index2canvas1(i) >> 16) & 0xff,
-					buf_start + 4 * decbuf_size +
-					decbuf_y_size + decbuf_uv_size +
-					decbuf_uv_size / 2, canvas_width / 2,
-					canvas_height / 2, CANVAS_ADDR_NOWRAP,
-					CANVAS_BLKMODE_LINEAR);
-#endif
-		} else {
+		ret = decoder_bmmu_box_alloc_buf_phy(mm_blk_handle, i,
+				decbuf_size, DRIVER_NAME, &buf_start);
+		if (ret < 0)
+			return ret;
 #ifdef NV21
-			canvas_config(index2canvas0(i) & 0xff,
-					buf_start + i * decbuf_size,
-					canvas_width, canvas_height,
-					CANVAS_ADDR_NOWRAP,
-					CANVAS_BLKMODE_LINEAR);
-			canvas_config((index2canvas0(i) >> 8) & 0xff,
-					buf_start + i * decbuf_size +
-					decbuf_y_size, canvas_width,
-					canvas_height / 2, CANVAS_ADDR_NOWRAP,
-					CANVAS_BLKMODE_LINEAR);
-			canvas_config(index2canvas1(i) & 0xff,
-					buf_start + i * decbuf_size +
-					decbuf_size / 2, canvas_width,
-					canvas_height, CANVAS_ADDR_NOWRAP,
-					CANVAS_BLKMODE_LINEAR);
-			canvas_config((index2canvas1(i) >> 8) & 0xff,
-					buf_start + i * decbuf_size +
-					decbuf_y_size + decbuf_uv_size / 2,
-					canvas_width, canvas_height / 2,
-					CANVAS_ADDR_NOWRAP,
-					CANVAS_BLKMODE_LINEAR);
+		canvas_config(index2canvas0(i) & 0xff,
+			buf_start,
+			canvas_width, canvas_height,
+			CANVAS_ADDR_NOWRAP,
+			CANVAS_BLKMODE_LINEAR);
+		canvas_config((index2canvas0(i) >> 8) & 0xff,
+			buf_start +
+			decbuf_y_size, canvas_width,
+			canvas_height / 2, CANVAS_ADDR_NOWRAP,
+			CANVAS_BLKMODE_LINEAR);
+		canvas_config(index2canvas1(i) & 0xff,
+			buf_start +
+			decbuf_size / 2, canvas_width,
+			canvas_height, CANVAS_ADDR_NOWRAP,
+			CANVAS_BLKMODE_LINEAR);
+		canvas_config((index2canvas1(i) >> 8) & 0xff,
+			buf_start +
+			decbuf_y_size + decbuf_uv_size / 2,
+			canvas_width, canvas_height / 2,
+			CANVAS_ADDR_NOWRAP,
+			CANVAS_BLKMODE_LINEAR);
 #else
-			canvas_config(index2canvas0(i) & 0xff,
-					buf_start + i * decbuf_size,
-					canvas_width, canvas_height,
-					CANVAS_ADDR_NOWRAP,
-					CANVAS_BLKMODE_LINEAR);
-			canvas_config((index2canvas0(i) >> 8) & 0xff,
-					buf_start + i * decbuf_size +
-					decbuf_y_size, canvas_width / 2,
-					canvas_height / 2, CANVAS_ADDR_NOWRAP,
-					CANVAS_BLKMODE_LINEAR);
-			canvas_config((index2canvas0(i) >> 16) & 0xff,
-					buf_start + i * decbuf_size +
-					decbuf_y_size + decbuf_uv_size,
-					canvas_width / 2, canvas_height / 2,
-					CANVAS_ADDR_NOWRAP,
-					CANVAS_BLKMODE_LINEAR);
-			canvas_config(index2canvas1(i) & 0xff,
-					buf_start + i * decbuf_size +
-					decbuf_size / 2, canvas_width,
-					canvas_height, CANVAS_ADDR_NOWRAP,
-					CANVAS_BLKMODE_LINEAR);
-			canvas_config((index2canvas1(i) >> 8) & 0xff,
-					buf_start + i * decbuf_size +
-					decbuf_y_size + decbuf_uv_size / 2,
-					canvas_width / 2, canvas_height / 2,
-					CANVAS_ADDR_NOWRAP,
-					CANVAS_BLKMODE_LINEAR);
-			canvas_config((index2canvas1(i) >> 16) & 0xff,
-					buf_start + i * decbuf_size +
-					decbuf_y_size + decbuf_uv_size +
-					decbuf_uv_size / 2, canvas_width / 2,
-					canvas_height / 2, CANVAS_ADDR_NOWRAP,
-					CANVAS_BLKMODE_LINEAR);
+		canvas_config(index2canvas0(i) & 0xff,
+			buf_start,
+			canvas_width, canvas_height,
+			CANVAS_ADDR_NOWRAP,
+			CANVAS_BLKMODE_LINEAR);
+		canvas_config((index2canvas0(i) >> 8) & 0xff,
+			buf_start +
+			decbuf_y_size, canvas_width / 2,
+			canvas_height / 2, CANVAS_ADDR_NOWRAP,
+			CANVAS_BLKMODE_LINEAR);
+		canvas_config((index2canvas0(i) >> 16) & 0xff,
+			buf_start +
+			decbuf_y_size + decbuf_uv_size,
+			canvas_width / 2, canvas_height / 2,
+			CANVAS_ADDR_NOWRAP,
+			CANVAS_BLKMODE_LINEAR);
+		canvas_config(index2canvas1(i) & 0xff,
+			buf_start +
+			decbuf_size / 2, canvas_width,
+			canvas_height, CANVAS_ADDR_NOWRAP,
+			CANVAS_BLKMODE_LINEAR);
+		canvas_config((index2canvas1(i) >> 8) & 0xff,
+			buf_start +
+			decbuf_y_size + decbuf_uv_size / 2,
+			canvas_width / 2, canvas_height / 2,
+			CANVAS_ADDR_NOWRAP,
+			CANVAS_BLKMODE_LINEAR);
+		canvas_config((index2canvas1(i) >> 16) & 0xff,
+			buf_start +
+			decbuf_y_size + decbuf_uv_size +
+			decbuf_uv_size / 2, canvas_width / 2,
+			canvas_height / 2, CANVAS_ADDR_NOWRAP,
+			CANVAS_BLKMODE_LINEAR);
 #endif
-		}
+
 	}
+	return 0;
 }
 
 static void init_scaler(void)
@@ -625,26 +595,27 @@ static void init_scaler(void)
 	WRITE_VREG(DOS_SW_RESET0, (1 << 10));
 	WRITE_VREG(DOS_SW_RESET0, 0);
 #else
-	WRITE_MPEG_REG(RESET2_REGISTER, RESET_PSCALE);
+	WRITE_RESET_REG(RESET2_REGISTER, RESET_PSCALE);
 #endif
-	READ_MPEG_REG(RESET2_REGISTER);
-	READ_MPEG_REG(RESET2_REGISTER);
-	READ_MPEG_REG(RESET2_REGISTER);
+	READ_RESET_REG(RESET2_REGISTER);
+	READ_RESET_REG(RESET2_REGISTER);
+	READ_RESET_REG(RESET2_REGISTER);
 
 	WRITE_VREG(PSCALE_RST, 0x7);
 	WRITE_VREG(PSCALE_RST, 0x0);
 }
 
-static void vmjpeg_prot_init(void)
+static int vmjpeg_prot_init(void)
 {
+	int r;
 #if 1/*MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6*/
 	WRITE_VREG(DOS_SW_RESET0, (1 << 7) | (1 << 6));
 	WRITE_VREG(DOS_SW_RESET0, 0);
 #else
-	WRITE_MPEG_REG(RESET0_REGISTER, RESET_IQIDCT | RESET_MC);
+	WRITE_RESET_REG(RESET0_REGISTER, RESET_IQIDCT | RESET_MC);
 #endif
 
-	vmjpeg_canvas_init();
+	r = vmjpeg_canvas_init();
 
 	WRITE_VREG(AV_SCRATCH_0, 12);
 	WRITE_VREG(AV_SCRATCH_1, 0x031a);
@@ -681,6 +652,17 @@ static void vmjpeg_prot_init(void)
 	CLEAR_VREG_MASK(MDEC_PIC_DC_CTRL, 1 << 17);
 #endif
 #endif
+	return r;
+}
+
+static int vmjpeg_vdec_info_init(void)
+{
+	gvs = kzalloc(sizeof(struct vdec_info), GFP_KERNEL);
+	if (NULL == gvs) {
+		pr_info("the struct of vdec status malloc failed.\n");
+		return -ENOMEM;
+	}
+	return 0;
 }
 
 static void vmjpeg_local_init(void)
@@ -706,6 +688,18 @@ static void vmjpeg_local_init(void)
 		vfpool[i].index = DECODE_BUFFER_NUM_MAX;
 		kfifo_put(&newframe_q, vf);
 	}
+	if (mm_blk_handle) {
+		decoder_bmmu_box_free(mm_blk_handle);
+		mm_blk_handle = NULL;
+	}
+
+	mm_blk_handle = decoder_bmmu_box_alloc_box(
+		DRIVER_NAME,
+		0,
+		MAX_BMMU_BUFFER_NUM,
+		4 + PAGE_SHIFT,
+		CODEC_MM_FLAGS_CMA_CLEAR |
+		CODEC_MM_FLAGS_FOR_VDECODER);
 }
 
 static s32 vmjpeg_init(void)
@@ -741,7 +735,9 @@ static s32 vmjpeg_init(void)
 	stat |= STAT_MC_LOAD;
 
 	/* enable AMRISC side protocol */
-	vmjpeg_prot_init();
+	ret = vmjpeg_prot_init();
+	if (ret < 0)
+		return ret;
 
 	ret = vdec_request_irq(VDEC_IRQ_1, vmjpeg_isr,
 			"vmjpeg-irq", (void *)vmjpeg_dec_id);
@@ -802,18 +798,18 @@ static int amvdec_mjpeg_probe(struct platform_device *pdev)
 		return -EFAULT;
 	}
 
-	buf_start = pdata->mem_start;
-	buf_size = pdata->mem_end - pdata->mem_start + 1;
-
 	if (pdata->sys_info)
 		vmjpeg_amstream_dec_info = *pdata->sys_info;
 
 	pdata->dec_status = vmjpeg_dec_status;
 
+	vmjpeg_vdec_info_init();
+
 	if (vmjpeg_init() < 0) {
 		amlog_level(LOG_LEVEL_ERROR, "amvdec_mjpeg init failed.\n");
 		mutex_unlock(&vmjpeg_mutex);
-
+		kfree(gvs);
+		gvs = NULL;
 		return -ENODEV;
 	}
 
@@ -855,6 +851,14 @@ static int amvdec_mjpeg_remove(struct platform_device *pdev)
 
 	mutex_unlock(&vmjpeg_mutex);
 
+	kfree(gvs);
+	gvs = NULL;
+
+	if (mm_blk_handle) {
+		decoder_bmmu_box_free(mm_blk_handle);
+		mm_blk_handle = NULL;
+	}
+
 	amlog_level(LOG_LEVEL_INFO, "amvdec_mjpeg remove.\n");
 
 	return 0;
@@ -878,6 +882,10 @@ static struct codec_profile_t amvdec_mjpeg_profile = {
 	.name = "mjpeg",
 	.profile = ""
 };
+static struct mconfig mjpeg_configs[] = {
+	MC_PU32("stat", &stat),
+};
+static struct mconfig_node mjpeg_node;
 
 static int __init amvdec_mjpeg_driver_init_module(void)
 {
@@ -889,6 +897,8 @@ static int __init amvdec_mjpeg_driver_init_module(void)
 		return -ENODEV;
 	}
 	vcodec_profile_register(&amvdec_mjpeg_profile);
+	INIT_REG_NODE_CONFIGS("media.decoder", &mjpeg_node,
+		"mjpeg", mjpeg_configs, CONFIG_FOR_RW);
 	return 0;
 }
 
diff --git a/drivers/frame_provider/decoder/mjpeg/vmjpeg_multi.c b/drivers/frame_provider/decoder/mjpeg/vmjpeg_multi.c
index 850e0b6..e1d451a 100644
--- a/drivers/frame_provider/decoder/mjpeg/vmjpeg_multi.c
+++ b/drivers/frame_provider/decoder/mjpeg/vmjpeg_multi.c
@@ -33,11 +33,13 @@
 #include <linux/amlogic/media/registers/register.h>
 #include "../../../stream_input/amports/amports_priv.h"
 
-#include <linux/amlogic/media/codec_mm/codec_mm.h>
-
 #include "../utils/vdec_input.h"
 #include "../utils/vdec.h"
 #include "../utils/amvdec.h"
+#include "../utils/decoder_mmu_box.h"
+#include "../utils/decoder_bmmu_box.h"
+#include <linux/amlogic/media/codec_mm/codec_mm.h>
+#include <linux/amlogic/media/codec_mm/configs.h>
 
 #define MEM_NAME "codec_mmjpeg"
 
@@ -62,7 +64,10 @@
 #define PICINFO_INTERLACE_FIRST     0x0010
 
 #define VF_POOL_SIZE          16
-#define DECODE_BUFFER_NUM_MAX 4
+#define DECODE_BUFFER_NUM_MAX		4
+#define MAX_BMMU_BUFFER_NUM		DECODE_BUFFER_NUM_MAX
+
+#define DEFAULT_MEM_SIZE	(32*SZ_1M)
 
 static struct vframe_s *vmjpeg_vf_peek(void *);
 static struct vframe_s *vmjpeg_vf_get(void *);
@@ -127,7 +132,7 @@ struct vdec_mjpeg_hw_s {
 	u32 dec_result;
 	unsigned long buf_start;
 	u32 buf_size;
-
+	void *mm_blk_handle;
 	struct dec_sysinfo vmjpeg_amstream_dec_info;
 
 	struct vframe_chunk_s *chunk;
@@ -269,15 +274,15 @@ static int vmjpeg_vf_states(struct vframe_states *states, void *op_arg)
 	return 0;
 }
 
-static int vmjpeg_dec_status(struct vdec_s *vdec, struct vdec_status *vstatus)
+static int vmjpeg_dec_status(struct vdec_s *vdec, struct vdec_info *vstatus)
 {
 	struct vdec_mjpeg_hw_s *hw = (struct vdec_mjpeg_hw_s *)vdec->private;
-	vstatus->width = hw->frame_width;
-	vstatus->height = hw->frame_height;
+	vstatus->frame_width = hw->frame_width;
+	vstatus->frame_height = hw->frame_height;
 	if (0 != hw->frame_dur)
-		vstatus->fps = 96000 / hw->frame_dur;
+		vstatus->frame_rate = 96000 / hw->frame_dur;
 	else
-		vstatus->fps = 96000;
+		vstatus->frame_rate = 96000;
 	vstatus->error_count = 0;
 	vstatus->status = hw->stat;
 
@@ -287,12 +292,12 @@ static int vmjpeg_dec_status(struct vdec_s *vdec, struct vdec_status *vstatus)
 /****************************************/
 static void vmjpeg_canvas_init(struct vdec_s *vdec)
 {
-	int i;
+	int i, ret;
 	u32 canvas_width, canvas_height;
 	u32 decbuf_size, decbuf_y_size, decbuf_uv_size;
+	unsigned long buf_start, addr;
 	struct vdec_mjpeg_hw_s *hw =
 		(struct vdec_mjpeg_hw_s *)vdec->private;
-	ulong addr;
 
 	canvas_width = 1920;
 	canvas_height = 1088;
@@ -304,24 +309,16 @@ static void vmjpeg_canvas_init(struct vdec_s *vdec)
 		int canvas;
 
 		canvas = vdec->get_canvas(i, 3);
-		if (hw->buffer_spec[i].cma_alloc_count == 0) {
-			hw->buffer_spec[i].cma_alloc_count =
-				PAGE_ALIGN(decbuf_size) / PAGE_SIZE;
-			hw->buffer_spec[i].cma_alloc_addr =
-				codec_mm_alloc_for_dma(MEM_NAME,
-					hw->buffer_spec[i].cma_alloc_count,
-					16, CODEC_MM_FLAGS_FOR_VDECODER);
-		}
 
-		if (!hw->buffer_spec[i].cma_alloc_addr) {
-			pr_err("CMA alloc failed, request buf size 0x%lx\n",
-				hw->buffer_spec[i].cma_alloc_count * PAGE_SIZE);
-			hw->buffer_spec[i].cma_alloc_count = 0;
-			break;
+		ret = decoder_bmmu_box_alloc_buf_phy(hw->mm_blk_handle, i,
+				decbuf_size, DRIVER_NAME, &buf_start);
+		if (ret < 0) {
+			pr_err("CMA alloc failed! size 0x%d  idx %d\n",
+				decbuf_size, i);
+			return;
 		}
 
-		hw->buffer_spec[i].buf_adr =
-			hw->buffer_spec[i].cma_alloc_addr;
+		hw->buffer_spec[i].buf_adr = buf_start;
 		addr = hw->buffer_spec[i].buf_adr;
 
 		hw->buffer_spec[i].y_addr = addr;
@@ -455,11 +452,11 @@ static void init_scaler(void)
 	WRITE_VREG(DOS_SW_RESET0, (1 << 10));
 	WRITE_VREG(DOS_SW_RESET0, 0);
 #else
-	WRITE_MPEG_REG(RESET2_REGISTER, RESET_PSCALE);
+	WRITE_RESET_REG(RESET2_REGISTER, RESET_PSCALE);
 #endif
-	READ_MPEG_REG(RESET2_REGISTER);
-	READ_MPEG_REG(RESET2_REGISTER);
-	READ_MPEG_REG(RESET2_REGISTER);
+	READ_RESET_REG(RESET2_REGISTER);
+	READ_RESET_REG(RESET2_REGISTER);
+	READ_RESET_REG(RESET2_REGISTER);
 
 	WRITE_VREG(PSCALE_RST, 0x7);
 	WRITE_VREG(PSCALE_RST, 0x0);
@@ -522,6 +519,20 @@ static s32 vmjpeg_init(struct vdec_s *vdec)
 		kfifo_put(&hw->newframe_q, vf);
 	}
 
+	if (hw->mm_blk_handle) {
+		decoder_bmmu_box_free(hw->mm_blk_handle);
+		hw->mm_blk_handle = NULL;
+	}
+
+	hw->mm_blk_handle = decoder_bmmu_box_alloc_box(
+		DRIVER_NAME,
+		0,
+		MAX_BMMU_BUFFER_NUM,
+		4 + PAGE_SHIFT,
+		CODEC_MM_FLAGS_CMA_CLEAR |
+		CODEC_MM_FLAGS_FOR_VDECODER);
+
+
 	INIT_WORK(&hw->work, vmjpeg_work);
 
 	return 0;
@@ -626,7 +637,6 @@ static int amvdec_mjpeg_probe(struct platform_device *pdev)
 	pdata->run_ready = run_ready;
 	pdata->irq_handler = vmjpeg_isr;
 
-	pdata->id = pdev->id;
 
 	if (pdata->use_vfm_path)
 		snprintf(pdata->vf_provider_name, VDEC_PROVIDER_NAME_SIZE,
@@ -641,8 +651,6 @@ static int amvdec_mjpeg_probe(struct platform_device *pdev)
 	platform_set_drvdata(pdev, pdata);
 
 	hw->platform_dev = pdev;
-	hw->buf_start = pdata->mem_start;
-	hw->buf_size = pdata->mem_end - pdata->mem_start + 1;
 
 	if (pdata->sys_info)
 		hw->vmjpeg_amstream_dec_info = *pdata->sys_info;
@@ -660,19 +668,13 @@ static int amvdec_mjpeg_remove(struct platform_device *pdev)
 	struct vdec_mjpeg_hw_s *hw =
 		(struct vdec_mjpeg_hw_s *)
 		(((struct vdec_s *)(platform_get_drvdata(pdev)))->private);
-	int i;
 
-	for (i = 0; i < DECODE_BUFFER_NUM_MAX; i++) {
-		if (hw->buffer_spec[i].cma_alloc_addr) {
-			pr_info("codec_mm release buffer_spec[%d], 0x%lx\n", i,
-				hw->buffer_spec[i].cma_alloc_addr);
-			codec_mm_free_for_dma(MEM_NAME,
-				hw->buffer_spec[i].cma_alloc_addr);
-			hw->buffer_spec[i].cma_alloc_count = 0;
-		}
-	}
 
 	cancel_work_sync(&hw->work);
+	if (hw->mm_blk_handle) {
+		decoder_bmmu_box_free(hw->mm_blk_handle);
+		hw->mm_blk_handle = NULL;
+	}
 
 	vdec_set_status(hw_to_vdec(hw), VDEC_STATUS_DISCONNECTED);
 
diff --git a/drivers/frame_provider/decoder/mpeg12/vmpeg12.c b/drivers/frame_provider/decoder/mpeg12/vmpeg12.c
index 1d15e11..dd1ebb5 100644
--- a/drivers/frame_provider/decoder/mpeg12/vmpeg12.c
+++ b/drivers/frame_provider/decoder/mpeg12/vmpeg12.c
@@ -37,6 +37,9 @@
 #include "vmpeg12.h"
 #include <linux/amlogic/media/registers/register.h>
 #include "../../../stream_input/amports/amports_priv.h"
+#include "../utils/decoder_mmu_box.h"
+#include "../utils/decoder_bmmu_box.h"
+#include <linux/amlogic/media/codec_mm/configs.h>
 
 #ifdef CONFIG_AM_VDEC_MPEG12_LOG
 #define AMLOG
@@ -83,10 +86,14 @@ MODULE_AMLOG(LOG_LEVEL_ERROR, 0, LOG_LEVEL_DESC, LOG_DEFAULT_MASK_DESC);
 
 #define SEQINFO_EXT_AVAILABLE   0x80000000
 #define SEQINFO_PROG            0x00010000
+#define CCBUF_SIZE      (5*1024)
 
 #define VF_POOL_SIZE        32
 #define DECODE_BUFFER_NUM_MAX 8
 #define PUT_INTERVAL        (HZ/100)
+#define WORKSPACE_SIZE		(2*SZ_64K)
+#define MAX_BMMU_BUFFER_NUM (DECODE_BUFFER_NUM_MAX + 1)
+
 
 #define INCPTR(p) ptr_atomic_wrap_inc(&p)
 
@@ -103,7 +110,7 @@ MODULE_AMLOG(LOG_LEVEL_ERROR, 0, LOG_LEVEL_DESC, LOG_DEFAULT_MASK_DESC);
 #if 1/* MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6 */
 #define NV21
 #endif
-#define CCBUF_SIZE      (5*1024)
+
 
 enum {
 	FRAME_REPEAT_TOP,
@@ -117,7 +124,7 @@ static void vmpeg_vf_put(struct vframe_s *, void *);
 static int vmpeg_vf_states(struct vframe_states *states, void *);
 static int vmpeg_event_cb(int type, void *data, void *private_data);
 
-static void vmpeg12_prot_init(void);
+static int vmpeg12_prot_init(void);
 static void vmpeg12_local_init(void);
 
 static const char vmpeg12_dec_id[] = "vmpeg12-dev";
@@ -129,7 +136,7 @@ static const struct vframe_operations_s vmpeg_vf_provider = {
 	.event_cb = vmpeg_event_cb,
 	.vf_states = vmpeg_vf_states,
 };
-
+static void *mm_blk_handle;
 static struct vframe_provider_s vmpeg_vf_prov;
 
 static DECLARE_KFIFO(newframe_q, struct vframe_s *, VF_POOL_SIZE);
@@ -137,8 +144,8 @@ static DECLARE_KFIFO(display_q, struct vframe_s *, VF_POOL_SIZE);
 static DECLARE_KFIFO(recycle_q, struct vframe_s *, VF_POOL_SIZE);
 
 static const u32 frame_rate_tab[16] = {
-	96000 / 30, 96000 / 24, 96000 / 24, 96000 / 25,
-	96000 / 30, 96000 / 30, 96000 / 50, 96000 / 60,
+	96000 / 30, 96000000 / 23976, 96000 / 24, 96000 / 25,
+	9600000 / 2997, 96000 / 30, 96000 / 50, 9600000 / 5994,
 	96000 / 60,
 	/* > 8 reserved, use 24 */
 	96000 / 24, 96000 / 24, 96000 / 24, 96000 / 24,
@@ -154,16 +161,20 @@ static u32 frame_width, frame_height, frame_dur, frame_prog;
 static u32 saved_resolution;
 static struct timer_list recycle_timer;
 static u32 stat;
-static unsigned long buf_start;
-static u32 buf_size, ccbuf_phyAddress;
+static u32 buf_size = 32 * 1024 * 1024;
+static u32 ccbuf_phyAddress;
 static void *ccbuf_phyAddress_virt;
 static int ccbuf_phyAddress_is_remaped_nocache;
+static u32 lastpts;
+static u32 fr_hint_status;
+
 
 static DEFINE_SPINLOCK(lock);
 
 static u32 frame_rpt_state;
 
 static struct dec_sysinfo vmpeg12_amstream_dec_info;
+static struct vdec_info *gvs;
 
 /* for error handling */
 static s32 frame_force_skip_flag;
@@ -171,6 +182,10 @@ static s32 error_frame_skip_level;
 static s32 wait_buffer_counter;
 static u32 first_i_frame_ready;
 
+static struct work_struct userdata_push_work;
+static struct work_struct notify_work;
+static struct work_struct reset_work;
+
 static inline int pool_index(struct vframe_s *vf)
 {
 	if ((vf >= &vfpool[0]) && (vf <= &vfpool[VF_POOL_SIZE - 1]))
@@ -221,10 +236,13 @@ static void set_frame_info(struct vframe_s *vf)
 	if (frame_dur > 0)
 		vf->duration = frame_dur;
 	else {
-		vf->duration = frame_dur =
-			frame_rate_tab[(READ_VREG(MREG_SEQ_INFO) >> 4) & 0xf];
+		int index = (READ_VREG(MREG_SEQ_INFO) >> 4) & 0xf;
+		vf->duration = frame_dur = frame_rate_tab[index];
+		schedule_work(&notify_work);
 	}
 
+	gvs->frame_dur = vf->duration;
+
 	ar_bits = READ_VREG(MREG_SEQ_INFO) & 0xf;
 
 	if (ar_bits == 0x2)
@@ -266,6 +284,42 @@ static bool error_skip(u32 info, struct vframe_s *vf)
 	return false;
 }
 
+static void userdata_push_do_work(struct work_struct *work)
+{
+	u32 reg;
+
+	struct userdata_poc_info_t user_data_poc;
+
+	user_data_poc.poc_info = 0;
+	user_data_poc.poc_number = 0;
+	reg = READ_VREG(MREG_BUFFEROUT);
+
+	if (!ccbuf_phyAddress_is_remaped_nocache &&
+		ccbuf_phyAddress &&
+		ccbuf_phyAddress_virt) {
+		codec_mm_dma_flush(
+			ccbuf_phyAddress_virt,
+			CCBUF_SIZE,
+			DMA_FROM_DEVICE);
+	}
+	wakeup_userdata_poll(user_data_poc,
+		reg & 0xffff,
+		(unsigned long)ccbuf_phyAddress_virt,
+		CCBUF_SIZE, 0);
+	WRITE_VREG(MREG_BUFFEROUT, 0);
+}
+
+static void vmpeg12_notify_work(struct work_struct *work)
+{
+	pr_info("frame duration changed %d\n", frame_dur);
+	if (fr_hint_status == VDEC_NEED_HINT) {
+		vf_notify_receiver(PROVIDER_NAME,
+			VFRAME_EVENT_PROVIDER_FR_HINT,
+			(void *)((unsigned long)frame_dur));
+		fr_hint_status = VDEC_HINTED;
+	}
+	return;
+}
 static irqreturn_t vmpeg12_isr(int irq, void *dev_id)
 {
 	u32 reg, info, seqinfo, offset, pts, pts_valid = 0;
@@ -277,22 +331,11 @@ static irqreturn_t vmpeg12_isr(int irq, void *dev_id)
 	reg = READ_VREG(MREG_BUFFEROUT);
 
 	if ((reg >> 16) == 0xfe) {
-		if (!ccbuf_phyAddress_is_remaped_nocache &&
-			ccbuf_phyAddress &&
-			ccbuf_phyAddress_virt) {
-			codec_mm_dma_flush(
-				ccbuf_phyAddress_virt,
-				CCBUF_SIZE,
-				DMA_FROM_DEVICE);
-		}
-		wakeup_userdata_poll(
-			reg & 0xffff,
-			(unsigned long)ccbuf_phyAddress_virt,
-			CCBUF_SIZE, 0);
-		WRITE_VREG(MREG_BUFFEROUT, 0);
+		schedule_work(&userdata_push_work);
 	} else if (reg) {
 		info = READ_VREG(MREG_PIC_INFO);
 		offset = READ_VREG(MREG_FRAME_OFFSET);
+		seqinfo = READ_VREG(MREG_SEQ_INFO);
 
 		if ((first_i_frame_ready == 0) &&
 			((info & PICINFO_TYPE_MASK) == PICINFO_TYPE_I) &&
@@ -306,9 +349,16 @@ static irqreturn_t vmpeg12_isr(int irq, void *dev_id)
 					PICINFO_TYPE_P)))
 			pts_valid = 1;
 
+		if (pts_valid && lastpts == pts)
+			pts_valid = 0;
+		if (pts_valid)
+			lastpts = pts;
 		/*if (frame_prog == 0) */
 		{
 			frame_prog = info & PICINFO_PROG;
+			if ((seqinfo & SEQINFO_EXT_AVAILABLE)
+				&& (!(seqinfo & SEQINFO_PROG)))
+				frame_prog = 0;
 		}
 
 		if ((dec_control &
@@ -382,6 +432,9 @@ static irqreturn_t vmpeg12_isr(int irq, void *dev_id)
 						vf->duration >> 1 : 0;
 			}
 
+			/*count info*/
+			vdec_count_info(gvs, info & PICINFO_ERROR, offset);
+
 			vf->duration += vf->duration_pulldown;
 			vf->canvas0Addr = vf->canvas1Addr =
 						index2canvas(index);
@@ -396,9 +449,14 @@ static irqreturn_t vmpeg12_isr(int irq, void *dev_id)
 				((first_i_frame_ready == 0)
 				 && ((PICINFO_TYPE_MASK & info) !=
 					 PICINFO_TYPE_I))) {
+				gvs->drop_frame_count++;
 				kfifo_put(&recycle_q,
 						  (const struct vframe_s *)vf);
 			} else {
+				vf->mem_handle =
+					decoder_bmmu_box_get_mem_handle(
+						mm_blk_handle,
+						index);
 				kfifo_put(&display_q,
 						  (const struct vframe_s *)vf);
 				vf_notify_receiver(PROVIDER_NAME,
@@ -418,7 +476,7 @@ static irqreturn_t vmpeg12_isr(int irq, void *dev_id)
 			/* to make DI easy. */
 			dec_control |= DEC_CONTROL_FLAG_FORCE_SEQ_INTERLACE;
 #endif
-
+#if 0
 			if (info & PICINFO_FRAME) {
 				frame_rpt_state =
 					(info & PICINFO_TOP_FIRST) ?
@@ -434,14 +492,18 @@ static irqreturn_t vmpeg12_isr(int irq, void *dev_id)
 				}
 				frame_rpt_state = FRAME_REPEAT_NONE;
 			}
-
+#else
+			frame_rpt_state = FRAME_REPEAT_NONE;
+#endif
 			if (kfifo_get(&newframe_q, &vf) == 0) {
 				pr_info
 				("fatal error, no available buffer slot.");
 				return IRQ_HANDLED;
 			}
-
-			vfbuf_use[index] = 2;
+			if (info & PICINFO_RPT_FIRST)
+				vfbuf_use[index] = 3;
+			else
+				vfbuf_use[index] = 2;
 
 			set_frame_info(vf);
 			vf->signal_type = 0;
@@ -468,9 +530,14 @@ static irqreturn_t vmpeg12_isr(int irq, void *dev_id)
 				((first_i_frame_ready == 0)
 				 && ((PICINFO_TYPE_MASK & info) !=
 					 PICINFO_TYPE_I))) {
+				gvs->drop_frame_count++;
 				kfifo_put(&recycle_q,
 						  (const struct vframe_s *)vf);
 			} else {
+				vf->mem_handle =
+					decoder_bmmu_box_get_mem_handle(
+						mm_blk_handle,
+						index);
 				kfifo_put(&display_q,
 						  (const struct vframe_s *)vf);
 				vf_notify_receiver(PROVIDER_NAME,
@@ -505,21 +572,69 @@ static irqreturn_t vmpeg12_isr(int irq, void *dev_id)
 			vf->pts_us64 = 0;
 			vf->type_original = vf->type;
 
+			/*count info*/
+			vdec_count_info(gvs, info & PICINFO_ERROR, offset);
+
 			if ((error_skip(info, vf)) ||
 				((first_i_frame_ready == 0)
 				 && ((PICINFO_TYPE_MASK & info) !=
 					PICINFO_TYPE_I))) {
+				gvs->drop_frame_count++;
 				kfifo_put(&recycle_q,
 					(const struct vframe_s *)vf);
 			} else {
+				vf->mem_handle =
+					decoder_bmmu_box_get_mem_handle(
+						mm_blk_handle,
+						index);
 				kfifo_put(&display_q,
 					(const struct vframe_s *)vf);
 				vf_notify_receiver(PROVIDER_NAME,
 					VFRAME_EVENT_PROVIDER_VFRAME_READY,
 					NULL);
 			}
-		}
 
+			if (info & PICINFO_RPT_FIRST) {
+				if (kfifo_get(&newframe_q, &vf) == 0) {
+					pr_info("error, no available buffer slot.");
+					return IRQ_HANDLED;
+				}
+
+				set_frame_info(vf);
+
+				vf->index = index;
+				vf->type = (first_field_type ==
+						VIDTYPE_INTERLACE_TOP) ?
+						VIDTYPE_INTERLACE_TOP :
+						VIDTYPE_INTERLACE_BOTTOM;
+#ifdef NV21
+				vf->type |= VIDTYPE_VIU_NV21;
+#endif
+				vf->duration >>= 1;
+				vf->duration_pulldown =
+					(info & PICINFO_RPT_FIRST) ?
+						vf->duration >> 1 : 0;
+				vf->duration += vf->duration_pulldown;
+				vf->orientation = 0;
+				vf->canvas0Addr = vf->canvas1Addr =
+							index2canvas(index);
+				vf->pts = 0;
+				vf->pts_us64 = 0;
+				if ((error_skip(info, vf)) ||
+					((first_i_frame_ready == 0)
+						&& ((PICINFO_TYPE_MASK & info)
+							!= PICINFO_TYPE_I))) {
+					kfifo_put(&recycle_q,
+					(const struct vframe_s *)vf);
+				} else {
+					kfifo_put(&display_q,
+						(const struct vframe_s *)vf);
+					vf_notify_receiver(PROVIDER_NAME,
+					VFRAME_EVENT_PROVIDER_VFRAME_READY,
+						NULL);
+				}
+			}
+		}
 		WRITE_VREG(MREG_BUFFEROUT, 0);
 	}
 
@@ -598,6 +713,21 @@ static void vmpeg12_ppmgr_reset(void)
 }
 #endif
 
+static void reset_do_work(struct work_struct *work)
+{
+	amvdec_stop();
+
+#ifdef CONFIG_AMLOGIC_POST_PROCESS_MANAGER
+	vmpeg12_ppmgr_reset();
+#else
+	vf_light_unreg_provider(&vmpeg_vf_prov);
+	vmpeg12_local_init();
+	vf_reg_provider(&vmpeg_vf_prov);
+#endif
+	vmpeg12_prot_init();
+	amvdec_start();
+}
+
 static void vmpeg_put_timer_func(unsigned long arg)
 {
 	struct timer_list *timer = (struct timer_list *)arg;
@@ -630,18 +760,7 @@ static void vmpeg_put_timer_func(unsigned long arg)
 
 	if (fatal_reset && (kfifo_is_empty(&display_q))) {
 		pr_info("$$$$decoder is waiting for buffer or fatal reset.\n");
-
-		amvdec_stop();
-
-#ifdef CONFIG_AMLOGIC_POST_PROCESS_MANAGER
-		vmpeg12_ppmgr_reset();
-#else
-		vf_light_unreg_provider(&vmpeg_vf_prov);
-		vmpeg12_local_init();
-		vf_reg_provider(&vmpeg_vf_prov);
-#endif
-		vmpeg12_prot_init();
-		amvdec_start();
+		schedule_work(&reset_work);
 	}
 
 	while (!kfifo_is_empty(&recycle_q) && (READ_VREG(MREG_BUFFERIN) == 0)) {
@@ -673,27 +792,49 @@ static void vmpeg_put_timer_func(unsigned long arg)
 	add_timer(timer);
 }
 
-int vmpeg12_dec_status(struct vdec_s *vdec, struct vdec_status *vstatus)
+int vmpeg12_dec_status(struct vdec_s *vdec, struct vdec_info *vstatus)
 {
-	vstatus->width = frame_width;
-	vstatus->height = frame_height;
+	vstatus->frame_width = frame_width;
+	vstatus->frame_height = frame_height;
 	if (frame_dur != 0)
-		vstatus->fps = 96000 / frame_dur;
+		vstatus->frame_rate = 96000 / frame_dur;
 	else
-		vstatus->fps = 96000;
+		vstatus->frame_rate = -1;
 	vstatus->error_count = READ_VREG(AV_SCRATCH_C);
 	vstatus->status = stat;
+	vstatus->bit_rate = gvs->bit_rate;
+	vstatus->frame_dur = frame_dur;
+	vstatus->frame_data = gvs->frame_data;
+	vstatus->total_data = gvs->total_data;
+	vstatus->frame_count = gvs->frame_count;
+	vstatus->error_frame_count = gvs->error_frame_count;
+	vstatus->drop_frame_count = gvs->drop_frame_count;
+	vstatus->total_data = gvs->total_data;
+	vstatus->samp_cnt = gvs->samp_cnt;
+	vstatus->offset = gvs->offset;
+	snprintf(vstatus->vdec_name, sizeof(vstatus->vdec_name),
+		"%s", DRIVER_NAME);
+
+	return 0;
+}
 
+static int vmpeg12_vdec_info_init(void)
+{
+	gvs = kzalloc(sizeof(struct vdec_info), GFP_KERNEL);
+	if (NULL == gvs) {
+		pr_info("the struct of vdec status malloc failed.\n");
+		return -ENOMEM;
+	}
 	return 0;
 }
 
 /****************************************/
-static void vmpeg12_canvas_init(void)
+static int vmpeg12_canvas_init(void)
 {
-	int i;
+	int i, ret;
 	u32 canvas_width, canvas_height;
 	u32 decbuf_size, decbuf_y_size, decbuf_uv_size;
-	u32 disp_addr = 0xffffffff;
+	static unsigned long buf_start;
 
 	if (buf_size <= 0x00400000) {
 		/* SD only */
@@ -711,65 +852,58 @@ static void vmpeg12_canvas_init(void)
 		decbuf_size = 0x300000;
 	}
 
-	if (is_vpp_postblend()) {
-		struct canvas_s cur_canvas;
 
-		canvas_read((READ_VCBUS_REG(VD1_IF0_CANVAS0) & 0xff),
-					&cur_canvas);
-		disp_addr = (cur_canvas.addr + 7) >> 3;
-	}
+	for (i = 0; i < MAX_BMMU_BUFFER_NUM; i++) {
+
+		if (i == (MAX_BMMU_BUFFER_NUM - 1)) /* workspace mem */
+			decbuf_size = WORKSPACE_SIZE;
+
+		ret = decoder_bmmu_box_alloc_buf_phy(mm_blk_handle, i,
+				decbuf_size, DRIVER_NAME, &buf_start);
+		if (ret < 0)
+			return ret;
+
+		if (i == (MAX_BMMU_BUFFER_NUM - 1)) {
+
+			WRITE_VREG(MREG_CO_MV_START, (buf_start + CCBUF_SIZE));
+			if (!ccbuf_phyAddress) {
+				ccbuf_phyAddress
+				= (u32)buf_start;
+
+				ccbuf_phyAddress_virt
+				= codec_mm_phys_to_virt(ccbuf_phyAddress);
+				if (!ccbuf_phyAddress_virt) {
+					ccbuf_phyAddress_virt
+					= ioremap_nocache(
+					ccbuf_phyAddress,
+					CCBUF_SIZE);
+					ccbuf_phyAddress_is_remaped_nocache = 1;
+				}
+			}
 
-	for (i = 0; i < 8; i++) {
-		if (((buf_start + i * decbuf_size + 7) >> 3) == disp_addr) {
-#ifdef NV21
-			canvas_config(2 * i + 0,
-				buf_start + 8 * decbuf_size,
-				canvas_width, canvas_height,
-				CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_32X32);
-			canvas_config(2 * i + 1,
-				buf_start + 8 * decbuf_size +
-				decbuf_y_size, canvas_width,
-				canvas_height / 2, CANVAS_ADDR_NOWRAP,
-				CANVAS_BLKMODE_32X32);
-#else
-			canvas_config(3 * i + 0,
-				buf_start + 8 * decbuf_size,
-				canvas_width, canvas_height,
-				CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_32X32);
-			canvas_config(3 * i + 1,
-				buf_start + 8 * decbuf_size +
-				decbuf_y_size, canvas_width / 2,
-				canvas_height / 2, CANVAS_ADDR_NOWRAP,
-						  CANVAS_BLKMODE_32X32);
-			canvas_config(3 * i + 2,
-			buf_start + 8 * decbuf_size +
-			decbuf_y_size + decbuf_uv_size,
-			canvas_width / 2, canvas_height / 2,
-			CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_32X32);
-#endif
 		} else {
 #ifdef NV21
 			canvas_config(2 * i + 0,
-				buf_start + i * decbuf_size,
+				buf_start,
 				canvas_width, canvas_height,
 				CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_32X32);
 			canvas_config(2 * i + 1,
-				buf_start + i * decbuf_size +
+				buf_start +
 				decbuf_y_size, canvas_width,
 				canvas_height / 2, CANVAS_ADDR_NOWRAP,
 				CANVAS_BLKMODE_32X32);
 #else
 			canvas_config(3 * i + 0,
-				buf_start + i * decbuf_size,
+				buf_start,
 				canvas_width, canvas_height,
 				CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_32X32);
 			canvas_config(3 * i + 1,
-				buf_start + i * decbuf_size +
+				buf_start +
 				decbuf_y_size, canvas_width / 2,
 				canvas_height / 2, CANVAS_ADDR_NOWRAP,
 				CANVAS_BLKMODE_32X32);
 			canvas_config(3 * i + 2,
-				buf_start + i * decbuf_size +
+				buf_start +
 				decbuf_y_size + decbuf_uv_size,
 				canvas_width / 2, canvas_height / 2,
 				CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_32X32);
@@ -777,23 +911,12 @@ static void vmpeg12_canvas_init(void)
 		}
 	}
 
-	WRITE_VREG(MREG_CO_MV_START,
-		buf_start + 9 * decbuf_size + CCBUF_SIZE);
-	if (!ccbuf_phyAddress) {
-		ccbuf_phyAddress = (u32)(buf_start + 9 * decbuf_size);
-		ccbuf_phyAddress_virt = codec_mm_phys_to_virt(ccbuf_phyAddress);
-		if (!ccbuf_phyAddress_virt) {
-			ccbuf_phyAddress_virt = ioremap_nocache(
-				ccbuf_phyAddress,
-				CCBUF_SIZE);
-			ccbuf_phyAddress_is_remaped_nocache = 1;
-		}
-	}
-
+	return 0;
 }
 
-static void vmpeg12_prot_init(void)
+static int vmpeg12_prot_init(void)
 {
+	int ret;
 	if (get_cpu_type() >= MESON_CPU_MAJOR_ID_M6) {
 		int save_reg = READ_VREG(POWER_CTL_VLD);
 
@@ -823,9 +946,9 @@ static void vmpeg12_prot_init(void)
 		WRITE_VREG(POWER_CTL_VLD, save_reg);
 
 	} else
-		WRITE_MPEG_REG(RESET0_REGISTER, RESET_IQIDCT | RESET_MC);
+		WRITE_RESET_REG(RESET0_REGISTER, RESET_IQIDCT | RESET_MC);
 
-	vmpeg12_canvas_init();
+	ret = vmpeg12_canvas_init();
 
 #ifdef NV21
 	WRITE_VREG(AV_SCRATCH_0, 0x010100);
@@ -873,6 +996,7 @@ static void vmpeg12_prot_init(void)
 #ifdef NV21
 	SET_VREG_MASK(MDEC_PIC_DC_CTRL, 1 << 17);
 #endif
+	return ret;
 }
 
 static void vmpeg12_local_init(void)
@@ -900,6 +1024,19 @@ static void vmpeg12_local_init(void)
 	for (i = 0; i < DECODE_BUFFER_NUM_MAX; i++)
 		vfbuf_use[i] = 0;
 
+	if (mm_blk_handle) {
+		decoder_bmmu_box_free(mm_blk_handle);
+		mm_blk_handle = NULL;
+	}
+
+		mm_blk_handle = decoder_bmmu_box_alloc_box(
+			DRIVER_NAME,
+			0,
+			MAX_BMMU_BUFFER_NUM,
+			4 + PAGE_SHIFT,
+			CODEC_MM_FLAGS_CMA_CLEAR |
+			CODEC_MM_FLAGS_FOR_VDECODER);
+
 
 	frame_width = frame_height = frame_dur = frame_prog = 0;
 	frame_force_skip_flag = 0;
@@ -964,9 +1101,15 @@ static s32 vmpeg12_init(void)
 					 NULL);
 	vf_reg_provider(&vmpeg_vf_prov);
 #endif
-
-	vf_notify_receiver(PROVIDER_NAME, VFRAME_EVENT_PROVIDER_FR_HINT,
-		(void *)((unsigned long)vmpeg12_amstream_dec_info.rate));
+	if (vmpeg12_amstream_dec_info.rate != 0) {
+		vf_notify_receiver(PROVIDER_NAME,
+			VFRAME_EVENT_PROVIDER_FR_HINT,
+			(void *)
+			((unsigned long)
+			vmpeg12_amstream_dec_info.rate));
+		fr_hint_status = VDEC_HINTED;
+	} else
+		fr_hint_status = VDEC_NEED_HINT;
 
 	stat |= STAT_VF_HOOK;
 
@@ -1000,16 +1143,20 @@ static int amvdec_mpeg12_probe(struct platform_device *pdev)
 	if (pdata->sys_info)
 		vmpeg12_amstream_dec_info = *pdata->sys_info;
 
-	buf_start = pdata->mem_start;
-	buf_size = pdata->mem_end - pdata->mem_start + 1;
-
 	pdata->dec_status = vmpeg12_dec_status;
 
+	vmpeg12_vdec_info_init();
+
 	if (vmpeg12_init() < 0) {
 		amlog_level(LOG_LEVEL_ERROR, "amvdec_mpeg12 init failed.\n");
+		kfree(gvs);
+		gvs = NULL;
 
 		return -ENODEV;
 	}
+	INIT_WORK(&userdata_push_work, userdata_push_do_work);
+	INIT_WORK(&notify_work, vmpeg12_notify_work);
+	INIT_WORK(&reset_work, reset_do_work);
 
 	amlog_level(LOG_LEVEL_INFO, "amvdec_mpeg12 probe end.\n");
 
@@ -1018,6 +1165,10 @@ static int amvdec_mpeg12_probe(struct platform_device *pdev)
 
 static int amvdec_mpeg12_remove(struct platform_device *pdev)
 {
+	cancel_work_sync(&userdata_push_work);
+	cancel_work_sync(&notify_work);
+	cancel_work_sync(&reset_work);
+
 	if (stat & STAT_VDEC_RUN) {
 		amvdec_stop();
 		stat &= ~STAT_VDEC_RUN;
@@ -1034,8 +1185,10 @@ static int amvdec_mpeg12_remove(struct platform_device *pdev)
 	}
 
 	if (stat & STAT_VF_HOOK) {
-		vf_notify_receiver(PROVIDER_NAME,
-			VFRAME_EVENT_PROVIDER_FR_END_HINT, NULL);
+		if (fr_hint_status == VDEC_HINTED)
+			vf_notify_receiver(PROVIDER_NAME,
+				VFRAME_EVENT_PROVIDER_FR_END_HINT, NULL);
+		fr_hint_status = VDEC_NO_NEED_HINT;
 
 		vf_unreg_provider(&vmpeg_vf_prov);
 		stat &= ~STAT_VF_HOOK;
@@ -1048,8 +1201,16 @@ static int amvdec_mpeg12_remove(struct platform_device *pdev)
 	ccbuf_phyAddress_virt = NULL;
 	ccbuf_phyAddress = 0;
 	ccbuf_phyAddress_is_remaped_nocache = 0;
+
+	if (mm_blk_handle) {
+		decoder_bmmu_box_free(mm_blk_handle);
+		mm_blk_handle = NULL;
+	}
 	amlog_level(LOG_LEVEL_INFO, "amvdec_mpeg12 remove.\n");
 
+	kfree(gvs);
+	gvs = NULL;
+
 	return 0;
 }
 
@@ -1072,6 +1233,15 @@ static struct codec_profile_t amvdec_mpeg12_profile = {
 	.profile = ""
 };
 
+
+static struct mconfig mpeg12_configs[] = {
+	MC_PU32("stat", &stat),
+	MC_PU32("dec_control", &dec_control),
+	MC_PU32("error_frame_skip_level", &error_frame_skip_level),
+};
+static struct mconfig_node mpeg12_node;
+
+
 static int __init amvdec_mpeg12_driver_init_module(void)
 {
 	amlog_level(LOG_LEVEL_INFO, "amvdec_mpeg12 module init\n");
@@ -1082,6 +1252,8 @@ static int __init amvdec_mpeg12_driver_init_module(void)
 		return -ENODEV;
 	}
 	vcodec_profile_register(&amvdec_mpeg12_profile);
+	INIT_REG_NODE_CONFIGS("media.decoder", &mpeg12_node,
+		"mpeg12", mpeg12_configs, CONFIG_FOR_RW);
 	return 0;
 }
 
@@ -1093,9 +1265,6 @@ static void __exit amvdec_mpeg12_driver_remove_module(void)
 }
 
 /****************************************/
-
-module_param(stat, uint, 0664);
-MODULE_PARM_DESC(stat, "\n amvdec_mpeg12 stat\n");
 module_param(dec_control, uint, 0664);
 MODULE_PARM_DESC(dec_control, "\n amvmpeg12 decoder control\n");
 module_param(error_frame_skip_level, uint, 0664);
diff --git a/drivers/frame_provider/decoder/mpeg4/vmpeg4.c b/drivers/frame_provider/decoder/mpeg4/vmpeg4.c
index 1f1541a..a157c49 100644
--- a/drivers/frame_provider/decoder/mpeg4/vmpeg4.c
+++ b/drivers/frame_provider/decoder/mpeg4/vmpeg4.c
@@ -35,7 +35,10 @@
 #include "vmpeg4.h"
 #include <linux/amlogic/media/registers/register.h>
 #include "../../../stream_input/amports/amports_priv.h"
-
+#include "../utils/decoder_mmu_box.h"
+#include "../utils/decoder_bmmu_box.h"
+#include <linux/amlogic/media/codec_mm/codec_mm.h>
+#include <linux/amlogic/media/codec_mm/configs.h>
 
 /* #define CONFIG_AM_VDEC_MPEG4_LOG */
 #ifdef CONFIG_AM_VDEC_MPEG4_LOG
@@ -100,6 +103,10 @@ MODULE_AMLOG(LOG_LEVEL_ERROR, 0, LOG_LEVEL_DESC, LOG_DEFAULT_MASK_DESC);
 #define VF_POOL_SIZE          32
 #define DECODE_BUFFER_NUM_MAX 8
 #define PUT_INTERVAL        (HZ/100)
+#define WORKSPACE_SIZE		(1 * SZ_1M)
+#define MAX_BMMU_BUFFER_NUM	(DECODE_BUFFER_NUM_MAX + 1)
+#define DCAC_BUFF_START_IP	0x02b00000
+
 
 #define RATE_DETECT_COUNT   5
 #define DURATION_UNIT       96000
@@ -113,7 +120,7 @@ static void vmpeg_vf_put(struct vframe_s *, void *);
 static int vmpeg_vf_states(struct vframe_states *states, void *);
 static int vmpeg_event_cb(int type, void *data, void *private_data);
 
-static void vmpeg4_prot_init(void);
+static int vmpeg4_prot_init(void);
 static void vmpeg4_local_init(void);
 
 static const char vmpeg4_dec_id[] = "vmpeg4-dev";
@@ -130,7 +137,7 @@ static const struct vframe_operations_s vmpeg_vf_provider = {
 	.event_cb = vmpeg_event_cb,
 	.vf_states = vmpeg_vf_states,
 };
-
+static void *mm_blk_handle;
 static struct vframe_provider_s vmpeg_vf_prov;
 
 static DECLARE_KFIFO(newframe_q, struct vframe_s *, VF_POOL_SIZE);
@@ -143,23 +150,29 @@ static u32 frame_width, frame_height, frame_dur, frame_prog;
 static u32 saved_resolution;
 static struct timer_list recycle_timer;
 static u32 stat;
-static unsigned long buf_start;
-static u32 buf_size, buf_offset;
+static u32 buf_size = 32 * 1024 * 1024;
+static u32 buf_offset;
 static u32 vmpeg4_ratio;
 static u64 vmpeg4_ratio64;
 static u32 rate_detect;
 static u32 vmpeg4_rotation;
+static u32 fr_hint_status;
 
 static u32 total_frame;
 static u32 last_vop_time_inc, last_duration;
 static u32 last_anch_pts, vop_time_inc_since_last_anch,
 	   frame_num_since_last_anch;
 static u64 last_anch_pts_us64;
+static struct vdec_info *gvs;
 
 #ifdef CONFIG_AM_VDEC_MPEG4_LOG
 u32 pts_hit, pts_missed, pts_i_hit, pts_i_missed;
 #endif
 
+static struct work_struct reset_work;
+static struct work_struct notify_work;
+
+
 static DEFINE_SPINLOCK(lock);
 
 static struct dec_sysinfo vmpeg4_amstream_dec_info;
@@ -317,6 +330,10 @@ static irqreturn_t vmpeg4_isr(int irq, void *dev_id)
 					(rate >> 16) * DURATION_UNIT /
 					(rate & 0xffff);
 				duration = vmpeg4_amstream_dec_info.rate;
+				if (fr_hint_status == VDEC_NEED_HINT) {
+					schedule_work(&notify_work);
+					fr_hint_status = VDEC_HINTED;
+				}
 			} else if (rate_detect < RATE_DETECT_COUNT) {
 				if (vop_time_inc < last_vop_time_inc) {
 					duration =
@@ -463,6 +480,10 @@ static irqreturn_t vmpeg4_isr(int irq, void *dev_id)
 			set_aspect_ratio(vf, READ_VREG(MP4_PIC_RATIO));
 
 			vfbuf_use[buffer_index]++;
+			vf->mem_handle =
+				decoder_bmmu_box_get_mem_handle(
+					mm_blk_handle,
+					buffer_index);
 
 			kfifo_put(&display_q, (const struct vframe_s *)vf);
 
@@ -500,6 +521,10 @@ static irqreturn_t vmpeg4_isr(int irq, void *dev_id)
 			set_aspect_ratio(vf, READ_VREG(MP4_PIC_RATIO));
 
 			vfbuf_use[buffer_index]++;
+			vf->mem_handle =
+				decoder_bmmu_box_get_mem_handle(
+					mm_blk_handle,
+					buffer_index);
 
 			amlog_mask(LOG_MASK_PTS,
 			"[%s:%d] [inte] dur=0x%x rate=%d picture_type=%d\n",
@@ -548,6 +573,10 @@ static irqreturn_t vmpeg4_isr(int irq, void *dev_id)
 			vmpeg4_amstream_dec_info.rate, picture_type);
 
 			vfbuf_use[buffer_index]++;
+			vf->mem_handle =
+				decoder_bmmu_box_get_mem_handle(
+					mm_blk_handle,
+					buffer_index);
 
 			kfifo_put(&display_q, (const struct vframe_s *)vf);
 
@@ -561,6 +590,10 @@ static irqreturn_t vmpeg4_isr(int irq, void *dev_id)
 		WRITE_VREG(MREG_BUFFEROUT, 0);
 
 		last_vop_time_inc = vop_time_inc;
+
+		/*count info*/
+		gvs->frame_dur = duration;
+		vdec_count_info(gvs, 0, offset);
 	}
 
 	WRITE_VREG(ASSIST_MBOX1_CLR_REG, 1);
@@ -628,6 +661,35 @@ static int vmpeg_vf_states(struct vframe_states *states, void *op_arg)
 	return 0;
 }
 
+static void vmpeg4_notify_work(struct work_struct *work)
+{
+	pr_info("frame duration changed %d\n", vmpeg4_amstream_dec_info.rate);
+	vf_notify_receiver(PROVIDER_NAME,
+					VFRAME_EVENT_PROVIDER_FR_HINT,
+					(void *)
+					((unsigned long)
+					vmpeg4_amstream_dec_info.rate));
+	return;
+}
+
+static void reset_do_work(struct work_struct *work)
+{
+	unsigned long flags;
+
+	amvdec_stop();
+#ifndef CONFIG_AMLOGIC_POST_PROCESS_MANAGER
+	vf_light_unreg_provider(&vmpeg_vf_prov);
+#endif
+	spin_lock_irqsave(&lock, flags);
+	vmpeg4_local_init();
+	vmpeg4_prot_init();
+	spin_unlock_irqrestore(&lock, flags);
+#ifndef CONFIG_AMLOGIC_POST_PROCESS_MANAGER
+	vf_reg_provider(&vmpeg_vf_prov);
+#endif
+	amvdec_start();
+}
+
 static void vmpeg_put_timer_func(unsigned long arg)
 {
 	struct timer_list *timer = (struct timer_list *)arg;
@@ -652,20 +714,8 @@ static void vmpeg_put_timer_func(unsigned long arg)
 			frame_width, frame_height, fps);
 	}
 	if (READ_VREG(AV_SCRATCH_L)) {
-		unsigned long flags;
 		pr_info("mpeg4 fatal error happened,need reset    !!\n");
-		amvdec_stop();
-#ifndef CONFIG_AMLOGIC_POST_PROCESS_MANAGER
-		vf_light_unreg_provider(&vmpeg_vf_prov);
-#endif
-		spin_lock_irqsave(&lock, flags);
-		vmpeg4_local_init();
-		vmpeg4_prot_init();
-		spin_unlock_irqrestore(&lock, flags);
-#ifndef CONFIG_AMLOGIC_POST_PROCESS_MANAGER
-		vf_reg_provider(&vmpeg_vf_prov);
-#endif
-		amvdec_start();
+		schedule_work(&reset_work);
 	}
 
 
@@ -674,28 +724,50 @@ static void vmpeg_put_timer_func(unsigned long arg)
 	add_timer(timer);
 }
 
-int vmpeg4_dec_status(struct vdec_s *vdec, struct vdec_status *vstatus)
+int vmpeg4_dec_status(struct vdec_s *vdec, struct vdec_info *vstatus)
 {
-	vstatus->width = vmpeg4_amstream_dec_info.width;
-	vstatus->height = vmpeg4_amstream_dec_info.height;
+	vstatus->frame_width = vmpeg4_amstream_dec_info.width;
+	vstatus->frame_height = vmpeg4_amstream_dec_info.height;
 	if (0 != vmpeg4_amstream_dec_info.rate)
-		vstatus->fps = DURATION_UNIT / vmpeg4_amstream_dec_info.rate;
+		vstatus->frame_rate =
+			DURATION_UNIT / vmpeg4_amstream_dec_info.rate;
 	else
-		vstatus->fps = DURATION_UNIT;
+		vstatus->frame_rate = -1;
 	vstatus->error_count = READ_VREG(MP4_ERR_COUNT);
 	vstatus->status = stat;
+	vstatus->bit_rate = gvs->bit_rate;
+	vstatus->frame_dur = frame_dur;
+	vstatus->frame_data = gvs->frame_data;
+	vstatus->total_data = gvs->total_data;
+	vstatus->frame_count = gvs->frame_count;
+	vstatus->error_frame_count = gvs->error_frame_count;
+	vstatus->drop_frame_count = gvs->drop_frame_count;
+	vstatus->total_data = gvs->total_data;
+	vstatus->samp_cnt = gvs->samp_cnt;
+	vstatus->offset = gvs->offset;
+	snprintf(vstatus->vdec_name, sizeof(vstatus->vdec_name),
+		"%s", DRIVER_NAME);
 
 	return 0;
 }
 
+static int vmpeg4_vdec_info_init(void)
+{
+	gvs = kzalloc(sizeof(struct vdec_info), GFP_KERNEL);
+	if (NULL == gvs) {
+		pr_info("the struct of vdec status malloc failed.\n");
+		return -ENOMEM;
+	}
+	return 0;
+}
+
 /****************************************/
-static void vmpeg4_canvas_init(void)
+static int vmpeg4_canvas_init(void)
 {
-	int i;
+	int i, ret;
 	u32 canvas_width, canvas_height;
-	u32 decbuf_size, decbuf_y_size, decbuf_uv_size;
-	u32 disp_addr = 0xffffffff;
-	u32 buff_off = 0;
+	unsigned long buf_start;
+	u32 alloc_size, decbuf_size, decbuf_y_size, decbuf_uv_size;
 
 	if (buf_size <= 0x00400000) {
 		/* SD only */
@@ -741,79 +813,65 @@ static void vmpeg4_canvas_init(void)
 		}
 	}
 
-	if (is_vpp_postblend()) {
-		struct canvas_s cur_canvas;
+	for (i = 0; i < MAX_BMMU_BUFFER_NUM; i++) {
+		/* workspace mem */
+		if (i == (MAX_BMMU_BUFFER_NUM - 1))
+			alloc_size =  WORKSPACE_SIZE;
+		else
+			alloc_size = decbuf_size;
+
+		ret = decoder_bmmu_box_alloc_buf_phy(mm_blk_handle, i,
+				alloc_size, DRIVER_NAME, &buf_start);
+		if (ret < 0)
+			return ret;
+		if (i == (MAX_BMMU_BUFFER_NUM - 1)) {
+			buf_offset = buf_start - DCAC_BUFF_START_IP;
+			continue;
+		}
 
-		canvas_read((READ_VCBUS_REG(VD1_IF0_CANVAS0) & 0xff),
-					&cur_canvas);
-		disp_addr = (cur_canvas.addr + 7) >> 3;
-	}
 
-	for (i = 0; i < 8; i++) {
-		u32 one_buf_start = buf_start + buff_off;
-		if (((one_buf_start + 7) >> 3) == disp_addr) {
-			/*last disp buffer, to next..*/
-			buff_off += decbuf_size;
-			one_buf_start = buf_start + buff_off;
-			pr_info("one_buf_start %d,=== %x disp_addr %x",
-				i, one_buf_start, disp_addr);
-		}
-		if (buff_off < 0x02000000 &&
-			buff_off + decbuf_size > 0x01b00000){
-			/*0x01b00000 is references buffer.
-			to next 32M;*/
-			buff_off = 32 * SZ_1M;/*next 32M*/
-			one_buf_start = buf_start + buff_off;
-		}
-		if (buff_off + decbuf_size > buf_size) {
-			pr_err("ERROR::too small buffer for buf%d %d x%d ,size =%d\n",
-				i,
-				canvas_width,
-				canvas_height,
-				buf_size);
-		}
-		pr_debug("alloced buffer %d at %x,%d\n",
-				i, one_buf_start, decbuf_size);
 #ifdef NV21
 		canvas_config(2 * i + 0,
-			one_buf_start,
+			buf_start,
 			canvas_width, canvas_height,
 			CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_32X32);
 		canvas_config(2 * i + 1,
-			one_buf_start +
+			buf_start +
 			decbuf_y_size, canvas_width,
 			canvas_height / 2, CANVAS_ADDR_NOWRAP,
 			CANVAS_BLKMODE_32X32);
 #else
 		canvas_config(3 * i + 0,
-			one_buf_start,
+			buf_start,
 			canvas_width, canvas_height,
 			CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_32X32);
 		canvas_config(3 * i + 1,
-			one_buf_start +
+			buf_start +
 			decbuf_y_size, canvas_width / 2,
 			canvas_height / 2, CANVAS_ADDR_NOWRAP,
 			CANVAS_BLKMODE_32X32);
 		canvas_config(3 * i + 2,
-			one_buf_start +
+			buf_start +
 			decbuf_y_size + decbuf_uv_size,
 			canvas_width / 2, canvas_height / 2,
 			CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_32X32);
 #endif
-		buff_off = buff_off + decbuf_size;
+
 	}
+	return 0;
 }
 
-static void vmpeg4_prot_init(void)
+static int vmpeg4_prot_init(void)
 {
+	int r;
 #if 1	/* /MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6 */
 	WRITE_VREG(DOS_SW_RESET0, (1 << 7) | (1 << 6));
 	WRITE_VREG(DOS_SW_RESET0, 0);
 #else
-	WRITE_MPEG_REG(RESET0_REGISTER, RESET_IQIDCT | RESET_MC);
+	WRITE_RESET_REG(RESET0_REGISTER, RESET_IQIDCT | RESET_MC);
 #endif
 
-	vmpeg4_canvas_init();
+	r = vmpeg4_canvas_init();
 
 	/* index v << 16 | u << 8 | y */
 #ifdef NV21
@@ -843,6 +901,9 @@ static void vmpeg4_prot_init(void)
 	/* disable PSCALE for hardware sharing */
 	WRITE_VREG(PSCALE_CTRL, 0);
 
+	/* clear repeat count */
+	WRITE_VREG(MP4_NOT_CODED_CNT, 0);
+
 	WRITE_VREG(MREG_BUFFERIN, 0);
 	WRITE_VREG(MREG_BUFFEROUT, 0);
 
@@ -852,8 +913,7 @@ static void vmpeg4_prot_init(void)
 	/* enable mailbox interrupt */
 	WRITE_VREG(ASSIST_MBOX1_MASK, 1);
 
-	/* clear repeat count */
-	WRITE_VREG(MP4_NOT_CODED_CNT, 0);
+
 
 #ifdef NV21
 	SET_VREG_MASK(MDEC_PIC_DC_CTRL, 1 << 17);
@@ -867,6 +927,7 @@ static void vmpeg4_prot_init(void)
 	WRITE_VREG(MP4_PIC_WH, (vmpeg4_amstream_dec_info.
 		width << 16) | vmpeg4_amstream_dec_info.height);
 	WRITE_VREG(MP4_SYS_RATE, vmpeg4_amstream_dec_info.rate);
+	return r;
 }
 
 static void vmpeg4_local_init(void)
@@ -911,10 +972,23 @@ static void vmpeg4_local_init(void)
 		vfpool[i].index = DECODE_BUFFER_NUM_MAX;
 		kfifo_put(&newframe_q, (const struct vframe_s *)vf);
 	}
+	if (mm_blk_handle) {
+		decoder_bmmu_box_free(mm_blk_handle);
+		mm_blk_handle = NULL;
+	}
+
+		mm_blk_handle = decoder_bmmu_box_alloc_box(
+			DRIVER_NAME,
+			0,
+			MAX_BMMU_BUFFER_NUM,
+			4 + PAGE_SHIFT,
+			CODEC_MM_FLAGS_CMA_CLEAR |
+			CODEC_MM_FLAGS_FOR_VDECODER);
 }
 
 static s32 vmpeg4_init(void)
 {
+	int r;
 	int trickmode_fffb = 0;
 	int size = -1;
 	char *buf = vmalloc(0x1000 * 16);
@@ -970,7 +1044,9 @@ static s32 vmpeg4_init(void)
 	stat |= STAT_MC_LOAD;
 
 	/* enable AMRISC side protocol */
-	vmpeg4_prot_init();
+	r = vmpeg4_prot_init();
+	if (r < 0)
+		return r;
 
 	if (vdec_request_irq(VDEC_IRQ_1, vmpeg4_isr,
 			"vmpeg4-irq", (void *)vmpeg4_dec_id)) {
@@ -981,6 +1057,7 @@ static s32 vmpeg4_init(void)
 	}
 
 	stat |= STAT_ISR_REG;
+	fr_hint_status = VDEC_NO_NEED_HINT;
 #ifdef CONFIG_AMLOGIC_POST_PROCESS_MANAGER
 	vf_provider_init(&vmpeg_vf_prov, PROVIDER_NAME, &vmpeg_vf_provider,
 					 NULL);
@@ -991,8 +1068,15 @@ static s32 vmpeg4_init(void)
 					 NULL);
 	vf_reg_provider(&vmpeg_vf_prov);
 #endif
-	vf_notify_receiver(PROVIDER_NAME, VFRAME_EVENT_PROVIDER_FR_HINT,
-		(void *)((unsigned long)vmpeg4_amstream_dec_info.rate));
+	if (vmpeg4_amstream_dec_info.rate != 0) {
+		vf_notify_receiver(PROVIDER_NAME,
+					VFRAME_EVENT_PROVIDER_FR_HINT,
+					(void *)
+					((unsigned long)
+					vmpeg4_amstream_dec_info.rate));
+		fr_hint_status = VDEC_HINTED;
+	} else
+		fr_hint_status = VDEC_NEED_HINT;
 
 	stat |= STAT_VF_HOOK;
 
@@ -1021,18 +1105,20 @@ static int amvdec_mpeg4_probe(struct platform_device *pdev)
 		return -EFAULT;
 	}
 
-	buf_start = pdata->mem_start;
-	buf_size = pdata->mem_end - pdata->mem_start + 1;
-	buf_offset = buf_start - ORI_BUFFER_START_ADDR;
-
 	if (pdata->sys_info)
 		vmpeg4_amstream_dec_info = *pdata->sys_info;
 
 	pdata->dec_status = vmpeg4_dec_status;
 
+	INIT_WORK(&reset_work, reset_do_work);
+	INIT_WORK(&notify_work, vmpeg4_notify_work);
+
+	vmpeg4_vdec_info_init();
+
 	if (vmpeg4_init() < 0) {
 		amlog_level(LOG_LEVEL_ERROR, "amvdec_mpeg4 init failed.\n");
-
+		kfree(gvs);
+		gvs = NULL;
 		return -ENODEV;
 	}
 
@@ -1057,20 +1143,32 @@ static int amvdec_mpeg4_remove(struct platform_device *pdev)
 	}
 
 	if (stat & STAT_VF_HOOK) {
-		vf_notify_receiver(PROVIDER_NAME,
-			VFRAME_EVENT_PROVIDER_FR_END_HINT, NULL);
+		if (fr_hint_status == VDEC_HINTED)
+			vf_notify_receiver(PROVIDER_NAME,
+				VFRAME_EVENT_PROVIDER_FR_END_HINT, NULL);
+		fr_hint_status = VDEC_NO_NEED_HINT;
 
 		vf_unreg_provider(&vmpeg_vf_prov);
 		stat &= ~STAT_VF_HOOK;
 	}
 
+	cancel_work_sync(&reset_work);
+	cancel_work_sync(&notify_work);
+
 	amvdec_disable();
 
+	if (mm_blk_handle) {
+		decoder_bmmu_box_free(mm_blk_handle);
+		mm_blk_handle = NULL;
+	}
+
 	amlog_mask(LOG_MASK_PTS,
 		"pts hit %d, pts missed %d, i hit %d, missed %d\n", pts_hit,
 			   pts_missed, pts_i_hit, pts_i_missed);
 	amlog_mask(LOG_MASK_PTS, "total frame %d, rate %d\n", total_frame,
 			   vmpeg4_amstream_dec_info.rate);
+	kfree(gvs);
+	gvs = NULL;
 
 	return 0;
 }
@@ -1093,6 +1191,10 @@ static struct codec_profile_t amvdec_mpeg4_profile = {
 	.name = "mpeg4",
 	.profile = ""
 };
+static struct mconfig mpeg4_configs[] = {
+	MC_PU32("stat", &stat),
+};
+static struct mconfig_node mpeg4_node;
 
 static int __init amvdec_mpeg4_driver_init_module(void)
 {
@@ -1104,6 +1206,8 @@ static int __init amvdec_mpeg4_driver_init_module(void)
 		return -ENODEV;
 	}
 	vcodec_profile_register(&amvdec_mpeg4_profile);
+	INIT_REG_NODE_CONFIGS("media.decoder", &mpeg4_node,
+		"mpeg4", mpeg4_configs, CONFIG_FOR_R);
 	return 0;
 }
 
@@ -1115,10 +1219,6 @@ static void __exit amvdec_mpeg4_driver_remove_module(void)
 }
 
 /****************************************/
-
-module_param(stat, uint, 0664);
-MODULE_PARM_DESC(stat, "\n amvdec_mpeg4 stat\n");
-
 module_init(amvdec_mpeg4_driver_init_module);
 module_exit(amvdec_mpeg4_driver_remove_module);
 
diff --git a/drivers/frame_provider/decoder/mpeg4/vmpeg4_multi.c b/drivers/frame_provider/decoder/mpeg4/vmpeg4_multi.c
index 5c4b242..aa6bf81 100644
--- a/drivers/frame_provider/decoder/mpeg4/vmpeg4_multi.c
+++ b/drivers/frame_provider/decoder/mpeg4/vmpeg4_multi.c
@@ -801,17 +801,17 @@ static int  vmpeg_vf_states(struct vframe_states *states, void *op_arg)
 }
 
 
-static int dec_status(struct vdec_s *vdec, struct vdec_status *vstatus)
+static int dec_status(struct vdec_s *vdec, struct vdec_info *vstatus)
 {
 	struct vdec_mpeg4_hw_s *hw = (struct vdec_mpeg4_hw_s *)vdec->private;
 
-	vstatus->width = hw->vmpeg4_amstream_dec_info.width;
-	vstatus->height = hw->vmpeg4_amstream_dec_info.height;
+	vstatus->frame_width = hw->vmpeg4_amstream_dec_info.width;
+	vstatus->frame_height = hw->vmpeg4_amstream_dec_info.height;
 	if (0 != hw->vmpeg4_amstream_dec_info.rate)
-		vstatus->fps = DURATION_UNIT /
+		vstatus->frame_rate = DURATION_UNIT /
 				hw->vmpeg4_amstream_dec_info.rate;
 	else
-		vstatus->fps = DURATION_UNIT;
+		vstatus->frame_rate = DURATION_UNIT;
 	vstatus->error_count = READ_VREG(MP4_ERR_COUNT);
 	vstatus->status = hw->stat;
 
@@ -1189,7 +1189,6 @@ static int amvdec_mpeg4_probe(struct platform_device *pdev)
 	pdata->reset = reset;
 	pdata->irq_handler = vmpeg4_isr;
 
-	pdata->id = pdev->id;
 
 	if (pdata->use_vfm_path)
 		snprintf(pdata->vf_provider_name, VDEC_PROVIDER_NAME_SIZE,
diff --git a/drivers/frame_provider/decoder/real/vreal.c b/drivers/frame_provider/decoder/real/vreal.c
index d47fa99..a0f5159 100644
--- a/drivers/frame_provider/decoder/real/vreal.c
+++ b/drivers/frame_provider/decoder/real/vreal.c
@@ -47,6 +47,10 @@
 
 #include "vreal.h"
 #include <linux/amlogic/media/registers/register.h>
+#include "../utils/decoder_mmu_box.h"
+#include "../utils/decoder_bmmu_box.h"
+#include <linux/amlogic/media/codec_mm/codec_mm.h>
+#include <linux/amlogic/media/codec_mm/configs.h>
 
 #define DRIVER_NAME "amvdec_real"
 #define MODULE_NAME "amvdec_real"
@@ -89,6 +93,9 @@
 #define VF_POOL_SIZE        16
 #define VF_BUF_NUM          4
 #define PUT_INTERVAL        (HZ/100)
+#define WORKSPACE_SIZE		(1 * SZ_1M)
+#define MAX_BMMU_BUFFER_NUM	(VF_BUF_NUM + 1)
+#define RV_AI_BUFF_START_IP	 0x01f00000
 
 static struct vframe_s *vreal_vf_peek(void *);
 static struct vframe_s *vreal_vf_get(void *);
@@ -96,7 +103,7 @@ static void vreal_vf_put(struct vframe_s *, void *);
 static int vreal_vf_states(struct vframe_states *states, void *);
 static int vreal_event_cb(int type, void *data, void *private_data);
 
-static void vreal_prot_init(void);
+static int vreal_prot_init(void);
 static void vreal_local_init(void);
 
 static const char vreal_dec_id[] = "vreal-dev";
@@ -115,6 +122,7 @@ static const struct vframe_operations_s vreal_vf_provider = {
 };
 
 static struct vframe_provider_s vreal_vf_prov;
+static void *mm_blk_handle;
 
 static DECLARE_KFIFO(newframe_q, struct vframe_s *, VF_POOL_SIZE);
 static DECLARE_KFIFO(display_q, struct vframe_s *, VF_POOL_SIZE);
@@ -127,8 +135,8 @@ static u32 frame_width, frame_height, frame_dur, frame_prog;
 static u32 saved_resolution;
 static struct timer_list recycle_timer;
 static u32 stat;
-static unsigned long buf_start;
-static u32 buf_size, buf_offset;
+static u32 buf_size = 32 * 1024 * 1024;
+static u32 buf_offset;
 static u32 vreal_ratio;
 u32 vreal_format;
 static u32 wait_key_frame;
@@ -335,6 +343,10 @@ static irqreturn_t vreal_isr(int irq, void *dev_id)
 		vf->type_original = vf->type;
 
 		vfbuf_use[buffer_index] = 1;
+		vf->mem_handle =
+			decoder_bmmu_box_get_mem_handle(
+				mm_blk_handle,
+				buffer_index);
 
 		kfifo_put(&display_q, (const struct vframe_s *)vf);
 
@@ -487,14 +499,14 @@ static void vreal_put_timer_func(unsigned long arg)
 	add_timer(timer);
 }
 
-int vreal_dec_status(struct vdec_s *vdec, struct vdec_status *vstatus)
+int vreal_dec_status(struct vdec_s *vdec, struct vdec_info *vstatus)
 {
-	vstatus->width = vreal_amstream_dec_info.width;
-	vstatus->height = vreal_amstream_dec_info.height;
+	vstatus->frame_width = vreal_amstream_dec_info.width;
+	vstatus->frame_height = vreal_amstream_dec_info.height;
 	if (0 != vreal_amstream_dec_info.rate)
-		vstatus->fps = 96000 / vreal_amstream_dec_info.rate;
+		vstatus->frame_rate = 96000 / vreal_amstream_dec_info.rate;
 	else
-		vstatus->fps = 96000;
+		vstatus->frame_rate = 96000;
 	vstatus->error_count = real_err_count;
 	vstatus->status =
 		((READ_VREG(STATUS_AMRISC) << 16) | fatal_flag) | stat;
@@ -503,13 +515,13 @@ int vreal_dec_status(struct vdec_s *vdec, struct vdec_status *vstatus)
 }
 
 /****************************************/
-static void vreal_canvas_init(void)
+static int  vreal_canvas_init(void)
 {
-	int i;
+	int i, ret;
+	unsigned long buf_start;
 	u32 canvas_width, canvas_height;
-	u32 decbuf_size, decbuf_y_size, decbuf_uv_size;
-	u32 disp_addr = 0xffffffff;
-	u32 buff_off = 0;
+	u32 alloc_size, decbuf_size, decbuf_y_size, decbuf_uv_size;
+
 	if (buf_size <= 0x00400000) {
 		/* SD only */
 		canvas_width = 768;
@@ -557,86 +569,69 @@ static void vreal_canvas_init(void)
 			decbuf_size = 0x300000;
 		}
 		#endif
-	/*	canvas_width = 1920;
-		canvas_height = 1088;
-		decbuf_y_size = 0x200000;
-		decbuf_uv_size = 0x80000;
-		decbuf_size = 0x300000;*/
-	}
-
-	if (is_vpp_postblend()) {
-		struct canvas_s cur_canvas;
-
-		canvas_read((READ_VCBUS_REG(VD1_IF0_CANVAS0) & 0xff),
-					&cur_canvas);
-		disp_addr = (cur_canvas.addr + 7) >> 3;
 	}
 
-	for (i = 0; i < 4; i++) {
-		u32 one_buf_start = buf_start + buff_off;
-		if (((one_buf_start + 7) >> 3) == disp_addr) {
-			/*last disp buffer, to next..*/
-			buff_off += decbuf_size;
-			one_buf_start = buf_start + buff_off;
-			pr_info("one_buf_start %d,=== %x disp_addr %x",
-				i, one_buf_start, disp_addr);
-		}
-		if (buff_off < 0x01000000 &&
-			buff_off + decbuf_size > 0x0f00000){
-			/*0x01b00000 is references buffer.
-			to next 16M;*/
-			buff_off = 16 * SZ_1M;/*next 16M*/
-			one_buf_start = buf_start + buff_off;
+	for (i = 0; i < MAX_BMMU_BUFFER_NUM; i++) {
+		/* workspace mem */
+		if (i == (MAX_BMMU_BUFFER_NUM - 1))
+			alloc_size =  WORKSPACE_SIZE;
+		else
+			alloc_size = decbuf_size;
+
+		ret = decoder_bmmu_box_alloc_buf_phy(mm_blk_handle, i,
+				alloc_size, DRIVER_NAME, &buf_start);
+		if (ret < 0)
+			return ret;
+
+		if (i == (MAX_BMMU_BUFFER_NUM - 1)) {
+			buf_offset = buf_start - RV_AI_BUFF_START_IP;
+			continue;
 		}
-		if (buff_off + decbuf_size > buf_size) {
-			pr_err("ERROR::too small buffer for buf%d %d x%d ,size =%d\n",
-				i,
-				canvas_width,
-				canvas_height,
-				buf_size);
-		}
-		pr_info("alloced buffer %d at %x,%d\n",
-				i, one_buf_start, decbuf_size);
- #ifdef NV21
+
+#ifdef NV21
 		canvas_config(2 * i + 0,
-			one_buf_start,
+			buf_start,
 			canvas_width, canvas_height,
 			CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_32X32);
 		canvas_config(2 * i + 1,
-			one_buf_start +
+			buf_start +
 			decbuf_y_size, canvas_width,
 			canvas_height / 2, CANVAS_ADDR_NOWRAP,
 			CANVAS_BLKMODE_32X32);
- #else
+#else
 		canvas_config(3 * i + 0,
-			one_buf_start,
+			buf_start,
 			canvas_width, canvas_height,
 			CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_32X32);
 		canvas_config(3 * i + 1,
-			one_buf_start +
+			buf_start +
 			decbuf_y_size, canvas_width / 2,
 			canvas_height / 2, CANVAS_ADDR_NOWRAP,
 			CANVAS_BLKMODE_32X32);
 		canvas_config(3 * i + 2,
-			one_buf_start +
+			buf_start +
 			decbuf_y_size + decbuf_uv_size,
 			canvas_width / 2, canvas_height / 2,
 			CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_32X32);
- #endif
-		buff_off = buff_off + decbuf_size;
+#endif
 	}
+
+	return 0;
 }
 
-static void vreal_prot_init(void)
+static int vreal_prot_init(void)
 {
+	int r;
 #if 1	/* MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6 */
 	WRITE_VREG(DOS_SW_RESET0, (1 << 7) | (1 << 6));
 	WRITE_VREG(DOS_SW_RESET0, 0);
 #else
-	WRITE_MPEG_REG(RESET0_REGISTER, RESET_IQIDCT | RESET_MC);
+	WRITE_RESET_REG(RESET0_REGISTER, RESET_IQIDCT | RESET_MC);
 #endif
 
-	vreal_canvas_init();
+
+
+	r = vreal_canvas_init();
 
 	/* index v << 16 | u << 8 | y */
 #ifdef NV21
@@ -658,7 +653,7 @@ static void vreal_prot_init(void)
 	WRITE_VREG(DOS_SW_RESET0, (1 << 9) | (1 << 8));
 	WRITE_VREG(DOS_SW_RESET0, 0);
 #else
-	WRITE_MPEG_REG(RESET2_REGISTER, RESET_PIC_DC | RESET_DBLK);
+	WRITE_RESET_REG(RESET2_REGISTER, RESET_PIC_DC | RESET_DBLK);
 #endif
 
 	/* disable PSCALE for hardware sharing */
@@ -688,6 +683,7 @@ static void vreal_prot_init(void)
 #ifdef NV21
 	SET_VREG_MASK(MDEC_PIC_DC_CTRL, 1 << 17);
 #endif
+	return r;
 }
 
 static void vreal_local_init(void)
@@ -716,6 +712,19 @@ static void vreal_local_init(void)
 		kfifo_put(&newframe_q, vf);
 	}
 
+	if (mm_blk_handle) {
+		decoder_bmmu_box_free(mm_blk_handle);
+		mm_blk_handle = NULL;
+	}
+
+	 mm_blk_handle = decoder_bmmu_box_alloc_box(
+			DRIVER_NAME,
+			0,
+			MAX_BMMU_BUFFER_NUM,
+			4 + PAGE_SHIFT,
+			CODEC_MM_FLAGS_CMA_CLEAR |
+			CODEC_MM_FLAGS_FOR_VDECODER);
+
 	decoder_state = 1;
 	hold = 0;
 	last_tr = -1;
@@ -818,8 +827,9 @@ s32 vreal_init(struct vdec_s *vdec)
 	stat |= STAT_MC_LOAD;
 
 	/* enable AMRISC side protocol */
-	vreal_prot_init();
-
+	ret = vreal_prot_init();
+	if (ret < 0)
+		return ret;
 	if (vdec_request_irq(VDEC_IRQ_1,  vreal_isr,
 		    "vreal-irq", (void *)vreal_dec_id)) {
 		amvdec_disable();
@@ -868,9 +878,6 @@ void vreal_set_fatal_flag(int flag)
 		fatal_flag = PARSER_FATAL_ERROR;
 }
 
-/*TODO encoder*/
-/* extern void AbortEncodeWithVdec2(int abort); */
-
 static int amvdec_real_probe(struct platform_device *pdev)
 {
 	struct vdec_s *pdata = *(struct vdec_s **)pdev->dev.platform_data;
@@ -879,46 +886,13 @@ static int amvdec_real_probe(struct platform_device *pdev)
 		pr_info("amvdec_real memory resource undefined.\n");
 		return -EFAULT;
 	}
-
-	buf_start = pdata->mem_start;
-	buf_size = pdata->mem_end - pdata->mem_start + 1;
-	buf_offset = buf_start - RM_DEF_BUFFER_ADDR;
-
 	if (pdata->sys_info)
 		vreal_amstream_dec_info = *pdata->sys_info;
-	/* #if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)&&(HAS_HDEC)) */
-	/* if(IS_MESON_M8_CPU){ */
-	if (has_hdec()) {
-		/* disable vdec2 dblk when miracast. */
-		int count = 0;
-		if (get_vdec2_usage() != USAGE_NONE)
-			/*TODO encoder */
-			/* AbortEncodeWithVdec2(1); */
-			while ((get_vdec2_usage() != USAGE_NONE)
-				   && (count < 10)) {
-				msleep(50);
-				count++;
-			}
-
-		if (get_vdec2_usage() != USAGE_NONE) {
-			pr_info("\namvdec_real_probe --- stop vdec2 fail.\n");
-			return -EBUSY;
-		}
-	}
-	/* } */
-	/* #endif */
 
 	pdata->dec_status = vreal_dec_status;
 
 	if (vreal_init(pdata) < 0) {
 		pr_info("amvdec_real init failed.\n");
-		/* #if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)&&(HAS_HDEC) */
-		/* if(IS_MESON_M8_CPU) */
-		if (has_hdec()) {
-			/*TODO encoder */
-			/* AbortEncodeWithVdec2(0); */
-		}
-		/* #endif */
 		return -ENODEV;
 	}
 
@@ -961,13 +935,10 @@ static int amvdec_real_remove(struct platform_device *pdev)
 
 	amvdec_disable();
 
-	/* #if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)&&(HAS_HDEC) */
-	/* if(IS_MESON_M8_CPU) */
-	if (has_hdec()) {
-		/*TODO encoder */
-		/* AbortEncodeWithVdec2(0); */
+	if (mm_blk_handle) {
+		decoder_bmmu_box_free(mm_blk_handle);
+		mm_blk_handle = NULL;
 	}
-	/* #endif */
 	pr_info("frame duration %d, frames %d\n", frame_dur, frame_count);
 	return 0;
 }
@@ -990,6 +961,10 @@ static struct codec_profile_t amvdec_real_profile = {
 	.name = "real",
 	.profile = "rmvb,1080p+"
 };
+static struct mconfig real_configs[] = {
+	MC_PU32("stat", &stat),
+};
+static struct mconfig_node real_node;
 
 static int __init amvdec_real_driver_init_module(void)
 {
@@ -1000,6 +975,8 @@ static int __init amvdec_real_driver_init_module(void)
 		return -ENODEV;
 	}
 	vcodec_profile_register(&amvdec_real_profile);
+	INIT_REG_NODE_CONFIGS("media.decoder", &real_node,
+		"real", real_configs, CONFIG_FOR_R);
 	return 0;
 }
 
@@ -1012,9 +989,6 @@ static void __exit amvdec_real_driver_remove_module(void)
 
 /****************************************/
 
-module_param(stat, uint, 0664);
-MODULE_PARM_DESC(stat, "\n amvdec_real stat\n");
-
 module_init(amvdec_real_driver_init_module);
 module_exit(amvdec_real_driver_remove_module);
 
diff --git a/drivers/frame_provider/decoder/utils/Makefile b/drivers/frame_provider/decoder/utils/Makefile
index b7e6184..92eadc3 100644
--- a/drivers/frame_provider/decoder/utils/Makefile
+++ b/drivers/frame_provider/decoder/utils/Makefile
@@ -1,4 +1,4 @@
 obj-m	+=	decoder_common.o
 decoder_common-objs	+=	utils.o vdec.o vdec_input.o amvdec.o
 decoder_common-objs	+=	decoder_mmu_box.o decoder_bmmu_box.o
-decoder_common-objs	+=	config_parser.o
+decoder_common-objs	+=	config_parser.o secprot.o vdec_profile.o
diff --git a/drivers/frame_provider/decoder/utils/amvdec.c b/drivers/frame_provider/decoder/utils/amvdec.c
index a5e1462..0b310ee 100644
--- a/drivers/frame_provider/decoder/utils/amvdec.c
+++ b/drivers/frame_provider/decoder/utils/amvdec.c
@@ -591,16 +591,16 @@ void amvdec_start(void)
 	} else {
 		/* #else */
 		/* additional cbus dummy register reading for timing control */
-		READ_MPEG_REG(RESET0_REGISTER);
-		READ_MPEG_REG(RESET0_REGISTER);
-		READ_MPEG_REG(RESET0_REGISTER);
-		READ_MPEG_REG(RESET0_REGISTER);
+		READ_RESET_REG(RESET0_REGISTER);
+		READ_RESET_REG(RESET0_REGISTER);
+		READ_RESET_REG(RESET0_REGISTER);
+		READ_RESET_REG(RESET0_REGISTER);
 
-		WRITE_MPEG_REG(RESET0_REGISTER, RESET_VCPU | RESET_CCPU);
+		WRITE_RESET_REG(RESET0_REGISTER, RESET_VCPU | RESET_CCPU);
 
-		READ_MPEG_REG(RESET0_REGISTER);
-		READ_MPEG_REG(RESET0_REGISTER);
-		READ_MPEG_REG(RESET0_REGISTER);
+		READ_RESET_REG(RESET0_REGISTER);
+		READ_RESET_REG(RESET0_REGISTER);
+		READ_RESET_REG(RESET0_REGISTER);
 	}
 	/* #endif */
 
@@ -687,13 +687,13 @@ void amvdec_stop(void)
 		READ_VREG(DOS_SW_RESET0);
 	} else {
 		/* #else */
-		WRITE_MPEG_REG(RESET0_REGISTER, RESET_VCPU | RESET_CCPU);
+		WRITE_RESET_REG(RESET0_REGISTER, RESET_VCPU | RESET_CCPU);
 
 		/* additional cbus dummy register reading for timing control */
-		READ_MPEG_REG(RESET0_REGISTER);
-		READ_MPEG_REG(RESET0_REGISTER);
-		READ_MPEG_REG(RESET0_REGISTER);
-		READ_MPEG_REG(RESET0_REGISTER);
+		READ_RESET_REG(RESET0_REGISTER);
+		READ_RESET_REG(RESET0_REGISTER);
+		READ_RESET_REG(RESET0_REGISTER);
+		READ_RESET_REG(RESET0_REGISTER);
 	}
 	/* #endif */
 
diff --git a/drivers/frame_provider/decoder/utils/amvdec.h b/drivers/frame_provider/decoder/utils/amvdec.h
index c6f11d7..d0b9bd3 100644
--- a/drivers/frame_provider/decoder/utils/amvdec.h
+++ b/drivers/frame_provider/decoder/utils/amvdec.h
@@ -31,6 +31,8 @@ struct amvdec_dec_reg_s {
 	struct dec_sysinfo *dec_sysinfo;
 };				/*amvdec_dec_reg_t */
 
+struct vdec_s;
+
 extern void amvdec_start(void);
 extern void amvdec_stop(void);
 extern void amvdec_enable(void);
diff --git a/drivers/frame_provider/decoder/utils/config_parser.c b/drivers/frame_provider/decoder/utils/config_parser.c
index b9c64f7..9db4d61 100644
--- a/drivers/frame_provider/decoder/utils/config_parser.c
+++ b/drivers/frame_provider/decoder/utils/config_parser.c
@@ -60,3 +60,5 @@ int get_config_int(const char *configs, const char *need, int *val)
 
 	return -4;
 }
+EXPORT_SYMBOL(get_config_int);
+
diff --git a/drivers/frame_provider/decoder/utils/decoder_bmmu_box.c b/drivers/frame_provider/decoder/utils/decoder_bmmu_box.c
index 7a858d5..892f11f 100644
--- a/drivers/frame_provider/decoder/utils/decoder_bmmu_box.c
+++ b/drivers/frame_provider/decoder/utils/decoder_bmmu_box.c
@@ -81,6 +81,12 @@ void *decoder_bmmu_box_alloc_box(const char *name,
 {
 	struct decoder_bmmu_box *box;
 	int size;
+	int tvp_flags;
+	tvp_flags = (mem_flags & CODEC_MM_FLAGS_TVP) ?
+		CODEC_MM_FLAGS_TVP : 0;
+
+	pr_info("decoder_bmmu_box_alloc_box, tvp_flags = %x\n", tvp_flags);
+
 	size = sizeof(struct decoder_bmmu_box) + sizeof(struct codec_mm_s *) *
 		   max_num;
 	box = kmalloc(size, GFP_KERNEL);
@@ -93,7 +99,7 @@ void *decoder_bmmu_box_alloc_box(const char *name,
 	box->name = name;
 	box->channel_id = channel_id;
 	box->align2n = aligned;
-	box->mem_flags = mem_flags;
+	box->mem_flags = mem_flags | tvp_flags;
 	mutex_init(&box->mutex);
 	INIT_LIST_HEAD(&box->list);
 	decoder_bmmu_box_mgr_add_box(box);
@@ -147,6 +153,8 @@ int decoder_bmmu_box_alloc_idx(void *handle, int idx, int size, int aligned_2n,
 		if (mm) {
 			box->mm_list[idx] = mm;
 			box->total_size += mm->buffer_size;
+			mm->ins_id = box->channel_id;
+			mm->ins_buffer_id = idx;
 		}
 	}
 	mutex_unlock(&box->mutex);
@@ -286,6 +294,41 @@ int decoder_bmmu_box_alloc_idx_wait(
 }
 EXPORT_SYMBOL(decoder_bmmu_box_alloc_idx_wait);
 
+int decoder_bmmu_box_alloc_buf_phy(
+	void *handle, int idx,
+	int size, unsigned char *driver_name,
+	unsigned long *buf_phy_addr)
+{
+	if (!decoder_bmmu_box_check_and_wait_size(
+			size,
+			1)) {
+		pr_info("%s not enough buf for buf_idx = %d\n",
+					driver_name, idx);
+		return	-ENOMEM;
+	}
+	if (!decoder_bmmu_box_alloc_idx_wait(
+			handle,
+			idx,
+			size,
+			-1,
+			-1,
+			BMMU_ALLOC_FLAGS_WAITCLEAR
+			)) {
+		*buf_phy_addr =
+			decoder_bmmu_box_get_phy_addr(
+			handle,
+			idx);
+		pr_info("%s malloc buf_idx = %d addr = %ld size = %d\n",
+			driver_name, idx, *buf_phy_addr, size);
+		} else {
+		pr_info("%s malloc failed  %d\n", driver_name, idx);
+			return -ENOMEM;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(decoder_bmmu_box_alloc_buf_phy);
+
 static int decoder_bmmu_box_dump(struct decoder_bmmu_box *box, void *buf,
 								 int size)
 {
@@ -294,20 +337,23 @@ static int decoder_bmmu_box_dump(struct decoder_bmmu_box *box, void *buf,
 	int tsize = 0;
 	int s;
 	int i;
-	if (!pbuf)
+	if (!buf) {
 		pbuf = sbuf;
-
+		size = 100000;
+	}
 #define BUFPRINT(args...) \
 	do {\
-		s = sprintf(pbuf, args);\
+		s = snprintf(pbuf, size - tsize, args);\
 		tsize += s;\
 		pbuf += s; \
 	} while (0)
 
 	for (i = 0; i < box->max_mm_num; i++) {
 		struct codec_mm_s *mm = box->mm_list[i];
-		if (buf && (size - tsize) < 128)
+		if (buf && (size - tsize) < 256) {
+			BUFPRINT("\n\t**NOT END**\n");
 			break;
+		}
 		if (mm) {
 			BUFPRINT("code mem[%d]:%p, addr=%p, size=%d,from=%d\n",
 					 i,
@@ -315,11 +361,13 @@ static int decoder_bmmu_box_dump(struct decoder_bmmu_box *box, void *buf,
 					 (void *)mm->phy_addr,
 					 mm->buffer_size,
 					 mm->from_flags);
+			if (!buf) {
+				pr_info("%s", sbuf);
+				pbuf = sbuf;
+			}
 		}
 	}
 #undef BUFPRINT
-	if (!buf)
-		pr_info("%s", sbuf);
 
 	return tsize;
 }
@@ -333,12 +381,13 @@ static int decoder_bmmu_box_dump_all(void *buf, int size)
 	int s;
 	int i;
 	struct list_head *head, *list;
-	if (!pbuf)
+	if (!buf) {
 		pbuf = sbuf;
-
+		size = 100000;
+	}
 #define BUFPRINT(args...) \
 	do {\
-		s = sprintf(pbuf, args);\
+		s = snprintf(pbuf, size - tsize, args);\
 		tsize += s;\
 		pbuf += s; \
 	} while (0)
@@ -350,15 +399,19 @@ static int decoder_bmmu_box_dump_all(void *buf, int size)
 	while (list != head) {
 		struct decoder_bmmu_box *box;
 		box = list_entry(list, struct decoder_bmmu_box, list);
-		BUFPRINT("box[%d]: %s, player_id:%d, max_num:%d, size:%d\n",
+		BUFPRINT("box[%d]: %s, %splayer_id:%d, max_num:%d, size:%d\n",
 				 i, box->name,
+				 (box->mem_flags & CODEC_MM_FLAGS_TVP) ?
+				 "TVP mode " : "",
 				 box->channel_id,
 				 box->max_mm_num,
 				 box->total_size);
 		if (buf) {
-			tsize += decoder_bmmu_box_dump(box, pbuf, size - tsize);
-			if (tsize > 0)
-				pbuf += tsize;
+			s = decoder_bmmu_box_dump(box, pbuf, size - tsize);
+			if (s > 0) {
+				tsize += s;
+				pbuf += s;
+			}
 		} else {
 			pr_info("%s", sbuf);
 			pbuf = sbuf;
@@ -383,8 +436,48 @@ static ssize_t box_dump_show(struct class *class, struct class_attribute *attr,
 	return ret;
 }
 
+static ssize_t box_debug_show(struct class *class,
+		struct class_attribute *attr,
+		char *buf)
+{
+	ssize_t size = 0;
+	size += sprintf(buf, "box debug help:\n");
+	size += sprintf(buf + size, "echo n > debug\n");
+	size += sprintf(buf + size, "n==0: clear all debugs)\n");
+	size += sprintf(buf + size,
+	"n=1: dump all box\n");
+
+	return size;
+}
+
+
+static ssize_t box_debug_store(struct class *class,
+		struct class_attribute *attr,
+		const char *buf, size_t size)
+{
+	unsigned val;
+	ssize_t ret;
+	val = -1;
+	ret = sscanf(buf, "%d", &val);
+	if (ret != 1)
+		return -EINVAL;
+	switch (val) {
+	case 1:
+		decoder_bmmu_box_dump_all(NULL , 0);
+		break;
+	default:
+		pr_err("unknow cmd! %d\n", val);
+	}
+	return size;
+
+}
+
+
+
 static struct class_attribute decoder_bmmu_box_class_attrs[] = {
 	__ATTR_RO(box_dump),
+	__ATTR(debug, S_IRUGO | S_IWUSR | S_IWGRP,
+		box_debug_show, box_debug_store),
 	__ATTR_NULL
 };
 
diff --git a/drivers/frame_provider/decoder/utils/decoder_bmmu_box.h b/drivers/frame_provider/decoder/utils/decoder_bmmu_box.h
index 99aa89b..9b6214a 100644
--- a/drivers/frame_provider/decoder/utils/decoder_bmmu_box.h
+++ b/drivers/frame_provider/decoder/utils/decoder_bmmu_box.h
@@ -43,6 +43,11 @@ void *decoder_bmmu_box_get_virt_addr(
 int decoder_bmmu_box_check_and_wait_size(
 	int size, int flags);
 
+int decoder_bmmu_box_alloc_buf_phy(
+	void *handle, int idx,
+	int size, unsigned char *driver_name,
+	unsigned long *buf_phy_addr);
+
 #define BMMU_ALLOC_FLAGS_WAIT (1 << 0)
 #define BMMU_ALLOC_FLAGS_CAN_CLEAR_KEEPER (1 << 1)
 #define BMMU_ALLOC_FLAGS_WAITCLEAR \
diff --git a/drivers/frame_provider/decoder/utils/decoder_mmu_box.c b/drivers/frame_provider/decoder/utils/decoder_mmu_box.c
index 26440fe..e7339d0 100644
--- a/drivers/frame_provider/decoder/utils/decoder_mmu_box.c
+++ b/drivers/frame_provider/decoder/utils/decoder_mmu_box.c
@@ -32,6 +32,7 @@ struct decoder_mmu_box {
 	int max_sc_num;
 	const char *name;
 	int channel_id;
+	int tvp_mode;
 	struct mutex mutex;
 	struct list_head list;
 	struct codec_mm_scatter *sc_list[1];
@@ -78,12 +79,15 @@ static int decoder_mmu_box_mgr_del_box(struct decoder_mmu_box *box)
 void *decoder_mmu_box_alloc_box(const char *name,
 	int channel_id,
 	int max_num,
-	int min_size_M)
+	int min_size_M,
+	int mem_flags)
 /*min_size_M:wait alloc this size*/
 {
 	struct decoder_mmu_box *box;
 	int size;
 
+	pr_info("decoder_mmu_box_alloc_box, mem_flags = 0x%x\n", mem_flags);
+
 	size = sizeof(struct decoder_mmu_box) +
 			sizeof(struct codec_mm_scatter *) *
 			max_num;
@@ -96,11 +100,13 @@ void *decoder_mmu_box_alloc_box(const char *name,
 	box->max_sc_num = max_num;
 	box->name = name;
 	box->channel_id = channel_id;
+	box->tvp_mode = mem_flags;
+
 	mutex_init(&box->mutex);
 	INIT_LIST_HEAD(&box->list);
 	decoder_mmu_box_mgr_add_box(box);
 	codec_mm_scatter_mgt_delay_free_swith(1, 2000,
-		min_size_M);
+		min_size_M, box->tvp_mode);
 	return (void *)box;
 }
 EXPORT_SYMBOL(decoder_mmu_box_alloc_box);
@@ -133,7 +139,8 @@ int decoder_mmu_box_alloc_idx(
 
 	}
 	if (!sc) {
-		sc = codec_mm_scatter_alloc(num_pages + 64, num_pages);
+		sc = codec_mm_scatter_alloc(num_pages + 64, num_pages,
+			box->tvp_mode);
 		if (!sc) {
 			mutex_unlock(&box->mutex);
 			pr_err("alloc mmu failed, need pages=%d\n",
@@ -217,8 +224,8 @@ int decoder_mmu_box_free(void *handle)
 	}
 	mutex_unlock(&box->mutex);
 	decoder_mmu_box_mgr_del_box(box);
+	codec_mm_scatter_mgt_delay_free_swith(0, 2000, 0, box->tvp_mode);
 	kfree(box);
-	codec_mm_scatter_mgt_delay_free_swith(0, 2000, 0);
 	return 0;
 }
 EXPORT_SYMBOL(decoder_mmu_box_free);
@@ -242,12 +249,13 @@ static int decoder_mmu_box_dump(struct decoder_mmu_box *box,
 	int s;
 	int i;
 
-	if (!pbuf)
+	if (!buf) {
 		pbuf = sbuf;
-
+		size = 100000;
+	}
 	#define BUFPRINT(args...) \
 	do {\
-		s = sprintf(pbuf, args);\
+		s = snprintf(pbuf, size - tsize, args);\
 		tsize += s;\
 		pbuf += s; \
 	} while (0)
@@ -278,12 +286,14 @@ static int decoder_mmu_box_dump_all(void *buf, int size)
 	int i;
 	struct list_head *head, *list;
 
-	if (!pbuf)
+	if (!pbuf) {
 		pbuf = sbuf;
+		size = 100000;
+	}
 
 	#define BUFPRINT(args...) \
 	do {\
-		s = sprintf(pbuf, args);\
+		s = snprintf(pbuf, size - tsize, args);\
 		tsize += s;\
 		pbuf += s; \
 	} while (0)
@@ -294,18 +304,20 @@ static int decoder_mmu_box_dump_all(void *buf, int size)
 	i = 0;
 	while (list != head) {
 		struct decoder_mmu_box *box;
-
 		box = list_entry(list, struct decoder_mmu_box,
 							list);
-		BUFPRINT("box[%d]: %s, player_id:%d, max_num:%d\n",
+		BUFPRINT("box[%d]: %s, %splayer_id:%d, max_num:%d\n",
 			i,
 			box->name,
+			box->tvp_mode ? "TVP mode " : "",
 			box->channel_id,
 			box->max_sc_num);
 		if (buf) {
-			tsize += decoder_mmu_box_dump(box, pbuf, size - tsize);
-			if (tsize > 0)
-				pbuf += tsize;
+			s += decoder_mmu_box_dump(box, pbuf, size - tsize);
+			if (s > 0) {
+				tsize += s;
+				pbuf += s;
+			}
 		} else {
 			pr_info("%s", sbuf);
 			pbuf = sbuf;
diff --git a/drivers/frame_provider/decoder/utils/decoder_mmu_box.h b/drivers/frame_provider/decoder/utils/decoder_mmu_box.h
index 387dd24..89ffba3 100644
--- a/drivers/frame_provider/decoder/utils/decoder_mmu_box.h
+++ b/drivers/frame_provider/decoder/utils/decoder_mmu_box.h
@@ -21,7 +21,8 @@
 void *decoder_mmu_box_alloc_box(const char *name,
 	int channel_id,
 	int max_num,
-	int min_size_M);
+	int min_size_M,
+	int mem_flags);
 
 int decoder_mmu_box_alloc_idx(
 	void *handle, int idx, int num_pages,
diff --git a/drivers/frame_provider/decoder/utils/secprot.c b/drivers/frame_provider/decoder/utils/secprot.c
new file mode 100644
index 0000000..1d14e2c
--- /dev/null
+++ b/drivers/frame_provider/decoder/utils/secprot.c
@@ -0,0 +1,43 @@
+/*
+ * drivers/amlogic/amports/arch/secprot.c
+ *
+ * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+*/
+
+#include "secprot.h"
+
+int tee_config_device_secure(int dev_id, int secure)
+{
+	int ret = 0;
+	register unsigned x0 asm("x0");
+	register unsigned x1 asm("x1");
+	register unsigned x2 asm("x2");
+
+	x0 = OPTEE_SMC_CONFIG_DEVICE_SECURE;
+	x1 = dev_id;
+	x2 = secure;
+
+	asm volatile(
+		__asmeq("%0", "x0")
+		__asmeq("%1", "x0")
+		__asmeq("%2", "x1")
+		__asmeq("%3", "x2")
+		"smc    #0\n"
+		: "=r"(x0)
+		: "r"(x0), "r"(x1), "r"(x2));
+	ret = x0;
+
+	return ret;
+}
+
diff --git a/drivers/frame_provider/decoder/utils/secprot.h b/drivers/frame_provider/decoder/utils/secprot.h
new file mode 100644
index 0000000..f8fc5da
--- /dev/null
+++ b/drivers/frame_provider/decoder/utils/secprot.h
@@ -0,0 +1,39 @@
+/*
+ * drivers/amlogic/amports/arch/secprot.h
+ *
+ * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+*/
+
+#ifndef __SECPROT_H_
+#define __SECPROT_H_
+
+#define DMC_DEV_TYPE_NON_SECURE        0
+#define DMC_DEV_TYPE_SECURE            1
+
+#define DMC_DEV_ID_GPU                 1
+#define DMC_DEV_ID_HEVC                4
+#define DMC_DEV_ID_PARSER              7
+#define DMC_DEV_ID_VPU                 8
+#define DMC_DEV_ID_VDEC                13
+#define DMC_DEV_ID_HCODEC              14
+#define DMC_DEV_ID_GE2D                15
+
+#define OPTEE_SMC_CONFIG_DEVICE_SECURE 0xb200000e
+
+#define __asmeq(x, y)  ".ifnc " x "," y " ; .err ; .endif\n\t"
+
+extern int tee_config_device_secure(int dev_id, int secure);
+
+#endif /* __SECPROT_H_ */
+
diff --git a/drivers/frame_provider/decoder/utils/utils.c b/drivers/frame_provider/decoder/utils/utils.c
index 33ab765..ea6f9f2 100644
--- a/drivers/frame_provider/decoder/utils/utils.c
+++ b/drivers/frame_provider/decoder/utils/utils.c
@@ -34,6 +34,7 @@
 #include "amvdec.h"
 #include "decoder_mmu_box.h"
 #include "decoder_bmmu_box.h"
+#include "vdec_profile.h"
 
 static int __init decoder_common_init(void)
 {
@@ -47,6 +48,8 @@ static int __init decoder_common_init(void)
 	decoder_mmu_box_init();/*exit?*/
 	decoder_bmmu_box_init();
 
+	vdec_profile_init_debugfs();
+
 	return 0;
 }
 
@@ -60,6 +63,8 @@ static void __exit decoder_common_exit(void)
 
 	decoder_mmu_box_exit();
 	decoder_bmmu_box_exit();
+
+	vdec_profile_exit_debugfs();
 }
 
 module_init(decoder_common_init);
diff --git a/drivers/frame_provider/decoder/utils/vdec.c b/drivers/frame_provider/decoder/utils/vdec.c
index 7c54882..ab10487 100644
--- a/drivers/frame_provider/decoder/utils/vdec.c
+++ b/drivers/frame_provider/decoder/utils/vdec.c
@@ -37,6 +37,7 @@
 
 #include <linux/amlogic/media/utils/vdec_reg.h>
 #include "vdec.h"
+#include "vdec_trace.h"
 #ifdef CONFIG_MULTI_DEC
 #include "vdec_profile.h"
 #endif
@@ -58,9 +59,12 @@
 
 #include "../../../common/media_clock/clk/clk.h"
 #include <linux/reset.h>
-#include <linux/amlogic/media/old_cpu_version.h>
+#include <linux/amlogic/cpu_version.h>
 #include <linux/amlogic/media/codec_mm/codec_mm.h>
 #include <linux/amlogic/media/video_sink/video_keeper.h>
+#include <linux/amlogic/media/codec_mm/configs.h>
+#include <linux/amlogic/media/frame_sync/ptsserv.h>
+#include "secprot.h"
 
 static DEFINE_MUTEX(vdec_mutex);
 
@@ -74,10 +78,10 @@ static unsigned int debug_trace_num = 16 * 20;
 static int step_mode;
 static unsigned int clk_config;
 
-static struct page *vdec_cma_page;
-int vdec_mem_alloced_from_codec, delay_release;
-static unsigned long reserved_mem_start, reserved_mem_end;
 static int hevc_max_reset_count;
+#define MAX_INSTANCE_MUN  9
+
+
 static DEFINE_SPINLOCK(vdec_spin_lock);
 
 #define HEVC_TEST_LIMIT 100
@@ -99,17 +103,16 @@ struct vdec_isr_context_s {
 struct vdec_core_s {
 	struct list_head connected_vdec_list;
 	spinlock_t lock;
-
+	struct ida ida;
 	atomic_t vdec_nr;
 	struct vdec_s *vfm_vdec;
 	struct vdec_s *active_vdec;
+	struct vdec_s *hint_fr_vdec;
 	struct platform_device *vdec_core_platform_device;
 	struct device *cma_dev;
-	unsigned long mem_start;
-	unsigned long mem_end;
-
 	struct semaphore sem;
 	struct task_struct *thread;
+	struct workqueue_struct *vdec_core_wq;
 
 	struct vdec_isr_context_s isr_context[VDEC_IRQ_MAX];
 	int power_ref_count[VDEC_MAX];
@@ -117,6 +120,33 @@ struct vdec_core_s {
 
 static struct vdec_core_s *vdec_core;
 
+static const char * const vdec_status_string[] = {
+	"VDEC_STATUS_UNINITIALIZED",
+	"VDEC_STATUS_DISCONNECTED",
+	"VDEC_STATUS_CONNECTED",
+	"VDEC_STATUS_ACTIVE"
+};
+
+static int debugflags;
+
+int vdec_get_debug_flags(void)
+{
+	return debugflags;
+}
+EXPORT_SYMBOL(vdec_get_debug_flags);
+
+unsigned char is_mult_inc(unsigned int type)
+{
+	unsigned char ret = 0;
+	if (vdec_get_debug_flags() & 0xf000)
+		ret = (vdec_get_debug_flags() & 0x1000)
+			? 1 : 0;
+	else if (type & PORT_TYPE_DECODER_SCHED)
+		ret = 1;
+	return ret;
+}
+EXPORT_SYMBOL(is_mult_inc);
+
 unsigned long vdec_core_lock(struct vdec_core_s *core)
 {
 	unsigned long flags;
@@ -166,7 +196,7 @@ static int get_canvas(unsigned int index, unsigned int base)
 }
 
 
-int vdec_status(struct vdec_s *vdec, struct vdec_status *vstatus)
+int vdec_status(struct vdec_s *vdec, struct vdec_info *vstatus)
 {
 	if (vdec->dec_status)
 		return vdec->dec_status(vdec, vstatus);
@@ -191,6 +221,36 @@ int vdec_set_trickmode(struct vdec_s *vdec, unsigned long trickmode)
 }
 EXPORT_SYMBOL(vdec_set_trickmode);
 
+void  vdec_count_info(struct vdec_info *vs, unsigned int err,
+	unsigned int offset)
+{
+	if (err)
+		vs->error_frame_count++;
+	if (offset) {
+		if (0 == vs->frame_count) {
+			vs->offset = 0;
+			vs->samp_cnt = 0;
+		}
+		vs->frame_data = offset > vs->total_data ?
+			offset - vs->total_data : vs->total_data - offset;
+		vs->total_data = offset;
+		if (vs->samp_cnt < 96000 * 2) { /* 2s */
+			if (0 == vs->samp_cnt)
+				vs->offset = offset;
+			vs->samp_cnt += vs->frame_dur;
+		} else {
+			vs->bit_rate = (offset - vs->offset) / 2;
+			/*pr_info("bitrate : %u\n",vs->bit_rate);*/
+			vs->samp_cnt = 0;
+		}
+		vs->frame_count++;
+	}
+	/*pr_info("size : %u, offset : %u, dur : %u, cnt : %u\n",
+		vs->offset,offset,vs->frame_dur,vs->samp_cnt);*/
+	return;
+}
+EXPORT_SYMBOL(vdec_count_info);
+
 /*
 * clk_config:
  *0:default
@@ -221,11 +281,6 @@ struct device *get_codec_cma_device(void)
 	return vdec_core->cma_dev;
 }
 
-static unsigned int get_mmu_mode(void)
-{
-	return 1;//DEBUG_TMP
-}
-
 #ifdef CONFIG_MULTI_DEC
 static const char * const vdec_device_name[] = {
 	"amvdec_mpeg12",     "ammvdec_mpeg12",
@@ -245,28 +300,6 @@ static const char * const vdec_device_name[] = {
 	"amvdec_vp9",        "ammvdec_vp9"
 };
 
-static int vdec_default_buf_size[] = {
-	32, 32, /*"amvdec_mpeg12",*/
-	32, 0,  /*"amvdec_mpeg4",*/
-	48, 0,  /*"amvdec_h264",*/
-	32, 32, /*"amvdec_mjpeg",*/
-	32, 32, /*"amvdec_real",*/
-	32, 32, /*"amjpegdec",*/
-	32, 32, /*"amvdec_vc1",*/
-	32, 32, /*"amvdec_avs",*/
-	32, 32, /*"amvdec_yuv",*/
-	64, 64, /*"amvdec_h264mvc",*/
-	64, 64, /*"amvdec_h264_4k2k", else alloc on decoder*/
-	48, 48, /*"amvdec_h265", else alloc on decoder*/
-	0, 0,   /* avs encoder */
-	0, 0,   /* jpg encoder */
-#ifdef VP9_10B_MMU
-	24, 24, /*"amvdec_vp9", else alloc on decoder*/
-#else
-	32, 32,
-#endif
-	0
-};
 
 #else
 
@@ -288,27 +321,6 @@ static const char * const vdec_device_name[] = {
 	"amvdec_vp9"
 };
 
-static int vdec_default_buf_size[] = {
-	32, /*"amvdec_mpeg12",*/
-	32, /*"amvdec_mpeg4",*/
-	48, /*"amvdec_h264",*/
-	32, /*"amvdec_mjpeg",*/
-	32, /*"amvdec_real",*/
-	32, /*"amjpegdec",*/
-	32, /*"amvdec_vc1",*/
-	32, /*"amvdec_avs",*/
-	32, /*"amvdec_yuv",*/
-	64, /*"amvdec_h264mvc",*/
-	64, /*"amvdec_h264_4k2k", else alloc on decoder*/
-	48, /*"amvdec_h265", else alloc on decoder*/
-	0,  /* avs encoder */
-	0,  /* jpg encoder */
-#ifdef VP9_10B_MMU
-	24, /*"amvdec_vp9", else alloc on decoder*/
-#else
-	32,
-#endif
-};
 #endif
 
 int vdec_set_decinfo(struct vdec_s *vdec, struct dec_sysinfo *p)
@@ -327,28 +339,33 @@ struct vdec_s *vdec_create(struct stream_port_s *port,
 {
 	struct vdec_s *vdec;
 	int type = VDEC_TYPE_SINGLE;
-
-	if (port->type & PORT_TYPE_DECODER_SCHED)
+	int id;
+	if (is_mult_inc(port->type))
 		type = (port->type & PORT_TYPE_FRAME) ?
 			VDEC_TYPE_FRAME_BLOCK :
 			VDEC_TYPE_STREAM_PARSER;
 
+	id = ida_simple_get(&vdec_core->ida,
+			0, MAX_INSTANCE_MUN, GFP_KERNEL);
+	if (id < 0) {
+		pr_info("vdec_create request id failed!ret =%d\n", id);
+		return NULL;
+	}
 	vdec = vzalloc(sizeof(struct vdec_s));
 
 	/* TBD */
 	if (vdec) {
 		vdec->magic = 0x43454456;
-		vdec->id = 0;
+		vdec->id = -1;
 		vdec->type = type;
 		vdec->port = port;
 		vdec->sys_info = &vdec->sys_info_store;
 
 		INIT_LIST_HEAD(&vdec->list);
 
-		vdec_input_init(&vdec->input, vdec);
-
 		atomic_inc(&vdec_core->vdec_nr);
-
+		vdec->id = id;
+		vdec_input_init(&vdec->input, vdec);
 		if (master) {
 			vdec->master = master;
 			master->slave = vdec;
@@ -359,6 +376,8 @@ struct vdec_s *vdec_create(struct stream_port_s *port,
 	pr_info("vdec_create instance %p, total %d\n", vdec,
 		atomic_read(&vdec_core->vdec_nr));
 
+	//trace_vdec_create(vdec); /*DEBUG_TMP*/
+
 	return vdec;
 }
 EXPORT_SYMBOL(vdec_create);
@@ -366,9 +385,14 @@ EXPORT_SYMBOL(vdec_create);
 int vdec_set_format(struct vdec_s *vdec, int format)
 {
 	vdec->format = format;
+	vdec->port_flag |= PORT_FLAG_VFORMAT;
 
-	if (vdec->slave)
+	if (vdec->slave) {
 		vdec->slave->format = format;
+		vdec->slave->port_flag |= PORT_FLAG_VFORMAT;
+	}
+
+	//trace_vdec_set_format(vdec, format);/*DEBUG_TMP*/
 
 	return 0;
 }
@@ -377,7 +401,9 @@ EXPORT_SYMBOL(vdec_set_format);
 int vdec_set_pts(struct vdec_s *vdec, u32 pts)
 {
 	vdec->pts = pts;
+	vdec->pts64 = div64_u64((u64)pts * 100, 9);
 	vdec->pts_valid = true;
+	//trace_vdec_set_pts(vdec, (u64)pts);/*DEBUG_TMP*/
 	return 0;
 }
 EXPORT_SYMBOL(vdec_set_pts);
@@ -385,19 +411,24 @@ EXPORT_SYMBOL(vdec_set_pts);
 int vdec_set_pts64(struct vdec_s *vdec, u64 pts64)
 {
 	vdec->pts64 = pts64;
+	vdec->pts = (u32)div64_u64(pts64 * 9, 100);
 	vdec->pts_valid = true;
+
+	//trace_vdec_set_pts64(vdec, pts64);/*DEBUG_TMP*/
 	return 0;
 }
 EXPORT_SYMBOL(vdec_set_pts64);
 
 void vdec_set_status(struct vdec_s *vdec, int status)
 {
+	//trace_vdec_set_status(vdec, status);/*DEBUG_TMP*/
 	vdec->status = status;
 }
 EXPORT_SYMBOL(vdec_set_status);
 
 void vdec_set_next_status(struct vdec_s *vdec, int status)
 {
+	//trace_vdec_set_next_status(vdec, status);/*DEBUG_TMP*/
 	vdec->next_status = status;
 }
 EXPORT_SYMBOL(vdec_set_next_status);
@@ -409,6 +440,13 @@ int vdec_set_video_path(struct vdec_s *vdec, int video_path)
 }
 EXPORT_SYMBOL(vdec_set_video_path);
 
+int vdec_set_receive_id(struct vdec_s *vdec, int receive_id)
+{
+	vdec->vf_receiver_inst = receive_id;
+	return 0;
+}
+EXPORT_SYMBOL(vdec_set_receive_id);
+
 /* add frame data to input chain */
 int vdec_write_vframe(struct vdec_s *vdec, const char *buf, size_t count)
 {
@@ -416,6 +454,90 @@ int vdec_write_vframe(struct vdec_s *vdec, const char *buf, size_t count)
 }
 EXPORT_SYMBOL(vdec_write_vframe);
 
+/* add a work queue thread for vdec*/
+void vdec_schedule_work(struct work_struct *work)
+{
+	if (vdec_core->vdec_core_wq)
+		queue_work(vdec_core->vdec_core_wq, work);
+	else
+		schedule_work(work);
+}
+EXPORT_SYMBOL(vdec_schedule_work);
+
+static struct vdec_s *vdec_get_associate(struct vdec_s *vdec)
+{
+	if (vdec->master)
+		return vdec->master;
+	else if (vdec->slave)
+		return vdec->slave;
+	return NULL;
+}
+
+static void vdec_sync_input_read(struct vdec_s *vdec)
+{
+	if (!vdec_stream_based(vdec))
+		return;
+
+	if (vdec_dual(vdec)) {
+		u32 me, other;
+		if (vdec->input.target == VDEC_INPUT_TARGET_VLD) {
+			me = READ_VREG(VLD_MEM_VIFIFO_WRAP_COUNT);
+			other =
+				vdec_get_associate(vdec)->input.stream_cookie;
+			if (me > other)
+				return;
+			else if (me == other) {
+				me = READ_VREG(VLD_MEM_VIFIFO_RP);
+				other =
+				vdec_get_associate(vdec)->input.swap_rp;
+				if (me > other) {
+					WRITE_PARSER_REG(PARSER_VIDEO_RP,
+						vdec_get_associate(vdec)->
+						input.swap_rp);
+					return;
+				}
+			}
+			WRITE_PARSER_REG(PARSER_VIDEO_RP,
+				READ_VREG(VLD_MEM_VIFIFO_RP));
+		} else if (vdec->input.target == VDEC_INPUT_TARGET_HEVC) {
+			me = READ_VREG(HEVC_SHIFT_BYTE_COUNT);
+			if (((me & 0x80000000) == 0) &&
+				(vdec->input.streaming_rp & 0x80000000))
+				me += 1ULL << 32;
+			other = vdec_get_associate(vdec)->input.streaming_rp;
+			if (me > other) {
+				WRITE_PARSER_REG(PARSER_VIDEO_RP,
+					vdec_get_associate(vdec)->
+					input.swap_rp);
+				return;
+			}
+
+			WRITE_PARSER_REG(PARSER_VIDEO_RP,
+				READ_VREG(HEVC_STREAM_RD_PTR));
+		}
+	} else if (vdec->input.target == VDEC_INPUT_TARGET_VLD) {
+		WRITE_PARSER_REG(PARSER_VIDEO_RP,
+			READ_VREG(VLD_MEM_VIFIFO_RP));
+	} else if (vdec->input.target == VDEC_INPUT_TARGET_HEVC) {
+		WRITE_PARSER_REG(PARSER_VIDEO_RP,
+			READ_VREG(HEVC_STREAM_RD_PTR));
+	}
+}
+
+static void vdec_sync_input_write(struct vdec_s *vdec)
+{
+	if (!vdec_stream_based(vdec))
+		return;
+
+	if (vdec->input.target == VDEC_INPUT_TARGET_VLD) {
+		WRITE_VREG(VLD_MEM_VIFIFO_WP,
+			READ_PARSER_REG(PARSER_VIDEO_WP));
+	} else if (vdec->input.target == VDEC_INPUT_TARGET_HEVC) {
+		WRITE_VREG(HEVC_STREAM_WR_PTR,
+			READ_PARSER_REG(PARSER_VIDEO_WP));
+	}
+}
+
 /*
 *get next frame from input chain
 */
@@ -425,11 +547,9 @@ EXPORT_SYMBOL(vdec_write_vframe);
  */
 #define VLD_PADDING_SIZE 1024
 #define HEVC_PADDING_SIZE (1024*16)
-#define FIFO_ALIGN 8
 int vdec_prepare_input(struct vdec_s *vdec, struct vframe_chunk_s **p)
 {
-	struct vdec_input_s *input = (vdec->master) ?
-		&vdec->master->input : &vdec->input;
+	struct vdec_input_s *input = &vdec->input;
 	struct vframe_chunk_s *chunk = NULL;
 	struct vframe_block_list_s *block = NULL;
 	int dummy;
@@ -442,7 +562,7 @@ int vdec_prepare_input(struct vdec_s *vdec, struct vframe_chunk_s **p)
 		WRITE_VREG(DOS_SW_RESET0, (1<<5) | (1<<4) | (1<<3));
 		WRITE_VREG(DOS_SW_RESET0, 0);
 
-		dummy = READ_MPEG_REG(RESET0_REGISTER);
+		dummy = READ_RESET_REG(RESET0_REGISTER);
 		WRITE_VREG(POWER_CTL_VLD, 1 << 4);
 	} else if (input->target == VDEC_INPUT_TARGET_HEVC) {
 #if 0
@@ -492,7 +612,7 @@ int vdec_prepare_input(struct vdec_s *vdec, struct vframe_chunk_s **p)
 					block->size - 8);
 			WRITE_VREG(VLD_MEM_VIFIFO_CURR_PTR,
 					round_down(block->start + chunk->offset,
-						FIFO_ALIGN));
+						VDEC_FIFO_ALIGN));
 
 			WRITE_VREG(VLD_MEM_VIFIFO_CONTROL, 1);
 			WRITE_VREG(VLD_MEM_VIFIFO_CONTROL, 0);
@@ -501,13 +621,14 @@ int vdec_prepare_input(struct vdec_s *vdec, struct vframe_chunk_s **p)
 			WRITE_VREG(VLD_MEM_VIFIFO_BUF_CNTL, 2);
 			WRITE_VREG(VLD_MEM_VIFIFO_RP,
 					round_down(block->start + chunk->offset,
-						FIFO_ALIGN));
+						VDEC_FIFO_ALIGN));
 			dummy = chunk->offset + chunk->size +
 				VLD_PADDING_SIZE;
 			if (dummy >= block->size)
 				dummy -= block->size;
 			WRITE_VREG(VLD_MEM_VIFIFO_WP,
-				round_down(block->start + dummy, FIFO_ALIGN));
+				round_down(block->start + dummy,
+					VDEC_FIFO_ALIGN));
 
 			WRITE_VREG(VLD_MEM_VIFIFO_BUF_CNTL, 3);
 			WRITE_VREG(VLD_MEM_VIFIFO_BUF_CNTL, 2);
@@ -526,7 +647,8 @@ int vdec_prepare_input(struct vdec_s *vdec, struct vframe_chunk_s **p)
 			if (dummy >= block->size)
 				dummy -= block->size;
 			WRITE_VREG(HEVC_STREAM_WR_PTR,
-				round_down(block->start + dummy, FIFO_ALIGN));
+				round_down(block->start + dummy,
+					VDEC_FIFO_ALIGN));
 
 			/* set endian */
 			SET_VREG_MASK(HEVC_STREAM_CONTROL, 7 << 4);
@@ -536,16 +658,38 @@ int vdec_prepare_input(struct vdec_s *vdec, struct vframe_chunk_s **p)
 		return chunk->size;
 
 	} else {
+		/* stream based */
 		u32 rp = 0, wp = 0, fifo_len = 0;
 		int size;
-		/* stream based */
-		if (input->swap_valid) {
+		bool swap_valid = input->swap_valid;
+		unsigned long swap_page_phys = input->swap_page_phys;
+
+		if (vdec_dual(vdec) &&
+			((vdec->flag & VDEC_FLAG_SELF_INPUT_CONTEXT) == 0)) {
+			/* keep using previous input context */
+			struct vdec_s *master = (vdec->slave) ?
+				vdec : vdec->master;
+		    if (master->input.last_swap_slave) {
+				swap_valid = master->slave->input.swap_valid;
+				swap_page_phys =
+					master->slave->input.swap_page_phys;
+			} else {
+				swap_valid = master->input.swap_valid;
+				swap_page_phys = master->input.swap_page_phys;
+			}
+		}
+
+		if (swap_valid) {
 			if (input->target == VDEC_INPUT_TARGET_VLD) {
+				if (vdec->format == VFORMAT_H264)
+					SET_VREG_MASK(POWER_CTL_VLD,
+						(1 << 9));
+
 				WRITE_VREG(VLD_MEM_VIFIFO_CONTROL, 0);
 
 				/* restore read side */
 				WRITE_VREG(VLD_MEM_SWAP_ADDR,
-					page_to_phys(input->swap_page));
+					swap_page_phys);
 				WRITE_VREG(VLD_MEM_SWAP_CTL, 1);
 
 				while (READ_VREG(VLD_MEM_SWAP_CTL) & (1<<7))
@@ -563,9 +707,9 @@ int vdec_prepare_input(struct vdec_s *vdec, struct vframe_chunk_s **p)
 				WRITE_VREG(VLD_MEM_VIFIFO_CONTROL,
 					(0x11 << 16) | (1<<10));
 
-				/* update write side */
-				WRITE_VREG(VLD_MEM_VIFIFO_WP,
-					READ_MPEG_REG(PARSER_VIDEO_WP));
+				/* sync with front end */
+				vdec_sync_input_read(vdec);
+				vdec_sync_input_write(vdec);
 
 				wp = READ_VREG(VLD_MEM_VIFIFO_WP);
 			} else if (input->target == VDEC_INPUT_TARGET_HEVC) {
@@ -573,7 +717,7 @@ int vdec_prepare_input(struct vdec_s *vdec, struct vframe_chunk_s **p)
 
 				/* restore read side */
 				WRITE_VREG(HEVC_STREAM_SWAP_ADDR,
-					page_to_phys(input->swap_page));
+					swap_page_phys);
 				WRITE_VREG(HEVC_STREAM_SWAP_CTRL, 1);
 
 				while (READ_VREG(HEVC_STREAM_SWAP_CTRL)
@@ -592,11 +736,13 @@ int vdec_prepare_input(struct vdec_s *vdec, struct vframe_chunk_s **p)
 
 				/* enable */
 
-				/* update write side */
-				WRITE_VREG(HEVC_STREAM_WR_PTR,
-					READ_MPEG_REG(PARSER_VIDEO_WP));
+				/* sync with front end */
+				vdec_sync_input_read(vdec);
+				vdec_sync_input_write(vdec);
 
 				wp = READ_VREG(HEVC_STREAM_WR_PTR);
+
+				/*pr_info("vdec: restore context\r\n");*/
 			}
 
 		} else {
@@ -615,7 +761,7 @@ int vdec_prepare_input(struct vdec_s *vdec, struct vframe_chunk_s **p)
 				WRITE_VREG(VLD_MEM_VIFIFO_BUF_CNTL, 2);
 				WRITE_VREG(VLD_MEM_VIFIFO_RP, input->start);
 				WRITE_VREG(VLD_MEM_VIFIFO_WP,
-					READ_MPEG_REG(PARSER_VIDEO_WP));
+					READ_PARSER_REG(PARSER_VIDEO_WP));
 
 				rp = READ_VREG(VLD_MEM_VIFIFO_RP);
 
@@ -633,7 +779,7 @@ int vdec_prepare_input(struct vdec_s *vdec, struct vframe_chunk_s **p)
 				WRITE_VREG(HEVC_STREAM_RD_PTR,
 					input->start);
 				WRITE_VREG(HEVC_STREAM_WR_PTR,
-					READ_MPEG_REG(PARSER_VIDEO_WP));
+					READ_PARSER_REG(PARSER_VIDEO_WP));
 
 				rp = READ_VREG(HEVC_STREAM_RD_PTR);
 				wp = READ_VREG(HEVC_STREAM_WR_PTR);
@@ -678,10 +824,68 @@ void vdec_enable_input(struct vdec_s *vdec)
 }
 EXPORT_SYMBOL(vdec_enable_input);
 
+int vdec_set_input_buffer(struct vdec_s *vdec, u32 start, u32 size)
+{
+	int r = vdec_input_set_buffer(&vdec->input, start, size);
+
+	if (r)
+		return r;
+
+	if (vdec->slave)
+		r = vdec_input_set_buffer(&vdec->slave->input, start, size);
+
+	return r;
+}
+EXPORT_SYMBOL(vdec_set_input_buffer);
+
+/*
+ * vdec_eos returns the possibility that there are
+ * more input can be used by decoder through vdec_prepare_input
+ * Note: this function should be called prior to vdec_vframe_dirty
+ * by decoder driver to determine if EOS happens for stream based
+ * decoding when there is no sufficient data for a frame
+ */
+bool vdec_has_more_input(struct vdec_s *vdec)
+{
+	struct vdec_input_s *input = &vdec->input;
+
+	if (!input->eos)
+		return true;
+
+	if (input_frame_based(input))
+		return vdec_input_next_input_chunk(input) != NULL;
+	else {
+		if (input->target == VDEC_INPUT_TARGET_VLD)
+			return READ_VREG(VLD_MEM_VIFIFO_WP) !=
+				READ_PARSER_REG(PARSER_VIDEO_WP);
+		else {
+			return (READ_VREG(HEVC_STREAM_WR_PTR) & ~0x3) !=
+				(READ_PARSER_REG(PARSER_VIDEO_WP) & ~0x3);
+		}
+	}
+}
+EXPORT_SYMBOL(vdec_has_more_input);
+
+void vdec_set_prepare_level(struct vdec_s *vdec, int level)
+{
+	vdec->input.prepare_level = level;
+}
+EXPORT_SYMBOL(vdec_set_prepare_level);
+
 void vdec_set_flag(struct vdec_s *vdec, u32 flag)
 {
 	vdec->flag = flag;
 }
+EXPORT_SYMBOL(vdec_set_flag);
+
+void vdec_set_eos(struct vdec_s *vdec, bool eos)
+{
+	vdec->input.eos = eos;
+
+	if (vdec->slave)
+		vdec->slave->input.eos = eos;
+}
+EXPORT_SYMBOL(vdec_set_eos);
 
 void vdec_set_next_sched(struct vdec_s *vdec, struct vdec_s *next_vdec)
 {
@@ -690,38 +894,99 @@ void vdec_set_next_sched(struct vdec_s *vdec, struct vdec_s *next_vdec)
 		next_vdec->sched = 1;
 	}
 }
+EXPORT_SYMBOL(vdec_set_next_sched);
+
+/*
+ * Swap Context:       S0     S1     S2     S3     S4
+ * Sample sequence:  M     S      M      M      S
+ * Master Context:     S0     S0     S2     S3     S3
+ * Slave context:      NA     S1     S1     S2     S4
+ *                                          ^
+ *                                          ^
+ *                                          ^
+ *                                    the tricky part
+ * If there are back to back decoding of master or slave
+ * then the context of the counter part should be updated
+ * with current decoder. In this example, S1 should be
+ * updated to S2.
+ * This is done by swap the swap_page and related info
+ * between two layers.
+ */
+static void vdec_borrow_input_context(struct vdec_s *vdec)
+{
+	struct page *swap_page;
+	unsigned long swap_page_phys;
+	struct vdec_input_s *me;
+	struct vdec_input_s *other;
+
+	if (!vdec_dual(vdec))
+		return;
+
+	me = &vdec->input;
+	other = &vdec_get_associate(vdec)->input;
+
+	/* swap the swap_context, borrow counter part's
+	 * swap context storage and update all related info.
+	 * After vdec_vframe_dirty, vdec_save_input_context
+	 * will be called to update current vdec's
+	 * swap context
+	 */
+	swap_page = other->swap_page;
+	other->swap_page = me->swap_page;
+	me->swap_page = swap_page;
+
+	swap_page_phys = other->swap_page_phys;
+	other->swap_page_phys = me->swap_page_phys;
+	me->swap_page_phys = swap_page_phys;
+
+	other->swap_rp = me->swap_rp;
+	other->streaming_rp = me->streaming_rp;
+	other->stream_cookie = me->stream_cookie;
+	other->swap_valid = me->swap_valid;
+}
+
 void vdec_vframe_dirty(struct vdec_s *vdec, struct vframe_chunk_s *chunk)
 {
 	if (chunk)
 		chunk->flag |= VFRAME_CHUNK_FLAG_CONSUMED;
 
 	if (vdec_stream_based(vdec)) {
-		if (vdec->slave &&
-			((vdec->slave->flag &
-			VDEC_FLAG_INPUT_KEEP_CONTEXT) == 0)) {
-			vdec->input.swap_needed = false;
-		} else
-			vdec->input.swap_needed = true;
-
-		if (vdec->input.target == VDEC_INPUT_TARGET_VLD) {
-			WRITE_MPEG_REG(PARSER_VIDEO_RP,
-				READ_VREG(VLD_MEM_VIFIFO_RP));
-			WRITE_VREG(VLD_MEM_VIFIFO_WP,
-				READ_MPEG_REG(PARSER_VIDEO_WP));
-		} else if (vdec->input.target == VDEC_INPUT_TARGET_HEVC) {
-			WRITE_MPEG_REG(PARSER_VIDEO_RP,
-				READ_VREG(HEVC_STREAM_RD_PTR));
-			WRITE_VREG(HEVC_STREAM_WR_PTR,
-				READ_MPEG_REG(PARSER_VIDEO_WP));
+		vdec->input.swap_needed = true;
+
+		if (vdec_dual(vdec)) {
+			vdec_get_associate(vdec)->input.dirty_count = 0;
+			vdec->input.dirty_count++;
+			if (vdec->input.dirty_count > 1) {
+				vdec->input.dirty_count = 1;
+				vdec_borrow_input_context(vdec);
+			}
 		}
+
+		/* for stream based mode, we update read and write pointer
+		 * also in case decoder wants to keep working on decoding
+		 * for more frames while input front end has more data
+		 */
+		vdec_sync_input_read(vdec);
+		vdec_sync_input_write(vdec);
+
+		vdec->need_more_data |= VDEC_NEED_MORE_DATA_DIRTY;
+		vdec->need_more_data &= ~VDEC_NEED_MORE_DATA;
 	}
 }
 EXPORT_SYMBOL(vdec_vframe_dirty);
 
+bool vdec_need_more_data(struct vdec_s *vdec)
+{
+	if (vdec_stream_based(vdec))
+		return vdec->need_more_data & VDEC_NEED_MORE_DATA;
+
+	return false;
+}
+EXPORT_SYMBOL(vdec_need_more_data);
+
 void vdec_save_input_context(struct vdec_s *vdec)
 {
-	struct vdec_input_s *input = (vdec->master) ?
-		&vdec->master->input : &vdec->input;
+	struct vdec_input_s *input = &vdec->input;
 
 #ifdef CONFIG_MULTI_DEC
 	vdec_profile(vdec, VDEC_PROFILE_EVENT_SAVE_INPUT);
@@ -733,16 +998,22 @@ void vdec_save_input_context(struct vdec_s *vdec)
 	if (input_stream_based(input) && (input->swap_needed)) {
 		if (input->target == VDEC_INPUT_TARGET_VLD) {
 			WRITE_VREG(VLD_MEM_SWAP_ADDR,
-				page_to_phys(input->swap_page));
+				input->swap_page_phys);
 			WRITE_VREG(VLD_MEM_SWAP_CTL, 3);
 			while (READ_VREG(VLD_MEM_SWAP_CTL) & (1<<7))
 				;
 			WRITE_VREG(VLD_MEM_SWAP_CTL, 0);
 			vdec->input.stream_cookie =
 				READ_VREG(VLD_MEM_VIFIFO_WRAP_COUNT);
+			vdec->input.swap_rp =
+				READ_VREG(VLD_MEM_VIFIFO_RP);
+			vdec->input.total_rd_count =
+				(u64)vdec->input.stream_cookie *
+				vdec->input.size + vdec->input.swap_rp -
+				READ_VREG(VLD_MEM_VIFIFO_BYTES_AVAIL);
 		} else if (input->target == VDEC_INPUT_TARGET_HEVC) {
 			WRITE_VREG(HEVC_STREAM_SWAP_ADDR,
-				page_to_phys(input->swap_page));
+				input->swap_page_phys);
 			WRITE_VREG(HEVC_STREAM_SWAP_CTRL, 3);
 
 			while (READ_VREG(HEVC_STREAM_SWAP_CTRL) & (1<<7))
@@ -751,16 +1022,29 @@ void vdec_save_input_context(struct vdec_s *vdec)
 
 			vdec->input.stream_cookie =
 				READ_VREG(HEVC_SHIFT_BYTE_COUNT);
+			vdec->input.swap_rp =
+				READ_VREG(HEVC_STREAM_RD_PTR);
+			if (((vdec->input.stream_cookie & 0x80000000) == 0) &&
+				(vdec->input.streaming_rp & 0x80000000))
+				vdec->input.streaming_rp += 1ULL << 32;
+			vdec->input.streaming_rp &= 0xffffffffULL << 32;
+			vdec->input.streaming_rp |= vdec->input.stream_cookie;
+			vdec->input.total_rd_count = vdec->input.streaming_rp;
 		}
 
 		input->swap_valid = true;
+		input->swap_needed = false;
+		/*pr_info("vdec: save context\r\n");*/
 
-		if (input->target == VDEC_INPUT_TARGET_VLD)
-			WRITE_MPEG_REG(PARSER_VIDEO_RP,
-				READ_VREG(VLD_MEM_VIFIFO_RP));
-		else
-			WRITE_MPEG_REG(PARSER_VIDEO_RP,
-				READ_VREG(HEVC_STREAM_RD_PTR));
+		vdec_sync_input_read(vdec);
+
+		if (vdec_dual(vdec)) {
+			struct vdec_s *master = (vdec->slave) ?
+				vdec : vdec->master;
+			master->input.last_swap_slave = (master->slave == vdec);
+			/* pr_info("master->input.last_swap_slave = %d\n",
+				master->input.last_swap_slave); */
+		}
 	}
 }
 EXPORT_SYMBOL(vdec_save_input_context);
@@ -781,20 +1065,42 @@ void vdec_clean_input(struct vdec_s *vdec)
 }
 EXPORT_SYMBOL(vdec_clean_input);
 
-const char *vdec_status_str(struct vdec_s *vdec)
+int vdec_sync_input(struct vdec_s *vdec)
 {
-	switch (vdec->status) {
-	case VDEC_STATUS_UNINITIALIZED:
-		return "VDEC_STATUS_UNINITIALIZED";
-	case VDEC_STATUS_DISCONNECTED:
-		return "VDEC_STATUS_DISCONNECTED";
-	case VDEC_STATUS_CONNECTED:
-		return "VDEC_STATUS_CONNECTED";
-	case VDEC_STATUS_ACTIVE:
-		return "VDEC_STATUS_ACTIVE";
-	default:
-		return "invalid status";
+	struct vdec_input_s *input = &vdec->input;
+	u32 rp = 0, wp = 0, fifo_len = 0;
+	int size;
+
+	vdec_sync_input_read(vdec);
+	vdec_sync_input_write(vdec);
+	if (input->target == VDEC_INPUT_TARGET_VLD) {
+		rp = READ_VREG(VLD_MEM_VIFIFO_RP);
+		wp = READ_VREG(VLD_MEM_VIFIFO_WP);
+
+	} else if (input->target == VDEC_INPUT_TARGET_HEVC) {
+		rp = READ_VREG(HEVC_STREAM_RD_PTR);
+		wp = READ_VREG(HEVC_STREAM_WR_PTR);
+		fifo_len = (READ_VREG(HEVC_STREAM_FIFO_CTL)
+				>> 16) & 0x7f;
+	}
+	if (wp >= rp)
+		size = wp - rp + fifo_len;
+	else
+		size = wp + input->size - rp + fifo_len;
+	if (size < 0) {
+		pr_info("%s error: input->size %x wp %x rp %x fifo_len %x => size %x\r\n",
+			__func__, input->size, wp, rp, fifo_len, size);
+		size = 0;
 	}
+	return size;
+
+}
+EXPORT_SYMBOL(vdec_sync_input);
+
+const char *vdec_status_str(struct vdec_s *vdec)
+{
+	return vdec->status < ARRAY_SIZE(vdec_status_string) ?
+		vdec_status_string[vdec->status] : "INVALID";
 }
 
 const char *vdec_type_str(struct vdec_s *vdec)
@@ -817,6 +1123,7 @@ const char *vdec_device_name_str(struct vdec_s *vdec)
 {
 	return vdec_device_name[vdec->format * 2 + 1];
 }
+EXPORT_SYMBOL(vdec_device_name_str);
 
 void walk_vdec_core_list(char *s)
 {
@@ -841,11 +1148,15 @@ void walk_vdec_core_list(char *s)
 }
 EXPORT_SYMBOL(walk_vdec_core_list);
 
-/* insert vdec to vdec_core for scheduling */
+/* insert vdec to vdec_core for scheduling,
+ * for dual running decoders, connect/disconnect always runs in pairs
+ */
 int vdec_connect(struct vdec_s *vdec)
 {
 	unsigned long flags;
 
+	//trace_vdec_connect(vdec);/*DEBUG_TMP*/
+
 	if (vdec->status != VDEC_STATUS_DISCONNECTED)
 		return 0;
 
@@ -884,6 +1195,7 @@ int vdec_disconnect(struct vdec_s *vdec)
 #ifdef CONFIG_MULTI_DEC
 	vdec_profile(vdec, VDEC_PROFILE_EVENT_DISCONNECT);
 #endif
+	//trace_vdec_disconnect(vdec);/*DEBUG_TMP*/
 
 	if ((vdec->status != VDEC_STATUS_CONNECTED) &&
 		(vdec->status != VDEC_STATUS_ACTIVE)) {
@@ -917,13 +1229,14 @@ EXPORT_SYMBOL(vdec_disconnect);
 /* release vdec structure */
 int vdec_destroy(struct vdec_s *vdec)
 {
-	if (!vdec->master)
-		vdec_input_release(&vdec->input);
+	//trace_vdec_destroy(vdec);/*DEBUG_TMP*/
+
+	vdec_input_release(&vdec->input);
 
 #ifdef CONFIG_MULTI_DEC
 	vdec_profile_flush(vdec);
 #endif
-
+	ida_simple_remove(&vdec_core->ida, vdec->id);
 	vfree(vdec);
 
 	atomic_dec(&vdec_core->vdec_nr);
@@ -948,26 +1261,6 @@ static const char *get_dev_name(bool use_legacy_vdec, int format)
 #endif
 }
 
-void vdec_free_cmabuf(void)
-{
-	mutex_lock(&vdec_mutex);
-
-	if (inited_vcodec_num > 0) {
-		mutex_unlock(&vdec_mutex);
-		return;
-	}
-
-	if (vdec_mem_alloced_from_codec && vdec_core->mem_start) {
-		codec_mm_free_for_dma(MEM_NAME, vdec_core->mem_start);
-		vdec_cma_page = NULL;
-		vdec_core->mem_start = reserved_mem_start;
-		vdec_core->mem_end = reserved_mem_end;
-		pr_info("force free vdec memory\n");
-	}
-
-	mutex_unlock(&vdec_mutex);
-}
-
 /*
 *register vdec_device
  * create output, vfm or create ionvideo output
@@ -976,19 +1269,8 @@ s32 vdec_init(struct vdec_s *vdec, int is_4k)
 {
 	int r = 0;
 	struct vdec_s *p = vdec;
-	int retry_num = 0;
-	int more_buffers = 0;
 	const char *dev_name;
-
-	if (is_4k && vdec->format < VFORMAT_H264) {
-		/*
-		*old decoder don't support 4k
-		*	but size is bigger;
-		*	clear 4k flag, and used more buffers;
-		*/
-		more_buffers = 1;
-		is_4k = 0;
-	}
+	int id = PLATFORM_DEVID_AUTO;/*if have used my self*/
 
 	dev_name = get_dev_name(vdec_single(vdec), vdec->format);
 
@@ -1012,36 +1294,6 @@ s32 vdec_init(struct vdec_s *vdec, int is_4k)
 		}
 	}
 
-	if (vdec_single(vdec) &&
-		((vdec->format == VFORMAT_H264_4K2K) ||
-		(vdec->format == VFORMAT_HEVC && is_4k))) {
-		try_free_keep_video(0);
-	}
-
-	/*
-	*when blackout_policy was set, vdec would not free cma buffer, if
-	*	current vformat require larger buffer size than current
-	*	buf size, reallocated it
-	*/
-	if (vdec_single(vdec) &&
-		((vdec_core->mem_start != vdec_core->mem_end &&
-			vdec_core->mem_end - vdec_core->mem_start + 1 <
-			vdec_default_buf_size[vdec->format] * SZ_1M))) {
-#ifdef CONFIG_MULTI_DEC
-		pr_info("current vdec size %ld, vformat %d need size %d\n",
-			vdec_core->mem_end - vdec_core->mem_start,
-			vdec->format,
-			vdec_default_buf_size[vdec->format * 2] * SZ_1M);
-#else
-		pr_info("current vdec size %ld, vformat %d need size %d\n",
-			vdec_core->mem_end - vdec_core->mem_start,
-			vdec->format,
-			vdec_default_buf_size[vdec->format] * SZ_1M);
-#endif
-		try_free_keep_video(0);
-		vdec_free_cmabuf();
-	}
-
 	mutex_lock(&vdec_mutex);
 	inited_vcodec_num++;
 	mutex_unlock(&vdec_mutex);
@@ -1056,137 +1308,14 @@ s32 vdec_init(struct vdec_s *vdec, int is_4k)
 	p->get_canvas = get_canvas;
 	/* todo */
 	if (!vdec_dual(vdec))
-	p->use_vfm_path = vdec_stream_based(vdec);
-
-	if (vdec_single(vdec)) {
-		pr_info("vdec_dev_reg.mem[0x%lx -- 0x%lx]\n",
-			vdec_core->mem_start,
-			vdec_core->mem_end);
-		p->mem_start = vdec_core->mem_start;
-		p->mem_end = vdec_core->mem_end;
-	}
-
-	/* allocate base memory for decoder instance */
-	while ((p->mem_start == p->mem_end) && (vdec_single(vdec))) {
-		int alloc_size;
-
-#ifdef CONFIG_MULTI_DEC
-		alloc_size =
-			vdec_default_buf_size[vdec->format * 2 + 1]
-			* SZ_1M;
-#else
-		alloc_size = vdec_default_buf_size[vdec->format] * SZ_1M;
-#endif
-		if (alloc_size == 0)
-			break;/*alloc end*/
-		if (is_4k) {
-			/*used 264 4k's setting for 265.*/
-#ifdef CONFIG_MULTI_DEC
-			int m4k_size =
-				vdec_default_buf_size[VFORMAT_H264_4K2K * 2] *
-				SZ_1M;
-#else
-			int m4k_size =
-				vdec_default_buf_size[VFORMAT_H264_4K2K] *
-				SZ_1M;
-#endif
-			if (get_cpu_type() >= MESON_CPU_MAJOR_ID_GXTVBB)
-				m4k_size = 32 * SZ_1M;
-			if ((m4k_size > 0) && (m4k_size < 200 * SZ_1M))
-				alloc_size = m4k_size;
-
-#ifdef VP9_10B_MMU
-			if ((vdec->format == VFORMAT_VP9) &&
-				(get_cpu_type() >= MESON_CPU_MAJOR_ID_GXL)) {
-#ifdef CONFIG_MULTI_DEC
-				if (p->use_vfm_path)
-					alloc_size =
-					vdec_default_buf_size[VFORMAT_VP9 * 2]
-					* SZ_1M;
-				else
-					alloc_size =
-					vdec_default_buf_size[VFORMAT_VP9
-						* 2 + 1] * SZ_1M;
-
-#else
-				alloc_size =
-				vdec_default_buf_size[VFORMAT_VP9] * SZ_1M;
-#endif
-			}
-#endif
-		} else if (more_buffers) {
-			alloc_size = alloc_size + 16 * SZ_1M;
-		}
-
-		if ((vdec->format == VFORMAT_HEVC)
-			&& get_mmu_mode()
-			&& (get_cpu_type() >= MESON_CPU_MAJOR_ID_GXL)) {
-#ifdef CONFIG_MULTI_DEC
-			if (p->use_vfm_path)
-				alloc_size = 33 * SZ_1M;
-			else
-				alloc_size = 33 * SZ_1M;
-#else
-			alloc_size = 33 * SZ_1M;
-#endif
-		}
-
-		if ((vdec->format == VFORMAT_H264)
-			&& (get_cpu_type() >= MESON_CPU_MAJOR_ID_GXL)
-			&& codec_mm_get_total_size() <= 80 * SZ_1M) {
-#ifdef CONFIG_MULTI_DEC
-			if (p->use_vfm_path)
-				alloc_size = 32 * SZ_1M;
-			else
-				alloc_size = 32 * SZ_1M;
-#else
-			alloc_size = 32 * SZ_1M;
-#endif
-		}
-
-
-		p->mem_start = codec_mm_alloc_for_dma(MEM_NAME,
-			alloc_size / PAGE_SIZE, 4 + PAGE_SHIFT,
-			CODEC_MM_FLAGS_CMA_CLEAR | CODEC_MM_FLAGS_CPU |
-			CODEC_MM_FLAGS_FOR_VDECODER);
-		if (!p->mem_start) {
-			if (retry_num < 1) {
-				pr_err("vdec base CMA allocation failed,try again\\n");
-				retry_num++;
-				try_free_keep_video(0);
-				continue;/*retry alloc*/
-			}
-			pr_err("vdec base CMA allocation failed.\n");
-
-			mutex_lock(&vdec_mutex);
-			inited_vcodec_num--;
-			mutex_unlock(&vdec_mutex);
-
-			return -ENOMEM;
-		}
-
-		p->mem_end = p->mem_start + alloc_size - 1;
-		pr_info("vdec base memory alloced [%p -- %p]\n",
-			(void *)p->mem_start,
-			(void *)p->mem_end);
-
-		break;/*alloc end*/
-	}
-
-	if (vdec_single(vdec)) {
-		vdec_core->mem_start = p->mem_start;
-		vdec_core->mem_end = p->mem_end;
-		vdec_mem_alloced_from_codec = 1;
-	}
-
-/*alloc end:*/
+		p->use_vfm_path = vdec_stream_based(vdec);
 	/* vdec_dev_reg.flag = 0; */
-
-	p->dev =
-		platform_device_register_data(
+	if (vdec->id >= 0)
+		id = vdec->id;
+	p->dev = platform_device_register_data(
 				&vdec_core->vdec_core_platform_device->dev,
 				dev_name,
-				PLATFORM_DEVID_AUTO,
+				id,
 				&p, sizeof(struct vdec_s *));
 
 	if (IS_ERR(p->dev)) {
@@ -1199,6 +1328,12 @@ s32 vdec_init(struct vdec_s *vdec, int is_4k)
 		mutex_unlock(&vdec_mutex);
 
 		goto error;
+	} else if (!p->dev->dev.driver) {
+		pr_info("vdec: Decoder device %s driver probe failed.\n",
+			dev_name);
+		r = -ENODEV;
+
+		goto error;
 	}
 
 	if ((p->type == VDEC_TYPE_FRAME_BLOCK) && (p->run == NULL)) {
@@ -1214,6 +1349,7 @@ s32 vdec_init(struct vdec_s *vdec, int is_4k)
 
 	if (p->use_vfm_path) {
 		vdec->vf_receiver_inst = -1;
+		vdec->vfm_map_id[0] = 0;
 	} else if (!vdec_dual(vdec)) {
 		/* create IONVIDEO instance and connect decoder's
 		 * vf_provider interface to it
@@ -1230,8 +1366,8 @@ s32 vdec_init(struct vdec_s *vdec, int is_4k)
 		}
 		if (p->frame_base_video_path == FRAME_BASE_PATH_IONVIDEO) {
 #if 1
-		//r = ionvideo_alloc_map(&vdec->vf_receiver_name,
-				//&vdec->vf_receiver_inst);//DEBUG_TMP
+			/*r = ionvideo_assign_map(&vdec->vf_receiver_name,
+					&vdec->vf_receiver_inst);*/ /*DEBUG_TMP*/
 #else
 		/*
 		 * temporarily just use decoder instance ID as iondriver ID
@@ -1254,29 +1390,25 @@ s32 vdec_init(struct vdec_s *vdec, int is_4k)
 			goto error;
 		}
 
-		snprintf(vdec->vfm_map_chain, VDEC_MAP_NAME_SIZE,
-			"%s %s", vdec->vf_provider_name,
-			vdec->vf_receiver_name);
-		snprintf(vdec->vfm_map_id, VDEC_MAP_NAME_SIZE,
-			"%s-%s", vdec->vf_provider_name,
-			vdec->vf_receiver_name);
-
+			snprintf(vdec->vfm_map_chain, VDEC_MAP_NAME_SIZE,
+				"%s %s", vdec->vf_provider_name,
+				vdec->vf_receiver_name);
+			snprintf(vdec->vfm_map_id, VDEC_MAP_NAME_SIZE,
+				"vdec-map-%d", vdec->id);
 		} else if (p->frame_base_video_path ==
 				FRAME_BASE_PATH_AMLVIDEO_AMVIDEO) {
 			snprintf(vdec->vfm_map_chain, VDEC_MAP_NAME_SIZE,
 				"%s %s", vdec->vf_provider_name,
-				"amlvideo.0 amvideo");
+				"amlvideo deinterlace amvideo");
 			snprintf(vdec->vfm_map_id, VDEC_MAP_NAME_SIZE,
-				"%s-%s", vdec->vf_provider_name,
-				"amlvideo.0 amvideo");
+				"vdec-map-%d", vdec->id);
 		} else if (p->frame_base_video_path ==
 				FRAME_BASE_PATH_AMLVIDEO1_AMVIDEO2) {
 			snprintf(vdec->vfm_map_chain, VDEC_MAP_NAME_SIZE,
 				"%s %s", vdec->vf_provider_name,
 				"ppmgr amlvideo.1 amvide2");
 			snprintf(vdec->vfm_map_id, VDEC_MAP_NAME_SIZE,
-				"%s-%s", vdec->vf_provider_name,
-				"ppmgr amlvideo.1 amvide2");
+				"vdec-map-%d", vdec->id);
 		}
 
 		if (vfm_map_add(vdec->vfm_map_id,
@@ -1318,10 +1450,28 @@ s32 vdec_init(struct vdec_s *vdec, int is_4k)
 		vf_notify_receiver(p->vf_provider_name,
 			VFRAME_EVENT_PROVIDER_START,
 			vdec);
+
+		if (vdec_core->hint_fr_vdec == NULL)
+			vdec_core->hint_fr_vdec = vdec;
+
+		if (vdec_core->hint_fr_vdec == vdec) {
+			if (p->sys_info->rate != 0) {
+				vf_notify_receiver(p->vf_provider_name,
+					VFRAME_EVENT_PROVIDER_FR_HINT,
+					(void *)
+					((unsigned long)p->sys_info->rate));
+				vdec->fr_hint_state = VDEC_HINTED;
+			} else {
+				vdec->fr_hint_state = VDEC_NEED_HINT;
+			}
+		}
 	}
 
 	pr_info("vdec_init, vf_provider_name = %s\n", p->vf_provider_name);
-
+	vdec_input_prepare_bufs(/*prepared buffer for fast playing.*/
+		&vdec->input,
+		vdec->sys_info->width,
+		vdec->sys_info->height);
 	/* vdec is now ready to be active */
 	vdec_set_status(vdec, VDEC_STATUS_DISCONNECTED);
 
@@ -1332,59 +1482,58 @@ error:
 }
 EXPORT_SYMBOL(vdec_init);
 
+/* vdec_create/init/release/destroy are applied to both dual running decoders
+ */
 void vdec_release(struct vdec_s *vdec)
 {
+	//trace_vdec_release(vdec);/*DEBUG_TMP*/
+
 	vdec_disconnect(vdec);
 
-	if (vdec->vframe_provider.name)
+	if (vdec->vframe_provider.name) {
+		if (!vdec_single(vdec)) {
+			if (vdec_core->hint_fr_vdec == vdec
+			&& vdec->fr_hint_state == VDEC_HINTED)
+				vf_notify_receiver(
+					vdec->vf_provider_name,
+					VFRAME_EVENT_PROVIDER_FR_END_HINT,
+					NULL);
+			vdec->fr_hint_state = VDEC_NO_NEED_HINT;
+		}
 		vf_unreg_provider(&vdec->vframe_provider);
+	}
 
 	if (vdec_core->vfm_vdec == vdec)
 		vdec_core->vfm_vdec = NULL;
 
+	if (vdec_core->hint_fr_vdec == vdec)
+		vdec_core->hint_fr_vdec = NULL;
+
 	if (vdec->vf_receiver_inst >= 0) {
 		if (vdec->vfm_map_id[0]) {
 			vfm_map_remove(vdec->vfm_map_id);
 			vdec->vfm_map_id[0] = 0;
 		}
-
-		/*
-		*vf_receiver_inst should be > 0 since 0 is
-		 * for either un-initialized vdec or a ionvideo
-		 * instance reserved for legacy path.
-		 */
-		//ionvideo_release_map(vdec->vf_receiver_inst);//DEBUG_TMP
 	}
 
 	platform_device_unregister(vdec->dev);
-
-	if (!vdec->use_vfm_path) {
-		if (vdec->mem_start) {
-			codec_mm_free_for_dma(MEM_NAME, vdec->mem_start);
-			vdec->mem_start = 0;
-			vdec->mem_end = 0;
-		}
-	} else if (delay_release-- <= 0 &&
-			!keep_vdec_mem &&
-			vdec_mem_alloced_from_codec &&
-			vdec_core->mem_start &&
-			get_blackout_policy()) {
-		codec_mm_free_for_dma(MEM_NAME, vdec_core->mem_start);
-		vdec_cma_page = NULL;
-		vdec_core->mem_start = reserved_mem_start;
-		vdec_core->mem_end = reserved_mem_end;
-	}
-
 	vdec_destroy(vdec);
 
 	mutex_lock(&vdec_mutex);
 	inited_vcodec_num--;
 	mutex_unlock(&vdec_mutex);
+
+	pr_info("vdec_release instance %p, total %d\n", vdec,
+		atomic_read(&vdec_core->vdec_nr));
 }
 EXPORT_SYMBOL(vdec_release);
 
+/* For dual running decoders, vdec_reset is only called with master vdec.
+ */
 int vdec_reset(struct vdec_s *vdec)
 {
+	//trace_vdec_reset(vdec); /*DEBUG_TMP*/
+
 	vdec_disconnect(vdec);
 
 	if (vdec->vframe_provider.name)
@@ -1417,6 +1566,17 @@ int vdec_reset(struct vdec_s *vdec)
 }
 EXPORT_SYMBOL(vdec_reset);
 
+void vdec_free_cmabuf(void)
+{
+	mutex_lock(&vdec_mutex);
+
+	if (inited_vcodec_num > 0) {
+		mutex_unlock(&vdec_mutex);
+		return;
+	}
+	mutex_unlock(&vdec_mutex);
+}
+
 static struct vdec_s *active_vdec(struct vdec_core_s *core)
 {
 	struct vdec_s *vdec;
@@ -1508,6 +1668,7 @@ static irqreturn_t vdec_thread_isr(int irq, void *dev_id)
 static inline bool vdec_ready_to_run(struct vdec_s *vdec)
 {
 	bool r;
+	struct vdec_input_s *input = &vdec->input;
 
 	if (vdec->status != VDEC_STATUS_CONNECTED)
 		return false;
@@ -1519,6 +1680,25 @@ static inline bool vdec_ready_to_run(struct vdec_s *vdec)
 		(vdec->sched == 0))
 		return false;
 
+	/* check streaming prepare level threshold if not EOS */
+	if (input && input_stream_based(input) && !input->eos) {
+		u32 rp, wp, level;
+
+		rp = READ_PARSER_REG(PARSER_VIDEO_RP);
+		wp = READ_PARSER_REG(PARSER_VIDEO_WP);
+		if (wp < rp)
+			level = input->size + wp - rp;
+		else
+			level = wp - rp;
+
+		if ((level < input->prepare_level) &&
+			(pts_get_rec_num(PTS_TYPE_VIDEO,
+				vdec->input.total_rd_count) < 2)) {
+			vdec->need_more_data |= VDEC_NEED_MORE_DATA;
+			return false;
+		}
+	}
+
 	if (step_mode) {
 		if ((step_mode & 0xff) != vdec->id)
 			return false;
@@ -1540,6 +1720,36 @@ static inline bool vdec_ready_to_run(struct vdec_s *vdec)
 	return r;
 }
 
+/*
+ * Set up secure protection for each decoder instance running.
+ * Note: The operation from REE side only resets memory access
+ * to a default policy and even a non_secure type will still be
+ * changed to secure type automatically when secure source is
+ * detected inside TEE.
+ * Perform need_more_data checking and set flag is decoder
+ * is not consuming data.
+ */
+static inline void vdec_prepare_run(struct vdec_s *vdec)
+{
+	struct vdec_input_s *input = &vdec->input;
+	int type = (vdec_secure(vdec)) ? DMC_DEV_TYPE_SECURE :
+			DMC_DEV_TYPE_NON_SECURE;
+
+	if (input->target == VDEC_INPUT_TARGET_VLD)
+		tee_config_device_secure(DMC_DEV_ID_VDEC, type);
+	else if (input->target == VDEC_INPUT_TARGET_HEVC)
+		tee_config_device_secure(DMC_DEV_ID_HEVC, type);
+
+	if (vdec_stream_based(vdec) &&
+		((vdec->need_more_data & VDEC_NEED_MORE_DATA_RUN) &&
+		(vdec->need_more_data & VDEC_NEED_MORE_DATA_DIRTY) == 0)) {
+		vdec->need_more_data |= VDEC_NEED_MORE_DATA;
+	}
+
+	vdec->need_more_data |= VDEC_NEED_MORE_DATA_RUN;
+	vdec->need_more_data &= ~VDEC_NEED_MORE_DATA_DIRTY;
+}
+
 /* struct vdec_core_shread manages all decoder instance in active list. When
  * a vdec is added into the active list, it can onlt be in two status:
  * VDEC_STATUS_CONNECTED(the decoder does not own HW resource and ready to run)
@@ -1549,7 +1759,6 @@ static inline bool vdec_ready_to_run(struct vdec_s *vdec)
  */
 static int vdec_core_thread(void *data)
 {
-	unsigned long flags;
 	struct vdec_core_s *core = (struct vdec_core_s *)data;
 
 	struct sched_param param = {.sched_priority = MAX_RT_PRIO - 1};
@@ -1597,7 +1806,7 @@ static int vdec_core_thread(void *data)
 		 * }
 		 */
 
-		flags = vdec_core_lock(core);
+		mutex_lock(&vdec_mutex);
 
 		/* check disconnected decoders */
 		list_for_each_entry_safe(vdec, tmp,
@@ -1655,7 +1864,7 @@ static int vdec_core_thread(void *data)
 			core->active_vdec = NULL;
 		}
 
-		vdec_core_unlock(core, flags);
+		mutex_unlock(&vdec_mutex);
 
 		/* start the vdec instance */
 		if ((vdec) && (vdec->status != VDEC_STATUS_ACTIVE)) {
@@ -1666,6 +1875,8 @@ static int vdec_core_thread(void *data)
 #ifdef CONFIG_MULTI_DEC
 			vdec_profile(vdec, VDEC_PROFILE_EVENT_RUN);
 #endif
+			vdec_prepare_run(vdec);
+
 			vdec->run(vdec, vdec_callback, core);
 		}
 
@@ -2144,6 +2355,53 @@ int vdec_source_changed(int format, int width, int height, int fps)
 }
 EXPORT_SYMBOL(vdec_source_changed);
 
+void hevc_reset_core(struct vdec_s *vdec)
+{
+	unsigned long flags;
+	WRITE_VREG(HEVC_STREAM_CONTROL, 0);
+	spin_lock_irqsave(&vdec_spin_lock, flags);
+	codec_dmcbus_write(DMC_REQ_CTRL,
+		codec_dmcbus_read(DMC_REQ_CTRL) & (~(1 << 4)));
+	spin_unlock_irqrestore(&vdec_spin_lock, flags);
+
+	while (!(codec_dmcbus_read(DMC_CHAN_STS)
+		& (1 << 4)))
+		;
+
+	if (input_frame_based(vdec))
+		WRITE_VREG(HEVC_STREAM_CONTROL, 0);
+
+		/*
+	 * 2: assist
+	 * 3: parser
+	 * 4: parser_state
+	 * 8: dblk
+	 * 11:mcpu
+	 * 12:ccpu
+	 * 13:ddr
+	 * 14:iqit
+	 * 15:ipp
+	 * 17:qdct
+	 * 18:mpred
+	 * 19:sao
+	 * 24:hevc_afifo
+	 */
+	WRITE_VREG(DOS_SW_RESET3,
+		(1<<3)|(1<<4)|(1<<8)|(1<<11)|
+		(1<<12)|(1<<13)|(1<<14)|(1<<15)|
+		(1<<17)|(1<<18)|(1<<19)|(1<<24));
+
+	WRITE_VREG(DOS_SW_RESET3, 0);
+
+
+	spin_lock_irqsave(&vdec_spin_lock, flags);
+	codec_dmcbus_write(DMC_REQ_CTRL,
+		codec_dmcbus_read(DMC_REQ_CTRL) | (1 << 4));
+	spin_unlock_irqrestore(&vdec_spin_lock, flags);
+
+}
+EXPORT_SYMBOL(hevc_reset_core);
+
 int vdec2_source_changed(int format, int width, int height, int fps)
 {
 	int ret = -1;
@@ -2191,26 +2449,6 @@ int hevc_source_changed(int format, int width, int height, int fps)
 }
 EXPORT_SYMBOL(hevc_source_changed);
 
-static enum vdec2_usage_e vdec2_usage = USAGE_NONE;
-void set_vdec2_usage(enum vdec2_usage_e usage)
-{
-	if (has_vdec2()) {
-		mutex_lock(&vdec_mutex);
-		vdec2_usage = usage;
-		mutex_unlock(&vdec_mutex);
-	}
-}
-EXPORT_SYMBOL(set_vdec2_usage);
-
-enum vdec2_usage_e get_vdec2_usage(void)
-{
-	if (has_vdec2())
-		return vdec2_usage;
-	else
-		return 0;
-}
-EXPORT_SYMBOL(get_vdec2_usage);
-
 static struct am_reg am_risc[] = {
 	{"MSP", 0x300},
 	{"MPSR", 0x301},
@@ -2659,8 +2897,10 @@ static ssize_t core_show(struct class *class, struct class_attribute *attr,
 
 		list_for_each_entry(vdec, &core->connected_vdec_list, list) {
 			pbuf += sprintf(pbuf,
-				"\tvdec (%p (%s)), status = %s,\ttype = %s\n",
-				vdec, vdec_device_name[vdec->format * 2],
+				"\tvdec.%d (%p (%s)), status = %s,\ttype = %s\n",
+				vdec->id,
+				vdec,
+				vdec_device_name[vdec->format * 2],
 				vdec_status_str(vdec),
 				vdec_type_str(vdec));
 		}
@@ -2669,6 +2909,142 @@ static ssize_t core_show(struct class *class, struct class_attribute *attr,
 	return pbuf - buf;
 }
 
+static ssize_t vdec_status_show(struct class *class,
+			struct class_attribute *attr, char *buf)
+{
+	char *pbuf = buf;
+	struct vdec_s *vdec;
+	struct vdec_info vs;
+	unsigned char vdec_num = 0;
+	struct vdec_core_s *core = vdec_core;
+	unsigned long flags = vdec_core_lock(vdec_core);
+
+	if (list_empty(&core->connected_vdec_list)) {
+		pbuf += sprintf(pbuf, "No vdec.\n");
+		goto out;
+	}
+
+	list_for_each_entry(vdec, &core->connected_vdec_list, list) {
+		if (VDEC_STATUS_CONNECTED == vdec->status) {
+			memset(&vs, 0, sizeof(vs));
+			if (vdec_status(vdec, &vs)) {
+				pbuf += sprintf(pbuf, "err.\n");
+				goto out;
+			}
+			pbuf += sprintf(pbuf,
+				"vdec channel %u statistics:\n",
+				vdec_num);
+			pbuf += sprintf(pbuf,
+				"%13s : %s\n", "device name",
+				vs.vdec_name);
+			pbuf += sprintf(pbuf,
+				"%13s : %u\n", "frame width",
+				vs.frame_width);
+			pbuf += sprintf(pbuf,
+				"%13s : %u\n", "frame height",
+				vs.frame_height);
+			pbuf += sprintf(pbuf,
+				"%13s : %u %s\n", "frame rate",
+				vs.frame_rate, "fps");
+			pbuf += sprintf(pbuf,
+				"%13s : %u %s\n", "bit rate",
+				vs.bit_rate / 1024 * 8, "kbps");
+			pbuf += sprintf(pbuf,
+				"%13s : %u\n", "status",
+				vs.status);
+			pbuf += sprintf(pbuf,
+				"%13s : %u\n", "frame dur",
+				vs.frame_dur);
+			pbuf += sprintf(pbuf,
+				"%13s : %u %s\n", "frame data",
+				vs.frame_data / 1024, "KB");
+			pbuf += sprintf(pbuf,
+				"%13s : %u\n", "frame count",
+				vs.frame_count);
+			pbuf += sprintf(pbuf,
+				"%13s : %u\n", "drop count",
+				vs.drop_frame_count);
+			pbuf += sprintf(pbuf,
+				"%13s : %u\n", "fra err count",
+				vs.error_frame_count);
+			pbuf += sprintf(pbuf,
+				"%13s : %u\n", "hw err count",
+				vs.error_count);
+			pbuf += sprintf(pbuf,
+				"%13s : %llu %s\n\n", "total data",
+				vs.total_data / 1024, "KB");
+
+			vdec_num++;
+		}
+	}
+out:
+	vdec_core_unlock(vdec_core, flags);
+	return pbuf - buf;
+}
+
+static ssize_t dump_vdec_blocks_show(struct class *class,
+			struct class_attribute *attr, char *buf)
+{
+	struct vdec_core_s *core = vdec_core;
+	char *pbuf = buf;
+
+	if (list_empty(&core->connected_vdec_list))
+		pbuf += sprintf(pbuf, "connected vdec list empty\n");
+	else {
+		struct vdec_s *vdec;
+		list_for_each_entry(vdec, &core->connected_vdec_list, list) {
+			pbuf += vdec_input_dump_blocks(&vdec->input,
+				pbuf, PAGE_SIZE - (pbuf - buf));
+		}
+	}
+
+	return pbuf - buf;
+}
+static ssize_t dump_vdec_chunks_show(struct class *class,
+			struct class_attribute *attr, char *buf)
+{
+	struct vdec_core_s *core = vdec_core;
+	char *pbuf = buf;
+
+	if (list_empty(&core->connected_vdec_list))
+		pbuf += sprintf(pbuf, "connected vdec list empty\n");
+	else {
+		struct vdec_s *vdec;
+		list_for_each_entry(vdec, &core->connected_vdec_list, list) {
+			pbuf += vdec_input_dump_chunks(&vdec->input,
+				pbuf, PAGE_SIZE - (pbuf - buf));
+		}
+	}
+
+	return pbuf - buf;
+}
+
+#if 0 /*DEBUG_TMP*/
+static ssize_t dump_decoder_state_show(struct class *class,
+			struct class_attribute *attr, char *buf)
+{
+	char *pbuf = buf;
+	struct vdec_s *vdec;
+	struct vdec_core_s *core = vdec_core;
+	unsigned long flags = vdec_core_lock(vdec_core);
+
+	if (list_empty(&core->connected_vdec_list)) {
+		pbuf += sprintf(pbuf, "No vdec.\n");
+	} else {
+		list_for_each_entry(vdec,
+			&core->connected_vdec_list, list) {
+			if ((vdec->status == VDEC_STATUS_CONNECTED
+				|| vdec->status == VDEC_STATUS_ACTIVE)
+				&& vdec->dump_state)
+					vdec->dump_state(vdec);
+		}
+	}
+	vdec_core_unlock(vdec_core, flags);
+
+	return pbuf - buf;
+}
+#endif
+
 static struct class_attribute vdec_class_attrs[] = {
 	__ATTR_RO(amrisc_regs),
 	__ATTR_RO(dump_trace),
@@ -2680,6 +3056,9 @@ static struct class_attribute vdec_class_attrs[] = {
 	__ATTR(keep_vdec_mem, S_IRUGO | S_IWUSR | S_IWGRP,
 	show_keep_vdec_mem, store_keep_vdec_mem),
 	__ATTR_RO(core),
+	__ATTR_RO(vdec_status),
+	__ATTR_RO(dump_vdec_blocks),
+	__ATTR_RO(dump_vdec_chunks),
 	__ATTR_NULL
 };
 
@@ -2688,31 +3067,6 @@ static struct class vdec_class = {
 		.class_attrs = vdec_class_attrs,
 	};
 
-
-/*
-*pre alloced enough memory for decoder
-*fast start.
-*/
-void pre_alloc_vdec_memory(void)
-{
-	if (!keep_vdec_mem || vdec_core->mem_start)
-		return;
-
-	vdec_core->mem_start = codec_mm_alloc_for_dma(MEM_NAME,
-		CMA_ALLOC_SIZE / PAGE_SIZE, 4 + PAGE_SHIFT,
-		CODEC_MM_FLAGS_CMA_CLEAR |
-		CODEC_MM_FLAGS_FOR_VDECODER);
-	if (!vdec_core->mem_start)
-		return;
-	pr_debug("vdec base memory alloced %p\n",
-	(void *)vdec_core->mem_start);
-
-	vdec_core->mem_end = vdec_core->mem_start + CMA_ALLOC_SIZE - 1;
-	vdec_mem_alloced_from_codec = 1;
-	delay_release = 3;
-}
-EXPORT_SYMBOL(pre_alloc_vdec_memory);
-
 struct device *get_vdec_device(void)
 {
 	return &vdec_core->vdec_core_platform_device->dev;
@@ -2770,26 +3124,14 @@ static int vdec_probe(struct platform_device *pdev)
 		/* set vdec dmc request to urgent */
 		WRITE_DMCREG(DMC_AM5_CHAN_CTRL, 0x3f203cf);
 	}
-	if (codec_mm_get_reserved_size() >= 48 * SZ_1M
-		&& codec_mm_get_reserved_size() <=  96 * SZ_1M) {
-#ifdef CONFIG_MULTI_DEC
-		vdec_default_buf_size[VFORMAT_H264_4K2K * 2] =
-			codec_mm_get_reserved_size() / SZ_1M;
-#else
-		vdec_default_buf_size[VFORMAT_H264_4K2K] =
-			codec_mm_get_reserved_size() / SZ_1M;
-#endif
-
-		/*all reserved size for prealloc*/
-	}
-	pre_alloc_vdec_memory();
-
 	INIT_LIST_HEAD(&vdec_core->connected_vdec_list);
 	spin_lock_init(&vdec_core->lock);
-
+	ida_init(&vdec_core->ida);
 	vdec_core->thread = kthread_run(vdec_core_thread, vdec_core,
 					"vdec-core");
 
+	vdec_core->vdec_core_wq = create_singlethread_workqueue("threadvdec");
+
 	return 0;
 }
 
@@ -2810,6 +3152,7 @@ static int vdec_remove(struct platform_device *pdev)
 
 	kthread_stop(vdec_core->thread);
 
+	destroy_workqueue(vdec_core->vdec_core_wq);
 	class_unregister(&vdec_class);
 
 	return 0;
@@ -2822,6 +3165,16 @@ static const struct of_device_id amlogic_vdec_dt_match[] = {
 	{},
 };
 
+static struct mconfig vdec_configs[] = {
+	MC_PI32("debugflags", &debugflags),
+	MC_PU32("debug_trace_num", &debug_trace_num),
+	MC_PI32("hevc_max_reset_count", &hevc_max_reset_count),
+	MC_PU32("clk_config", &clk_config),
+	MC_PI32("step_mode", &step_mode),
+	MC_PI32("poweron_clock_level", &poweron_clock_level),
+};
+static struct mconfig_node vdec_node;
+
 static struct platform_driver vdec_driver = {
 	.probe = vdec_probe,
 	.remove = vdec_remove,
@@ -2837,7 +3190,8 @@ int vdec_module_init(void)
 		pr_info("failed to register vdec module\n");
 		return -ENODEV;
 	}
-
+	INIT_REG_NODE_CONFIGS("media.decoder", &vdec_node,
+		"vdec", vdec_configs, CONFIG_FOR_RW);
 	return 0;
 }
 EXPORT_SYMBOL(vdec_module_init);
@@ -2855,7 +3209,8 @@ static int __init vdec_module_init(void)
 		pr_info("failed to register vdec module\n");
 		return -ENODEV;
 	}
-
+	INIT_REG_NODE_CONFIGS("media.decoder", &vdec_node,
+		"vdec", vdec_configs, CONFIG_FOR_RW);
 	return 0;
 }
 
@@ -2867,14 +3222,6 @@ static void __exit vdec_module_exit(void)
 
 static int vdec_mem_device_init(struct reserved_mem *rmem, struct device *dev)
 {
-	unsigned long start, end;
-
-	start = rmem->base;
-	end = rmem->base + rmem->size - 1;
-	pr_info("init vdec memsource %lx->%lx\n", start, end);
-
-	vdec_core->mem_start = start;
-	vdec_core->mem_end = end;
 	vdec_core->cma_dev = dev;
 
 	return 0;
@@ -2898,10 +3245,16 @@ module_param(debug_trace_num, uint, 0664);
 module_param(hevc_max_reset_count, int, 0664);
 module_param(clk_config, uint, 0664);
 module_param(step_mode, int, 0664);
+
+module_param(debugflags, uint, 0664);
+MODULE_PARM_DESC(debugflags, "\n vdec debugflags\n");
+
 /*
 *module_init(vdec_module_init);
 *module_exit(vdec_module_exit);
 */
+#define CREATE_TRACE_POINTS
+#include "vdec_trace.h"
 MODULE_DESCRIPTION("AMLOGIC vdec driver");
 MODULE_LICENSE("GPL");
 MODULE_AUTHOR("Tim Yao <timyao@amlogic.com>");
diff --git a/drivers/frame_provider/decoder/utils/vdec.h b/drivers/frame_provider/decoder/utils/vdec.h
index cb63f8d..c3d785e 100644
--- a/drivers/frame_provider/decoder/utils/vdec.h
+++ b/drivers/frame_provider/decoder/utils/vdec.h
@@ -43,6 +43,8 @@ void vdec_module_exit(void);
 
 #define DEC_FLAG_HEVC_WORKAROUND 0x01
 
+#define VDEC_FIFO_ALIGN 8
+
 enum vdec_type_e {
 	VDEC_1 = 0,
 	VDEC_HCODEC,
@@ -81,6 +83,12 @@ enum vdec_irq_num {
 	VDEC_IRQ_2,
 	VDEC_IRQ_MAX,
 };
+
+enum vdec_fr_hint_state {
+	VDEC_NO_NEED_HINT = 0,
+	VDEC_NEED_HINT,
+	VDEC_HINTED,
+};
 extern s32 vdec_request_threaded_irq(enum vdec_irq_num num,
 			irq_handler_t handler,
 			irq_handler_t thread_fn,
@@ -90,15 +98,6 @@ extern s32 vdec_request_irq(enum vdec_irq_num num, irq_handler_t handler,
 	const char *devname, void *dev);
 extern void vdec_free_irq(enum vdec_irq_num num, void *dev);
 
-enum vdec2_usage_e {
-	USAGE_NONE,
-	USAGE_DEC_4K2K,
-	USAGE_ENCODE,
-};
-
-extern void set_vdec2_usage(enum vdec2_usage_e usage);
-extern enum vdec2_usage_e get_vdec2_usage(void);
-
 extern void dma_contiguous_early_fixup(phys_addr_t base, unsigned long size);
 unsigned int get_vdec_clk_config_settings(void);
 void update_vdec_clk_config_settings(unsigned int config);
@@ -133,9 +132,14 @@ enum vformat_t;
 
 #define VDEC_PROVIDER_NAME_SIZE 16
 #define VDEC_RECEIVER_NAME_SIZE 16
-#define VDEC_MAP_NAME_SIZE      40
+#define VDEC_MAP_NAME_SIZE      45
+
+#define VDEC_FLAG_OTHER_INPUT_CONTEXT 0x0
+#define VDEC_FLAG_SELF_INPUT_CONTEXT 0x01
 
-#define VDEC_FLAG_INPUT_KEEP_CONTEXT 0x01
+#define VDEC_NEED_MORE_DATA_RUN   0x01
+#define VDEC_NEED_MORE_DATA_DIRTY 0x02
+#define VDEC_NEED_MORE_DATA       0x04
 
 struct vdec_s {
 	u32 magic;
@@ -155,6 +159,7 @@ struct vdec_s {
 	bool pts_valid;
 	int flag;
 	int sched;
+	int need_more_data;
 
 	struct completion inactive_done;
 
@@ -162,6 +167,8 @@ struct vdec_s {
 	unsigned long mem_start;
 	unsigned long mem_end;
 
+	void *mm_blk_handle;
+
 	struct device *cma_dev;
 	struct platform_device *dev;
 	struct dec_sysinfo sys_info_store;
@@ -182,6 +189,7 @@ struct vdec_s {
 	char vfm_map_chain[VDEC_MAP_NAME_SIZE];
 	int vf_receiver_inst;
 	enum FRAME_BASE_VIDEO_PATH frame_base_video_path;
+	enum vdec_fr_hint_state fr_hint_state;
 	bool use_vfm_path;
 	char config[PAGE_SIZE];
 	int config_len;
@@ -189,18 +197,19 @@ struct vdec_s {
 	/* canvas */
 	int (*get_canvas)(unsigned int index, unsigned int base);
 
-	int (*dec_status)(struct vdec_s *vdec, struct vdec_status *vstatus);
+	int (*dec_status)(struct vdec_s *vdec, struct vdec_info *vstatus);
 	int (*set_trickmode)(struct vdec_s *vdec, unsigned long trickmode);
 
-	 bool (*run_ready)(struct vdec_s *vdec);
+	bool (*run_ready)(struct vdec_s *vdec);
 	void (*run)(struct vdec_s *vdec,
-		void (*callback)(struct vdec_s *, void *), void *);
+			void (*callback)(struct vdec_s *, void *), void *);
 	void (*reset)(struct vdec_s *vdec);
-	 irqreturn_t (*irq_handler)(struct vdec_s *);
-	 irqreturn_t (*threaded_irq_handler)(struct vdec_s *);
+	void (*dump_state)(struct vdec_s *vdec);
+	irqreturn_t (*irq_handler)(struct vdec_s *);
+	irqreturn_t (*threaded_irq_handler)(struct vdec_s *);
 
 	/* private */
-	void *private;		/* decoder per instance specific data */
+	void *private;       /* decoder per instance specific data */
 };
 
 /* common decoder vframe provider name to use default vfm path */
@@ -226,7 +235,10 @@ struct vdec_s {
 #define vdec_single(vdec) \
 	((vdec)->type == VDEC_TYPE_SINGLE)
 #define vdec_dual(vdec) \
-	((vdec)->port->type & PORT_TYPE_DUALDEC)
+	(((vdec)->port->type & PORT_TYPE_DUALDEC) ||\
+	 (vdec_get_debug_flags() & 0x100))
+#define vdec_secure(vdec) \
+	(((vdec)->port_flag & PORT_FLAG_DRM))
 
 /* construct vdec strcture */
 extern struct vdec_s *vdec_create(struct stream_port_s *port,
@@ -243,6 +255,9 @@ extern int vdec_set_pts64(struct vdec_s *vdec, u64 pts64);
 /* set vfm map when use frame base decoder */
 extern int vdec_set_video_path(struct vdec_s *vdec, int video_path);
 
+/* set receive id when receive is ionvideo or amlvideo */
+extern int vdec_set_receive_id(struct vdec_s *vdec, int receive_id);
+
 /* add frame data to input chain */
 extern int vdec_write_vframe(struct vdec_s *vdec, const char *buf,
 				size_t count);
@@ -257,9 +272,21 @@ extern int vdec_prepare_input(struct vdec_s *vdec, struct vframe_chunk_s **p);
 /* clean decoder input */
 extern void vdec_clean_input(struct vdec_s *vdec);
 
+/* sync decoder input */
+extern int vdec_sync_input(struct vdec_s *vdec);
+
 /* enable decoder input */
 extern void vdec_enable_input(struct vdec_s *vdec);
 
+/* set decoder input prepare level */
+extern void vdec_set_prepare_level(struct vdec_s *vdec, int level);
+
+/* set vdec input */
+extern int vdec_set_input_buffer(struct vdec_s *vdec, u32 start, u32 size);
+
+/* check if decoder can get more input */
+extern bool vdec_has_more_input(struct vdec_s *vdec);
+
 /* allocate input chain
  * register vdec_device
  * create output, vfm or create ionvideo output
@@ -289,12 +316,14 @@ extern int vdec_init(struct vdec_s *vdec, int is_4k);
 
 extern void vdec_release(struct vdec_s *vdec);
 
-extern int vdec_status(struct vdec_s *vdec, struct vdec_status *vstatus);
+extern int vdec_status(struct vdec_s *vdec, struct vdec_info *vstatus);
 
 extern int vdec_set_trickmode(struct vdec_s *vdec, unsigned long trickmode);
 
 extern void vdec_set_flag(struct vdec_s *vdec, u32 flag);
 
+extern void vdec_set_eos(struct vdec_s *vdec, bool eos);
+
 extern void vdec_set_next_sched(struct vdec_s *vdec, struct vdec_s *next_vdec);
 
 extern const char *vdec_status_str(struct vdec_s *vdec);
@@ -303,4 +332,17 @@ extern const char *vdec_type_str(struct vdec_s *vdec);
 
 extern const char *vdec_device_name_str(struct vdec_s *vdec);
 
+extern void vdec_schedule_work(struct work_struct *work);
+
+extern void  vdec_count_info(struct vdec_info *vs, unsigned int err,
+	unsigned int offset);
+
+extern bool vdec_need_more_data(struct vdec_s *vdec);
+
+extern void hevc_reset_core(struct vdec_s *vdec);
+
+int vdec_get_debug_flags(void);
+
+unsigned char is_mult_inc(unsigned int);
+
 #endif				/* VDEC_H */
diff --git a/drivers/frame_provider/decoder/utils/vdec_input.c b/drivers/frame_provider/decoder/utils/vdec_input.c
index d6acac1..9626c51 100644
--- a/drivers/frame_provider/decoder/utils/vdec_input.c
+++ b/drivers/frame_provider/decoder/utils/vdec_input.c
@@ -25,32 +25,48 @@
 #include "vdec.h"
 #include "vdec_input.h"
 
-#define VFRAME_BLOCK_SIZE (4*SZ_1M)
-#define VFRAME_BLOCK_PAGESIZE (PAGE_ALIGN(VFRAME_BLOCK_SIZE)/PAGE_SIZE)
+#define VFRAME_BLOCK_SIZE (512 * SZ_1K)/*512 for 1080p default init.*/
+#define VFRAME_BLOCK_SIZE_4K (2 * SZ_1M) /*2M for 4K default.*/
+#define VFRAME_BLOCK_SIZE_MAX (4 * SZ_1M)
+
 #define VFRAME_BLOCK_PAGEALIGN 4
-#define VFRAME_BLOCK_MAX_LEVEL (8*SZ_1M)
+#define VFRAME_BLOCK_MIN_LEVEL (2 * SZ_1M)
+#define VFRAME_BLOCK_MAX_LEVEL (8 * SZ_1M)
+#define VFRAME_BLOCK_MAX_TOTAL_SIZE (16 * SZ_1M)
+
+/*
+2s for OMX
+*/
+#define MAX_FRAME_DURATION_S 2
+
+
 #define VFRAME_BLOCK_HOLE (SZ_64K)
 
-#define FRAME_PADDING_SIZE 1024U
+#define MIN_FRAME_PADDING_SIZE ((u32)(L1_CACHE_BYTES))
+
+
 #define MEM_NAME "VFRAME_INPUT"
+static int vdec_input_get_duration_u64(struct vdec_input_s *input);
+static struct vframe_block_list_s *
+	vdec_input_alloc_new_block(struct vdec_input_s *input);
 
 static int vframe_chunk_fill(struct vdec_input_s *input,
 			struct vframe_chunk_s *chunk, const char *buf,
 			size_t count, struct vframe_block_list_s *block)
 {
 	u8 *p = (u8 *)block->start_virt + block->wp;
-
+	int total_size = count + chunk->pading_size;
 	if (block->type == VDEC_TYPE_FRAME_BLOCK) {
 		if (copy_from_user(p, buf, count))
 			return -EFAULT;
 
 		p += count;
 
-		memset(p, 0, FRAME_PADDING_SIZE);
+		memset(p, 0, chunk->pading_size);
 
 		dma_sync_single_for_device(get_vdec_device(),
 			block->start + block->wp,
-			count + FRAME_PADDING_SIZE, DMA_TO_DEVICE);
+			total_size, DMA_TO_DEVICE);
 
 	} else if (block->type == VDEC_TYPE_FRAME_CIRCULAR) {
 		size_t len = min((size_t)(block->size - block->wp), count);
@@ -81,7 +97,7 @@ static int vframe_chunk_fill(struct vdec_input_s *input,
 		if (wp >= block->size)
 			wp -= block->size;
 
-		len = min(block->size - wp, FRAME_PADDING_SIZE);
+		len = min(block->size - wp, chunk->pading_size);
 
 		memset(p, 0, len);
 
@@ -89,14 +105,14 @@ static int vframe_chunk_fill(struct vdec_input_s *input,
 			block->start + wp,
 			len, DMA_TO_DEVICE);
 
-		if (len < FRAME_PADDING_SIZE) {
+		if (chunk->pading_size > len) {
 			p = (u8 *)block->start_virt;
 
 			memset(p, 0, count - len);
 
 			dma_sync_single_for_device(get_vdec_device(),
 					block->start,
-					count - len, DMA_TO_DEVICE);
+				chunk->pading_size - len, DMA_TO_DEVICE);
 		}
 	}
 
@@ -117,9 +133,10 @@ static inline u32 vframe_block_space(struct vframe_block_list_s *block)
 static void vframe_block_add_chunk(struct vframe_block_list_s *block,
 				struct vframe_chunk_s *chunk)
 {
-	block->wp += chunk->size + FRAME_PADDING_SIZE;
+	block->wp += chunk->size + chunk->pading_size;
 	if (block->wp >= block->size)
 		block->wp -= block->size;
+	block->data_size += chunk->size;
 	block->chunk_count++;
 	chunk->block = block;
 	block->input->wr_block = block;
@@ -127,28 +144,19 @@ static void vframe_block_add_chunk(struct vframe_block_list_s *block,
 	block->input->sequence++;
 }
 
-static void vframe_block_free_storage(struct vframe_block_list_s *block)
+static void vframe_block_free_block(struct vframe_block_list_s *block)
 {
 	if (block->addr) {
-		dma_unmap_single(
-			get_vdec_device(),
-			block->start,
-			VFRAME_BLOCK_PAGESIZE,
-			DMA_TO_DEVICE);
-
 		codec_mm_free_for_dma(MEM_NAME,	block->addr);
-
-		block->addr = 0;
-		block->start_virt = NULL;
-		block->start = 0;
 	}
-
-	block->size = 0;
+	pr_err("free block %d, size=%d\n", block->id, block->size);
+	kfree(block);
 }
 
 static int vframe_block_init_alloc_storage(struct vdec_input_s *input,
 			struct vframe_block_list_s *block)
 {
+	int alloc_size = input->default_block_size;
 	block->magic = 0x4b434c42;
 	block->input = input;
 	block->type = input->type;
@@ -156,11 +164,14 @@ static int vframe_block_init_alloc_storage(struct vdec_input_s *input,
 	/*
 	 * todo: for different type use different size
 	 */
-	block->addr = codec_mm_alloc_for_dma(
+	alloc_size = PAGE_ALIGN(alloc_size);
+	block->addr = codec_mm_alloc_for_dma_ex(
 		MEM_NAME,
-		VFRAME_BLOCK_PAGESIZE,
+		alloc_size/PAGE_SIZE,
 		VFRAME_BLOCK_PAGEALIGN,
-		CODEC_MM_FLAGS_DMA_CPU | CODEC_MM_FLAGS_FOR_VDECODER);
+		CODEC_MM_FLAGS_DMA_CPU | CODEC_MM_FLAGS_FOR_VDECODER,
+		input->id,
+		block->id);
 
 	if (!block->addr) {
 		pr_err("Input block allocation failed\n");
@@ -168,12 +179,8 @@ static int vframe_block_init_alloc_storage(struct vdec_input_s *input,
 	}
 
 	block->start_virt = (void *)codec_mm_phys_to_virt(block->addr);
-	block->start = dma_map_single(
-		get_vdec_device(),
-		block->start_virt,
-		VFRAME_BLOCK_PAGESIZE,
-		DMA_TO_DEVICE);
-	block->size = VFRAME_BLOCK_PAGESIZE * PAGE_SIZE;
+	block->start = block->addr;
+	block->size = alloc_size;
 
 	return 0;
 }
@@ -181,12 +188,212 @@ static int vframe_block_init_alloc_storage(struct vdec_input_s *input,
 void vdec_input_init(struct vdec_input_s *input, struct vdec_s *vdec)
 {
 	INIT_LIST_HEAD(&input->vframe_block_list);
+	INIT_LIST_HEAD(&input->vframe_block_free_list);
 	INIT_LIST_HEAD(&input->vframe_chunk_list);
 	spin_lock_init(&input->lock);
-
+	input->id = vdec->id;
+	input->block_nums = 0;
 	input->vdec = vdec;
+	input->block_id_seq = 0;
+	input->size = 0;
+	input->default_block_size = VFRAME_BLOCK_SIZE;
+}
+int vdec_input_prepare_bufs(struct vdec_input_s *input,
+	int frame_width, int frame_height)
+{
+	struct vframe_block_list_s *block;
+	int i;
+	unsigned long flags;
+
+	if (input->size > 0)
+		return 0;
+	if (frame_width * frame_height >= 1920 * 1088) {
+		/*have add data before. ignore prepare buffers.*/
+		input->default_block_size = VFRAME_BLOCK_SIZE_4K;
+	}
+	/*prepared 3 buffers for smooth start.*/
+	for (i = 0; i < 3; i++) {
+		block = vdec_input_alloc_new_block(input);
+		if (!block)
+			break;
+		flags = vdec_input_lock(input);
+		list_move_tail(&block->list,
+				&input->vframe_block_free_list);
+		input->wr_block = NULL;
+		vdec_input_unlock(input, flags);
+	}
+	return 0;
+}
+
+static int vdec_input_dump_block_locked(
+	struct vframe_block_list_s *block,
+	char *buf, int size)
+{
+	char *pbuf = buf;
+	char sbuf[512];
+	int tsize = 0;
+	int s;
+	if (!pbuf) {
+		pbuf = sbuf;
+		size = 512;
+	}
+	#define BUFPRINT(args...) \
+	do {\
+		s = snprintf(pbuf, size - tsize, args);\
+		tsize += s;\
+		pbuf += s; \
+	} while (0)
+
+	BUFPRINT("\tblock:[%d:%p]-addr=%p,vstart=%p,type=%d\n",
+		block->id,
+		block,
+		(void *)block->addr,
+		(void *)block->start_virt,
+		block->type);
+	BUFPRINT("\t-blocksize=%d,data=%d,wp=%d,rp=%d,chunk_count=%d\n",
+		block->size,
+		block->data_size,
+		block->wp,
+		block->rp,
+		block->chunk_count);
+	/*
+	BUFPRINT("\tlist=%p,next=%p,prev=%p\n",
+		&block->list,
+		block->list.next,
+		block->list.prev);
+	*/
+	#undef BUFPRINT
+	if (!buf)
+		pr_info("%s", sbuf);
+	return tsize;
+}
+
+int vdec_input_dump_blocks(struct vdec_input_s *input,
+	char *bufs, int size)
+{
+	struct list_head *p, *tmp;
+	unsigned long flags;
+	char *lbuf = bufs;
+	char sbuf[256];
+	int s = 0;
+
+	if (!bufs)
+		lbuf = sbuf;
+	s += sprintf(lbuf + s,
+		"blocks:vdec-%d id:%d,bufsize=%d,dsize=%d,frames:%d,dur:%dms\n",
+		input->id,
+		input->block_nums,
+		input->size,
+		input->data_size,
+		input->have_frame_num,
+		vdec_input_get_duration_u64(input)/1000);
+	if (bufs)
+		lbuf += s;
+	else {
+		pr_info("%s", sbuf);
+		lbuf = NULL;
+	}
+
+	flags = vdec_input_lock(input);
+	/* dump input blocks */
+	list_for_each_safe(p, tmp, &input->vframe_block_list) {
+		struct vframe_block_list_s *block = list_entry(
+			p, struct vframe_block_list_s, list);
+		if (bufs != NULL)
+			lbuf = bufs + s;
+		s += vdec_input_dump_block_locked(block, lbuf, size - s);
+	}
+	list_for_each_safe(p, tmp, &input->vframe_block_free_list) {
+		struct vframe_block_list_s *block = list_entry(
+			p, struct vframe_block_list_s, list);
+		if (bufs != NULL)
+			lbuf = bufs + s;
+		s += vdec_input_dump_block_locked(block, lbuf, size - s);
+	}
+	vdec_input_unlock(input, flags);
+	return s;
 }
-EXPORT_SYMBOL(vdec_input_init);
+
+static int vdec_input_dump_chunk_locked(
+	struct vframe_chunk_s *chunk,
+	char *buf, int size)
+{
+	char *pbuf = buf;
+	char sbuf[512];
+	int tsize = 0;
+	int s;
+	if (!pbuf) {
+		pbuf = sbuf;
+		size = 512;
+	}
+	#define BUFPRINT(args...) \
+	do {\
+		s = snprintf(pbuf, size - tsize, args);\
+		tsize += s;\
+		pbuf += s; \
+	} while (0)
+
+	BUFPRINT(
+		"\t[%lld:%p]-off=%d,size:%d,p:%d,\tpts64=%lld,addr=%p\n",
+		chunk->sequence,
+		chunk->block,
+		chunk->offset,
+		chunk->size,
+		chunk->pading_size,
+		chunk->pts64,
+		(void *)(chunk->block->addr + chunk->offset));
+	/*
+	BUFPRINT("\tlist=%p,next=%p,prev=%p\n",
+		&chunk->list,
+		chunk->list.next,
+		chunk->list.prev);
+	*/
+	#undef BUFPRINT
+	if (!buf)
+		pr_info("%s", sbuf);
+	return tsize;
+}
+
+int vdec_input_dump_chunks(struct vdec_input_s *input,
+	char *bufs, int size)
+{
+
+	struct list_head *p, *tmp;
+	unsigned long flags;
+	char *lbuf = bufs;
+	char sbuf[256];
+	int s = 0;
+
+	if (!bufs)
+		lbuf = sbuf;
+	s += sprintf(lbuf + s,
+		"blocks:vdec-%d id:%d,bufsize=%d,dsize=%d,frames:%d,maxframe:%d\n",
+		input->id,
+		input->block_nums,
+		input->size,
+		input->data_size,
+		input->have_frame_num,
+		input->frame_max_size);
+	if (bufs)
+		lbuf += s;
+	if (!bufs) {
+		pr_info("%s", sbuf);
+		lbuf = NULL;
+	}
+	flags = vdec_input_lock(input);
+	/*dump chunks list infos.*/
+	list_for_each_safe(p, tmp, &input->vframe_chunk_list) {
+		struct vframe_chunk_s *chunk = list_entry(
+				p, struct vframe_chunk_s, list);
+		if (bufs != NULL)
+			lbuf = bufs + s;
+		s += vdec_input_dump_chunk_locked(chunk, lbuf, size - s);
+	}
+	vdec_input_unlock(input, flags);
+	return s;
+}
+
+
 
 int vdec_input_set_buffer(struct vdec_input_s *input, u32 start, u32 size)
 {
@@ -195,9 +402,20 @@ int vdec_input_set_buffer(struct vdec_input_s *input, u32 start, u32 size)
 
 	input->start = start;
 	input->size = size;
-	input->swap_page = alloc_page(GFP_KERNEL);
+	input->swap_rp = start;
+
+	if (vdec_secure(input->vdec))
+		input->swap_page_phys = codec_mm_alloc_for_dma("SWAP",
+			1, 0, CODEC_MM_FLAGS_TVP);
+	else {
+		input->swap_page = alloc_page(GFP_KERNEL);
+		if (input->swap_page) {
+			input->swap_page_phys =
+				page_to_phys(input->swap_page);
+		}
+	}
 
-	if (input->swap_page == NULL)
+	if (input->swap_page_phys == 0)
 		return -ENOMEM;
 
 	return 0;
@@ -208,6 +426,10 @@ void vdec_input_set_type(struct vdec_input_s *input, int type, int target)
 {
 	input->type = type;
 	input->target = target;
+	if (type == VDEC_TYPE_FRAME_CIRCULAR) {
+		/*alway used max block.*/
+		input->default_block_size = VFRAME_BLOCK_SIZE_MAX;
+	}
 }
 EXPORT_SYMBOL(vdec_input_set_type);
 
@@ -247,30 +469,21 @@ static void vdec_input_add_block(struct vdec_input_s *input,
 	unsigned long flags;
 
 	flags = vdec_input_lock(input);
-
+	block->wp = 0;
+	block->id = input->block_id_seq++;
 	list_add_tail(&block->list, &input->vframe_block_list);
 	input->size += block->size;
-
+	input->block_nums++;
+	input->wr_block = block;
 	vdec_input_unlock(input, flags);
 }
 
-static void vdec_input_remove_block(struct vdec_input_s *input,
+static inline void vdec_input_del_block_locked(struct vdec_input_s *input,
 				struct vframe_block_list_s *block)
 {
-	unsigned long flags;
-
-	flags = vdec_input_lock(input);
-
 	list_del(&block->list);
 	input->size -= block->size;
-
-	vdec_input_unlock(input, flags);
-
-	vframe_block_free_storage(block);
-
-	kfree(block);
-
-	pr_info("block %p removed\n", block);
+	input->block_nums--;
 }
 
 int vdec_input_level(struct vdec_input_s *input)
@@ -279,13 +492,164 @@ int vdec_input_level(struct vdec_input_s *input)
 }
 EXPORT_SYMBOL(vdec_input_level);
 
+static struct vframe_block_list_s *
+	vdec_input_alloc_new_block(struct vdec_input_s *input)
+{
+	struct vframe_block_list_s *block;
+	block = kzalloc(sizeof(struct vframe_block_list_s),
+			GFP_KERNEL);
+	if (block == NULL) {
+		input->no_mem_err_cnt++;
+		pr_err("vframe_block structure allocation failed\n");
+		return NULL;
+	}
+
+	if (vframe_block_init_alloc_storage(input,
+		block) != 0) {
+		kfree(block);
+		pr_err("vframe_block storage allocation failed\n");
+		return NULL;
+	}
+
+	INIT_LIST_HEAD(&block->list);
+
+	vdec_input_add_block(input, block);
+
+	pr_info("vdec-%d:new block id=%d, total_blocks:%d, size=%d\n",
+		input->id,
+		block->id,
+		input->block_nums,
+		block->size);
+	if (0 && input->size > VFRAME_BLOCK_MAX_LEVEL * 2) {
+		/*
+		used
+		*/
+		pr_info(
+		"input[%d] reach max: size:%d, blocks:%d",
+			input->id,
+			input->size,
+			input->block_nums);
+		pr_info("level:%d, wr:%lld,rd:%lld\n",
+			vdec_input_level(input),
+			input->total_wr_count,
+			input->total_rd_count);
+		vdec_input_dump_blocks(input, NULL, 0);
+	}
+	return block;
+}
+static int vdec_input_get_duration_u64(struct vdec_input_s *input)
+{
+	int duration = (input->last_inpts_u64 - input->last_comsumed_pts_u64);
+	if (input->last_in_nopts_cnt > 0 &&
+		input->last_comsumed_pts_u64 > 0 &&
+		input->last_duration > 0) {
+		duration += (input->last_in_nopts_cnt -
+			input->last_comsumed_no_pts_cnt) *
+			input->last_duration;
+	}
+	if (duration > 1000 * 1000000)/*> 1000S,I think jumped.*/
+		duration = 0;
+	if (duration <= 0 && input->last_duration > 0) {
+		/*..*/
+		duration = input->last_duration * input->have_frame_num;
+	}
+	if (duration < 0)
+		duration = 0;
+	return duration;
+}
+/*
+	ret >= 13: have enough buffer, blocked add more buffers
+*/
+static int vdec_input_have_blocks_enough(struct vdec_input_s *input)
+{
+	int ret = 0;
+	if (vdec_input_level(input) > VFRAME_BLOCK_MIN_LEVEL)
+		ret += 1;
+	if (vdec_input_level(input) >= VFRAME_BLOCK_MAX_LEVEL)
+		ret += 2;
+	if (vdec_input_get_duration_u64(input) > MAX_FRAME_DURATION_S)
+		ret += 4;
+	if (input->have_frame_num > 30)
+		ret += 8;
+	else
+		ret -= 8;/*not enough frames.*/
+	if (input->size >= VFRAME_BLOCK_MAX_TOTAL_SIZE)
+		ret += 100;/*always bloced add more buffers.*/
+
+	return ret;
+}
+static int	vdec_input_get_free_block(
+	struct vdec_input_s *input,
+	int size,/*frame size + pading*/
+	struct vframe_block_list_s **block_ret)
+{
+	struct vframe_block_list_s *to_freeblock = NULL;
+	struct vframe_block_list_s *block = NULL;
+	unsigned long flags;
+	flags = vdec_input_lock(input);
+	/*get from free list.*/
+	if (!list_empty(&input->vframe_block_free_list)) {
+		block = list_entry(input->vframe_block_free_list.next,
+		struct vframe_block_list_s, list);
+		if (block->size < (size)) {
+			vdec_input_del_block_locked(input, block);
+			to_freeblock = block;
+			block = NULL;
+		} else {
+			list_move_tail(&block->list,
+				&input->vframe_block_list);
+			input->wr_block = block;/*swith to new block*/
+		}
+	}
+	vdec_input_unlock(input, flags);
+	if (to_freeblock) {
+		/*free the small block.*/
+		vframe_block_free_block(to_freeblock);
+	}
+	if (block) {
+		*block_ret = block;
+		return 0;
+	}
+
+	if (vdec_input_have_blocks_enough(input) > 13) {
+		/*buf fulled */
+		return -EAGAIN;
+	}
+	if (input->no_mem_err_cnt > 3) {
+		/*alloced failed more times.
+		*/
+		return -EAGAIN;
+	}
+	if (input->default_block_size <=
+		size * 2) {
+		int def_size = input->default_block_size;
+		do {
+			def_size *= 2;
+		} while ((def_size <= 2 * size) &&
+			(def_size <= VFRAME_BLOCK_SIZE_MAX));
+		if (def_size < size)
+			def_size = ALIGN(size + 64, (1 << 17));
+		/*128k aligned,same as codec_mm*/
+		input->default_block_size = def_size;
+	}
+	block = vdec_input_alloc_new_block(input);
+	if (!block) {
+		input->no_mem_err_cnt++;
+		return -EAGAIN;
+	}
+	input->no_mem_err_cnt = 0;
+	*block_ret = block;
+	return 0;
+}
+
 int vdec_input_add_frame(struct vdec_input_s *input, const char *buf,
 			size_t count)
 {
 	unsigned long flags;
 	struct vframe_chunk_s *chunk;
 	struct vdec_s *vdec = input->vdec;
-	struct vframe_block_list_s *block = input->wr_block;
+	struct vframe_block_list_s *block;
+	int need_pading_size = MIN_FRAME_PADDING_SIZE;
 
 #if 0
 	if (add_count == 0) {
@@ -326,69 +690,46 @@ int vdec_input_add_frame(struct vdec_input_s *input, const char *buf,
 #endif
 	if (input_stream_based(input))
 		return -EINVAL;
-
-	/* prepare block to write */
-	if ((!block) || (block &&
-		(vframe_block_space(block) < (count + FRAME_PADDING_SIZE)))) {
-		/* switch to another block for the added chunk */
-		struct vframe_block_list_s *new_block;
-
-#if 0
-		pr_info("Adding new block, total level = %d, total_wr_count=%d, total_rd_count=%d\n",
-			vdec_input_level(input),
-			(int)input->total_wr_count,
-			(int)input->total_rd_count);
-#endif
-
-		if ((!list_empty(&input->vframe_block_list)) &&
-			(block->type == VDEC_TYPE_FRAME_CIRCULAR))
-			return -EAGAIN;
-		/*
-		*todo: add input limit check for
-		 * VDEC_TYPE_FRAME_BLOCK
-		 */
-		if (vdec_input_level(input) >
-			VFRAME_BLOCK_MAX_LEVEL) {
-			pr_info("vdec_input %p reaching max size\n",
-				input);
-			return -EAGAIN;
-		}
-
-		/*
-		*check next block of current wr_block, it should be an empty
-		 * block to use
-		 */
-		if ((block) && (!list_is_last(
-			&block->list, &input->vframe_block_list))) {
-			block = list_next_entry(block, list);
-
-			if (vframe_block_space(block) != VFRAME_BLOCK_SIZE)
-				/* should never happen */
-				pr_err("next writing block not empty.\n");
-		} else {
-			/* add a new block into input list */
-			new_block = kzalloc(sizeof(struct vframe_block_list_s),
-					GFP_KERNEL);
-			if (new_block == NULL) {
-				pr_err("vframe_block structure allocation failed\n");
-				return -EAGAIN;
-			}
-
-			if (vframe_block_init_alloc_storage(input,
-				new_block) != 0) {
-				kfree(new_block);
-				pr_err("vframe_block storage allocation failed\n");
-				return -EAGAIN;
-			}
-
-			INIT_LIST_HEAD(&new_block->list);
-
-			vdec_input_add_block(input, new_block);
-
-			/* pr_info("added new block %p\n", new_block); */
-
-			block = new_block;
+	if (count < PAGE_SIZE) {
+		need_pading_size = PAGE_ALIGN(count + need_pading_size) -
+			count;
+	} else {
+		/*to 64 bytes aligned;*/
+		if (count & 0x3f)
+			need_pading_size += 64 - (count & 0x3f);
+	}
+	block = input->wr_block;
+	if (block &&
+		(vframe_block_space(block) > (count + need_pading_size))) {
+		/*this block have enough buffers.
+		do nothings.
+		*/
+	} else if (block && (block->type == VDEC_TYPE_FRAME_CIRCULAR)) {
+		/*in circular module.
+		only one block,.*/
+		return -EAGAIN;
+	} else if (block != NULL) {
+		/*have block but not enough space.
+		recycle the no enough blocks.*/
+		flags = vdec_input_lock(input);
+		if (input->wr_block == block &&
+			block->chunk_count == 0) {
+			block->rp = 0;
+			block->wp = 0;
+			/*block no data move to freelist*/
+			list_move_tail(&block->list,
+				&input->vframe_block_free_list);
+			input->wr_block = NULL;
 		}
+		vdec_input_unlock(input, flags);
+		block = NULL;
+	}
+	if (!block) {/*try new block.*/
+		int ret = vdec_input_get_free_block(input,
+			count + need_pading_size,
+			&block);
+		if (ret < 0)/*no enough block now.*/
+			return ret;
 	}
 
 	chunk = kzalloc(sizeof(struct vframe_chunk_s), GFP_KERNEL);
@@ -403,11 +744,22 @@ int vdec_input_add_frame(struct vdec_input_s *input, const char *buf,
 		chunk->pts = vdec->pts;
 		chunk->pts64 = vdec->pts64;
 	}
+	if (vdec->pts_valid &&
+		input->last_inpts_u64 > 0 &&
+		input->last_in_nopts_cnt == 0) {
+		int d = (int)(chunk->pts64 - input->last_inpts_u64);
+		if (d > 0 && (d < input->last_duration))
+			input->last_duration = d;
+		/*	alwasy: used the smallest duration;
+			if 60fps->30 fps.
+			maybe have warning value.
+		*/
+	}
 	chunk->pts_valid = vdec->pts_valid;
 	vdec->pts_valid = false;
 	chunk->offset = block->wp;
 	chunk->size = count;
-
+	chunk->pading_size = need_pading_size;
 	INIT_LIST_HEAD(&chunk->list);
 
 	if (vframe_chunk_fill(input, chunk, buf, count, block)) {
@@ -421,9 +773,18 @@ int vdec_input_add_frame(struct vdec_input_s *input, const char *buf,
 	vframe_block_add_chunk(block, chunk);
 
 	list_add_tail(&chunk->list, &input->vframe_chunk_list);
-
+	input->data_size += chunk->size;
+	input->have_frame_num++;
+	if (chunk->pts_valid) {
+		input->last_inpts_u64 = chunk->pts64;
+		input->last_in_nopts_cnt = 0;
+	} else {
+		/*nopts*/
+		input->last_in_nopts_cnt++;
+	}
 	vdec_input_unlock(input, flags);
-
+	if (chunk->size > input->frame_max_size)
+		input->frame_max_size = chunk->size;
 	input->total_wr_count += count;
 
 #if 0
@@ -437,11 +798,15 @@ EXPORT_SYMBOL(vdec_input_add_frame);
 
 struct vframe_chunk_s *vdec_input_next_chunk(struct vdec_input_s *input)
 {
-	if (list_empty(&input->vframe_chunk_list))
-		return NULL;
-
-	return list_first_entry(&input->vframe_chunk_list,
+	struct vframe_chunk_s *chunk = NULL;
+	unsigned long flags;
+	flags = vdec_input_lock(input);
+	if (!list_empty(&input->vframe_chunk_list)) {
+		chunk = list_first_entry(&input->vframe_chunk_list,
 				struct vframe_chunk_s, list);
+	}
+	vdec_input_unlock(input, flags);
+	return chunk;
 }
 EXPORT_SYMBOL(vdec_input_next_chunk);
 
@@ -450,6 +815,8 @@ struct vframe_chunk_s *vdec_input_next_input_chunk(
 {
 	struct vframe_chunk_s *chunk = NULL;
 	struct list_head *p;
+	unsigned long flags;
+	flags = vdec_input_lock(input);
 
 	list_for_each(p, &input->vframe_chunk_list) {
 		struct vframe_chunk_s *c = list_entry(
@@ -459,7 +826,7 @@ struct vframe_chunk_s *vdec_input_next_input_chunk(
 			break;
 		}
 	}
-
+	vdec_input_unlock(input, flags);
 	return chunk;
 }
 EXPORT_SYMBOL(vdec_input_next_input_chunk);
@@ -469,32 +836,39 @@ void vdec_input_release_chunk(struct vdec_input_s *input,
 {
 	unsigned long flags;
 	struct vframe_block_list_s *block = chunk->block;
-
+	struct vframe_block_list_s *tofreeblock = NULL;
 	flags = vdec_input_lock(input);
 
 	list_del(&chunk->list);
-
+	input->have_frame_num--;
+	if (chunk->pts_valid) {
+		input->last_comsumed_no_pts_cnt = 0;
+		input->last_comsumed_pts_u64 = chunk->pts64;
+	} else
+		input->last_comsumed_no_pts_cnt++;
 	block->rp += chunk->size;
 	if (block->rp >= block->size)
 		block->rp -= block->size;
+	block->data_size -= chunk->size;
 	block->chunk_count--;
+	input->data_size -= chunk->size;
 	input->total_rd_count += chunk->size;
-
-	if (block->chunk_count == 0) {
-		/* reuse the block */
-		block->wp = 0;
-		block->rp = 0;
-
-		if ((input->wr_block == block) &&
-			(!list_is_last(&block->list,
-				&input->vframe_block_list)))
-			input->wr_block = list_next_entry(block, list);
-
-		list_move_tail(&block->list, &input->vframe_block_list);
+	if (block->chunk_count == 0 &&
+		input->wr_block != block) {/*don't free used block*/
+		if (block->size < input->default_block_size) {
+			vdec_input_del_block_locked(input, block);
+			tofreeblock = block;
+		} else {
+			block->rp = 0;
+			block->wp = 0;
+			list_move_tail(&block->list,
+				&input->vframe_block_free_list);
+		}
 	}
 
 	vdec_input_unlock(input, flags);
-
+	if (tofreeblock)
+		vframe_block_free_block(tofreeblock);
 	kfree(chunk);
 }
 EXPORT_SYMBOL(vdec_input_release_chunk);
@@ -528,17 +902,27 @@ void vdec_input_release(struct vdec_input_s *input)
 
 	/* release input blocks */
 	list_for_each_safe(p, tmp, &input->vframe_block_list) {
+		/*should never here.*/
+		list_move_tail(p, &input->vframe_block_free_list);
+	}
+	/* release input blocks */
+	list_for_each_safe(p, tmp, &input->vframe_block_free_list) {
 		struct vframe_block_list_s *block = list_entry(
 			p, struct vframe_block_list_s, list);
-		vdec_input_remove_block(input, block);
+		vdec_input_del_block_locked(input, block);
+		vframe_block_free_block(block);
 	}
 
-	/* release swap page */
-	if (input->swap_page) {
-		__free_page(input->swap_page);
+	/* release swap pages */
+	if (input->swap_page_phys) {
+		if (vdec_secure(input->vdec))
+			codec_mm_free_for_dma("SWAP", input->swap_page_phys);
+		else
+			__free_page(input->swap_page);
 		input->swap_page = NULL;
-		input->swap_valid = false;
+		input->swap_page_phys = 0;
 	}
+	input->swap_valid = false;
 }
 EXPORT_SYMBOL(vdec_input_release);
 
diff --git a/drivers/frame_provider/decoder/utils/vdec_input.h b/drivers/frame_provider/decoder/utils/vdec_input.h
index b029b89..489e4a0 100644
--- a/drivers/frame_provider/decoder/utils/vdec_input.h
+++ b/drivers/frame_provider/decoder/utils/vdec_input.h
@@ -23,6 +23,7 @@ struct vdec_input_s;
 
 struct vframe_block_list_s {
 	u32 magic;
+	int id;
 	struct list_head list;
 	ulong start;
 	void *start_virt;
@@ -31,6 +32,7 @@ struct vframe_block_list_s {
 	u32 size;
 	u32 wp;
 	u32 rp;
+	int data_size;
 	int chunk_count;
 	struct vdec_input_s *input;
 };
@@ -44,6 +46,7 @@ struct vframe_chunk_s {
 	u32 offset;
 	u32 size;
 	u32 pts;
+	u32 pading_size;
 	u64 pts64;
 	bool pts_valid;
 	u64 sequence;
@@ -56,21 +59,45 @@ struct vframe_chunk_s {
 struct vdec_input_s {
 	struct list_head vframe_block_list;
 	struct list_head vframe_chunk_list;
+	struct list_head vframe_block_free_list;
 	struct vframe_block_list_s *wr_block;
+	int have_free_blocks;
+	int no_mem_err_cnt;/*when alloc no mem cnt++*/
+	int block_nums;
+	int block_id_seq;
+	int id;
 	spinlock_t lock;
 	int type;
 	int target;
 	struct vdec_s *vdec;
 	bool swap_valid;
 	bool swap_needed;
+	bool eos;
 	struct page *swap_page;
-	int total_wr_count;
-	int total_rd_count;
+	unsigned long swap_page_phys;
+	u64 total_wr_count;
+	u64 total_rd_count;
+	u64 streaming_rp;
+	u32 swap_rp;
+	bool last_swap_slave;
+	int dirty_count;
 	u64 sequence;
 	unsigned start;
 	unsigned size;
-	int stream_cookie;	/* wrap count for vld_mem and*/
-				   /*HEVC_SHIFT_BYTE_COUNT for hevc */
+	int default_block_size;
+	int data_size;
+	int frame_max_size;
+	int prepare_level;
+/*for check frame delay.*/
+	u64 last_inpts_u64;
+	u64 last_comsumed_pts_u64;
+	int last_in_nopts_cnt;
+	int last_comsumed_no_pts_cnt;
+	int last_duration;
+/*for check frame delay.*/
+	int have_frame_num;
+	int stream_cookie; /* wrap count for vld_mem and
+			      HEVC_SHIFT_BYTE_COUNT for hevc */
 };
 
 struct vdec_input_status_s {
@@ -89,6 +116,8 @@ struct vdec_input_status_s {
 
 /* Initialize vdec_input structure */
 extern void vdec_input_init(struct vdec_input_s *input, struct vdec_s *vdec);
+extern int vdec_input_prepare_bufs(struct vdec_input_s *input,
+	int frame_width, int frame_height);
 
 /* Get available input data size */
 extern int vdec_input_level(struct vdec_input_s *input);
@@ -127,5 +156,9 @@ extern void vdec_input_unlock(struct vdec_input_s *input, unsigned long lock);
 
 /* release all resource for decoder's input */
 extern void vdec_input_release(struct vdec_input_s *input);
+int vdec_input_dump_chunks(struct vdec_input_s *input,
+	char *bufs, int size);
+int vdec_input_dump_blocks(struct vdec_input_s *input,
+	char *bufs, int size);
 
 #endif /* VDEC_INPUT_H */
diff --git a/drivers/frame_provider/decoder/utils/vdec_profile.c b/drivers/frame_provider/decoder/utils/vdec_profile.c
new file mode 100644
index 0000000..638cc33
--- /dev/null
+++ b/drivers/frame_provider/decoder/utils/vdec_profile.c
@@ -0,0 +1,217 @@
+/*
+ * drivers/amlogic/amports/vdec_profile.c
+ *
+ * Copyright (C) 2016 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+*/
+
+#include <linux/kernel.h>
+#include <linux/mutex.h>
+#include <linux/types.h>
+#include <linux/debugfs.h>
+
+#include <linux/amlogic/media/utils/vdec_reg.h>
+#include "vdec_profile.h"
+#include "vdec.h"
+
+#define ISA_TIMERE 0x2662
+#define ISA_TIMERE_HI 0x2663
+
+#define PROFILE_REC_SIZE 40
+
+static DEFINE_MUTEX(vdec_profile_mutex);
+static int rec_wp;
+static bool rec_wrapped;
+
+struct dentry *root, *event;
+
+struct vdec_profile_rec_s {
+	struct vdec_s *vdec;
+	u64 timestamp;
+	int event;
+};
+
+static struct vdec_profile_rec_s recs[PROFILE_REC_SIZE];
+static const char *event_name[VDEC_PROFILE_MAX_EVENT] = {
+	"run",
+	"cb",
+	"save_input",
+	"check run ready",
+	"run ready",
+	"disconnect",
+	"dec_work"
+};
+
+static u64 get_us_time(void)
+{
+	u32 lo, hi1, hi2;
+
+	do {
+		hi1 = READ_MPEG_REG(ISA_TIMERE_HI);
+		lo = READ_MPEG_REG(ISA_TIMERE);
+		hi2 = READ_MPEG_REG(ISA_TIMERE_HI);
+	} while (hi1 != hi2);
+
+	return (((u64)hi1) << 32) | lo;
+}
+
+void vdec_profile(struct vdec_s *vdec, int event)
+{
+	mutex_lock(&vdec_profile_mutex);
+
+	recs[rec_wp].vdec = vdec;
+	recs[rec_wp].timestamp = get_us_time();
+	recs[rec_wp].event = event;
+
+	rec_wp++;
+	if (rec_wp == PROFILE_REC_SIZE) {
+		rec_wrapped = true;
+		rec_wp = 0;
+	}
+
+	mutex_unlock(&vdec_profile_mutex);
+}
+
+void vdec_profile_flush(struct vdec_s *vdec)
+{
+	int i;
+
+	mutex_lock(&vdec_profile_mutex);
+
+	for (i = 0; i < PROFILE_REC_SIZE; i++) {
+		if (recs[i].vdec == vdec)
+			recs[i].vdec = NULL;
+	}
+
+	mutex_unlock(&vdec_profile_mutex);
+}
+
+static const char *event_str(int event)
+{
+	if (event < VDEC_PROFILE_MAX_EVENT)
+		return event_name[event];
+
+	return "INVALID";
+}
+
+static int vdec_profile_dbg_show(struct seq_file *m, void *v)
+{
+	int i, end;
+	u64 base_timestamp;
+
+	mutex_lock(&vdec_profile_mutex);
+
+	if (rec_wrapped) {
+		i = rec_wp;
+		end = rec_wp;
+	} else {
+		i = 0;
+		end = rec_wp;
+	}
+
+	base_timestamp = recs[i].timestamp;
+	while (1) {
+		if ((!rec_wrapped) && (i == end))
+			break;
+
+		if (recs[i].vdec) {
+			seq_printf(m, "[%s:%d] %016llu us : %s\n",
+				vdec_device_name_str(recs[i].vdec),
+				recs[i].vdec->id,
+				recs[i].timestamp - base_timestamp,
+				event_str(recs[i].event));
+		}
+
+		if (++i == PROFILE_REC_SIZE)
+			i = 0;
+
+		if (rec_wrapped && (i == end))
+			break;
+	}
+
+	mutex_unlock(&vdec_profile_mutex);
+
+	return 0;
+}
+
+static int vdec_profile_dbg_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, vdec_profile_dbg_show, NULL);
+}
+
+static const struct file_operations event_dbg_fops = {
+	.open    = vdec_profile_dbg_open,
+	.read    = seq_read,
+	.llseek  = seq_lseek,
+	.release = single_release,
+};
+
+#if 0 /*DEBUG_TMP*/
+static int __init vdec_profile_init_debugfs(void)
+{
+	struct dentry *root, *event;
+
+	root = debugfs_create_dir("vdec_profile", NULL);
+	if (IS_ERR(root) || !root)
+		goto err;
+
+	event = debugfs_create_file("event", 0400, root, NULL,
+			&event_dbg_fops);
+	if (!event)
+		goto err_1;
+
+	mutex_init(&vdec_profile_mutex);
+
+	return 0;
+
+err_1:
+	debugfs_remove(root);
+err:
+	pr_err("Can not create debugfs for vdec_profile\n");
+	return 0;
+}
+
+#endif
+
+int vdec_profile_init_debugfs(void)
+{
+	root = debugfs_create_dir("vdec_profile", NULL);
+	if (IS_ERR(root) || !root)
+		goto err;
+
+	event = debugfs_create_file("event", 0400, root, NULL,
+			&event_dbg_fops);
+	if (!event)
+		goto err_1;
+
+	mutex_init(&vdec_profile_mutex);
+
+	return 0;
+
+err_1:
+	debugfs_remove(root);
+err:
+	pr_err("Can not create debugfs for vdec_profile\n");
+	return 0;
+}
+EXPORT_SYMBOL(vdec_profile_init_debugfs);
+
+void vdec_profile_exit_debugfs(void)
+{
+	debugfs_remove(event);
+	debugfs_remove(root);
+}
+EXPORT_SYMBOL(vdec_profile_exit_debugfs);
+
+/*module_init(vdec_profile_init_debugfs);*/
+
diff --git a/drivers/frame_provider/decoder/utils/vdec_profile.h b/drivers/frame_provider/decoder/utils/vdec_profile.h
new file mode 100644
index 0000000..6ad2343
--- /dev/null
+++ b/drivers/frame_provider/decoder/utils/vdec_profile.h
@@ -0,0 +1,39 @@
+/*
+ * drivers/amlogic/amports/vdec_profile.h
+ *
+ * Copyright (C) 2016 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+*/
+
+#ifndef VDEC_PROFILE_H
+#define VDEC_PROFILE_H
+
+struct vdec_s;
+
+#define VDEC_PROFILE_EVENT_RUN         0
+#define VDEC_PROFILE_EVENT_CB          1
+#define VDEC_PROFILE_EVENT_SAVE_INPUT  2
+#define VDEC_PROFILE_EVENT_CHK_RUN_READY 3
+#define VDEC_PROFILE_EVENT_RUN_READY   4
+#define VDEC_PROFILE_EVENT_DISCONNECT  5
+#define VDEC_PROFILE_EVENT_DEC_WORK    6
+#define VDEC_PROFILE_MAX_EVENT         7
+
+extern void vdec_profile(struct vdec_s *vdec, int event);
+
+extern void vdec_profile_flush(struct vdec_s *vdec);
+
+int vdec_profile_init_debugfs(void);
+void vdec_profile_exit_debugfs(void);
+
+#endif /* VDEC_PROFILE_H */
diff --git a/drivers/frame_provider/decoder/utils/vdec_trace.h b/drivers/frame_provider/decoder/utils/vdec_trace.h
new file mode 100644
index 0000000..e09518e
--- /dev/null
+++ b/drivers/frame_provider/decoder/utils/vdec_trace.h
@@ -0,0 +1,149 @@
+/*
+ * drivers/amlogic/amports/vdec_trace.h
+ *
+ * Copyright (C) 2016 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+*/
+
+#undef TRACE_SYSTEM
+#define TRACE_SYSTEM vdec
+
+#if !defined(_VDEC_TRACE_H) || defined(TRACE_HEADER_MULTI_READ)
+#define _VDEC_TRACE_H
+
+#include <linux/tracepoint.h>
+
+struct vdec_s;
+
+/* single lifecycle events */
+DECLARE_EVENT_CLASS(vdec_event_class,
+	TP_PROTO(struct vdec_s *vdec),
+	TP_ARGS(vdec),
+	TP_STRUCT__entry(
+		__field(struct vdec_s *, vdec)
+	),
+	TP_fast_assign(
+		__entry->vdec = vdec;
+	),
+	TP_printk("[%p]",  __entry->vdec)
+);
+
+#define DEFINE_VDEC_EVENT(name) \
+DEFINE_EVENT(vdec_event_class, name, \
+	TP_PROTO(struct vdec_s *vdec), \
+	TP_ARGS(vdec))
+
+DEFINE_VDEC_EVENT(vdec_create);
+DEFINE_VDEC_EVENT(vdec_connect);
+DEFINE_VDEC_EVENT(vdec_disconnect);
+DEFINE_VDEC_EVENT(vdec_destroy);
+DEFINE_VDEC_EVENT(vdec_reset);
+DEFINE_VDEC_EVENT(vdec_release);
+
+/* set format event */
+#define format_name(format) \
+	__print_symbolic(format, \
+		{0, "MPEG"}, \
+		{1, "MPEG4"}, \
+		{2, "H264"}, \
+		{3, "MJPEG"}, \
+		{4, "REAL"}, \
+		{5, "JPEG"}, \
+		{6, "VC1"}, \
+		{7, "AVS"}, \
+		{8, "YUV"}, \
+		{9, "H264MVC"}, \
+		{10, "H264_4K2K"}, \
+		{11, "H265"}, \
+		{12, "ENC_AVC"}, \
+		{13, "ENC_JPEG"}, \
+		{14, "VP9"})
+
+TRACE_EVENT(vdec_set_format,
+	TP_PROTO(struct vdec_s *vdec, int format),
+	TP_ARGS(vdec, format),
+	TP_STRUCT__entry(
+		__field(struct vdec_s *, vdec)
+		__field(int, format)
+	),
+	TP_fast_assign(
+		 __entry->vdec = vdec;
+		 __entry->format = format;
+	),
+	TP_printk("[%p]:%s", __entry->vdec,
+		format_name(__entry->format))
+);
+
+/* status events */
+#define status_name(status) \
+	__print_symbolic(status, \
+		{0, "UNINITIALIZED"}, \
+		{1, "DISCONNECTED"}, \
+		{2, "CONNECTED"}, \
+		{3, "ACTIVE"})
+
+DECLARE_EVENT_CLASS(vdec_status_class,
+	TP_PROTO(struct vdec_s *vdec, int state),
+	TP_ARGS(vdec, state),
+	TP_STRUCT__entry(
+		__field(struct vdec_s *, vdec)
+		__field(int, state)
+	),
+	TP_fast_assign(
+		__entry->vdec = vdec;
+		__entry->state = state;
+	),
+	TP_printk("[%p]:%s", __entry->vdec, status_name(__entry->state))
+);
+
+#define DEFINE_STATUS_EVENT(name) \
+DEFINE_EVENT(vdec_status_class, name, \
+	TP_PROTO(struct vdec_s *vdec, int status), \
+	TP_ARGS(vdec, status))
+
+DEFINE_STATUS_EVENT(vdec_set_status);
+DEFINE_STATUS_EVENT(vdec_set_next_status);
+
+/* set pts events */
+DECLARE_EVENT_CLASS(vdec_pts_class,
+	TP_PROTO(struct vdec_s *vdec, u64 pts),
+	TP_ARGS(vdec, pts),
+	TP_STRUCT__entry(
+		__field(struct vdec_s *, vdec)
+		__field(u64, pts)
+	),
+	TP_fast_assign(
+		__entry->vdec = vdec;
+		__entry->pts = pts;
+	),
+	TP_printk("[%p]%llu", __entry->vdec, __entry->pts)
+);
+
+#define DEFINE_PTS_EVENT(name) \
+DEFINE_EVENT(vdec_pts_class, name, \
+	TP_PROTO(struct vdec_s *vdec, u64 pts), \
+	TP_ARGS(vdec, pts))
+
+DEFINE_PTS_EVENT(vdec_set_pts);
+DEFINE_PTS_EVENT(vdec_set_pts64);
+
+#endif /* _VDEC_TRACE_H */
+
+/*
+#undef TRACE_INCLUDE_PATH
+#undef TRACE_INCLUDE_FILE
+#define TRACE_INCLUDE_PATH .
+#define TRACE_INCLUDE_FILE vdec_trace
+#include <trace/define_trace.h>
+*/
+/**/ //DEBUG_TMP
diff --git a/drivers/frame_provider/decoder/vc1/vvc1.c b/drivers/frame_provider/decoder/vc1/vvc1.c
index 3495d92..64cd6bb 100644
--- a/drivers/frame_provider/decoder/vc1/vvc1.c
+++ b/drivers/frame_provider/decoder/vc1/vvc1.c
@@ -36,6 +36,10 @@
 #include "../utils/vdec.h"
 #include <linux/amlogic/media/registers/register.h>
 #include "../../../stream_input/amports/amports_priv.h"
+#include "../utils/decoder_mmu_box.h"
+#include "../utils/decoder_bmmu_box.h"
+#include <linux/amlogic/media/codec_mm/codec_mm.h>
+#include <linux/amlogic/media/codec_mm/configs.h>
 
 #define DRIVER_NAME "amvdec_vc1"
 #define MODULE_NAME "amvdec_vc1"
@@ -65,8 +69,14 @@
 #define VC1_OFFSET_REG      AV_SCRATCH_C
 #define MEM_OFFSET_REG      AV_SCRATCH_F
 
-#define VF_POOL_SIZE          32
-#define DECODE_BUFFER_NUM_MAX 8
+#define VF_POOL_SIZE		32
+#define DECODE_BUFFER_NUM_MAX	8
+#define WORKSPACE_SIZE		(2 * SZ_1M)
+#define MAX_BMMU_BUFFER_NUM	(DECODE_BUFFER_NUM_MAX + 1)
+#define VF_BUFFER_IDX(n)	(1 + n)
+#define DCAC_BUFF_START_ADDR	0x02e00000
+
+
 #define PUT_INTERVAL        (HZ/100)
 
 #if 1	/* /MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6 */
@@ -75,6 +85,7 @@
 #define MEM_FIFO_CNT_BIT        16
 #define MEM_LEVEL_CNT_BIT       18
 #endif
+static struct vdec_info *gvs;
 
 static struct vframe_s *vvc1_vf_peek(void *);
 static struct vframe_s *vvc1_vf_get(void *);
@@ -82,7 +93,7 @@ static void vvc1_vf_put(struct vframe_s *, void *);
 static int vvc1_vf_states(struct vframe_states *states, void *);
 static int vvc1_event_cb(int type, void *data, void *private_data);
 
-static void vvc1_prot_init(void);
+static int vvc1_prot_init(void);
 static void vvc1_local_init(void);
 
 static const char vvc1_dec_id[] = "vvc1-dev";
@@ -95,7 +106,7 @@ static const struct vframe_operations_s vvc1_vf_provider = {
 	.event_cb = vvc1_event_cb,
 	.vf_states = vvc1_vf_states,
 };
-
+static void *mm_blk_handle;
 static struct vframe_provider_s vvc1_vf_prov;
 
 static DECLARE_KFIFO(newframe_q, struct vframe_s *, VF_POOL_SIZE);
@@ -109,8 +120,8 @@ static int cur_pool_idx;
 static s32 vfbuf_use[DECODE_BUFFER_NUM_MAX];
 static struct timer_list recycle_timer;
 static u32 stat;
-static unsigned long buf_start;
-static u32 buf_size, buf_offset;
+static u32 buf_size = 32 * 1024 * 1024;
+static u32 buf_offset;
 static u32 avi_flag;
 static u32 vvc1_ratio;
 static u32 vvc1_format;
@@ -464,6 +475,10 @@ static irqreturn_t vvc1_isr(int irq, void *dev_id)
 			set_aspect_ratio(vf, READ_VREG(VC1_PIC_RATIO));
 
 			vfbuf_use[buffer_index]++;
+			vf->mem_handle =
+				decoder_bmmu_box_get_mem_handle(
+					mm_blk_handle,
+					buffer_index);
 
 			kfifo_put(&display_q, (const struct vframe_s *)vf);
 
@@ -519,6 +534,10 @@ static irqreturn_t vvc1_isr(int irq, void *dev_id)
 			set_aspect_ratio(vf, READ_VREG(VC1_PIC_RATIO));
 
 			vfbuf_use[buffer_index]++;
+			vf->mem_handle =
+				decoder_bmmu_box_get_mem_handle(
+					mm_blk_handle,
+					buffer_index);
 
 			kfifo_put(&display_q, (const struct vframe_s *)vf);
 
@@ -600,7 +619,10 @@ static irqreturn_t vvc1_isr(int irq, void *dev_id)
 			set_aspect_ratio(vf, READ_VREG(VC1_PIC_RATIO));
 
 			vfbuf_use[buffer_index]++;
-
+			vf->mem_handle =
+				decoder_bmmu_box_get_mem_handle(
+					mm_blk_handle,
+					buffer_index);
 			kfifo_put(&display_q, (const struct vframe_s *)vf);
 
 			vf_notify_receiver(PROVIDER_NAME,
@@ -610,6 +632,10 @@ static irqreturn_t vvc1_isr(int irq, void *dev_id)
 		frame_dur = vvc1_amstream_dec_info.rate;
 		total_frame++;
 
+		/*count info*/
+		gvs->frame_dur = frame_dur;
+		vdec_count_info(gvs, 0, offset);
+
 		/* pr_info("PicType = %d, PTS = 0x%x, repeat
 		count %d\n", picture_type, vf->pts, repeat_count); */
 		WRITE_VREG(VC1_BUFFEROUT, 0);
@@ -682,27 +708,49 @@ static int vvc1_event_cb(int type, void *data, void *private_data)
 	return 0;
 }
 
-int vvc1_dec_status(struct vdec_s *vdec, struct vdec_status *vstatus)
+int vvc1_dec_status(struct vdec_s *vdec, struct vdec_info *vstatus)
 {
-	vstatus->width = vvc1_amstream_dec_info.width;
-	vstatus->height = vvc1_amstream_dec_info.height;
-	if (0 != vvc1_amstream_dec_info.rate)
-		vstatus->fps = 96000 / vvc1_amstream_dec_info.rate;
+	vstatus->frame_width = vvc1_amstream_dec_info.width;
+	vstatus->frame_height = vvc1_amstream_dec_info.height;
+	if (vvc1_amstream_dec_info.rate != 0)
+		vstatus->frame_rate = 96000 / vvc1_amstream_dec_info.rate;
 	else
-		vstatus->fps = 96000;
-	vstatus->error_count = READ_VREG(AV_SCRATCH_4);
+		vstatus->frame_rate = -1;
+	vstatus->error_count = READ_VREG(AV_SCRATCH_C);
 	vstatus->status = stat;
+	vstatus->bit_rate = gvs->bit_rate;
+	vstatus->frame_dur = vvc1_amstream_dec_info.rate;
+	vstatus->frame_data = gvs->frame_data;
+	vstatus->total_data = gvs->total_data;
+	vstatus->frame_count = gvs->frame_count;
+	vstatus->error_frame_count = gvs->error_frame_count;
+	vstatus->drop_frame_count = gvs->drop_frame_count;
+	vstatus->total_data = gvs->total_data;
+	vstatus->samp_cnt = gvs->samp_cnt;
+	vstatus->offset = gvs->offset;
+	snprintf(vstatus->vdec_name, sizeof(vstatus->vdec_name),
+		"%s", DRIVER_NAME);
 
 	return 0;
 }
 
+static int vvc1_vdec_info_init(void)
+{
+	gvs = kzalloc(sizeof(struct vdec_info), GFP_KERNEL);
+	if (NULL == gvs) {
+		pr_info("the struct of vdec status malloc failed.\n");
+		return -ENOMEM;
+	}
+	return 0;
+}
+
 /****************************************/
-static void vvc1_canvas_init(void)
+static int vvc1_canvas_init(void)
 {
-	int i;
+	int i, ret;
 	u32 canvas_width, canvas_height;
-	u32 decbuf_size, decbuf_y_size, decbuf_uv_size;
-	u32 disp_addr = 0xffffffff;
+	u32 alloc_size, decbuf_size, decbuf_y_size, decbuf_uv_size;
+	unsigned long buf_start;
 
 	if (buf_size <= 0x00400000) {
 		/* SD only */
@@ -720,75 +768,56 @@ static void vvc1_canvas_init(void)
 		decbuf_size = 0x300000;
 	}
 
-	if (is_vpp_postblend()) {
-		struct canvas_s cur_canvas;
-
-		canvas_read((READ_VCBUS_REG(VD1_IF0_CANVAS0) & 0xff),
-					&cur_canvas);
-		disp_addr = (cur_canvas.addr + 7) >> 3;
-	}
+	for (i = 0; i < MAX_BMMU_BUFFER_NUM; i++) {
+		/* workspace mem */
+		if (i == (MAX_BMMU_BUFFER_NUM - 1))
+			alloc_size = WORKSPACE_SIZE;
+		else
+			alloc_size = decbuf_size;
+
+		ret = decoder_bmmu_box_alloc_buf_phy(mm_blk_handle, i,
+				alloc_size, DRIVER_NAME, &buf_start);
+		if (ret < 0)
+			return ret;
+		if (i == (MAX_BMMU_BUFFER_NUM - 1)) {
+			buf_offset = buf_start - DCAC_BUFF_START_ADDR;
+			continue;
+		}
 
-	for (i = 0; i < 8; i++) {
-		if (((buf_start + i * decbuf_size + 7) >> 3) == disp_addr) {
 #ifdef NV21
-			canvas_config(2 * i + 0,
-				buf_start + 8 * decbuf_size,
-				canvas_width, canvas_height,
-				CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_32X32);
-			canvas_config(2 * i + 1,
-				buf_start + 8 * decbuf_size +
-				decbuf_y_size, canvas_width,
-				canvas_height / 2, CANVAS_ADDR_NOWRAP,
-				CANVAS_BLKMODE_32X32);
+		canvas_config(2 * i + 0,
+			buf_start,
+			canvas_width, canvas_height,
+			CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_32X32);
+		canvas_config(2 * i + 1,
+			buf_start +
+			decbuf_y_size, canvas_width,
+			canvas_height / 2, CANVAS_ADDR_NOWRAP,
+			CANVAS_BLKMODE_32X32);
 #else
-			canvas_config(3 * i + 0,
-				buf_start + 8 * decbuf_size,
-				canvas_width, canvas_height,
-				CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_32X32);
-			canvas_config(3 * i + 1,
-				buf_start + 8 * decbuf_size +
-				decbuf_y_size, canvas_width / 2,
-				canvas_height / 2, CANVAS_ADDR_NOWRAP,
-				CANVAS_BLKMODE_32X32);
-			canvas_config(3 * i + 2,
-				buf_start + 8 * decbuf_size +
-				decbuf_y_size + decbuf_uv_size,
-				canvas_width / 2, canvas_height / 2,
-				CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_32X32);
+		canvas_config(3 * i + 0,
+			buf_start,
+			canvas_width, canvas_height,
+			CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_32X32);
+		canvas_config(3 * i + 1,
+			buf_start +
+			decbuf_y_size, canvas_width / 2,
+			canvas_height / 2, CANVAS_ADDR_NOWRAP,
+			CANVAS_BLKMODE_32X32);
+		canvas_config(3 * i + 2,
+			buf_start +
+			decbuf_y_size + decbuf_uv_size,
+			canvas_width / 2, canvas_height / 2,
+			CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_32X32);
 #endif
-		} else {
-#ifdef NV21
-			canvas_config(2 * i + 0,
-				buf_start + i * decbuf_size,
-				canvas_width, canvas_height,
-				CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_32X32);
-			canvas_config(2 * i + 1,
-				buf_start + i * decbuf_size +
-				decbuf_y_size, canvas_width,
-				canvas_height / 2, CANVAS_ADDR_NOWRAP,
-				CANVAS_BLKMODE_32X32);
-#else
-			canvas_config(3 * i + 0,
-				buf_start + i * decbuf_size,
-				canvas_width, canvas_height,
-				CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_32X32);
-			canvas_config(3 * i + 1,
-				buf_start + i * decbuf_size +
-				decbuf_y_size, canvas_width / 2,
-				canvas_height / 2, CANVAS_ADDR_NOWRAP,
-				CANVAS_BLKMODE_32X32);
-			canvas_config(3 * i + 2,
-				buf_start + i * decbuf_size +
-				decbuf_y_size + decbuf_uv_size,
-				canvas_width / 2, canvas_height / 2,
-				CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_32X32);
-#endif
-		}
+
 	}
+	return 0;
 }
 
-static void vvc1_prot_init(void)
+static int vvc1_prot_init(void)
 {
+	int r;
 #if 1	/* /MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6 */
 	WRITE_VREG(DOS_SW_RESET0, (1 << 7) | (1 << 6) | (1 << 4));
 	WRITE_VREG(DOS_SW_RESET0, 0);
@@ -802,20 +831,20 @@ static void vvc1_prot_init(void)
 	WRITE_VREG(DOS_SW_RESET0, 0);
 
 #else
-	WRITE_MPEG_REG(RESET0_REGISTER,
+	WRITE_RESET_REG(RESET0_REGISTER,
 				   RESET_IQIDCT | RESET_MC | RESET_VLD_PART);
-	READ_MPEG_REG(RESET0_REGISTER);
-	WRITE_MPEG_REG(RESET0_REGISTER,
+	READ_RESET_REG(RESET0_REGISTER);
+	WRITE_RESET_REG(RESET0_REGISTER,
 				   RESET_IQIDCT | RESET_MC | RESET_VLD_PART);
 
-	WRITE_MPEG_REG(RESET2_REGISTER, RESET_PIC_DC | RESET_DBLK);
+	WRITE_RESET_REG(RESET2_REGISTER, RESET_PIC_DC | RESET_DBLK);
 #endif
 
 	WRITE_VREG(POWER_CTL_VLD, 0x10);
 	WRITE_VREG_BITS(VLD_MEM_VIFIFO_CONTROL, 2, MEM_FIFO_CNT_BIT, 2);
 	WRITE_VREG_BITS(VLD_MEM_VIFIFO_CONTROL, 8, MEM_LEVEL_CNT_BIT, 6);
 
-	vvc1_canvas_init();
+	r = vvc1_canvas_init();
 
 	/* index v << 16 | u << 8 | y */
 #ifdef NV21
@@ -857,6 +886,7 @@ static void vvc1_prot_init(void)
 #ifdef NV21
 	SET_VREG_MASK(MDEC_PIC_DC_CTRL, 1 << 17);
 #endif
+	return r;
 }
 
 static void vvc1_local_init(void)
@@ -899,6 +929,18 @@ static void vvc1_local_init(void)
 			}
 		kfifo_put(&newframe_q, (const struct vframe_s *)vf);
 	}
+	if (mm_blk_handle) {
+		decoder_bmmu_box_free(mm_blk_handle);
+		mm_blk_handle = NULL;
+	}
+
+		mm_blk_handle = decoder_bmmu_box_alloc_box(
+			DRIVER_NAME,
+			0,
+			MAX_BMMU_BUFFER_NUM,
+			4 + PAGE_SHIFT,
+			CODEC_MM_FLAGS_CMA_CLEAR |
+			CODEC_MM_FLAGS_FOR_VDECODER);
 }
 
 #ifdef CONFIG_AMLOGIC_POST_PROCESS_MANAGER
@@ -960,7 +1002,7 @@ static void vvc1_put_timer_func(unsigned long arg)
 
 static s32 vvc1_init(void)
 {
-	int size = -1;
+	int ret = -1, size = -1;
 	char *buf = vmalloc(0x1000 * 16);
 	if (IS_ERR_OR_NULL(buf))
 		return -ENOMEM;
@@ -1004,7 +1046,9 @@ static s32 vvc1_init(void)
 	stat |= STAT_MC_LOAD;
 
 	/* enable AMRISC side protocol */
-	vvc1_prot_init();
+	ret = vvc1_prot_init();
+	if (ret < 0)
+		return ret;
 
 	if (vdec_request_irq(VDEC_IRQ_1, vvc1_isr,
 		    "vvc1-irq", (void *)vvc1_dec_id)) {
@@ -1056,18 +1100,17 @@ static int amvdec_vc1_probe(struct platform_device *pdev)
 		return -EFAULT;
 	}
 
-	buf_start = pdata->mem_start;
-	buf_size = pdata->mem_end - pdata->mem_start + 1;
-	buf_offset = buf_start - ORI_BUFFER_START_ADDR;
-
 	if (pdata->sys_info)
 		vvc1_amstream_dec_info = *pdata->sys_info;
 
 	pdata->dec_status = vvc1_dec_status;
 
+	vvc1_vdec_info_init();
+
 	if (vvc1_init() < 0) {
 		pr_info("amvdec_vc1 init failed.\n");
-
+		kfree(gvs);
+		gvs = NULL;
 		return -ENODEV;
 	}
 
@@ -1101,6 +1144,11 @@ static int amvdec_vc1_remove(struct platform_device *pdev)
 
 	amvdec_disable();
 
+	if (mm_blk_handle) {
+		decoder_bmmu_box_free(mm_blk_handle);
+		mm_blk_handle = NULL;
+	}
+
 #ifdef DEBUG_PTS
 	pr_info("pts hit %d, pts missed %d, i hit %d, missed %d\n", pts_hit,
 		pts_missed, pts_i_hit, pts_i_missed);
@@ -1108,6 +1156,8 @@ static int amvdec_vc1_remove(struct platform_device *pdev)
 		total_frame, avi_flag,
 		vvc1_amstream_dec_info.rate);
 #endif
+	kfree(gvs);
+	gvs = NULL;
 
 	return 0;
 }
@@ -1158,10 +1208,6 @@ static void __exit amvdec_vc1_driver_remove_module(void)
 }
 
 /****************************************/
-
-module_param(stat, uint, 0664);
-MODULE_PARM_DESC(stat, "\n amvdec_vc1 stat\n");
-
 module_init(amvdec_vc1_driver_init_module);
 module_exit(amvdec_vc1_driver_remove_module);
 
diff --git a/drivers/frame_provider/decoder/vp9/vvp9.c b/drivers/frame_provider/decoder/vp9/vvp9.c
index 0e819e7..2f95b27 100644
--- a/drivers/frame_provider/decoder/vp9/vvp9.c
+++ b/drivers/frame_provider/decoder/vp9/vvp9.c
@@ -48,6 +48,8 @@
 #include "../utils/amvdec.h"
 
 #include <linux/amlogic/media/video_sink/video.h>
+#include <linux/amlogic/media/codec_mm/configs.h>
+#include "../utils/config_parser.h"
 
 #define MIX_STREAM_SUPPORT
 #define SUPPORT_4K2K
@@ -77,13 +79,12 @@
 #define HEVC_DECODE_BUFEMPTY        0x20
 #define HEVC_DECODE_TIMEOUT         0x21
 #define HEVC_SEARCH_BUFEMPTY        0x22
+#define HEVC_DECODE_OVER_SIZE       0x23
 #define VP9_HEAD_PARSER_DONE            0xf0
 #define VP9_HEAD_SEARCH_DONE          0xf1
 #define VP9_EOS                        0xf2
 #define HEVC_ACTION_DONE                0xff
 
-#define MAX_BUF_NUM 24
-#define MAX_REF_ACTIVE  16
 #define VF_POOL_SIZE        32
 
 #undef pr_info
@@ -93,6 +94,7 @@
 #define DECODE_MODE_MULTI_STREAMBASE	1
 #define DECODE_MODE_MULTI_FRAMEBASE		2
 
+#define MV_MEM_UNIT 0x240
 /*---------------------------------------------------
  Include "parser_cmd.h"
 ---------------------------------------------------*/
@@ -162,12 +164,38 @@ unsigned short parser_cmd[PARSER_CMD_NUMBER] = {
 #endif
 
 #ifdef MULTI_INSTANCE_SUPPORT
-#define MAX_DECODE_INSTANCE_NUM     5
+#define MAX_DECODE_INSTANCE_NUM     12
 #define MULTI_DRIVER_NAME "ammvdec_vp9"
+
+static unsigned int max_decode_instance_num
+				= MAX_DECODE_INSTANCE_NUM;
+static unsigned int decode_frame_count[MAX_DECODE_INSTANCE_NUM];
+static unsigned int display_frame_count[MAX_DECODE_INSTANCE_NUM];
+static unsigned int max_process_time[MAX_DECODE_INSTANCE_NUM];
+static unsigned int run_count[MAX_DECODE_INSTANCE_NUM];
+static unsigned int input_empty[MAX_DECODE_INSTANCE_NUM];
+static unsigned int not_run_ready[MAX_DECODE_INSTANCE_NUM];
+
+static u32 decode_timeout_val = 200;
+static int start_decode_buf_level = 0x8000;
+#ifdef VP9_10B_MMU
+static u32 work_buf_size; /* = 24 * 1024 * 1024*/;
+#else
+static u32 work_buf_size = 32 * 1024 * 1024;
 #endif
 
+static u32 mv_buf_margin;
+
+/* DOUBLE_WRITE_MODE is enabled only when NV21 8 bit output is needed */
+/* double_write_mode: 0, no double write; 1, 1:1 ratio; 2, (1/4):(1/4) ratio
+	0x10, double write only
+*/
+static u32 double_write_mode;
+
 #define DRIVER_NAME "amvdec_vp9"
 #define MODULE_NAME "amvdec_vp9"
+#define DRIVER_HEADER_NAME "amvdec_vp9_header"
+
 
 #define PUT_INTERVAL        (HZ/100)
 #define ERROR_SYSTEM_RESET_COUNT   200
@@ -192,6 +220,10 @@ static s32 vvp9_init(struct VP9Decoder_s *pbi);
 static void vvp9_prot_init(struct VP9Decoder_s *pbi);
 static int vvp9_local_init(struct VP9Decoder_s *pbi);
 static void vvp9_put_timer_func(unsigned long arg);
+static void dump_data(struct VP9Decoder_s *pbi, int size);
+static unsigned char get_data_check_sum
+	(struct VP9Decoder_s *pbi, int size);
+static void dump_pic_list(struct VP9Decoder_s *pbi);
 #ifdef VP9_10B_MMU
 static int vp9_alloc_mmu(
 		struct VP9Decoder_s *pbi,
@@ -259,6 +291,11 @@ struct BUF_s {
 	unsigned int free_start_adr;
 } /*BUF_t */;
 
+struct MVBUF_s {
+	unsigned long start_adr;
+	unsigned int size;
+	int used_flag;
+} /*MVBUF_t */;
 
 	/* #undef BUFMGR_ONLY to enable hardware configuration */
 
@@ -301,26 +338,23 @@ typedef unsigned short u16;
 
 #define VP9_DEBUG_BUFMGR                   0x01
 #define VP9_DEBUG_BUFMGR_MORE              0x02
-#define VP9_DEBUG_UCODE                    0x04
-#define VP9_DEBUG_REG                      0x08
-#define VP9_DEBUG_MERGE			0x10
-#define VP9_DEBUG_BASIC				        0x40
+#define VP9_DEBUG_BUFMGR_DETAIL            0x04
+#define VP9_DEBUG_OUT_PTS                  0x10
 #define VP9_DEBUG_SEND_PARAM_WITH_REG      0x100
-#define VP9_DEBUG_NO_DISPLAY               0x200
+#define VP9_DEBUG_MERGE                    0x200
 #define VP9_DEBUG_DBG_LF_PRINT             0x400
-#define VP9_DEBUG_OUT_PTS                  0x800
-#define VP9_DEBUG_VF_REF				   0x1000
+#define VP9_DEBUG_REG                      0x800
 #define VP9_DEBUG_DIS_LOC_ERROR_PROC       0x10000
 #define VP9_DEBUG_DIS_SYS_ERROR_PROC   0x20000
 #define VP9_DEBUG_DUMP_PIC_LIST       0x40000
 #define VP9_DEBUG_TRIG_SLICE_SEGMENT_PROC 0x80000
 #define VP9_DEBUG_HW_RESET               0x100000
 #define VP9_DEBUG_LOAD_UCODE_FROM_FILE   0x200000
-#define VP9_DEBUG_ERROR_TRIG             0x400000
-#define VP9_DEBUG_NOWAIT_DECODE_DONE_WHEN_STOP   0x4000000
+#define VP9_DEBUG_FORCE_SEND_AGAIN       0x400000
+#define VP9_DEBUG_DUMP_DATA              0x800000
+#define IGNORE_PARAM_FROM_CONFIG		0x8000000
 #ifdef MULTI_INSTANCE_SUPPORT
 #define PRINT_FLAG_ERROR				0
-#define PRINT_FLAG_UCODE_EVT             0x10000000
 #define PRINT_FLAG_VDEC_STATUS             0x20000000
 #define PRINT_FLAG_VDEC_DETAIL             0x40000000
 #define PRINT_FLAG_VDEC_DATA             0x80000000
@@ -328,6 +362,31 @@ typedef unsigned short u16;
 
 static u32 debug;
 
+/*for debug*/
+/*
+	udebug_flag:
+	bit 0, enable ucode print
+	bit 1, enable ucode detail print
+	bit [31:16] not 0, pos to dump lmem
+		bit 2, pop bits to lmem
+		bit [11:8], pre-pop bits for alignment (when bit 2 is 1)
+*/
+static u32 udebug_flag;
+/*
+	when udebug_flag[1:0] is not 0
+	udebug_pause_pos not 0,
+		pause position
+*/
+static u32 udebug_pause_pos;
+/*
+	when udebug_flag[1:0] is not 0
+	and udebug_pause_pos is not 0,
+		pause only when DEBUG_REG2 is equal to this val
+*/
+static u32 udebug_pause_val;
+
+static u32 udebug_pause_decode_idx;
+
 #define DEBUG_REG
 #ifdef DEBUG_REG
 void WRITE_VREG_DBG2(unsigned adr, unsigned val)
@@ -431,6 +490,7 @@ enum vpx_bit_depth_t {
 struct PIC_BUFFER_CONFIG_s {
 	int index;
 	int BUF_index;
+	int mv_buf_index;
 	int comp_body_size;
 	int buf_size;
 	int vf_ref;
@@ -441,13 +501,9 @@ struct PIC_BUFFER_CONFIG_s {
 #endif
 	int decode_idx;
 	int slice_type;
-	int num_reorder_pic;
 	int stream_offset;
-	uint8_t used_by_display;
-	uint8_t referenced;
-	uint8_t output_mark;
-	uint8_t recon_mark;
-	uint8_t output_ready;
+	u32 pts;
+	u64 pts64;
 	uint8_t error_mark;
 	/**/
 	int slice_idx;
@@ -539,12 +595,25 @@ TODO(hkuang): Add ondemand frame buffers instead of hardcoding the number
 // of framebuffers.
 TODO(jkoleszar): These 3 extra references could probably come from the
 normal reference pool.*/
-#define FRAME_BUFFERS (REF_FRAMES + 7)
+#define FRAME_BUFFERS (REF_FRAMES + 16)
+#define HEADER_FRAME_BUFFERS (FRAME_BUFFERS)
+#define MAX_BUF_NUM (FRAME_BUFFERS)
 
 #define FRAME_CONTEXTS_LOG2 2
 #define FRAME_CONTEXTS (1 << FRAME_CONTEXTS_LOG2)
-#define MAX_BMMU_BUFFER_NUM (FRAME_BUFFERS + 1)
-#define WORK_SPACE_BUF_ID (FRAME_BUFFERS)
+/*buffer + header buffer + workspace*/
+#ifdef MV_USE_FIXED_BUF
+#define MAX_BMMU_BUFFER_NUM (FRAME_BUFFERS + HEADER_FRAME_BUFFERS + 1)
+#define VF_BUFFER_IDX(n) (n)
+#define HEADER_BUFFER_IDX(n) (FRAME_BUFFERS + n)
+#define WORK_SPACE_BUF_ID (FRAME_BUFFERS + HEADER_FRAME_BUFFERS)
+#else
+#define MAX_BMMU_BUFFER_NUM ((FRAME_BUFFERS * 2) + HEADER_FRAME_BUFFERS + 1)
+#define VF_BUFFER_IDX(n) (n)
+#define HEADER_BUFFER_IDX(n) (FRAME_BUFFERS + n)
+#define MV_BUFFER_IDX(n) ((FRAME_BUFFERS * 2) + n)
+#define WORK_SPACE_BUF_ID ((FRAME_BUFFERS * 2) + HEADER_FRAME_BUFFERS)
+#endif
 
 struct RefCntBuffer_s {
 	int ref_count;
@@ -606,14 +675,11 @@ vpx_release_frame_buffer_cb_fn_t release_fb_cb;*/
 
 } BufferPool;
 
-static void lock_buffer_pool(struct BufferPool_s *pool)
-{
-	spin_lock_irqsave(&pool->lock, pool->flags);
-}
-static void unlock_buffer_pool(struct BufferPool_s *pool)
-{
-	spin_unlock_irqrestore(&pool->lock, pool->flags);
-}
+#define lock_buffer_pool(pool, flags) \
+		spin_lock_irqsave(&pool->lock, flags)
+
+#define unlock_buffer_pool(pool, flags) \
+		spin_unlock_irqrestore(&pool->lock, flags)
 
 struct VP9_Common_s {
 	enum vpx_color_space_t color_space;
@@ -649,7 +715,9 @@ struct VP9_Common_s {
 
 	int prev_fb_idx;
 	int new_fb_idx;
-
+#ifdef VP9_10B_MMU
+	int cur_fb_idx_mmu;
+#endif
 	/*last frame's frame type for motion search*/
 	enum FRAME_TYPE last_frame_type;
 	enum FRAME_TYPE frame_type;
@@ -718,60 +786,10 @@ struct VP9_Common_s {
 
 } VP9_COMMON;
 
-static void set_canvas(struct PIC_BUFFER_CONFIG_s *pic_config);
+static void set_canvas(struct VP9Decoder_s *pbi,
+	struct PIC_BUFFER_CONFIG_s *pic_config);
 static int prepare_display_buf(struct VP9Decoder_s *pbi,
 					struct PIC_BUFFER_CONFIG_s *pic_config);
-static int get_free_fb(struct VP9_Common_s *cm)
-{
-	struct RefCntBuffer_s *const frame_bufs = cm->buffer_pool->frame_bufs;
-	int i;
-
-	lock_buffer_pool(cm->buffer_pool);
-	for (i = 0; i < FRAME_BUFFERS; ++i) {
-		if (debug & VP9_DEBUG_BUFMGR_MORE)
-			pr_info("%s:%d, ref_count %d vf_ref %d used_by_d %d index %d\r\n",
-			__func__, i, frame_bufs[i].ref_count,
-			frame_bufs[i].buf.vf_ref,
-			frame_bufs[i].buf.used_by_display,
-			frame_bufs[i].buf.index);
-		if ((frame_bufs[i].ref_count == 0) &&
-			(frame_bufs[i].buf.vf_ref == 0) &&
-			(frame_bufs[i].buf.used_by_display == 0) &&
-			(frame_bufs[i].buf.index != -1)
-			)
-			break;
-	}
-	if (i != FRAME_BUFFERS) {
-		frame_bufs[i].ref_count = 1;
-		/*pr_info("[MMU DEBUG 1] set ref_count[%d] : %d\r\n",
-					i, frame_bufs[i].ref_count);*/
-	} else {
-		/* Reset i to be INVALID_IDX to indicate
-			no free buffer found*/
-		i = INVALID_IDX;
-	}
-
-	unlock_buffer_pool(cm->buffer_pool);
-	return i;
-}
-
-static unsigned char is_buffer_empty(struct VP9_Common_s *cm)
-{
-	struct RefCntBuffer_s *const frame_bufs = cm->buffer_pool->frame_bufs;
-	int i;
-
-	for (i = 0; i < FRAME_BUFFERS; ++i)
-		if ((frame_bufs[i].ref_count == 0) &&
-			(frame_bufs[i].buf.vf_ref == 0) &&
-			(frame_bufs[i].buf.used_by_display == 0) &&
-			(frame_bufs[i].buf.index != -1)
-			)
-			break;
-	if (i != FRAME_BUFFERS)
-		return 0;
-
-	return 1;
-}
 
 static struct PIC_BUFFER_CONFIG_s *get_frame_new_buffer(struct VP9_Common_s *cm)
 {
@@ -902,6 +920,7 @@ static int setup_frame_size(
 			ret);
 		return ret;
 	}
+	cm->cur_fb_idx_mmu = cm->new_fb_idx;
 #endif
 
 	resize_context_buffers(cm, width, height);
@@ -1014,6 +1033,7 @@ static int setup_frame_size_with_refs(
 			cm->new_fb_idx);
 		return ret;
 	}
+	cm->cur_fb_idx_mmu = cm->new_fb_idx;
 #endif
 
 	/*Check to make sure at least one of frames that this frame references
@@ -1113,7 +1133,9 @@ struct BuffInfo_s {
 	struct buff_s cm_header;
 #endif
 	struct buff_s mpred_above;
+#ifdef MV_USE_FIXED_BUF
 	struct buff_s mpred_mv;
+#endif
 	struct buff_s rpm;
 	struct buff_s lmem;
 } BuffInfo_t;
@@ -1128,9 +1150,14 @@ struct BuffInfo_s {
 #define DEC_UNINIT_PICLIST			6
 #define DEC_RESULT_GET_DATA         7
 #define DEC_RESULT_GET_DATA_RETRY   8
+#define DEC_RESULT_EOS              9
+#define DEC_RESULT_FORCE_EXIT       10
 
 static void vp9_work(struct work_struct *work);
 #endif
+struct loop_filter_info_n;
+struct loopfilter;
+struct segmentation;
 
 struct VP9Decoder_s {
 #ifdef MULTI_INSTANCE_SUPPORT
@@ -1143,12 +1170,23 @@ struct VP9Decoder_s {
 	struct vframe_chunk_s *chunk;
 	int dec_result;
 	struct work_struct work;
+	u32 start_shift_bytes;
 
 	struct BuffInfo_s work_space_buf_store;
 	unsigned long buf_start;
 	u32 buf_size;
 	u32 cma_alloc_count;
 	unsigned long cma_alloc_addr;
+	uint8_t eos;
+	unsigned long int start_process_time;
+	unsigned last_lcu_idx;
+	int decode_timeout_count;
+	unsigned timeout_num;
+
+	int double_write_mode;
+#endif
+#ifdef VP9_10B_MMU
+	long used_4k_num;
 #endif
 	unsigned char m_ins_flag;
 	char *provider_name;
@@ -1162,8 +1200,16 @@ struct VP9Decoder_s {
 	int fatal_error;
 	uint8_t init_flag;
 	uint8_t process_busy;
+#define PROC_STATE_INIT			0
+#define PROC_STATE_DECODESLICE	1
+#define PROC_STATE_SENDAGAIN	2
+	uint8_t process_state;
+	u32 ucode_pause_pos;
+
 	int show_frame_num;
+#ifndef VP9_10B_MMU
 	struct buff_s mc_buf_spec;
+#endif
 	struct dec_sysinfo vvp9_amstream_dec_info;
 	void *rpm_addr;
 	void *lmem_addr;
@@ -1185,11 +1231,15 @@ struct VP9Decoder_s {
 	unsigned int use_cma_flag;
 
 	struct BUF_s m_BUF[MAX_BUF_NUM];
+	struct MVBUF_s m_mv_BUF[MAX_BUF_NUM];
 	u32 used_buf_num;
 	DECLARE_KFIFO(newframe_q, struct vframe_s *, VF_POOL_SIZE);
 	DECLARE_KFIFO(display_q, struct vframe_s *, VF_POOL_SIZE);
 	DECLARE_KFIFO(pending_q, struct vframe_s *, VF_POOL_SIZE);
 	struct vframe_s vfpool[VF_POOL_SIZE];
+	u32 vf_pre_count;
+	u32 vf_get_count;
+	u32 vf_put_count;
 	int buf_num;
 	int pic_num;
 	int lcu_size_log2;
@@ -1221,8 +1271,9 @@ struct VP9Decoder_s {
 	struct BufferPool_s vp9_buffer_pool;
 
 	struct BuffInfo_s *work_space_buf;
+#ifndef VP9_10B_MMU
 	struct buff_s *mc_buf;
-
+#endif
 	unsigned int frame_width;
 	unsigned int frame_height;
 
@@ -1247,6 +1298,14 @@ struct VP9Decoder_s {
 	int PB_skip_count_after_decoding;
 	/*hw*/
 
+	/*lf*/
+	int default_filt_lvl;
+	struct loop_filter_info_n *lfi;
+	struct loopfilter *lf;
+	struct segmentation *seg_4lf;
+	/**/
+	struct vdec_info *gvs;
+
 	u32 pre_stream_offset;
 
 	unsigned int dec_status;
@@ -1293,6 +1352,42 @@ static int vp9_print_cont(struct VP9Decoder_s *pbi,
 	}
 	return 0;
 }
+
+static void reset_process_time(struct VP9Decoder_s *pbi)
+{
+	if (pbi->start_process_time) {
+		unsigned process_time =
+			1000 * (jiffies - pbi->start_process_time) / HZ;
+		pbi->start_process_time = 0;
+		if (process_time > max_process_time[pbi->index])
+			max_process_time[pbi->index] = process_time;
+	}
+}
+
+static void start_process_time(struct VP9Decoder_s *pbi)
+{
+	pbi->start_process_time = jiffies;
+	pbi->decode_timeout_count = 0;
+	pbi->last_lcu_idx = 0;
+}
+
+static void timeout_process(struct VP9Decoder_s *pbi)
+{
+	pbi->timeout_num++;
+	amhevc_stop();
+	vp9_print(pbi,
+		0, "%s decoder timeout\n", __func__);
+
+	pbi->dec_result = DEC_RESULT_DONE;
+	reset_process_time(pbi);
+	vdec_schedule_work(&pbi->work);
+}
+
+static int get_double_write_mode(struct VP9Decoder_s *pbi)
+{
+	return pbi->m_ins_flag ?
+		pbi->double_write_mode : double_write_mode;
+}
 #endif
 
 #ifdef VP9_10B_MMU
@@ -1318,6 +1413,208 @@ int vp9_alloc_mmu(
 		mmu_index_adr);
 }
 #endif
+
+#ifndef MV_USE_FIXED_BUF
+static void dealloc_mv_bufs(struct VP9Decoder_s *pbi)
+{
+	int i;
+	for (i = 0; i < FRAME_BUFFERS; i++) {
+		if (pbi->m_mv_BUF[i].start_adr) {
+			if (debug)
+				pr_info(
+				"dealloc mv buf(%d) adr %ld size 0x%x used_flag %d\n",
+				i, pbi->m_mv_BUF[i].start_adr,
+				pbi->m_mv_BUF[i].size,
+				pbi->m_mv_BUF[i].used_flag);
+			decoder_bmmu_box_free_idx(
+				pbi->bmmu_box,
+				MV_BUFFER_IDX(i));
+			pbi->m_mv_BUF[i].start_adr = 0;
+			pbi->m_mv_BUF[i].size = 0;
+			pbi->m_mv_BUF[i].used_flag = 0;
+		}
+	}
+}
+
+static int alloc_mv_buf(struct VP9Decoder_s *pbi,
+	int i, int size)
+{
+	int ret = 0;
+	if (decoder_bmmu_box_alloc_buf_phy
+		(pbi->bmmu_box,
+		MV_BUFFER_IDX(i), size,
+		DRIVER_NAME,
+		&pbi->m_mv_BUF[i].start_adr) < 0) {
+		pbi->m_mv_BUF[i].start_adr = 0;
+		ret = -1;
+	} else {
+		pbi->m_mv_BUF[i].size = size;
+		pbi->m_mv_BUF[i].used_flag = 0;
+		ret = 0;
+		if (debug) {
+			pr_info(
+			"MV Buffer %d: start_adr %p size %x\n",
+			i,
+			(void *)pbi->m_mv_BUF[i].start_adr,
+			pbi->m_mv_BUF[i].size);
+		}
+	}
+	return ret;
+}
+
+static int init_mv_buf_list(struct VP9Decoder_s *pbi)
+{
+	int i;
+	int ret = 0;
+	int count = FRAME_BUFFERS;
+	int pic_width = pbi->init_pic_w;
+	int pic_height = pbi->init_pic_h;
+	int lcu_size = 64; /*fixed 64*/
+	int pic_width_64 = (pic_width + 63) & (~0x3f);
+	int pic_height_32 = (pic_height + 31) & (~0x1f);
+	int pic_width_lcu  = (pic_width_64 % lcu_size) ?
+				pic_width_64 / lcu_size  + 1
+				: pic_width_64 / lcu_size;
+	int pic_height_lcu = (pic_height_32 % lcu_size) ?
+				pic_height_32 / lcu_size + 1
+				: pic_height_32 / lcu_size;
+	int lcu_total       = pic_width_lcu * pic_height_lcu;
+	int size = ((lcu_total * MV_MEM_UNIT) + 0xffff) &
+		(~0xffff);
+	if (mv_buf_margin > 0)
+		count = REF_FRAMES + mv_buf_margin;
+	for (i = 0; i < count; i++) {
+		if (alloc_mv_buf(pbi, i, size) < 0) {
+			ret = -1;
+			break;
+		}
+	}
+	return ret;
+}
+
+static int get_mv_buf(struct VP9Decoder_s *pbi,
+				struct PIC_BUFFER_CONFIG_s *pic)
+{
+	int i;
+	int ret = -1;
+	for (i = 0; i < FRAME_BUFFERS; i++) {
+		if (pbi->m_mv_BUF[i].start_adr &&
+			pbi->m_mv_BUF[i].used_flag == 0) {
+			pbi->m_mv_BUF[i].used_flag = 1;
+			ret = i;
+			break;
+		}
+	}
+
+	if (ret >= 0) {
+		pic->mv_buf_index = ret;
+		pic->mpred_mv_wr_start_addr =
+			(pbi->m_mv_BUF[ret].start_adr + 0xffff) &
+			(~0xffff);
+		if (debug & VP9_DEBUG_BUFMGR_MORE)
+			pr_info(
+			"%s => %d (%ld) size 0x%x\n",
+			__func__, ret,
+			pic->mpred_mv_wr_start_addr,
+			pbi->m_mv_BUF[ret].size);
+	} else {
+		pr_info(
+		"%s: Error, mv buf is not enough\n",
+		__func__);
+	}
+	return ret;
+}
+
+static void put_mv_buf(struct VP9Decoder_s *pbi,
+				struct PIC_BUFFER_CONFIG_s *pic)
+{
+	int i = pic->mv_buf_index;
+	if (i >= FRAME_BUFFERS) {
+		if (debug & VP9_DEBUG_BUFMGR_MORE)
+			pr_info(
+			"%s: index %d beyond range\n",
+			__func__, i);
+		return;
+	}
+	if (debug & VP9_DEBUG_BUFMGR_MORE)
+		pr_info(
+		"%s(%d): used_flag(%d)\n",
+		__func__, i,
+		pbi->m_mv_BUF[i].used_flag);
+
+	pic->mv_buf_index = -1;
+	if (pbi->m_mv_BUF[i].start_adr &&
+		pbi->m_mv_BUF[i].used_flag)
+		pbi->m_mv_BUF[i].used_flag = 0;
+}
+
+static void	put_un_used_mv_bufs(struct VP9Decoder_s *pbi)
+{
+	struct VP9_Common_s *const cm = &pbi->common;
+	struct RefCntBuffer_s *const frame_bufs = cm->buffer_pool->frame_bufs;
+	int i;
+	for (i = 0; i < pbi->used_buf_num; ++i) {
+		if ((frame_bufs[i].ref_count == 0) &&
+			(frame_bufs[i].buf.index != -1) &&
+			(frame_bufs[i].buf.mv_buf_index >= 0)
+			)
+			put_mv_buf(pbi, &frame_bufs[i].buf);
+	}
+}
+#endif
+
+static int get_free_fb(struct VP9Decoder_s *pbi)
+{
+	struct VP9_Common_s *const cm = &pbi->common;
+	struct RefCntBuffer_s *const frame_bufs = cm->buffer_pool->frame_bufs;
+	int i;
+	unsigned long flags;
+
+	lock_buffer_pool(cm->buffer_pool, flags);
+	if (debug & VP9_DEBUG_BUFMGR_MORE) {
+		for (i = 0; i < pbi->used_buf_num; ++i) {
+			pr_info("%s:%d, ref_count %d vf_ref %d index %d\r\n",
+			__func__, i, frame_bufs[i].ref_count,
+			frame_bufs[i].buf.vf_ref,
+			frame_bufs[i].buf.index);
+		}
+	}
+	for (i = 0; i < pbi->used_buf_num; ++i) {
+		if ((frame_bufs[i].ref_count == 0) &&
+			(frame_bufs[i].buf.vf_ref == 0) &&
+			(frame_bufs[i].buf.index != -1)
+			)
+			break;
+	}
+	if (i != pbi->used_buf_num) {
+		frame_bufs[i].ref_count = 1;
+		/*pr_info("[MMU DEBUG 1] set ref_count[%d] : %d\r\n",
+					i, frame_bufs[i].ref_count);*/
+	} else {
+		/* Reset i to be INVALID_IDX to indicate
+			no free buffer found*/
+		i = INVALID_IDX;
+	}
+
+	unlock_buffer_pool(cm->buffer_pool, flags);
+	return i;
+}
+
+static int get_free_buf_count(struct VP9Decoder_s *pbi)
+{
+	struct VP9_Common_s *const cm = &pbi->common;
+	struct RefCntBuffer_s *const frame_bufs = cm->buffer_pool->frame_bufs;
+	int i;
+	int free_buf_count = 0;
+	for (i = 0; i < pbi->used_buf_num; ++i)
+		if ((frame_bufs[i].ref_count == 0) &&
+			(frame_bufs[i].buf.vf_ref == 0) &&
+			(frame_bufs[i].buf.index != -1)
+			)
+			free_buf_count++;
+	return free_buf_count;
+}
+
 static void decrease_ref_count(int idx, struct RefCntBuffer_s *const frame_bufs,
 					struct BufferPool_s *const pool)
 {
@@ -1344,9 +1641,10 @@ static void generate_next_ref_frames(struct VP9Decoder_s *pbi)
 	struct RefCntBuffer_s *frame_bufs = cm->buffer_pool->frame_bufs;
 	struct BufferPool_s *const pool = cm->buffer_pool;
 	int mask, ref_index = 0;
+	unsigned long flags;
 
 	/* Generate next_ref_frame_map.*/
-	lock_buffer_pool(pool);
+	lock_buffer_pool(pool, flags);
 	for (mask = pbi->refresh_frame_flags; mask; mask >>= 1) {
 		if (mask & 1) {
 			cm->next_ref_frame_map[ref_index] = cm->new_fb_idx;
@@ -1378,7 +1676,7 @@ static void generate_next_ref_frames(struct VP9Decoder_s *pbi)
 			frame_bufs[cm->ref_frame_map[ref_index]].ref_count);*/
 		}
 	}
-	unlock_buffer_pool(pool);
+	unlock_buffer_pool(pool, flags);
 	return;
 }
 
@@ -1389,8 +1687,9 @@ static void refresh_ref_frames(struct VP9Decoder_s *pbi)
 	struct BufferPool_s *pool = cm->buffer_pool;
 	struct RefCntBuffer_s *frame_bufs = cm->buffer_pool->frame_bufs;
 	int mask, ref_index = 0;
+	unsigned long flags;
 
-	lock_buffer_pool(pool);
+	lock_buffer_pool(pool, flags);
 	for (mask = pbi->refresh_frame_flags; mask; mask >>= 1) {
 		const int old_idx = cm->ref_frame_map[ref_index];
 		/*Current thread releases the holding of reference frame.*/
@@ -1412,7 +1711,7 @@ static void refresh_ref_frames(struct VP9Decoder_s *pbi)
 		cm->ref_frame_map[ref_index] =
 			cm->next_ref_frame_map[ref_index];
 	}
-	unlock_buffer_pool(pool);
+	unlock_buffer_pool(pool, flags);
 	return;
 }
 int vp9_bufmgr_process(struct VP9Decoder_s *pbi, union param_u *params)
@@ -1432,13 +1731,16 @@ int vp9_bufmgr_process(struct VP9Decoder_s *pbi, union param_u *params)
 	}
 	pbi->has_keyframe = 1;
 	on_no_keyframe_skiped = 0;
+/*
 #ifdef VP9_10B_MMU
+	if (!pbi->m_ins_flag)
+		pbi->used_4k_num = (READ_VREG(HEVC_SAO_MMU_STATUS) >> 16);
 	if (cm->prev_fb_idx >= 0) {
-		long used_4k_num = (READ_VREG(HEVC_SAO_MMU_STATUS) >> 16);
 		decoder_mmu_box_free_idx_tail(pbi->mmu_box,
-		cm->prev_fb_idx, used_4k_num);
+		cm->prev_fb_idx, pbi->used_4k_num);
 	}
 #endif
+*/
 	if (cm->new_fb_idx >= 0
 		&& frame_bufs[cm->new_fb_idx].ref_count == 0){
 		vp9_release_frame_buffer
@@ -1446,15 +1748,29 @@ int vp9_bufmgr_process(struct VP9Decoder_s *pbi, union param_u *params)
 	}
 	/*pr_info("Before get_free_fb, prev_fb_idx : %d, new_fb_idx : %d\r\n",
 		cm->prev_fb_idx, cm->new_fb_idx);*/
-	cm->new_fb_idx = get_free_fb(cm);
-	cm->cur_frame = &pool->frame_bufs[cm->new_fb_idx];
-	/*if (debug & VP9_DEBUG_BUFMGR)
-		pr_info("[VP9 DEBUG]%s(get_free_fb): %d\r\n", __func__,
-				cm->new_fb_idx);*/
+#ifndef MV_USE_FIXED_BUF
+	put_un_used_mv_bufs(pbi);
+	if (debug & VP9_DEBUG_BUFMGR_DETAIL)
+		dump_pic_list(pbi);
+#endif
+	cm->new_fb_idx = get_free_fb(pbi);
 	if (cm->new_fb_idx == INVALID_IDX) {
 		pr_info("get_free_fb error\r\n");
 		return -1;
 	}
+#ifndef MV_USE_FIXED_BUF
+	if (get_mv_buf(pbi, &pool->frame_bufs[cm->new_fb_idx].buf) < 0) {
+		pr_info("get_mv_buf fail\r\n");
+		return -1;
+	}
+	if (debug & VP9_DEBUG_BUFMGR_DETAIL)
+		dump_pic_list(pbi);
+#endif
+	cm->cur_frame = &pool->frame_bufs[cm->new_fb_idx];
+	/*if (debug & VP9_DEBUG_BUFMGR)
+		pr_info("[VP9 DEBUG]%s(get_free_fb): %d\r\n", __func__,
+				cm->new_fb_idx);*/
+
 	pbi->cur_buf = &frame_bufs[cm->new_fb_idx];
 #ifdef VP9_10B_MMU
 	/* moved to after picture size ready
@@ -1475,6 +1791,7 @@ int vp9_bufmgr_process(struct VP9Decoder_s *pbi, union param_u *params)
 		/* Show an existing frame directly.*/
 		int frame_to_show_idx = params->p.frame_to_show_idx;
 		int frame_to_show;
+		unsigned long flags;
 		if (frame_to_show_idx >= REF_FRAMES) {
 			pr_info("frame_to_show_idx %d exceed max index\r\n",
 					frame_to_show_idx);
@@ -1483,10 +1800,10 @@ int vp9_bufmgr_process(struct VP9Decoder_s *pbi, union param_u *params)
 
 		frame_to_show = cm->ref_frame_map[frame_to_show_idx];
 		/*pr_info("frame_to_show %d\r\n", frame_to_show);*/
-		lock_buffer_pool(pool);
+		lock_buffer_pool(pool, flags);
 		if (frame_to_show < 0 ||
 			frame_bufs[frame_to_show].ref_count < 1) {
-			unlock_buffer_pool(pool);
+			unlock_buffer_pool(pool, flags);
 			pr_err
 			("Error:Buffer %d does not contain a decoded frame",
 			frame_to_show);
@@ -1494,7 +1811,7 @@ int vp9_bufmgr_process(struct VP9Decoder_s *pbi, union param_u *params)
 		}
 
 		ref_cnt_fb(frame_bufs, &cm->new_fb_idx, frame_to_show);
-		unlock_buffer_pool(pool);
+		unlock_buffer_pool(pool, flags);
 		pbi->refresh_frame_flags = 0;
 		/*cm->lf.filter_level = 0;*/
 		cm->show_frame = 1;
@@ -1652,9 +1969,11 @@ int vp9_bufmgr_process(struct VP9Decoder_s *pbi, union param_u *params)
 	get_frame_new_buffer(cm)->color_space = cm->color_space;
 	get_frame_new_buffer(cm)->slice_type = cm->frame_type;
 
-	if (pbi->need_resync)
+	if (pbi->need_resync) {
 		pr_err
 		("Error: Keyframe/intra-only frame required to reset\r\n");
+		return -1;
+	}
 	generate_next_ref_frames(pbi);
 	pbi->hold_ref_buf = 1;
 
@@ -1699,16 +2018,17 @@ void swap_frame_buffers(struct VP9Decoder_s *pbi)
 	struct VP9_Common_s *const cm = &pbi->common;
 	struct BufferPool_s *const pool = cm->buffer_pool;
 	struct RefCntBuffer_s *const frame_bufs = cm->buffer_pool->frame_bufs;
+	unsigned long flags;
 	refresh_ref_frames(pbi);
 	pbi->hold_ref_buf = 0;
 	cm->frame_to_show = get_frame_new_buffer(cm);
 
 	/*if (!pbi->frame_parallel_decode || !cm->show_frame) {*/
-	lock_buffer_pool(pool);
+	lock_buffer_pool(pool, flags);
 	--frame_bufs[cm->new_fb_idx].ref_count;
 	/*pr_info("[MMU DEBUG 8] dec ref_count[%d] : %d\r\n", cm->new_fb_idx,
 		frame_bufs[cm->new_fb_idx].ref_count);*/
-	unlock_buffer_pool(pool);
+	unlock_buffer_pool(pool, flags);
 	/*}*/
 
 	/*Invalidate these references until the next frame starts.*/
@@ -1761,6 +2081,10 @@ int vp9_bufmgr_init(struct VP9Decoder_s *pbi, struct BuffInfo_s *buf_spec_i,
 	spin_lock_init(&cm->buffer_pool->lock);
 	cm->prev_fb_idx = INVALID_IDX;
 	cm->new_fb_idx = INVALID_IDX;
+#ifdef VP9_10B_MMU
+	pbi->used_4k_num = -1;
+	cm->cur_fb_idx_mmu = INVALID_IDX;
+#endif
 	pr_info
 	("After vp9_bufmgr_init, prev_fb_idx : %d, new_fb_idx : %d\r\n",
 		cm->prev_fb_idx, cm->new_fb_idx);
@@ -1773,7 +2097,9 @@ int vp9_bufmgr_init(struct VP9Decoder_s *pbi, struct BuffInfo_s *buf_spec_i,
 
 	/* private init */
 	pbi->work_space_buf = buf_spec_i;
+#ifndef VP9_10B_MMU
 	pbi->mc_buf = mc_buf_i;
+#endif
 	pbi->rpm_addr = NULL;
 	pbi->lmem_addr = NULL;
 
@@ -1851,11 +2177,6 @@ VP9 buffer management end
 #define HEVC_CM_HEADER_OFFSET                      0x362b
 
 #define LOSLESS_COMPRESS_MODE
-/* DOUBLE_WRITE_MODE is enabled only when NV21 8 bit output is needed */
-/* double_write_mode: 0, no double write; 1, 1:1 ratio; 2, (1/4):(1/4) ratio
-	0x10, double write only
-*/
-static u32 double_write_mode;
 
 /*#define DECOMP_HEADR_SURGENT*/
 
@@ -1880,8 +2201,6 @@ static u32 dbg_nal_skip_flag;
 static u32 dbg_nal_skip_count;
 #endif
 /*for debug*/
-static u32 decode_stop_pos;
-static u32 decode_stop_pos_pre;
 static u32 decode_pic_begin;
 static uint slice_parse_begin;
 static u32 step;
@@ -1929,11 +2248,6 @@ bit 1, 1: only decode I picture;
 */
 static u32 i_only_flag;
 
-/*
-use_cma: 1, use both reserver memory and cma for buffers
-2, only use cma for buffers
-*/
-static u32 use_cma = 2;
 
 static u32 max_decoding_time;
 /*
@@ -1961,6 +2275,7 @@ static u32 error_handle_policy;
 
 static u32 max_buf_num = 12;
 
+static u32 run_ready_min_buf_num = 2;
 
 static DEFINE_MUTEX(vvp9_mutex);
 #ifndef MULTI_INSTANCE_SUPPORT
@@ -2096,6 +2411,7 @@ static struct BuffInfo_s amvvp9_workbuff_spec[WORK_BUF_SPEC_NUM] = {
 		.mmu_vbh = {
 			.buf_size = 0x5000, /*2*16*(more than 2304)/4, 4K*/
 		},
+#if 0
 		.cm_header = {
 			/*add one for keeper.*/
 			.buf_size = MMU_COMPRESS_HEADER_SIZE *
@@ -2103,12 +2419,15 @@ static struct BuffInfo_s amvvp9_workbuff_spec[WORK_BUF_SPEC_NUM] = {
 			/* 0x44000 = ((1088*2*1024*4)/32/4)*(32/8) */
 		},
 #endif
+#endif
 		.mpred_above = {
 			.buf_size = 0x10000, /* 2 * size of hevc*/
 		},
+#ifdef MV_USE_FIXED_BUF
 		.mpred_mv = {/* 1080p, 0x40000 per buffer */
 			.buf_size = 0x40000 * FRAME_BUFFERS,
 		},
+#endif
 		.rpm = {
 			.buf_size = RPM_BUF_SIZE,
 		},
@@ -2185,6 +2504,7 @@ static struct BuffInfo_s amvvp9_workbuff_spec[WORK_BUF_SPEC_NUM] = {
 		.mmu_vbh = {
 			.buf_size = 0x5000,/*2*16*(more than 2304)/4, 4K*/
 		},
+#if 0
 		.cm_header = {
 			/*add one for keeper.*/
 			.buf_size = MMU_COMPRESS_HEADER_SIZE *
@@ -2192,15 +2512,18 @@ static struct BuffInfo_s amvvp9_workbuff_spec[WORK_BUF_SPEC_NUM] = {
 			/* 0x44000 = ((1088*2*1024*4)/32/4)*(32/8) */
 		},
 #endif
+#endif
 		.mpred_above = {
 			.buf_size = 0x10000, /* 2 * size of hevc*/
 		},
+#ifdef MV_USE_FIXED_BUF
 		.mpred_mv = {
 			/* .buf_size = 0x100000*16,
 			//4k2k , 0x100000 per buffer */
 			/* 4096x2304 , 0x120000 per buffer */
 			.buf_size = 0x120000 * FRAME_BUFFERS,
 		},
+#endif
 		.rpm = {
 			.buf_size = RPM_BUF_SIZE,
 		},
@@ -2291,96 +2614,94 @@ static void init_buff_spec(struct VP9Decoder_s *pbi,
 #ifdef VP9_10B_MMU
 	buf_spec->mmu_vbh.buf_start  =
 		buf_spec->seg_map.buf_start + buf_spec->seg_map.buf_size;
-	buf_spec->cm_header.buf_start =
-		buf_spec->mmu_vbh.buf_start + buf_spec->mmu_vbh.buf_size;
 	buf_spec->mpred_above.buf_start =
-		buf_spec->cm_header.buf_start + buf_spec->cm_header.buf_size;
+		buf_spec->mmu_vbh.buf_start + buf_spec->mmu_vbh.buf_size;
 #else
 	buf_spec->mpred_above.buf_start =
 		buf_spec->seg_map.buf_start + buf_spec->seg_map.buf_size;
 #endif
+#ifdef MV_USE_FIXED_BUF
 	buf_spec->mpred_mv.buf_start =
 		buf_spec->mpred_above.buf_start +
 		buf_spec->mpred_above.buf_size;
-	if (debug & VP9_DEBUG_SEND_PARAM_WITH_REG) {
-		buf_spec->end_adr =
-			buf_spec->mpred_mv.buf_start +
-			buf_spec->mpred_mv.buf_size;
-	} else {
-		buf_spec->rpm.buf_start =
-			buf_spec->mpred_mv.buf_start +
-			buf_spec->mpred_mv.buf_size;
-		if (debug & VP9_DEBUG_UCODE) {
-			buf_spec->lmem.buf_start =
-				buf_spec->rpm.buf_start +
-				buf_spec->rpm.buf_size;
-			buf_spec->end_adr =
-				buf_spec->lmem.buf_start +
-				buf_spec->lmem.buf_size;
+
+	buf_spec->rpm.buf_start =
+		buf_spec->mpred_mv.buf_start +
+		buf_spec->mpred_mv.buf_size;
+#else
+	buf_spec->rpm.buf_start =
+		buf_spec->mpred_above.buf_start +
+		buf_spec->mpred_above.buf_size;
+
+#endif
+	buf_spec->lmem.buf_start =
+		buf_spec->rpm.buf_start +
+		buf_spec->rpm.buf_size;
+	buf_spec->end_adr =
+		buf_spec->lmem.buf_start +
+		buf_spec->lmem.buf_size;
+
+	if (pbi) {
+		mem_start_virt =
+			codec_mm_phys_to_virt(buf_spec->dblk_para.buf_start);
+		if (mem_start_virt) {
+			memset(mem_start_virt, 0, buf_spec->dblk_para.buf_size);
+			codec_mm_dma_flush(mem_start_virt,
+				buf_spec->dblk_para.buf_size,
+				DMA_TO_DEVICE);
 		} else {
-			buf_spec->end_adr =
-				buf_spec->rpm.buf_start +
-				buf_spec->rpm.buf_size;
+			/*not virt for tvp playing,
+			may need clear on ucode.*/
+			pr_err("mem_start_virt failed\n");
 		}
-	}
-	mem_start_virt = codec_mm_phys_to_virt(buf_spec->dblk_para.buf_start);
-	if (mem_start_virt) {
-		memset(mem_start_virt, 0, buf_spec->dblk_para.buf_size);
-		codec_mm_dma_flush(mem_start_virt,
-			buf_spec->dblk_para.buf_size,
-			DMA_TO_DEVICE);
-	} else {
-		/*not virt for tvp playing,
-		may need clear on ucode.*/
-		pr_err("mem_start_virt failed\n");
-	}
-	if (debug) {
-		pr_info("%s workspace (%x %x) size = %x\n", __func__,
-			   buf_spec->start_adr, buf_spec->end_adr,
-			   buf_spec->end_adr - buf_spec->start_adr);
-	}
-	if (debug) {
-		pr_info("ipp.buf_start             :%x\n",
-			   buf_spec->ipp.buf_start);
-		pr_info("sao_abv.buf_start          :%x\n",
-			   buf_spec->sao_abv.buf_start);
-		pr_info("sao_vb.buf_start          :%x\n",
-			   buf_spec->sao_vb.buf_start);
-		pr_info("short_term_rps.buf_start  :%x\n",
-			   buf_spec->short_term_rps.buf_start);
-		pr_info("vps.buf_start             :%x\n",
-			   buf_spec->vps.buf_start);
-		pr_info("sps.buf_start             :%x\n",
-			   buf_spec->sps.buf_start);
-		pr_info("pps.buf_start             :%x\n",
-			   buf_spec->pps.buf_start);
-		pr_info("sao_up.buf_start          :%x\n",
-			   buf_spec->sao_up.buf_start);
-		pr_info("swap_buf.buf_start        :%x\n",
-			   buf_spec->swap_buf.buf_start);
-		pr_info("swap_buf2.buf_start       :%x\n",
-			   buf_spec->swap_buf2.buf_start);
-		pr_info("scalelut.buf_start        :%x\n",
-			   buf_spec->scalelut.buf_start);
-		pr_info("dblk_para.buf_start       :%x\n",
-			   buf_spec->dblk_para.buf_start);
-		pr_info("dblk_data.buf_start       :%x\n",
-			   buf_spec->dblk_data.buf_start);
-		pr_info("seg_map.buf_start       :%x\n",
-			buf_spec->seg_map.buf_start);
-#ifdef VP9_10B_MMU
-		pr_info("mmu_vbh.buf_start     :%x\n",
-			buf_spec->mmu_vbh.buf_start);
-		pr_info("cm_header.buf_start     :%x\n",
-			buf_spec->cm_header.buf_start);
-#endif
-		pr_info("mpred_above.buf_start     :%x\n",
-			   buf_spec->mpred_above.buf_start);
-		pr_info("mpred_mv.buf_start        :%x\n",
-			   buf_spec->mpred_mv.buf_start);
-		if ((debug & VP9_DEBUG_SEND_PARAM_WITH_REG) == 0) {
-			pr_info("rpm.buf_start             :%x\n",
-				   buf_spec->rpm.buf_start);
+		if (debug) {
+			pr_info("%s workspace (%x %x) size = %x\n", __func__,
+				   buf_spec->start_adr, buf_spec->end_adr,
+				   buf_spec->end_adr - buf_spec->start_adr);
+		}
+		if (debug) {
+			pr_info("ipp.buf_start             :%x\n",
+				   buf_spec->ipp.buf_start);
+			pr_info("sao_abv.buf_start          :%x\n",
+				   buf_spec->sao_abv.buf_start);
+			pr_info("sao_vb.buf_start          :%x\n",
+				   buf_spec->sao_vb.buf_start);
+			pr_info("short_term_rps.buf_start  :%x\n",
+				   buf_spec->short_term_rps.buf_start);
+			pr_info("vps.buf_start             :%x\n",
+				   buf_spec->vps.buf_start);
+			pr_info("sps.buf_start             :%x\n",
+				   buf_spec->sps.buf_start);
+			pr_info("pps.buf_start             :%x\n",
+				   buf_spec->pps.buf_start);
+			pr_info("sao_up.buf_start          :%x\n",
+				   buf_spec->sao_up.buf_start);
+			pr_info("swap_buf.buf_start        :%x\n",
+				   buf_spec->swap_buf.buf_start);
+			pr_info("swap_buf2.buf_start       :%x\n",
+				   buf_spec->swap_buf2.buf_start);
+			pr_info("scalelut.buf_start        :%x\n",
+				   buf_spec->scalelut.buf_start);
+			pr_info("dblk_para.buf_start       :%x\n",
+				   buf_spec->dblk_para.buf_start);
+			pr_info("dblk_data.buf_start       :%x\n",
+				   buf_spec->dblk_data.buf_start);
+			pr_info("seg_map.buf_start       :%x\n",
+				buf_spec->seg_map.buf_start);
+	#ifdef VP9_10B_MMU
+			pr_info("mmu_vbh.buf_start     :%x\n",
+				buf_spec->mmu_vbh.buf_start);
+	#endif
+			pr_info("mpred_above.buf_start     :%x\n",
+				   buf_spec->mpred_above.buf_start);
+#ifdef MV_USE_FIXED_BUF
+			pr_info("mpred_mv.buf_start        :%x\n",
+				   buf_spec->mpred_mv.buf_start);
+#endif
+			if ((debug & VP9_DEBUG_SEND_PARAM_WITH_REG) == 0) {
+				pr_info("rpm.buf_start             :%x\n",
+					   buf_spec->rpm.buf_start);
+			}
 		}
 	}
 
@@ -3341,7 +3662,9 @@ if (cur_kf == 0) {
 
 static void uninit_mmu_buffers(struct VP9Decoder_s *pbi)
 {
-
+#ifndef MV_USE_FIXED_BUF
+	dealloc_mv_bufs(pbi);
+#endif
 	decoder_mmu_box_free(pbi->mmu_box);
 	pbi->mmu_box = NULL;
 
@@ -3378,10 +3701,12 @@ static void init_buf_list(struct VP9Decoder_s *pbi)
 	int mc_buffer_size = losless_comp_header_size
 		+ losless_comp_body_size;
 	int mc_buffer_size_h = (mc_buffer_size + 0xffff)>>16;
-	if (double_write_mode) {
-		int pic_width_dw = (double_write_mode == 2) ?
+	if (get_double_write_mode(pbi)) {
+		int pic_width_dw = ((get_double_write_mode(pbi) == 2) ||
+			(get_double_write_mode(pbi) == 3)) ?
 			pic_width / 2 : pic_width;
-		int pic_height_dw = (double_write_mode == 2) ?
+		int pic_height_dw = ((get_double_write_mode(pbi) == 2) ||
+			(get_double_write_mode(pbi) == 3)) ?
 			pic_height / 2 : pic_height;
 		int lcu_size = 64; /*fixed 64*/
 		int pic_width_64 = (pic_width_dw + 63) & (~0x3f);
@@ -3403,7 +3728,7 @@ static void init_buf_list(struct VP9Decoder_s *pbi)
 	if (mc_buffer_size & 0xffff) { /*64k alignment*/
 		mc_buffer_size_h += 1;
 	}
-	if ((double_write_mode & 0x10) == 0)
+	if ((get_double_write_mode(pbi) & 0x10) == 0)
 		buf_size += (mc_buffer_size_h << 16);
 		if (debug) {
 			pr_info
@@ -3413,41 +3738,20 @@ static void init_buf_list(struct VP9Decoder_s *pbi)
 	}
 
 	for (i = 0; i < pbi->used_buf_num; i++) {
-		if (((i + 1) * buf_size) > pbi->mc_buf->buf_size) {
-			if (use_cma)
-				pbi->use_cma_flag = 1;
-			else {
-				if (debug) {
-					pr_info("%s maximum buf size is used\n",
-						   __func__);
-				}
-				break;
-			}
-		}
+		if (((i + 1) * buf_size) > pbi->mc_buf->buf_size)
+			pbi->use_cma_flag = 1;
 #ifndef VP9_10B_MMU
 		pbi->m_BUF[i].alloc_flag = 0;
 		pbi->m_BUF[i].index = i;
 
-		if (use_cma == 2)
-			pbi->use_cma_flag = 1;
+		pbi->use_cma_flag = 1;
 		if (pbi->use_cma_flag) {
-			if (!decoder_bmmu_box_alloc_idx_wait(
-					pbi->bmmu_box,
-					i,
-					buf_size,
-					-1,
-					-1,
-					BMMU_ALLOC_FLAGS_WAITCLEAR)) {
-				pbi->m_BUF[i].alloc_addr =
-					decoder_bmmu_box_get_phy_addr(
-						pbi->bmmu_box,
-						i);
-				pbi->m_BUF[i].cma_page_count =
+			pbi->m_BUF[i].cma_page_count =
 					PAGE_ALIGN(buf_size) / PAGE_SIZE;
-				pr_info("CMA malloc ok  %d\n", i);
-			} else {
+			if (decoder_bmmu_box_alloc_buf_phy(pbi->bmmu_box,
+					VF_BUFFER_IDX(i), buf_size, DRIVER_NAME,
+					&pbi->m_BUF[i].alloc_addr) < 0) {
 				pbi->m_BUF[i].cma_page_count = 0;
-				pr_info("CMA malloc failed  %d\n", i);
 				if (i <= 5) {
 					pbi->fatal_error |=
 					DECODER_FATAL_ERROR_NO_MEM;
@@ -3484,14 +3788,12 @@ static void init_buf_list(struct VP9Decoder_s *pbi)
 }
 #endif
 static int config_pic(struct VP9Decoder_s *pbi,
-				struct PIC_BUFFER_CONFIG_s *pic_config,
-				unsigned long last_disp_addr)
+				struct PIC_BUFFER_CONFIG_s *pic_config)
 {
 	int ret = -1;
 	int i;
 	int pic_width = pbi->init_pic_w;
 	int pic_height = pbi->init_pic_h;
-	int MV_MEM_UNIT = 0x240;
 	int lcu_size = 64; /*fixed 64*/
 	int pic_width_64 = (pic_width + 63) & (~0x3f);
 	int pic_height_32 = (pic_height + 31) & (~0x1f);
@@ -3502,9 +3804,10 @@ static int config_pic(struct VP9Decoder_s *pbi,
 				pic_height_32 / lcu_size + 1
 				: pic_height_32 / lcu_size;
 	int lcu_total       = pic_width_lcu * pic_height_lcu;
-
+#ifdef MV_USE_FIXED_BUF
 	u32 mpred_mv_end = pbi->work_space_buf->mpred_mv.buf_start +
 			pbi->work_space_buf->mpred_mv.buf_size;
+#endif
 	u32 y_adr = 0;
 	int buf_size = 0;
 
@@ -3517,10 +3820,12 @@ static int config_pic(struct VP9Decoder_s *pbi,
 	int mc_buffer_size_h = (mc_buffer_size + 0xffff) >> 16;
 	int mc_buffer_size_u_v = 0;
 	int mc_buffer_size_u_v_h = 0;
-	if (double_write_mode) {
-		int pic_width_dw = (double_write_mode == 2) ?
+	if (get_double_write_mode(pbi)) {
+		int pic_width_dw = ((get_double_write_mode(pbi) == 2) ||
+			(get_double_write_mode(pbi) == 3)) ?
 			pic_width / 2 : pic_width;
-		int pic_height_dw = (double_write_mode == 2) ?
+		int pic_height_dw = ((get_double_write_mode(pbi) == 2) ||
+			(get_double_write_mode(pbi) == 3)) ?
 			pic_height / 2 : pic_height;
 		int pic_width_64_dw = (pic_width_dw + 63) & (~0x3f);
 		int pic_height_32_dw = (pic_height_dw + 31) & (~0x1f);
@@ -3541,49 +3846,34 @@ static int config_pic(struct VP9Decoder_s *pbi,
 	if (mc_buffer_size & 0xffff) /*64k alignment*/
 		mc_buffer_size_h += 1;
 #ifndef VP9_10B_MMU
-	if ((double_write_mode & 0x10) == 0)
+	if ((get_double_write_mode(pbi) & 0x10) == 0)
 		buf_size += (mc_buffer_size_h << 16);
 #endif
 
 #ifdef VP9_10B_MMU
-	if ((pbi->work_space_buf->cm_header.buf_start +
-		((pic_config->index + 2)
-		* MMU_COMPRESS_HEADER_SIZE))
-		> (pbi->work_space_buf->cm_header.buf_start +
-		pbi->work_space_buf->cm_header.buf_size)) {
-		pr_info("MMU header_adr allocate fail\n");
-		return -1;
-	}
+	pic_config->header_adr = decoder_bmmu_box_get_phy_addr(
+			pbi->bmmu_box, HEADER_BUFFER_IDX(pic_config->index));
 
-	pic_config->header_adr = pbi->work_space_buf->cm_header.buf_start
-		+ (pic_config->index * MMU_COMPRESS_HEADER_SIZE);
-	if (last_disp_addr && pic_config->header_adr == last_disp_addr) {
-		/*if same as disp add used last one.*/
-		pr_info("same as disp %d: %ld\n",
-			pic_config->index, pic_config->header_adr);
-		pic_config->header_adr =
-			pbi->work_space_buf->cm_header.buf_start +
-			(FRAME_BUFFERS * MMU_COMPRESS_HEADER_SIZE);
-	}
-	if (debug & VP9_DEBUG_BUFMGR) {
+	if (debug & VP9_DEBUG_BUFMGR_MORE) {
 		pr_info("MMU header_adr %d: %ld\n",
 			pic_config->index, pic_config->header_adr);
 	}
 #endif
 
 	i = pic_config->index;
+#ifdef MV_USE_FIXED_BUF
 	if ((pbi->work_space_buf->mpred_mv.buf_start +
 		(((i + 1) * lcu_total) * MV_MEM_UNIT))
 		<= mpred_mv_end
-#ifdef VP9_10B_MMU
-#endif
 	) {
+#endif
+#ifndef VP9_10B_MMU
 		if (debug) {
 			pr_err("start %x  .size=%d\n",
 				pbi->mc_buf_spec.buf_start + i * buf_size,
 				buf_size);
 		}
-
+#endif
 #ifndef VP9_10B_MMU
 		for (i = 0; i < pbi->buf_num; i++) {
 			y_adr = ((pbi->m_BUF[i].free_start_adr
@@ -3598,29 +3888,33 @@ static int config_pic(struct VP9Decoder_s *pbi,
 		}
 		if (i < pbi->buf_num)
 #else
-		if ((pbi->mc_buf->buf_start + (i + 1) * buf_size) <
+		/*if ((pbi->mc_buf->buf_start + (i + 1) * buf_size) <
 			pbi->mc_buf->buf_end)
 			y_adr = pbi->mc_buf->buf_start + i * buf_size;
-		else {
-			if (!decoder_bmmu_box_alloc_idx_wait(
-					pbi->bmmu_box,
-					i,
-					buf_size,
-					-1,
-					-1,
-					BMMU_ALLOC_FLAGS_WAITCLEAR
-					)) {
-				pic_config->cma_alloc_addr =
-					decoder_bmmu_box_get_phy_addr(
-						pbi->bmmu_box,
-						i);
-			} else {
-				pr_err("alloc cma buffer failed %d\n", i);
+		else {*/
+		if (buf_size > 0) {
+			ret = decoder_bmmu_box_alloc_buf_phy(pbi->bmmu_box,
+					VF_BUFFER_IDX(i),
+					buf_size, DRIVER_NAME,
+					&pic_config->cma_alloc_addr);
+			if (ret < 0) {
+				pr_info(
+					"decoder_bmmu_box_alloc_buf_phy idx %d size %d fail\n",
+					VF_BUFFER_IDX(i),
+					buf_size
+					);
+				return ret;
 			}
 			if (pic_config->cma_alloc_addr)
 				y_adr = pic_config->cma_alloc_addr;
-			else
+			else {
+				pr_info(
+					"decoder_bmmu_box_alloc_buf_phy idx %d size %d return null\n",
+					VF_BUFFER_IDX(i),
+					buf_size
+					);
 				return -1;
+			}
 		}
 #endif
 		{
@@ -3637,7 +3931,7 @@ static int config_pic(struct VP9Decoder_s *pbi,
 			pic_config->mc_canvas_y = pic_config->index;
 			pic_config->mc_canvas_u_v = pic_config->index;
 #ifndef VP9_10B_MMU
-			if (double_write_mode & 0x10) {
+			if (get_double_write_mode(pbi) & 0x10) {
 				pic_config->mc_u_v_adr = y_adr +
 				((mc_buffer_size_u_v_h << 16) << 1);
 
@@ -3650,7 +3944,7 @@ static int config_pic(struct VP9Decoder_s *pbi,
 				pic_config->dw_u_v_adr = pic_config->mc_u_v_adr;
 			} else
 #endif
-			if (double_write_mode) {
+			if (get_double_write_mode(pbi)) {
 				pic_config->dw_y_adr = y_adr
 #ifndef VP9_10B_MMU
 				+ (mc_buffer_size_h << 16)
@@ -3658,13 +3952,17 @@ static int config_pic(struct VP9Decoder_s *pbi,
 				;
 				pic_config->dw_u_v_adr = pic_config->dw_y_adr +
 					((mc_buffer_size_u_v_h << 16) << 1);
+#ifdef VP9_10B_MMU
+				pic_config->mc_y_adr = pic_config->dw_y_adr;
+				pic_config->mc_u_v_adr = pic_config->dw_u_v_adr;
+#endif
 			}
-
+#ifdef MV_USE_FIXED_BUF
 			pic_config->mpred_mv_wr_start_addr =
 			pbi->work_space_buf->mpred_mv.buf_start +
 					((pic_config->index * lcu_total)
 					* MV_MEM_UNIT);
-
+#endif
 			if (debug) {
 				pr_info
 				("%s index %d BUF_index %d mc_y_adr %lx ",
@@ -3684,7 +3982,9 @@ static int config_pic(struct VP9Decoder_s *pbi,
 			}
 			ret = 0;
 		}
+#ifdef MV_USE_FIXED_BUF
 	}
+#endif
 	return ret;
 }
 
@@ -3693,28 +3993,28 @@ static void init_pic_list(struct VP9Decoder_s *pbi)
 	int i;
 	struct VP9_Common_s *cm = &pbi->common;
 	struct PIC_BUFFER_CONFIG_s *pic_config;
-	struct vframe_s vf;
-	unsigned long disp_addr = 0;
-
-	if (!get_video0_frame_info(&vf)) {
-		if (vf.type & VIDTYPE_SCATTER) {
-			/*sc only used header.*/
-			disp_addr = vf.compHeadAddr;
-		} else if (vf.type & VIDTYPE_COMPRESS) {
-			/*sc checked body.*/
-			disp_addr = vf.compBodyAddr;
-		} else {
-			struct canvas_s cur_canvas;
-			canvas_read(vf.canvas0Addr & 0xff, &cur_canvas);
-			disp_addr = cur_canvas.addr;
+#ifdef VP9_10B_MMU
+	/*alloc VP9 compress header first*/
+	for (i = 0; i < pbi->used_buf_num; i++) {
+		unsigned long buf_addr;
+		if (decoder_bmmu_box_alloc_buf_phy
+				(pbi->bmmu_box,
+				HEADER_BUFFER_IDX(i), MMU_COMPRESS_HEADER_SIZE,
+				DRIVER_HEADER_NAME,
+				&buf_addr) < 0){
+			pr_info("%s malloc compress header failed %d\n",
+				DRIVER_HEADER_NAME, i);
+			pbi->fatal_error |= DECODER_FATAL_ERROR_NO_MEM;
+			return;
 		}
 	}
-
-	for (i = 0; i < FRAME_BUFFERS; i++) {
+#endif
+	for (i = 0; i < pbi->used_buf_num; i++) {
 		pic_config = &cm->buffer_pool->frame_bufs[i].buf;
 		pic_config->index = i;
 		pic_config->BUF_index = -1;
-		if (config_pic(pbi, pic_config, disp_addr) < 0) {
+		pic_config->mv_buf_index = -1;
+		if (config_pic(pbi, pic_config) < 0) {
 			if (debug)
 				pr_info("Config_pic %d fail\n",
 					pic_config->index);
@@ -3725,11 +4025,14 @@ static void init_pic_list(struct VP9Decoder_s *pbi)
 		pic_config->y_crop_height = pbi->init_pic_h;
 		/*set_canvas(pic_config);*/
 	}
-	for (; i < FRAME_BUFFERS; i++) {
+	for (; i < pbi->used_buf_num; i++) {
 		pic_config = &cm->buffer_pool->frame_bufs[i].buf;
 		pic_config->index = -1;
 		pic_config->BUF_index = -1;
+		pic_config->mv_buf_index = -1;
 	}
+	pr_info("%s ok, used_buf_num = %d\n",
+		__func__, pbi->used_buf_num);
 
 }
 
@@ -3744,7 +4047,7 @@ static void init_pic_list_hw(struct VP9Decoder_s *pbi)
 		(0x1 << 1) | (0x1 << 2));
 
 
-	for (i = 0; i < FRAME_BUFFERS; i++) {
+	for (i = 0; i < pbi->used_buf_num; i++) {
 		pic_config = &cm->buffer_pool->frame_bufs[i].buf;
 		if (pic_config->index < 0)
 			break;
@@ -3779,6 +4082,28 @@ static void init_pic_list_hw(struct VP9Decoder_s *pbi)
 
 static void dump_pic_list(struct VP9Decoder_s *pbi)
 {
+	struct VP9_Common_s *const cm = &pbi->common;
+	struct PIC_BUFFER_CONFIG_s *pic_config;
+	int i;
+	for (i = 0; i < FRAME_BUFFERS; i++) {
+		pic_config = &cm->buffer_pool->frame_bufs[i].buf;
+		vp9_print(pbi, 0,
+			"Buf(%d) index %d mv_buf_index %d vf_ref %d dec_idx %d slice_type %d w/h %d/%d adr%ld\n",
+			i,
+			pic_config->index,
+#ifndef MV_USE_FIXED_BUF
+			pic_config->mv_buf_index,
+#else
+			-1,
+#endif
+			pic_config->vf_ref,
+			pic_config->decode_idx,
+			pic_config->slice_type,
+			pic_config->y_crop_width,
+			pic_config->y_crop_height,
+			pic_config->cma_alloc_addr
+			);
+	}
 	return;
 }
 
@@ -3837,14 +4162,15 @@ static int config_mc_buffer(struct VP9Decoder_s *pbi, unsigned short bit_depth)
 	struct PIC_BUFFER_CONFIG_s *cur_pic_config = &cm->cur_frame->buf;
 	uint8_t scale_enable = 0;
 
-	if (debug&VP9_DEBUG_BUFMGR)
+	if (debug&VP9_DEBUG_BUFMGR_MORE)
 		pr_info("config_mc_buffer entered .....\n");
 
 	WRITE_VREG(HEVCD_MPP_ANC_CANVAS_ACCCONFIG_ADDR,
 			(0 << 8) | (0 << 1) | 1);
 	for (i = 0; i < REFS_PER_FRAME; ++i) {
 		struct PIC_BUFFER_CONFIG_s *pic_config = cm->frame_refs[i].buf;
-
+		if (!pic_config)
+			continue;
 		WRITE_VREG(HEVCD_MPP_ANC_CANVAS_DATA_ADDR,
 		(pic_config->mc_canvas_u_v << 16)
 		| (pic_config->mc_canvas_u_v << 8)
@@ -3858,7 +4184,8 @@ static int config_mc_buffer(struct VP9Decoder_s *pbi, unsigned short bit_depth)
 			(16 << 8) | (0 << 1) | 1);
 	for (i = 0; i < REFS_PER_FRAME; ++i) {
 		struct PIC_BUFFER_CONFIG_s *pic_config = cm->frame_refs[i].buf;
-
+		if (!pic_config)
+			continue;
 		WRITE_VREG(HEVCD_MPP_ANC_CANVAS_DATA_ADDR,
 			(pic_config->mc_canvas_u_v << 16)
 			| (pic_config->mc_canvas_u_v << 8)
@@ -3871,7 +4198,8 @@ static int config_mc_buffer(struct VP9Decoder_s *pbi, unsigned short bit_depth)
 	for (i = 0; i < REFS_PER_FRAME; i++) {
 		int ref_pic_body_size;
 		struct PIC_BUFFER_CONFIG_s *pic_config = cm->frame_refs[i].buf;
-
+		if (!pic_config)
+			continue;
 		WRITE_VREG(VP9D_MPP_REFINFO_DATA, pic_config->y_crop_width);
 		WRITE_VREG(VP9D_MPP_REFINFO_DATA, pic_config->y_crop_height);
 
@@ -3917,7 +4245,6 @@ static void config_mpred_hw(struct VP9Decoder_s *pbi)
 	int     mpred_curr_lcu_x;
 	int     mpred_curr_lcu_y;
 	int     mpred_mv_rd_end_addr;
-	int     MV_MEM_UNIT = 0x240;
 
 
 	mpred_mv_rd_end_addr = last_frame_pic_config->mpred_mv_wr_start_addr
@@ -3968,10 +4295,10 @@ static void config_sao_hw(struct VP9Decoder_s *pbi, union param_u *params)
 		(mc_buffer_size_u_v + 0xffff) >> 16;/*64k alignment*/
 
 #ifndef VP9_10B_MMU
-	if ((double_write_mode & 0x10) == 0)
+	if ((get_double_write_mode(pbi) & 0x10) == 0)
 		WRITE_VREG(HEVC_CM_BODY_START_ADDR, pic_config->mc_y_adr);
 #endif
-	if (double_write_mode) {
+	if (get_double_write_mode(pbi)) {
 		WRITE_VREG(HEVC_SAO_Y_START_ADDR, pic_config->dw_y_adr);
 		WRITE_VREG(HEVC_SAO_C_START_ADDR, pic_config->dw_u_v_adr);
 		WRITE_VREG(HEVC_SAO_Y_WPTR, pic_config->dw_y_adr);
@@ -4048,16 +4375,16 @@ static void config_sao_hw(struct VP9Decoder_s *pbi, union param_u *params)
 	/* data32 |= 0x670;  // Big-Endian per 64-bit */
 	data32 |= endian;	/* Big-Endian per 64-bit */
 	data32 &= (~0x3); /*[1]:dw_disable [0]:cm_disable*/
-	if (double_write_mode == 0)
+	if (get_double_write_mode(pbi) == 0)
 		data32 |= 0x2; /*disable double write*/
 #ifndef VP9_10B_MMU
 	else
-	if (double_write_mode & 0x10)
+	if (get_double_write_mode(pbi) & 0x10)
 		data32 |= 0x1; /*disable cm*/
 #endif
 	WRITE_VREG(HEVC_SAO_CTRL1, data32);
 
-	if (double_write_mode & 0x10) {
+	if (get_double_write_mode(pbi) & 0x10) {
 		/* [23:22] dw_v1_ctrl
 		[21:20] dw_v0_ctrl
 		[19:18] dw_h1_ctrl
@@ -4070,7 +4397,7 @@ static void config_sao_hw(struct VP9Decoder_s *pbi, union param_u *params)
 	} else {
 		data32 = READ_VREG(HEVC_SAO_CTRL5);
 		data32 &= (~(0xff << 16));
-		if (double_write_mode != 1)
+		if (get_double_write_mode(pbi) != 1)
 			data32 |= (0xff<<16);
 		WRITE_VREG(HEVC_SAO_CTRL5, data32);
 	}
@@ -4101,7 +4428,7 @@ static void vp9_config_work_space_hw(struct VP9Decoder_s *pbi)
 #ifdef VP9_10B_MMU
 	unsigned int data32;
 #endif
-	if (debug)
+	if (debug && pbi->init_flag == 0)
 		pr_info("%s %x %x %x %x %x %x %x %x %x %x %x %x\n",
 			__func__,
 			buf_spec->ipp.buf_start,
@@ -4173,8 +4500,7 @@ static void vp9_config_work_space_hw(struct VP9Decoder_s *pbi)
 
 	WRITE_VREG(VP9_SEG_MAP_BUFFER, buf_spec->seg_map.buf_start);
 
-	if (debug & VP9_DEBUG_UCODE)
-		WRITE_VREG(LMEM_DUMP_ADR, (u32)pbi->lmem_phy_addr);
+	WRITE_VREG(LMEM_DUMP_ADR, (u32)pbi->lmem_phy_addr);
 
 	 /**/
 	WRITE_VREG(VP9_PROB_SWAP_BUFFER, pbi->prob_buffer_phy_addr);
@@ -4307,25 +4633,14 @@ static void vp9_update_sharpness(struct loop_filter_info_n *lfi,
 	}
 }
 
-int default_filt_lvl;
-struct loop_filter_info_n *lfi;
-struct loopfilter *lf;
-struct segmentation *seg_4lf;
-
 /*instantiate this function once when decode is started*/
-void vp9_loop_filter_init(void)
+void vp9_loop_filter_init(struct VP9Decoder_s *pbi)
 {
+	struct loop_filter_info_n *lfi = pbi->lfi;
+	struct loopfilter *lf = pbi->lf;
+	struct segmentation *seg_4lf = pbi->seg_4lf;
 	int i;
-	if (!lfi)
-		lfi = kmalloc(sizeof(struct loop_filter_info_n), GFP_KERNEL);
-	if (!lf)
-		lf = kmalloc(sizeof(struct loopfilter), GFP_KERNEL);
-	if (!seg_4lf)
-		seg_4lf = kmalloc(sizeof(struct segmentation), GFP_KERNEL);
-	if (lfi == NULL || lf == NULL || seg_4lf == NULL) {
-		pr_err("[test.c] vp9_loop_filter init malloc error!!!\n");
-		return;
-	}
+
 	memset(lfi, 0, sizeof(struct loop_filter_info_n));
 	memset(lf, 0, sizeof(struct loopfilter));
 	memset(seg_4lf, 0, sizeof(struct segmentation));
@@ -4460,8 +4775,8 @@ static void vp9_init_decoder_hw(struct VP9Decoder_s *pbi)
 	unsigned int data32;
 	int i;
 
-	if (debug & VP9_DEBUG_BUFMGR)
-		pr_info("[test.c] Enable HEVC Parser Interrupt\n");
+	/*if (debug & VP9_DEBUG_BUFMGR_MORE)
+		pr_info("%s\n", __func__);*/
 		data32 = READ_VREG(HEVC_PARSER_INT_CONTROL);
 #if 1
 		/* set bit 31~29 to 3 if HEVC_STREAM_FIFO_CTL[29] is 1 */
@@ -4478,26 +4793,23 @@ static void vp9_init_decoder_hw(struct VP9Decoder_s *pbi)
 		;
 	WRITE_VREG(HEVC_PARSER_INT_CONTROL, data32);
 
-	if (debug & VP9_DEBUG_BUFMGR)
-		pr_info("[test.c] Enable HEVC Parser Shift\n");
-
-		data32 = READ_VREG(HEVC_SHIFT_STATUS);
-		data32 = data32 |
-		(0 << 1) |/*emulation_check_off VP9
-			do not have emulation*/
-		(1 << 0)/*startcode_check_on*/
-		;
-		WRITE_VREG(HEVC_SHIFT_STATUS, data32);
-		WRITE_VREG(HEVC_SHIFT_CONTROL,
-		(0 << 14) | /*disable_start_code_protect*/
-		(1 << 10) | /*length_zero_startcode_en for VP9*/
-		(1 << 9) | /*length_valid_startcode_en for VP9*/
-		(3 << 6) | /*sft_valid_wr_position*/
-		(2 << 4) | /*emulate_code_length_sub_1*/
-		(3 << 1) | /*start_code_length_sub_1
-		VP9 use 0x00000001 as startcode (4 Bytes)*/
-		(1 << 0)   /*stream_shift_enable*/
-		);
+	data32 = READ_VREG(HEVC_SHIFT_STATUS);
+	data32 = data32 |
+	(0 << 1) |/*emulation_check_off VP9
+		do not have emulation*/
+	(1 << 0)/*startcode_check_on*/
+	;
+	WRITE_VREG(HEVC_SHIFT_STATUS, data32);
+	WRITE_VREG(HEVC_SHIFT_CONTROL,
+	(0 << 14) | /*disable_start_code_protect*/
+	(1 << 10) | /*length_zero_startcode_en for VP9*/
+	(1 << 9) | /*length_valid_startcode_en for VP9*/
+	(3 << 6) | /*sft_valid_wr_position*/
+	(2 << 4) | /*emulate_code_length_sub_1*/
+	(3 << 1) | /*start_code_length_sub_1
+	VP9 use 0x00000001 as startcode (4 Bytes)*/
+	(1 << 0)   /*stream_shift_enable*/
+	);
 
 	WRITE_VREG(HEVC_CABAC_CONTROL,
 		(1 << 0)/*cabac_enable*/
@@ -4511,8 +4823,7 @@ static void vp9_init_decoder_hw(struct VP9Decoder_s *pbi)
 	WRITE_VREG(HEVC_DEC_STATUS_REG, 0);
 
 	/*Initial IQIT_SCALELUT memory -- just to avoid X in simulation*/
-	if (debug & VP9_DEBUG_BUFMGR)
-		pr_info("Initial IQIT_SCALELUT memory\n");
+
 	WRITE_VREG(HEVC_IQIT_SCALELUT_WR_ADDR, 0);/*cfg_p_addr*/
 	for (i = 0; i < 1024; i++)
 		WRITE_VREG(HEVC_IQIT_SCALELUT_DATA, 0);
@@ -4524,7 +4835,9 @@ static void vp9_init_decoder_hw(struct VP9Decoder_s *pbi)
 	WRITE_VREG(HEVC_STREAM_SWAP_TEST, 0);
 #endif
 #ifdef MULTI_INSTANCE_SUPPORT
-	if (pbi->platform_dev && vdec_frame_based(hw_to_vdec(pbi)))
+	if (!pbi->m_ins_flag)
+		WRITE_VREG(DECODE_MODE, DECODE_MODE_SINGLE);
+	else if (vdec_frame_based(hw_to_vdec(pbi)))
 		WRITE_VREG(DECODE_MODE, DECODE_MODE_MULTI_FRAMEBASE);
 	else
 		WRITE_VREG(DECODE_MODE, DECODE_MODE_MULTI_STREAMBASE);
@@ -4536,8 +4849,6 @@ static void vp9_init_decoder_hw(struct VP9Decoder_s *pbi)
 	WRITE_VREG(HEVC_DECODE_PIC_NUM_REG, 0x7fffffff); /*to remove*/
 #endif
 	/*Send parser_cmd*/
-	if (debug)
-		pr_info("[test.c] SEND Parser Command ...\n");
 	WRITE_VREG(HEVC_PARSER_CMD_WRITE, (1 << 16) | (0 << 0));
 	for (i = 0; i < PARSER_CMD_NUMBER; i++)
 		WRITE_VREG(HEVC_PARSER_CMD_WRITE, parser_cmd[i]);
@@ -4559,8 +4870,6 @@ static void vp9_init_decoder_hw(struct VP9Decoder_s *pbi)
 	(1<<31)
 	);
 	*/
-	if (debug)
-		pr_info("[test.c] Reset IPP\n");
 	WRITE_VREG(HEVCD_IPP_TOP_CNTL,
 		(0 << 1) | /*enable ipp*/
 		(1 << 0)   /*software reset ipp and mpp*/
@@ -4669,6 +4978,32 @@ static void  config_mcrcc_axi_hw(struct VP9Decoder_s *pbi)
 
 static struct VP9Decoder_s gHevc;
 
+static void free_lf_buf(struct VP9Decoder_s *pbi)
+{
+	if (pbi->lfi)
+		vfree(pbi->lfi);
+	if (pbi->lf)
+		vfree(pbi->lf);
+	if (pbi->seg_4lf)
+		vfree(pbi->seg_4lf);
+	pbi->lfi = NULL;
+	pbi->lf = NULL;
+	pbi->seg_4lf = NULL;
+}
+
+static int alloc_lf_buf(struct VP9Decoder_s *pbi)
+{
+	pbi->lfi = vmalloc(sizeof(struct loop_filter_info_n));
+	pbi->lf = vmalloc(sizeof(struct loopfilter));
+	pbi->seg_4lf = vmalloc(sizeof(struct segmentation));
+	if (pbi->lfi == NULL || pbi->lf == NULL || pbi->seg_4lf == NULL) {
+		free_lf_buf(pbi);
+		pr_err("[test.c] vp9_loop_filter init malloc error!!!\n");
+		return -1;
+	}
+	return 0;
+}
+
 static void vp9_local_uninit(struct VP9Decoder_s *pbi)
 {
 	pbi->rpm_ptr = NULL;
@@ -4716,13 +5051,11 @@ static void vp9_local_uninit(struct VP9Decoder_s *pbi)
 #endif
 
 #ifdef VP9_LPF_LVL_UPDATE
-	kfree(lfi);
-	lfi = NULL;
-	kfree(lf);
-	lf = NULL;
-	kfree(seg_4lf);
-	seg_4lf = NULL;
+	free_lf_buf(pbi);
 #endif
+	if (pbi->gvs)
+		vfree(pbi->gvs);
+	pbi->gvs = NULL;
 }
 
 static int vp9_local_init(struct VP9Decoder_s *pbi)
@@ -4743,7 +5076,9 @@ static int vp9_local_init(struct VP9Decoder_s *pbi)
 		sizeof(struct BuffInfo_s));
 #endif
 	cur_buf_info->start_adr = pbi->buf_start;
+#ifndef VP9_10B_MMU
 	pbi->mc_buf_spec.buf_end = pbi->buf_start + pbi->buf_size;
+#endif
 #else
 /*! MULTI_INSTANCE_SUPPORT*/
 #ifdef SUPPORT_4K2K
@@ -4754,6 +5089,9 @@ static int vp9_local_init(struct VP9Decoder_s *pbi)
 #endif
 
 	init_buff_spec(pbi, cur_buf_info);
+#ifdef VP9_10B_MMU
+	vp9_bufmgr_init(pbi, cur_buf_info, NULL);
+#else
 	pbi->mc_buf_spec.buf_start = (cur_buf_info->end_adr + 0xffff)
 	    & (~0xffff);
 	pbi->mc_buf_spec.buf_size = (pbi->mc_buf_spec.buf_end
@@ -4765,6 +5103,7 @@ static int vp9_local_init(struct VP9Decoder_s *pbi)
 			pbi->mc_buf_spec.buf_size);
 	}
 	vp9_bufmgr_init(pbi, cur_buf_info, &pbi->mc_buf_spec);
+#endif
 
 	pbi->init_pic_w = buf_alloc_width ? buf_alloc_width :
 		(pbi->vvp9_amstream_dec_info.width ?
@@ -4774,8 +5113,21 @@ static int vp9_local_init(struct VP9Decoder_s *pbi)
 		(pbi->vvp9_amstream_dec_info.height ?
 		pbi->vvp9_amstream_dec_info.height :
 		pbi->work_space_buf->max_height);
+#ifndef MV_USE_FIXED_BUF
+	if (init_mv_buf_list(pbi) < 0) {
+		pr_err("%s: init_mv_buf_list fail\n", __func__);
+		return -1;
+	}
+#endif
+
 #ifndef VP9_10B_MMU
 	init_buf_list(pbi);
+#else
+	pbi->used_buf_num = max_buf_num;
+	if (pbi->used_buf_num > MAX_BUF_NUM)
+		pbi->used_buf_num = MAX_BUF_NUM;
+	if (pbi->used_buf_num > FRAME_BUFFERS)
+		pbi->used_buf_num = FRAME_BUFFERS;
 #endif
 	init_pic_list(pbi);
 
@@ -4805,27 +5157,26 @@ static int vp9_local_init(struct VP9Decoder_s *pbi)
 		pbi->rpm_ptr = pbi->rpm_addr;
 	}
 
-	if (debug & VP9_DEBUG_UCODE) {
-		pbi->lmem_addr = dma_alloc_coherent(amports_get_dma_device(),
-				LMEM_BUF_SIZE,
-				&pbi->lmem_phy_addr, GFP_KERNEL);
-		if (pbi->lmem_addr == NULL) {
-			pr_err("%s: failed to alloc lmem buffer\n", __func__);
-			return -1;
-		}
+	pbi->lmem_addr = dma_alloc_coherent(amports_get_dma_device(),
+			LMEM_BUF_SIZE,
+			&pbi->lmem_phy_addr, GFP_KERNEL);
+	if (pbi->lmem_addr == NULL) {
+		pr_err("%s: failed to alloc lmem buffer\n", __func__);
+		return -1;
+	}
 /*
-		pbi->lmem_phy_addr = dma_map_single(amports_get_dma_device(),
-			pbi->lmem_addr, LMEM_BUF_SIZE, DMA_BIDIRECTIONAL);
-		if (dma_mapping_error(amports_get_dma_device(),
-			pbi->lmem_phy_addr)) {
-			pr_err("%s: failed to map lmem buffer\n", __func__);
-			kfree(pbi->lmem_addr);
-			pbi->lmem_addr = NULL;
-			return -1;
-		}
-*/
-		pbi->lmem_ptr = pbi->lmem_addr;
+	pbi->lmem_phy_addr = dma_map_single(amports_get_dma_device(),
+		pbi->lmem_addr, LMEM_BUF_SIZE, DMA_BIDIRECTIONAL);
+	if (dma_mapping_error(amports_get_dma_device(),
+		pbi->lmem_phy_addr)) {
+		pr_err("%s: failed to map lmem buffer\n", __func__);
+		kfree(pbi->lmem_addr);
+		pbi->lmem_addr = NULL;
+		return -1;
 	}
+*/
+	pbi->lmem_ptr = pbi->lmem_addr;
+
 	pbi->prob_buffer_addr = dma_alloc_coherent(amports_get_dma_device(),
 				PROB_BUF_SIZE,
 				&pbi->prob_buffer_phy_addr, GFP_KERNEL);
@@ -4907,16 +5258,18 @@ static int vp9_local_init(struct VP9Decoder_s *pbi)
 	 ((x)->y_canvas_index << 0))
 
 
-static void set_canvas(struct PIC_BUFFER_CONFIG_s *pic_config)
+static void set_canvas(struct VP9Decoder_s *pbi,
+	struct PIC_BUFFER_CONFIG_s *pic_config)
 {
 	int canvas_w = ALIGN(pic_config->y_crop_width, 64)/4;
 	int canvas_h = ALIGN(pic_config->y_crop_height, 32)/4;
 	int blkmode = mem_map_mode;
 	/*CANVAS_BLKMODE_64X32*/
-	if	(double_write_mode) {
+	if	(get_double_write_mode(pbi)) {
 		canvas_w = pic_config->y_crop_width;
 		canvas_h = pic_config->y_crop_height;
-		if (double_write_mode == 2) {
+		if ((get_double_write_mode(pbi) == 2) ||
+			(get_double_write_mode(pbi) == 3)) {
 			canvas_w >>= 2;
 			canvas_h >>= 2;
 		}
@@ -5025,8 +5378,16 @@ static struct vframe_s *vvp9_vf_get(void *op_arg)
 
 	if (kfifo_get(&pbi->display_q, &vf)) {
 		uint8_t index = vf->index & 0xff;
-		 if (index >= 0	&& index < FRAME_BUFFERS)
+		if (index >= 0	&& index < pbi->used_buf_num) {
+			pbi->vf_get_count++;
+			if (debug & VP9_DEBUG_BUFMGR)
+				pr_info("%s type 0x%x w/h %d/%d, pts %d, %lld\n",
+					__func__, vf->type,
+					vf->width, vf->height,
+					vf->pts,
+					vf->pts_us64);
 			return vf;
+		}
 	}
 	return NULL;
 }
@@ -5037,12 +5398,14 @@ static void vvp9_vf_put(struct vframe_s *vf, void *op_arg)
 	uint8_t index = vf->index & 0xff;
 
 	kfifo_put(&pbi->newframe_q, (const struct vframe_s *)vf);
-
+	pbi->vf_put_count++;
 	if (index >= 0
-		&& index < FRAME_BUFFERS) {
+		&& index < pbi->used_buf_num) {
 		struct VP9_Common_s *cm = &pbi->common;
 		struct BufferPool_s *pool = cm->buffer_pool;
-		lock_buffer_pool(pool);
+		unsigned long flags;
+
+		lock_buffer_pool(pool, flags);
 		if (pool->frame_bufs[index].buf.vf_ref > 0)
 			pool->frame_bufs[index].buf.vf_ref--;
 
@@ -5051,7 +5414,7 @@ static void vvp9_vf_put(struct vframe_s *vf, void *op_arg)
 						0x1);
 		pbi->last_put_idx = index;
 		pbi->new_frame_displayed++;
-		unlock_buffer_pool(pool);
+		unlock_buffer_pool(pool, flags);
 	}
 
 }
@@ -5084,7 +5447,7 @@ void inc_vf_ref(struct VP9Decoder_s *pbi, int index)
 	struct VP9_Common_s *cm = &pbi->common;
 	cm->buffer_pool->frame_bufs[index].buf.vf_ref++;
 
-	if (debug & VP9_DEBUG_BUFMGR)
+	if (debug & VP9_DEBUG_BUFMGR_MORE)
 		pr_info("%s index = %d new vf_ref = %d\r\n",
 			__func__, index,
 			cm->buffer_pool->frame_bufs[index].buf.vf_ref);
@@ -5105,10 +5468,17 @@ static int prepare_display_buf(struct VP9Decoder_s *pbi,
 		return -1;
 	}
 
-	if (double_write_mode) {
-		set_canvas(pic_config);
+	if (get_double_write_mode(pbi)) {
+		set_canvas(pbi, pic_config);
 	}
+	display_frame_count[pbi->index]++;
 	if (vf) {
+#ifdef MULTI_INSTANCE_SUPPORT
+		if (vdec_frame_based(hw_to_vdec(pbi))) {
+			vf->pts = pic_config->pts;
+			vf->pts_us64 = pic_config->pts64;
+		} else
+#endif
 		/* if (pts_lookup_offset(PTS_TYPE_VIDEO,
 		   stream_offset, &vf->pts, 0) != 0) { */
 		if (pts_lookup_offset_us64
@@ -5178,9 +5548,8 @@ static int prepare_display_buf(struct VP9Decoder_s *pbi,
 		}
 
 		vf->index = 0xff00 | pic_config->index;
-#if 1
-/*SUPPORT_10BIT*/
-		if (double_write_mode & 0x10) {
+
+		if (get_double_write_mode(pbi) & 0x10) {
 			/* double write only */
 			vf->compBodyAddr = 0;
 			vf->compHeadAddr = 0;
@@ -5195,10 +5564,16 @@ static int prepare_display_buf(struct VP9Decoder_s *pbi,
 		/*head adr*/
 #endif
 		}
-		if (double_write_mode) {
+		if (get_double_write_mode(pbi)) {
 			vf->type = VIDTYPE_PROGRESSIVE |
 				VIDTYPE_VIU_FIELD;
 			vf->type |= VIDTYPE_VIU_NV21;
+			if (get_double_write_mode(pbi) == 3) {
+				vf->type |= VIDTYPE_COMPRESS;
+#ifdef VP9_10B_MMU
+				vf->type |= VIDTYPE_SCATTER;
+#endif
+			}
 #ifdef MULTI_INSTANCE_SUPPORT
 			if (pbi->m_ins_flag) {
 					vf->canvas0Addr = vf->canvas1Addr = -1;
@@ -5223,36 +5598,37 @@ static int prepare_display_buf(struct VP9Decoder_s *pbi,
 #ifdef VP9_10B_MMU
 			vf->type |= VIDTYPE_SCATTER;
 #endif
-			switch (pic_config->bit_depth) {
-			case VPX_BITS_8:
-				vf->bitdepth = BITDEPTH_Y8 |
-					BITDEPTH_U8 | BITDEPTH_V8;
-				break;
-			case VPX_BITS_10:
-			case VPX_BITS_12:
-				vf->bitdepth = BITDEPTH_Y10 |
-					BITDEPTH_U10 | BITDEPTH_V10;
-				break;
-			default:
-				vf->bitdepth = BITDEPTH_Y10 |
-					BITDEPTH_U10 | BITDEPTH_V10;
-				break;
-			}
-			if (pic_config->bit_depth == VPX_BITS_8)
-				vf->bitdepth |= BITDEPTH_SAVING_MODE;
-	}
-#else
-		vf->type = VIDTYPE_PROGRESSIVE | VIDTYPE_VIU_FIELD;
-		vf->type |= VIDTYPE_VIU_NV21;
-		vf->canvas0Addr = vf->canvas1Addr = spec2canvas(pic_config);
-#endif
+		}
+
+		switch (pic_config->bit_depth) {
+		case VPX_BITS_8:
+			vf->bitdepth = BITDEPTH_Y8 |
+				BITDEPTH_U8 | BITDEPTH_V8;
+			break;
+		case VPX_BITS_10:
+		case VPX_BITS_12:
+			vf->bitdepth = BITDEPTH_Y10 |
+				BITDEPTH_U10 | BITDEPTH_V10;
+			break;
+		default:
+			vf->bitdepth = BITDEPTH_Y10 |
+				BITDEPTH_U10 | BITDEPTH_V10;
+			break;
+		}
+		if ((vf->type & VIDTYPE_COMPRESS) == 0)
+			vf->bitdepth =
+				BITDEPTH_Y8 | BITDEPTH_U8 | BITDEPTH_V8;
+		if (pic_config->bit_depth == VPX_BITS_8)
+			vf->bitdepth |= BITDEPTH_SAVING_MODE;
+
 		set_frame_info(pbi, vf);
 		/* if((vf->width!=pic_config->width)|
 			(vf->height!=pic_config->height)) */
 		/* pr_info("aaa: %d/%d, %d/%d\n",
 		   vf->width,vf->height, pic_config->width,
 			pic_config->height); */
-		if (double_write_mode == 2) {
+		if ((get_double_write_mode(pbi) == 2) ||
+			(get_double_write_mode(pbi) == 3)) {
 			vf->width = pic_config->y_crop_width/4;
 			vf->height = pic_config->y_crop_height/4;
 		} else {
@@ -5272,17 +5648,35 @@ static int prepare_display_buf(struct VP9Decoder_s *pbi,
 			else
 				vf->duration = 0;
 		}
+#ifdef VP9_10B_MMU
 		if (vf->type & VIDTYPE_SCATTER) {
 			vf->mem_handle = decoder_mmu_box_get_mem_handle(
 				pbi->mmu_box,
 				pic_config->index);
+			vf->mem_head_handle = decoder_bmmu_box_get_mem_handle(
+				pbi->bmmu_box,
+				HEADER_BUFFER_IDX(pic_config->index));
 		} else {
 			vf->mem_handle = decoder_bmmu_box_get_mem_handle(
 				pbi->bmmu_box,
-				pic_config->index);
+				VF_BUFFER_IDX(pic_config->index));
+			vf->mem_head_handle = decoder_bmmu_box_get_mem_handle(
+				pbi->bmmu_box,
+				HEADER_BUFFER_IDX(pic_config->index));
 		}
+#else
+		vf->mem_handle = decoder_bmmu_box_get_mem_handle(
+			pbi->bmmu_box,
+			VF_BUFFER_IDX(pic_config->index));
+#endif
 		inc_vf_ref(pbi, pic_config->index);
 		kfifo_put(&pbi->display_q, (const struct vframe_s *)vf);
+		pbi->vf_pre_count++;
+#ifndef CONFIG_MULTI_DEC
+		/*count info*/
+		gvs->frame_dur = pbi->frame_dur;
+		vdec_count_info(gvs, 0, stream_offset);
+#endif
 		vf_notify_receiver(pbi->provider_name,
 				VFRAME_EVENT_PROVIDER_VFRAME_READY, NULL);
 	}
@@ -5378,6 +5772,53 @@ static void debug_buffer_mgr_more(struct VP9Decoder_s *pbi)
 
 }
 
+#ifdef VP9_10B_MMU
+static void vp9_recycle_mmu_buf_tail(struct VP9Decoder_s *pbi)
+{
+	struct VP9_Common_s *const cm = &pbi->common;
+	if (cm->cur_fb_idx_mmu != INVALID_IDX) {
+		if (pbi->used_4k_num == -1)
+			pbi->used_4k_num =
+			(READ_VREG(HEVC_SAO_MMU_STATUS) >> 16);
+		decoder_mmu_box_free_idx_tail(pbi->mmu_box,
+			cm->cur_fb_idx_mmu, pbi->used_4k_num);
+
+		cm->cur_fb_idx_mmu = INVALID_IDX;
+		pbi->used_4k_num = -1;
+	}
+}
+
+#ifdef MULTI_INSTANCE_SUPPORT
+static void vp9_recycle_mmu_buf(struct VP9Decoder_s *pbi)
+{
+	struct VP9_Common_s *const cm = &pbi->common;
+	if (cm->cur_fb_idx_mmu != INVALID_IDX) {
+		decoder_mmu_box_free_idx(pbi->mmu_box,
+			cm->cur_fb_idx_mmu);
+
+		cm->cur_fb_idx_mmu = INVALID_IDX;
+		pbi->used_4k_num = -1;
+	}
+}
+#endif
+#endif
+
+static void dec_again_process(struct VP9Decoder_s *pbi)
+{
+	amhevc_stop();
+	pbi->dec_result = DEC_RESULT_AGAIN;
+	if (pbi->process_state ==
+		PROC_STATE_DECODESLICE) {
+		pbi->process_state =
+		PROC_STATE_SENDAGAIN;
+#ifdef VP9_10B_MMU
+		vp9_recycle_mmu_buf(pbi);
+#endif
+	}
+	reset_process_time(pbi);
+	vdec_schedule_work(&pbi->work);
+}
+
 static irqreturn_t vvp9_isr_thread_fn(int irq, void *data)
 {
 	struct VP9Decoder_s *pbi = (struct VP9Decoder_s *)data;
@@ -5388,9 +5829,44 @@ static irqreturn_t vvp9_isr_thread_fn(int irq, void *data)
 	/*if (pbi->wait_buf)
 		pr_info("set wait_buf to 0\r\n");
 	*/
+	if (pbi->eos)
+		return IRQ_HANDLED;
 	pbi->wait_buf = 0;
+#ifdef MULTI_INSTANCE_SUPPORT
+	if ((dec_status == HEVC_NAL_DECODE_DONE) ||
+			(dec_status == HEVC_SEARCH_BUFEMPTY) ||
+			(dec_status == HEVC_DECODE_BUFEMPTY)
+		) {
+		if (pbi->m_ins_flag) {
+			reset_process_time(pbi);
+			if (!vdec_frame_based(hw_to_vdec(pbi)))
+				dec_again_process(pbi);
+			else {
+				pbi->dec_result = DEC_RESULT_GET_DATA;
+				vdec_schedule_work(&pbi->work);
+			}
+		}
+		pbi->process_busy = 0;
+		return IRQ_HANDLED;
+	} else if (dec_status == HEVC_DECPIC_DATA_DONE) {
+		if (pbi->m_ins_flag) {
+			reset_process_time(pbi);
+			pbi->dec_result = DEC_RESULT_DONE;
+			amhevc_stop();
+			vdec_schedule_work(&pbi->work);
+		}
+
+		pbi->process_busy = 0;
+		return IRQ_HANDLED;
+	}
+#endif
 
 	if (dec_status == VP9_EOS) {
+#ifdef MULTI_INSTANCE_SUPPORT
+		if (pbi->m_ins_flag)
+			reset_process_time(pbi);
+#endif
+
 		pr_info("VP9_EOS, flush buffer\r\n");
 
 		vp9_bufmgr_postproc(pbi);
@@ -5398,6 +5874,23 @@ static irqreturn_t vvp9_isr_thread_fn(int irq, void *data)
 		pr_info("send VP9_10B_DISCARD_NAL\r\n");
 		WRITE_VREG(HEVC_DEC_STATUS_REG, VP9_10B_DISCARD_NAL);
 		pbi->process_busy = 0;
+#ifdef MULTI_INSTANCE_SUPPORT
+		if (pbi->m_ins_flag) {
+			pbi->dec_result = DEC_RESULT_DONE;
+			amhevc_stop();
+			vdec_schedule_work(&pbi->work);
+		}
+#endif
+		return IRQ_HANDLED;
+	} else if (dec_status == HEVC_DECODE_OVER_SIZE) {
+		pr_info("vp9  decode oversize !!\n");
+		debug |= (VP9_DEBUG_DIS_LOC_ERROR_PROC |
+			VP9_DEBUG_DIS_SYS_ERROR_PROC);
+		pbi->fatal_error |= DECODER_FATAL_ERROR_SIZE_OVERFLOW;
+#ifdef MULTI_INSTANCE_SUPPORT
+	if (pbi->m_ins_flag)
+		reset_process_time(pbi);
+#endif
 		return IRQ_HANDLED;
 	}
 
@@ -5405,8 +5898,20 @@ static irqreturn_t vvp9_isr_thread_fn(int irq, void *data)
 		pbi->process_busy = 0;
 		return IRQ_HANDLED;
 	}
-	if (pbi->frame_count > 0)
-		vp9_bufmgr_postproc(pbi);
+
+#ifdef MULTI_INSTANCE_SUPPORT
+	if (pbi->m_ins_flag)
+		reset_process_time(pbi);
+#endif
+
+	if (pbi->process_state != PROC_STATE_SENDAGAIN) {
+#ifdef VP9_10B_MMU
+		vp9_recycle_mmu_buf_tail(pbi);
+#endif
+
+		if (pbi->frame_count > 0)
+			vp9_bufmgr_postproc(pbi);
+	}
 
 	if (debug & VP9_DEBUG_SEND_PARAM_WITH_REG) {
 		get_rpm_param(&vp9_param);
@@ -5429,16 +5934,64 @@ static irqreturn_t vvp9_isr_thread_fn(int irq, void *data)
 	bit_depth_luma = vp9_param.p.bit_depth;
 	bit_depth_chroma = vp9_param.p.bit_depth;
 
-	ret = vp9_bufmgr_process(pbi, &vp9_param);
-	pbi->slice_idx++;
+	if (pbi->process_state != PROC_STATE_SENDAGAIN) {
+		ret = vp9_bufmgr_process(pbi, &vp9_param);
+		if (!pbi->m_ins_flag)
+			pbi->slice_idx++;
+	} else {
+		union param_u *params = &vp9_param;
+#ifdef VP9_10B_MMU
+		ret = vp9_alloc_mmu(pbi,
+			cm->new_fb_idx,
+			params->p.width,
+			params->p.height,
+			params->p.bit_depth,
+			pbi->frame_mmu_map_addr);
+		if (ret >= 0)
+			cm->cur_fb_idx_mmu = cm->new_fb_idx;
+		else
+			pr_err("can't alloc need mmu1,idx %d ret =%d\n",
+				cm->new_fb_idx,
+				ret);
+#else
+		ret = 0;
+#endif
+		WRITE_VREG(HEVC_PARSER_PICTURE_SIZE,
+		(params->p.height << 16) | params->p.width);
+	}
 	if (ret < 0) {
 		pr_info("vp9_bufmgr_process=> %d, VP9_10B_DISCARD_NAL\r\n",
 		 ret);
 		WRITE_VREG(HEVC_DEC_STATUS_REG, VP9_10B_DISCARD_NAL);
+		cm->show_frame = 0;
 		pbi->process_busy = 0;
+#ifdef VP9_10B_MMU
+		vp9_recycle_mmu_buf(pbi);
+#endif
+#ifdef MULTI_INSTANCE_SUPPORT
+		if (pbi->m_ins_flag) {
+			pbi->dec_result = DEC_RESULT_DONE;
+			amhevc_stop();
+			vdec_schedule_work(&pbi->work);
+		}
+#endif
 		return IRQ_HANDLED;
 	} else if (ret == 0) {
-		pbi->frame_count++;
+		if (pbi->process_state != PROC_STATE_SENDAGAIN) {
+			if (!pbi->m_ins_flag) {
+				pbi->frame_count++;
+				decode_frame_count[pbi->index]
+					= pbi->frame_count;
+			}
+#ifdef MULTI_INSTANCE_SUPPORT
+			if (pbi->chunk) {
+				struct PIC_BUFFER_CONFIG_s *cur_pic_config =
+					&cm->cur_frame->buf;
+				cur_pic_config->pts = pbi->chunk->pts;
+				cur_pic_config->pts64 = pbi->chunk->pts64;
+			}
+#endif
+		}
 		/*pr_info("Decode Frame Data %d\n", pbi->frame_count);*/
 		config_pic_size(pbi, vp9_param.p.bit_depth);
 		if ((pbi->common.frame_type != KEY_FRAME)
@@ -5454,33 +6007,33 @@ static irqreturn_t vvp9_isr_thread_fn(int irq, void *data)
 	config_sao_hw(pbi, &vp9_param);
 
 #ifdef VP9_LPF_LVL_UPDATE
-    /*
-     * Get loop filter related picture level parameters from Parser
-     */
-	lf->mode_ref_delta_enabled = vp9_param.p.mode_ref_delta_enabled;
-	lf->sharpness_level = vp9_param.p.sharpness_level;
+	/*
+	 * Get loop filter related picture level parameters from Parser
+	 */
+	pbi->lf->mode_ref_delta_enabled = vp9_param.p.mode_ref_delta_enabled;
+	pbi->lf->sharpness_level = vp9_param.p.sharpness_level;
 	for (i = 0; i < 4; i++)
-		lf->ref_deltas[i] = vp9_param.p.ref_deltas[i];
+		pbi->lf->ref_deltas[i] = vp9_param.p.ref_deltas[i];
 	for (i = 0; i < 2; i++)
-		lf->mode_deltas[i] = vp9_param.p.mode_deltas[i];
-	default_filt_lvl = vp9_param.p.filter_level;
-	seg_4lf->enabled = vp9_param.p.seg_enabled;
-	seg_4lf->abs_delta = vp9_param.p.seg_abs_delta;
+		pbi->lf->mode_deltas[i] = vp9_param.p.mode_deltas[i];
+	pbi->default_filt_lvl = vp9_param.p.filter_level;
+	pbi->seg_4lf->enabled = vp9_param.p.seg_enabled;
+	pbi->seg_4lf->abs_delta = vp9_param.p.seg_abs_delta;
 	for (i = 0; i < MAX_SEGMENTS; i++)
-		seg_4lf->feature_mask[i] = (vp9_param.p.seg_lf_info[i] &
+		pbi->seg_4lf->feature_mask[i] = (vp9_param.p.seg_lf_info[i] &
 		0x8000) ? (1 << SEG_LVL_ALT_LF) : 0;
-
 	for (i = 0; i < MAX_SEGMENTS; i++)
-			seg_4lf->feature_data[i][SEG_LVL_ALT_LF]
-			= (vp9_param.p.seg_lf_info[i]
-			& 0x100) ? -(vp9_param.p.seg_lf_info[i]
-			& 0x3f) : (vp9_param.p.seg_lf_info[i] & 0x3f);
+		pbi->seg_4lf->feature_data[i][SEG_LVL_ALT_LF]
+		= (vp9_param.p.seg_lf_info[i]
+		& 0x100) ? -(vp9_param.p.seg_lf_info[i]
+		& 0x3f) : (vp9_param.p.seg_lf_info[i] & 0x3f);
 	/*
 	* Update loop filter Thr/Lvl table for every frame
 	*/
 	/*pr_info
 	("vp9_loop_filter (run before every frame decoding start)\n");*/
-	vp9_loop_filter_frame_init(seg_4lf, lfi, lf, default_filt_lvl);
+	vp9_loop_filter_frame_init(pbi->seg_4lf,
+		pbi->lfi, pbi->lf, pbi->default_filt_lvl);
 #endif
 	/*pr_info("HEVC_DEC_STATUS_REG <= VP9_10B_DECODE_SLICE\n");*/
 
@@ -5492,20 +6045,25 @@ static irqreturn_t vvp9_isr_thread_fn(int irq, void *data)
 	WRITE_VREG(HEVC_DEC_STATUS_REG, VP9_10B_DECODE_SLICE);
 	}
 	pbi->process_busy = 0;
+	pbi->process_state = PROC_STATE_DECODESLICE;
 #ifdef VP9_10B_MMU
-	if (pbi->last_put_idx >= 0 && pbi->last_put_idx < FRAME_BUFFERS) {
+	if (pbi->last_put_idx >= 0 && pbi->last_put_idx < pbi->used_buf_num) {
 		struct RefCntBuffer_s *frame_bufs = cm->buffer_pool->frame_bufs;
 		int i = pbi->last_put_idx;
 		/*free not used buffers.*/
 		if ((frame_bufs[i].ref_count == 0) &&
 			(frame_bufs[i].buf.vf_ref == 0) &&
-			(frame_bufs[i].buf.used_by_display == 0) &&
 			(frame_bufs[i].buf.index != -1)) {
 			decoder_mmu_box_free_idx(pbi->mmu_box, i);
 		}
 		pbi->last_put_idx = -1;
 	}
 #endif
+#ifdef MULTI_INSTANCE_SUPPORT
+	if (pbi->m_ins_flag)
+		start_process_time(pbi);
+#endif
+
 	return IRQ_HANDLED;
 }
 
@@ -5516,6 +6074,10 @@ static irqreturn_t vvp9_isr(int irq, void *data)
 	struct VP9Decoder_s *pbi = (struct VP9Decoder_s *)data;
 	unsigned int adapt_prob_status;
 	struct VP9_Common_s *const cm = &pbi->common;
+	uint debug_tag;
+
+	WRITE_VREG(HEVC_ASSIST_MBOX1_CLR_REG, 1);
+
 	dec_status = READ_VREG(HEVC_DEC_STATUS_REG);
 	adapt_prob_status = READ_VREG(VP9_ADAPT_PROB_REG);
 	if (pbi->init_flag == 0)
@@ -5525,57 +6087,92 @@ static irqreturn_t vvp9_isr(int irq, void *data)
 	pbi->dec_status = dec_status;
 	pbi->process_busy = 1;
 	if (debug & VP9_DEBUG_BUFMGR)
-		pr_info("vp9 isr dec status  = %d\n", dec_status);
-
-	if (debug & VP9_DEBUG_UCODE) {
-		if (READ_HREG(DEBUG_REG1) & 0x10000) {
-			dma_sync_single_for_cpu(
-				amports_get_dma_device(),
-				pbi->lmem_phy_addr,
-				LMEM_BUF_SIZE,
-				DMA_FROM_DEVICE);
+		pr_info("vp9 isr dec status  = 0x%x, lcu 0x%x shiftbyte 0x%x (%x %x lev %x, wr %x, rd %x)\n",
+			dec_status, READ_VREG(HEVC_PARSER_LCU_START),
+			READ_VREG(HEVC_SHIFT_BYTE_COUNT),
+			READ_VREG(HEVC_STREAM_START_ADDR),
+			READ_VREG(HEVC_STREAM_END_ADDR),
+			READ_VREG(HEVC_STREAM_LEVEL),
+			READ_VREG(HEVC_STREAM_WR_PTR),
+			READ_VREG(HEVC_STREAM_RD_PTR)
+		);
 
-			pr_info("LMEM<tag %x>:\n", READ_HREG(DEBUG_REG1));
-			for (i = 0; i < 0x400; i += 4) {
-				int ii;
-				if ((i & 0xf) == 0)
-					pr_info("%03x: ", i);
-				for (ii = 0; ii < 4; ii++) {
-					pr_info("%04x ",
-						   pbi->lmem_ptr[i + 3 - ii]);
-				}
-				if (((i + ii) & 0xf) == 0)
-					pr_info("\n");
+	debug_tag = READ_HREG(DEBUG_REG1);
+	if (debug_tag & 0x10000) {
+		dma_sync_single_for_cpu(
+			amports_get_dma_device(),
+			pbi->lmem_phy_addr,
+			LMEM_BUF_SIZE,
+			DMA_FROM_DEVICE);
+
+		pr_info("LMEM<tag %x>:\n", READ_HREG(DEBUG_REG1));
+		for (i = 0; i < 0x400; i += 4) {
+			int ii;
+			if ((i & 0xf) == 0)
+				pr_info("%03x: ", i);
+			for (ii = 0; ii < 4; ii++) {
+				pr_info("%04x ",
+					   pbi->lmem_ptr[i + 3 - ii]);
 			}
-			WRITE_HREG(DEBUG_REG1, 0);
-		} else if (READ_HREG(DEBUG_REG1) != 0) {
-			pr_info("dbg%x: %x\n", READ_HREG(DEBUG_REG1),
-				   READ_HREG(DEBUG_REG2));
-			WRITE_HREG(DEBUG_REG1, 0);
-			pbi->process_busy = 0;
-			return IRQ_HANDLED;
+			if (((i + ii) & 0xf) == 0)
+				pr_info("\n");
 		}
 
-	}
-
-	if (pbi->error_flag == 1) {
-		pbi->error_flag = 2;
-		pbi->process_busy = 0;
-		return IRQ_HANDLED;
-	} else if (pbi->error_flag == 3) {
+		if ((udebug_pause_pos == (debug_tag & 0xffff)) &&
+			(udebug_pause_decode_idx == 0 ||
+			udebug_pause_decode_idx == pbi->slice_idx) &&
+			(udebug_pause_val == 0 ||
+			udebug_pause_val == READ_HREG(DEBUG_REG2)))
+			pbi->ucode_pause_pos = udebug_pause_pos;
+		else if (debug_tag & 0x20000)
+			pbi->ucode_pause_pos = 0xffffffff;
+		if (pbi->ucode_pause_pos)
+			reset_process_time(pbi);
+		else
+			WRITE_HREG(DEBUG_REG1, 0);
+	} else if (debug_tag != 0) {
+		pr_info(
+			"dbg%x: %x lcu %x\n", READ_HREG(DEBUG_REG1),
+			   READ_HREG(DEBUG_REG2),
+			   READ_VREG(HEVC_PARSER_LCU_START));
+		if ((udebug_pause_pos == (debug_tag & 0xffff)) &&
+			(udebug_pause_decode_idx == 0 ||
+			udebug_pause_decode_idx == pbi->slice_idx) &&
+			(udebug_pause_val == 0 ||
+			udebug_pause_val == READ_HREG(DEBUG_REG2)))
+			pbi->ucode_pause_pos = udebug_pause_pos;
+		if (pbi->ucode_pause_pos)
+			reset_process_time(pbi);
+		else
+			WRITE_HREG(DEBUG_REG1, 0);
 		pbi->process_busy = 0;
 		return IRQ_HANDLED;
 	}
 
-	if (is_buffer_empty(cm)) {
-		/*
-		if (pbi->wait_buf == 0)
-			pr_info("set wait_buf to 1\r\n");
-		*/
-		pbi->wait_buf = 1;
-		pbi->process_busy = 0;
-		return IRQ_HANDLED;
+#ifdef MULTI_INSTANCE_SUPPORT
+	if (!pbi->m_ins_flag) {
+#endif
+		if (pbi->error_flag == 1) {
+			pbi->error_flag = 2;
+			pbi->process_busy = 0;
+			return IRQ_HANDLED;
+		} else if (pbi->error_flag == 3) {
+			pbi->process_busy = 0;
+			return IRQ_HANDLED;
+		}
+
+		if (get_free_buf_count(pbi) <= 0) {
+			/*
+			if (pbi->wait_buf == 0)
+				pr_info("set wait_buf to 1\r\n");
+			*/
+			pbi->wait_buf = 1;
+			pbi->process_busy = 0;
+			return IRQ_HANDLED;
+		}
+#ifdef MULTI_INSTANCE_SUPPORT
 	}
+#endif
 	if ((adapt_prob_status & 0xff) == 0xfd) {
 		/*VP9_REQ_ADAPT_PROB*/
 		int pre_fc = (cm->frame_type == KEY_FRAME) ? 1 : 0;
@@ -5585,7 +6182,10 @@ static irqreturn_t vvp9_isr(int irq, void *data)
 		uint8_t *cur_prob_b =
 		((uint8_t *)pbi->prob_buffer_addr) + 0x4000;
 		uint8_t *count_b = (uint8_t *)pbi->count_buffer_addr;
-
+#ifdef MULTI_INSTANCE_SUPPORT
+		if (pbi->m_ins_flag)
+			reset_process_time(pbi);
+#endif
 		adapt_coef_probs(pbi->pic_count,
 			(cm->last_frame_type == KEY_FRAME),
 			pre_fc, (adapt_prob_status >> 8),
@@ -5595,94 +6195,13 @@ static irqreturn_t vvp9_isr(int irq, void *data)
 		memcpy(prev_prob_b, cur_prob_b, PROB_SIZE);
 		WRITE_VREG(VP9_ADAPT_PROB_REG, 0);
 		pbi->pic_count += 1;
-
-		/*return IRQ_HANDLED;*/
-	}
 #ifdef MULTI_INSTANCE_SUPPORT
-#if 0
-	if ((dec_status == HEVC_DECPIC_DATA_DONE) && (pbi->m_ins_flag)) {
-		if (pbi->chunk) {
-			pbi->cur_pic->pts = pbi->chunk->pts;
-			pbi->cur_pic->pts64 = pbi->chunk->pts64;
-		} else if (pts_lookup_offset_us64
-			(PTS_TYPE_VIDEO,
-			pbi->cur_pic->stream_offset,
-			&pbi->cur_pic->pts,
-			0,
-			&pbi->cur_pic->pts64) != 0) {
-#ifdef DEBUG_PTS
-			pbi->pts_missed++;
-#endif
-			pbi->cur_pic->pts = 0;
-			pbi->cur_pic->pts64 = 0;
-		}
-	}
-#endif
-	if (dec_status == HEVC_NAL_DECODE_DONE) {
-		if (pbi->m_ins_flag) {
-#if 0
-			if (!vdec_frame_based(hw_to_vdec(hevc))) {
-				pbi->dec_result = DEC_RESULT_AGAIN;
-				if ((debug &
-				ONLY_RESET_AT_START) == 0)
-					amhevc_stop();
-			} else
-				pbi->dec_result = DEC_RESULT_GET_DATA;
-#else
-			if (!vdec_frame_based(hw_to_vdec(pbi)))
-				pbi->dec_result = DEC_RESULT_AGAIN;
-			else
-				pbi->dec_result = DEC_RESULT_DONE;
-			amhevc_stop();
+		if (pbi->m_ins_flag)
+			start_process_time(pbi);
 #endif
-			schedule_work(&pbi->work);
-		}
-		pbi->process_busy = 0;
-		return IRQ_HANDLED;
-	} else if (dec_status == HEVC_DECPIC_DATA_DONE) {
-		if (pbi->m_ins_flag) {
-			pbi->dec_result = DEC_RESULT_DONE;
-			amhevc_stop();
-			schedule_work(&pbi->work);
-		}
 
-		pbi->process_busy = 0;
-		return IRQ_HANDLED;
-	} else if (
-			(dec_status == HEVC_SEARCH_BUFEMPTY) ||
-			(dec_status == HEVC_DECODE_BUFEMPTY) ||
-			(dec_status == HEVC_DECODE_TIMEOUT)) {
-		if (vdec_frame_based(hw_to_vdec(pbi)) ||
-			(READ_VREG(HEVC_STREAM_LEVEL) > 0x200)) {
-			if (debug & VP9_DEBUG_DIS_LOC_ERROR_PROC) {
-				vp9_print(pbi, PRINT_FLAG_ERROR,
-					"%s decoding error, level 0x%x\n",
-					__func__, READ_VREG(HEVC_STREAM_LEVEL));
-				goto send_again;
-			}
-			amhevc_stop();
-			vp9_print(pbi, PRINT_FLAG_UCODE_EVT,
-				"%s %s\n", __func__,
-				(dec_status == HEVC_SEARCH_BUFEMPTY) ?
-				"HEVC_SEARCH_BUFEMPTY" :
-				(dec_status == HEVC_DECODE_BUFEMPTY) ?
-				"HEVC_DECODE_BUFEMPTY" : "HEVC_DECODE_TIMEOUT");
-			pbi->dec_result = DEC_RESULT_DONE;
-
-			schedule_work(&pbi->work);
-		} else {
-			/* WRITE_VREG(DPB_STATUS_REG, H264_ACTION_INIT); */
-			vp9_print(pbi, PRINT_FLAG_VDEC_STATUS,
-				"%s DEC_RESULT_AGAIN\n", __func__);
-send_again:
-			pbi->dec_result = DEC_RESULT_AGAIN;
-			schedule_work(&pbi->work);
-		}
-		pbi->process_busy = 0;
-		return IRQ_HANDLED;
+		/*return IRQ_HANDLED;*/
 	}
-#endif
-
 	return IRQ_WAKE_THREAD;
 }
 
@@ -5697,8 +6216,8 @@ static void vvp9_put_timer_func(unsigned long arg)
 	if (pbi->m_ins_flag) {
 		if (hw_to_vdec(pbi)->next_status
 			== VDEC_STATUS_DISCONNECTED) {
-			pbi->dec_result = DEC_RESULT_DONE;
-			schedule_work(&pbi->work);
+			pbi->dec_result = DEC_RESULT_FORCE_EXIT;
+			vdec_schedule_work(&pbi->work);
 			pr_info(
 			"vdec requested to be disconnected\n");
 			return;
@@ -5750,12 +6269,77 @@ static void vvp9_put_timer_func(unsigned long arg)
 			}
 		}
 	}
+#ifdef MULTI_INSTANCE_SUPPORT
+	else {
+		if (
+			(decode_timeout_val > 0) &&
+			(pbi->start_process_time > 0) &&
+			((1000 * (jiffies - pbi->start_process_time) / HZ)
+				> decode_timeout_val)
+		) {
+			int current_lcu_idx =
+				READ_VREG(HEVC_PARSER_LCU_START)
+				& 0xffffff;
+			if (pbi->last_lcu_idx == current_lcu_idx) {
+				if (pbi->decode_timeout_count > 0)
+					pbi->decode_timeout_count--;
+				if (pbi->decode_timeout_count == 0) {
+					if (input_frame_based(
+						hw_to_vdec(pbi)) ||
+					(READ_VREG(HEVC_STREAM_LEVEL) > 0x200))
+						timeout_process(pbi);
+					else {
+						vp9_print(pbi, 0,
+							"timeout & empty, again\n");
+						dec_again_process(pbi);
+					}
+				}
+			} else {
+				start_process_time(pbi);
+				pbi->last_lcu_idx = current_lcu_idx;
+			}
+		}
+	}
+#endif
+
+	if ((pbi->ucode_pause_pos != 0) &&
+		(pbi->ucode_pause_pos != 0xffffffff) &&
+		udebug_pause_pos != pbi->ucode_pause_pos) {
+		pbi->ucode_pause_pos = 0;
+		WRITE_HREG(DEBUG_REG1, 0);
+	}
+#ifdef MULTI_INSTANCE_SUPPORT
+	if (debug & VP9_DEBUG_FORCE_SEND_AGAIN) {
+		pr_info(
+		"Force Send Again\r\n");
+		debug &= ~VP9_DEBUG_FORCE_SEND_AGAIN;
+		reset_process_time(pbi);
+		pbi->dec_result = DEC_RESULT_AGAIN;
+		if (pbi->process_state ==
+			PROC_STATE_DECODESLICE) {
+#ifdef VP9_10B_MMU
+			vp9_recycle_mmu_buf(pbi);
+#endif
+			pbi->process_state =
+			PROC_STATE_SENDAGAIN;
+		}
+		amhevc_stop();
 
-	if (decode_stop_pos != decode_stop_pos_pre) {
-		WRITE_VREG(DECODE_STOP_POS, decode_stop_pos);
-		decode_stop_pos_pre = decode_stop_pos;
+		vdec_schedule_work(&pbi->work);
 	}
 
+	if (debug & VP9_DEBUG_DUMP_DATA) {
+		debug &= ~VP9_DEBUG_DUMP_DATA;
+		vp9_print(pbi, 0,
+			"%s: chunk size 0x%x off 0x%x sum 0x%x\n",
+			__func__,
+			pbi->chunk->size,
+			pbi->chunk->offset,
+			get_data_check_sum(pbi, pbi->chunk->size)
+			);
+		dump_data(pbi, pbi->chunk->size);
+	}
+#endif
 	if (debug & VP9_DEBUG_DUMP_PIC_LIST) {
 		dump_pic_list(pbi);
 		debug &= ~VP9_DEBUG_DUMP_PIC_LIST;
@@ -5766,10 +6350,6 @@ static void vvp9_put_timer_func(unsigned long arg)
 	}
 	/*if (debug & VP9_DEBUG_HW_RESET) {
 	}*/
-	if (debug & VP9_DEBUG_ERROR_TRIG) {
-		WRITE_VREG(DECODE_STOP_POS, 1);
-		debug &= ~VP9_DEBUG_ERROR_TRIG;
-	}
 
 	if (radr != 0) {
 		if (rval != 0) {
@@ -5803,7 +6383,7 @@ static void vvp9_put_timer_func(unsigned long arg)
 		if (dbg_cmd == 1) {
 			u32 disp_laddr;
 			if (get_cpu_type() >= MESON_CPU_MAJOR_ID_GXBB &&
-				double_write_mode == 0) {
+				get_double_write_mode(pbi) == 0) {
 				disp_laddr =
 					READ_VCBUS_REG(AFBC_BODY_BADDR) << 4;
 			} else {
@@ -5834,17 +6414,31 @@ static void vvp9_put_timer_func(unsigned long arg)
 }
 
 
-int vvp9_dec_status(struct vdec_s *vdec, struct vdec_status *vstatus)
+int vvp9_dec_status(struct vdec_s *vdec, struct vdec_info *vstatus)
 {
-	struct VP9Decoder_s *pbi = &gHevc;
-	vstatus->width = frame_width;
-	vstatus->height = frame_height;
-	if (pbi->frame_dur != 0)
-		vstatus->fps = 96000 / pbi->frame_dur;
+	struct VP9Decoder_s *vp9 = &gHevc;
+	vstatus->frame_width = frame_width;
+	vstatus->frame_height = frame_height;
+	if (vp9->frame_dur != 0)
+		vstatus->frame_rate = 96000 / vp9->frame_dur;
 	else
-		vstatus->fps = -1;
+		vstatus->frame_rate = -1;
 	vstatus->error_count = 0;
-	vstatus->status = pbi->stat | pbi->fatal_error;
+	vstatus->status = vp9->stat | vp9->fatal_error;
+	vstatus->frame_dur = vp9->frame_dur;
+#ifndef CONFIG_MULTI_DEC
+	vstatus->bit_rate = gvs->bit_rate;
+	vstatus->frame_data = gvs->frame_data;
+	vstatus->total_data = gvs->total_data;
+	vstatus->frame_count = gvs->frame_count;
+	vstatus->error_frame_count = gvs->error_frame_count;
+	vstatus->drop_frame_count = gvs->drop_frame_count;
+	vstatus->total_data = gvs->total_data;
+	vstatus->samp_cnt = gvs->samp_cnt;
+	vstatus->offset = gvs->offset;
+	snprintf(vstatus->vdec_name, sizeof(vstatus->vdec_name),
+		"%s", DRIVER_NAME);
+#endif
 	return 0;
 }
 
@@ -5879,12 +6473,12 @@ static void vvp9_prot_init(struct VP9Decoder_s *pbi)
 	vp9_init_decoder_hw(pbi);
 
 #ifdef VP9_LPF_LVL_UPDATE
-	vp9_loop_filter_init();
+	vp9_loop_filter_init(pbi);
 #endif
 
 #if 1
-	if (debug & VP9_DEBUG_BUFMGR)
-		pr_info("[test.c] Enable BitStream Fetch\n");
+	if (debug & VP9_DEBUG_BUFMGR_MORE)
+		pr_info("%s\n", __func__);
 	data32 = READ_VREG(HEVC_STREAM_CONTROL);
 	data32 = data32 |
 		(1 << 0)/*stream_fetch_enable*/
@@ -5933,14 +6527,11 @@ static void vvp9_prot_init(struct VP9Decoder_s *pbi)
 	/* disable PSCALE for hardware sharing */
 	WRITE_VREG(HEVC_PSCALE_CTRL, 0);
 
-	if (debug & VP9_DEBUG_UCODE)
-		WRITE_VREG(DEBUG_REG1, 0x1);
-	else
-		WRITE_VREG(DEBUG_REG1, 0x0);
+	WRITE_VREG(DEBUG_REG1, 0x0);
 	/*check vps/sps/pps/i-slice in ucode*/
 	WRITE_VREG(NAL_SEARCH_CTL, 0x8);
 
-	WRITE_VREG(DECODE_STOP_POS, decode_stop_pos);
+	WRITE_VREG(DECODE_STOP_POS, udebug_flag);
 
 }
 
@@ -5949,6 +6540,14 @@ static int vvp9_local_init(struct VP9Decoder_s *pbi)
 	int i;
 	int ret;
 	int width, height;
+	if (alloc_lf_buf(pbi) < 0)
+		return -1;
+
+	pbi->gvs = vzalloc(sizeof(struct vdec_info));
+	if (NULL == pbi->gvs) {
+		pr_info("the struct of vdec status malloc failed.\n");
+		return -1;
+	}
 #ifdef DEBUG_PTS
 	pbi->pts_missed = 0;
 	pbi->pts_hit = 0;
@@ -6014,6 +6613,7 @@ static s32 vvp9_init(struct VP9Decoder_s *pbi)
 		add_timer(&pbi->timer);
 
 		pbi->stat |= STAT_TIMER_ARM;
+		pbi->stat |= STAT_ISR_REG;
 
 		INIT_WORK(&pbi->work, vp9_work);
 
@@ -6093,25 +6693,17 @@ static int vvp9_stop(struct VP9Decoder_s *pbi)
 {
 
 	pbi->init_flag = 0;
-	/*
-	if ((debug & VP9_DEBUG_NOWAIT_DECODE_DONE_WHEN_STOP) == 0) {
-		int wait_timeout_count = 0;
-		while ((READ_VREG(HEVC_DEC_STATUS_REG) ==
-			   VP9_10B_DECODE_SLICE &&
-				wait_timeout_count < 10) ||
-				pbi->process_busy){
-			wait_timeout_count++;
-			msleep(20);
-		}
-	}
-	*/
+
 	if (pbi->stat & STAT_VDEC_RUN) {
 		amhevc_stop();
 		pbi->stat &= ~STAT_VDEC_RUN;
 	}
 
 	if (pbi->stat & STAT_ISR_REG) {
-		WRITE_VREG(HEVC_ASSIST_MBOX1_MASK, 0);
+#ifdef MULTI_INSTANCE_SUPPORT
+		if (!pbi->m_ins_flag)
+#endif
+			WRITE_VREG(HEVC_ASSIST_MBOX1_MASK, 0);
 		vdec_free_irq(VDEC_IRQ_1, (void *)pbi);
 		pbi->stat &= ~STAT_ISR_REG;
 	}
@@ -6131,11 +6723,10 @@ static int vvp9_stop(struct VP9Decoder_s *pbi)
 	vp9_local_uninit(pbi);
 
 #ifdef MULTI_INSTANCE_SUPPORT
-	if (pbi->m_ins_flag) {
+	if (pbi->m_ins_flag)
 		cancel_work_sync(&pbi->work);
-	} else {
+	else
 		amhevc_disable();
-	}
 #else
 	amhevc_disable();
 #endif
@@ -6146,10 +6737,14 @@ static int vvp9_stop(struct VP9Decoder_s *pbi)
 
 static int amvdec_vp9_mmu_init(struct VP9Decoder_s *pbi)
 {
+	int tvp_flag = vdec_secure(hw_to_vdec(pbi)) ?
+		CODEC_MM_FLAGS_TVP : 0;
+
 #ifdef VP9_10B_MMU
 	pbi->mmu_box = decoder_mmu_box_alloc_box(DRIVER_NAME,
-		0, FRAME_BUFFERS,
-		48 * SZ_1M
+		pbi->index, FRAME_BUFFERS,
+		48 * SZ_1M,
+		tvp_flag
 		);
 	if (!pbi->mmu_box) {
 		pr_err("vp9 alloc mmu box failed!!\n");
@@ -6162,7 +6757,8 @@ static int amvdec_vp9_mmu_init(struct VP9Decoder_s *pbi)
 			MAX_BMMU_BUFFER_NUM,
 			4 + PAGE_SHIFT,
 			CODEC_MM_FLAGS_CMA_CLEAR |
-			CODEC_MM_FLAGS_FOR_VDECODER);
+			CODEC_MM_FLAGS_FOR_VDECODER |
+			tvp_flag);
 	if (!pbi->bmmu_box) {
 		pr_err("vp9 alloc bmmu box failed!!\n");
 		return -1;
@@ -6174,6 +6770,10 @@ static int amvdec_vp9_probe(struct platform_device *pdev)
 	struct vdec_s *pdata = *(struct vdec_s **)pdev->dev.platform_data;
 	struct BUF_s BUF[MAX_BUF_NUM];
 	struct VP9Decoder_s *pbi = &gHevc;
+	int ret;
+#ifndef MULTI_INSTANCE_SUPPORT
+	int i;
+#endif
 	pr_info("%s\n", __func__);
 	mutex_lock(&vvp9_mutex);
 
@@ -6182,6 +6782,12 @@ static int amvdec_vp9_probe(struct platform_device *pdev)
 	memcpy(&pbi->m_BUF[0], &BUF[0], sizeof(struct BUF_s) * MAX_BUF_NUM);
 
 	pbi->init_flag = 0;
+
+#ifdef MULTI_INSTANCE_SUPPORT
+	pbi->eos = 0;
+	pbi->start_process_time = 0;
+	pbi->timeout_num = 0;
+#endif
 	pbi->fatal_error = 0;
 	pbi->show_frame_num = 0;
 	if (pdata == NULL) {
@@ -6191,20 +6797,38 @@ static int amvdec_vp9_probe(struct platform_device *pdev)
 	}
 	pbi->m_ins_flag = 0;
 #ifdef MULTI_INSTANCE_SUPPORT
-	pbi->buf_start = pdata->mem_start;
-	pbi->buf_size = pdata->mem_end - pdata->mem_start + 1;
-#else
-	pbi->mc_buf_spec.buf_end = pdata->mem_end + 1;
-	for (i = 0; i < WORK_BUF_SPEC_NUM; i++)
-		amvvp9_workbuff_spec[i].start_adr = pdata->mem_start;
+	pbi->platform_dev = pdev;
+	platform_set_drvdata(pdev, pdata);
 #endif
 	if (amvdec_vp9_mmu_init(pbi) < 0) {
+		mutex_unlock(&vvp9_mutex);
 		pr_err("vp9 alloc bmmu box failed!!\n");
 		return -1;
 	}
+
+	ret = decoder_bmmu_box_alloc_buf_phy(pbi->bmmu_box, WORK_SPACE_BUF_ID,
+			work_buf_size, DRIVER_NAME, &pdata->mem_start);
+	if (ret < 0) {
+		uninit_mmu_buffers(pbi);
+		mutex_unlock(&vvp9_mutex);
+		return ret;
+	}
+	pbi->buf_size = work_buf_size;
+
+#ifdef MULTI_INSTANCE_SUPPORT
+	pbi->buf_start = pdata->mem_start;
+#else
+#ifndef VP9_10B_MMU
+	pbi->mc_buf_spec.buf_end = pdata->mem_start + pbi->buf_size;
+#endif
+	for (i = 0; i < WORK_BUF_SPEC_NUM; i++)
+		amvvp9_workbuff_spec[i].start_adr = pdata->mem_start;
+#endif
+
+
 	if (debug) {
-		pr_info("===VP9 decoder mem resource 0x%lx -- 0x%lx\n",
-			   pdata->mem_start, pdata->mem_end + 1);
+		pr_info("===VP9 decoder mem resource 0x%lx size 0x%x\n",
+			   pdata->mem_start, pbi->buf_size);
 	}
 
 	if (pdata->sys_info)
@@ -6224,6 +6848,7 @@ static int amvdec_vp9_probe(struct platform_device *pdev)
 	if (vvp9_init(pbi) < 0) {
 		pr_info("\namvdec_vp9 init failed.\n");
 		vp9_local_uninit(pbi);
+		uninit_mmu_buffers(pbi);
 		mutex_unlock(&vvp9_mutex);
 		return -ENODEV;
 	}
@@ -6278,30 +6903,6 @@ static struct codec_profile_t amvdec_vp9_profile = {
 	.profile = ""
 };
 
-#ifdef MULTI_INSTANCE_SUPPORT
-static unsigned int start_decode_buf_level = 0x8000;
-#ifdef VP9_10B_MMU
-static u32 work_buf_size = 24 * 1024 * 1024;
-#else
-static u32 work_buf_size = 32 * 1024 * 1024;
-#endif
-
-static unsigned char decoder_id_used[MAX_DECODE_INSTANCE_NUM];
-static unsigned int get_free_decoder_id(struct vdec_s *vdec)
-{
-	/*stream base decoder always has id of 0*/
-	int i;
-	if (vdec_frame_based(vdec)) {
-		for (i = 1; i < decoder_id_used[i]; i++) {
-			if (!decoder_id_used[i]) {
-				decoder_id_used[i] = 1;
-				return i;
-			}
-		}
-	}
-	return 0;
-}
-
 static unsigned char get_data_check_sum
 	(struct VP9Decoder_s *pbi, int size)
 {
@@ -6319,6 +6920,16 @@ static void dump_data(struct VP9Decoder_s *pbi, int size)
 	int jj;
 	u8 *data = ((u8 *)pbi->chunk->block->start_virt) +
 		pbi->chunk->offset;
+	int padding_size = pbi->chunk->offset &
+		(VDEC_FIFO_ALIGN - 1);
+	vp9_print(pbi, 0, "padding: ");
+	for (jj = padding_size; jj > 0; jj--)
+		vp9_print_cont(pbi,
+			0,
+			"%02x ", *(data - jj));
+	vp9_print_cont(pbi, 0, "data adr %p\n",
+		data);
+
 	for (jj = 0; jj < size; jj++) {
 		if ((jj & 0xf) == 0)
 			vp9_print(pbi,
@@ -6341,14 +6952,28 @@ static void vp9_work(struct work_struct *work)
 {
 	struct VP9Decoder_s *pbi = container_of(work,
 		struct VP9Decoder_s, work);
-	struct VP9_Common_s *const cm = &pbi->common;
 	struct vdec_s *vdec = hw_to_vdec(pbi);
 	/* finished decoding one frame or error,
 	 * notify vdec core to switch context
 	 */
+	vp9_print(pbi, PRINT_FLAG_VDEC_DETAIL,
+		"%s dec_result %d %x %x %x\n",
+		__func__,
+		pbi->dec_result,
+		READ_VREG(HEVC_STREAM_LEVEL),
+		READ_VREG(HEVC_STREAM_WR_PTR),
+		READ_VREG(HEVC_STREAM_RD_PTR));
+
+	if (((pbi->dec_result == DEC_RESULT_GET_DATA) ||
+		(pbi->dec_result == DEC_RESULT_GET_DATA_RETRY))
+		&& (hw_to_vdec(pbi)->next_status !=
+		VDEC_STATUS_DISCONNECTED)) {
+		if (!vdec_has_more_input(vdec)) {
+			pbi->dec_result = DEC_RESULT_EOS;
+			vdec_schedule_work(&pbi->work);
+			return;
+		}
 
-	if ((pbi->dec_result == DEC_RESULT_GET_DATA) ||
-		(pbi->dec_result == DEC_RESULT_GET_DATA_RETRY)) {
 		if (pbi->dec_result == DEC_RESULT_GET_DATA) {
 			vp9_print(pbi, PRINT_FLAG_VDEC_STATUS,
 				"%s DEC_RESULT_GET_DATA %x %x %x\n",
@@ -6360,8 +6985,10 @@ static void vp9_work(struct work_struct *work)
 			vdec_clean_input(vdec);
 		}
 
-		if (!is_buffer_empty(cm)) {
+		if (get_free_buf_count(pbi) >=
+			run_ready_min_buf_num) {
 			int r;
+			int decode_size;
 			r = vdec_prepare_input(vdec, &pbi->chunk);
 			if (r < 0) {
 				pbi->dec_result = DEC_RESULT_GET_DATA_RETRY;
@@ -6370,7 +6997,7 @@ static void vp9_work(struct work_struct *work)
 					PRINT_FLAG_VDEC_DETAIL,
 					"amvdec_vh265: Insufficient data\n");
 
-				schedule_work(&pbi->work);
+				vdec_schedule_work(&pbi->work);
 				return;
 			}
 			pbi->dec_result = DEC_RESULT_NONE;
@@ -6383,39 +7010,87 @@ static void vp9_work(struct work_struct *work)
 
 			if (debug & PRINT_FLAG_VDEC_DATA)
 				dump_data(pbi, pbi->chunk->size);
-			WRITE_VREG(HEVC_DECODE_SIZE, r);
+
+			decode_size = pbi->chunk->size +
+				(pbi->chunk->offset & (VDEC_FIFO_ALIGN - 1));
+
+			WRITE_VREG(HEVC_DECODE_SIZE,
+				READ_VREG(HEVC_DECODE_SIZE) + decode_size);
 
 			vdec_enable_input(vdec);
 
 			WRITE_VREG(HEVC_DEC_STATUS_REG, HEVC_ACTION_DONE);
+
+			start_process_time(pbi);
+
 		} else{
 			pbi->dec_result = DEC_RESULT_GET_DATA_RETRY;
 
 			vp9_print(pbi, PRINT_FLAG_VDEC_DETAIL,
 				"amvdec_vh265: Insufficient data\n");
 
-			schedule_work(&pbi->work);
+			vdec_schedule_work(&pbi->work);
 		}
 		return;
 	} else if (pbi->dec_result == DEC_RESULT_DONE) {
 		/* if (!pbi->ctx_valid)
 			pbi->ctx_valid = 1; */
+		pbi->slice_idx++;
+		pbi->frame_count++;
+		pbi->process_state = PROC_STATE_INIT;
+		decode_frame_count[pbi->index] = pbi->frame_count;
+
+#ifdef VP9_10B_MMU
+		pbi->used_4k_num =
+			(READ_VREG(HEVC_SAO_MMU_STATUS) >> 16);
+#endif
 		vp9_print(pbi, PRINT_FLAG_VDEC_STATUS,
-			"%s dec_result %d %x %x %x\n",
+			"%s (===> %d) dec_result %d %x %x %x shiftbytes 0x%x decbytes 0x%x\n",
 			__func__,
+			pbi->frame_count,
 			pbi->dec_result,
 			READ_VREG(HEVC_STREAM_LEVEL),
 			READ_VREG(HEVC_STREAM_WR_PTR),
-			READ_VREG(HEVC_STREAM_RD_PTR));
+			READ_VREG(HEVC_STREAM_RD_PTR),
+			READ_VREG(HEVC_SHIFT_BYTE_COUNT),
+			READ_VREG(HEVC_SHIFT_BYTE_COUNT) -
+			pbi->start_shift_bytes
+			);
 		vdec_vframe_dirty(hw_to_vdec(pbi), pbi->chunk);
-	} else {
-		vp9_print(pbi, PRINT_FLAG_VDEC_DETAIL,
-			"%s dec_result %d %x %x %x\n",
-			__func__,
-			pbi->dec_result,
-			READ_VREG(HEVC_STREAM_LEVEL),
-			READ_VREG(HEVC_STREAM_WR_PTR),
-			READ_VREG(HEVC_STREAM_RD_PTR));
+	} else if (pbi->dec_result == DEC_RESULT_AGAIN) {
+		/*
+			stream base: stream buf empty or timeout
+			frame base: vdec_prepare_input fail
+		*/
+		if (!vdec_has_more_input(vdec)) {
+			pbi->dec_result = DEC_RESULT_EOS;
+			vdec_schedule_work(&pbi->work);
+			return;
+		}
+	} else if (pbi->dec_result == DEC_RESULT_EOS) {
+		vp9_print(pbi, PRINT_FLAG_VDEC_STATUS,
+			"%s: end of stream\n",
+			__func__);
+		pbi->eos = 1;
+		vp9_bufmgr_postproc(pbi);
+		vdec_vframe_dirty(hw_to_vdec(pbi), pbi->chunk);
+	} else if (pbi->dec_result == DEC_RESULT_FORCE_EXIT) {
+		vp9_print(pbi, PRINT_FLAG_VDEC_STATUS,
+			"%s: force exit\n",
+			__func__);
+		if (pbi->stat & STAT_VDEC_RUN) {
+			amhevc_stop();
+			pbi->stat &= ~STAT_VDEC_RUN;
+		}
+
+		if (pbi->stat & STAT_ISR_REG) {
+#ifdef MULTI_INSTANCE_SUPPORT
+			if (!pbi->m_ins_flag)
+#endif
+				WRITE_VREG(HEVC_ASSIST_MBOX1_MASK, 0);
+			vdec_free_irq(VDEC_IRQ_1, (void *)pbi);
+			pbi->stat &= ~STAT_ISR_REG;
+		}
 	}
 
 	/* mark itself has all HW resource released and input released */
@@ -6436,60 +7111,20 @@ static bool run_ready(struct vdec_s *vdec)
 {
 	struct VP9Decoder_s *pbi =
 		(struct VP9Decoder_s *)vdec->private;
-	struct VP9_Common_s *const cm = &pbi->common;
-
+	bool ret = 0;
 	vp9_print(pbi,
 		PRINT_FLAG_VDEC_DETAIL, "%s\r\n", __func__);
+	if (pbi->eos)
+		return ret;
 
-	if ((!vdec_frame_based(vdec)) && (start_decode_buf_level > 0)) {
-		u32 rp, wp;
-		u32 level;
-
-		rp = READ_MPEG_REG(PARSER_VIDEO_RP);
-		wp = READ_MPEG_REG(PARSER_VIDEO_WP);
-
-		if (wp < rp)
-			level = vdec->input.size + wp - rp;
-		else
-			level = wp - rp;
-
-		if (level < start_decode_buf_level) {
-			vp9_print(pbi, 0,
-				"level %d not run_ready\n", level);
-			return false;
-		}
-	} else if (vdec_frame_based(vdec)) {
-		if (!vdec_input_next_input_chunk(&vdec->input))
-			return false;
-	}
-
-	return !is_buffer_empty(cm);
-}
-
-static void reset_dec_hw(struct vdec_s *vdec)
-{
-	if (input_frame_based(vdec))
-		WRITE_VREG(HEVC_STREAM_CONTROL, 0);
-
-		/*
-	 * 2: assist
-	 * 3: parser
-	 * 4: parser_state
-	 * 8: dblk
-	 * 11:mcpu
-	 * 12:ccpu
-	 * 13:ddr
-	 * 14:iqit
-	 * 15:ipp
-	 * 17:qdct
-	 * 18:mpred
-	 * 19:sao
-	 * 24:hevc_afifo
-	 */
-	WRITE_VREG(DOS_SW_RESET3,
-		(1<<3)|(1<<4)|(1<<8)|(1<<11)|(1<<12)|(1<<14)|(1<<15)|
-		(1<<17)|(1<<18)|(1<<19));
-	WRITE_VREG(DOS_SW_RESET3, 0);
+	if (get_free_buf_count(pbi) >=
+		run_ready_min_buf_num)
+		ret = 1;
+	if (ret)
+		not_run_ready[pbi->index] = 0;
+	else
+		not_run_ready[pbi->index]++;
+	return ret;
 }
 
 static void run(struct vdec_s *vdec,
@@ -6503,32 +7138,56 @@ static void run(struct vdec_s *vdec,
 	if (IS_ERR_OR_NULL(buf))
 		return;
 
+	run_count[pbi->index]++;
 	pbi->vdec_cb_arg = arg;
 	pbi->vdec_cb = callback;
 	/* pbi->chunk = vdec_prepare_input(vdec); */
-	reset_dec_hw(vdec);
+	hevc_reset_core(vdec);
 
 	r = vdec_prepare_input(vdec, &pbi->chunk);
 	if (r < 0) {
+		input_empty[pbi->index]++;
+
 		pbi->dec_result = DEC_RESULT_AGAIN;
 
 		vp9_print(pbi, PRINT_FLAG_VDEC_DETAIL,
 			"ammvdec_vh265: Insufficient data\n");
 
-		schedule_work(&pbi->work);
+		vdec_schedule_work(&pbi->work);
 		return;
 	}
+	input_empty[pbi->index] = 0;
 	pbi->dec_result = DEC_RESULT_NONE;
+	pbi->start_shift_bytes = READ_VREG(HEVC_SHIFT_BYTE_COUNT);
 
-	vp9_print(pbi, PRINT_FLAG_VDEC_STATUS,
-		"%s: size 0x%x sum 0x%x (%x %x %x)\n",
-		__func__, r,
-		(vdec_frame_based(vdec) &&
-		(debug & PRINT_FLAG_VDEC_STATUS)) ?
-		get_data_check_sum(pbi, r) : 0,
-	READ_VREG(HEVC_STREAM_LEVEL),
-	READ_VREG(HEVC_STREAM_WR_PTR),
-	READ_VREG(HEVC_STREAM_RD_PTR));
+	if (debug & PRINT_FLAG_VDEC_STATUS) {
+		int ii;
+		vp9_print(pbi, 0,
+			"%s (%d): size 0x%x (0x%x 0x%x) sum 0x%x (%x %x %x %x %x) bytes 0x%x",
+			__func__,
+			pbi->frame_count, r,
+			pbi->chunk ? pbi->chunk->size : 0,
+			pbi->chunk ? pbi->chunk->offset : 0,
+			(vdec_frame_based(vdec) &&
+			(debug & PRINT_FLAG_VDEC_STATUS)) ?
+			get_data_check_sum(pbi, r) : 0,
+		READ_VREG(HEVC_STREAM_START_ADDR),
+		READ_VREG(HEVC_STREAM_END_ADDR),
+		READ_VREG(HEVC_STREAM_LEVEL),
+		READ_VREG(HEVC_STREAM_WR_PTR),
+		READ_VREG(HEVC_STREAM_RD_PTR),
+		pbi->start_shift_bytes);
+		if (vdec_frame_based(vdec)) {
+			u8 *data = ((u8 *)pbi->chunk->block->start_virt) +
+				pbi->chunk->offset;
+			vp9_print_cont(pbi, 0, "data adr %p:",
+				data);
+			for (ii = 0; ii < 8; ii++)
+				vp9_print_cont(pbi, 0, "%02x ",
+					data[ii]);
+		}
+		vp9_print_cont(pbi, 0, "\r\n");
+	}
 
 	size = get_firmware_data(VIDEO_DEC_VP9_MMU, buf);
 	if (size < 0) {
@@ -6540,13 +7199,15 @@ static void run(struct vdec_s *vdec,
 	if (amhevc_loadmc_ex(VFORMAT_VP9, NULL, buf) < 0) {
 		amhevc_disable();
 		vfree(buf);
+		vp9_print(pbi, 0,
+			"%s: Error amvdec_loadmc fail\n", __func__);
 		return;
 	}
 
 	vfree(buf);
 
 	if (vp9_hw_ctx_restore(pbi) < 0) {
-		schedule_work(&pbi->work);
+		vdec_schedule_work(&pbi->work);
 		return;
 	}
 
@@ -6559,12 +7220,14 @@ static void run(struct vdec_s *vdec,
 			dump_data(pbi, pbi->chunk->size);
 
 		WRITE_VREG(HEVC_SHIFT_BYTE_COUNT, 0);
+		r = pbi->chunk->size +
+			(pbi->chunk->offset & (VDEC_FIFO_ALIGN - 1));
 	}
 	WRITE_VREG(HEVC_DECODE_SIZE, r);
 	WRITE_VREG(HEVC_DECODE_COUNT, pbi->slice_idx);
 	pbi->init_flag = 1;
 
-	vp9_print(pbi, PRINT_FLAG_VDEC_STATUS,
+	vp9_print(pbi, PRINT_FLAG_VDEC_DETAIL,
 		"%s: start hevc (%x %x %x)\n",
 		__func__,
 		READ_VREG(HEVC_DEC_STATUS_REG),
@@ -6572,7 +7235,9 @@ static void run(struct vdec_s *vdec,
 		READ_VREG(HEVC_MPSR));
 
 	amhevc_start();
+	pbi->stat |= STAT_VDEC_RUN;
 
+	start_process_time(pbi);
 }
 
 static void reset(struct vdec_s *vdec)
@@ -6600,10 +7265,144 @@ static irqreturn_t vp9_threaded_irq_cb(struct vdec_s *vdec)
 	return vvp9_isr_thread_fn(0, pbi);
 }
 
+static void vp9_dump_state(struct vdec_s *vdec)
+{
+	struct VP9Decoder_s *pbi =
+		(struct VP9Decoder_s *)vdec->private;
+	struct VP9_Common_s *const cm = &pbi->common;
+	int i;
+	vp9_print(pbi, 0, "====== %s\n", __func__);
+
+	vp9_print(pbi, 0,
+		"width/height (%d/%d), used_buf_num %d\n",
+		cm->width,
+		cm->height,
+		pbi->used_buf_num
+		);
+
+	vp9_print(pbi, 0,
+		"is_framebase(%d), eos %d, dec_result 0x%x dec_frm %d disp_frm %d run %d not_run_ready %d input_empty %d\n",
+		input_frame_based(vdec),
+		pbi->eos,
+		pbi->dec_result,
+		decode_frame_count[pbi->index],
+		display_frame_count[pbi->index],
+		run_count[pbi->index],
+		not_run_ready[pbi->index],
+		input_empty[pbi->index]
+		);
+
+	if (vf_get_receiver(vdec->vf_provider_name)) {
+		enum receviver_start_e state =
+		vf_notify_receiver(vdec->vf_provider_name,
+			VFRAME_EVENT_PROVIDER_QUREY_STATE,
+			NULL);
+		vp9_print(pbi, 0,
+			"\nreceiver(%s) state %d\n",
+			vdec->vf_provider_name,
+			state);
+	}
+
+	vp9_print(pbi, 0,
+	"%s, newq(%d/%d), dispq(%d/%d), vf prepare/get/put (%d/%d/%d), free_buf_count %d (min %d for run_ready)\n",
+	__func__,
+	kfifo_len(&pbi->newframe_q),
+	VF_POOL_SIZE,
+	kfifo_len(&pbi->display_q),
+	VF_POOL_SIZE,
+	pbi->vf_pre_count,
+	pbi->vf_get_count,
+	pbi->vf_put_count,
+	get_free_buf_count(pbi),
+	run_ready_min_buf_num
+	);
+
+	dump_pic_list(pbi);
+
+	for (i = 0; i < MAX_BUF_NUM; i++) {
+		vp9_print(pbi, 0,
+			"mv_Buf(%d) start_adr 0x%x size 0x%x used %d\n",
+			i,
+			pbi->m_mv_BUF[i].start_adr,
+			pbi->m_mv_BUF[i].size,
+			pbi->m_mv_BUF[i].used_flag);
+	}
+
+	vp9_print(pbi, 0,
+		"HEVC_DEC_STATUS_REG=0x%x\n",
+		READ_VREG(HEVC_DEC_STATUS_REG));
+	vp9_print(pbi, 0,
+		"HEVC_MPC_E=0x%x\n",
+		READ_VREG(HEVC_MPC_E));
+	vp9_print(pbi, 0,
+		"DECODE_MODE=0x%x\n",
+		READ_VREG(DECODE_MODE));
+	vp9_print(pbi, 0,
+		"NAL_SEARCH_CTL=0x%x\n",
+		READ_VREG(NAL_SEARCH_CTL));
+	vp9_print(pbi, 0,
+		"HEVC_PARSER_LCU_START=0x%x\n",
+		READ_VREG(HEVC_PARSER_LCU_START));
+	vp9_print(pbi, 0,
+		"HEVC_DECODE_SIZE=0x%x\n",
+		READ_VREG(HEVC_DECODE_SIZE));
+	vp9_print(pbi, 0,
+		"HEVC_SHIFT_BYTE_COUNT=0x%x\n",
+		READ_VREG(HEVC_SHIFT_BYTE_COUNT));
+	vp9_print(pbi, 0,
+		"HEVC_STREAM_START_ADDR=0x%x\n",
+		READ_VREG(HEVC_STREAM_START_ADDR));
+	vp9_print(pbi, 0,
+		"HEVC_STREAM_END_ADDR=0x%x\n",
+		READ_VREG(HEVC_STREAM_END_ADDR));
+	vp9_print(pbi, 0,
+		"HEVC_STREAM_LEVEL=0x%x\n",
+		READ_VREG(HEVC_STREAM_LEVEL));
+	vp9_print(pbi, 0,
+		"HEVC_STREAM_WR_PTR=0x%x\n",
+		READ_VREG(HEVC_STREAM_WR_PTR));
+	vp9_print(pbi, 0,
+		"HEVC_STREAM_RD_PTR=0x%x\n",
+		READ_VREG(HEVC_STREAM_RD_PTR));
+	vp9_print(pbi, 0,
+		"PARSER_VIDEO_RP=0x%x\n",
+		READ_PARSER_REG(PARSER_VIDEO_RP));
+	vp9_print(pbi, 0,
+		"PARSER_VIDEO_WP=0x%x\n",
+		READ_PARSER_REG(PARSER_VIDEO_WP));
+
+	if (input_frame_based(vdec) &&
+		(debug & PRINT_FLAG_VDEC_DATA)
+		) {
+		int jj;
+		if (pbi->chunk && pbi->chunk->block &&
+			pbi->chunk->size > 0) {
+			u8 *data =
+			((u8 *)pbi->chunk->block->start_virt) +
+				pbi->chunk->offset;
+			vp9_print(pbi, 0,
+				"frame data size 0x%x\n",
+				pbi->chunk->size);
+			for (jj = 0; jj < pbi->chunk->size; jj++) {
+				if ((jj & 0xf) == 0)
+					vp9_print(pbi, 0,
+						"%06x:", jj);
+				vp9_print_cont(pbi, 0,
+					"%02x ", data[jj]);
+				if (((jj + 1) & 0xf) == 0)
+					vp9_print_cont(pbi, 0,
+						"\n");
+			}
+		}
+	}
+
+}
 
 static int ammvdec_vp9_probe(struct platform_device *pdev)
 {
 	struct vdec_s *pdata = *(struct vdec_s **)pdev->dev.platform_data;
+	int ret;
+	int config_val;
 
 	struct BUF_s BUF[MAX_BUF_NUM];
 	struct VP9Decoder_s *pbi = NULL;
@@ -6612,8 +7411,10 @@ static int ammvdec_vp9_probe(struct platform_device *pdev)
 		pr_info("\nammvdec_vp9 memory resource undefined.\n");
 		return -EFAULT;
 	}
-	pbi = (struct VP9Decoder_s *)devm_kzalloc(&pdev->dev,
-		sizeof(struct VP9Decoder_s), GFP_KERNEL);
+	/*pbi = (struct VP9Decoder_s *)devm_kzalloc(&pdev->dev,
+		sizeof(struct VP9Decoder_s), GFP_KERNEL);*/
+	pbi = vmalloc(sizeof(struct VP9Decoder_s));
+	memset(pbi, 0, sizeof(struct VP9Decoder_s));
 	if (pbi == NULL) {
 		pr_info("\nammvdec_vp9 device data allocation failed\n");
 		return -ENOMEM;
@@ -6626,15 +7427,15 @@ static int ammvdec_vp9_probe(struct platform_device *pdev)
 	pdata->reset = reset;
 	pdata->irq_handler = vp9_irq_cb;
 	pdata->threaded_irq_handler = vp9_threaded_irq_cb;
+	pdata->dump_state = vp9_dump_state;
 
-	pdata->id = pdev->id;
 
 
 	memcpy(&BUF[0], &pbi->m_BUF[0], sizeof(struct BUF_s) * MAX_BUF_NUM);
 	memset(pbi, 0, sizeof(VP9Decoder));
 	memcpy(&pbi->m_BUF[0], &BUF[0], sizeof(struct BUF_s) * MAX_BUF_NUM);
 
-	pbi->index = get_free_decoder_id(pdata);
+	pbi->index = pdev->id;
 
 	if (pdata->use_vfm_path)
 		snprintf(pdata->vf_provider_name, VDEC_PROVIDER_NAME_SIZE,
@@ -6650,36 +7451,46 @@ static int ammvdec_vp9_probe(struct platform_device *pdev)
 	platform_set_drvdata(pdev, pdata);
 
 	pbi->platform_dev = pdev;
+#if 1
+	if ((debug & IGNORE_PARAM_FROM_CONFIG) == 0 &&
+			pdata->config && pdata->config_len) {
+#ifdef MULTI_INSTANCE_SUPPORT
+		/*use ptr config for doubel_write_mode, etc*/
+		vp9_print(pbi, 0, "pdata->config=%s\n", pdata->config);
+		if (get_config_int(pdata->config, "vp9_double_write_mode",
+				&config_val) == 0)
+			pbi->double_write_mode = config_val;
+		else
+			pbi->double_write_mode = double_write_mode;
+#endif
+	} else
+#endif
+	{
+		/*pbi->vvp9_amstream_dec_info.width = 0;
+		pbi->vvp9_amstream_dec_info.height = 0;
+		pbi->vvp9_amstream_dec_info.rate = 30;*/
+		pbi->double_write_mode = double_write_mode;
+	}
 #if 0
 	pbi->buf_start = pdata->mem_start;
 	pbi->buf_size = pdata->mem_end - pdata->mem_start + 1;
 #else
 	if (amvdec_vp9_mmu_init(pbi) < 0) {
 		pr_err("vp9 alloc bmmu box failed!!\n");
-		devm_kfree(&pdev->dev, (void *)pbi);
+		/* devm_kfree(&pdev->dev, (void *)pbi); */
+		vfree((void *)pbi);
 		return -1;
 	}
 
 	pbi->cma_alloc_count = PAGE_ALIGN(work_buf_size) / PAGE_SIZE;
-	if (!decoder_bmmu_box_alloc_idx_wait(
-			pbi->bmmu_box,
-			WORK_SPACE_BUF_ID,
-			pbi->cma_alloc_count * PAGE_SIZE,
-			-1,
-			-1,
-			BMMU_ALLOC_FLAGS_WAITCLEAR
-			))	{
-		pbi->cma_alloc_addr = decoder_bmmu_box_get_phy_addr(
-					pbi->bmmu_box,
-					WORK_SPACE_BUF_ID);
-	} else {
-		vp9_print(pbi, 0,
-			"codec_mm alloc failed, request buf size 0x%lx\n",
-				pbi->cma_alloc_count * PAGE_SIZE);
-		pbi->cma_alloc_count = 0;
+	ret = decoder_bmmu_box_alloc_buf_phy(pbi->bmmu_box, WORK_SPACE_BUF_ID,
+			pbi->cma_alloc_count * PAGE_SIZE, DRIVER_NAME,
+			&pbi->cma_alloc_addr);
+	if (ret < 0) {
 		uninit_mmu_buffers(pbi);
-		devm_kfree(&pdev->dev, (void *)pbi);
-		return -ENOMEM;
+		/* devm_kfree(&pdev->dev, (void *)pbi); */
+		vfree((void *)pbi);
+		return ret;
 	}
 	pbi->buf_start = pbi->cma_alloc_addr;
 	pbi->buf_size = work_buf_size;
@@ -6692,14 +7503,15 @@ static int ammvdec_vp9_probe(struct platform_device *pdev)
 	if (pdata == NULL) {
 		pr_info("\namvdec_vp9 memory resource undefined.\n");
 		uninit_mmu_buffers(pbi);
-		devm_kfree(&pdev->dev, (void *)pbi);
+		/* devm_kfree(&pdev->dev, (void *)pbi); */
+		vfree((void *)pbi);
 		return -EFAULT;
 	}
 
 	if (debug) {
-		pr_info("===VP9 decoder mem resource 0x%lx -- 0x%lx\n",
+		pr_info("===VP9 decoder mem resource 0x%lx size 0x%x\n",
 			   pbi->buf_start,
-			   pbi->buf_start + pbi->buf_size);
+			   pbi->buf_size);
 	}
 
 	if (pdata->sys_info)
@@ -6716,9 +7528,15 @@ static int ammvdec_vp9_probe(struct platform_device *pdev)
 		pr_info("\namvdec_vp9 init failed.\n");
 		vp9_local_uninit(pbi);
 		uninit_mmu_buffers(pbi);
-		devm_kfree(&pdev->dev, (void *)pbi);
+		/* devm_kfree(&pdev->dev, (void *)pbi); */
+		vfree((void *)pbi);
 		return -ENODEV;
 	}
+
+	hevc_source_changed(VFORMAT_VP9,
+			4096, 2048, 60);
+
+	vdec_set_prepare_level(pdata, start_decode_buf_level);
 	return 0;
 }
 
@@ -6738,7 +7556,8 @@ static int ammvdec_vp9_remove(struct platform_device *pdev)
 	pr_info("pts missed %ld, pts hit %ld, duration %d\n",
 		   pbi->pts_missed, pbi->pts_hit, pbi->frame_dur);
 #endif
-	devm_kfree(&pdev->dev, (void *)pbi);
+	/* devm_kfree(&pdev->dev, (void *)pbi); */
+	vfree((void *)pbi);
 	return 0;
 }
 
@@ -6754,9 +7573,61 @@ static struct platform_driver ammvdec_vp9_driver = {
 	}
 };
 #endif
+static struct mconfig vp9_configs[] = {
+	MC_PU32("bit_depth_luma", &bit_depth_luma),
+	MC_PU32("bit_depth_chroma", &bit_depth_chroma),
+	MC_PU32("frame_width", &frame_width),
+	MC_PU32("frame_height", &frame_height),
+	MC_PU32("debug", &debug),
+	MC_PU32("radr", &radr),
+	MC_PU32("rval", &rval),
+	MC_PU32("pop_shorts", &pop_shorts),
+	MC_PU32("dbg_cmd", &dbg_cmd),
+	MC_PU32("dbg_skip_decode_index", &dbg_skip_decode_index),
+	MC_PU32("endian", &endian),
+	MC_PU32("step", &step),
+	MC_PU32("udebug_flag", &udebug_flag),
+	MC_PU32("decode_pic_begin", &decode_pic_begin),
+	MC_PU32("slice_parse_begin", &slice_parse_begin),
+	MC_PU32("i_only_flag", &i_only_flag),
+	MC_PU32("error_handle_policy", &error_handle_policy),
+	MC_PU32("buf_alloc_width", &buf_alloc_width),
+	MC_PU32("buf_alloc_height", &buf_alloc_height),
+	MC_PU32("buf_alloc_depth", &buf_alloc_depth),
+	MC_PU32("buf_alloc_size", &buf_alloc_size),
+	MC_PU32("buffer_mode", &buffer_mode),
+	MC_PU32("buffer_mode_dbg", &buffer_mode_dbg),
+	MC_PU32("max_buf_num", &max_buf_num),
+	MC_PU32("dynamic_buf_num_margin", &dynamic_buf_num_margin),
+	MC_PU32("mem_map_mode", &mem_map_mode),
+	MC_PU32("double_write_mode", &double_write_mode),
+	MC_PU32("enable_mem_saving", &enable_mem_saving),
+	MC_PU32("force_w_h", &force_w_h),
+	MC_PU32("force_fps", &force_fps),
+	MC_PU32("max_decoding_time", &max_decoding_time),
+	MC_PU32("on_no_keyframe_skiped", &on_no_keyframe_skiped),
+	MC_PU32("start_decode_buf_level", &start_decode_buf_level),
+	MC_PU32("decode_timeout_val", &decode_timeout_val),
+};
+static struct mconfig_node vp9_node;
 
 static int __init amvdec_vp9_driver_init_module(void)
 {
+
+#ifdef VP9_10B_MMU
+
+	struct BuffInfo_s *p_buf_info;
+#ifdef SUPPORT_4K2K
+	p_buf_info = &amvvp9_workbuff_spec[1];
+#else
+	p_buf_info = &amvvp9_workbuff_spec[0];
+#endif
+	init_buff_spec(NULL, p_buf_info);
+	work_buf_size =
+		(p_buf_info->end_adr - p_buf_info->start_adr
+		 + 0xffff) & (~0xffff);
+
+#endif
 	pr_debug("amvdec_vp9 module init\n");
 	error_handle_policy = 0;
 
@@ -6764,8 +7635,7 @@ static int __init amvdec_vp9_driver_init_module(void)
 	dbg_nal_skip_flag = 0;
 	dbg_nal_skip_count = 0;
 #endif
-	decode_stop_pos = 0;
-	decode_stop_pos_pre = 0;
+	udebug_flag = 0;
 	decode_pic_begin = 0;
 	slice_parse_begin = 0;
 	step = 0;
@@ -6788,6 +7658,8 @@ static int __init amvdec_vp9_driver_init_module(void)
 	}
 
 	vcodec_profile_register(&amvdec_vp9_profile);
+	INIT_REG_NODE_CONFIGS("media.decoder", &vp9_node,
+		"vp9", vp9_configs, CONFIG_FOR_RW);
 
 	return 0;
 }
@@ -6802,12 +7674,6 @@ static void __exit amvdec_vp9_driver_remove_module(void)
 }
 
 /****************************************/
-/*
-module_param(stat, uint, 0664);
-MODULE_PARM_DESC(stat, "\n amvdec_vp9 stat\n");
-*/
-module_param(use_cma, uint, 0664);
-MODULE_PARM_DESC(use_cma, "\n amvdec_vp9 use_cma\n");
 
 module_param(bit_depth_luma, uint, 0664);
 MODULE_PARM_DESC(bit_depth_luma, "\n amvdec_vp9 bit_depth_luma\n");
@@ -6825,29 +7691,26 @@ module_param(debug, uint, 0664);
 MODULE_PARM_DESC(debug, "\n amvdec_vp9 debug\n");
 
 module_param(radr, uint, 0664);
-MODULE_PARM_DESC(radr, "\nradr\n");
+MODULE_PARM_DESC(radr, "\n radr\n");
 
 module_param(rval, uint, 0664);
-MODULE_PARM_DESC(rval, "\nrval\n");
+MODULE_PARM_DESC(rval, "\n rval\n");
 
 module_param(pop_shorts, uint, 0664);
-MODULE_PARM_DESC(pop_shorts, "\nrval\n");
+MODULE_PARM_DESC(pop_shorts, "\n rval\n");
 
 module_param(dbg_cmd, uint, 0664);
-MODULE_PARM_DESC(dbg_cmd, "\ndbg_cmd\n");
+MODULE_PARM_DESC(dbg_cmd, "\n dbg_cmd\n");
 
 module_param(dbg_skip_decode_index, uint, 0664);
-MODULE_PARM_DESC(dbg_skip_decode_index, "\ndbg_skip_decode_index\n");
+MODULE_PARM_DESC(dbg_skip_decode_index, "\n dbg_skip_decode_index\n");
 
 module_param(endian, uint, 0664);
-MODULE_PARM_DESC(endian, "\nrval\n");
+MODULE_PARM_DESC(endian, "\n rval\n");
 
 module_param(step, uint, 0664);
 MODULE_PARM_DESC(step, "\n amvdec_vp9 step\n");
 
-module_param(decode_stop_pos, uint, 0664);
-MODULE_PARM_DESC(decode_stop_pos, "\n amvdec_vp9 decode_stop_pos\n");
-
 module_param(decode_pic_begin, uint, 0664);
 MODULE_PARM_DESC(decode_pic_begin, "\n amvdec_vp9 decode_pic_begin\n");
 
@@ -6883,6 +7746,13 @@ MODULE_PARM_DESC(max_buf_num, "\n max_buf_num\n");
 
 module_param(dynamic_buf_num_margin, uint, 0664);
 MODULE_PARM_DESC(dynamic_buf_num_margin, "\n dynamic_buf_num_margin\n");
+
+module_param(mv_buf_margin, uint, 0664);
+MODULE_PARM_DESC(mv_buf_margin, "\n mv_buf_margin\n");
+
+module_param(run_ready_min_buf_num, uint, 0664);
+MODULE_PARM_DESC(run_ready_min_buf_num, "\n run_ready_min_buf_num\n");
+
 /**/
 
 module_param(mem_map_mode, uint, 0664);
@@ -6909,11 +7779,45 @@ module_param(on_no_keyframe_skiped, uint, 0664);
 MODULE_PARM_DESC(on_no_keyframe_skiped, "\n on_no_keyframe_skiped\n");
 
 #ifdef MULTI_INSTANCE_SUPPORT
-module_param(start_decode_buf_level, uint, 0664);
+module_param(start_decode_buf_level, int, 0664);
 MODULE_PARM_DESC(start_decode_buf_level,
-		"\n ammvdec_h264 start_decode_buf_level\n");
+		"\n vp9 start_decode_buf_level\n");
+
+module_param(decode_timeout_val, uint, 0664);
+MODULE_PARM_DESC(decode_timeout_val,
+	"\n vp9 decode_timeout_val\n");
+
+module_param_array(decode_frame_count, uint,
+	&max_decode_instance_num, 0664);
+
+module_param_array(display_frame_count, uint,
+	&max_decode_instance_num, 0664);
+
+module_param_array(max_process_time, uint,
+	&max_decode_instance_num, 0664);
+
+module_param_array(run_count, uint,
+	&max_decode_instance_num, 0664);
+
+module_param_array(input_empty, uint,
+	&max_decode_instance_num, 0664);
+
+module_param_array(not_run_ready, uint,
+	&max_decode_instance_num, 0664);
 #endif
 
+module_param(udebug_flag, uint, 0664);
+MODULE_PARM_DESC(udebug_flag, "\n amvdec_h265 udebug_flag\n");
+
+module_param(udebug_pause_pos, uint, 0664);
+MODULE_PARM_DESC(udebug_pause_pos, "\n udebug_pause_pos\n");
+
+module_param(udebug_pause_val, uint, 0664);
+MODULE_PARM_DESC(udebug_pause_val, "\n udebug_pause_val\n");
+
+module_param(udebug_pause_decode_idx, uint, 0664);
+MODULE_PARM_DESC(udebug_pause_decode_idx, "\n udebug_pause_decode_idx\n");
+
 module_init(amvdec_vp9_driver_init_module);
 module_exit(amvdec_vp9_driver_remove_module);
 
diff --git a/drivers/frame_provider/decoder/vp9/vvp9.h b/drivers/frame_provider/decoder/vp9/vvp9.h
index 4cf3254..523b983 100644
--- a/drivers/frame_provider/decoder/vp9/vvp9.h
+++ b/drivers/frame_provider/decoder/vp9/vvp9.h
@@ -17,9 +17,7 @@
 
 #ifndef VVP9_H
 #define VVP9_H
-#ifndef CONFIG_MULTI_DEC
 #define VP9_10B_MMU
-#endif
 void adapt_coef_probs(int pic_count, int prev_kf, int cur_kf, int pre_fc,
 unsigned int *prev_prob, unsigned int *cur_prob, unsigned int *count);
 #endif
diff --git a/drivers/stream_input/amports/adec.c b/drivers/stream_input/amports/adec.c
index 220c888..2213e57 100644
--- a/drivers/stream_input/amports/adec.c
+++ b/drivers/stream_input/amports/adec.c
@@ -21,14 +21,13 @@
 #include <linux/platform_device.h>
 #include <linux/slab.h>
 #include <linux/uio_driver.h>
-
 #include <linux/amlogic/media/utils/aformat.h>
 #include <linux/amlogic/media/frame_sync/ptsserv.h>
-
 #include <linux/amlogic/media/registers/register.h>
-
+#include <linux/amlogic/media/codec_mm/configs.h>
 #include "../parser/streambuf.h"
 #include <linux/module.h>
+#include <linux/of.h>
 #include "amports_priv.h"
 
 #define INFO_VALID ((astream_dev) && (astream_dev->format))
@@ -39,6 +38,7 @@ struct astream_device_s {
 	s32 channum;
 	s32 samplerate;
 	s32 datawidth;
+	int offset;
 
 	struct device dev;
 };
@@ -67,7 +67,15 @@ static char *astream_format[] = {
 	"amadec_ape",
 	"amadec_eac3",
 	"amadec_pcm_widi",
-	"amadec_wmavoi"
+	"amadec_dra",
+	"amadec_sipr",
+	"amadec_truehd",
+	"amadec_mpeg1",
+	"amadec_mpeg2",
+	"amadec_wmavoi",
+	"amadec_wmalossless",
+	"amadec_pcm_s24le",
+	"adec_max"
 };
 
 static const char *na_string = "NA";
@@ -125,12 +133,19 @@ static ssize_t pts_show(struct class *class, struct class_attribute *attr,
 		return sprintf(buf, "%s\n", na_string);
 }
 
+static ssize_t addr_offset_show(struct class *class,
+				struct class_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", astream_dev->offset);
+}
+
 static struct class_attribute astream_class_attrs[] = {
 	__ATTR_RO(format),
 	__ATTR_RO(samplerate),
 	__ATTR_RO(channum),
 	__ATTR_RO(datawidth),
 	__ATTR_RO(pts),
+	__ATTR_RO(addr_offset),
 	__ATTR_NULL
 };
 
@@ -142,7 +157,7 @@ static struct class astream_class = {
 #if 1
 #define IO_CBUS_PHY_BASE 0xc1100000
 #define CBUS_REG_OFFSET(reg) ((reg) << 2)
-#define IO_SECBUS_PHY_BASE		0xda000000
+#define IO_SECBUS_PHY_BASE 0xda000000
 
 static struct uio_info astream_uio_info = {
 	.name = "astream_uio",
@@ -228,9 +243,61 @@ s32 adec_release(enum aformat_e vf)
 	return 0;
 }
 
+int amstream_adec_show_fun(const char *trigger, int id, char *sbuf, int size)
+{
+	int ret = -1;
+	void *buf, *getbuf = NULL;
+	if (size < PAGE_SIZE) {
+		void *getbuf = (void *)__get_free_page(GFP_KERNEL);
+		if (!getbuf)
+			return -ENOMEM;
+		buf = getbuf;
+	} else {
+		buf = sbuf;
+	}
+	switch (trigger[0]) {
+	case 'f':
+		ret =  format_show(NULL, NULL, buf);
+		break;
+	case 's':
+		ret =  samplerate_show(NULL, NULL, buf);
+		break;
+	case 'c':
+		ret =  channum_show(NULL, NULL, buf);
+		break;
+	case 'd':
+		ret =  datawidth_show(NULL, NULL, buf);
+		break;
+	case 'p':
+		ret =  pts_show(NULL, NULL, buf);
+		break;
+	default:
+		ret = -1;
+	}
+	if (ret > 0 && getbuf != NULL) {
+		int ret = min_t(int, ret, size);
+		strncpy(sbuf, buf, ret);
+	}
+	if (getbuf != NULL)
+		free_page((unsigned long)getbuf);
+	return ret;
+}
+
+static struct mconfig adec_configs[] = {
+	MC_FUN("format", &amstream_adec_show_fun, NULL),
+	MC_FUN("samplerate", &amstream_adec_show_fun, NULL),
+	MC_FUN("channum", &amstream_adec_show_fun, NULL),
+	MC_FUN("datawidth", &amstream_adec_show_fun, NULL),
+	MC_FUN("pts", &amstream_adec_show_fun, NULL),
+};
+static struct mconfig_node adec_node;
+
+
 s32 astream_dev_register(void)
 {
 	s32 r;
+	struct device_node *node;
+	unsigned int cbus_base = 0xffd00000;
 
 	r = class_register(&astream_class);
 	if (r) {
@@ -241,13 +308,14 @@ s32 astream_dev_register(void)
 	astream_dev = kzalloc(sizeof(struct astream_device_s), GFP_KERNEL);
 
 	if (!astream_dev) {
+		pr_info("astream device create fail.\n");
 		r = -ENOMEM;
 		goto err_3;
 	}
 
 	astream_dev->dev.class = &astream_class;
 	astream_dev->dev.release = astream_release;
-
+	astream_dev->offset = 0;
 	dev_set_name(&astream_dev->dev, "astream-dev");
 
 	dev_set_drvdata(&astream_dev->dev, astream_dev);
@@ -258,6 +326,31 @@ s32 astream_dev_register(void)
 		goto err_2;
 	}
 
+	if (MESON_CPU_MAJOR_ID_TXL < get_cpu_type()) {
+		node = of_find_node_by_path("/codec_io/io_cbus_base");
+		if (!node) {
+			pr_info("No io_cbus_base node found.");
+			goto err_1;
+		}
+
+		r = of_property_read_u32_index(node, "reg", 1, &cbus_base);
+		if (r) {
+			pr_info("No find node.\n");
+			goto err_1;
+		}
+
+		/*need to offset -0x100 in txlx.*/
+		astream_dev->offset = -0x100;
+
+		astream_uio_info.mem[0].addr =
+			(cbus_base + CBUS_REG_OFFSET(AIU_AIFIFO_CTRL +
+			astream_dev->offset)) & (PAGE_MASK);
+
+		astream_uio_info.mem[3].addr =
+			(cbus_base + CBUS_REG_OFFSET(ASSIST_HW_REV +
+			0x100)) & (PAGE_MASK);
+	}
+
 #if 1
 	if (uio_register_device(&astream_dev->dev, &astream_uio_info)) {
 		pr_info("astream UIO device register fail.\n");
@@ -265,7 +358,8 @@ s32 astream_dev_register(void)
 		goto err_1;
 	}
 #endif
-
+	INIT_REG_NODE_CONFIGS("media", &adec_node,
+		"adec", adec_configs, CONFIG_FOR_R);
 	return 0;
 
 err_1:
diff --git a/drivers/stream_input/amports/amports_priv.h b/drivers/stream_input/amports/amports_priv.h
index 4b6f96e..7ee7859 100644
--- a/drivers/stream_input/amports/amports_priv.h
+++ b/drivers/stream_input/amports/amports_priv.h
@@ -31,8 +31,6 @@ struct port_priv_s {
 
 struct stream_buf_s *get_buf_by_type(u32 type);
 
-extern void amvenc_dos_top_reg_fix(void);
-
 /*video.c provide*/
 extern u32 trickmode_i;
 struct amvideocap_req;
@@ -47,10 +45,9 @@ int amstream_request_firmware_from_sys(const char *file_name,
 void set_vsync_pts_inc_mode(int inc);
 
 void set_real_audio_info(void *arg);
-#define dbg() pr_info("on %s,line %d\n", __func__, __LINE__)
+#define dbg() pr_info("on %s,line %d\n", __func__, __LINE__);
 
 struct device *amports_get_dma_device(void);
 struct device *get_codec_cma_device(void);
-int amports_get_debug_flags(void);
 
 #endif
diff --git a/drivers/stream_input/amports/amstream.c b/drivers/stream_input/amports/amstream.c
index f1d2c74..ed2161e 100644
--- a/drivers/stream_input/amports/amstream.c
+++ b/drivers/stream_input/amports/amstream.c
@@ -80,6 +80,7 @@
 #include <linux/compat.h>
 #endif
 #include <linux/amlogic/media/codec_mm/codec_mm.h>
+#include <linux/amlogic/media/codec_mm/configs.h>
 
 #define CONFIG_AM_VDEC_REAL //DEBUG_TMP
 
@@ -100,9 +101,6 @@ u32 amstream_buf_num;
 #endif
 #define NO_VDEC2_INIT 1
 
-
-static int debugflags;
-
 #define DEFAULT_VIDEO_BUFFER_SIZE       (1024 * 1024 * 3)
 #define DEFAULT_VIDEO_BUFFER_SIZE_4K       (1024 * 1024 * 6)
 #define DEFAULT_VIDEO_BUFFER_SIZE_TVP       (1024 * 1024 * 10)
@@ -116,7 +114,6 @@ static int def_4k_vstreambuf_sizeM =
 	(DEFAULT_VIDEO_BUFFER_SIZE_4K >> 20);
 static int def_vstreambuf_sizeM =
 	(DEFAULT_VIDEO_BUFFER_SIZE >> 20);
-static int debugflags;
 static int slow_input;
 
 
@@ -132,14 +129,6 @@ struct device *amports_get_dma_device(void)
 }
 EXPORT_SYMBOL(amports_get_dma_device);
 
-/*
-*bit0:no threadrw
-*/
-int amports_get_debug_flags(void)
-{
-	return debugflags;
-}
-
 #ifdef DATA_DEBUG
 #include <linux/fs.h>
 
@@ -328,15 +317,19 @@ static int userdata_length;
 static wait_queue_head_t amstream_userdata_wait;
 #define USERDATA_FIFO_NUM    1024
 static struct userdata_poc_info_t userdata_poc_info[USERDATA_FIFO_NUM];
-static int userdata_poc_ri = 0, userdata_poc_wi;
+static int userdata_poc_ri, userdata_poc_wi;
+static int last_read_wi;
+
+
+static DEFINE_MUTEX(userdata_mutex);
 
 static struct stream_port_s ports[] = {
-#ifdef CONFIG_MULTI_DEC
 	{
 		.name = "amstream_vbuf",
 		.type = PORT_TYPE_ES | PORT_TYPE_VIDEO,
 		.fops = &vbuf_fops,
 	},
+#ifdef CONFIG_MULTI_DEC
 	{
 		.name = "amstream_vbuf_sched",
 		.type = PORT_TYPE_ES | PORT_TYPE_VIDEO |
@@ -349,25 +342,19 @@ static struct stream_port_s ports[] = {
 			PORT_TYPE_FRAME | PORT_TYPE_DECODER_SCHED,
 		.fops = &vframe_fops,
 	},
-#else
-	{
-		.name = "amstream_vbuf",
-		.type = PORT_TYPE_ES | PORT_TYPE_VIDEO,
-		.fops = &vbuf_fops,
-	},
 #endif
 	{
 		.name = "amstream_abuf",
 		.type = PORT_TYPE_ES | PORT_TYPE_AUDIO,
 		.fops = &abuf_fops,
 	},
-#ifdef CONFIG_MULTI_DEC
 	{
 		.name = "amstream_mpts",
 		.type = PORT_TYPE_MPTS | PORT_TYPE_VIDEO |
 			PORT_TYPE_AUDIO | PORT_TYPE_SUB,
 		.fops = &mpts_fops,
 	},
+#ifdef CONFIG_MULTI_DEC
 	{
 		.name = "amstream_mpts_sched",
 		.type = PORT_TYPE_MPTS | PORT_TYPE_VIDEO |
@@ -375,13 +362,6 @@ static struct stream_port_s ports[] = {
 			PORT_TYPE_DECODER_SCHED,
 		.fops = &mpts_fops,
 	},
-#else
-	{
-		.name = "amstream_mpts",
-		.type = PORT_TYPE_MPTS | PORT_TYPE_VIDEO |
-			PORT_TYPE_AUDIO | PORT_TYPE_SUB,
-		.fops = &mpts_fops,
-	},
 #endif
 	{
 		.name = "amstream_mpps",
@@ -409,21 +389,13 @@ static struct stream_port_s ports[] = {
 		.type = PORT_TYPE_USERDATA,
 		.fops = &userdata_fops,
 	},
-#ifdef CONFIG_MULTI_DEC
 	{
 		.name = "amstream_hevc",
-#ifdef CONFIG_AM_VDEC_DV
-/*test dobly vision, remove later*/
-		.type = PORT_TYPE_ES | PORT_TYPE_VIDEO | PORT_TYPE_HEVC |
-			PORT_TYPE_DECODER_SCHED | PORT_TYPE_DUALDEC,
-		.fops = &vbuf_fops,
-		.vformat = VFORMAT_HEVC,
-#else
 		.type = PORT_TYPE_ES | PORT_TYPE_VIDEO | PORT_TYPE_HEVC,
 		.fops = &vbuf_fops,
 		.vformat = VFORMAT_HEVC,
-#endif
 	},
+#ifdef CONFIG_MULTI_DEC
 	{
 		.name = "amstream_hevc_frame",
 		.type = PORT_TYPE_ES | PORT_TYPE_VIDEO | PORT_TYPE_HEVC |
@@ -437,9 +409,8 @@ static struct stream_port_s ports[] = {
 			PORT_TYPE_DECODER_SCHED,
 		.fops = &vbuf_fops,
 		.vformat = VFORMAT_HEVC,
-	}
+	},
 #ifdef CONFIG_AM_VDEC_DV
-	,
 	{
 		.name = "amstream_dves_avc",
 		.type = PORT_TYPE_ES | PORT_TYPE_VIDEO |
@@ -452,15 +423,8 @@ static struct stream_port_s ports[] = {
 			PORT_TYPE_DECODER_SCHED | PORT_TYPE_DUALDEC,
 		.fops = &vbuf_fops,
 		.vformat = VFORMAT_HEVC,
-	}
+	},
 #endif
-#else
-	{
-		.name = "amstream_hevc",
-		.type = PORT_TYPE_ES | PORT_TYPE_VIDEO | PORT_TYPE_HEVC,
-		.fops = &vbuf_fops,
-		.vformat = VFORMAT_HEVC,
-	}
 #endif
 };
 
@@ -546,7 +510,7 @@ static void amstream_change_vbufsize(struct port_priv_s *priv,
 	}
 	if (pvbuf->for_4k) {
 		pvbuf->buf_size = def_4k_vstreambuf_sizeM * SZ_1M;
-		if (codec_mm_video_tvp_enabled())
+		if (priv->vdec->port_flag & PORT_FLAG_DRM)
 			pvbuf->buf_size = DEFAULT_VIDEO_BUFFER_SIZE_4K_TVP;
 		if ((pvbuf->buf_size > 30 * SZ_1M) &&
 		(codec_mm_get_total_size() < 220 * SZ_1M)) {
@@ -554,11 +518,11 @@ static void amstream_change_vbufsize(struct port_priv_s *priv,
 			pvbuf->buf_size = pvbuf->buf_size >> 1;
 		}
 	} else if (pvbuf->buf_size > def_vstreambuf_sizeM * SZ_1M) {
-		if (codec_mm_video_tvp_enabled())
+		if (priv->vdec->port_flag & PORT_FLAG_DRM)
 			pvbuf->buf_size = DEFAULT_VIDEO_BUFFER_SIZE_TVP;
 	} else {
 		pvbuf->buf_size = def_vstreambuf_sizeM * SZ_1M;
-		if (codec_mm_video_tvp_enabled())
+		if (priv->vdec->port_flag & PORT_FLAG_DRM)
 			pvbuf->buf_size = DEFAULT_VIDEO_BUFFER_SIZE_TVP;
 	}
 	reset_canuse_buferlevel(10000);
@@ -594,6 +558,7 @@ static void video_port_release(struct port_priv_s *priv,
 {
 	struct stream_port_s *port = priv->port;
 	struct vdec_s *vdec = priv->vdec;
+	bool is_multidec = !vdec_single(vdec);
 
 	switch (release_num) {
 	default:
@@ -612,7 +577,7 @@ static void video_port_release(struct port_priv_s *priv,
 	/*fallthrough*/
 	case 2:
 		if ((port->type & PORT_TYPE_FRAME) == 0)
-			stbuf_release(pbuf);
+			stbuf_release(pbuf, is_multidec);
 	/*fallthrough*/
 	case 1:
 		;
@@ -626,7 +591,7 @@ static int video_port_init(struct port_priv_s *priv,
 	struct stream_port_s *port = priv->port;
 	struct vdec_s *vdec = priv->vdec;
 
-	if ((port->flag & PORT_FLAG_VFORMAT) == 0) {
+	if ((vdec->port_flag & PORT_FLAG_VFORMAT) == 0) {
 		pr_err("vformat not set\n");
 		return -EPERM;
 	}
@@ -635,6 +600,9 @@ static int video_port_init(struct port_priv_s *priv,
 		(priv->vdec->sys_info->height *
 			priv->vdec->sys_info->width) > 1920*1088) {
 		pbuf->for_4k = 1;
+		if (get_cpu_type() >= MESON_CPU_MAJOR_ID_TXLX
+				&& port->vformat == VFORMAT_H264)
+			vdec_poweron(VDEC_HEVC);
 	} else {
 		pbuf->for_4k = 0;
 	}
@@ -664,7 +632,7 @@ static int video_port_init(struct port_priv_s *priv,
 		}
 	}
 
-	r = stbuf_init(pbuf, vdec);
+	r = stbuf_init(pbuf, vdec, false);
 	if (r < 0) {
 		pr_err("video_port_init %d, stbuf_init failed\n", __LINE__);
 		return r;
@@ -724,7 +692,7 @@ static void audio_port_release(struct stream_port_s *port,
 		adec_release(port->vformat);
 	/*fallthrough*/
 	case 2:
-		stbuf_release(pbuf);
+		stbuf_release(pbuf, false);
 	/*fallthrough*/
 	case 1:
 		;
@@ -743,9 +711,9 @@ static int audio_port_reset(struct stream_port_s *port,
 
 	pts_stop(PTS_TYPE_AUDIO);
 
-	stbuf_release(pbuf);
+	stbuf_release(pbuf, false);
 
-	r = stbuf_init(pbuf, NULL);
+	r = stbuf_init(pbuf, NULL, false);
 	if (r < 0)
 		return r;
 
@@ -783,9 +751,9 @@ static int sub_port_reset(struct stream_port_s *port,
 
 	port->flag &= (~PORT_FLAG_INITED);
 
-	stbuf_release(pbuf);
+	stbuf_release(pbuf, false);
 
-	r = stbuf_init(pbuf, NULL);
+	r = stbuf_init(pbuf, NULL, false);
 	if (r < 0)
 		return r;
 
@@ -817,7 +785,7 @@ static int audio_port_init(struct stream_port_s *port,
 		return 0;
 	}
 
-	r = stbuf_init(pbuf, NULL);
+	r = stbuf_init(pbuf, NULL, false);
 	if (r < 0)
 		return r;
 	r = adec_init(port);
@@ -844,7 +812,7 @@ static void sub_port_release(struct stream_port_s *port,
 		/* this is es sub */
 		esparser_release(pbuf);
 	}
-	stbuf_release(pbuf);
+	stbuf_release(pbuf, false);
 	sub_port_inited = 0;
 }
 
@@ -857,7 +825,7 @@ static int sub_port_init(struct stream_port_s *port, struct stream_buf_s *pbuf)
 		return 0;
 	}
 
-	r = stbuf_init(pbuf, NULL);
+	r = stbuf_init(pbuf, NULL, false);
 	if (r < 0)
 		return r;
 
@@ -875,13 +843,22 @@ static int sub_port_init(struct stream_port_s *port, struct stream_buf_s *pbuf)
 	return 0;
 }
 
+static void amstream_user_buffer_init(void)
+{
+	struct stream_buf_s *pubuf = &bufs[BUF_TYPE_USERDATA];
+
+	pubuf->buf_size = 0;
+	pubuf->buf_start = 0;
+	pubuf->buf_wp = 0;
+	pubuf->buf_rp = 0;
+}
+
 static int amstream_port_init(struct port_priv_s *priv)
 {
 	int r;
 	struct stream_buf_s *pvbuf = &bufs[BUF_TYPE_VIDEO];
 	struct stream_buf_s *pabuf = &bufs[BUF_TYPE_AUDIO];
 	struct stream_buf_s *psbuf = &bufs[BUF_TYPE_SUBTITLE];
-	struct stream_buf_s *pubuf = &bufs[BUF_TYPE_USERDATA];
 	struct stream_port_s *port = priv->port;
 	struct vdec_s *vdec = priv->vdec;
 
@@ -889,6 +866,8 @@ static int amstream_port_init(struct port_priv_s *priv)
 
 	stbuf_fetch_init();
 
+	amstream_user_buffer_init();
+
 	if (port_get_inited(priv)) {
 		mutex_unlock(&amstream_mutex);
 		return 0;
@@ -904,11 +883,7 @@ static int amstream_port_init(struct port_priv_s *priv)
 	}
 
 	if ((port->type & PORT_TYPE_VIDEO) &&
-		(port->flag & PORT_FLAG_VFORMAT)) {
-		pubuf->buf_size = 0;
-		pubuf->buf_start = 0;
-		pubuf->buf_wp = 0;
-		pubuf->buf_rp = 0;
+		(vdec->port_flag & PORT_FLAG_VFORMAT)) {
 		pvbuf->for_4k = 0;
 		if (has_hevc_vdec()) {
 			if (port->vformat == VFORMAT_HEVC ||
@@ -983,7 +958,7 @@ static int amstream_port_init(struct port_priv_s *priv)
 #endif
 
 	if ((port->type & PORT_TYPE_VIDEO) &&
-		(port->flag & PORT_FLAG_VFORMAT))
+		(vdec->port_flag & PORT_FLAG_VFORMAT))
 		/* connect vdec at the end after all HW initialization */
 		vdec_connect(vdec);
 
@@ -1101,7 +1076,7 @@ static ssize_t amstream_vbuf_write(struct file *file, const char *buf,
 			return r;
 	}
 
-	if (port->flag & PORT_FLAG_DRM)
+	if (priv->vdec->port_flag & PORT_FLAG_DRM)
 		r = drm_write(file, pbuf, buf, count);
 	else
 		r = esparser_write(file, pbuf, buf, count);
@@ -1120,10 +1095,24 @@ static ssize_t amstream_vframe_write(struct file *file, const char *buf,
 					   size_t count, loff_t *ppos)
 {
 	struct port_priv_s *priv = (struct port_priv_s *)file->private_data;
+	ssize_t ret;
+	int wait_max_cnt = 5;
 #ifdef DATA_DEBUG
 	debug_file_write(buf, count);
 #endif
-	return vdec_write_vframe(priv->vdec, buf, count);
+	do {
+		ret = vdec_write_vframe(priv->vdec, buf, count);
+		if (file->f_flags & O_NONBLOCK) {
+			break;/*alway return for no block mode.*/
+		} else if (ret == -EAGAIN) {
+			int level;
+			level = vdec_input_level(&priv->vdec->input);
+			if (wait_max_cnt-- < 0)
+				break;
+			msleep(20);
+		}
+	} while (ret == -EAGAIN);
+	return ret;
 }
 
 static ssize_t amstream_abuf_write(struct file *file, const char *buf,
@@ -1262,17 +1251,17 @@ static ssize_t amstream_sub_read(struct file *file, char __user *buf,
 								res);
 				}
 
-			return first_num - res;
-		}
+				return first_num - res;
+			}
 
-		res = copy_to_user((void *)buf,
-			(void *)(codec_mm_phys_to_virt(sub_start)),
-			data_size - first_num);
+			res = copy_to_user((void *)buf,
+				(void *)(codec_mm_phys_to_virt(sub_start)),
+				data_size - first_num);
 
-		if (res >= 0) {
-			stbuf_sub_rp_set(sub_start + data_size -
-				first_num - res);
-		}
+			if (res >= 0) {
+				stbuf_sub_rp_set(sub_start + data_size -
+					first_num - res);
+			}
 
 			return data_size - first_num - res;
 		}
@@ -1323,12 +1312,8 @@ static unsigned int amstream_sub_poll(struct file *file,
 	return 0;
 }
 
-void set_userdata_poc(struct userdata_poc_info_t poc)
+static void set_userdata_poc(struct userdata_poc_info_t poc)
 {
-	/*
-	*pr_err("id %d, slicetype %d\n",
-	* userdata_slicetype_wi, slicetype);
-	*/
 	userdata_poc_info[userdata_poc_wi] = poc;
 	userdata_poc_wi++;
 	if (userdata_poc_wi == USERDATA_FIFO_NUM)
@@ -1340,19 +1325,63 @@ void init_userdata_fifo(void)
 {
 	userdata_poc_ri = 0;
 	userdata_poc_wi = 0;
+	userdata_length = 0;
 }
 EXPORT_SYMBOL(init_userdata_fifo);
 
-int wakeup_userdata_poll(int wp, unsigned long start_phyaddr, int buf_size,
+void reset_userdata_fifo(int bInit)
+{
+	struct stream_buf_s *userdata_buf;
+	int wi, ri;
+	u32 rp, wp;
+
+	mutex_lock(&userdata_mutex);
+
+	wi = userdata_poc_wi;
+	ri = userdata_poc_ri;
+
+	userdata_buf = &bufs[BUF_TYPE_USERDATA];
+	rp = userdata_buf->buf_rp;
+	wp = userdata_buf->buf_wp;
+	if (bInit) {
+		/* decoder reset */
+		userdata_buf->buf_rp = 0;
+		userdata_buf->buf_wp = 0;
+		userdata_poc_ri = 0;
+		userdata_poc_wi = 0;
+	} else {
+		/* just clean fifo buffer */
+		userdata_buf->buf_rp = userdata_buf->buf_wp;
+		userdata_poc_ri = userdata_poc_wi;
+	}
+	userdata_length = 0;
+	last_read_wi = userdata_poc_wi;
+
+	mutex_unlock(&userdata_mutex);
+	pr_info("reset_userdata_fifo, bInit=%d, wi=%d, ri=%d, rp=%d, wp=%d\n",
+		bInit, wi, ri, rp, wp);
+}
+EXPORT_SYMBOL(reset_userdata_fifo);
+
+int wakeup_userdata_poll(struct userdata_poc_info_t poc,
+						int wp,
+						unsigned long start_phyaddr,
+						int buf_size,
 						 int data_length)
 {
 	struct stream_buf_s *userdata_buf = &bufs[BUF_TYPE_USERDATA];
+	mutex_lock(&userdata_mutex);
 
+	if (data_length & 0x7)
+		data_length = (((data_length + 8) >> 3) << 3);
+	set_userdata_poc(poc);
 	userdata_buf->buf_start = start_phyaddr;
 	userdata_buf->buf_wp = wp;
 	userdata_buf->buf_size = buf_size;
 	atomic_set(&userdata_ready, 1);
 	userdata_length += data_length;
+	mutex_unlock(&userdata_mutex);
+
 	wake_up_interruptible(&amstream_userdata_wait);
 	return userdata_buf->buf_rp;
 }
@@ -1372,53 +1401,117 @@ static unsigned int amstream_userdata_poll(struct file *file,
 static ssize_t amstream_userdata_read(struct file *file, char __user *buf,
 			size_t count, loff_t *ppos)
 {
-	u32 data_size, res, retVal = 0, buf_wp;
+	u32 data_size, res, retVal = 0;
+	u32 buf_wp, buf_rp, buf_size;
+	unsigned long buf_start;
 	struct stream_buf_s *userdata_buf = &bufs[BUF_TYPE_USERDATA];
+#ifdef DEBUG_USER_DATA
+	int old_wi;
+#endif
+
+	mutex_lock(&userdata_mutex);
+
+	if (userdata_poc_ri != last_read_wi) {
+		/***********************************************
+		app picks up poc counter wrong from last read user data
+		for H264. So, we need to recalculate userdata_poc_ri
+		to the userdata_poc_wi from the last read.
+		***********************************************/
+#if 0
+		pr_info("app pick up poc error: ri = %d, last_wi = %d\n",
+			userdata_poc_ri, last_read_wi);
+#endif
+		userdata_poc_ri = last_read_wi;
+	}
 
 	buf_wp = userdata_buf->buf_wp;
-	if (userdata_buf->buf_start == 0 || userdata_buf->buf_size == 0)
+	buf_rp = userdata_buf->buf_rp;
+	buf_size = userdata_buf->buf_size;
+	buf_start = userdata_buf->buf_start;
+#ifdef DEBUG_USER_DATA
+	old_wi = last_read_wi;
+#endif
+	last_read_wi = userdata_poc_wi;
+	mutex_unlock(&userdata_mutex);
+
+	if (buf_start == 0 || buf_size == 0)
 		return 0;
-	if (buf_wp == userdata_buf->buf_rp)
+	if (buf_wp == buf_rp)
 		return 0;
-	if (buf_wp > userdata_buf->buf_rp)
-		data_size = buf_wp - userdata_buf->buf_rp;
-	else {
-		data_size =
-			userdata_buf->buf_size - userdata_buf->buf_rp + buf_wp;
-	}
+	if (buf_wp > buf_rp)
+		data_size = buf_wp - buf_rp;
+	else
+		data_size = buf_size - buf_rp + buf_wp;
+
 	if (data_size > count)
 		data_size = count;
-	if (buf_wp < userdata_buf->buf_rp) {
-		int first_num = userdata_buf->buf_size - userdata_buf->buf_rp;
-
+#ifdef DEBUG_USER_DATA
+	pr_info("wi:%d ri:%d wp:%d rp:%d size:%d, last_read_wi=%d\n",
+		userdata_poc_wi, userdata_poc_ri,
+		buf_wp, buf_rp, data_size, old_wi);
+#endif
+	if (buf_wp < buf_rp) {
+		int first_num = buf_size - buf_rp;
 		if (data_size <= first_num) {
 			res = copy_to_user((void *)buf,
-				(void *)((userdata_buf->buf_rp +
-				userdata_buf->buf_start)), data_size);
+				(void *)((buf_rp +
+				buf_start)), data_size);
+			if (res)
+				pr_info("p1 read not end res=%d, request=%d\n",
+					res, data_size);
+
+			mutex_lock(&userdata_mutex);
 			userdata_buf->buf_rp += data_size - res;
+			mutex_unlock(&userdata_mutex);
 			retVal = data_size - res;
 		} else {
 			if (first_num > 0) {
 				res = copy_to_user((void *)buf,
-				(void *)((userdata_buf->buf_rp +
-				userdata_buf->buf_start)), first_num);
-				userdata_buf->buf_rp += first_num - res;
-				retVal = first_num - res;
+				(void *)((buf_rp +
+				buf_start)), first_num);
+				if (res)
+					pr_info("p2 read not end res=%d, request=%d\n",
+						res, first_num);
+
+				res = copy_to_user((void *)buf+first_num,
+				(void *)(buf_start),
+				data_size - first_num);
+
+				if (res)
+					pr_info("p3 read not end res=%d, request=%d\n",
+						res, data_size - first_num);
+
+				mutex_lock(&userdata_mutex);
+				userdata_buf->buf_rp += data_size;
+				if (userdata_buf->buf_rp >= buf_size)
+					userdata_buf->buf_rp =
+						userdata_buf->buf_rp - buf_size;
+				mutex_unlock(&userdata_mutex);
+
+				retVal = data_size;
 			} else {
+				/* first_num == 0*/
 				res = copy_to_user((void *)buf,
-				(void *)((userdata_buf->buf_start)),
+				(void *)((buf_start)),
 				data_size - first_num);
+				mutex_lock(&userdata_mutex);
 				userdata_buf->buf_rp =
 					data_size - first_num - res;
+				mutex_unlock(&userdata_mutex);
 				retVal = data_size - first_num - res;
 			}
 		}
 	} else {
 		res = copy_to_user((void *)buf,
-			(void *)((userdata_buf->buf_rp +
-			userdata_buf->buf_start)),
+			(void *)((buf_rp + buf_start)),
 			data_size);
+		if (res)
+			pr_info("p4 read not end res=%d, request=%d\n",
+				res, data_size);
+
+		mutex_lock(&userdata_mutex);
 		userdata_buf->buf_rp += data_size - res;
+		mutex_unlock(&userdata_mutex);
 		retVal = data_size - res;
 	}
 	return retVal;
@@ -1438,7 +1531,7 @@ static int amstream_open(struct inode *inode, struct file *file)
 
 	if (port->type & PORT_TYPE_VIDEO) {
 		for (s = &ports[0], i = 0; i < amstream_port_num; i++, s++) {
-			if (((s->type & PORT_TYPE_DECODER_SCHED) == 0) &&
+			if ((!is_mult_inc(s->type)) &&
 				(s->type & PORT_TYPE_VIDEO) &&
 				(s->flag & PORT_FLAG_IN_USE)) {
 				mutex_unlock(&amstream_mutex);
@@ -1463,8 +1556,10 @@ static int amstream_open(struct inode *inode, struct file *file)
 	}
 
 	priv = kzalloc(sizeof(struct port_priv_s), GFP_KERNEL);
-	if (priv == NULL)
+	if (priv == NULL) {
+		mutex_unlock(&amstream_mutex);
 		return -ENOMEM;
+	}
 
 	priv->port = port;
 
@@ -1482,20 +1577,24 @@ static int amstream_open(struct inode *inode, struct file *file)
 			/* TODO: mod gate */
 			/* switch_mod_gate_by_name("vdec", 1); */
 			amports_switch_gate("vdec", 1);
-			amports_switch_gate("clk_vdec_mux", 1);
 			amports_switch_gate("clk_hcodec_mux", 1);
 
 			if (has_hevc_vdec()) {
-				amports_switch_gate("clk_hevc_mux", 1);
 				if (port->type &
-					(PORT_TYPE_MPTS | PORT_TYPE_HEVC))
+					(PORT_TYPE_MPTS | PORT_TYPE_HEVC)) {
+					amports_switch_gate("clk_hevc_mux", 1);
 					vdec_poweron(VDEC_HEVC);
+				}
 
-				if ((port->type & PORT_TYPE_HEVC) == 0)
+				if ((port->type & PORT_TYPE_HEVC) == 0) {
+					amports_switch_gate("clk_vdec_mux", 1);
 					vdec_poweron(VDEC_1);
+				}
 			} else {
-				if (get_cpu_type() >= MESON_CPU_MAJOR_ID_M8)
+				if (get_cpu_type() >= MESON_CPU_MAJOR_ID_M8) {
+					amports_switch_gate("clk_vdec_mux", 1);
 					vdec_poweron(VDEC_1);
+				}
 			}
 		}
 
@@ -1534,7 +1633,8 @@ static int amstream_open(struct inode *inode, struct file *file)
 			return -ENOMEM;
 		}
 
-		if (port->type & PORT_TYPE_DUALDEC) {
+		if ((port->type & PORT_TYPE_DUALDEC) ||
+			(vdec_get_debug_flags() & 0x100)) {
 			priv->vdec->slave = vdec_create(port, priv->vdec);
 
 			if (priv->vdec->slave == NULL) {
@@ -1553,6 +1653,10 @@ static int amstream_release(struct inode *inode, struct file *file)
 {
 	struct port_priv_s *priv = file->private_data;
 	struct stream_port_s *port = priv->port;
+#ifdef CONFIG_MULTI_DEC
+	u32 port_flag = 0;
+	u32 is_4k = 0;
+#endif
 
 	if (iminor(inode) >= amstream_port_num)
 		return -ENODEV;
@@ -1563,6 +1667,12 @@ static int amstream_release(struct inode *inode, struct file *file)
 		amstream_port_release(priv);
 
 	if (priv->vdec) {
+#ifdef CONFIG_MULTI_DEC
+		port_flag = priv->vdec->port_flag;
+#endif
+		if ((priv->vdec->sys_info->height *
+			priv->vdec->sys_info->width) > 1920*1088)
+			is_4k = 1;
 		if (priv->vdec->slave)
 			vdec_release(priv->vdec->slave);
 
@@ -1603,11 +1713,12 @@ static int amstream_release(struct inode *inode, struct file *file)
 
 				vdec_poweroff(VDEC_1);
 #else
-				if ((port->type & PORT_TYPE_MPTS) &&
-				((port->flag & PORT_FLAG_VFORMAT) == 0)) {
-					vdec_poweroff(VDEC_1);
-					vdec_poweroff(VDEC_HEVC);
-				} else if ((port->vformat == VFORMAT_HEVC
+			if (get_cpu_type() >= MESON_CPU_MAJOR_ID_TXLX
+				&& port->vformat == VFORMAT_H264
+				&& is_4k)
+				vdec_poweroff(VDEC_HEVC);
+
+			 if ((port->vformat == VFORMAT_HEVC
 					|| port->vformat == VFORMAT_VP9)) {
 					vdec_poweroff(VDEC_HEVC);
 				} else {
@@ -1787,6 +1898,9 @@ static long amstream_ioctl_get(struct port_priv_s *priv, ulong arg)
 	case AMSTREAM_GET_ION_ID:
 		parm.data_32 = priv->vdec->vf_receiver_inst;
 		break;
+	case AMSTREAM_GET_NEED_MORE_DATA:
+		parm.data_32 = vdec_need_more_data(priv->vdec);
+		break;
 	default:
 		r = -ENOIOCTLCMD;
 		break;
@@ -1828,11 +1942,13 @@ static long amstream_ioctl_set(struct port_priv_s *priv, ulong arg)
 				if (has_hevc_vdec()) {
 					r = stbuf_change_size(
 						&bufs[BUF_TYPE_HEVC],
-						parm.data_32);
+						parm.data_32,
+						false);
 				}
 				r = stbuf_change_size(
 						&bufs[BUF_TYPE_VIDEO],
-						parm.data_32);
+						parm.data_32,
+						false);
 			}
 		} else if (this->type & PORT_TYPE_FRAME) {
 			/* todo: frame based set max buffer size */
@@ -1852,7 +1968,9 @@ static long amstream_ioctl_set(struct port_priv_s *priv, ulong arg)
 			((bufs[BUF_TYPE_AUDIO].flag & BUF_FLAG_IN_USE) == 0)) {
 			if (bufs[BUF_TYPE_AUDIO].flag & BUF_FLAG_ALLOC) {
 				r = stbuf_change_size(
-					&bufs[BUF_TYPE_AUDIO], parm.data_32);
+					&bufs[BUF_TYPE_AUDIO],
+					parm.data_32,
+					false);
 			}
 		} else
 			r = -EINVAL;
@@ -2043,6 +2161,9 @@ static long amstream_ioctl_set(struct port_priv_s *priv, ulong arg)
 		if (parm.data_32 == 1) {
 			pr_err("set drmmode\n");
 			this->flag |= PORT_FLAG_DRM;
+			if ((this->type & PORT_TYPE_VIDEO) &&
+				(priv->vdec))
+				priv->vdec->port_flag |= PORT_FLAG_DRM;
 		} else {
 			this->flag &= (~PORT_FLAG_DRM);
 			pr_err("no drmmode\n");
@@ -2059,12 +2180,23 @@ static long amstream_ioctl_set(struct port_priv_s *priv, ulong arg)
 		break;
 	}
 	case AMSTREAM_SET_FRAME_BASE_PATH:
-		if ((this->type & PORT_TYPE_DECODER_SCHED) &&
+		if (is_mult_inc(this->type) &&
 			(parm.frame_base_video_path < FRAME_BASE_PATH_MAX)) {
 			vdec_set_video_path(priv->vdec, parm.data_32);
 		} else
 			r = -EINVAL;
 		break;
+	case AMSTREAM_SET_EOS:
+		if (priv->vdec)
+			vdec_set_eos(priv->vdec, parm.data_32);
+		break;
+	case AMSTREAM_SET_RECEIVE_ID:
+		if (is_mult_inc(this->type))
+			vdec_set_receive_id(priv->vdec, parm.data_32);
+		else
+			r = -EINVAL;
+		break;
+
 	default:
 		r = -ENOIOCTLCMD;
 		break;
@@ -2150,16 +2282,16 @@ static long amstream_ioctl_get_ex(struct port_priv_s *priv, ulong arg)
 			pr_err("no video\n");
 			return -EINVAL;
 		} else {
-			struct vdec_status vstatus;
+			struct vdec_info vstatus;
 			struct am_ioctl_parm_ex *p = &parm;
 
 			if (p == NULL)
 				return -EINVAL;
 			if (vdec_status(priv->vdec, &vstatus) == -1)
 				return -ENODEV;
-			p->vstatus.width = vstatus.width;
-			p->vstatus.height = vstatus.height;
-			p->vstatus.fps = vstatus.fps;
+			p->vstatus.width = vstatus.frame_width;
+			p->vstatus.height = vstatus.frame_height;
+			p->vstatus.fps = vstatus.frame_rate;
 			p->vstatus.error_count = vstatus.error_count;
 			p->vstatus.status = vstatus.status;
 		}
@@ -2377,10 +2509,12 @@ static long amstream_do_ioctl_old(struct port_priv_s *priv,
 			if (bufs[BUF_TYPE_VIDEO].flag & BUF_FLAG_ALLOC) {
 				if (has_hevc_vdec()) {
 					r = stbuf_change_size(
-						&bufs[BUF_TYPE_HEVC], arg);
+						&bufs[BUF_TYPE_HEVC],
+						arg, false);
 				}
 				r = stbuf_change_size(
-						&bufs[BUF_TYPE_VIDEO], arg);
+						&bufs[BUF_TYPE_VIDEO],
+						arg, false);
 			}
 		} else
 			r = -EINVAL;
@@ -2399,7 +2533,7 @@ static long amstream_do_ioctl_old(struct port_priv_s *priv,
 			((bufs[BUF_TYPE_AUDIO].flag & BUF_FLAG_IN_USE) == 0)) {
 			if (bufs[BUF_TYPE_AUDIO].flag & BUF_FLAG_ALLOC) {
 				r = stbuf_change_size(
-					&bufs[BUF_TYPE_AUDIO], arg);
+					&bufs[BUF_TYPE_AUDIO], arg, false);
 			}
 		} else
 			r = -EINVAL;
@@ -2628,7 +2762,7 @@ static long amstream_do_ioctl_old(struct port_priv_s *priv,
 		if ((this->type & PORT_TYPE_VIDEO) == 0)
 			return -EINVAL;
 		{
-			struct vdec_status vstatus;
+			struct vdec_info vstatus;
 			struct am_io_param para;
 			struct am_io_param *p = &para;
 
@@ -2636,9 +2770,9 @@ static long amstream_do_ioctl_old(struct port_priv_s *priv,
 				return -EINVAL;
 			if (vdec_status(priv->vdec, &vstatus) == -1)
 				return -ENODEV;
-			p->vstatus.width = vstatus.width;
-			p->vstatus.height = vstatus.height;
-			p->vstatus.fps = vstatus.fps;
+			p->vstatus.width = vstatus.frame_width;
+			p->vstatus.height = vstatus.frame_height;
+			p->vstatus.fps = vstatus.frame_rate;
 			p->vstatus.error_count = vstatus.error_count;
 			p->vstatus.status = vstatus.status;
 			if (copy_to_user((void *)arg, p, sizeof(para)))
@@ -2646,6 +2780,21 @@ static long amstream_do_ioctl_old(struct port_priv_s *priv,
 			return r;
 		}
 
+	case AMSTREAM_IOC_VDECINFO:
+		if ((this->type & PORT_TYPE_VIDEO) == 0)
+			return -EINVAL;
+		{
+			struct vdec_info vinfo;
+			struct am_io_info para;
+
+			if (vdec_status(priv->vdec, &vinfo) == -1)
+				return -ENODEV;
+			memcpy(&para.vinfo, &vinfo, sizeof(struct vdec_info));
+			if (copy_to_user((void *)arg, &para, sizeof(para)))
+				r = -EFAULT;
+			return r;
+		}
+
 	case AMSTREAM_IOC_ADECSTAT:
 		if ((this->type & PORT_TYPE_AUDIO) == 0)
 			return -EINVAL;
@@ -2736,7 +2885,7 @@ static long amstream_do_ioctl_old(struct port_priv_s *priv,
 				val = sub_wp - sub_rp;
 			else
 				val = psbuf->buf_size - (sub_rp - sub_wp);
-			put_user(val, (unsigned long __user *)arg);
+			put_user(val, (int __user *)arg);
 		} else
 			r = -EINVAL;
 		break;
@@ -2753,22 +2902,52 @@ static long amstream_do_ioctl_old(struct port_priv_s *priv,
 	case AMSTREAM_IOC_UD_POC:
 		if (this->type & PORT_TYPE_USERDATA) {
 			/* *((u32 *)arg) = userdata_length; */
-			int res;
-			struct userdata_poc_info_t userdata_poc =
-					userdata_poc_info[userdata_poc_ri];
-			/*
-			*put_user(userdata_poc.poc_number,
-			 * (unsigned long __user *)arg);
-			 */
-			res =
+			int ri;
+#ifdef DEBUG_USER_DATA
+			int wi;
+#endif
+			int bDataAvail = 0;
+
+			mutex_lock(&userdata_mutex);
+			if (userdata_poc_wi != userdata_poc_ri) {
+				bDataAvail = 1;
+				ri = userdata_poc_ri;
+#ifdef DEBUG_USER_DATA
+				wi = userdata_poc_wi;
+#endif
+				userdata_poc_ri++;
+				if (userdata_poc_ri >= USERDATA_FIFO_NUM)
+					userdata_poc_ri = 0;
+			}
+			mutex_unlock(&userdata_mutex);
+			if (bDataAvail) {
+				int res;
+				struct userdata_poc_info_t userdata_poc =
+					userdata_poc_info[ri];
+#ifdef DEBUG_USER_DATA
+				pr_info("read poc: ri=%d, wi=%d, poc=%d, last_wi=%d\n",
+					ri, wi,
+					userdata_poc.poc_number,
+					last_read_wi);
+#endif
+				res =
 				copy_to_user((unsigned long __user *)arg,
 					&userdata_poc,
 					sizeof(struct userdata_poc_info_t));
-			if (res < 0)
+				if (res < 0)
+					r = -EFAULT;
+			} else {
 				r = -EFAULT;
-			userdata_poc_ri++;
-			if (USERDATA_FIFO_NUM == userdata_poc_ri)
-				userdata_poc_ri = 0;
+			}
+		} else {
+			r = -EINVAL;
+		}
+		break;
+
+	case AMSTREAM_IOC_UD_FLUSH_USERDATA:
+		if (this->type & PORT_TYPE_USERDATA) {
+			reset_userdata_fifo(0);
+			pr_info("reset_userdata_fifo\n");
 		} else
 			r = -EINVAL;
 		break;
@@ -2921,6 +3100,9 @@ static long amstream_do_ioctl_old(struct port_priv_s *priv,
 		if ((u32) arg == 1) {
 			pr_err("set drmmode\n");
 			this->flag |= PORT_FLAG_DRM;
+			if ((this->type & PORT_TYPE_VIDEO) &&
+				(priv->vdec))
+				priv->vdec->port_flag |= PORT_FLAG_DRM;
 		} else {
 			this->flag &= (~PORT_FLAG_DRM);
 			pr_err("no drmmode\n");
@@ -3466,6 +3648,42 @@ error1:
 	return err;
 }
 
+int videobufused_show_fun(const char *trigger, int id, char *sbuf, int size)
+{
+	int ret = -1;
+	void *buf, *getbuf = NULL;
+	if (size < PAGE_SIZE) {
+		getbuf = (void *)__get_free_page(GFP_KERNEL);
+		if (!getbuf)
+			return -ENOMEM;
+		buf = getbuf;
+	} else {
+		buf = sbuf;
+	}
+
+	switch (id) {
+	case 0:
+		ret = videobufused_show(NULL, NULL , buf);
+		break;
+	default:
+		ret = -1;
+	}
+	if (ret > 0 && getbuf != NULL) {
+		ret = min_t(int, ret, size);
+		strncpy(sbuf, buf, ret);
+	}
+	if (getbuf != NULL)
+		free_page((unsigned long)getbuf);
+	return ret;
+}
+
+static struct mconfig amports_configs[] = {
+	MC_PI32("def_4k_vstreambuf_sizeM", &def_4k_vstreambuf_sizeM),
+	MC_PI32("def_vstreambuf_sizeM", &def_vstreambuf_sizeM),
+	MC_PI32("slow_input", &slow_input),
+	MC_FUN_ID("videobufused", videobufused_show_fun, NULL, 0),
+};
+
 /*static struct resource memobj;*/
 static int amstream_probe(struct platform_device *pdev)
 {
@@ -3525,6 +3743,7 @@ static int amstream_probe(struct platform_device *pdev)
 
 	/*prealloc fetch buf to avoid no continue buffer later...*/
 	stbuf_fetch_init();
+	REG_PATH_CONFIGS("media.amports", amports_configs);
 	return 0;
 
 	/*
@@ -3548,9 +3767,9 @@ static int amstream_remove(struct platform_device *pdev)
 	struct stream_port_s *st;
 
 	if (bufs[BUF_TYPE_VIDEO].flag & BUF_FLAG_ALLOC)
-		stbuf_change_size(&bufs[BUF_TYPE_VIDEO], 0);
+		stbuf_change_size(&bufs[BUF_TYPE_VIDEO], 0, false);
 	if (bufs[BUF_TYPE_AUDIO].flag & BUF_FLAG_ALLOC)
-		stbuf_change_size(&bufs[BUF_TYPE_AUDIO], 0);
+		stbuf_change_size(&bufs[BUF_TYPE_AUDIO], 0, false);
 	stbuf_fetch_release();
 	tsdemux_class_unregister();
 	for (st = &ports[0], i = 0; i < amstream_port_num; i++, st++)
@@ -3631,9 +3850,6 @@ static void __exit amstream_module_exit(void)
 module_init(amstream_module_init);
 module_exit(amstream_module_exit);
 
-module_param(debugflags, uint, 0664);
-MODULE_PARM_DESC(debugflags, "\n amstream debugflags\n");
-
 module_param(def_4k_vstreambuf_sizeM, uint, 0664);
 MODULE_PARM_DESC(def_4k_vstreambuf_sizeM,
 	"\nDefault video Stream buf size for 4K MByptes\n");
diff --git a/drivers/stream_input/parser/esparser.c b/drivers/stream_input/parser/esparser.c
index a9b8e29..1dee180 100644
--- a/drivers/stream_input/parser/esparser.c
+++ b/drivers/stream_input/parser/esparser.c
@@ -50,7 +50,7 @@
 #define ES_START_CODE_PATTERN 0x00000100
 #define ES_START_CODE_MASK    0xffffff00
 #define SEARCH_PATTERN_LEN   512
-#define ES_PARSER_POP      READ_MPEG_REG(PFIFO_DATA)
+#define ES_PARSER_POP      READ_PARSER_REG(PFIFO_DATA)
 
 #define PARSER_WRITE        (ES_WRITE | ES_PARSER_START)
 #define PARSER_VIDEO        (ES_TYPE_VIDEO)
@@ -103,19 +103,20 @@ static void set_buf_wp(u32 type, u32 wp)
 {
 	if (type == BUF_TYPE_AUDIO) {
 		audio_real_wp = wp;
-		WRITE_MPEG_REG(AIU_MEM_AIFIFO_MAN_WP, wp/* & 0xffffff00*/);
+		WRITE_AIU_REG(AIU_MEM_AIFIFO_MAN_WP, wp/* & 0xffffff00*/);
 	}
+	return;
 }
 
 static irqreturn_t esparser_isr(int irq, void *dev_id)
 {
-	u32 int_status = READ_MPEG_REG(PARSER_INT_STATUS);
+	u32 int_status = READ_PARSER_REG(PARSER_INT_STATUS);
 
-	WRITE_MPEG_REG(PARSER_INT_STATUS, int_status);
+	WRITE_PARSER_REG(PARSER_INT_STATUS, int_status);
 
 	if (int_status & PARSER_INTSTAT_SC_FOUND) {
-		WRITE_MPEG_REG(PFIFO_RD_PTR, 0);
-		WRITE_MPEG_REG(PFIFO_WR_PTR, 0);
+		WRITE_PARSER_REG(PFIFO_RD_PTR, 0);
+		WRITE_PARSER_REG(PFIFO_WR_PTR, 0);
 		search_done = 1;
 		wake_up_interruptible(&wq);
 	}
@@ -126,24 +127,24 @@ static inline u32 buf_wp(u32 type)
 {
 	u32 wp;
 
-	if ((READ_MPEG_REG(PARSER_ES_CONTROL) & ES_VID_MAN_RD_PTR) == 0) {
+	if ((READ_PARSER_REG(PARSER_ES_CONTROL) & ES_VID_MAN_RD_PTR) == 0) {
 		wp =
 #if 1/* MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8 */
 		(type == BUF_TYPE_HEVC) ? READ_VREG(HEVC_STREAM_WR_PTR) :
 #endif
 		(type == BUF_TYPE_VIDEO) ? READ_VREG(VLD_MEM_VIFIFO_WP) :
 		(type == BUF_TYPE_AUDIO) ?
-		READ_MPEG_REG(AIU_MEM_AIFIFO_MAN_WP) :
-		READ_MPEG_REG(PARSER_SUB_START_PTR);
+		READ_AIU_REG(AIU_MEM_AIFIFO_MAN_WP) :
+		READ_PARSER_REG(PARSER_SUB_START_PTR);
 	} else {
 		wp =
 #if 1/* MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8 */
-		(type == BUF_TYPE_HEVC) ? READ_MPEG_REG(PARSER_VIDEO_WP) :
+		(type == BUF_TYPE_HEVC) ? READ_PARSER_REG(PARSER_VIDEO_WP) :
 #endif
-		(type == BUF_TYPE_VIDEO) ? READ_MPEG_REG(PARSER_VIDEO_WP) :
+		(type == BUF_TYPE_VIDEO) ? READ_PARSER_REG(PARSER_VIDEO_WP) :
 		(type == BUF_TYPE_AUDIO) ?
-			READ_MPEG_REG(AIU_MEM_AIFIFO_MAN_WP) :
-			READ_MPEG_REG(PARSER_SUB_START_PTR);
+			READ_AIU_REG(AIU_MEM_AIFIFO_MAN_WP) :
+			READ_PARSER_REG(PARSER_SUB_START_PTR);
 	}
 
 	return wp;
@@ -191,50 +192,49 @@ static ssize_t _esparser_write(const char __user *buf,
 
 		/* wmb(); don't need */
 		/* reset the Write and read pointer to zero again */
-		WRITE_MPEG_REG(PFIFO_RD_PTR, 0);
-		WRITE_MPEG_REG(PFIFO_WR_PTR, 0);
+		WRITE_PARSER_REG(PFIFO_RD_PTR, 0);
+		WRITE_PARSER_REG(PFIFO_WR_PTR, 0);
 
-		WRITE_MPEG_REG_BITS(PARSER_CONTROL, len, ES_PACK_SIZE_BIT,
+		WRITE_PARSER_REG_BITS(PARSER_CONTROL, len, ES_PACK_SIZE_BIT,
 							ES_PACK_SIZE_WID);
-		WRITE_MPEG_REG_BITS(PARSER_CONTROL,
+		WRITE_PARSER_REG_BITS(PARSER_CONTROL,
 				parser_type | PARSER_WRITE |
 				PARSER_AUTOSEARCH, ES_CTRL_BIT,
 				ES_CTRL_WID);
 
 		if (isphybuf) {
 			u32 buf_32 = (unsigned long)buf & 0xffffffff;
-
-			WRITE_MPEG_REG(PARSER_FETCH_ADDR, buf_32);
+			WRITE_PARSER_REG(PARSER_FETCH_ADDR, buf_32);
 		} else {
-			WRITE_MPEG_REG(PARSER_FETCH_ADDR, dma_addr);
+			WRITE_PARSER_REG(PARSER_FETCH_ADDR, dma_addr);
 			dma_unmap_single(amports_get_dma_device(), dma_addr,
 					FETCHBUF_SIZE, DMA_TO_DEVICE);
 		}
 
 		search_done = 0;
 		if (!(isphybuf & TYPE_PATTERN)) {
-			WRITE_MPEG_REG(PARSER_FETCH_CMD,
+			WRITE_PARSER_REG(PARSER_FETCH_CMD,
 				(7 << FETCH_ENDIAN) | len);
-			WRITE_MPEG_REG(PARSER_FETCH_ADDR, search_pattern_map);
-			WRITE_MPEG_REG(PARSER_FETCH_CMD,
+			WRITE_PARSER_REG(PARSER_FETCH_ADDR, search_pattern_map);
+			WRITE_PARSER_REG(PARSER_FETCH_CMD,
 				(7 << FETCH_ENDIAN) | SEARCH_PATTERN_LEN);
 		} else {
-			WRITE_MPEG_REG(PARSER_FETCH_CMD,
+			WRITE_PARSER_REG(PARSER_FETCH_CMD,
 				(7 << FETCH_ENDIAN) | (len + 512));
 		}
 		ret = wait_event_interruptible_timeout(wq, search_done != 0,
 			HZ / 5);
 		if (ret == 0) {
-			WRITE_MPEG_REG(PARSER_FETCH_CMD, 0);
+			WRITE_PARSER_REG(PARSER_FETCH_CMD, 0);
 
-			if (wp == buf_wp(type))
+			if (wp == buf_wp(type)) {
 				/*no data fetched */
 				return -EAGAIN;
-
-			pr_info("W Timeout, but fetch ok,");
-			pr_info("type %d len=%d,wpdiff=%d, isphy %x\n",
-				type, len, wp - buf_wp(type), isphybuf);
-
+			} else {
+				pr_info("W Timeout, but fetch ok,");
+				pr_info("type %d len=%d,wpdiff=%d, isphy %x\n",
+				 type, len, wp - buf_wp(type), isphybuf);
+			}
 		} else if (ret < 0)
 			return -ERESTARTSYS;
 	}
@@ -259,12 +259,12 @@ static ssize_t _esparser_write_s(const char __user *buf,
 	dma_addr_t buf_wp_map;
 
 	if (type != BUF_TYPE_AUDIO)
-		WARN_ON(1);/*BUG();*/
+		BUG();
 	wp = get_buf_wp(type);
 	buf_end = get_buf_end(type) + 8;
 	buf_start = get_buf_start(type);
-	/*pr_info("write wp 0x%x, count %d, start 0x%x, end 0x%x\n",*/
-	/*		 wp, (u32)count, buf_start, buf_end);*/
+	/*pr_info("write wp 0x%x, count %d, start 0x%x, end 0x%x\n",
+	*		 wp, (u32)count, buf_start, buf_end);*/
 	if (wp + count > buf_end) {
 		ret = copy_from_user(codec_mm_phys_to_virt(wp),
 				 p, buf_end - wp);
@@ -390,9 +390,9 @@ s32 esparser_init(struct stream_buf_s *buf, struct vdec_s *vdec)
 		else
 			return -EINVAL;
 	mutex_lock(&esparser_mutex);
-	parser_sub_start_ptr = READ_MPEG_REG(PARSER_SUB_START_PTR);
-	parser_sub_end_ptr = READ_MPEG_REG(PARSER_SUB_END_PTR);
-	parser_sub_rp = READ_MPEG_REG(PARSER_SUB_RP);
+	parser_sub_start_ptr = READ_PARSER_REG(PARSER_SUB_START_PTR);
+	parser_sub_end_ptr = READ_PARSER_REG(PARSER_SUB_END_PTR);
+	parser_sub_rp = READ_PARSER_REG(PARSER_SUB_RP);
 
 	buf->flag |= BUF_FLAG_PARSER;
 
@@ -430,32 +430,32 @@ s32 esparser_init(struct stream_buf_s *buf, struct vdec_s *vdec)
 		}
 
 		/* reset PARSER with first esparser_init() call */
-		WRITE_MPEG_REG(RESET1_REGISTER, RESET_PARSER);
+		WRITE_RESET_REG(RESET1_REGISTER, RESET_PARSER);
 
 		/* TS data path */
 #ifndef CONFIG_AM_DVB
-		WRITE_MPEG_REG(FEC_INPUT_CONTROL, 0);
+		WRITE_DEMUX_REG(FEC_INPUT_CONTROL, 0);
 #else
 		tsdemux_set_reset_flag();
 #endif
-		CLEAR_MPEG_REG_MASK(TS_HIU_CTL, 1 << USE_HI_BSF_INTERFACE);
-		CLEAR_MPEG_REG_MASK(TS_HIU_CTL_2, 1 << USE_HI_BSF_INTERFACE);
-		CLEAR_MPEG_REG_MASK(TS_HIU_CTL_3, 1 << USE_HI_BSF_INTERFACE);
+		CLEAR_DEMUX_REG_MASK(TS_HIU_CTL, 1 << USE_HI_BSF_INTERFACE);
+		CLEAR_DEMUX_REG_MASK(TS_HIU_CTL_2, 1 << USE_HI_BSF_INTERFACE);
+		CLEAR_DEMUX_REG_MASK(TS_HIU_CTL_3, 1 << USE_HI_BSF_INTERFACE);
 
-		CLEAR_MPEG_REG_MASK(TS_FILE_CONFIG, (1 << TS_HIU_ENABLE));
+		CLEAR_DEMUX_REG_MASK(TS_FILE_CONFIG, (1 << TS_HIU_ENABLE));
 
-		WRITE_MPEG_REG(PARSER_CONFIG,
+		WRITE_PARSER_REG(PARSER_CONFIG,
 					   (10 << PS_CFG_PFIFO_EMPTY_CNT_BIT) |
 					   (1 << PS_CFG_MAX_ES_WR_CYCLE_BIT) |
 					   (16 << PS_CFG_MAX_FETCH_CYCLE_BIT));
 
-		WRITE_MPEG_REG(PFIFO_RD_PTR, 0);
-		WRITE_MPEG_REG(PFIFO_WR_PTR, 0);
+		WRITE_PARSER_REG(PFIFO_RD_PTR, 0);
+		WRITE_PARSER_REG(PFIFO_WR_PTR, 0);
 
-		WRITE_MPEG_REG(PARSER_SEARCH_PATTERN, ES_START_CODE_PATTERN);
-		WRITE_MPEG_REG(PARSER_SEARCH_MASK, ES_START_CODE_MASK);
+		WRITE_PARSER_REG(PARSER_SEARCH_PATTERN, ES_START_CODE_PATTERN);
+		WRITE_PARSER_REG(PARSER_SEARCH_MASK, ES_START_CODE_MASK);
 
-		WRITE_MPEG_REG(PARSER_CONFIG,
+		WRITE_PARSER_REG(PARSER_CONFIG,
 					   (10 << PS_CFG_PFIFO_EMPTY_CNT_BIT) |
 					   (1 << PS_CFG_MAX_ES_WR_CYCLE_BIT) |
 					   PS_CFG_STARTCODE_WID_24 |
@@ -463,18 +463,18 @@ s32 esparser_init(struct stream_buf_s *buf, struct vdec_s *vdec)
 					   /* single byte pop */
 					   (16 << PS_CFG_MAX_FETCH_CYCLE_BIT));
 
-		WRITE_MPEG_REG(PARSER_CONTROL, PARSER_AUTOSEARCH);
+		WRITE_PARSER_REG(PARSER_CONTROL, PARSER_AUTOSEARCH);
 
 	}
-	/* #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8 */
+
 	/* hook stream buffer with PARSER */
 	if (has_hevc_vdec() && (pts_type == PTS_TYPE_HEVC)) {
-		WRITE_MPEG_REG(PARSER_VIDEO_START_PTR, vdec->input.start);
-		WRITE_MPEG_REG(PARSER_VIDEO_END_PTR, vdec->input.start
+		WRITE_PARSER_REG(PARSER_VIDEO_START_PTR, vdec->input.start);
+		WRITE_PARSER_REG(PARSER_VIDEO_END_PTR, vdec->input.start
 			+ vdec->input.size - 8);
 
 		if (vdec_single(vdec)) {
-			CLEAR_MPEG_REG_MASK(PARSER_ES_CONTROL,
+			CLEAR_PARSER_REG_MASK(PARSER_ES_CONTROL,
 				ES_VID_MAN_RD_PTR);
 
 			/* set vififo_vbuf_rp_sel=>hevc */
@@ -487,70 +487,68 @@ s32 esparser_init(struct stream_buf_s *buf, struct vdec_s *vdec)
 			SET_VREG_MASK(HEVC_STREAM_CONTROL, 1);
 
 			/* set stream_buffer_hole with 256 bytes */
-			SET_VREG_MASK(HEVC_STREAM_FIFO_CTL,
-				(1 << 29));
+			SET_VREG_MASK(HEVC_STREAM_FIFO_CTL, (1 << 29));
 		} else {
-			SET_MPEG_REG_MASK(PARSER_ES_CONTROL,
+			SET_PARSER_REG_MASK(PARSER_ES_CONTROL,
 					ES_VID_MAN_RD_PTR);
-			WRITE_MPEG_REG(PARSER_VIDEO_WP, vdec->input.start);
-			WRITE_MPEG_REG(PARSER_VIDEO_RP, vdec->input.start);
+			WRITE_PARSER_REG(PARSER_VIDEO_WP, vdec->input.start);
+			WRITE_PARSER_REG(PARSER_VIDEO_RP, vdec->input.start);
 		}
 		video_data_parsed = 0;
 	} else if (pts_type == PTS_TYPE_VIDEO) {
-		WRITE_MPEG_REG(PARSER_VIDEO_START_PTR,
+		WRITE_PARSER_REG(PARSER_VIDEO_START_PTR,
 			vdec->input.start);
-		WRITE_MPEG_REG(PARSER_VIDEO_END_PTR,
+		WRITE_PARSER_REG(PARSER_VIDEO_END_PTR,
 			vdec->input.start + vdec->input.size - 8);
 		if (vdec_single(vdec)) {
-			CLEAR_MPEG_REG_MASK(PARSER_ES_CONTROL,
+			CLEAR_PARSER_REG_MASK(PARSER_ES_CONTROL,
 				ES_VID_MAN_RD_PTR);
 
 			WRITE_VREG(VLD_MEM_VIFIFO_BUF_CNTL, MEM_BUFCTRL_INIT);
 			CLEAR_VREG_MASK(VLD_MEM_VIFIFO_BUF_CNTL,
 				MEM_BUFCTRL_INIT);
 
-				if (has_hevc_vdec()) {
-					/* set vififo_vbuf_rp_sel=>vdec */
-					WRITE_VREG(DOS_GEN_CTRL0, 0);
-
-				}
-			} else {
-				SET_MPEG_REG_MASK(PARSER_ES_CONTROL,
-						ES_VID_MAN_RD_PTR);
-				WRITE_MPEG_REG(PARSER_VIDEO_WP,
-						vdec->input.start);
-				WRITE_MPEG_REG(PARSER_VIDEO_RP,
-						vdec->input.start);
+			if (has_hevc_vdec()) {
+				/* set vififo_vbuf_rp_sel=>vdec */
+				WRITE_VREG(DOS_GEN_CTRL0, 0);
 			}
-			video_data_parsed = 0;
-		} else if (pts_type == PTS_TYPE_AUDIO) {
-			/* set wp as buffer start */
-			SET_MPEG_REG_MASK(AIU_MEM_AIFIFO_BUF_CNTL,
-				MEM_BUFCTRL_MANUAL);
-			WRITE_MPEG_REG(AIU_MEM_AIFIFO_MAN_RP,
-				READ_MPEG_REG(AIU_MEM_AIFIFO_START_PTR));
-			WRITE_MPEG_REG_BITS(AIU_MEM_AIFIFO_CONTROL, 7, 3, 3);
-			SET_MPEG_REG_MASK(AIU_MEM_AIFIFO_BUF_CNTL,
-				MEM_BUFCTRL_INIT);
-			CLEAR_MPEG_REG_MASK(AIU_MEM_AIFIFO_BUF_CNTL,
-				MEM_BUFCTRL_INIT);
-			WRITE_MPEG_REG(AIU_MEM_AIFIFO_MAN_WP,
-				READ_MPEG_REG(AIU_MEM_AIFIFO_START_PTR));
-			audio_data_parsed = 0;
-			audio_buf_start =
-				READ_MPEG_REG(AIU_MEM_AIFIFO_START_PTR);
-			audio_real_wp = audio_buf_start;
-			audio_buf_end = READ_MPEG_REG(AIU_MEM_AIFIFO_END_PTR);
-		} else if (buf->type == BUF_TYPE_SUBTITLE) {
-			WRITE_MPEG_REG(PARSER_SUB_START_PTR,
-				parser_sub_start_ptr);
-			WRITE_MPEG_REG(PARSER_SUB_END_PTR,
-				parser_sub_end_ptr);
-			WRITE_MPEG_REG(PARSER_SUB_RP, parser_sub_rp);
-			SET_MPEG_REG_MASK(PARSER_ES_CONTROL,
-				(7 << ES_SUB_WR_ENDIAN_BIT) |
-				ES_SUB_MAN_RD_PTR);
+		} else {
+			SET_PARSER_REG_MASK(PARSER_ES_CONTROL,
+					ES_VID_MAN_RD_PTR);
+			WRITE_PARSER_REG(PARSER_VIDEO_WP,
+					vdec->input.start);
+			WRITE_PARSER_REG(PARSER_VIDEO_RP,
+					vdec->input.start);
 		}
+		video_data_parsed = 0;
+	} else if (pts_type == PTS_TYPE_AUDIO) {
+		/* set wp as buffer start */
+		SET_AIU_REG_MASK(AIU_MEM_AIFIFO_BUF_CNTL,
+			MEM_BUFCTRL_MANUAL);
+		WRITE_AIU_REG(AIU_MEM_AIFIFO_MAN_RP,
+			READ_AIU_REG(AIU_MEM_AIFIFO_START_PTR));
+		WRITE_AIU_REG_BITS(AIU_MEM_AIFIFO_CONTROL, 7, 3, 3);
+		SET_AIU_REG_MASK(AIU_MEM_AIFIFO_BUF_CNTL,
+			MEM_BUFCTRL_INIT);
+		CLEAR_AIU_REG_MASK(AIU_MEM_AIFIFO_BUF_CNTL,
+			MEM_BUFCTRL_INIT);
+		WRITE_AIU_REG(AIU_MEM_AIFIFO_MAN_WP,
+			READ_AIU_REG(AIU_MEM_AIFIFO_START_PTR));
+		audio_data_parsed = 0;
+		audio_buf_start =
+			READ_AIU_REG(AIU_MEM_AIFIFO_START_PTR);
+		audio_real_wp = audio_buf_start;
+		audio_buf_end = READ_AIU_REG(AIU_MEM_AIFIFO_END_PTR);
+	} else if (buf->type == BUF_TYPE_SUBTITLE) {
+		WRITE_PARSER_REG(PARSER_SUB_START_PTR,
+			parser_sub_start_ptr);
+		WRITE_PARSER_REG(PARSER_SUB_END_PTR,
+			parser_sub_end_ptr);
+		WRITE_PARSER_REG(PARSER_SUB_RP, parser_sub_rp);
+		SET_PARSER_REG_MASK(PARSER_ES_CONTROL,
+			(7 << ES_SUB_WR_ENDIAN_BIT) |
+			ES_SUB_MAN_RD_PTR);
+	}
 
 	if (pts_type < PTS_TYPE_MAX) {
 		r = pts_start(pts_type);
@@ -581,13 +579,13 @@ s32 esparser_init(struct stream_buf_s *buf, struct vdec_s *vdec)
 			goto Err_2;
 		}
 
-		WRITE_MPEG_REG(PARSER_INT_STATUS, 0xffff);
-		WRITE_MPEG_REG(PARSER_INT_ENABLE,
+		WRITE_PARSER_REG(PARSER_INT_STATUS, 0xffff);
+		WRITE_PARSER_REG(PARSER_INT_ENABLE,
 					   PARSER_INTSTAT_SC_FOUND <<
 					   PARSER_INT_HOST_EN_BIT);
 	}
 	mutex_unlock(&esparser_mutex);
-	if (!(amports_get_debug_flags() & 1) &&
+	if (!(vdec_get_debug_flags() & 1) &&
 		!codec_mm_video_tvp_enabled()) {
 		int block_size = (buf->type == BUF_TYPE_AUDIO) ?
 			PAGE_SIZE : PAGE_SIZE << 4;
@@ -619,21 +617,24 @@ void esparser_audio_reset_s(struct stream_buf_s *buf)
 
 	spin_lock_irqsave(&lock, flags);
 
-	SET_MPEG_REG_MASK(AIU_MEM_AIFIFO_BUF_CNTL, MEM_BUFCTRL_MANUAL);
-	WRITE_MPEG_REG(AIU_MEM_AIFIFO_MAN_RP,
-			READ_MPEG_REG(AIU_MEM_AIFIFO_START_PTR));
-	WRITE_MPEG_REG_BITS(AIU_MEM_AIFIFO_CONTROL, 7, 3, 3);
-	SET_MPEG_REG_MASK(AIU_MEM_AIFIFO_BUF_CNTL, MEM_BUFCTRL_INIT);
-	CLEAR_MPEG_REG_MASK(AIU_MEM_AIFIFO_BUF_CNTL, MEM_BUFCTRL_INIT);
-	WRITE_MPEG_REG(AIU_MEM_AIFIFO_MAN_WP,
-			READ_MPEG_REG(AIU_MEM_AIFIFO_START_PTR));
+	SET_AIU_REG_MASK(AIU_MEM_AIFIFO_BUF_CNTL, MEM_BUFCTRL_MANUAL);
+	WRITE_AIU_REG(AIU_MEM_AIFIFO_MAN_RP,
+			READ_AIU_REG(AIU_MEM_AIFIFO_START_PTR));
+	WRITE_AIU_REG_BITS(AIU_MEM_AIFIFO_CONTROL, 7, 3, 3);
+	SET_AIU_REG_MASK(AIU_MEM_AIFIFO_BUF_CNTL, MEM_BUFCTRL_INIT);
+	CLEAR_AIU_REG_MASK(AIU_MEM_AIFIFO_BUF_CNTL, MEM_BUFCTRL_INIT);
+	WRITE_AIU_REG(AIU_MEM_AIFIFO_MAN_WP,
+			READ_AIU_REG(AIU_MEM_AIFIFO_START_PTR));
 
 	buf->flag |= BUF_FLAG_PARSER;
 
 	audio_data_parsed = 0;
-	audio_real_wp = READ_MPEG_REG(AIU_MEM_AIFIFO_START_PTR);
+	audio_real_wp = READ_AIU_REG(AIU_MEM_AIFIFO_START_PTR);
+	audio_buf_start = READ_AIU_REG(AIU_MEM_AIFIFO_START_PTR);
+	audio_buf_end = READ_AIU_REG(AIU_MEM_AIFIFO_END_PTR);
 	spin_unlock_irqrestore(&lock, flags);
 
+	return;
 }
 
 void esparser_audio_reset(struct stream_buf_s *buf)
@@ -643,19 +644,19 @@ void esparser_audio_reset(struct stream_buf_s *buf)
 
 	spin_lock_irqsave(&lock, flags);
 
-	WRITE_MPEG_REG(PARSER_AUDIO_WP,
-				   READ_MPEG_REG(AIU_MEM_AIFIFO_START_PTR));
-	WRITE_MPEG_REG(PARSER_AUDIO_RP,
-				   READ_MPEG_REG(AIU_MEM_AIFIFO_START_PTR));
+	WRITE_PARSER_REG(PARSER_AUDIO_WP,
+				   READ_AIU_REG(AIU_MEM_AIFIFO_START_PTR));
+	WRITE_PARSER_REG(PARSER_AUDIO_RP,
+				   READ_AIU_REG(AIU_MEM_AIFIFO_START_PTR));
 
-	WRITE_MPEG_REG(PARSER_AUDIO_START_PTR,
-				   READ_MPEG_REG(AIU_MEM_AIFIFO_START_PTR));
-	WRITE_MPEG_REG(PARSER_AUDIO_END_PTR,
-				   READ_MPEG_REG(AIU_MEM_AIFIFO_END_PTR));
-	CLEAR_MPEG_REG_MASK(PARSER_ES_CONTROL, ES_AUD_MAN_RD_PTR);
+	WRITE_PARSER_REG(PARSER_AUDIO_START_PTR,
+				   READ_AIU_REG(AIU_MEM_AIFIFO_START_PTR));
+	WRITE_PARSER_REG(PARSER_AUDIO_END_PTR,
+				   READ_AIU_REG(AIU_MEM_AIFIFO_END_PTR));
+	CLEAR_PARSER_REG_MASK(PARSER_ES_CONTROL, ES_AUD_MAN_RD_PTR);
 
-	WRITE_MPEG_REG(AIU_MEM_AIFIFO_BUF_CNTL, MEM_BUFCTRL_INIT);
-	CLEAR_MPEG_REG_MASK(AIU_MEM_AIFIFO_BUF_CNTL, MEM_BUFCTRL_INIT);
+	WRITE_AIU_REG(AIU_MEM_AIFIFO_BUF_CNTL, MEM_BUFCTRL_INIT);
+	CLEAR_AIU_REG_MASK(AIU_MEM_AIFIFO_BUF_CNTL, MEM_BUFCTRL_INIT);
 
 	buf->flag |= BUF_FLAG_PARSER;
 
@@ -684,7 +685,7 @@ void esparser_release(struct stream_buf_s *buf)
 	if (buf->write_thread)
 		threadrw_release(buf);
 	if (atomic_dec_and_test(&esparser_use_count)) {
-		WRITE_MPEG_REG(PARSER_INT_ENABLE, 0);
+		WRITE_PARSER_REG(PARSER_INT_ENABLE, 0);
 		/*TODO irq */
 
 		vdec_free_irq(PARSER_IRQ, (void *)esparser_id);
@@ -779,15 +780,10 @@ ssize_t drm_write(struct file *file, struct stream_buf_s *stbuf,
 	while (len > 0) {
 		if (stbuf->type != BUF_TYPE_SUBTITLE
 			&& stbuf_space(stbuf) < count) {
-			len = min(stbuf_canusesize(stbuf) / 8, len);
-			if (stbuf_space(stbuf) < len) {
-				r = stbuf_wait_space(stbuf, len);
-				/* write part data , not allow return ; */
-				if ((r < leftcount) && (leftcount > 0))
-					continue;
-				else if ((r < 0) && (leftcount == 0))/*full; */
-					return -EAGAIN;
-			}
+			/*should not write partial data in drm mode*/
+			stbuf_wait_space(stbuf, count);
+			if (stbuf_space(stbuf) < count)
+				return -EAGAIN;
 		}
 		len = min_t(u32, len, count);
 
@@ -926,14 +922,14 @@ void esparser_sub_reset(void)
 
 	spin_lock_irqsave(&lock, flags);
 
-	parser_sub_start_ptr = READ_MPEG_REG(PARSER_SUB_START_PTR);
-	parser_sub_end_ptr = READ_MPEG_REG(PARSER_SUB_END_PTR);
+	parser_sub_start_ptr = READ_PARSER_REG(PARSER_SUB_START_PTR);
+	parser_sub_end_ptr = READ_PARSER_REG(PARSER_SUB_END_PTR);
 
-	WRITE_MPEG_REG(PARSER_SUB_START_PTR, parser_sub_start_ptr);
-	WRITE_MPEG_REG(PARSER_SUB_END_PTR, parser_sub_end_ptr);
-	WRITE_MPEG_REG(PARSER_SUB_RP, parser_sub_start_ptr);
-	WRITE_MPEG_REG(PARSER_SUB_WP, parser_sub_start_ptr);
-	SET_MPEG_REG_MASK(PARSER_ES_CONTROL,
+	WRITE_PARSER_REG(PARSER_SUB_START_PTR, parser_sub_start_ptr);
+	WRITE_PARSER_REG(PARSER_SUB_END_PTR, parser_sub_end_ptr);
+	WRITE_PARSER_REG(PARSER_SUB_RP, parser_sub_start_ptr);
+	WRITE_PARSER_REG(PARSER_SUB_WP, parser_sub_start_ptr);
+	SET_PARSER_REG_MASK(PARSER_ES_CONTROL,
 		(7 << ES_SUB_WR_ENDIAN_BIT) | ES_SUB_MAN_RD_PTR);
 
 	spin_unlock_irqrestore(&lock, flags);
diff --git a/drivers/stream_input/parser/esparser.h b/drivers/stream_input/parser/esparser.h
index 62396a2..a76fc73 100644
--- a/drivers/stream_input/parser/esparser.h
+++ b/drivers/stream_input/parser/esparser.h
@@ -21,16 +21,19 @@
 #include "../../frame_provider/decoder/utils/vdec.h"
 
 extern ssize_t drm_write(struct file *file,
-	struct stream_buf_s *stbuf, const char __user *buf, size_t count);
+		struct stream_buf_s *stbuf,
+		const char __user *buf, size_t count);
 
 extern s32 esparser_init(struct stream_buf_s *buf, struct vdec_s *vdec);
 extern s32 esparser_init_s(struct stream_buf_s *buf);
 extern void esparser_release(struct stream_buf_s *buf);
 extern ssize_t esparser_write(struct file *file,
-	struct stream_buf_s *stbuf, const char __user *buf, size_t count);
-extern ssize_t esparser_write_ex(struct file *file,
 	struct stream_buf_s *stbuf,
-	const char __user *buf, size_t count, int is_phy);
+	const char __user *buf, size_t count);
+extern ssize_t esparser_write_ex(struct file *file,
+			struct stream_buf_s *stbuf,
+			const char __user *buf, size_t count,
+			int is_phy);
 
 extern s32 es_vpts_checkin_us64(struct stream_buf_s *buf, u64 us64);
 
diff --git a/drivers/stream_input/parser/psparser.c b/drivers/stream_input/parser/psparser.c
index 5c8a8b1..8003894 100644
--- a/drivers/stream_input/parser/psparser.c
+++ b/drivers/stream_input/parser/psparser.c
@@ -58,10 +58,10 @@
 #define PARSER_PARAMETER_LENGTH_BIT     16
 #define PARSER_PARAMETER_LOOP_BIT       24
 
-#define PARSER_POP      READ_MPEG_REG(PFIFO_DATA)
+#define PARSER_POP      READ_PARSER_REG(PFIFO_DATA)
 #define SET_BLOCK(size) \
-WRITE_MPEG_REG_BITS(PARSER_CONTROL, size, ES_PACK_SIZE_BIT, ES_PACK_SIZE_WID)
-#define SET_DISCARD_SIZE(size) WRITE_MPEG_REG(PARSER_PARAMETER, size)
+WRITE_PARSER_REG_BITS(PARSER_CONTROL, size, ES_PACK_SIZE_BIT, ES_PACK_SIZE_WID)
+#define SET_DISCARD_SIZE(size) WRITE_PARSER_REG(PARSER_PARAMETER, size)
 
 #define VIDEO_AUTO_FLUSH
 #ifdef VIDEO_AUTO_FLUSH
@@ -566,21 +566,21 @@ static u32 parser_process(s32 type, s32 packet_len)
 						("sub pts 0x%x, len %d\n",
 						 pts, packet_len);
 						SET_BLOCK(packet_len);
-						WRITE_MPEG_REG
+						WRITE_PARSER_REG
 						(PARSER_PARAMETER,
 						 16 <<
 						 PARSER_PARAMETER_LENGTH_BIT);
-						WRITE_MPEG_REG
+						WRITE_PARSER_REG
 						(PARSER_INSERT_DATA,
 						 SUB_INSERT_START_CODE_HIGH);
-						WRITE_MPEG_REG
+						WRITE_PARSER_REG
 						(PARSER_INSERT_DATA,
 						 SUB_INSERT_START_CODE_LOW |
 						 get_sub_type());
-						WRITE_MPEG_REG
+						WRITE_PARSER_REG
 						(PARSER_INSERT_DATA,
 						 packet_len);
-						WRITE_MPEG_REG
+						WRITE_PARSER_REG
 						(PARSER_INSERT_DATA, pts);
 						atomic_set(&sub_block_found, 1);
 						return SEND_SUBPIC_SEARCH;
@@ -731,48 +731,48 @@ static void on_start_code_found(int start_code)
 
 	switch (next_action) {
 	case SEARCH_START_CODE:
-		WRITE_MPEG_REG(PARSER_CONTROL, PARSER_AUTOSEARCH);
+		WRITE_PARSER_REG(PARSER_CONTROL, PARSER_AUTOSEARCH);
 		break;
 
 	case SEND_VIDEO_SEARCH:
-		WRITE_MPEG_REG_BITS(PARSER_CONTROL,
+		WRITE_PARSER_REG_BITS(PARSER_CONTROL,
 			PARSER_AUTOSEARCH | PARSER_VIDEO |
 			PARSER_WRITE, ES_CTRL_BIT, ES_CTRL_WID);
 		break;
 
 	case SEND_AUDIO_SEARCH:
-		WRITE_MPEG_REG_BITS(PARSER_CONTROL,
+		WRITE_PARSER_REG_BITS(PARSER_CONTROL,
 			PARSER_AUTOSEARCH | PARSER_AUDIO |
 			PARSER_WRITE, ES_CTRL_BIT, ES_CTRL_WID);
 		break;
 
 	case SEND_SUBPIC_SEARCH:
-		WRITE_MPEG_REG_BITS(PARSER_CONTROL,
+		WRITE_PARSER_REG_BITS(PARSER_CONTROL,
 			PARSER_AUTOSEARCH | PARSER_SUBPIC |
 			PARSER_WRITE | ES_INSERT_BEFORE_ES_WRITE,
 			ES_CTRL_BIT, ES_CTRL_WID);
 		break;
 
 	case DISCARD_SEARCH:
-		WRITE_MPEG_REG_BITS(PARSER_CONTROL,
+		WRITE_PARSER_REG_BITS(PARSER_CONTROL,
 			PARSER_AUTOSEARCH | PARSER_DISCARD,
 			ES_CTRL_BIT, ES_CTRL_WID);
 		break;
 
 	case DISCARD_ONLY:
-		WRITE_MPEG_REG_BITS(PARSER_CONTROL,
+		WRITE_PARSER_REG_BITS(PARSER_CONTROL,
 			PARSER_DISCARD, ES_CTRL_BIT, ES_CTRL_WID);
 		break;
 
 #ifdef VIDEO_AUTO_FLUSH
 	case SEARCH_START_CODE_VIDEO_FLUSH:
-		WRITE_MPEG_REG(PARSER_INSERT_DATA, 0xffffffff);
-		WRITE_MPEG_REG(PARSER_INSERT_DATA, 0xffffffff);
-		WRITE_MPEG_REG(PARSER_PARAMETER,
+		WRITE_PARSER_REG(PARSER_INSERT_DATA, 0xffffffff);
+		WRITE_PARSER_REG(PARSER_INSERT_DATA, 0xffffffff);
+		WRITE_PARSER_REG(PARSER_PARAMETER,
 			((VIDEO_AUTO_FLUSH_BYTE_COUNT /
 			  8) << PARSER_PARAMETER_LOOP_BIT) | (8 <<
 			  PARSER_PARAMETER_LENGTH_BIT));
-		WRITE_MPEG_REG(PARSER_CONTROL,
+		WRITE_PARSER_REG(PARSER_CONTROL,
 			PARSER_AUTOSEARCH | PARSER_VIDEO | PARSER_WRITE |
 			ES_INSERT_BEFORE_ES_WRITE);
 		break;
@@ -783,9 +783,9 @@ static void on_start_code_found(int start_code)
 static void parser_tasklet(ulong data)
 {
 	s32 sc;
-	u32 int_status = READ_MPEG_REG(PARSER_INT_STATUS);
+	u32 int_status = READ_PARSER_REG(PARSER_INT_STATUS);
 
-	WRITE_MPEG_REG(PARSER_INT_STATUS, int_status);
+	WRITE_PARSER_REG(PARSER_INT_STATUS, int_status);
 
 	if (int_status & PARSER_INTSTAT_FETCH_CMD) {
 		fetch_done = 1;
@@ -833,16 +833,16 @@ static ssize_t _psparser_write(const char __user *buf, size_t count)
 
 		wmb(); /* Ensure fetchbuf  contents visible */
 
-		WRITE_MPEG_REG(PARSER_FETCH_ADDR, dma_addr);
+		WRITE_PARSER_REG(PARSER_FETCH_ADDR, dma_addr);
 
-		WRITE_MPEG_REG(PARSER_FETCH_CMD, (7 << FETCH_ENDIAN) | len);
+		WRITE_PARSER_REG(PARSER_FETCH_CMD, (7 << FETCH_ENDIAN) | len);
 		dma_unmap_single(amports_get_dma_device(), dma_addr,
 						 FETCHBUF_SIZE, DMA_TO_DEVICE);
 		ret =
 		    wait_event_interruptible_timeout(wq, fetch_done != 0,
 			    HZ / 10);
 		if (ret == 0) {
-			WRITE_MPEG_REG(PARSER_FETCH_CMD, 0);
+			WRITE_PARSER_REG(PARSER_FETCH_CMD, 0);
 			pr_info("write timeout, retry\n");
 			return -EAGAIN;
 		} else if (ret < 0)
@@ -875,9 +875,9 @@ s32 psparser_init(u32 vid, u32 aid, u32 sid, struct vdec_s *vdec)
 	}
 	sub_found_num = 0;
 #endif
-	parser_sub_start_ptr = READ_MPEG_REG(PARSER_SUB_START_PTR);
-	parser_sub_end_ptr = READ_MPEG_REG(PARSER_SUB_END_PTR);
-	parser_sub_rp = READ_MPEG_REG(PARSER_SUB_RP);
+	parser_sub_start_ptr = READ_PARSER_REG(PARSER_SUB_START_PTR);
+	parser_sub_end_ptr = READ_PARSER_REG(PARSER_SUB_END_PTR);
+	parser_sub_rp = READ_PARSER_REG(PARSER_SUB_RP);
 
 	video_id = vid;
 	audio_id = aid;
@@ -900,41 +900,41 @@ s32 psparser_init(u32 vid, u32 aid, u32 sid, struct vdec_s *vdec)
 		return -ENOMEM;
 	}
 
-	WRITE_MPEG_REG(RESET1_REGISTER, RESET_PARSER);
+	WRITE_RESET_REG(RESET1_REGISTER, RESET_PARSER);
 
 	/* TS data path */
 #ifndef CONFIG_AM_DVB
-	WRITE_MPEG_REG(FEC_INPUT_CONTROL, 0);
+	WRITE_DEMUX_REG(FEC_INPUT_CONTROL, 0);
 #else
 	tsdemux_set_reset_flag();
 #endif
-	CLEAR_MPEG_REG_MASK(TS_HIU_CTL, 1 << USE_HI_BSF_INTERFACE);
-	CLEAR_MPEG_REG_MASK(TS_HIU_CTL_2, 1 << USE_HI_BSF_INTERFACE);
-	CLEAR_MPEG_REG_MASK(TS_HIU_CTL_3, 1 << USE_HI_BSF_INTERFACE);
-	CLEAR_MPEG_REG_MASK(TS_FILE_CONFIG, (1 << TS_HIU_ENABLE));
+	CLEAR_DEMUX_REG_MASK(TS_HIU_CTL, 1 << USE_HI_BSF_INTERFACE);
+	CLEAR_DEMUX_REG_MASK(TS_HIU_CTL_2, 1 << USE_HI_BSF_INTERFACE);
+	CLEAR_DEMUX_REG_MASK(TS_HIU_CTL_3, 1 << USE_HI_BSF_INTERFACE);
+	CLEAR_DEMUX_REG_MASK(TS_FILE_CONFIG, (1 << TS_HIU_ENABLE));
 
 	/* hook stream buffer with PARSER */
-	WRITE_MPEG_REG(PARSER_VIDEO_START_PTR, vdec->input.start);
-	WRITE_MPEG_REG(PARSER_VIDEO_END_PTR,
+	WRITE_PARSER_REG(PARSER_VIDEO_START_PTR, vdec->input.start);
+	WRITE_PARSER_REG(PARSER_VIDEO_END_PTR,
 		vdec->input.start + vdec->input.size - 8);
 
 	if (vdec_single(vdec)) {
-		CLEAR_MPEG_REG_MASK(PARSER_ES_CONTROL, ES_VID_MAN_RD_PTR);
+		CLEAR_PARSER_REG_MASK(PARSER_ES_CONTROL, ES_VID_MAN_RD_PTR);
 		WRITE_VREG(VLD_MEM_VIFIFO_BUF_CNTL, MEM_BUFCTRL_INIT);
 		CLEAR_VREG_MASK(VLD_MEM_VIFIFO_BUF_CNTL, MEM_BUFCTRL_INIT);
 	} else {
-		SET_MPEG_REG_MASK(PARSER_ES_CONTROL, ES_VID_MAN_RD_PTR);
-		WRITE_MPEG_REG(PARSER_VIDEO_WP, vdec->input.start);
-		WRITE_MPEG_REG(PARSER_VIDEO_RP, vdec->input.start);
+		SET_PARSER_REG_MASK(PARSER_ES_CONTROL, ES_VID_MAN_RD_PTR);
+		WRITE_PARSER_REG(PARSER_VIDEO_WP, vdec->input.start);
+		WRITE_PARSER_REG(PARSER_VIDEO_RP, vdec->input.start);
 	}
 
-	WRITE_MPEG_REG(PARSER_AUDIO_START_PTR,
-				   READ_MPEG_REG(AIU_MEM_AIFIFO_START_PTR));
-	WRITE_MPEG_REG(PARSER_AUDIO_END_PTR,
-				   READ_MPEG_REG(AIU_MEM_AIFIFO_END_PTR));
-	CLEAR_MPEG_REG_MASK(PARSER_ES_CONTROL, ES_AUD_MAN_RD_PTR);
+	WRITE_PARSER_REG(PARSER_AUDIO_START_PTR,
+				   READ_AIU_REG(AIU_MEM_AIFIFO_START_PTR));
+	WRITE_PARSER_REG(PARSER_AUDIO_END_PTR,
+				   READ_AIU_REG(AIU_MEM_AIFIFO_END_PTR));
+	CLEAR_PARSER_REG_MASK(PARSER_ES_CONTROL, ES_AUD_MAN_RD_PTR);
 
-	WRITE_MPEG_REG(PARSER_CONFIG,
+	WRITE_PARSER_REG(PARSER_CONFIG,
 				   (10 << PS_CFG_PFIFO_EMPTY_CNT_BIT) |
 				   (1 << PS_CFG_MAX_ES_WR_CYCLE_BIT) |
 				   (16 << PS_CFG_MAX_FETCH_CYCLE_BIT));
@@ -944,29 +944,29 @@ s32 psparser_init(u32 vid, u32 aid, u32 sid, struct vdec_s *vdec)
 		CLEAR_VREG_MASK(VLD_MEM_VIFIFO_BUF_CNTL, MEM_BUFCTRL_INIT);
 	}
 
-	WRITE_MPEG_REG(AIU_MEM_AIFIFO_BUF_CNTL, MEM_BUFCTRL_INIT);
-	CLEAR_MPEG_REG_MASK(AIU_MEM_AIFIFO_BUF_CNTL, MEM_BUFCTRL_INIT);
+	WRITE_AIU_REG(AIU_MEM_AIFIFO_BUF_CNTL, MEM_BUFCTRL_INIT);
+	CLEAR_AIU_REG_MASK(AIU_MEM_AIFIFO_BUF_CNTL, MEM_BUFCTRL_INIT);
 
-	WRITE_MPEG_REG(PARSER_SUB_START_PTR, parser_sub_start_ptr);
-	WRITE_MPEG_REG(PARSER_SUB_END_PTR, parser_sub_end_ptr);
-	WRITE_MPEG_REG(PARSER_SUB_RP, parser_sub_start_ptr);
-	WRITE_MPEG_REG(PARSER_SUB_WP, parser_sub_start_ptr);
-	SET_MPEG_REG_MASK(PARSER_ES_CONTROL,
+	WRITE_PARSER_REG(PARSER_SUB_START_PTR, parser_sub_start_ptr);
+	WRITE_PARSER_REG(PARSER_SUB_END_PTR, parser_sub_end_ptr);
+	WRITE_PARSER_REG(PARSER_SUB_RP, parser_sub_start_ptr);
+	WRITE_PARSER_REG(PARSER_SUB_WP, parser_sub_start_ptr);
+	SET_PARSER_REG_MASK(PARSER_ES_CONTROL,
 		(7 << ES_SUB_WR_ENDIAN_BIT) | ES_SUB_MAN_RD_PTR);
 
-	WRITE_MPEG_REG(PFIFO_RD_PTR, 0);
-	WRITE_MPEG_REG(PFIFO_WR_PTR, 0);
+	WRITE_PARSER_REG(PFIFO_RD_PTR, 0);
+	WRITE_PARSER_REG(PFIFO_WR_PTR, 0);
 
-	WRITE_MPEG_REG(PARSER_SEARCH_PATTERN, MPEG_START_CODE_PATTERN);
-	WRITE_MPEG_REG(PARSER_SEARCH_MASK, MPEG_START_CODE_MASK);
+	WRITE_PARSER_REG(PARSER_SEARCH_PATTERN, MPEG_START_CODE_PATTERN);
+	WRITE_PARSER_REG(PARSER_SEARCH_MASK, MPEG_START_CODE_MASK);
 
-	WRITE_MPEG_REG(PARSER_CONFIG,
+	WRITE_PARSER_REG(PARSER_CONFIG,
 		(10 << PS_CFG_PFIFO_EMPTY_CNT_BIT) |
 		(1 << PS_CFG_MAX_ES_WR_CYCLE_BIT) |
 		PS_CFG_STARTCODE_WID_24 |
 		PS_CFG_PFIFO_ACCESS_WID_8 |	/* single byte pop */
 				   (16 << PS_CFG_MAX_FETCH_CYCLE_BIT));
-	WRITE_MPEG_REG(PARSER_CONTROL, PARSER_AUTOSEARCH);
+	WRITE_PARSER_REG(PARSER_CONTROL, PARSER_AUTOSEARCH);
 
 	tasklet_init(&psparser_tasklet, parser_tasklet, 0);
 	r = pts_start(PTS_TYPE_VIDEO);
@@ -990,8 +990,8 @@ s32 psparser_init(u32 vid, u32 aid, u32 sid, struct vdec_s *vdec)
 		goto Err_3;
 	}
 
-	WRITE_MPEG_REG(PARSER_INT_STATUS, 0xffff);
-	WRITE_MPEG_REG(PARSER_INT_ENABLE,
+	WRITE_PARSER_REG(PARSER_INT_STATUS, 0xffff);
+	WRITE_PARSER_REG(PARSER_INT_ENABLE,
 		PARSER_INT_ALL << PARSER_INT_HOST_EN_BIT);
 
 	return 0;
@@ -1012,7 +1012,7 @@ void psparser_release(void)
 
 	pr_info("psparser_release\n");
 
-	WRITE_MPEG_REG(PARSER_INT_ENABLE, 0);
+	WRITE_PARSER_REG(PARSER_INT_ENABLE, 0);
 	/*TODO irq */
 
 	vdec_free_irq(PARSER_IRQ, (void *)psparser_id);
@@ -1076,19 +1076,19 @@ void psparser_audio_reset(void)
 
 	spin_lock_irqsave(&lock, flags);
 
-	WRITE_MPEG_REG(PARSER_AUDIO_WP,
-				   READ_MPEG_REG(AIU_MEM_AIFIFO_START_PTR));
-	WRITE_MPEG_REG(PARSER_AUDIO_RP,
-				   READ_MPEG_REG(AIU_MEM_AIFIFO_START_PTR));
+	WRITE_PARSER_REG(PARSER_AUDIO_WP,
+				   READ_AIU_REG(AIU_MEM_AIFIFO_START_PTR));
+	WRITE_PARSER_REG(PARSER_AUDIO_RP,
+				   READ_AIU_REG(AIU_MEM_AIFIFO_START_PTR));
 
-	WRITE_MPEG_REG(PARSER_AUDIO_START_PTR,
-				   READ_MPEG_REG(AIU_MEM_AIFIFO_START_PTR));
-	WRITE_MPEG_REG(PARSER_AUDIO_END_PTR,
-				   READ_MPEG_REG(AIU_MEM_AIFIFO_END_PTR));
-	CLEAR_MPEG_REG_MASK(PARSER_ES_CONTROL, ES_AUD_MAN_RD_PTR);
+	WRITE_PARSER_REG(PARSER_AUDIO_START_PTR,
+				   READ_AIU_REG(AIU_MEM_AIFIFO_START_PTR));
+	WRITE_PARSER_REG(PARSER_AUDIO_END_PTR,
+				   READ_AIU_REG(AIU_MEM_AIFIFO_END_PTR));
+	CLEAR_PARSER_REG_MASK(PARSER_ES_CONTROL, ES_AUD_MAN_RD_PTR);
 
-	WRITE_MPEG_REG(AIU_MEM_AIFIFO_BUF_CNTL, MEM_BUFCTRL_INIT);
-	CLEAR_MPEG_REG_MASK(AIU_MEM_AIFIFO_BUF_CNTL, MEM_BUFCTRL_INIT);
+	WRITE_AIU_REG(AIU_MEM_AIFIFO_BUF_CNTL, MEM_BUFCTRL_INIT);
+	CLEAR_AIU_REG_MASK(AIU_MEM_AIFIFO_BUF_CNTL, MEM_BUFCTRL_INIT);
 
 	audio_data_parsed = 0;
 
@@ -1106,14 +1106,14 @@ void psparser_sub_reset(void)
 
 	spin_lock_irqsave(&lock, flags);
 
-	parser_sub_start_ptr = READ_MPEG_REG(PARSER_SUB_START_PTR);
-	parser_sub_end_ptr = READ_MPEG_REG(PARSER_SUB_END_PTR);
+	parser_sub_start_ptr = READ_PARSER_REG(PARSER_SUB_START_PTR);
+	parser_sub_end_ptr = READ_PARSER_REG(PARSER_SUB_END_PTR);
 
-	WRITE_MPEG_REG(PARSER_SUB_START_PTR, parser_sub_start_ptr);
-	WRITE_MPEG_REG(PARSER_SUB_END_PTR, parser_sub_end_ptr);
-	WRITE_MPEG_REG(PARSER_SUB_RP, parser_sub_start_ptr);
-	WRITE_MPEG_REG(PARSER_SUB_WP, parser_sub_start_ptr);
-	SET_MPEG_REG_MASK(PARSER_ES_CONTROL,
+	WRITE_PARSER_REG(PARSER_SUB_START_PTR, parser_sub_start_ptr);
+	WRITE_PARSER_REG(PARSER_SUB_END_PTR, parser_sub_end_ptr);
+	WRITE_PARSER_REG(PARSER_SUB_RP, parser_sub_start_ptr);
+	WRITE_PARSER_REG(PARSER_SUB_WP, parser_sub_start_ptr);
+	SET_PARSER_REG_MASK(PARSER_ES_CONTROL,
 		(7 << ES_SUB_WR_ENDIAN_BIT) | ES_SUB_MAN_RD_PTR);
 
 	spin_unlock_irqrestore(&lock, flags);
diff --git a/drivers/stream_input/parser/psparser.h b/drivers/stream_input/parser/psparser.h
index 1280b6a..5854873 100644
--- a/drivers/stream_input/parser/psparser.h
+++ b/drivers/stream_input/parser/psparser.h
@@ -25,8 +25,9 @@ extern s32 psparser_init(u32 vid, u32 aid, u32 sid, struct vdec_s *vdec);
 extern void psparser_release(void);
 
 extern ssize_t psparser_write(struct file *file,
-	struct stream_buf_s *vbuf,
-	struct stream_buf_s *abuf, const char __user *buf, size_t count);
+		struct stream_buf_s *vbuf,
+		struct stream_buf_s *abuf,
+		const char __user *buf, size_t count);
 
 extern void psparser_change_avid(unsigned int vid, unsigned int aid);
 
diff --git a/drivers/stream_input/parser/rmparser.c b/drivers/stream_input/parser/rmparser.c
index 63d7a63..621672e 100644
--- a/drivers/stream_input/parser/rmparser.c
+++ b/drivers/stream_input/parser/rmparser.c
@@ -45,10 +45,10 @@ static const char rmparser_id[] = "rmparser-id";
 
 static irqreturn_t rm_parser_isr(int irq, void *dev_id)
 {
-	u32 int_status = READ_MPEG_REG(PARSER_INT_STATUS);
+	u32 int_status = READ_PARSER_REG(PARSER_INT_STATUS);
 
 	if (int_status & PARSER_INTSTAT_FETCH_CMD) {
-		WRITE_MPEG_REG(PARSER_INT_STATUS, PARSER_INTSTAT_FETCH_CMD);
+		WRITE_PARSER_REG(PARSER_INT_STATUS, PARSER_INTSTAT_FETCH_CMD);
 		fetch_done = 1;
 
 		wake_up_interruptible(&rm_wq);
@@ -66,44 +66,44 @@ s32 rmparser_init(struct vdec_s *vdec)
 		return -ENOMEM;
 	}
 
-	WRITE_MPEG_REG(RESET1_REGISTER, RESET_PARSER);
+	WRITE_RESET_REG(RESET1_REGISTER, RESET_PARSER);
 
 	/* TS data path */
 #ifndef CONFIG_AM_DVB
-	WRITE_MPEG_REG(FEC_INPUT_CONTROL, 0);
+	WRITE_DEMUX_REG(FEC_INPUT_CONTROL, 0);
 #else
 	tsdemux_set_reset_flag();
 #endif
-	CLEAR_MPEG_REG_MASK(TS_HIU_CTL, 1 << USE_HI_BSF_INTERFACE);
-	CLEAR_MPEG_REG_MASK(TS_HIU_CTL_2, 1 << USE_HI_BSF_INTERFACE);
-	CLEAR_MPEG_REG_MASK(TS_HIU_CTL_3, 1 << USE_HI_BSF_INTERFACE);
+	CLEAR_DEMUX_REG_MASK(TS_HIU_CTL, 1 << USE_HI_BSF_INTERFACE);
+	CLEAR_DEMUX_REG_MASK(TS_HIU_CTL_2, 1 << USE_HI_BSF_INTERFACE);
+	CLEAR_DEMUX_REG_MASK(TS_HIU_CTL_3, 1 << USE_HI_BSF_INTERFACE);
 
-	CLEAR_MPEG_REG_MASK(TS_FILE_CONFIG, (1 << TS_HIU_ENABLE));
+	CLEAR_DEMUX_REG_MASK(TS_FILE_CONFIG, (1 << TS_HIU_ENABLE));
 
 	/* hook stream buffer with PARSER */
-	WRITE_MPEG_REG(PARSER_VIDEO_START_PTR, vdec->input.start);
-	WRITE_MPEG_REG(PARSER_VIDEO_END_PTR,
+	WRITE_PARSER_REG(PARSER_VIDEO_START_PTR, vdec->input.start);
+	WRITE_PARSER_REG(PARSER_VIDEO_END_PTR,
 		vdec->input.start + vdec->input.size - 8);
 
-	CLEAR_MPEG_REG_MASK(PARSER_ES_CONTROL, ES_VID_MAN_RD_PTR);
+	CLEAR_PARSER_REG_MASK(PARSER_ES_CONTROL, ES_VID_MAN_RD_PTR);
 
-	WRITE_MPEG_REG(PARSER_AUDIO_START_PTR,
-				   READ_MPEG_REG(AIU_MEM_AIFIFO_START_PTR));
-	WRITE_MPEG_REG(PARSER_AUDIO_END_PTR,
-				   READ_MPEG_REG(AIU_MEM_AIFIFO_END_PTR));
-	CLEAR_MPEG_REG_MASK(PARSER_ES_CONTROL, ES_AUD_MAN_RD_PTR);
+	WRITE_PARSER_REG(PARSER_AUDIO_START_PTR,
+				   READ_AIU_REG(AIU_MEM_AIFIFO_START_PTR));
+	WRITE_PARSER_REG(PARSER_AUDIO_END_PTR,
+				   READ_AIU_REG(AIU_MEM_AIFIFO_END_PTR));
+	CLEAR_PARSER_REG_MASK(PARSER_ES_CONTROL, ES_AUD_MAN_RD_PTR);
 
 	WRITE_VREG(VLD_MEM_VIFIFO_BUF_CNTL, MEM_BUFCTRL_INIT);
 	CLEAR_VREG_MASK(VLD_MEM_VIFIFO_BUF_CNTL, MEM_BUFCTRL_INIT);
 
-	WRITE_MPEG_REG(AIU_MEM_AIFIFO_BUF_CNTL, MEM_BUFCTRL_INIT);
-	CLEAR_MPEG_REG_MASK(AIU_MEM_AIFIFO_BUF_CNTL, MEM_BUFCTRL_INIT);
+	WRITE_AIU_REG(AIU_MEM_AIFIFO_BUF_CNTL, MEM_BUFCTRL_INIT);
+	CLEAR_AIU_REG_MASK(AIU_MEM_AIFIFO_BUF_CNTL, MEM_BUFCTRL_INIT);
 
-	WRITE_MPEG_REG(PFIFO_RD_PTR, 0);
-	WRITE_MPEG_REG(PFIFO_WR_PTR, 0);
+	WRITE_PARSER_REG(PFIFO_RD_PTR, 0);
+	WRITE_PARSER_REG(PFIFO_WR_PTR, 0);
 
-	WRITE_MPEG_REG(PARSER_SEARCH_MASK, 0);
-	WRITE_MPEG_REG(PARSER_CONTROL, (ES_SEARCH | ES_PARSER_START));
+	WRITE_PARSER_REG(PARSER_SEARCH_MASK, 0);
+	WRITE_PARSER_REG(PARSER_CONTROL, (ES_SEARCH | ES_PARSER_START));
 
 #ifdef MANAGE_PTS
 	if (pts_start(PTS_TYPE_VIDEO) < 0)
@@ -124,8 +124,8 @@ s32 rmparser_init(struct vdec_s *vdec)
 		goto Err_3;
 	}
 
-	WRITE_MPEG_REG(PARSER_INT_STATUS, 0xffff);
-	WRITE_MPEG_REG(PARSER_INT_ENABLE,
+	WRITE_PARSER_REG(PARSER_INT_STATUS, 0xffff);
+	WRITE_PARSER_REG(PARSER_INT_ENABLE,
 			((PARSER_INT_ALL & (~PARSER_INTSTAT_FETCH_CMD)) <<
 					PARSER_INT_AMRISC_EN_BIT)
 			| (PARSER_INTSTAT_FETCH_CMD << PARSER_INT_HOST_EN_BIT));
@@ -143,7 +143,7 @@ EXPORT_SYMBOL(rmparser_init);
 
 void rmparser_release(void)
 {
-	WRITE_MPEG_REG(PARSER_INT_ENABLE, 0);
+	WRITE_PARSER_REG(PARSER_INT_ENABLE, 0);
 	/*TODO irq */
 
 	vdec_free_irq(PARSER_IRQ, (void *)rmparser_id);
@@ -161,8 +161,8 @@ static inline u32 buf_wp(u32 type)
 {
 	return (type == BUF_TYPE_VIDEO) ? READ_VREG(VLD_MEM_VIFIFO_WP) :
 		(type == BUF_TYPE_AUDIO) ?
-		READ_MPEG_REG(AIU_MEM_AIFIFO_MAN_WP) :
-		READ_MPEG_REG(PARSER_SUB_START_PTR);
+		READ_AIU_REG(AIU_MEM_AIFIFO_MAN_WP) :
+		READ_PARSER_REG(PARSER_SUB_START_PTR);
 }
 
 static ssize_t _rmparser_write(const char __user *buf, size_t count)
@@ -192,28 +192,28 @@ static ssize_t _rmparser_write(const char __user *buf, size_t count)
 		wmb(); /* Ensure fetchbuf  contents visible */
 		vwp = buf_wp(BUF_TYPE_VIDEO);
 		awp = buf_wp(BUF_TYPE_AUDIO);
-		WRITE_MPEG_REG(PARSER_FETCH_ADDR, dma_addr);
+		WRITE_PARSER_REG(PARSER_FETCH_ADDR, dma_addr);
 
-		WRITE_MPEG_REG(PARSER_FETCH_CMD, (7 << FETCH_ENDIAN) | len);
+		WRITE_PARSER_REG(PARSER_FETCH_CMD, (7 << FETCH_ENDIAN) | len);
 		dma_unmap_single(amports_get_dma_device(), dma_addr,
 						 FETCHBUF_SIZE, DMA_TO_DEVICE);
 		ret =
 			wait_event_interruptible_timeout(rm_wq, fetch_done != 0,
 					HZ / 10);
 		if (ret == 0) {
-			WRITE_MPEG_REG(PARSER_FETCH_CMD, 0);
+			WRITE_PARSER_REG(PARSER_FETCH_CMD, 0);
 			parse_halt++;
 			pr_info
 			("write timeout,retry,halt_count=%d parse_control=%x\n",
-			 parse_halt, READ_MPEG_REG(PARSER_CONTROL));
+			 parse_halt, READ_PARSER_REG(PARSER_CONTROL));
 
 			//vreal_set_fatal_flag(1);//DEBUG_TMP
 
 			if (parse_halt > 10) {
-				WRITE_MPEG_REG(PARSER_CONTROL,
+				WRITE_PARSER_REG(PARSER_CONTROL,
 						(ES_SEARCH | ES_PARSER_START));
 				pr_info("reset parse_control=%x\n",
-					   READ_MPEG_REG(PARSER_CONTROL));
+					   READ_PARSER_REG(PARSER_CONTROL));
 			}
 			return -EAGAIN;
 		} else if (ret < 0)
@@ -240,10 +240,10 @@ static ssize_t _rmparser_write(const char __user *buf, size_t count)
 			if (parse_halt > 10 &&
 					(v_st_lv < 1000 || a_st_lv < 100)) {
 				/*reset while at  least one is underflow. */
-				WRITE_MPEG_REG(PARSER_CONTROL,
+				WRITE_PARSER_REG(PARSER_CONTROL,
 						(ES_SEARCH | ES_PARSER_START));
 				pr_info("reset parse_control=%x\n",
-					   READ_MPEG_REG(PARSER_CONTROL));
+					   READ_PARSER_REG(PARSER_CONTROL));
 			}
 			if (parse_halt <= 10 ||
 				halt_droped_len < 100 * 1024) {
@@ -298,16 +298,14 @@ ssize_t rmparser_write(struct file *file,
 	towrite = min(towrite, count);
 	return _rmparser_write(buf, towrite);
 }
-EXPORT_SYMBOL(rmparser_write);
 
 void rm_set_vasid(u32 vid, u32 aid)
 {
 	pr_info("rm_set_vasid aid %d, vid %d\n", aid, vid);
-	WRITE_MPEG_REG(VAS_STREAM_ID, (aid << 8) | vid);
+	WRITE_PARSER_REG(VAS_STREAM_ID, (aid << 8) | vid);
 
 	return;
 }
-EXPORT_SYMBOL(rm_set_vasid);
 
 void rm_audio_reset(void)
 {
@@ -316,19 +314,19 @@ void rm_audio_reset(void)
 
 	spin_lock_irqsave(&lock, flags);
 
-	WRITE_MPEG_REG(PARSER_AUDIO_WP,
-				   READ_MPEG_REG(AIU_MEM_AIFIFO_START_PTR));
-	WRITE_MPEG_REG(PARSER_AUDIO_RP,
-				   READ_MPEG_REG(AIU_MEM_AIFIFO_START_PTR));
+	WRITE_PARSER_REG(PARSER_AUDIO_WP,
+				   READ_AIU_REG(AIU_MEM_AIFIFO_START_PTR));
+	WRITE_PARSER_REG(PARSER_AUDIO_RP,
+				   READ_AIU_REG(AIU_MEM_AIFIFO_START_PTR));
 
-	WRITE_MPEG_REG(PARSER_AUDIO_START_PTR,
-				   READ_MPEG_REG(AIU_MEM_AIFIFO_START_PTR));
-	WRITE_MPEG_REG(PARSER_AUDIO_END_PTR,
-				   READ_MPEG_REG(AIU_MEM_AIFIFO_END_PTR));
-	CLEAR_MPEG_REG_MASK(PARSER_ES_CONTROL, ES_AUD_MAN_RD_PTR);
+	WRITE_PARSER_REG(PARSER_AUDIO_START_PTR,
+				   READ_AIU_REG(AIU_MEM_AIFIFO_START_PTR));
+	WRITE_PARSER_REG(PARSER_AUDIO_END_PTR,
+				   READ_AIU_REG(AIU_MEM_AIFIFO_END_PTR));
+	CLEAR_PARSER_REG_MASK(PARSER_ES_CONTROL, ES_AUD_MAN_RD_PTR);
 
-	WRITE_MPEG_REG(AIU_MEM_AIFIFO_BUF_CNTL, MEM_BUFCTRL_INIT);
-	CLEAR_MPEG_REG_MASK(AIU_MEM_AIFIFO_BUF_CNTL, MEM_BUFCTRL_INIT);
+	WRITE_AIU_REG(AIU_MEM_AIFIFO_BUF_CNTL, MEM_BUFCTRL_INIT);
+	CLEAR_AIU_REG_MASK(AIU_MEM_AIFIFO_BUF_CNTL, MEM_BUFCTRL_INIT);
 
 	spin_unlock_irqrestore(&lock, flags);
 
diff --git a/drivers/stream_input/parser/streambuf.c b/drivers/stream_input/parser/streambuf.c
index 8b9aa33..933ca3b 100644
--- a/drivers/stream_input/parser/streambuf.c
+++ b/drivers/stream_input/parser/streambuf.c
@@ -43,9 +43,9 @@
 #define STBUF_WAIT_INTERVAL  (HZ/100)
 #define MEM_NAME "streambuf"
 
-void *fetchbuf;
+void *fetchbuf = 0;
 
-static s32 _stbuf_alloc(struct stream_buf_s *buf)
+static s32 _stbuf_alloc(struct stream_buf_s *buf, bool is_secure)
 {
 	if (buf->buf_size == 0)
 		return -ENOBUFS;
@@ -76,6 +76,9 @@ static s32 _stbuf_alloc(struct stream_buf_s *buf)
 			flags |= CODEC_MM_FLAGS_DMA_CPU;
 		}
 
+		if (is_secure)
+			flags |= CODEC_MM_FLAGS_TVP;
+
 		buf->buf_start = codec_mm_alloc_for_dma(MEM_NAME,
 			buf->buf_page_num, 4+PAGE_SHIFT, flags);
 		if (!buf->buf_start) {
@@ -100,11 +103,15 @@ static s32 _stbuf_alloc(struct stream_buf_s *buf)
 				"Subtitle", buf->buf_size);
 			return -ENOMEM;
 		}
-		pr_info("%s stbuf alloced at %p, size = %d\n",
+
+		buf->is_secure = is_secure;
+
+		pr_info("%s stbuf alloced at %p, secure = %d, size = %d\n",
 				(buf->type == BUF_TYPE_HEVC) ? "HEVC" :
 				(buf->type == BUF_TYPE_VIDEO) ? "Video" :
 				(buf->type == BUF_TYPE_AUDIO) ? "Audio" :
 				"Subtitle", (void *)buf->buf_start,
+				buf->is_secure,
 				buf->buf_size);
 	}
 	if (buf->buf_size < buf->canusebuf_size)
@@ -114,14 +121,14 @@ static s32 _stbuf_alloc(struct stream_buf_s *buf)
 	return 0;
 }
 
-int stbuf_change_size(struct stream_buf_s *buf, int size)
+int stbuf_change_size(struct stream_buf_s *buf, int size, bool is_secure)
 {
 	unsigned long old_buf;
 	int old_size, old_pagenum;
 	int ret;
 
-	pr_info("buffersize=%d,%d,start=%p\n", size, buf->buf_size,
-			(void *)buf->buf_start);
+	pr_info("buffersize=%d,%d,start=%p, secure=%d\n", size, buf->buf_size,
+			(void *)buf->buf_start, is_secure);
 
 	if (buf->buf_size == size && buf->buf_start != 0)
 		return 0;
@@ -133,24 +140,30 @@ int stbuf_change_size(struct stream_buf_s *buf, int size)
 	buf->buf_size = size;
 	ret = size;
 
-	if (size == 0 || _stbuf_alloc(buf) == 0) {
+	if (size == 0 ||
+		_stbuf_alloc(buf, is_secure) == 0) {
 		/*
 		 * size=0:We only free the old memory;
 		 * alloc ok,changed to new buffer
 		 */
-		if (old_buf != 0)
+		if (old_buf != 0) {
 			codec_mm_free_for_dma(MEM_NAME, old_buf);
+		}
+
+		if (size == 0)
+			buf->is_secure = false;
 
 		pr_info("changed the (%d) buffer size from %d to %d\n",
 				buf->type, old_size, size);
 		return 0;
+	} else {
+		/* alloc failed */
+		buf->buf_start = old_buf;
+		buf->buf_size = old_size;
+		buf->buf_page_num = old_pagenum;
+		pr_info("changed the (%d) buffer size from %d to %d,failed\n",
+				buf->type, old_size, size);
 	}
-	/* alloc failed */
-	buf->buf_start = old_buf;
-	buf->buf_size = old_size;
-	buf->buf_page_num = old_pagenum;
-	pr_info("changed the (%d) buffer size from %d to %d,failed\n",
-			buf->type, old_size, size);
 
 	return ret;
 }
@@ -196,12 +209,12 @@ static void _stbuf_timer_func(unsigned long arg)
 u32 stbuf_level(struct stream_buf_s *buf)
 {
 	if ((buf->type == BUF_TYPE_HEVC) || (buf->type == BUF_TYPE_VIDEO)) {
-		if (READ_MPEG_REG(PARSER_ES_CONTROL) & 1) {
-			int level = READ_MPEG_REG(PARSER_VIDEO_WP) -
-				READ_MPEG_REG(PARSER_VIDEO_RP);
+		if (READ_PARSER_REG(PARSER_ES_CONTROL) & 1) {
+			int level = READ_PARSER_REG(PARSER_VIDEO_WP) -
+				READ_PARSER_REG(PARSER_VIDEO_RP);
 			if (level < 0)
-				level += READ_MPEG_REG(PARSER_VIDEO_END_PTR) -
-				READ_MPEG_REG(PARSER_VIDEO_START_PTR) + 8;
+				level += READ_PARSER_REG(PARSER_VIDEO_END_PTR) -
+				READ_PARSER_REG(PARSER_VIDEO_START_PTR) + 8;
 			return (u32)level;
 		} else
 			return (buf->type == BUF_TYPE_HEVC) ?
@@ -215,8 +228,8 @@ u32 stbuf_level(struct stream_buf_s *buf)
 u32 stbuf_rp(struct stream_buf_s *buf)
 {
 	if ((buf->type == BUF_TYPE_HEVC) || (buf->type == BUF_TYPE_VIDEO)) {
-		if (READ_MPEG_REG(PARSER_ES_CONTROL) & 1)
-			return READ_MPEG_REG(PARSER_VIDEO_RP);
+		if (READ_PARSER_REG(PARSER_ES_CONTROL) & 1)
+			return READ_PARSER_REG(PARSER_VIDEO_RP);
 		else
 			return (buf->type == BUF_TYPE_HEVC) ?
 				READ_VREG(HEVC_STREAM_RD_PTR) :
@@ -241,7 +254,7 @@ u32 stbuf_space(struct stream_buf_s *buf)
 
 	if ((buf->type == BUF_TYPE_VIDEO)
 		|| (has_hevc_vdec() && buf->type == BUF_TYPE_HEVC))
-		size -= READ_MPEG_REG(PARSER_VIDEO_HOLE);
+		size -= READ_PARSER_REG(PARSER_VIDEO_HOLE);
 
 	return size > 0 ? size : 0;
 }
@@ -256,32 +269,41 @@ u32 stbuf_canusesize(struct stream_buf_s *buf)
 	return buf->canusebuf_size;
 }
 
-s32 stbuf_init(struct stream_buf_s *buf, struct vdec_s *vdec)
+s32 stbuf_init(struct stream_buf_s *buf, struct vdec_s *vdec, bool is_multi)
 {
 	s32 r;
 	u32 dummy;
 	u32 addr32;
 
 	if (!buf->buf_start) {
-		r = _stbuf_alloc(buf);
+		r = _stbuf_alloc(buf, (vdec) ?
+			vdec->port_flag & PORT_FLAG_DRM : 0);
 		if (r < 0)
 			return r;
 	}
 	addr32 = buf->buf_start & 0xffffffff;
 	init_waitqueue_head(&buf->wq);
 
+	/*
+	 * For multidec, do not touch HW stream buffers during port
+	 * init and release.
+	 */
 	if ((buf->type == BUF_TYPE_VIDEO) || (buf->type == BUF_TYPE_HEVC)) {
 		if (vdec) {
 			if (vdec_stream_based(vdec))
-				vdec_input_set_buffer(&vdec->input, addr32,
+				vdec_set_input_buffer(vdec, addr32,
 						buf->buf_size);
 			else
-				return vdec_input_set_buffer(&vdec->input,
-					addr32,	buf->buf_size);
+				return vdec_set_input_buffer(vdec, addr32,
+						buf->buf_size);
 		}
 	}
 
 	buf->write_thread = 0;
+
+	if ((vdec && !vdec_single(vdec)) || (is_multi))
+		return 0;
+
 	if (has_hevc_vdec() && buf->type == BUF_TYPE_HEVC) {
 		CLEAR_VREG_MASK(HEVC_STREAM_CONTROL, 1);
 		WRITE_VREG(HEVC_STREAM_START_ADDR, addr32);
@@ -301,21 +323,21 @@ s32 stbuf_init(struct stream_buf_s *buf, struct vdec_s *vdec)
 		WRITE_VREG(DOS_SW_RESET0, (1 << 4));
 		WRITE_VREG(DOS_SW_RESET0, 0);
 #else
-		WRITE_MPEG_REG(RESET0_REGISTER, RESET_VLD);
+		WRITE_RESET_REG(RESET0_REGISTER, RESET_VLD);
 #endif
 
-		dummy = READ_MPEG_REG(RESET0_REGISTER);
+		dummy = READ_RESET_REG(RESET0_REGISTER);
 		WRITE_VREG(POWER_CTL_VLD, 1 << 4);
 	} else if (buf->type == BUF_TYPE_AUDIO) {
 		_WRITE_ST_REG(CONTROL, 0);
 
-		WRITE_MPEG_REG(AIU_AIFIFO_GBIT, 0x80);
+		WRITE_AIU_REG(AIU_AIFIFO_GBIT, 0x80);
 	}
 
 	if (buf->type == BUF_TYPE_SUBTITLE) {
-		WRITE_MPEG_REG(PARSER_SUB_RP, addr32);
-		WRITE_MPEG_REG(PARSER_SUB_START_PTR, addr32);
-		WRITE_MPEG_REG(PARSER_SUB_END_PTR,
+		WRITE_PARSER_REG(PARSER_SUB_RP, addr32);
+		WRITE_PARSER_REG(PARSER_SUB_START_PTR, addr32);
+		WRITE_PARSER_REG(PARSER_SUB_END_PTR,
 					   addr32 + buf->buf_size - 8);
 
 		return 0;
@@ -383,36 +405,38 @@ s32 stbuf_wait_space(struct stream_buf_s *stream_buf, size_t count)
 	return 0;
 }
 
-void stbuf_release(struct stream_buf_s *buf)
+void stbuf_release(struct stream_buf_s *buf, bool is_multi)
 {
 	buf->first_tstamp = INVALID_PTS;
 
-	stbuf_init(buf, NULL);	/* reinit buffer */
+	stbuf_init(buf, NULL, is_multi);/* reinit buffer */
 
 	if (buf->flag & BUF_FLAG_ALLOC && buf->buf_start) {
 		codec_mm_free_for_dma(MEM_NAME, buf->buf_start);
 		buf->flag &= ~BUF_FLAG_ALLOC;
 		buf->buf_start = 0;
+		buf->is_secure = false;
 	}
 	buf->flag &= ~BUF_FLAG_IN_USE;
 }
 
 u32 stbuf_sub_rp_get(void)
 {
-	return READ_MPEG_REG(PARSER_SUB_RP);
+	return READ_PARSER_REG(PARSER_SUB_RP);
 }
 
 void stbuf_sub_rp_set(unsigned int sub_rp)
 {
-	WRITE_MPEG_REG(PARSER_SUB_RP, sub_rp);
+	WRITE_PARSER_REG(PARSER_SUB_RP, sub_rp);
+	return;
 }
 
 u32 stbuf_sub_wp_get(void)
 {
-	return READ_MPEG_REG(PARSER_SUB_WP);
+	return READ_PARSER_REG(PARSER_SUB_WP);
 }
 
 u32 stbuf_sub_start_get(void)
 {
-	return READ_MPEG_REG(PARSER_SUB_START_PTR);
+	return READ_PARSER_REG(PARSER_SUB_START_PTR);
 }
diff --git a/drivers/stream_input/parser/streambuf.h b/drivers/stream_input/parser/streambuf.h
index cdae0a8..31acbf0 100644
--- a/drivers/stream_input/parser/streambuf.h
+++ b/drivers/stream_input/parser/streambuf.h
@@ -59,6 +59,7 @@ struct stream_buf_s {
 	u64 last_write_jiffies64;
 	void *write_thread;
 	int for_4k;
+	bool is_secure;
 } /*stream_buf_t */;
 
 struct stream_port_s {
@@ -118,10 +119,12 @@ extern u32 stbuf_rp(struct stream_buf_s *buf);
 extern u32 stbuf_space(struct stream_buf_s *buf);
 extern u32 stbuf_size(struct stream_buf_s *buf);
 extern u32 stbuf_canusesize(struct stream_buf_s *buf);
-extern s32 stbuf_init(struct stream_buf_s *buf, struct vdec_s *vdec);
+extern s32 stbuf_init(struct stream_buf_s *buf, struct vdec_s *vdec,
+		bool is_multi);
 extern s32 stbuf_wait_space(struct stream_buf_s *stream_buf, size_t count);
-extern void stbuf_release(struct stream_buf_s *buf);
-extern int stbuf_change_size(struct stream_buf_s *buf, int size);
+extern void stbuf_release(struct stream_buf_s *buf, bool is_multi);
+extern int stbuf_change_size(struct stream_buf_s *buf, int size,
+				bool is_secure);
 extern int stbuf_fetch_init(void);
 extern void stbuf_fetch_release(void);
 extern u32 stbuf_sub_rp_get(void);
diff --git a/drivers/stream_input/parser/streambuf_reg.h b/drivers/stream_input/parser/streambuf_reg.h
index f00c705..cb6ea63 100644
--- a/drivers/stream_input/parser/streambuf_reg.h
+++ b/drivers/stream_input/parser/streambuf_reg.h
@@ -88,12 +88,13 @@
 	if (buf->reg_base == VLD_MEM_VIFIFO_REG_BASE) \
 		codec_dosbus_write((buf->reg_base+(r)), (val)); \
 	else \
-		codec_cbus_write((buf->reg_base+(r)), (val)); \
+		codec_aiubus_write((buf->reg_base+(r)), (val)); \
 	} while (0)
 #define _READ_ST_REG(r) \
 	((buf->reg_base == VLD_MEM_VIFIFO_REG_BASE) ? \
 	 codec_dosbus_read(buf->reg_base+(r)) : \
-	 codec_cbus_read(buf->reg_base+(r)))
+	 codec_aiubus_read(buf->reg_base+(r)))
+
 #define _SET_ST_REG_MASK(r, val) _WRITE_ST_REG(r, _READ_ST_REG(r) | (val))
 #define _CLR_ST_REG_MASK(r, val) _WRITE_ST_REG(r, _READ_ST_REG(r)&~(val))
 #define _READ_VDEC2_ST_REG(r) (codec_dosbus_read(\
diff --git a/drivers/stream_input/parser/tsdemux.c b/drivers/stream_input/parser/tsdemux.c
index ba9a590..d7b9a18 100644
--- a/drivers/stream_input/parser/tsdemux.c
+++ b/drivers/stream_input/parser/tsdemux.c
@@ -226,35 +226,35 @@ static irqreturn_t tsdemux_isr(int irq, void *dev_id)
 	int id = (long)dev_id;
 
 	if (!enable_demux_driver()) {
-		int_status = READ_MPEG_REG(STB_INT_STATUS);
+		int_status = READ_DEMUX_REG(STB_INT_STATUS);
 	} else {
 		if (id == 0)
-			int_status = READ_MPEG_REG(STB_INT_STATUS);
+			int_status = READ_DEMUX_REG(STB_INT_STATUS);
 		else if (id == 1)
-			int_status = READ_MPEG_REG(STB_INT_STATUS_2);
+			int_status = READ_DEMUX_REG(STB_INT_STATUS_2);
 		else if (id == 2)
-			int_status = READ_MPEG_REG(STB_INT_STATUS_3);
+			int_status = READ_DEMUX_REG(STB_INT_STATUS_3);
 	}
 
 	if (int_status & (1 << NEW_PDTS_READY)) {
 		if (!enable_demux_driver()) {
-			u32 pdts_status = READ_MPEG_REG(STB_PTS_DTS_STATUS);
+			u32 pdts_status = READ_DEMUX_REG(STB_PTS_DTS_STATUS);
 
 			if (pdts_status & (1 << VIDEO_PTS_READY))
 				pts_checkin_wrptr(PTS_TYPE_VIDEO,
-					READ_MPEG_REG(VIDEO_PDTS_WR_PTR),
-					READ_MPEG_REG(VIDEO_PTS_DEMUX));
+					READ_DEMUX_REG(VIDEO_PDTS_WR_PTR),
+					READ_DEMUX_REG(VIDEO_PTS_DEMUX));
 
 			if (pdts_status & (1 << AUDIO_PTS_READY))
 				pts_checkin_wrptr(PTS_TYPE_AUDIO,
-					READ_MPEG_REG(AUDIO_PDTS_WR_PTR),
-					READ_MPEG_REG(AUDIO_PTS_DEMUX));
+					READ_DEMUX_REG(AUDIO_PDTS_WR_PTR),
+					READ_DEMUX_REG(AUDIO_PTS_DEMUX));
 
-			WRITE_MPEG_REG(STB_PTS_DTS_STATUS, pdts_status);
+			WRITE_DEMUX_REG(STB_PTS_DTS_STATUS, pdts_status);
 		} else {
 #define DMX_READ_REG(i, r)\
-	((i) ? ((i == 1) ? READ_MPEG_REG(r##_2) : \
-		READ_MPEG_REG(r##_3)) : READ_MPEG_REG(r))
+	((i) ? ((i == 1) ? READ_DEMUX_REG(r##_2) : \
+		READ_DEMUX_REG(r##_3)) : READ_DEMUX_REG(r))
 
 			u32 pdts_status = DMX_READ_REG(id, STB_PTS_DTS_STATUS);
 
@@ -269,13 +269,13 @@ static irqreturn_t tsdemux_isr(int irq, void *dev_id)
 					DMX_READ_REG(id, AUDIO_PTS_DEMUX));
 
 			if (id == 1)
-				WRITE_MPEG_REG(STB_PTS_DTS_STATUS_2,
+				WRITE_DEMUX_REG(STB_PTS_DTS_STATUS_2,
 							pdts_status);
 			else if (id == 2)
-				WRITE_MPEG_REG(STB_PTS_DTS_STATUS_3,
+				WRITE_DEMUX_REG(STB_PTS_DTS_STATUS_3,
 							pdts_status);
 			else
-				WRITE_MPEG_REG(STB_PTS_DTS_STATUS,
+				WRITE_DEMUX_REG(STB_PTS_DTS_STATUS,
 							pdts_status);
 		}
 	}
@@ -290,16 +290,16 @@ static irqreturn_t tsdemux_isr(int irq, void *dev_id)
 	}
 
 	if (!enable_demux_driver())
-		WRITE_MPEG_REG(STB_INT_STATUS, int_status);
+		WRITE_DEMUX_REG(STB_INT_STATUS, int_status);
 
 	return IRQ_HANDLED;
 }
 
 static irqreturn_t parser_isr(int irq, void *dev_id)
 {
-	u32 int_status = READ_MPEG_REG(PARSER_INT_STATUS);
+	u32 int_status = READ_PARSER_REG(PARSER_INT_STATUS);
 
-	WRITE_MPEG_REG(PARSER_INT_STATUS, int_status);
+	WRITE_PARSER_REG(PARSER_INT_STATUS, int_status);
 
 	if (int_status & PARSER_INTSTAT_FETCH_CMD) {
 		fetch_done = 1;
@@ -344,22 +344,21 @@ static ssize_t _tsdemux_write(const char __user *buf, size_t count,
 
 		if (isphybuf) {
 			u32 buf_32 = (unsigned long)buf & 0xffffffff;
-
-			WRITE_MPEG_REG(PARSER_FETCH_ADDR, buf_32);
+			WRITE_PARSER_REG(PARSER_FETCH_ADDR, buf_32);
 		} else {
-			WRITE_MPEG_REG(PARSER_FETCH_ADDR, dma_addr);
+			WRITE_PARSER_REG(PARSER_FETCH_ADDR, dma_addr);
 			dma_unmap_single(amports_get_dma_device(), dma_addr,
 					FETCHBUF_SIZE, DMA_TO_DEVICE);
 		}
 
-		WRITE_MPEG_REG(PARSER_FETCH_CMD, (7 << FETCH_ENDIAN) | len);
+		WRITE_PARSER_REG(PARSER_FETCH_CMD, (7 << FETCH_ENDIAN) | len);
 
 
 		ret =
 			wait_event_interruptible_timeout(wq, fetch_done != 0,
 					HZ / 2);
 		if (ret == 0) {
-			WRITE_MPEG_REG(PARSER_FETCH_CMD, 0);
+			WRITE_PARSER_REG(PARSER_FETCH_CMD, 0);
 			pr_info("write timeout, retry\n");
 			return -EAGAIN;
 		} else if (ret < 0)
@@ -408,19 +407,19 @@ static int reset_pcr_regs(void)
 		pr_info("[%s:%d] clk_81 = %x clk_unit =%x\n", __func__,
 				__LINE__, clk_81, clk_unit);
 
-		if (READ_MPEG_REG(TS_HIU_CTL_2) & 0x80) {
-			WRITE_MPEG_REG(PCR90K_CTL_2, (12 << 1) | clk_unit);
-			WRITE_MPEG_REG(ASSIGN_PID_NUMBER_2, pcr_num);
+		if (READ_DEMUX_REG(TS_HIU_CTL_2) & 0x80) {
+			WRITE_DEMUX_REG(PCR90K_CTL_2, (12 << 1) | clk_unit);
+			WRITE_DEMUX_REG(ASSIGN_PID_NUMBER_2, pcr_num);
 			pr_info("[tsdemux_init] To use device 2,pcr_num=%d\n",
 					pcr_num);
-		} else if (READ_MPEG_REG(TS_HIU_CTL_3) & 0x80) {
-			WRITE_MPEG_REG(PCR90K_CTL_3, (12 << 1) | clk_unit);
-			WRITE_MPEG_REG(ASSIGN_PID_NUMBER_3, pcr_num);
+		} else if (READ_DEMUX_REG(TS_HIU_CTL_3) & 0x80) {
+			WRITE_DEMUX_REG(PCR90K_CTL_3, (12 << 1) | clk_unit);
+			WRITE_DEMUX_REG(ASSIGN_PID_NUMBER_3, pcr_num);
 			pr_info("[tsdemux_init] To use device 3,pcr_num=%d\n",
 					pcr_num);
 		} else {
-			WRITE_MPEG_REG(PCR90K_CTL, (12 << 1) | clk_unit);
-			WRITE_MPEG_REG(ASSIGN_PID_NUMBER, pcr_num);
+			WRITE_DEMUX_REG(PCR90K_CTL, (12 << 1) | clk_unit);
+			WRITE_DEMUX_REG(ASSIGN_PID_NUMBER, pcr_num);
 			pr_info("[tsdemux_init] To use device 1,pcr_num=%d\n",
 					pcr_num);
 		}
@@ -448,19 +447,19 @@ s32 tsdemux_init(u32 vid, u32 aid, u32 sid, u32 pcrid, bool is_hevc,
 
 	amports_switch_gate("demux", 1);
 
-	parser_sub_start_ptr = READ_MPEG_REG(PARSER_SUB_START_PTR);
-	parser_sub_end_ptr = READ_MPEG_REG(PARSER_SUB_END_PTR);
-	parser_sub_rp = READ_MPEG_REG(PARSER_SUB_RP);
+	parser_sub_start_ptr = READ_PARSER_REG(PARSER_SUB_START_PTR);
+	parser_sub_end_ptr = READ_PARSER_REG(PARSER_SUB_END_PTR);
+	parser_sub_rp = READ_PARSER_REG(PARSER_SUB_RP);
 
-	WRITE_MPEG_REG(RESET1_REGISTER, RESET_PARSER);
+	WRITE_RESET_REG(RESET1_REGISTER, RESET_PARSER);
 
 	if (enable_demux_driver()) {
 		tsdemux_reset();
 	} else {
-		WRITE_MPEG_REG(RESET1_REGISTER, RESET_PARSER | RESET_DEMUXSTB);
+		WRITE_RESET_REG(RESET1_REGISTER, RESET_PARSER | RESET_DEMUXSTB);
 
-		WRITE_MPEG_REG(STB_TOP_CONFIG, 0);
-		WRITE_MPEG_REG(DEMUX_CONTROL, 0);
+		WRITE_DEMUX_REG(STB_TOP_CONFIG, 0);
+		WRITE_DEMUX_REG(DEMUX_CONTROL, 0);
 	}
 
 	/* set PID filter */
@@ -472,48 +471,48 @@ s32 tsdemux_init(u32 vid, u32 aid, u32 sid, u32 pcrid, bool is_hevc,
 		 sid, pcrid);
 
 	if (!enable_demux_driver()) {
-		WRITE_MPEG_REG(FM_WR_DATA,
+		WRITE_DEMUX_REG(FM_WR_DATA,
 				(((vid < 0x1fff)
 					? (vid & 0x1fff) | (VIDEO_PACKET << 13)
 					: 0xffff) << 16)
 				| ((aid < 0x1fff)
 					? (aid & 0x1fff) | (AUDIO_PACKET << 13)
 					: 0xffff));
-		WRITE_MPEG_REG(FM_WR_ADDR, 0x8000);
-		while (READ_MPEG_REG(FM_WR_ADDR) & 0x8000)
+		WRITE_DEMUX_REG(FM_WR_ADDR, 0x8000);
+		while (READ_DEMUX_REG(FM_WR_ADDR) & 0x8000)
 			;
 
-		WRITE_MPEG_REG(FM_WR_DATA,
+		WRITE_DEMUX_REG(FM_WR_DATA,
 				(((sid < 0x1fff)
 					? (sid & 0x1fff) | (SUB_PACKET << 13)
 					: 0xffff) << 16)
 				| 0xffff);
-		WRITE_MPEG_REG(FM_WR_ADDR, 0x8001);
-		while (READ_MPEG_REG(FM_WR_ADDR) & 0x8000)
+		WRITE_DEMUX_REG(FM_WR_ADDR, 0x8001);
+		while (READ_DEMUX_REG(FM_WR_ADDR) & 0x8000)
 			;
 
-		WRITE_MPEG_REG(MAX_FM_COMP_ADDR, 1);
+		WRITE_DEMUX_REG(MAX_FM_COMP_ADDR, 1);
 
-		WRITE_MPEG_REG(STB_INT_MASK, 0);
-		WRITE_MPEG_REG(STB_INT_STATUS, 0xffff);
+		WRITE_DEMUX_REG(STB_INT_MASK, 0);
+		WRITE_DEMUX_REG(STB_INT_STATUS, 0xffff);
 
 		/* TS data path */
-		WRITE_MPEG_REG(FEC_INPUT_CONTROL, 0x7000);
-		WRITE_MPEG_REG(DEMUX_MEM_REQ_EN,
+		WRITE_DEMUX_REG(FEC_INPUT_CONTROL, 0x7000);
+		WRITE_DEMUX_REG(DEMUX_MEM_REQ_EN,
 				(1 << VIDEO_PACKET) |
 				(1 << AUDIO_PACKET) | (1 << SUB_PACKET));
-		WRITE_MPEG_REG(DEMUX_ENDIAN,
+		WRITE_DEMUX_REG(DEMUX_ENDIAN,
 				(7 << OTHER_ENDIAN) |
 				(7 << BYPASS_ENDIAN) | (0 << SECTION_ENDIAN));
-		WRITE_MPEG_REG(TS_HIU_CTL, 1 << USE_HI_BSF_INTERFACE);
-		WRITE_MPEG_REG(TS_FILE_CONFIG,
+		WRITE_DEMUX_REG(TS_HIU_CTL, 1 << USE_HI_BSF_INTERFACE);
+		WRITE_DEMUX_REG(TS_FILE_CONFIG,
 				(demux_skipbyte << 16) |
 				(6 << DES_OUT_DLY) |
 				(3 << TRANSPORT_SCRAMBLING_CONTROL_ODD) |
 				(1 << TS_HIU_ENABLE) | (4 << FEC_FILE_CLK_DIV));
 
 		/* enable TS demux */
-		WRITE_MPEG_REG(DEMUX_CONTROL,
+		WRITE_DEMUX_REG(DEMUX_CONTROL,
 				(1 << STB_DEMUX_ENABLE) |
 				(1 << KEEP_DUPLICATE_PACKAGE));
 	}
@@ -525,12 +524,12 @@ s32 tsdemux_init(u32 vid, u32 aid, u32 sid, u32 pcrid, bool is_hevc,
 
 	/* hook stream buffer with PARSER */
 	if (has_hevc_vdec() && is_hevc) {
-		WRITE_MPEG_REG(PARSER_VIDEO_START_PTR, vdec->input.start);
-		WRITE_MPEG_REG(PARSER_VIDEO_END_PTR, vdec->input.start +
+		WRITE_PARSER_REG(PARSER_VIDEO_START_PTR, vdec->input.start);
+		WRITE_PARSER_REG(PARSER_VIDEO_END_PTR, vdec->input.start +
 			vdec->input.size - 8);
 
 		if (vdec_single(vdec)) {
-			CLEAR_MPEG_REG_MASK(PARSER_ES_CONTROL,
+			CLEAR_PARSER_REG_MASK(PARSER_ES_CONTROL,
 					ES_VID_MAN_RD_PTR);
 			/* set vififo_vbuf_rp_sel=>hevc */
 			WRITE_VREG(DOS_GEN_CTRL0, 3 << 1);
@@ -543,19 +542,18 @@ s32 tsdemux_init(u32 vid, u32 aid, u32 sid, u32 pcrid, bool is_hevc,
 			SET_VREG_MASK(HEVC_STREAM_FIFO_CTL,
 					  (1 << 29));
 		} else {
-			SET_MPEG_REG_MASK(PARSER_ES_CONTROL, ES_VID_MAN_RD_PTR);
-			WRITE_MPEG_REG(PARSER_VIDEO_WP, vdec->input.start);
-			WRITE_MPEG_REG(PARSER_VIDEO_RP, vdec->input.start);
+			SET_PARSER_REG_MASK(PARSER_ES_CONTROL,
+					ES_VID_MAN_RD_PTR);
+			WRITE_PARSER_REG(PARSER_VIDEO_WP, vdec->input.start);
+			WRITE_PARSER_REG(PARSER_VIDEO_RP, vdec->input.start);
 		}
-	} else
-		/* #endif */
-	{
-		WRITE_MPEG_REG(PARSER_VIDEO_START_PTR, vdec->input.start);
-		WRITE_MPEG_REG(PARSER_VIDEO_END_PTR, vdec->input.start +
+	} else {
+		WRITE_PARSER_REG(PARSER_VIDEO_START_PTR, vdec->input.start);
+		WRITE_PARSER_REG(PARSER_VIDEO_END_PTR, vdec->input.start +
 			vdec->input.size - 8);
 
 		if (vdec_single(vdec)) {
-			CLEAR_MPEG_REG_MASK(PARSER_ES_CONTROL,
+			CLEAR_PARSER_REG_MASK(PARSER_ES_CONTROL,
 					ES_VID_MAN_RD_PTR);
 
 			WRITE_VREG(VLD_MEM_VIFIFO_BUF_CNTL, MEM_BUFCTRL_INIT);
@@ -565,30 +563,31 @@ s32 tsdemux_init(u32 vid, u32 aid, u32 sid, u32 pcrid, bool is_hevc,
 			if (has_hevc_vdec())
 				WRITE_VREG(DOS_GEN_CTRL0, 0);
 		} else {
-			SET_MPEG_REG_MASK(PARSER_ES_CONTROL, ES_VID_MAN_RD_PTR);
-			WRITE_MPEG_REG(PARSER_VIDEO_WP, vdec->input.start);
-			WRITE_MPEG_REG(PARSER_VIDEO_RP, vdec->input.start);
+			SET_PARSER_REG_MASK(PARSER_ES_CONTROL,
+					ES_VID_MAN_RD_PTR);
+			WRITE_PARSER_REG(PARSER_VIDEO_WP, vdec->input.start);
+			WRITE_PARSER_REG(PARSER_VIDEO_RP, vdec->input.start);
 		}
 	}
 
-	WRITE_MPEG_REG(PARSER_AUDIO_START_PTR,
-				   READ_MPEG_REG(AIU_MEM_AIFIFO_START_PTR));
-	WRITE_MPEG_REG(PARSER_AUDIO_END_PTR,
-				   READ_MPEG_REG(AIU_MEM_AIFIFO_END_PTR));
-	CLEAR_MPEG_REG_MASK(PARSER_ES_CONTROL, ES_AUD_MAN_RD_PTR);
+	WRITE_PARSER_REG(PARSER_AUDIO_START_PTR,
+				   READ_AIU_REG(AIU_MEM_AIFIFO_START_PTR));
+	WRITE_PARSER_REG(PARSER_AUDIO_END_PTR,
+				   READ_AIU_REG(AIU_MEM_AIFIFO_END_PTR));
+	CLEAR_PARSER_REG_MASK(PARSER_ES_CONTROL, ES_AUD_MAN_RD_PTR);
 
-	WRITE_MPEG_REG(PARSER_CONFIG,
+	WRITE_PARSER_REG(PARSER_CONFIG,
 				   (10 << PS_CFG_PFIFO_EMPTY_CNT_BIT) |
 				   (1 << PS_CFG_MAX_ES_WR_CYCLE_BIT) |
 				   (16 << PS_CFG_MAX_FETCH_CYCLE_BIT));
 
-	WRITE_MPEG_REG(AIU_MEM_AIFIFO_BUF_CNTL, MEM_BUFCTRL_INIT);
-	CLEAR_MPEG_REG_MASK(AIU_MEM_AIFIFO_BUF_CNTL, MEM_BUFCTRL_INIT);
+	WRITE_AIU_REG(AIU_MEM_AIFIFO_BUF_CNTL, MEM_BUFCTRL_INIT);
+	CLEAR_AIU_REG_MASK(AIU_MEM_AIFIFO_BUF_CNTL, MEM_BUFCTRL_INIT);
 
-	WRITE_MPEG_REG(PARSER_SUB_START_PTR, parser_sub_start_ptr);
-	WRITE_MPEG_REG(PARSER_SUB_END_PTR, parser_sub_end_ptr);
-	WRITE_MPEG_REG(PARSER_SUB_RP, parser_sub_rp);
-	SET_MPEG_REG_MASK(PARSER_ES_CONTROL,
+	WRITE_PARSER_REG(PARSER_SUB_START_PTR, parser_sub_start_ptr);
+	WRITE_PARSER_REG(PARSER_SUB_END_PTR, parser_sub_end_ptr);
+	WRITE_PARSER_REG(PARSER_SUB_RP, parser_sub_rp);
+	SET_PARSER_REG_MASK(PARSER_ES_CONTROL,
 			(7 << ES_SUB_WR_ENDIAN_BIT) | ES_SUB_MAN_RD_PTR);
 
 	/* #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8 */
@@ -615,12 +614,12 @@ s32 tsdemux_init(u32 vid, u32 aid, u32 sid, u32 pcrid, bool is_hevc,
 	if (r)
 		goto err3;
 
-	WRITE_MPEG_REG(PARSER_INT_STATUS, 0xffff);
-	WRITE_MPEG_REG(PARSER_INT_ENABLE,
+	WRITE_PARSER_REG(PARSER_INT_STATUS, 0xffff);
+	WRITE_PARSER_REG(PARSER_INT_ENABLE,
 			PARSER_INTSTAT_FETCH_CMD << PARSER_INT_HOST_EN_BIT);
 
-	WRITE_MPEG_REG(PARSER_VIDEO_HOLE, 0x400);
-	WRITE_MPEG_REG(PARSER_AUDIO_HOLE, 0x400);
+	WRITE_PARSER_REG(PARSER_VIDEO_HOLE, 0x400);
+	WRITE_PARSER_REG(PARSER_AUDIO_HOLE, 0x400);
 
 	discontinued_counter = 0;
 
@@ -630,7 +629,7 @@ s32 tsdemux_init(u32 vid, u32 aid, u32 sid, u32 pcrid, bool is_hevc,
 		r = vdec_request_irq(DEMUX_IRQ, tsdemux_isr,
 				"tsdemux-irq", (void *)tsdemux_irq_id);
 
-		WRITE_MPEG_REG(STB_INT_MASK, (1 << SUB_PES_READY)
+		WRITE_DEMUX_REG(STB_INT_MASK, (1 << SUB_PES_READY)
 					   | (1 << NEW_PDTS_READY)
 					   | (1 << DIS_CONTINUITY_PACKET));
 		if (r)
@@ -687,14 +686,14 @@ void tsdemux_release(void)
 	pcrscr_valid = 0;
 	first_pcr = 0;
 
-	WRITE_MPEG_REG(PARSER_INT_ENABLE, 0);
-	WRITE_MPEG_REG(PARSER_VIDEO_HOLE, 0);
-	WRITE_MPEG_REG(PARSER_AUDIO_HOLE, 0);
+	WRITE_PARSER_REG(PARSER_INT_ENABLE, 0);
+	WRITE_PARSER_REG(PARSER_VIDEO_HOLE, 0);
+	WRITE_PARSER_REG(PARSER_AUDIO_HOLE, 0);
 
 #ifdef CONFIG_MULTI_DEC
-	SET_MPEG_REG_MASK(PARSER_ES_CONTROL, ES_VID_MAN_RD_PTR);
-	WRITE_MPEG_REG(PARSER_VIDEO_WP, 0);
-	WRITE_MPEG_REG(PARSER_VIDEO_RP, 0);
+	SET_PARSER_REG_MASK(PARSER_ES_CONTROL, ES_VID_MAN_RD_PTR);
+	WRITE_PARSER_REG(PARSER_VIDEO_WP, 0);
+	WRITE_PARSER_REG(PARSER_VIDEO_RP, 0);
 #endif
 
 	/*TODO irq */
@@ -702,7 +701,7 @@ void tsdemux_release(void)
 	vdec_free_irq(PARSER_IRQ, (void *)tsdemux_fetch_id);
 
 	if (!enable_demux_driver()) {
-		WRITE_MPEG_REG(STB_INT_MASK, 0);
+		WRITE_DEMUX_REG(STB_INT_MASK, 0);
 		/*TODO irq */
 
 		vdec_free_irq(DEMUX_IRQ, (void *)tsdemux_irq_id);
@@ -724,7 +723,7 @@ void tsdemux_release(void)
 	pts_stop(PTS_TYPE_VIDEO);
 	pts_stop(PTS_TYPE_AUDIO);
 
-	WRITE_MPEG_REG(RESET1_REGISTER, RESET_PARSER);
+	WRITE_RESET_REG(RESET1_REGISTER, RESET_PARSER);
 
 	/* #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6 */
 	/*TODO clk */
@@ -978,11 +977,11 @@ void tsdemux_class_unregister(void)
 void tsdemux_change_avid(unsigned int vid, unsigned int aid)
 {
 	if (!enable_demux_driver()) {
-		WRITE_MPEG_REG(FM_WR_DATA,
+		WRITE_DEMUX_REG(FM_WR_DATA,
 				(((vid & 0x1fff) | (VIDEO_PACKET << 13)) << 16)
 				| ((aid & 0x1fff) | (AUDIO_PACKET << 13)));
-		WRITE_MPEG_REG(FM_WR_ADDR, 0x8000);
-		while (READ_MPEG_REG(FM_WR_ADDR) & 0x8000)
+		WRITE_DEMUX_REG(FM_WR_ADDR, 0x8000);
+		while (READ_DEMUX_REG(FM_WR_ADDR) & 0x8000)
 			;
 	} else {
 		curr_vid_id = vid;
@@ -999,11 +998,11 @@ void tsdemux_change_avid(unsigned int vid, unsigned int aid)
 void tsdemux_change_sid(unsigned int sid)
 {
 	if (!enable_demux_driver()) {
-		WRITE_MPEG_REG(FM_WR_DATA,
+		WRITE_DEMUX_REG(FM_WR_DATA,
 				(((sid & 0x1fff) | (SUB_PACKET << 13)) << 16)
 				| 0xffff);
-		WRITE_MPEG_REG(FM_WR_ADDR, 0x8001);
-		while (READ_MPEG_REG(FM_WR_ADDR) & 0x8000)
+		WRITE_DEMUX_REG(FM_WR_ADDR, 0x8001);
+		while (READ_DEMUX_REG(FM_WR_ADDR) & 0x8000)
 			;
 	} else {
 		curr_sub_id = sid;
@@ -1023,19 +1022,19 @@ void tsdemux_audio_reset(void)
 
 	spin_lock_irqsave(&lock, flags);
 
-	WRITE_MPEG_REG(PARSER_AUDIO_WP,
-				   READ_MPEG_REG(AIU_MEM_AIFIFO_START_PTR));
-	WRITE_MPEG_REG(PARSER_AUDIO_RP,
-				   READ_MPEG_REG(AIU_MEM_AIFIFO_START_PTR));
+	WRITE_PARSER_REG(PARSER_AUDIO_WP,
+				   READ_AIU_REG(AIU_MEM_AIFIFO_START_PTR));
+	WRITE_PARSER_REG(PARSER_AUDIO_RP,
+				   READ_AIU_REG(AIU_MEM_AIFIFO_START_PTR));
 
-	WRITE_MPEG_REG(PARSER_AUDIO_START_PTR,
-				   READ_MPEG_REG(AIU_MEM_AIFIFO_START_PTR));
-	WRITE_MPEG_REG(PARSER_AUDIO_END_PTR,
-				   READ_MPEG_REG(AIU_MEM_AIFIFO_END_PTR));
-	CLEAR_MPEG_REG_MASK(PARSER_ES_CONTROL, ES_AUD_MAN_RD_PTR);
+	WRITE_PARSER_REG(PARSER_AUDIO_START_PTR,
+				   READ_AIU_REG(AIU_MEM_AIFIFO_START_PTR));
+	WRITE_PARSER_REG(PARSER_AUDIO_END_PTR,
+				   READ_AIU_REG(AIU_MEM_AIFIFO_END_PTR));
+	CLEAR_PARSER_REG_MASK(PARSER_ES_CONTROL, ES_AUD_MAN_RD_PTR);
 
-	WRITE_MPEG_REG(AIU_MEM_AIFIFO_BUF_CNTL, MEM_BUFCTRL_INIT);
-	CLEAR_MPEG_REG_MASK(AIU_MEM_AIFIFO_BUF_CNTL, MEM_BUFCTRL_INIT);
+	WRITE_AIU_REG(AIU_MEM_AIFIFO_BUF_CNTL, MEM_BUFCTRL_INIT);
+	CLEAR_AIU_REG_MASK(AIU_MEM_AIFIFO_BUF_CNTL, MEM_BUFCTRL_INIT);
 
 	spin_unlock_irqrestore(&lock, flags);
 
@@ -1050,14 +1049,14 @@ void tsdemux_sub_reset(void)
 
 	spin_lock_irqsave(&lock, flags);
 
-	parser_sub_start_ptr = READ_MPEG_REG(PARSER_SUB_START_PTR);
-	parser_sub_end_ptr = READ_MPEG_REG(PARSER_SUB_END_PTR);
+	parser_sub_start_ptr = READ_PARSER_REG(PARSER_SUB_START_PTR);
+	parser_sub_end_ptr = READ_PARSER_REG(PARSER_SUB_END_PTR);
 
-	WRITE_MPEG_REG(PARSER_SUB_START_PTR, parser_sub_start_ptr);
-	WRITE_MPEG_REG(PARSER_SUB_END_PTR, parser_sub_end_ptr);
-	WRITE_MPEG_REG(PARSER_SUB_RP, parser_sub_start_ptr);
-	WRITE_MPEG_REG(PARSER_SUB_WP, parser_sub_start_ptr);
-	SET_MPEG_REG_MASK(PARSER_ES_CONTROL,
+	WRITE_PARSER_REG(PARSER_SUB_START_PTR, parser_sub_start_ptr);
+	WRITE_PARSER_REG(PARSER_SUB_END_PTR, parser_sub_end_ptr);
+	WRITE_PARSER_REG(PARSER_SUB_RP, parser_sub_start_ptr);
+	WRITE_PARSER_REG(PARSER_SUB_WP, parser_sub_start_ptr);
+	SET_PARSER_REG_MASK(PARSER_ES_CONTROL,
 			(7 << ES_SUB_WR_ENDIAN_BIT) | ES_SUB_MAN_RD_PTR);
 
 	spin_unlock_irqrestore(&lock, flags);
@@ -1093,12 +1092,12 @@ u32 tsdemux_pcrscr_get(void)
 	if (pcrscr_valid == 0)
 		return 0;
 
-	if (READ_MPEG_REG(TS_HIU_CTL_2) & 0x80)
-		pcr = READ_MPEG_REG(PCR_DEMUX_2);
-	else if (READ_MPEG_REG(TS_HIU_CTL_3) & 0x80)
-		pcr = READ_MPEG_REG(PCR_DEMUX_3);
+	if (READ_DEMUX_REG(TS_HIU_CTL_2) & 0x80)
+		pcr = READ_DEMUX_REG(PCR_DEMUX_2);
+	else if (READ_DEMUX_REG(TS_HIU_CTL_3) & 0x80)
+		pcr = READ_DEMUX_REG(PCR_DEMUX_3);
 	else
-		pcr = READ_MPEG_REG(PCR_DEMUX);
+		pcr = READ_DEMUX_REG(PCR_DEMUX);
 	if (first_pcr == 0)
 		first_pcr = pcr;
 	return pcr;
@@ -1111,13 +1110,12 @@ u32 tsdemux_first_pcrscr_get(void)
 
 	if (first_pcr == 0) {
 		u32 pcr;
-
-		if (READ_MPEG_REG(TS_HIU_CTL_2) & 0x80)
-			pcr = READ_MPEG_REG(PCR_DEMUX_2);
-		else if (READ_MPEG_REG(TS_HIU_CTL_3) & 0x80)
-			pcr = READ_MPEG_REG(PCR_DEMUX_3);
+		if (READ_DEMUX_REG(TS_HIU_CTL_2) & 0x80)
+			pcr = READ_DEMUX_REG(PCR_DEMUX_2);
+		else if (READ_DEMUX_REG(TS_HIU_CTL_3) & 0x80)
+			pcr = READ_DEMUX_REG(PCR_DEMUX_3);
 		else
-			pcr = READ_MPEG_REG(PCR_DEMUX);
+			pcr = READ_DEMUX_REG(PCR_DEMUX);
 		first_pcr = pcr;
 		/* pr_info("set first_pcr = 0x%x\n", pcr); */
 	}
diff --git a/firmware/video_ucode.bin b/firmware/video_ucode.bin
index e495e377b7a425ee8a575fca689c722b36a1d21c..9f7753efa680b98279d56f76c61810ada6e34d32 100644
GIT binary patch
delta 26442
zcmeHw34B$>_5aMxdvlj}6G#F90)%XYkU&^egs?aXVBQNDB36r7kwrlfQIH}akV#NU
zKoNZ{Q?*sVt>T8zl4@HWwUrlCRJ3YoYwOzn#JbnEYW4q}JNH4bR=WB7|Nozl@55#8
zY-i5QoH^&roVh3BnO@@kUjC%<HH~CBBkPNf8k&5{dVdFv(8&I)>I$x=g~@X37<<&5
z;YS@aY|d5L-IB|!!jUJOzp$|Wn+pnu9a}hTMD;QFH?nZ}&|$}t@D~<OM+v!rko^}g
zICbY!-yBM>j`X*e6aVN`f?bu}KY3zgNG;D@=9|I_AtxknnQxQHj1Uu7J3f;irt^DD
zy0|0xP^8$O?+C_Up?>AQ1WP*6X%*M0%Gh`$l8j}3Zz5R6_{nVi819YtNhIUR!kGGN
zQ;>cgPp*rWHEq*He~J2N+9JNAQ4xP?3Q+6wOoH`!=yx%V=CATdguiXl6TO7(78ZFO
zS1FgTT;V5rDVq>M5`%?J-fZ&SNCs=W?g6Gl4bQ8a%=Ua*7$cTJz2b#trk<ky9*-Oq
zDSX;>=n{g4m-#MmP2`BE+w;z#(K<2Evs(*2Rfe%?d@*LX6nbQ;yz8TAL6$lRX)V8t
zslPS(e2U!vQFH}W$rssCU0(MwB#QdyqW9uSBH#Md8Yi##S+wWQ^Xx+EY%KHYkwawm
zC(-ezZ_|ZuG==#~cF=GBfe8uo9o4M5Y@;Z?h5EZa66rwSJJe>+ZQks0XPNKx6U?64
z>~*MFUaNlJTH`tS!gk13k0-O;-j?c@ta9^)l3vSvubW_M6!Gmd0I-($nZSb|Lku1C
zSmv)oejI5|zOs|8ZeeBSPg~gT2WNW9TZY0d%zkL5NAP~dg)OYEWv0h%j3_D+Z@GNp
zlW4Ex8}8XvB5Ro+_m!O*E$md0<5tXVVWQ2TUnjPBb!fpZj=P?2{psXVZ@qh)!9i_F
zda<%&`AX_nl%i1nWM;=-^z{4_%r6J&tcxHWv{I)A2kCb8WVU-2aqAwrBY8%wdpEJg
z(1_QOVD;z*>2RIo%2;3ez_-V-yq())4_b6Xa&guGdU^8NtX;)vnt1&;&5Vzv{<|3C
z&Lp84+Z!ylGa~Q&)atUcyjz?WCNR8hswikaH>4i-=>&75H+tgJCO>&W_ZpgzcR8%U
z5_NK~!)6qS8r!EOAn);JYIj>8XKvC|O|l{H*u<DHHug{nGTNjG<mn-J^r}YJu5p<d
z6+%P4P7k1s4C{|d?#(;N9&3i7{ns9wKrOL5xv*!$uz=WZAOU5n2Tfgap9vcV3VTDw
zEU#gZusPOlY`bu|{GQMHB>&d4i+s#y{gcCbCFLcVZ0uaN%wLPyBM9q2oFa-i!q+u@
zwG#gTW<KtN2*oUq|A_@Sreex=tmdc#%5YFuQwaZ*1*2k*QMUNRyzj2r=GkJKSEsfm
zPs{JyL>LzI6A9L#3ca;zt4E?uzEcSJbgLKdgEsgqZ>`wuiHs&+({8*E;N#f_T*PV;
zESie$f@z$@Dnn;3%C+@Hn>U!gtDD2{eS^alC|fs2c%b0q@ALaw>ft2oU15ozCWrSP
zUdHb;J*wy<*tr_&A_G;^v-r7r=cgrC^e!kSyG&6}UCz)W<`xPT+q|8LADDCzP2ShL
zAfN0AqZDhDghdsgZBM@2d%h)ZPR{5v!cx!4bzND5r}h~v`7_Bk`<&vb$HM5|WJBLF
zPj!URN0Y1j=9h|Zo37bFZuelU2drLAGV}GcO(y<+(0g)w-)~vs5qW<u>(_f*SRO;F
z9$xKl)15lbbV|OF%f{r16HN(COro0jx1)qQIeA~fYZKH`2K*I!T_;tTN~zJ9=VMKy
zs;5bFuv$_-nG>ua%?&hS0`#j9lbf?y&uQeBCZ-{g{-D^4guNT=-3I^ArT7({(7a_e
zB$r^C-#EpN>yRy;M=oJ%fx)H%T~&pq<>b)9F_s#bTv)in;!h-ti&9O3R6@=isPF1l
zg0E`e2dL;$=}cyoJ0Ef@9iLT_X7C)r20=Uwsx69<*n?f(pxmzf)Xv<UO(F!MasEv$
z?jXQfAWA(2QKH}PP$gdFb1r+sD{^125T3&H4x)x}h`*Q)kkcUbbfXo|x=hQV3Nq8H
zcs3ErVL~c@kzkc4X0XbS1*@EjkZfj^jR+gZvjZQB=(*ypKvq?rg!mrfR*Lh3PE-IP
zxp_RDuqmG<=+0z)>1B@ChPEJ7k~2$7cYa)2ngNMbRNlkl1C!O|Wr)lwzt9r>c0ODF
zFzrQV$Lw-&@lPLM^R<v_wFADv?~{8A*(nxZko=_Llnk-RmQ6+M7>mzNZm6uv;@fRM
zvl0^_X2#STJNH!1rQI~sbIEr0x|a24*#6U+=0*-afjzs*Uq^)eZ3#O)`G>*TR(-LY
zQp&pfnt6Mhh3j>=EZMcHG(&k!a(yW~!Qvz2{!&(Kk>T=_QkHM=;WEEJyUbE&?Q9sb
zH<IK>KjZ6Rb|P6U4q=rnKc-K6YF~6D-P!p3<(W=}CfavxKl$<aLW?X(7EH)Ho}6t~
z%<i?&P8NZdA|$eQYNJ~p;r5B$NW{J7=9oImlv$fgqK}UOcPMFe9|zasXPR_1C%Ixm
zW#8)vI*Jx%n$)^l5=n$m_!)9fH5=l7Bdl<GvS4Cwce;s*(-6xap}uaSwz$Q!3%7Xo
zVi9%pLY%qUuM6R<h2(Gr2J+;v>M6;E6U*|*R1@7@Ln7&-sxi53Vm>EROjcb6iSP#V
zz83G!kS6BT7JFADiRBCt%$-dFN-7CuT3Rbg{(9ojOfhw}-+)S)H(`*Hy^fz`iCTI6
z7&apL-Q!of{8$4P<Wx7uA~(qWWA)^GPku0#)fS5iliP~*qDeiC-+VAoakuS1>B)w1
ztRjoQAN6B=GZR2S3`q`;Uq)4X_HnE?-T6$Sl#ZzAif%WVb(5_Gt2=2UOT$thL<3Q>
z`+>rkAZ8Nlw2=LiTwTM8i^+Q?-^LnOAFm3QoO&lrLpkzJa_*$!V)dp;(p5?Ny`|Aj
z&!T!Gxoy%4i@cgFn>;%6?q~p~8TgU|$%T_wmx=u*sjgVr9nD=`@k<j=L`XnO9nHk$
z&&&Da*%S0pSv`TBpZ!qSVwz4KmiJ9yyXmfE#gzFC;zuE>Py=^=dYAXugT%52LM{4P
zp{I5op7;6|%ksrcPe3j7AH2!Cyk?8{*i*A3BG%|nCbK+|Eg$K@%IjW<1rRQIIY$26
z<kvx)sZ+&<t3DI;GqqsYZLp?K8r|4=GQk{W_zJ(%w91pS8gpgOo~(QRLOpHUnav@U
zF(vl9!Xvk>^7-{qS=W;tlfjpQNAzT6(RaS?i?@=GG|tTzSB1UKB@wOSij5{tHp;By
zS$<&xT1b7hu>Dcs`B+hFFHrVw@b|SB2zNImioBza<tJY{aYS;$RDSg9n!~%cR_G(^
z7o&CjvO_A?dk{xK-aPPDOhekeNZIycWw(Pja(eaGcpe#R<b++U+cNS+&6RsjU=2BH
zmLc8U7orw;f|@BS8rTpk*OsR>fW)(Hc~Ju^%2KDAa&~RpC8s9$o}8D<b8WxlLV$c8
z8Y_1h&#~nb4Xm#vz9!$)Fl<})o5H$hk;X%H`4n9@L%4uH1^iCM<+dp-zXz!^W$G+$
zr_=&3k%MuY$mFl4Xx3Ysy#AEhT;Vgbe9)gj*F28NAt$lo<Eq2D<VLTqn7e9}iSyA$
z>!_=p?23_L9hB9hS64g1b%*(kf2+xF&%Tb{(Pzh!)9HV0Pr7B*FuIdo^o>RTWr(k5
zEQ)+L$?2x)*hF*MRgOH3_WzID*w|?&z3Fs1C_>K7@UO})m0x?C9&M4M<+{^pfqN#z
zL5W-B-X!liogUju^n|kYBxhtK!hM{HW0f6;<Y<$01|5IOE2B*5(rScHb5_zu+*d%@
zC2d{ZQVprC(0v6}N}l3u9>`Xy48I)jFSio6q`S^<bW0y3K^}Pkd4K_ad+iKb=83Y5
zU=l@dxn~9~aeJ-sKT+7>UM4?yhqhRWo^r(*^!99K`ECXTyAH9dQc*c#CLL~xEpq-$
zI@<Y!`Uy15<(==*ew=@_-2W6nTERa_%BXXWU&A(LQOB7*+>NJ@{@3L}L+Y%IplYDz
z=PJ7u&!$;)P>xz@`Obwr>QSt23hCJ@$GuM<9`y&)RELdy{Z!#O$m;kM``abJ48<K3
zPua>=uTme9fpLThgz6PpJ)4dj(Uu4G@pshk$b)=9==J~$`z^{KBnaDd`~~D|{R5%v
zBK{kB*Pm$Rl>Nv?l<Uv~NE}79#Zc@MY&G>7dmeG<40voe6DT|fFkw8U)2=2~0_kEC
zG%Nh%ujkOAv_oc|Nsk@QpD_KxFxqV>#P<RihE&H}@#xAO8t7vHngt{tlS|K}wHCiX
z-ghRg_xQs|hs;wC$*i+zg+-LCK8s#$sa<mKS+q7Q4mxPXlfvWV$%45w-xFia5R1EH
z?OZy-B6r9YbLqR5xLz)tM`u{#J96(ly3kTr%5i7w*}lAe@!2$sdg5Y(EV)>&JBLDe
zFPFERLmMo<M1F7%oocz=W&M0QJ&!vXem3~*iM7y8x}y_0%^vdZn@>-oN@kr)dz3WI
z_R^#gw~E{ZroVH%4ROiOrGs1-Yb0((-46N9bLr9jr<vg)VW{g|0`iLIjC12TWAIeF
zi9EUYT-vYC*Dx}<7@3nWo7m`agbBU*oC*-qT|kG(X$xr2Dovdlg$_MJA+_qb3yRV4
z<`BFKw$CTY)eGn@S@;3{i5zquEgh?d8hRGrvx0e3L(LGi^+dNj(J8?^r|Gm6UE)>1
zPF`^y?b-AQ^*v4SOkl%`S+5nICVX|jN!K{6P2<oDgMn`9)2#UL5pG)$KicgG!r`uq
z(+n{H8015sfi&YfUWWdL@m9n+@;h{VD~+TOZ_*8{NjK0tY#<1$-8O`}<9eBrVpQyn
zJrvSN3A&?IGo&RDY8aP=Fxs%Q)<|{)VYTaG7ah+T=_Y~@NC)B3u3H4yYIBoEKvq~6
zB#uT>g;>{pF$#FxtCiJ(!q_KxLhniQ(O3Z*%febO01~~>GsNRM-tRNBg?yK9@x&?v
zTOU8@HYODaJ4Szp&7WX<7W0_uHi-K5JM2g>T#%e9T-ED8Q;_GN+`F>jd|J@d0VH*g
zTf!bE&=cKb7iSr5c<<0XE5=acj3j}ub6K6AF00FtOpIhPM$$*;5bClANlwi6;#~v=
zV5^tvi4cs{Cs#H>{@%a@R=)0$-bs>aM&s>VxeX1AD5gvUEhdpvh{!?UCCb+Cs>8r(
zMFS~tRI-%@3|JAv%`?IGQxD?sBs>hx+9&5<K)ZOCSpEhKqWar1xhBIpKJywdVyyXj
zU`Ajd&t_Po>9=IgB6_@q1vx!p^=sMywu2J7(RDdI!l79P9e87z5gSkH6B;v39is(~
zFt^|c)96|RY<{n%LG0Uf9e#co{~uE~uIq+*;ylZ5Kw19#Fz;iC2^{Or4H`Qa6(P~c
z)5K|ntkN48^@;)N=w7Ze?*sI9c8%qi6CO;-K^Yb;ip4Q<;>Bfw96M~pksdFR(-&(J
z!Ml2a1TxNjjx!Lt*8$P)qEnhT#9LYp$uKD68aMEK)-eYBTB`*c%q;9d**#jWU1+$0
zy2i}3<`#i?Twv0D)V(|lBquBltCpy%&9r8N|2}q{U_RIzUts$uPT<j?fmYK12^WSI
zpgLV#X3|q~@P)MJsB;b5`a9+{$28kof-a$HeV&piMGFy}kRx<@$<-IqyiH4JR9<r-
z?R~a`#CWM8VRC}$ulP+!dA&?}s#&;B7G-KT@!N2=8`tSr!+Kmgk8=lLCD3rkB{<`b
z&I*{5>WK|~e+Z4C-=syfzZ|!O=2^T-p0b2iusAZv*W_hOXhWv>k(rbfc5h0)xP-3H
zA$OZ30fO{%L6|?5tG`JLhP9zuN-sZbj8Yl|h{!2Zhb`w0qzB6x>Fed=-=rl?V7_+S
z?60{AB*oNBPmd26Fw$na3iREEba4}!EQ6RY6SmgV)8!|DJk(ZnA9;AfyqT`9<Mp6S
z!|E8U>^AH}G<$2qc~?Re#>fxNP{#NydHzz`*X=+B7md2I`9hkT?G6CiU2B+|GtG6n
zQr0H#T}peOnn3b;fn^5j)J*~%mavGOATI`J>*dylG6bqi+W^5PX)5jmsG2)p9ARW-
z#L?n`tco~%sZnoul0dQzzKHf1s9)W3un&z$`9=^uvEn!{YAeM8m_5OD(8G96qnncF
zT|@_X4j{)DpXtW?$m=hnd9|&GJL*PHtw-ws!x45MbhB%iF1xNAB&$INb+Aqj#uvM8
zHf60v0TDL20~LsLw%1XF!P4&-yf%bjx3<EZcHq4;eQ7qX%ked6cc5UZ1??h?qrSs$
z3`Qo^U*iVaLl^Y%avVqFnmu!jSg;@tvGGdRt-zwjkZD44G!O_hy;8)*pn?hvYXyW7
z0E-oJ*D_k=IUsIroFNy<H<!`gbc*zr(|Xz}PhL(do95~BDL-UQ*fls-iI+MSHLRCn
zE=Cp`P*0C=o1Pf_)H#L^if17VH2rAaiaZzWj=yf`#tB&=nP-+}T(iP>$O;S5Ui2XE
zZgQN$X2@WQ<463o2t;EJ8g&4?Rd-dRFK!OvsX@wiK(MXgO)2C#l~^x$TJf}LD#Dl<
zc@F8L^H5%=8JP|^h_~Vqn5W-j3-6Ski=JhHP-Y8nfL7K&rhYjP5T}LQK0szx&~sg(
zV-SE~mBjT4O%-G_;t5Qci+Ruu={}tCPP2Qk+(XmcGisMX{iE2|ytsn)sGgSz+WQmr
zzmH}evY9#EkafNpoQ_I>0azDJtiyZT4h|75*rRBszEW0QObe`dscg8I=41ZOxtNyF
zl)U0%I=)w2m)5ndS*~MS%&{4ZqgI>zA7s-uId~<lOdKq=6-+>nSI%nJVNq7EOX>&d
zo*iYWwaVRtxW+@LwLZjyuBFxrH-T2x$t^2sNzOquYq_U;3>2STNr!jW>2Zr>d5>}C
zKgt=;AYD?j?<!hX5fE-PVsO(fXnZpe?~H#0@lv^A6&=^hP{U1L3T5@mI5^O<DBGGs
zg<O<vjg}XzrbBzxWAXSaBWxY!%tO&a0X9O3zpnk>)pR4JPst6r)>QdjLCbT*sfNAu
ztLg8Z@y>(L9%X(vs~G!<vE8iWES@b_ceC<5O@Ep{#LMON$d)UcY0ti`pm@D-9SCAa
z+lTN|Zy9(gc~3Jvw&_;PF@fmoJjX%LHHk2@NN#xhLAO=Y02p>_7U&YoHh4#yH}E1a
zfgZ<)i{OCt43yO)5EoeTD1UGi(&UEGi%)Hir9j&l$tGLB-0*gD(143ZG_MQ*ws1=~
zrfE0;q=7CLv0zbYo&p4gHnHOOThu?ST(NGz)YF6-e@Vmw*jsgdlb+CR&5jwY<9Y?l
zVR=?=(+j#D%CzpD=H5`Z%q=883fj;`;-z{q3wttjWaq}3SO=7Fy-}^Vh&>7ItlvSb
zNm$H}qEG7)kAVSb+?_QdrkQ}op#%B#$ZNZrTMEj30%f%%)G+D?sV4i;5D;;f`H!No
zgZSmT!4ly50StUVL<38qqUI<-!qz}EU|qHYmhLoC8VQZmdgOIR#z9;UfQx#;>IE`d
z%C`*~dI+0!$c$k$G=Lc1TLDb>K(7})>iU<!Qon@e_3A)5-K%v_xZAM3aEp0F>$)kq
zrH55=jQX)rdG(~Y%HSvNYw~BI(_dIMSNc7za##HztS`s*wE7kC9VU8&svCP+6I`_|
zUG+CTt)sHZttKk4dnm$468W1;=>SWNm-W4@>wCq^HC5nz4`LK+C75{!eNM;|*V0OB
zPk~&$76$+w1@eV_D}R_Cd)>|Yt!DhZevqCq;y(t$NUQ8B)5PNd(-wfCd*p-pR&N}I
z{06~5OxWQ-u*)JADq$kiIEV=1?M1z<bE!U~+R(?UwMa~EXrnVSNR-OA+Gvf=SlZXB
z$bp{CJdE-rjP81i+ir<mxQ^C>0pGKZK4GZ?@{s~-_`zc9HT9ZeUO#Y_pjfHQyqw;e
zmx3yq=#5Fssde2ToPhnT%qp}BGTVaqQa6za6-16Iw4Sis-qI_wDk|b-pw|f?8H8~i
zg3-0=5ZXfuVZbXVf?iAIj3TS5$<bOx9nuG&Ji=Cltq4=lR8l%b+=(L{OFoV;r5C7<
zYssMLKZi%-Ey_wEEw0x}0(l7I2vZ1K5#lz8okAE#=+q-0VH{zqAGlB}UYtS{Kp02p
zOhN&KafFUW0%07XGa2avk&ZBhuoa<J$x;a8T5UT4`A`Gm2;<m+I1Pv+j3Z1TY(?ng
zp}dYeK;Feu+Z1=5DJX~xXBsjP#t}L_Pyt~aVG3a@Lg!SZqhcIkT<@n)&(S+rgehHK
z=jS4>^AS4JQ4e7pp$mGCXX72$1)Q#Ec%yLjdukSXng}CW*=q~mTk+nJE~NE_t4sw4
zJx_%1alE&M?^-$RNSDFXyH|(hD`eJ2n%}pz3QON2b{nWopCHDU-W}8Y(VYFZl~{ky
zUJsU;CVGu;o4l&j8j>9!fNu0Zly!xCs?^H$^p-$n5Px!+e6!Tb@7n>o&>hj~1OoMP
zAd!aFDqp;c&dUi{(36G*od8^%!See4R&hljFJ{b&x#_$rVZ)|s<j;vnf78@ysFJVu
zw+iy-U^ZWNYN9tIoHObn>lK8hZcVg*o_yhII<N0STqVM$UrjOMwnT9@2e*Z8g6dZ4
z%J~DVf~Njsgxz0@v7?O`D}m8*j(RIr(o*cr#T?(LpHY@o_I3-q@l+DX*OIit3jTE?
z=8n8&_Qe5wYScgV-l4P`n@rlRqXpx0h+hVrUVh*ltqR!W<x#>etClY$X|biwkY2e}
zVX60I)wgJIo|<k7m&9t=jYC`9k{D&;4{~9-Rc!IE%XQzP_5H<E;+Fv6&7;u~Y^PpD
z_$qXKRk+OW-#pVJ1DE-)N;=SLvUpss_%?0u$o?i@pFQ*+DfbVwX3&@AuuU`<!3h=C
zg#-D~#P1J){S{%6Xof@f7;YU1->Z3sR`-K-E??Y4lNNtKuCBD^H;Eq^pw3JX_-HHu
z5Ke0~!e=?tN16$|yGV~))OCPkaJY=LgQQW7G^A^*nwHCPsCw?RgnbrXA}DvLp58oR
zQzg&%4qcSLzFGu4e=-WiFxrnH^fM+z5~Jno-=Pb=M2HyT^9N&~5pKAK4rp>}*!S18
zxaAII<<D?dj>{J1Ac{XUBMqC4a$K;`{TYb1^kK|7xG*sgbXg9Av0gj65A&9^xC2r5
zobZB$e!mSDEXtoEY#_=H2rpO+q(w#t3@=zfX!%lILyP1)*U-`J>RS57iM#%&FI#@=
z&f{X6{+Kotz4^}=ibj3$l}i|kewDs*x#?{>IAc|4Cpw)Db~mmFB&{0tzhN#CPyb_c
zk$TFQi^z6kF5-iXxri5Oa}g}T{fxaxeMf#UgC0w7lvQWYdM$ZjHrke>x2LW?Wz!+f
z4@FFlc#j@Mf1u4q)iDvVf`c&<vE<z|X<l8MF-Q=);)n($^+|Z(zU*@hNbl3Z*)0ZE
z+I~bf$Z@k^KYA0#t012a8zkQOTz&;G>|{R@2XNq}x0MJJ2*vA%>__}H8rY8l8x!nB
zfsF~F!rfMFKhk$xJ5Wcx3>eyA^s>BbHta_*H?<+E%}&~Wq|Huko$N>2?9|rDex#4Z
zI{q2^(VywaVZSilLe~QG5qSo%&`lk0#gjH4iG6?x^AXu+%tvIYyzkF+l8dunZ9Nhx
zne`W1Nq;V@|3Z_nZTv&q5g%`cm;XT4{uL8{k6iIr`X0SWF8q+5L9ds4Kcwf=Z_9BX
zVYaVsU;Gj6LfvMAqY`r6$2iSslDB+Jr_dFhZAPbc@BJm2jE*YfGt8K%(@m(k)#uxc
z3i^`i7!VkZ#HpA<7>fwP1VW+hP5-9Rh@2Q2jpoo{bhVs1hYq1@WQz_impkUr0U5G|
z8EcXlVThY=H`XLE!VH~0G44#Y3e%jX+TbwvXrQgFNj;hf427R(P7*&e>ALs-iaCi7
z1`3_bNgVbPoMr~*rPh4N0OWTZGAA_!Cu#qTIZ0_dRA^38<>(L0NF3pRW=?9_42|Dx
z*R`<xB6E`JhsHXYlT-nEb_8=0Ut?hZBXg1%3>(!yV@@JHzZ`Rtf|&}U7&l4Kxqro+
z#6vUC7nzfI3{!RlbCQ6e6G|0n1<7i2lDgH{69oGrb5d4JZ8G*Gk+EE^xqwd0B6ol@
zLkH3ZC4Ren_5xaMiCYg@lor9tLbe<{mORX)B;GZLfvsO)Qc{;4Zc-u;9NNUB-V6^C
zJDHTURYjYW$REQzV^W$I^i-_=dy|rQ-KeskH7ODFvYhbGH7RL(mA-?aS7_Qu*H!{;
zt&>Sfyn+*BAoA~+lvL8pMB1bzmK%=nS(6f3Y|?$SqfJUA8Jd*Dcg)oOBa@Q4!Zh$%
zlM=t&qz5LY9@S)#VO}1C5=$YcLW8$B$F!^WjV{{$w`@urvNs^VULrUeOWTyh<2cLz
zl59#@{C+blDcF?6PvuKX=(-&B1Cy3EDv<}jbfXf-)!l@#;)I4HV}#O1CGmaqA9;Af
zydxWx)O}_wza*oQ!cEvC8I{xuvuz~T95gEFSGOFjJs)K9?;DlGRcIYx2*M78|64{S
z(uQ_nOcMA8;!80q@n%p#C!-P<hZ~jDN^Mla<(-rN&Z@-w{qt5O0RxD>?8W~FG6Ac#
zvsH=w%@9u7s-zYeZm6wFY2)vJLa_Co2if=kZL3lf^ye(_qtL3PvM>^*!sfF=hL3k`
z?$fO0KeZ}>qXsO>d1wOeR*PtylzOd_W?B8_I-^vuX^$f$Yt0}E+yn?X8qjNnHAh=?
zoKni>!D1mYtivo8;sP_!`mo=vQeRo6(pIVbcrbx~Z<XTf<!h^Og-xxIBUaPu1TQcX
z9>bZFC@?JCSsh_97)*J;Fx~{qw}?0j#|Hn<ge76Zx;s;3n<}kqaHm$@lVjy(iZ1CS
zTosm21xYv>*HXQ84Q>d?cXF)t1qX=(XItV}LjeTex8VrH=8pz;F-qi%xz>Px(=vwI
z4|cP99N9LO>x$RRu@XK<>~8forZVUf-v>cDp*i#`QyETNzcQ8m*Gy%lN5d+nxt>0b
zPFu?Oz5lGGY@o9<ZS8`gtg!GN6Fah<Y@%~px+2VEM`zz`VreUxx=FrpDJ`=^qc)S3
zS!#i-x{NOU|I1tkvsqv+%lQ}0Wq<j~Tvo5XGM9a2F8lJ#Wh3OYGOL@F7$p~$S@}7M
zQD(E2fI8^H{^5?2RVyO-{ydz)sAcekfa4JvUlA#_Jk&r=j;9q!T+i}mUm1fjI3nJc
zY=Bkwzh;FCy%T(8g@bADvsSaOtZ?LCw8E*zUBdcjJ}Enb%?)l&0-Kxuq^zB;vHqEF
z%8me%cQWJc`oKE9=Ez@=9RcFd&JagsoIdP7hIkl`3o`x-I2Lxs@$QV%i~egkZdr9S
zZIA5BIQ2gt$aJ?g$Xg@bBQ=pTW8H4pbaEv8-0u`Px;diboFhzDnxeGhoK4dr+5NE3
zBlz)89?*A{Z1}N3$ca87Q6sGMmw<z_FIpayBh|}&r>KUhJbCrB$htCesoCOjTt3rq
zDsfY>5;qkqVY#p5cLnDTe61XQYNV3BCucksX`;BV@K~fIdnArf;5H}KYz`-QlgybO
z+2o1-!J#b?Wpc;#$b3tD)LyVRGKbQx?JeJk%(g5(Qoc4LQspUFA9aiBx3b`jNWLW=
zXs_NEDWP<qobhy|q}P);tOfi8KCp7t!T^!;^;cAT+pnD&c`agzPug3~iY%rUf4lvI
zxskjKi;R|8^CMN3aNEbtk6cHsM_0=$bFCBQpaqex{tz6(lI{km9J3%YGlz5uPls@+
zDY!!YfV^u#Wa@Yodg4&HU7;})7aL_f5!G9Q&7M*wT{W68xZO!^4p4OQsbhlND4Tv4
z$sb6mA43-&ttF8dZcb`gWSptvVSdCb;r8~G_SNS_>a5udOdff_w8sQK&c%G#xQcEw
zSkH#x3QG8$$`I`)=s8?*0el;6)&Vcx&D1Xh?DY5X40C;1w(l~2u179iEr(o22e$JI
zBF{UPn9!cTJaUp%h1)J~TEec(5ccgqwyY}LcDenuzrXELi5oNrK3yR1elybVgqwoi
zzJ;@cDqtXb5x>%(<sQiAkvFe3J*@&(3pG|Jo69g+z)F94qcN)-Rm1K^U6M!qp+v~%
zE{+WLRE`EhBDa4evsOm(EY($(t&CJ;>w|1PatA8LxVHnKkh4}sN(UY=pw0uB^Kso;
zxx^og+Jn<KSN_M;f>VaO0HsMpgQoN%37`$dwU6x?Yuur@_AwOKHHJ>^>JA0;w<*%H
zkOs9!U;7vaqlmutvB)oShvC}C&`#Gr&VRqf9frD#!fPM;{T^KV7>a8j!%%+6AQAZ0
z7)FcmRU&?>^SzIuZ%2w`|5cIE?L*&*Jejzv(AkxW;Od9J@D8~tm1Y_pM`RkuRu3Ke
z#aBPTG=6>X>c<h7hNupi2Cju<Uu>9$8hbd?Q22yLcjt?k23dcQX`C8aZSisPg;OKN
zIb_V?Y=f+kIgf*F@PUSH@Cv!(aj*^kX?wwGk=fKD-8A2rW6?31Z47Z=GEIw@Wx+mh
z4gPR@^%;?3aDiv#jG2+*e0>q&^Z16?r}@V3BbG(m*J!>$-*5lmmk}?+Q;`s4OnSeG
zjIcz=Mu;cDM#i;o|4n2X?II4C#TA@`?G6~r>0MPLb^d+6qAvP!_zDU6ig@{Oz9R1b
za`*~w{)(^szsgs>o7govdPGh3$SkC=6ARfjE_y@-?8p##XNa?+v$&k~o^@kn;7BL2
zX-hOznYKocq%!?$4Q;w9nvKgwIX6YCEVW<O-V{BhSiEGooOmNtkpc+;^wQx0dEZUZ
z<2_Ni+;79>O437mH%ANV15L++7rgRN;~8y2a+iT)Klw&1H6E%3-|E>`v1gNwjC&dW
zT3<1H0=&ds08bhdd`51Ui*JsOr?<#mH%IsM;4d36Hk>rs@M~g|s~EJpc6m$m7c@f*
zw&eNWk6vo2C*=p<kHYKCSWDL379H!6UswTXa*y0_TeKiY>@#ugSHzxxYw>g2@4qct
zn~_Vt4}J%{`RySWzn6ad{ES|5(4Emi7P(VSzcV^>;!U3Op!TbBqqk?l7H{1j@hsTt
z?K$w0$3M}&7-2)hw-akK;CTe^s`$`5xzA`-ym+~M>(1y3D}T8>_pa!0x=LPuSF}N{
z+#dBU)geE)EBZ(Q|0xaJfhdF+aAJ>#3i}h2CVnFK-yNN5kuzo0_ULp=Y;Rw;J!)A6
zd}CM%;lWB*hLx_A+jd0P6)5Pn+Rq5br!_&DY-Ni}Od7dVPTd*Z=5gFZ&}Gze$$k)h
z!6I$)wI4)xSmFor+8;*e=ZZX2SM>_R0aW(b6|KovudepVb*7sx+(GFt5!dP=d8K{v
zuIOB9smI&*w@2sGCJ`DS^PyRshkHhUoF`b?9fN@SrcvX1KJZi5hH-p0r{gg|)K?*5
zla)OQj|d%<*^Ppc7S)C05qPvCI~N}@)f1zMr@wpP{xZYweKf8CK1w<6&ud*5M65q+
z$1j1nzN?o&1NgcpqQC9b=}rrYIKxHM8P225FI?QZ!n;PI${?A7&YXJZ%1B!0)NtZ8
zc=XL(l#frtHx<)h-1PKUTW}v%hXSp5QgoIZT#(A1;o9&&R)-$$24JlgI?o+)<wJ%U
z<R^y+rSKV@!Z(gSobsevxT`y({hI|N1Q<cba2?layg8;3b@2f}eG~p$kLNKwx(BKl
zXIHwXK*X^kkvQJ9lBd%YjB2{)dUzi@0bkwVsmJ5$2lp%L@dzlDddPJdT@RN!Sqg}B
zbaJ*9z(7aprohF)ZrU7Oix<5}c27fis<P|w=$_k%8y<t<#&886RE6rj2Clz2a8Ndm
zuoX`n@A|8PR-LAi*7d`WsBLkkm(R}(rY?ReM*03Zdb`m?Isn*1LcN{_ebXObcLjj8
zw?hEZ4Rr>reM`0K@_6<<aHf}PGC)&^>vFohMj)l15VoFTk0U*V-3r(q@_Dq$5SjP!
z)|h?C>|g`rqF@~eP6M>VZ`O9Bun0Gx_PDJ<xwS1*BD$BYEj(i#%C_R`lAz&Ejq1(>
zqk{(5VKfpbR~N$6qfFdT+4t^9Zm^GPx`SKVtLR$Hehkl}_-JJ}K)9rp#qqV9ql#iN
z^xr`|brrYttm|88f!9@(ub+Ys!SsXv?%9HGvKlwDNjr(f|7><Rag?uHOe_!e*9P!5
z2VK#VzZMkMPdBQ8ov;s|sqNra3=31QZW8Qpl)U)f=m@$_?zlHP4xcN&b8qyzd{JYl
zQnZB30nS7;g{g`1miwZgSn3*i%a5Z4mXh+3A4lg5tpjJmZz!BnYI#FWrh!lpxPq$F
zwJ_0sNdg&!d?8Q$Nwhb7@0lL7FZoGy39Zy$zUk5#@L&4yOyWMgXQrpZPyI3=xgPGC
z<7TK^yzxt#WxxBQ%@*(1zV-g-jPCGb_e^ZpGyhG6W6P?MwB30w`f*|8C(o-noBo_u
z4gT_9Pz^e7jIPFMHauvReHbl{5PTmE-^Oz0hfz+s-11?xho_dCK@k_phdzux(Z^lk
zcR(8ue_rluH@v))8(z32`Y75ji%dM^g%=L#0x!H=d*SUWZZxy$#u6+sRYks)F*tC-
zn>^2cPX6d`(G#7G{lU*6E3_lt<6QN!?Za&i<MQ-RqIDG~yxJUiz7;sYNPE6jaBTbd
z(oUXlyWunMx8&YWKvGIZKaI9q<av4jr_se(BD6|sKa}LjAC6-dMJH=08-SAMP<AW*
zmCUwSuEoDA%PdxA@mB3;_O(bK?uU5OW|pXXn7Ovg(tSuy>oy4dNBQnVmx)Zd!DjdO
z)SYu<D6~<zZFquw#NmdPTjWCRhqfPGq}|Y#IXZ8x#qCWl8&ts04L!!fbA%?v-B?>>
ze&})bT==9NQBUTE(Rqi8s54C(N1m>hc1p|Vgy4{W5Zvsr{v0@^Es%e3*&A?w*8Z%=
z>L~`I$Y;6TG)@jWX=6QUZWMRm=^^g3a!=iBAdwyID}3frEZ9pk*-2TV&_LC0V^u%-
zS|+Qi5QT@ki52}m-%TtjkmIsgK`yz@_S^cR{$|q#?_npO%O7m<190_P*2G_hFEs_9
zb_zUM`?MP_aQ4&WUojfO1!?xwu5QC<u*{=`r`f9hB1ikDt5Yw=4tj7Ef~ntWpKRM1
zfg2EyTp2iljiX#@3y*64=FS8GzF^86^q)6Xz;6zIx-pX3<ToG`9}oZ#j9g&2jBd<+
z@TEhIapdhcfI54dRnH@B^LD0i+dP;RU9VXqd4=&vi+bW&ltE`xg+L6xPrWDPhh5kP
zi~Q9%oF$=KT=A#C;VgO6_=<xoKkaaq90;RtXos`f!PJIq)?kU-<O|t2Hrgc{a@Z*j
z`PFJ)JMM$8*~PLTmtAj(4()Ijj<nMrYQ<(xJtAMvW#bCOF(C~N2DZ@rH0ENkNmC=`
z@!i<(Yc4fj`^eN~zV<QO**k37Nu&*sWcxqx4%;jjc4xH~uZJ_(Db}#%$p;E&S?XQ6
zFpsThvb%h~_Tj;EZGEW2`FQuUl&wFEUDrY)-jg$9T9#=o#_cMYPTzxk4NHrpHoW^{
ztEc5V(Mn|tk7}1BzS!bvMN}b8*GF1YL?^_cg9WP3$HvdBZcGc;x-6(pc>YeficZ3{
znOhoIJZKmS3jDJN0=3I##^J0`3)RmPrW&qIzM&g|us=+Yp6#ti+8z|}AXND~aHygS
zV-#95K{(CCYR!b&gfy*y+D{wBQ!nq`NKc_m9Q6c~@8+@MoIMvo@xav9F9QMUQM*Wv
z=)vl1)p8?VwO7c`db}jd4$libUXok9&fYGGEAQ{Yh7`5HUAuOa8F?|Lk3_|O+phph
z91dPJHIefqgG<UrGVU{r?<L`p^HAm-L)Dcfli2~UIeOs3D<djfb*Up;y#x6qq86zx
z2UdV#LSNq91AOEp+!w>#BsVvfHy-FM>`HN)SBZqovBJ(=Q|zrBg0Y%P0u7P;49BoL
zEX$tinfSvdo*AhKNL|&S??bTo;qd%GJ&9bE-Dg)mE43|BubuA7l|^i19^tlM*B`nn
z8fh&BhrqXld}8~aBDM`jdi~_m5;ofs56S%{>@JJHDc6-^RjM50KUZWK|G6rw9sYB@
z?v{c-+6j66#Wd4x?F(0&_W8bWaf(pQdbsLqrYM)q)vU5WeGgZ6feJa%B-ho#un;jG
zbk!8?`?ktelhak`Xx7^k^(IOtYwx#OK8|KR3Pk<iJG&JV!;*E{*==`GYofb5IlJZZ
z9>A;>$C)hc>{elJ_2%=Cv)iIW&Tfmb`GcDl66#!;{W4hAaT!d#DnA$vDLqCOjA4~9
z#MF;rC(&Wr)$J2*seva-<kGS1VcJ7hk7MIJ^;+n*Hm|*99NU4d>6Z2poDHG9UNKHh
z1D~|NUllkO4jjwAtbNj!6#dR*Lk4;3W#d&<{5DJj4^b}!E@{QDO_HvueigoVa!D)p
z!zJxvPv8Qh9)GnDu4$`1vDLV6<@=0Z+LVdb6)QXNOB;H4O+-5RrG3QsrM=hqrNtS7
z9=x=JU4D=8OM4Ui(oUDZp2&Ljx-Kk{_ThT1iIZ!!57(`E>YOM<mSP9xAqRELmX93I
zwpqMXF0Nx0mMCh!zK+#fSAXs3T2TdE4kD-yU)73yc$UYv=E2zDFBj+)s}+RZqR`Xs
zp!g^Ol^=U-ywAT-*!L{KvtKT)XBXDYU*j#h5L=@n6u~xJV1?eZ1dA#BBLn<#BS+rD
zU<q8<ey>v5YZrkzU4Z6>bCj3Glh_83<2{quP%k_&Q1{#N<w<O;)><aBZuxJS`8o<f
zGypFxq?~2)>yud-EtRV$v!xce-3OD|d|b$!bpkt^_S0Tvr)1}c<O?jdQ(4|Ca4Ji;
z%IOVocDz|GZD1vtIi`^IC@Zqz6}CtAR(6;}S+Yg$ZGdi<8Mu?Bn`FTh)+5t7R1MM=
z&SWkA9XWjpn?k8}CEL6Er{SzY4NQBI<)6s?Q`oWAhtcE>r{I*Tkxj7pb#ied+iUR+
zvi3x_4#V;Ii728jy_HR6bfh^4@h~OpaEn!ICiS>gTVJ4uqLTyr?}keQ<fn;=?2%O`
zv66{D4{;!&N7|p6IDaIh(%Q+ccsQ(rvU>IpdZdLGrsHIG`=*mHvKBeH-8z|huzDWd
zp7nLM-`X^t6^>IsG-@=*?mb>(u;pV-nqK#<VH#O%(iD`qRJz>i_8HSz4t2VsTa8*B
zz2G!9!Bg-XJ~?-S3zh%=)1b1ecjRlQ>Gl6doqoKFFUPCCq0|2$PeGW?U$gzj+_+1y
zvxpKB;q6y^gY}MDLdtEk*nO5--#&LXG!Xf%v)E&@a31U9k$twmF$P-QBaffQ3Yx?d
zhE~ao!WR6+80kh_^+>1(VfR6v3-k3mkX=;hxkFKws!P0~+b{9DyeOE;AU21&S>T{i
z5f~L~jA4;C&WwmiV=$O}=FAAmYV`GPXG$ONnP+Xk!6!%A{NpD7i4r7yWJ0dPqew&-
zLIIn9Xwu2gLqvWmtIuXv7ZCiZmM6d$bU6aitIIY5!3OwNhb(&iZ1`|jH8SfQ*6%26
oIrMxI&=T2L<f(D+2tEuF^?H-ev3^PTPVmPube?wJe75y}0DpM;00000

delta 24295
zcmeHv3wTw<wg1e{KKtyw&n7^Cgai`uAOV7eHwY-51SIDKh=D4_2ateB1q4B)0fY?r
z-~=oJTbW9G6%gMQ1zOTts{>j&K~#L!Ypd0I#cJ!TT5PQs?r-+&K(Kn%YWu(c@AG`$
z`PQD-nl)?Ita+@N#XrdA&t!XJN0rx*i!AcvPO~rYpEN$$MNMk{{Mto3H`08+r!hF%
zf5xC;gNB~Ep?ycc-pD`otjlKRmtV3lf571U{=<e38Z^A$;QRso`VS@HFU;N&B;*o8
zt{QS|^6n=u>qj@5#nH=%Hz<{`HncDHCzyRJNXL3lXO@7B$WHZMl#H_o(P4J?$>}Ze
z@-7`OZ}az=h26<R2^87pDpb@SXVDJap|)o+vbU`~7Hy;A{ddjDrCs*+j*YUpMbhfM
zE`(cYqsCcjLz$ZvC1%>8{FwY(LlEDk!e1CE8Eg>GR%Edw4FQ?_-3ISBnZ!(F^Qe<w
z;5KiN4q3L;OJvI^A)F-o@F?@&h;$jws3tJ~X~(9E2(Z+94k}Az@QCyL-7!T`B`bBK
z$$XcTpwTt2#G<S6U4Ew65wr5rWewt1y&RMO-QdY_;)R&CloJ0vYhao@NW?qGjFIB!
zsYqw>qG$cuueB5Qp<=fR4U+y&d(<%bYE-lJ!w_1YEmz96b~kQCr>}IIL4UKXbCW8(
zt=zS9c+>{}q(8ywVz7LFo|8G6XV-gfNAPMG@uJhX#mb4-237DuL^C6+-dlt8IO6Oa
z8EyU+w<;@G&<Uy^*O=TAm#14@{X>pfI{s&?to?gyUFp^X%PK3nuhu2_{{H+`R^_T%
zmqqJ6mRav{(?9C0vSpikFYd{x_)%Lcn?CFBaMwDw>3Zc&enqULZ!~9|6^*|VRHt~a
zx=vN8#HW&#1@Y10<E;I4#Hk!}w|`Ttlg)0?{phD+xpd#|!?9l*bc6pudJlT7e>i<l
z=BM=<o3#6Zwyq`a-yiY(4>}E|<NeaiZgi|)l{qc<jHpM8AS0EU&-)Exve7zDo*~Mz
ztszy6h2ioOdC0eP97mdxghw~jIMH&);-`oBkgnnbe5ZxwPZv9~tvvsNtiiN=_vWmz
zls5Z^J6F5>VVzmt?^k8#8063Xh1sPJdnf8Wn!!xz-;jNe!T;n}<qSVhM(VxQ=q?6W
zNx3CWgaP9o`k&Xi{O?v!Zz?9Ewy`o|qX%r{S3Mz3O-J-J$a?s_pWfw0*<EfWzf1fk
z*UFm`Yw(;W5>~U!cUQ}8E_WL|JD*46bekLRiaJ=GyP9utiPPXIv59vDe*B&01V#oi
zoo2^!5Z{=KI=1U(u{%TfcYkr0GJ_oSZ|zcQ$Y1$Sbs3P!_i2J%6ygU%xt!{kcFikf
z4~9wd8q2MemXpt|*p_=O`AZ!yWB%-}c{%JCI><3#T@q%MV9n3{ZCz&@<PJYQcZk7$
z=a0#)cG(M7(BJYm{*AelT=q;DeAYjjTjH`O!{AeXSzb<Oa)Ty33flJfkx}MomEh0K
zyUvi0i`hk1x3+hOc@$F)uJHWRx}EM!)^U7_zpmTiQ`ssDgh?wk0w~VVC|H(ms{M4r
zO5HyrkoC&28WPHx7*}9*E+oIz$o4}sMfuhsr}SG@y30SBpGB95oMLMf9VVt0TW9(|
zEtp~O-}*U)De?9&YvS&Emp@E5c8?qKUcajQ)i%2wwL_!$wcWe#{<wShG-#%Ro>>O(
z=@0K&f<Rr*OAVQ~`?;PEQIFNdqCI6ab?iZl_&ZC#W1v}X?@4KLdQ>#@w+0*h+y3U>
zW$9#R)N9ilBEoB9{H@*3^}dkWY*5s5$i0?d(`P(=#=o)8rDFUb>oiLJbIYm?(#yZI
ztk96%{m087_Qn32Wvl6|-3$9ZZf?l$?z2J9bYw=oXPfC(yrM2>Ilq>8e*WODO*JE|
zd($`Md%iciYYAJhB9Qt@lSL<VBqm=a+q!MQ?U}ki_pi>6k@<f0=*&VgLr1OdKq8Nw
z#-o)*HO^xg5WG&ulRE$E(Y<p80o{<HDLS^Y0#il{^7H-2N0&MLoUnl3>x?cg`;HFD
z$$se>IYY?VIvC}*y3zctZge4!*h)gCuJBrjTn$y@a17;%VbO2<OV22Yvom#Ye>pK*
zvXW{YSBWCBy=+^VQRB3b!^VYaX=wLY{k<CBe!DUK+OUZ$ylMp6Y|oEzfBcxSl=(M|
z+3k{{IwKz<){VC^{kfIn48GaFuQJDwKM?8Fkfc&EvDzA$%a2677~5iTOoODKX0uDS
zx|Ix+H|?ype7d`1Rd*`pPO#eLkiSNP;kExk%*1qs7d6oc5Y3PH^TrkyvJZ4}RDu;p
zmj``D-VfuDjs01?Fu^J;B=71tRg}FGey=*wX7aYkn`kX`WjEbT?6BB8(HfpEcSQo6
zD?u##lXz*OwW37+M#ohaVuD-Q&XF(ZaKa>ktTeAA4*ySo>iEYEe$X$go|nNN3TtfX
z@Q3{!)sGnDXJYf&*17(nGuu_mpKIdPl)V4g4)@?*VnlmkI(s<ZB|kek?ai%*;mKQE
zzDLJjQ@+(b_~dkx+cn-e0+pTam(}#_jMaleaOKM}@?nF=ck0aiR{zGD9@&djC){gA
z88q>?*IUs)bC=z{+~eE)muiOCWT{pMVs0<1r}$AXtFwRpgmJUw^<g_YKx#m!yiSK%
z2-{#?rKCwtkZlQ;Yw|tWR;jv542RYDS7zalA(F&@Y!;6uPT|q2;XLXM!?3|JAvu7#
zu_EU3PGa38tHg~C;BMt5Ji2;;|IvhrqT^)i6o1@A=Ko+~SFwGvbuKlVj!m{G-H>l?
zJd0(r5n3%q3!&H`Q3O9W!=H3kbq1TN#dH6qG8&y&<FG0Ip0moj$r!YWgf0e=s}Es9
z1Mw{-i3@Es)hcW=Nf(V)#2tRN|M=ON8LC+GrKse2tSy*hN!LI3>^y@^@Ry!lR>F^2
z8fj1DfV@T7&8}U6nLHd<3XvQuc1*RhsNo+zyLtdSBdkK+>{c2qT3NosRdb&z%}41p
z6`zuGgLqcqUpQ%qAxHW*PO9i2T`L$+WVp`BM_8hAhE>2=I3_Cz&=xX>4bd4S;uUWy
zE5<owa99XwI&QS%^v5#!>IScA!4K(=yY5;vg??>o{;kXV)7|uY=P&qtj6*(m7jd=P
zMQDs~rY$h1-SqvcP3K~h!e~2j>Up&IE7!4}kf08=Q`t0yo?^0@Y2JqR-Njk&(mu}B
zOSQV`C)P}%dCq@fGA?ooobF=h6go7UbjEt+5VQDDz^9l+08=BdM-X%>9X08KVLJDA
z1)pYCQ6q6KP#7B9Ioku6?_7W)MNcwo7NnE>B+cuI?^lz=xw)gtSL1ZwOM*1E3u(YX
zt{0o9(h^tZrv;SpEOB5eEpj?7^^Qtn%jM$8dvqwhL6l9SRYr4`SUQc~)gHRUNrUQD
z5Nl;g#gJM$z>wF8*|l_p`w{gLsGogA#XaxS%n=QSXJ5)9?87DAF(6Gs@ycK6C5Y{n
zTkF%QZBHNI#8Xhne_0Y#%%`LUID}V6Psw0QGzOPq@KcPrD@D}@^db71NS{tK3*{xC
z0~OdvPDL?|{+@b{+MWR>0QoCo%yc?(h?9xg_(jBJg67{+uMv;|HmmS&P$mmuz-E+@
zFCgq7{DQdeFSK{%uaO-=qM!?u&jH2|K8o!Eh8=$vVGm1AEP)+N`urK73BxHBw~-hL
z#Ea{W(f)Lic;p!Ei{;W01y)^OV)RJ+{whlhnnC-~gqS&l4$Y8Ka}k`3Hln0_Q0$mN
zGhOxoFsFmSUy8?P&<casiHr+ql`DUO_;w)pC*r~jXsN+>ij5c0jRw12l+2_R15%Ix
zyOWH@@lWFKs9qSa7l13#1F0yOcMNf5n%88D*gTUCG5CLor)JVW8)UtB<U%^tAZtX)
zEIQ9%E5)W+=ybB8>A)<SPD{wenqWQ`tU&j-!(T0^WB89lBVrxOV{*1Q`dwOW$eE)0
zB0AA%>?pQ<Owa4|p5e83i8-NyN0J@Et&Ei}k}_t~Z+C$vB={*oNrKGys(y~s0ki0_
zI#;Z}(Clc&jRHq(nN3e|8ZlSIjfj&F&(5ZUimNmoB!mjXl?p?~NGG0g8vetb=1!t)
z4(--;3`p+)o}PgsfDEu%g-1gO#6@#x-;T|SeW9?b8Xd4uTr-DuPgl%SI2}wM>~!(c
z9J)tLzL<7Bo%9W5Sr`FBNMFq$r!!hOk-Ih|xfvWMkD-=Od~K)zehTu5ofp&24G&Y#
zMT%>2Y<@5aR&Y0v|NC{kB4~A3eIrV$W;H7~V2I=3Fd?2X$Wez1@r(gZBcLosyRxy*
zhQy{+xI1dj(P6ds=15Pd@HT435pGZwT+vbiB7zD6INWi%K#0(0wX<XSDA)x%F~qR~
zFcIGpam|1V$JH%7!Y)nWNCa@W(-^>0o#p_7XzbV&(T(|mfHt^f2@Uj8u+2kcA{T3W
z{GE-`NFX!T`Pd#}&)*r9<)X559*yULh%B@$4+N=jH{EqD9i_H~4%_PTWg0ifHWm^_
z9tGYQec4q)dtf1pkq!;itJ)Yf6}#e?OJz9NV|gcM<n55}sejC;THaD=0>rEEs*n@S
z2rEuF*e^Q;Xc+#D_%j?SH3J5Di(A-+h?dMMBa4B>1z@p@Ru_mj=hK{qcxN89F{V9o
zEvDt0EWTH_PU6T&UZB@ztqF1p(f?`awnA{N5Di4Qb$TPhig>wS<FSEX=?Aif2HKn)
zs}Hn!8%zMHy<5Z;m(Uz%h2gCO_sGZM)=TJ^bh!?S8RL2u^b%PoKDvYsH`p36WC0yx
zVCbz_K=TZFg}8A6&1@il)cBHzwzwQjP(6|u!EwN})pb_tl^L05c#kXm;jtLINQc?$
zx@=sP4b%86!>dMK{#uy!@fKHY<P=^x6Xh_0k*A4WgBb}&YYjGeHJp<6BID)yn_p>o
zcO1JZkm2LgRHPu50&~dA^}$rtnrTjvjHU|F5f5*TIjB5-#w)IZt@9+1hrLLG>CO2y
zvy>uEoYnxD=4dIn9G|!<)D5!&)t3N*#A)aqr5mo%+^<5u1DNXA!V?-oX$Ce&hdq?J
zCLLk)NYLU9x)(P<yB@>|+ci*UYQ;WbG>a&_B!6|-t>Iv>p>Bc-uhQ{xQFkfrJaV>H
zRsW!nriTit2+dIKg<fb@?ZnAYBVbYqC)+BnT}V4&f_v;z+GR)*@hRk2LQBSLeiO{T
zid;Ke$EQ|u$4;jf*^fO|cL-W%k++Cu<|Mj9b%M{$S8j2gNL`?VWaoM>*<DmGqJ=q0
zq_^g|gA=1R3>|)&ShI+hS}CN<I&t43THQuA>Apx|<xE7U%jnuVwnIm8Y=XQF%#=UV
zWF<3#X8c2!I>l&8Tclwp6~{M$oFxGj2`vLYfv_6Gjes#h7t^8!b$;47{Vb<hMakL#
zEz~jMY8{Co;FN&Mn~B$4%q{$*3Fx7g{9`dJ$To1Lgj@KBX|;|j<7Uy|{43E1iVj>-
z%Fe;bO+sP=zDqYH#_Gh)i)n731PU~QkRX%lx>ic75ovb2a?8n>?AYyqRJ^sAb~&dR
z(QB2kqUTioioS$Fq6wm<T@6pC2YUZ{(AR@oW0iz=MZ55KmYEj0+_crqL6(~~$5FoO
zalR2O7j@sGS-sR}BZ|cpD|)Pt##a#|1$0h#jE(7|og`Qh$KgX<Z2cbX(U9zd;KB=>
zQ~(z`PJ0jvq8okgI3U_atu}T^WG$%a35Bo*H32&9v7$g37kjQGs%XJcbv&$b*##)C
zIQU8C;5^D9({tPeGBhL52<Y^JU;;`=0Gd-zJ2a>yz6y2sg8Ts{08{x2=gk4mIGSTi
zoT4iTIZdH{H71zi;wS3_dNutiK}#wenEuollS?5b!24(~%uK*5muLaDI}q`HJuNOt
zDy4*@dA2xAK!X(9lhE+&7>-wQ#>=b4$R)Ij+M;m@?cE^L4et%5`>+$SjUqQb6ex_}
z#~RfbSJH~^XjHw3AG=5^S@|UOnn81*xRK^Sm-5%bF)af{Yx4{BSdSx(#KUoK8{S2z
zOHDX-{z^>aRE$_kod&HSYJ&l8m&&NE6b8Q~2**!>Vo`tSxj532_@`8!-sl*$MgSA_
zdH@1~xRi=VoL&>4(-F2&o};gRhvVxca5t*;!gTKTz!reKPtWykM<hE>w@wpN7qnOv
zP-hWI{Np$kYQ|Vo;RJfH5j~?SQk<Fg-b&|qzI~IOX%+R3lL?I`a+lGpA?!oy-GMr7
zvc<AHB6_}NNCIb=jX>E5l&<>T#W1sDC?R~HRLon3nKM-+)-9ts=&$$EjUpNsk1eC4
zvQwp~93>p1&atD0Wk)S5rNUxCTVoV;#Ko7>-ihP6wn1emUS+IsY%5|NP&rXYBjVj?
z#7eD}PL&FWamjrwXjW=9cbZX?D_*&r7G)eKvx2z^P2$vc#(+*LK5me7_aL*pN14Ua
zNZYuWvYb|y24WmBHEqZi(3^&EYx+%ui^Sv0>Bt<-{OxWWdDSp!VX|x#^V%EL23sW_
zXm1P`_pYG*vJYS^d6%1(3mJ8hIiH(0qr`JXd4_S1xV?eCLZ20DI9-~-&d~~}TY0fN
z?Y+HNdWy`Iw9w>}i6?k_qpO&_lI9okwpxmv%yQTmu-cc~j|-*JB&i-^^GZ4#ozcIO
z(ZL~aYpikc-by;OfhAAw=AiMA5N>L$H@&;pNh&dbhEJwLEWrfztwjDNR^T?HTjB$F
zVDFoTyow2Nj(Jbb2%nTTm3QLGSRA6Qm<iYrz3JVRK?RPIZz#I};VNdR%9IEPh*ZIa
zJeEYk;{?K<ro{Mns(kBwg{lHwPRVNg_dFKh-locj@v5%rifC9h<4Ti>{#QUDPDQ%P
zliWYqxv8?=$tOPx>QGryMG|8fYZRsAZZ3}{u!dKA=PFDuk0O5UE@C_iri=xRG1R+O
z(W)4A1&=8mplC>7TpvK*#*NHScEV<a)zqnQ9Ow;Zj8z4Jh`^LG7Kuq@_OPb6i$E-F
zv^EG)$l^e*6bgul21vrZ3D`SZhzf`Rt{Bo<6O&ZsKujazg8>X;)Uv=irQZo^TvV_&
zBxWr#+V~E*h#{l6u71s>;_)maGg}WU9$kaAdLwoxP9ZbbKx<<bypk3TCiiQbr0NuP
zJgMlD_ceHRYF<X1V#uc!?I66XXitayG%PPpzlwG%;JbA2bBeCNijH>3T`fglyowHN
z&u-H}j*UkFILSo8)wG8}Mu@7bX^9~hi^sE##W|@SN;+_Ii0PUHc6vgTwr<W9Q*(?`
zS|$3drd^Cgo_J|B&FQcDKsC2&o95#hwaJSSZyW?ftv3{_WE&k;3La->t7&gw*$XUK
za=r-A3mtbdl5T3PhC=Aj78<yTa8p5&&Y|kOYh9x{V=+Wot}!)@e@w)+xkkB4SiFXo
zW?;E)x#0F#aCxo4qK$<jJ<q6sE}oEQJYld`#UpF!faBTLBHLJ<&Ao;e>TKP`-QA4a
zGUHf-HDkr&WK=kf0UV8Ou}J?u&1>Uenc`$Db`ouH{w0QepFUwU<_LEkEiFx{Rl{hA
zP6^nlAT(Z5LByv31GRYuWV}dBT}R6rl1R5J5wG$C+USNPU>pmCl!6G`apZTA4j9L}
zF$t&?LL>f(3>Jy6l12(~DK$tFNJHPm0poy4z$9P_Fa>B=AsuXw1ID}YhG-HWxG)e+
z0j2=$vB&@w76(jX<&*+U0ovmb-wW}8alj;?TCSx4)l$zMk917ValjOIHFh<^oe&0$
z1115JfGNO~4gNX!SB#50_L<0-i2{?65ikyz1WW>^08@Z=7ShiFM8P;<3gI})B>_`_
zalqs`;_Yi`&h$8lPps!o9M<X-z8k}DwQg(<zvK9JHt0Obp2#15r|{hveyeq0b4wn4
zI~&9Ny~OPGG$+?C!>Be$v=IWNjvP~$-4nAF9D%%I>w5ZO`xsUXEpqH&=sDt!4Ycpf
zR0&#Ad?Kk0FtuLhtF^e=E66nB9YoDBIX#%<Ps+np9^F!vmtZ#aAVV$H+2Zt#bXG>7
zehz8%GakeyPZ4`I(!x>|Z%?g@IbqskKs6o>QS*R30r79^GLQEWQ%j7zoLAAKuiE92
zV)WpQVf%~=0J}Toky|>6;Xa*}I}4XdaInC_1I!}HtQoi#vK`B|?zVWqr+HIv0bh#M
zDr|t(4n=(%tQqp1*v;rC{+>P%3CdBuqGLx+#NFJW<8B+lEjg8VC8+DwZ_N$3GGiEz
z-a1UI>uD4k>^yPxbvSHgN5o4AXR=8;Z&9q=y1Cyfrzi&H_DAvNbrcrni6Z@aT2)M{
ziB|-C#fm;~btd3zSjWr!darn8txI~<do#uI>uG}_M~S1?Q{2t?ZG)$-|J*WEOxgrn
zzzp$9snG$Tc@w>~m+VWtVuer=%Z#Mi{9ve$Ap!A?EKM!k)sT&g4ZRKDkbA{Pg3fLr
zztBkST1>mcAtA_aEBG9<)Cp(vFd1z`IBrlUIb6vjF%k$L?{UO6;(q}AP*ZIj3r^=b
zVto={vr2DW4jWADN=4f~#)6#Ka2}}dgUGZN-{XMLOB-!A4;S-pp!3{jMGy!>`0x#2
zG~mcGqetvXV%?5reU}%w;%A#_!SM)I>~897u!bIoh^1K81NM|2az1)a26IGDg53oW
z_5c;?MCWywUwS|gd%_N>MpH|^UhEdP7ns`P8D_oiP^U*uxf^`<%6DdAMXBZ+@|URB
z6Sz3$pV#@tI_{%DiaO!CSG}hY^n8X`^6$Dwnpj^$*5D!pr+eN~cjPvnby4M}w_5B^
zZ-3qPCzzblE(^_1Q|KVdMB^0N?O$wm;tzke*-7rxW+#42V0Lmyu{JwN(G07T%d@rF
ziLDbyrqWfRz3I*j64eGLZfS!PvBZ$~=|FmmvNsKP$T1vas(ui6*V1l-_}@R@&cyzv
z&*sUz7CX}iv`_oxC!3i_qo}HbnduFY{ui26aM{ULCV3cVVbC`WFaaoEJ7HzwuOJRq
zB?8z8$X~|3ScL%{Sef|m5LR1EKuk;)e@Wao9abhBe>Ebgj8KiRGASceYb%rdPlQ`p
zndI|8^Ql&*x%B?y)}$l!)b_v990HdDV-k5->^MTRoP8({TN2r)ZAmc8WPC`+IzLBr
zJ5cpAap8wpMEz83{E+(e$6wBnL<WXtzwKi4UtvSsDxUf)eV<+@9{C%cM%RgwkLY}Q
zmDuzVI&xLhfsbfgTD(A$DK9}g(V?GaLL&3U(ZAC(>Fg60q>JdenVhD5?IxswC9+x*
z!a}HK#80;&<>hkNnUoPJur~qn1h}ZefM3dp#LHV5k=VdcP;b{pBsNg9NF5ZnHX<>c
zytFnV$$rSEj7V7xJayuXI8OO-D-wZ)Kv|bmqrQw4iIk#Yt*l6-7piV$MUn_7PFRr|
zf@9DxVnyOGM<qflk}^d#;+p_Ae<dqY1CG*`>uq)%G8NC4pJ_$nT~S#pD-!R5mVJ&D
zNy12ksepWz6^S*#6!k@{NV4O<#)?$ZasurXU@{L)PRfd;jx=y)X%WEBvLZ<+4%NE<
z&5DF$z0b8Gk%JnK4Y5^LB(`0f6<C_q)vc^Z*)a~YkuoDOvP9elJ5rmQPMDGSjmnHP
zf^KeYMd}8v5*U%#JNl&Ve={O+m_%9|kt8k`s4x!=P_2zfq+T15<Qp1qyp<7&E&dcE
zlCnf8e%Y;zNaXs@HX^bA`sa;E{1ttc`=yOYa=m7LixG)0KA|9#5sA;&VRhiBj7Z9i
zry4~z=}!DCBNEGBs}Yk=7?EV7jt`7TS>NLGw61b3ev(<6%nB6}wsmUz^3Ph47-m&P
z?kBBC>`|P;|7)yB>EwRh87Wwi*e^upWpqs)-=*VP%t+*yny&u`W+Z~kwx4B2Vz+`V
zU($>u_vohlJIqM@2GI98W+VoKhw5^<2`txUB=z|(Fe5Qs{#9lqxehe}{yWV`@@mu#
zGY<ny0H$!<@O7GzNW;lyB(g#au>DCh5{JDBYe`Gl#T46<t;|T+=e9N@v2I`7jKnY2
zYL?;RRx{AIHY1TE;h>h<j3j4kO&f=%m1Ffc@BDwzjKtH7^8zyxpQc-<Eg5<X`BlwG
z(h_;gXr?W(L%JiKM@7GMBflzns@^rH0OcypHx3=Fx~j#}#J{mLm13IdjlZ&#eE~}o
zZmz)6bSBk?rUcK`-5J9fq09}(!wM7k-Eg%iFAO)p+RaT{;*j}&w@Hnc?R1gk70e;w
zcM9KaI_5j=*mhT@x1`rNunq*nkKn92o{{0CZmw}~yb;7Duc&p1IK6|hHiHb-U5>>m
zx*b#=QYNp7qW*WLC;q@`*RR+3g(I#XhzC~E%uh9fb#U41`oKvZ7U`>SV~Jn)jZq9L
z^c$ntzsxAcam1-~o;rPQF^aJ-VHD#(3CnAv82J)LF@9%DQDqd%khkh!i&0G8B35J@
zB?hZhR<RrZzp{qO^uQWsNL#GSH7dTSF^s?SjWMhW^YS;wuy2fEShjy{#;_scV2RPO
ztoc+J=T<QoXNh4?NVE9FG}|V>wCtKRD@cQJqZ#W#2L_PFQ^k#MnInxgr;3-}GIOjo
zYQ2~*j=p6UiXZhb`hQjP8hh=8DQ(6#=CyCkYyVF3+J^l4J>2*r5755EbFn6Rh4D4K
zKx3_5hwV9HOez1$@6GzP#yBi(O8>8n@gy4OrhN@G=C`Ktp0p_iUmJ~Emk**%=2L0s
ze04^)G+Uv(&Fo~Bn|GD|;oVJVo8jZYNpL&zxo%8`e(nRr)h%vJHcd9$cf&r9;Kz>Q
zSv!Gg-An^yM7@&ZFrT%&8*G2sk{}-$w#2gw$}QPRY@BSa$?T2i1HIuOp*KwSy_t4g
zLaq`O=a{|e2V&ki<_bgh6K|hm7H04=SmQk07FikEu9u6#bInaI%hzYStU&BL*PLyz
zzcrPeXHKUEx0*ISVa_n<5OL&5v#$fwqau~RfTw_Fj=_G}R5i^kq=rn1d9`L?4u1rP
zx~M>3j+_@93(bdL5Av&~JD)aRH;s=;lmEQAkkYrCtXXDenjwdYyxC?MjPFg=v&|n;
zdQiMM$DA%E&oyf^czSre<6^GFEe<?)J22OrIEq~!vTQ;KFV_p}L_{s|VOV%Dj6YLD
z8!WQ<_JAA*4;~YIo0xX7nN#pr;>AF&Y7;qK=XJq$`I_FOve%kkdKu5ght3J{NnMY{
z@qQOLqhNc~g5j(`iK%;i3QgaaR$A-{+)M#p(eDy7Gcwm@$ra*>Y@=7xy|0?j+Xgwk
zsd|a|ZNtKal|MGj7f&oRyPct5xV?h|uQHV69f{Z5t8@OC!_2qORo5p8NmrD8q$%q?
ztlYW>c}WKG`YDLBhn>f65+g1*`?w4z1HFOduHT3q@0ghe^Te9V&C>SjIk!Ue$I{cB
zyVRu^LEkmI_j+5SyclTa<3clw5U&qP_X%&3kU!~CY?!Ei*DUQyaOo$gGQ3RD57#i>
z?ZBh`aE(PATy6%}FoFo&o)CXnZnB2H;XRDLxQEfV)jf=U;XRDL;XRCZVg(NFZAANh
z;vPnSVCoN&`r;nOJ2C3??ON^z-@Wsl`K|6@D6-T&jCVfm9)?2Duk}5Qo-54f6C3ge
z?Ma!qg~30rJGLp+GSHj<%>$hc4F~!ZymTc?^hlSdef~(7$yOu1feumwy{P?wlgGK_
zqVO?{bJ9Ju;S`H~k71mX|5oFC2BmJ(#`DeTh8m4WrkZ80dLXMLg}o%op29#Ud(}WM
zQlk^&yeRv?rw?<PYPz%5JZz@HbyAZ*(_8?}@LrSkg6XEY+z3%RBIiXDZcv8nfsYrI
z82BTb<csEH+LpZ$j#!*jvD6B&meUF9sH)wUQwY5NpHm3=pP>*~s1Rh+){F59utgup
z2md*Jz_0v9AE<j-|L63<p~RjMkuS1p{G2&HpOE8o{GO4KFS6MA9E_|r#=1xy6Lmw<
zZZ?g#j{bGi)=0QK*%tZg%M+|6kCVP>d!#*1x-+&%FhL7Zu{|=WP~H?Or#r&sNH7h6
zyb$84`F-0XV_a6c#A{SH8aoO1mPlTeggJ+}xK@vwQpil?Uo|9iG@j_8KgCj`FwbKN
z6EzCmC|Pgu{f4*NlU8&z{BT{uo#<%KBHtAYZ;6b;y~jPbL=I%}En1~TpGjako{wT1
zEVkEZ61PU4rD^g_D(2rFxyr!9(<8S>s?(G^g33E0r@L&UMlJ6V>+Xo;Wyov8sxXB_
zN8?&~QPTr=L@Lrcu$h`}{#{Kk?Bv(aPs<jk+#NZ^V6(-!cSmXm!%@fHgk@tnaNv}!
z?wY%|x(9my-sQhg9_TP7;fcZOGzs4#+>!<Qo4s5wj@=zuYCK;rmhFfPpew|V9g%7`
zTFwI>BrGZ1dm@kI$z?R~W5X`j)kjCcG{02Gk!9lTdm<AJHd9pG8#&h?^P6tGH)0rh
z>c*1tCC1KdRcL%zs9HR*E3zh!jn-lHyj}H2v^|!dqjVe}B`(|@xzm+HLp-O7oS#Hq
zGI*u<=qHg~23sh0{4_GV19>)F7d;=s!$kDn6DiLjudndfIeI~)9CE44#j6!3UTeB~
zPvk;skSChnZi>vNLuIMXm4o%j#a+4e)+{V$&erG%jJJw3d7&n;<&_TaQ7`WLWn>6_
zO#J?rk&#r2f(If$%#r0`cD%1s#rU^%F)~Ix_dw*RK{ku$9*n@<$`8bm2O~53t<gS&
z`oYPV5;k@=4TMcj2^j)OB4_D1l`ci2jC5)Gv5YLDs>*$l4n^G7)Q>{1J;b+QnOcvF
ztK+PP+GRLt@>chuW7mqY`ywk1GQH{XeUYi1_Wak^sb01&Kb1DwuSY)4H@~xGSK+3p
z6)FPT`s#|{l2(dfquJfSThS8NDm3{rf;~w`QR`X^eAwz*SuR_u`9SK$KG%AptG(1~
z#@Hut_MyBI@>X66rMNq0bxY@GoN!7=Mro&nJa9@#wzqOh*aWA9J!y+aLZ&<tI;_Pb
zp*TC;sx;dCTHKg!Wp)^U*$MA|$`_=3x86VIWQ&*KHV~Iy|2y4kGUTttp0?IPcnH%I
zw@a?H<P%Lp+F1r<@_xAQE1_J}wYP4|?6S8Ot8N)c5@bmU6p=p^c^MX-udIe2zul(z
zTc$N|_xg^f(iV??gAB3|F8v^5m%yjr)I2gfbj~+NpM~wm#Sr;j9S7YJIQ3KS@`J&8
z;fXwahK?gMbzF;6KQcYUhjc|yfUh<zKfMV~{ak9ZZ#Q`RN66^zEm@<{ss{qke&px6
z1l!p(wJUP@@to7eExA@!I_sv(D`$K>PaMd#%BHbyCp+I`d7tilPj>wR&i6KlHE+>S
zc8dDn>(a;IZz%73ne0_~D!?x)aSup&l!EUjo*^E{vocH71KK!RvLCnOE6ML;$DQhN
zcocybD*lo#OC0f0o|Ut)t2u!DHblolbnvmE(0?CjBwPqq11jGR<j<j!m;(=g-3orK
zOSzwL@W-Fk@v=W0{B_HHT8GpY<2Wf2S`E(nVoYrAW^Fdu2im*eJE6;@ceQuFH^ShX
z+PmN3F!;Li?q|UN&hP>YuNQ9>YYMOj+bKROuqN5;xfMY_!pYx4aiGw;(U1=-Pk(vs
z*hbCDC{zyF7r6R6El>8-k%4<Y=v&ol*;B{yLE_Iv*6X+}0>Y&w$JKi&#aBGQXz}F7
zmz}`L?g~8lU9LR&RT$(9<;t(Ro$S5Di{T)-WmNe07o2a9w?syXwbV_u0l%Tcar@wK
z4>(Rs5`7X;^*!(h{8H2$z_+?XsJ^S}MNUtvY79?mE&OTz%jDH3rv?7Yuoe7tzh&7c
z{FbS^R+8(&{Bp~`siq`nyy~Nq9hdRTS9rYM@_$z|*p{_g9+c;@K9q>fy{s<npTs_T
zmtjOFx=!#c;E+FWLXIi_+TiVe(lF_sQmcE^kY~aP;djLH{?^b;2`8SFcx01=geALU
zJmDn<8QXNAzjY@ySa-2_pf%kf4~Z8BT07GC`z!qO%ElYKbKrcCbqt&j@{Ub8gDtmH
z34@0|#i<t8do8X6N$Bn`a3y#?TnT20x+*KnVWFo#DOOflz4O?Qa7_qg@CjPhDl2d-
zV`{I2tOkw)``TcMQan=7u~rwCgf9E|I5-aMBFe{FS$SmaKY9ryV{|cI2`_;?I)-k>
zT004pVkZ!m5<K@+_$%S|k9|vjD}R6_d`{Y?Tbh;rtu%|hF4D(YJ?Ka=WSrGIcG?P0
zd8)OgWBWB@;szP$Zyqy5{ArwZgHsY#U96l1K18zv&wwufL+BZ>bJON(YZo|ub5nJV
z)t6=;)_&%c6F~mP^5aeb$!mcVK>2%}tegPK*FraUuY_?*Q@^a702URzq@yZT)QjPF
zD<6RTx5@|LGWty5`VY5SwOc>-jB@+eP<-HIuYbJxAHDvu6ukaDL4N_KfAibJb6~)=
zmcH5zpMU%5t;*%!rP==xCWemm_>Xj${795cvbJUNIgwz1AJ<NdTXKeYX_9rP!Fz}`
z-?2*J<g#hccdRO7Lw@ItXAP<#WtfQbp<mUjqa65hg{K6?5C)gMO8lZ&9_{D(E`w(c
zHjHBpTkCST>zxfhb~_j0f1g-<u660Ksw><DaFWLgkVOI&#{AAj7y+TD-S?F!CW-fc
zZ@BbZ09^t1d{MaVBZeqF&sv9t#Lv&O`WZLCRl#}I>6owkpKo<6d{=kMKonL5-B7Km
zH@k{9c1Ki9JKrjy#p3Got;IMw5=YOsW@8G!Xo~e+yr>CW_;t}jbKHer4qW*4&D|b4
z+XL!Pdho;P;EJhMQJW6BVBo+nLpkv4z)-5S13z}N<)3$UE?(-wgJ0j`AAE)bKj#D@
zX#-J~vDxxpKYRQ@W`rqlO;HK*PjcV~zo>yAApW=mzhe=9)}+B{^6wG<rb*diP^~pu
zIp<nhYr$#cdc0Jz)_|4I)>%UhcJ*!P(=FPw)>ZRe6`sl-mkNnfz8k|a1MyU~kb`2(
z46Eo2cqR@iCEE3$d_;#?DwN`iaSs1gSOj@hFH}}&*MFo-cu+XAX~zuog25*><;=8P
z94ifODw$=yphRxdY%6~xIi!`X@*Ny6*Jsi4G#y9a$s!rX@dY|gtpidm`Ia|Loo!`M
zQ9s8T?Xvfy-nb5Ue*CU@WDZtl@Z0(J9BZV@-d6Er9P)-3GFQdFA*KShmxrTXO^3L{
zv4)HgjOV87=UQDNYEQ6hfpwq3u4$UL5OZF{hKwde^QG4L#Zt|sSTTSISw7lXeTj4!
zq&vDmI{WdhZgW&F5EYB8Ga>o#feb0!vdH>v?syE+aTq1zo@NFC<fJY*$8Ga8F~*C%
zm#RLxR2*Go<%o`ptd0XEDp6CVEQmX5_(T`*5IJ|o%q3>E$AWivss=S3#WU84OE0sE
z8(34+TOY&Ny9bQ}?2jS4le`jpZy}HNuOSXApW(I#a`_WI#gkV+40|O;IueKcIE=%P
zX7}rF<vUxoctO7F^g~`+bCuhVUFEiY1vt`3lwqICA+Zwf56H?};h+mYR#R(At45E@
z+FFyftMO#}dhg7x#3Vpm?V;eu4c-$)#8h$oQ5{F{EG~#U1^NC{#|33zJ|2%U1irYR
z7^urA90aqk%1>?&3Ev_XF19x2$+r*>j;pdV#9f0%RKxKr`I9L8o>geDVln1>R=57+
j!=m65Szq9?!l-wsKh}pU!}f#uB>d+2D$Rdj;<o<*%=XU8

-- 
2.11.0

