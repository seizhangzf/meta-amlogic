From 6fe3fcc7ee4aaa3990dd5f211a4a8a0cd4929c79 Mon Sep 17 00:00:00 2001
From: Pradeep Sriram <pradeep.sriram@amlogic.com>
Date: Fri, 21 Feb 2020 08:37:02 -0800
Subject: [PATCH 3/3] Revert "media_modules: optimize the loading of demod and
 tuner [2/3]"

This reverts commit e396ed3bcfefd5c90b9e9f141fdb22fd52c29454.
---
 drivers/stream_input/Makefile                 |    5 -
 drivers/stream_input/parser/demux/aml_dvb.h   |    5 +
 .../parser/demux/hw_demux/demod_gt.h          |   62 +-
 .../parser/demux/hw_demux/frontend.c          |  234 +-
 drivers/stream_input/parser/dvb_common.c      |  235 --
 drivers/stream_input/parser/dvb_common.h      |  119 -
 .../parser/hw_demux/aml_demod_gt.h            |   87 +-
 .../stream_input/parser/hw_demux/aml_dvb.c    |  281 +-
 .../stream_input/parser/hw_demux/aml_dvb.h    |    7 +
 drivers/stream_input/tv_frontend/Makefile     |   16 +
 drivers/stream_input/tv_frontend/aml_fe.c     | 1372 ++++++++
 drivers/stream_input/tv_frontend/aml_fe.h     |  213 ++
 .../tv_frontend/atv_demod/atvdemod_frontend.c |  791 +++++
 .../tv_frontend/atv_demod/atvdemod_func.c     | 2163 ++++++++++++
 .../tv_frontend/atv_demod/atvdemod_func.h     |  323 ++
 .../tv_frontend/dtv_demod/aml_demod.c         |  725 ++++
 .../tv_frontend/dtv_demod/amlfrontend.c       | 1402 ++++++++
 .../tv_frontend/dtv_demod/demod_func.c        | 2996 +++++++++++++++++
 .../tv_frontend/dtv_demod/dvbc_func.c         | 1331 ++++++++
 .../tv_frontend/dtv_demod/dvbt_func.c         | 2188 ++++++++++++
 .../tv_frontend/dtv_demod/i2c_func.c          |   42 +
 .../include/acf_filter_coefficient.h          |  414 +++
 .../dtv_demod/include/addr_dtmb_che.h         |   77 +
 .../dtv_demod/include/addr_dtmb_che_bit.h     |  266 ++
 .../dtv_demod/include/addr_dtmb_front.h       |   70 +
 .../dtv_demod/include/addr_dtmb_front_bit.h   |  331 ++
 .../dtv_demod/include/addr_dtmb_sync.h        |   53 +
 .../dtv_demod/include/addr_dtmb_sync_bit.h    |  110 +
 .../dtv_demod/include/addr_dtmb_top.h         |   90 +
 .../dtv_demod/include/addr_dtmb_top_bit.h     |  178 +
 .../dtv_demod/include/aml_dtv_demod_reg.h     |   28 +
 .../dtv_demod/include/amlfrontend.h           |   86 +
 .../dtv_demod/include/demod_func.h            |  626 ++++
 .../tv_frontend/dtv_demod/tuner_func.c        |  189 ++
 34 files changed, 16593 insertions(+), 522 deletions(-)
 delete mode 100644 drivers/stream_input/parser/dvb_common.c
 delete mode 100644 drivers/stream_input/parser/dvb_common.h
 create mode 100644 drivers/stream_input/tv_frontend/Makefile
 create mode 100644 drivers/stream_input/tv_frontend/aml_fe.c
 create mode 100644 drivers/stream_input/tv_frontend/aml_fe.h
 create mode 100644 drivers/stream_input/tv_frontend/atv_demod/atvdemod_frontend.c
 create mode 100644 drivers/stream_input/tv_frontend/atv_demod/atvdemod_func.c
 create mode 100644 drivers/stream_input/tv_frontend/atv_demod/atvdemod_func.h
 create mode 100644 drivers/stream_input/tv_frontend/dtv_demod/aml_demod.c
 create mode 100644 drivers/stream_input/tv_frontend/dtv_demod/amlfrontend.c
 create mode 100644 drivers/stream_input/tv_frontend/dtv_demod/demod_func.c
 create mode 100644 drivers/stream_input/tv_frontend/dtv_demod/dvbc_func.c
 create mode 100644 drivers/stream_input/tv_frontend/dtv_demod/dvbt_func.c
 create mode 100644 drivers/stream_input/tv_frontend/dtv_demod/i2c_func.c
 create mode 100644 drivers/stream_input/tv_frontend/dtv_demod/include/acf_filter_coefficient.h
 create mode 100644 drivers/stream_input/tv_frontend/dtv_demod/include/addr_dtmb_che.h
 create mode 100644 drivers/stream_input/tv_frontend/dtv_demod/include/addr_dtmb_che_bit.h
 create mode 100644 drivers/stream_input/tv_frontend/dtv_demod/include/addr_dtmb_front.h
 create mode 100644 drivers/stream_input/tv_frontend/dtv_demod/include/addr_dtmb_front_bit.h
 create mode 100644 drivers/stream_input/tv_frontend/dtv_demod/include/addr_dtmb_sync.h
 create mode 100644 drivers/stream_input/tv_frontend/dtv_demod/include/addr_dtmb_sync_bit.h
 create mode 100644 drivers/stream_input/tv_frontend/dtv_demod/include/addr_dtmb_top.h
 create mode 100644 drivers/stream_input/tv_frontend/dtv_demod/include/addr_dtmb_top_bit.h
 create mode 100644 drivers/stream_input/tv_frontend/dtv_demod/include/aml_dtv_demod_reg.h
 create mode 100644 drivers/stream_input/tv_frontend/dtv_demod/include/amlfrontend.h
 create mode 100644 drivers/stream_input/tv_frontend/dtv_demod/include/demod_func.h
 create mode 100644 drivers/stream_input/tv_frontend/dtv_demod/tuner_func.c

diff --git a/drivers/stream_input/Makefile b/drivers/stream_input/Makefile
index a6cedab..6518166 100644
--- a/drivers/stream_input/Makefile
+++ b/drivers/stream_input/Makefile
@@ -8,16 +8,11 @@ stream_input-objs	+=	parser/esparser.o
 stream_input-objs	+=	parser/tsdemux.o
 stream_input-objs	+=	parser/psparser.o
 stream_input-objs	+=	parser/rmparser.o
-stream_input-objs	+=	parser/dvb_common.o
 stream_input-objs	+=	subtitle/subtitle.o
 
 obj-$(CONFIG_AMLOGIC_DVB)   += parser/hw_demux/
 obj-$(CONFIG_AMLOGIC_DVB)   += parser/demux/
 obj-$(CONFIG_AMLOGIC_DVB)   += parser/dvb_ci/
-
-ccflags-y += -I.
-ccflags-y += -I$(srctree)/drivers/media/dvb-core
-
 #obj-y 	+= 	tv_frontend/
 # obj-y	+=	box-frontend/avl6211/
 # obj-y	+=	box-frontend/atbm8881/
diff --git a/drivers/stream_input/parser/demux/aml_dvb.h b/drivers/stream_input/parser/demux/aml_dvb.h
index 539025d..eda7928 100644
--- a/drivers/stream_input/parser/demux/aml_dvb.h
+++ b/drivers/stream_input/parser/demux/aml_dvb.h
@@ -30,6 +30,11 @@
 #define DSC_DEV_COUNT     2
 #define FE_DEV_COUNT 	  2
 
+struct aml_tuner {
+	struct tuner_config cfg;
+	unsigned int i2c_adapter_id;
+	struct i2c_adapter *i2c_adp;
+};
 
 struct aml_dvb {
 	struct dvb_device    dvb_dev;
diff --git a/drivers/stream_input/parser/demux/hw_demux/demod_gt.h b/drivers/stream_input/parser/demux/hw_demux/demod_gt.h
index b2e42d5..0535da7 100644
--- a/drivers/stream_input/parser/demux/hw_demux/demod_gt.h
+++ b/drivers/stream_input/parser/demux/hw_demux/demod_gt.h
@@ -21,7 +21,65 @@
 #ifndef __AML_DEMOD_GT_H__
 #define __AML_DEMOD_GT_H__
 
-#include "../../dvb_common.h"
+#include  "dvb_frontend.h"
 
+struct amlfe_exp_config {
+	/*config by aml_fe ?*/
+	/* */
+	int set_mode;
+};
 
-#endif /*__AML_DEMOD_GT_H__*/
+struct amlfe_demod_config {
+	int	dev_id;
+	u32 ts;
+	struct i2c_adapter *i2c_adap;
+	int i2c_addr;
+	int	reset_gpio;
+	int	reset_value;
+};
+
+/* For configure different tuners */
+/* It can add fields as extensions */
+struct tuner_config {
+	u8 id;
+	u8 i2c_addr;
+	u8 xtal; /* 0: 16MHz, 1: 24MHz, 3: 27MHz */
+	u8 xtal_cap;
+	u8 xtal_mode;
+};
+
+static inline struct dvb_frontend* aml_dtvdm_attach (const struct amlfe_exp_config *config) {
+	return NULL;
+}
+
+static inline struct dvb_frontend* si2151_attach (struct dvb_frontend *fe,struct i2c_adapter *i2c, struct tuner_config *cfg)
+{
+	return NULL;
+}
+
+static inline struct dvb_frontend* mxl661_attach (struct dvb_frontend *fe,struct i2c_adapter *i2c, struct tuner_config *cfg)
+{
+	return NULL;
+}
+
+static inline struct dvb_frontend* si2159_attach (struct dvb_frontend *fe,struct i2c_adapter *i2c, struct tuner_config *cfg)
+{
+    return NULL;
+}
+
+static inline struct dvb_frontend* r842_attach (struct dvb_frontend *fe, struct i2c_adapter *i2c, struct tuner_config *cfg)
+{
+    return NULL;
+}
+
+static inline struct dvb_frontend* r840_attach (struct dvb_frontend *fe, struct i2c_adapter *i2c, struct tuner_config *cfg)
+{
+    return NULL;
+}
+
+static inline struct dvb_frontend* atbm8881_attach (const struct amlfe_demod_config *config)
+{
+	return NULL;
+}
+
+#endif	/*__AML_DEMOD_GT_H__*/
diff --git a/drivers/stream_input/parser/demux/hw_demux/frontend.c b/drivers/stream_input/parser/demux/hw_demux/frontend.c
index e648c4d..2e40179 100644
--- a/drivers/stream_input/parser/demux/hw_demux/frontend.c
+++ b/drivers/stream_input/parser/demux/hw_demux/frontend.c
@@ -38,7 +38,6 @@
 #include <linux/string.h>
 #include <linux/pinctrl/consumer.h>
 #include <linux/reset.h>
-#include <linux/of_gpio.h>
 #include <linux/amlogic/media/utils/amstream.h>
 //#include <linux/clk.h>
 #include "c_stb_define.h"
@@ -46,16 +45,94 @@
 #include "../aml_dvb.h"
 #include "dvb_reg.h"
 
+#include "../../../tv_frontend/aml_fe.h"
 #include "demod_gt.h"
 #include "../../../../common/media_clock/switch/amports_gate.h"
 
 #define pr_error(fmt, args...) printk("DVB: " fmt, ## args)
 #define pr_inf(fmt, args...)   printk("DVB: " fmt, ## args)
 
+typedef enum __demod_type
+{
+	DEMOD_INVALID,
+	DEMOD_INTERNAL,
+	DEMOD_ATBM8881,
+	DEMOD_MAX_NUM
+}demod_type;
+
+typedef enum __tuner_type
+{
+	TUNER_INVALID,
+	TUNER_SI2151,
+	TUNER_MXL661,
+	TUNER_SI2159,
+	TUNER_R842,
+	TUNER_R840,
+	TUNER_MAX_NUM
+}tuner_type;
+
 static struct dvb_frontend *frontend[FE_DEV_COUNT] = {NULL, NULL};
-static enum dtv_demod_type s_demod_type[FE_DEV_COUNT] = {AM_DTV_DEMOD_NONE, AM_DTV_DEMOD_NONE};
-static enum tuner_type s_tuner_type[FE_DEV_COUNT] = {AM_TUNER_NONE, AM_TUNER_NONE};
+static demod_type s_demod_type[FE_DEV_COUNT] = {DEMOD_INVALID, DEMOD_INVALID};
+static tuner_type s_tuner_type[FE_DEV_COUNT] = {TUNER_INVALID, TUNER_INVALID};
 
+static int dvb_attach_tuner(struct dvb_frontend *fe, struct aml_tuner *tuner, tuner_type *type)
+{
+	struct tuner_config *cfg = &tuner->cfg;
+	struct i2c_adapter *i2c_adap = tuner->i2c_adp;
+
+	switch (cfg->id) {
+	case AM_TUNER_R840:
+		if (!dvb_attach(r840_attach, fe, i2c_adap, cfg)) {
+			pr_error("dvb attach r840_attach tuner error\n");
+			return -1;
+		} else {
+			pr_inf("r840_attach  attach sucess\n");
+			*type = TUNER_R840;
+		}
+		break;
+	case AM_TUNER_R842:
+		if (!dvb_attach(r842_attach, fe, i2c_adap, cfg)) {
+			pr_error("dvb attach r842_attach tuner error\n");
+			return -1;
+		} else {
+			pr_inf("r842_attach  attach sucess\n");
+			*type = TUNER_R842;
+		}
+		break;
+	case AM_TUNER_SI2151:
+		if (!dvb_attach(si2151_attach, fe, i2c_adap, cfg)) {
+			pr_error("dvb attach tuner error\n");
+			return -1;
+		} else {
+			pr_inf("si2151 attach sucess\n");
+			*type = TUNER_SI2151;
+		}
+		break;
+	case AM_TUNER_SI2159:
+		if (!dvb_attach(si2159_attach, fe, i2c_adap, cfg)) {
+			pr_error("dvb attach si2159_attach tuner error\n");
+			return -1;
+		} else {
+			pr_inf("si2159_attach  attach sucess\n");
+			*type = TUNER_SI2159;
+		}
+		break;
+	case AM_TUNER_MXL661:
+		if (!dvb_attach(mxl661_attach, fe, i2c_adap, cfg)) {
+			pr_error("dvb attach mxl661_attach tuner error\n");
+			return -1;
+		} else {
+			pr_inf("mxl661_attach  attach sucess\n");
+			*type = TUNER_MXL661;
+		}
+		break;
+	default:
+		pr_error("can't support tuner type: %d\n", cfg->id);
+		break;
+	}
+
+	return 0;
+}
 
 ssize_t stb_show_tuner_setting(struct class *class,
 				   struct class_attribute *attr, char *buf)
@@ -136,12 +213,13 @@ EXIT:
 
 int frontend_probe(struct platform_device *pdev)
 {
-	struct demod_config config;
+	struct amlfe_exp_config config;
 	char buf[32];
 	const char *str = NULL;
 	struct device_node *node_tuner = NULL;
 	struct device_node *node_i2c = NULL;
 	u32 i2c_addr = 0xFFFFFFFF;
+	struct tuner_config *cfg = NULL;
 	u32 value = 0;
 	int i = 0;
 	int ret =0;
@@ -149,26 +227,25 @@ int frontend_probe(struct platform_device *pdev)
 	struct aml_dvb *advb = aml_get_dvb_device();
 
 	for (i=0; i<FE_DEV_COUNT; i++) {
-		memset(&config, 0, sizeof(struct demod_config));
-
 		memset(buf, 0, 32);
 		snprintf(buf, sizeof(buf), "fe%d_mode", i);
 		ret = of_property_read_string(pdev->dev.of_node, buf, &str);
 		if (ret) {
 			continue;
 		}
-		if (!strcmp(str,"internal")) {
-			config.mode = 0;
-
-			frontend[i] = dvb_attach_demod(&config, &s_demod_type[i], "internal");
+		if (!strcmp(str,"internal"))
+		{
+			config.set_mode = 0;
+			frontend[i] = dvb_attach(aml_dtvdm_attach,&config);
 			if (frontend[i] == NULL) {
 				pr_error("dvb attach demod error\n");
 				goto error_fe;
 			} else {
 				pr_inf("dtvdemod attatch sucess\n");
-				s_demod_type[i] = AM_DTV_DEMOD_AML;
+				s_demod_type[i] = DEMOD_INTERNAL;
 			}
 
+			memset(&cfg, 0, sizeof(struct tuner_config));
 			memset(buf, 0, 32);
 			snprintf(buf, sizeof(buf), "fe%d_tuner",i);
 			node_tuner = of_parse_phandle(pdev->dev.of_node, buf, 0);
@@ -214,8 +291,6 @@ int frontend_probe(struct platform_device *pdev)
 						advb->tuners[j].cfg.id = AM_TUNER_R840;
 					else if (!strncmp(str, "r842_tuner", 10))
 						advb->tuners[j].cfg.id = AM_TUNER_R842;
-					else if (!strncmp(str, "atbm2040_tuner", 14))
-						advb->tuners[i].cfg.id = AM_TUNER_ATBM2040;
 					else {
 						pr_err("nonsupport tuner: %s.\n", str);
 						advb->tuners[j].cfg.id = AM_TUNER_NONE;
@@ -285,8 +360,8 @@ int frontend_probe(struct platform_device *pdev)
 			}
 		} else if(!strcmp(str,"external")) {
 			const char *name = NULL;
+			struct amlfe_demod_config config;
 
-			config.mode = 1;
 			config.dev_id = i;
 			memset(buf, 0, 32);
 			snprintf(buf, sizeof(buf), "fe%d_demod",i);
@@ -345,66 +420,19 @@ int frontend_probe(struct platform_device *pdev)
 			ret = of_property_read_u32(pdev->dev.of_node, buf,&config.reset_value);
 			if (ret) {
 				pr_error("reset_value error\n");
-				config.reset_value = 0;
 				goto error_fe;
 			}
 
-			memset(buf, 0, 32);
-			snprintf(buf, sizeof(buf), "fe%d_ant_power_gpio", i);
-			ret = of_property_read_string(pdev->dev.of_node, buf, &str);
-			if (!ret) {
-				config.ant_power_gpio =
-					 of_get_named_gpio_flags(pdev->dev.of_node,
-					 buf, 0, NULL);
-				pr_inf("%s: %d\n", buf, config.ant_power_gpio);
-			} else {
-				config.ant_power_gpio = -1;
-				pr_error("cannot find resource \"%s\"\n", buf);
-			}
-
-			memset(buf, 0, 32);
-			snprintf(buf, sizeof(buf), "fe%d_ant_poweron_value", i);
-			ret = of_property_read_u32(pdev->dev.of_node, buf, &config.ant_power_value);
-			if (ret) {
-				pr_error("ant_power_value error\n");
-				config.ant_power_value = 0;
-			}
-
-			memset(buf, 0, 32);
-			snprintf(buf, sizeof(buf), "fe%d_tuner0_i2c_addr",i);
-			ret = of_property_read_u32(pdev->dev.of_node, buf,&config.tuner0_i2c_addr);
-			if (ret) {
-				pr_error("no tuner0 i2c_addr define\n");
-			}
-
-			memset(buf, 0, 32);
-			snprintf(buf, sizeof(buf), "fe%d_tuner1_i2c_addr",i);
-			ret = of_property_read_u32(pdev->dev.of_node, buf,&config.tuner1_i2c_addr);
-			if (ret) {
-				pr_error("no tuner1 addr define\n");
-			}
-
-			memset(buf, 0, 32);
-			snprintf(buf, sizeof(buf), "fe%d_tuner0_code",i);
-			ret = of_property_read_u32(pdev->dev.of_node, buf,&config.tuner0_code);
-			if (ret) {
-				pr_error("no tuner0_code define\n");
-			}
-
-			memset(buf, 0, 32);
-			snprintf(buf, sizeof(buf), "fe%d_tuner1_code",i);
-			ret = of_property_read_u32(pdev->dev.of_node, buf,&config.tuner1_code);
-			if (ret) {
-				pr_error("no tuner1_code define\n");
+			if (!strcmp(name,"Atbm8881")) {
+				frontend[i] = dvb_attach(atbm8881_attach,&config);
+				if (frontend[i] == NULL) {
+					pr_error("dvb attach demod error\n");
+					goto error_fe;
+				} else {
+					pr_inf("dtvdemod attatch sucess\n");
+					s_demod_type[i] = DEMOD_ATBM8881;
+				}
 			}
-
-			frontend[i] = dvb_attach_demod(&config, &s_demod_type[i], name);
-			if (frontend[i] == NULL) {
-				pr_error("dvb attach demod error\n");
-				goto error_fe;
-			} else
-				pr_inf("dtvdemod attatch sucess\n");
-
 			if (frontend[i]) {
 				ret = dvb_register_frontend(&advb->dvb_adapter, frontend[i]);
 				if (ret) {
@@ -419,12 +447,31 @@ int frontend_probe(struct platform_device *pdev)
 	return 0;
 error_fe:
 	for (i=0; i<FE_DEV_COUNT; i++) {
-		dvb_detach_demod(&s_demod_type[i]);
-		frontend[i] = NULL;
-		s_demod_type[i] = AM_DTV_DEMOD_NONE;
-
-		dvb_detach_tuner(&s_tuner_type[i]);
-		s_tuner_type[i] = AM_TUNER_NONE;
+		if (s_demod_type[i] == DEMOD_INTERNAL) {
+			dvb_detach(aml_dtvdm_attach);
+			frontend[i] = NULL;
+			s_demod_type[i] = DEMOD_INVALID;
+		}else if (s_demod_type[i] == DEMOD_ATBM8881) {
+			dvb_detach(atbm8881_attach);
+			frontend[i] = NULL;
+			s_demod_type[i] = DEMOD_INVALID;
+		}
+		if (s_tuner_type[i] == TUNER_SI2151) {
+			dvb_detach(si2151_attach);
+			s_tuner_type[i] = TUNER_INVALID;
+		}else if (s_tuner_type[i] == TUNER_MXL661) {
+			dvb_detach(mxl661_attach);
+			s_tuner_type[i] = TUNER_INVALID;
+		}else if (s_tuner_type[i] == TUNER_SI2159) {
+			dvb_detach(si2159_attach);
+			s_tuner_type[i] = TUNER_INVALID;
+		}else if (s_tuner_type[i] == TUNER_R842) {
+			dvb_detach(r842_attach);
+			s_tuner_type[i] = TUNER_INVALID;
+		}else if (s_tuner_type[i] == TUNER_R840) {
+			dvb_detach(r840_attach);
+			s_tuner_type[i] = TUNER_INVALID;
+		}
 	}
 
 	if (advb->tuners)
@@ -438,24 +485,33 @@ int frontend_remove(void)
 	int i;
 
 	for (i=0; i<FE_DEV_COUNT; i++) {
-		dvb_detach_demod(&s_demod_type[i]);
-
-		dvb_detach_tuner(&s_tuner_type[i]);
+		if (s_demod_type[i] == DEMOD_INTERNAL) {
+			dvb_detach(aml_dtvdm_attach);
+		}else if (s_demod_type[i] == DEMOD_ATBM8881) {
+			dvb_detach(atbm8881_attach);
+		}
+		if (s_tuner_type[i] == TUNER_SI2151) {
+			dvb_detach(si2151_attach);
+		}else if (s_tuner_type[i] == TUNER_MXL661) {
+			dvb_detach(mxl661_attach);
+		}else if (s_tuner_type[i] == TUNER_SI2159) {
+			dvb_detach(si2159_attach);
+		}else if (s_tuner_type[i] == TUNER_R842) {
+			dvb_detach(r842_attach);
+		}else if (s_tuner_type[i] == TUNER_R840) {
+			dvb_detach(r840_attach);
+		}
 
-		if (frontend[i] &&
-			((s_tuner_type[i] == AM_TUNER_SI2151)
-			|| (s_tuner_type[i] == AM_TUNER_MXL661)
-			|| (s_tuner_type[i] == AM_TUNER_SI2159)
-			|| (s_tuner_type[i] == AM_TUNER_R842)
-			|| (s_tuner_type[i] == AM_TUNER_R840)
-			|| (s_tuner_type[i] == AM_TUNER_ATBM2040))) {
+		if (frontend[i] && \
+			( (s_tuner_type[i] == TUNER_SI2151) || (s_tuner_type[i] == TUNER_MXL661) || (s_tuner_type[i] == TUNER_SI2159) || (s_tuner_type[i] == TUNER_R842) || (s_tuner_type[i] == TUNER_R840)) \
+			)
+		{
 			dvb_unregister_frontend(frontend[i]);
 			dvb_frontend_detach(frontend[i]);
 		}
-
 		frontend[i] = NULL;
-		s_demod_type[i] = AM_DTV_DEMOD_NONE;
-		s_tuner_type[i] = AM_TUNER_NONE;
+		s_demod_type[i] = DEMOD_INVALID;
+		s_tuner_type[i] = TUNER_INVALID;
 
 	}
 	return 0;
diff --git a/drivers/stream_input/parser/dvb_common.c b/drivers/stream_input/parser/dvb_common.c
deleted file mode 100644
index 64564c4..0000000
--- a/drivers/stream_input/parser/dvb_common.c
+++ /dev/null
@@ -1,235 +0,0 @@
-/*
- * ../hardware/amlogic/media_modules/drivers/stream_input/parser/dvb_common.c
- *
- * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- */
-
-#include <linux/printk.h>
-#include "dvb_common.h"
-
-#define pr_error(fmt, args...)  printk("DVB: " fmt, ## args)
-
-int dvb_attach_tuner(struct dvb_frontend *fe, struct aml_tuner *tuner,
-		enum tuner_type *type)
-{
-	struct tuner_config *cfg = NULL;
-	struct i2c_adapter *i2c_adap = NULL;
-
-	if (fe == NULL || tuner == NULL || type == NULL) {
-		pr_error("%s: NULL pointer.\n", __func__);
-		return -1;
-	}
-
-	cfg = &tuner->cfg;
-	i2c_adap = tuner->i2c_adp;
-
-	switch (cfg->id) {
-	case AM_TUNER_R840:
-		if (!dvb_attach(r840_attach, fe, i2c_adap, cfg)) {
-			pr_error("dvb attach r840_attach tuner error\n");
-			return -1;
-		} else {
-			pr_error("r840_attach  attach sucess\n");
-			*type = AM_TUNER_R840;
-		}
-		break;
-	case AM_TUNER_R842:
-		if (!dvb_attach(r842_attach, fe, i2c_adap, cfg)) {
-			pr_error("dvb attach r842_attach tuner error\n");
-			return -1;
-		} else {
-			pr_error("r842_attach  attach sucess\n");
-			*type = AM_TUNER_R842;
-		}
-		break;
-	case AM_TUNER_SI2151:
-		if (!dvb_attach(si2151_attach, fe, i2c_adap, cfg)) {
-			pr_error("dvb attach tuner error\n");
-			return -1;
-		} else {
-			pr_error("si2151 attach sucess\n");
-			*type = AM_TUNER_SI2151;
-		}
-		break;
-	case AM_TUNER_SI2159:
-		if (!dvb_attach(si2159_attach, fe, i2c_adap, cfg)) {
-			pr_error("dvb attach si2159_attach tuner error\n");
-			return -1;
-		} else {
-			pr_error("si2159_attach  attach sucess\n");
-			*type = AM_TUNER_SI2159;
-		}
-		break;
-	case AM_TUNER_MXL661:
-		if (!dvb_attach(mxl661_attach, fe, i2c_adap, cfg)) {
-			pr_error("dvb attach mxl661_attach tuner error\n");
-			return -1;
-		} else {
-			pr_error("mxl661_attach  attach sucess\n");
-			*type = AM_TUNER_MXL661;
-		}
-		break;
-	case AM_TUNER_ATBM2040:
-		if (!dvb_attach(atbm2040_attach, fe, i2c_adap, cfg)) {
-			pr_error("dvb attach atbm2040_attach tuner error\n");
-			return -1;
-		} else {
-			pr_error("atbm2040_attach  attach sucess\n");
-			*type = AM_TUNER_ATBM2040;
-		}
-		break;
-	default:
-		pr_error("can't support tuner type: %d\n", cfg->id);
-		break;
-	}
-
-	return 0;
-}
-EXPORT_SYMBOL(dvb_attach_tuner);
-
-int dvb_detach_tuner(enum tuner_type *type)
-{
-	if (type == NULL) {
-		pr_error("%s: type == NULL\n", __func__);
-		return -1;
-	}
-
-	switch (*type) {
-	case AM_TUNER_R840:
-		dvb_detach(r840_attach);
-		*type = AM_TUNER_NONE;
-		break;
-	case AM_TUNER_R842:
-		dvb_detach(r842_attach);
-		*type = AM_TUNER_NONE;
-		break;
-	case AM_TUNER_SI2151:
-		dvb_detach(si2151_attach);
-		*type = AM_TUNER_NONE;
-		break;
-	case AM_TUNER_SI2159:
-		dvb_detach(si2159_attach);
-		*type = AM_TUNER_NONE;
-		break;
-	case AM_TUNER_MXL661:
-		dvb_detach(mxl661_attach);
-		*type = AM_TUNER_NONE;
-		break;
-	case AM_TUNER_ATBM2040:
-		dvb_detach(atbm2040_attach);
-		*type = AM_TUNER_NONE;
-		break;
-	default:
-		pr_error("can't support tuner type: %d\n", *type);
-		break;
-	}
-
-	return 0;
-}
-EXPORT_SYMBOL(dvb_detach_tuner);
-
-struct dvb_frontend *dvb_attach_demod(struct demod_config *cfg,
-		enum dtv_demod_type *type, const char *name)
-{
-	struct dvb_frontend *fe = NULL;
-
-	if (cfg == NULL || type == NULL || name == NULL) {
-		pr_error("%s: NULL pointer.\n", __func__);
-		return NULL;
-	}
-
-	if (!strncmp(name, "internal", strlen("internal"))) {
-		fe = dvb_attach(aml_dtvdm_attach, cfg);
-		if (fe)
-			*type = AM_DTV_DEMOD_AML;
-	} else if (!strncmp(name, "Si2168", strlen("Si2168"))) {
-		fe = dvb_attach(si2168_attach, cfg);
-		if (fe)
-			*type = AM_DTV_DEMOD_SI2168;
-	} else if (!strncmp(name, "Si2168-1", strlen("Si2168-1"))) {
-		fe = dvb_attach(si2168_attach_1, cfg);
-		if (fe)
-			*type = AM_DTV_DEMOD_SI2168_1;
-	} else if (!strncmp(name, "Avl6762", strlen("Avl6762"))) {
-		fe = dvb_attach(avl6762_attach, cfg);
-		if (fe)
-			*type = AM_DTV_DEMOD_AVL6762;
-	} else if (!strncmp(name, "cxd2856", strlen("cxd2856"))) {
-		fe = dvb_attach(cxd2856_attach, cfg);
-		if (fe)
-			*type = AM_DTV_DEMOD_CXD2856;
-	} else if (!strncmp(name, "atbm7821", strlen("atbm7821"))) {
-		fe = dvb_attach(atbm7821_attach, cfg);
-		if (fe)
-			*type = AM_DTV_DEMOD_ATBM7821;
-	} else if (!strncmp(name, "mxl248", strlen("mxl248"))) {
-		fe = dvb_attach(mxl248_attach, cfg);
-		if (fe)
-			*type = AM_DTV_DEMOD_MXL248;
-	} else {
-		pr_error("can't support demod type: %s\n", name);
-	}
-
-	return fe;
-}
-EXPORT_SYMBOL(dvb_attach_demod);
-
-int dvb_detach_demod(enum dtv_demod_type *type)
-{
-	if (type == NULL) {
-		pr_error("%s: type == NULL\n", __func__);
-		return -1;
-	}
-
-	switch (*type) {
-	case AM_DTV_DEMOD_AML:
-		dvb_detach(aml_dtvdm_attach);
-		*type = AM_DTV_DEMOD_NONE;
-		break;
-	case AM_DTV_DEMOD_ATBM8881:
-		dvb_detach(atbm8881_attach);
-		*type = AM_DTV_DEMOD_NONE;
-		break;
-	case AM_DTV_DEMOD_SI2168:
-		dvb_detach(si2168_attach);
-		*type = AM_DTV_DEMOD_NONE;
-		break;
-	case AM_DTV_DEMOD_SI2168_1:
-		dvb_detach(si2168_attach_1);
-		*type = AM_DTV_DEMOD_NONE;
-		break;
-	case AM_DTV_DEMOD_AVL6762:
-		dvb_detach(avl6762_attach);
-		*type = AM_DTV_DEMOD_NONE;
-		break;
-	case AM_DTV_DEMOD_CXD2856:
-		dvb_detach(cxd2856_attach);
-		*type = AM_DTV_DEMOD_NONE;
-		break;
-	case AM_DTV_DEMOD_ATBM7821:
-		dvb_detach(atbm7821_attach);
-		*type = AM_DTV_DEMOD_NONE;
-		break;
-	case AM_DTV_DEMOD_MXL248:
-		dvb_detach(mxl248_attach);
-		*type = AM_DTV_DEMOD_NONE;
-		break;
-	default:
-		pr_error("can't support demod type: %d\n", *type);
-		break;
-	}
-
-	return 0;
-}
-EXPORT_SYMBOL(dvb_detach_demod);
diff --git a/drivers/stream_input/parser/dvb_common.h b/drivers/stream_input/parser/dvb_common.h
deleted file mode 100644
index 85a21d5..0000000
--- a/drivers/stream_input/parser/dvb_common.h
+++ /dev/null
@@ -1,119 +0,0 @@
-/*
- * ../hardware/amlogic/media_modules/drivers/stream_input/parser/dvb_common.h
- *
- * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- */
-
-#ifndef __DVB_COMMON_H__
-#define __DVB_COMMON_H__
-
-#include <linux/amlogic/aml_dtvdemod.h>
-
-#include "dvb_frontend.h"
-
-extern int dvb_attach_tuner(struct dvb_frontend *fe, struct aml_tuner *tuner,
-		enum tuner_type *type);
-extern int dvb_detach_tuner(enum tuner_type *type);
-extern struct dvb_frontend *dvb_attach_demod(struct demod_config *cfg,
-		enum dtv_demod_type *type, const char *name);
-extern int dvb_detach_demod(enum dtv_demod_type *type);
-
-/* For compile and load warnings */
-static inline struct dvb_frontend *mxl661_attach(struct dvb_frontend *fe,
-		struct i2c_adapter *i2c_adap, struct tuner_config *cfg)
-{
-	return NULL;
-}
-
-static inline struct dvb_frontend *si2151_attach(struct dvb_frontend *fe,
-		struct i2c_adapter *i2c_adap, struct tuner_config *cfg)
-{
-	return NULL;
-}
-
-static inline struct dvb_frontend *si2159_attach(struct dvb_frontend *fe,
-		struct i2c_adapter *i2c_adap, struct tuner_config *cfg)
-{
-	return NULL;
-}
-
-static inline struct dvb_frontend *r840_attach(struct dvb_frontend *fe,
-		struct i2c_adapter *i2c_adap, struct tuner_config *cfg)
-{
-	return NULL;
-}
-
-static inline struct dvb_frontend *r842_attach(struct dvb_frontend *fe,
-		struct i2c_adapter *i2c_adap, struct tuner_config *cfg)
-{
-	return NULL;
-}
-
-static inline struct dvb_frontend *atbm2040_attach(struct dvb_frontend *fe,
-		struct i2c_adapter *i2c_adap, struct tuner_config *cfg)
-{
-	return NULL;
-}
-
-static inline struct dvb_frontend *atbm253_attach(struct dvb_frontend *fe,
-		struct i2c_adapter *i2c_adap, struct tuner_config *cfg)
-{
-	return NULL;
-}
-/* For attach tuner driver end */
-
-static inline struct dvb_frontend *atbm8881_attach(
-		const struct demod_config *cfg)
-{
-	return NULL;
-}
-
-static inline struct dvb_frontend *si2168_attach(
-		const struct demod_config *cfg)
-{
-	return NULL;
-}
-
-static inline struct dvb_frontend *si2168_attach_1(
-		const struct demod_config *cfg)
-{
-	return NULL;
-}
-
-static inline struct dvb_frontend *avl6762_attach(
-		const struct demod_config *cfg)
-{
-	return NULL;
-}
-
-static inline struct dvb_frontend *atbm7821_attach(
-		const struct demod_config *cfg)
-{
-	return NULL;
-}
-
-static inline struct dvb_frontend *mxl248_attach(
-		const struct demod_config *cfg)
-{
-	return NULL;
-}
-
-static inline struct dvb_frontend *cxd2856_attach(
-		const struct demod_config *cfg)
-{
-	return NULL;
-}
-/* For attach demod driver end */
-
-#endif /* __DVB_COMMON_H__ */
diff --git a/drivers/stream_input/parser/hw_demux/aml_demod_gt.h b/drivers/stream_input/parser/hw_demux/aml_demod_gt.h
index 77658b0..7d8ae11 100644
--- a/drivers/stream_input/parser/hw_demux/aml_demod_gt.h
+++ b/drivers/stream_input/parser/hw_demux/aml_demod_gt.h
@@ -20,7 +20,90 @@
 #ifndef __AML_DEMOD_GT_H__
 #define __AML_DEMOD_GT_H__
 
-#include "../dvb_common.h"
+#include  "dvb_frontend.h"
 
+struct amlfe_exp_config {
+	/*config by aml_fe ?*/
+	/* */
+	int set_mode;
+};
 
-#endif /*__AML_DEMOD_GT_H__*/
+struct amlfe_demod_config {
+	int	dev_id;
+	u32 ts;
+	struct i2c_adapter *i2c_adap;
+	int i2c_addr;
+	int	reset_gpio;
+	int	reset_value;
+	int ts_out_mode; //serial or parallel; 0:serial, 1:parallel
+	int tuner0_i2c_addr;
+	int tuner1_i2c_addr;
+	int tuner0_code;
+	int tuner1_code;
+};
+
+/* For configure different tuners */
+/* It can add fields as extensions */
+struct tuner_config {
+	u8 id;
+	u8 i2c_addr;
+	u8 xtal; /* 0: 16MHz, 1: 24MHz, 3: 27MHz */
+	u8 xtal_cap;
+	u8 xtal_mode;
+};
+
+static inline struct dvb_frontend* aml_dtvdm_attach (const struct amlfe_exp_config *config) {
+	return NULL;
+}
+
+static inline struct dvb_frontend* si2151_attach (struct dvb_frontend *fe,struct i2c_adapter *i2c, struct tuner_config *cfg)
+{
+	return NULL;
+}
+
+static inline struct dvb_frontend* mxl661_attach (struct dvb_frontend *fe,struct i2c_adapter *i2c, struct tuner_config *cfg)
+{
+	return NULL;
+}
+
+static inline struct dvb_frontend* si2159_attach (struct dvb_frontend *fe,struct i2c_adapter *i2c, struct tuner_config *cfg)
+{
+    return NULL;
+}
+
+static inline struct dvb_frontend* r842_attach (struct dvb_frontend *fe, struct i2c_adapter *i2c, struct tuner_config *cfg)
+{
+    return NULL;
+}
+
+static inline struct dvb_frontend* r840_attach (struct dvb_frontend *fe, struct i2c_adapter *i2c, struct tuner_config *cfg)
+{
+    return NULL;
+}
+
+static inline struct dvb_frontend* atbm2040_attach (struct dvb_frontend *fe, struct i2c_adapter *i2c, struct tuner_config *cfg)
+{
+	return NULL;
+}
+
+static inline struct dvb_frontend* atbm8881_attach (const struct amlfe_demod_config *config)
+{
+	return NULL;
+}
+
+static inline struct dvb_frontend* si2168_attach (const struct amlfe_demod_config *config)
+{
+	return NULL;
+}
+
+static inline struct dvb_frontend* si2168_attach_1 (const struct amlfe_demod_config *config)
+{
+	return NULL;
+}
+
+static inline struct dvb_frontend* avl6762_attach (const struct amlfe_demod_config *config)
+{
+	return NULL;
+}
+
+#endif	/*__AML_DEMOD_GT_H__*/
diff --git a/drivers/stream_input/parser/hw_demux/aml_dvb.c b/drivers/stream_input/parser/hw_demux/aml_dvb.c
index 2c8c09a..1a5e174 100644
--- a/drivers/stream_input/parser/hw_demux/aml_dvb.c
+++ b/drivers/stream_input/parser/hw_demux/aml_dvb.c
@@ -46,7 +46,6 @@
 #include <linux/string.h>
 #include <linux/pinctrl/consumer.h>
 #include <linux/reset.h>
-#include <linux/of_gpio.h>
 #include <linux/amlogic/media/utils/amstream.h>
 #include <linux/amlogic/cpu_version.h>
 #include <linux/clk.h>
@@ -55,9 +54,33 @@
 #include "aml_dvb.h"
 #include "aml_dvb_reg.h"
 
+#include "../../tv_frontend/aml_fe.h"
 #include "aml_demod_gt.h"
 #include "../../../common/media_clock/switch/amports_gate.h"
 
+typedef enum __demod_type
+{
+	DEMOD_INVALID,
+	DEMOD_INTERNAL,
+	DEMOD_ATBM8881,
+	DEMOD_SI2168,
+	DEMOD_AVL6762,
+	DEMOD_SI2168_1,
+	DEMOD_MAX_NUM
+}demod_type;
+
+typedef enum __tuner_type
+{
+	TUNER_INVALID,
+	TUNER_SI2151,
+	TUNER_MXL661,
+	TUNER_SI2159,
+	TUNER_R842,
+	TUNER_R840,
+	TUNER_ATBM2040,
+	TUNER_MAX_NUM
+}tuner_type;
+
 #define pr_dbg(args...)\
 	do {\
 		if (debug_dvb)\
@@ -72,7 +95,7 @@ module_param(debug_dvb, int, 0644);
 
 #define CARD_NAME "amlogic-dvb"
 
-#define DVB_VERSION "V2.00"
+
 
 DVB_DEFINE_MOD_OPT_ADAPTER_NR(adapter_nr);
 
@@ -84,8 +107,8 @@ static struct aml_dvb aml_dvb_device;
 static struct class aml_stb_class;
 
 static struct dvb_frontend *frontend[FE_DEV_COUNT] = {NULL, NULL};
-static enum dtv_demod_type s_demod_type[FE_DEV_COUNT] = {AM_DTV_DEMOD_NONE, AM_DTV_DEMOD_NONE};
-static enum tuner_type s_tuner_type[FE_DEV_COUNT] = {AM_TUNER_NONE, AM_TUNER_NONE};
+static demod_type s_demod_type[FE_DEV_COUNT] = {DEMOD_INVALID, DEMOD_INVALID};
+static tuner_type s_tuner_type[FE_DEV_COUNT] = {TUNER_INVALID, TUNER_INVALID};
 static int dmx_reset_all_flag = 0;
 #if 0
 static struct reset_control *aml_dvb_demux_reset_ctl;
@@ -124,6 +147,74 @@ static struct tsdemux_ops aml_tsdemux_ops = {
 	.set_demux = aml_tsdemux_set_demux
 };
 
+static int dvb_attach_tuner(struct dvb_frontend *fe, struct aml_tuner *tuner, tuner_type *type)
+{
+	struct tuner_config *cfg = &tuner->cfg;
+	struct i2c_adapter *i2c_adap = tuner->i2c_adp;
+
+	switch (cfg->id) {
+	case AM_TUNER_R840:
+		if (!dvb_attach(r840_attach, fe, i2c_adap, cfg)) {
+			pr_error("dvb attach r840_attach tuner error\n");
+			return -1;
+		} else {
+			pr_inf("r840_attach  attach sucess\n");
+			*type = TUNER_R840;
+		}
+		break;
+	case AM_TUNER_R842:
+		if (!dvb_attach(r842_attach, fe, i2c_adap, cfg)) {
+			pr_error("dvb attach r842_attach tuner error\n");
+			return -1;
+		} else {
+			pr_inf("r842_attach  attach sucess\n");
+			*type = TUNER_R842;
+		}
+		break;
+	case AM_TUNER_SI2151:
+		if (!dvb_attach(si2151_attach, fe, i2c_adap, cfg)) {
+			pr_error("dvb attach tuner error\n");
+			return -1;
+		} else {
+			pr_inf("si2151 attach sucess\n");
+			*type = TUNER_SI2151;
+		}
+		break;
+	case AM_TUNER_SI2159:
+		if (!dvb_attach(si2159_attach, fe, i2c_adap, cfg)) {
+			pr_error("dvb attach si2159_attach tuner error\n");
+			return -1;
+		} else {
+			pr_inf("si2159_attach  attach sucess\n");
+			*type = TUNER_SI2159;
+		}
+		break;
+	case AM_TUNER_MXL661:
+		if (!dvb_attach(mxl661_attach, fe, i2c_adap, cfg)) {
+			pr_error("dvb attach mxl661_attach tuner error\n");
+			return -1;
+		} else {
+			pr_inf("mxl661_attach  attach sucess\n");
+			*type = TUNER_MXL661;
+		}
+		break;
+	case AM_TUNER_ATBM2040:
+		if (!dvb_attach(atbm2040_attach, fe, i2c_adap, cfg)) {
+			pr_error("dvb attach atbm2040_attach tuner error\n");
+			return -1;
+		} else {
+			pr_inf("atbm2040_attach  attach sucess\n");
+			*type = TUNER_ATBM2040;
+		}
+		break;
+	default:
+		pr_error("can't support tuner type: %d\n", cfg->id);
+		break;
+	}
+
+	return 0;
+}
+
 long aml_stb_get_base(int id)
 {
 	int newbase = 0;
@@ -695,7 +786,7 @@ static int aml_dvb_asyncfifo_init(struct aml_dvb *advb,
 	res = platform_get_resource_byname(advb->pdev, IORESOURCE_IRQ, buf);
 	if (res)
 		asyncfifo->asyncfifo_irq = res->start;
-	pr_inf("%s irq num:%d \n", buf, asyncfifo->asyncfifo_irq);
+	pr_info("%s irq num:%d ", buf, asyncfifo->asyncfifo_irq);
 	asyncfifo->dvb = advb;
 	asyncfifo->id = id;
 	asyncfifo->init = 0;
@@ -1230,7 +1321,7 @@ static ssize_t demux##i##_reset_store(struct class *class,  \
 {\
 	if (!strncmp("1", buf, 1)) { \
 		struct aml_dvb *dvb = &aml_dvb_device; \
-		pr_inf("Reset demux["#i"], call dmx_reset_dmx_hw\n"); \
+		pr_info("Reset demux["#i"], call dmx_reset_dmx_hw\n"); \
 		dmx_reset_dmx_id_hw_ex(dvb, i, 0); \
 	} \
 	return size; \
@@ -1925,7 +2016,7 @@ static int aml_dvb_probe(struct platform_device *pdev)
 	int i, ret = 0;
 	struct devio_aml_platform_data *pd_dvb;
 
-	pr_dbg("probe amlogic dvb driver [%s]\n", DVB_VERSION);
+	pr_dbg("probe amlogic dvb driver\n");
 
 	/*switch_mod_gate_by_name("demux", 1); */
 #if 0
@@ -2168,7 +2259,7 @@ static int aml_dvb_probe(struct platform_device *pdev)
 
 	//pengcc add for dvb using linux TV frontend api init
 	{
-		struct demod_config config;
+		struct amlfe_exp_config config;
 		char buf[32];
 		const char *str = NULL;
 		struct device_node *node_tuner = NULL;
@@ -2178,24 +2269,22 @@ static int aml_dvb_probe(struct platform_device *pdev)
 		int j = 0;
 
 		for (i=0; i<FE_DEV_COUNT; i++) {
-			memset(&config, 0, sizeof(struct demod_config));
-
 			memset(buf, 0, 32);
 			snprintf(buf, sizeof(buf), "fe%d_mode", i);
 			ret = of_property_read_string(pdev->dev.of_node, buf, &str);
 			if (ret) {
 				continue;
 			}
-			if (!strcmp(str, "internal")) {
-				config.mode = 0;
-
-				frontend[i] = dvb_attach_demod(&config, &s_demod_type[i], "internal");
+			if (!strcmp(str,"internal"))
+			{
+				config.set_mode = 0;
+				frontend[i] = dvb_attach(aml_dtvdm_attach,&config);
 				if (frontend[i] == NULL) {
 					pr_error("dvb attach demod error\n");
 					goto error_fe;
 				} else {
 					pr_inf("dtvdemod attatch sucess\n");
-					s_demod_type[i] = AM_DTV_DEMOD_AML;
+					s_demod_type[i] = DEMOD_INTERNAL;
 				}
 
 				memset(buf, 0, 32);
@@ -2315,8 +2404,8 @@ static int aml_dvb_probe(struct platform_device *pdev)
 				}
 			} else if(!strcmp(str,"external")) {
 				const char *name = NULL;
+				struct amlfe_demod_config config;
 
-				config.mode = 1;
 				config.dev_id = i;
 				memset(buf, 0, 32);
 				snprintf(buf, sizeof(buf), "fe%d_demod",i);
@@ -2375,52 +2464,26 @@ static int aml_dvb_probe(struct platform_device *pdev)
 				ret = of_property_read_u32(pdev->dev.of_node, buf,&config.reset_value);
 				if (ret) {
 					pr_error("reset_value error\n");
-					config.reset_value = 0;
 					goto error_fe;
 				}
-
-				memset(buf, 0, 32);
-				snprintf(buf, sizeof(buf), "fe%d_ant_power_gpio", i);
-				ret = of_property_read_string(pdev->dev.of_node, buf, &str);
-				if (!ret) {
-					config.ant_power_gpio =
-						 of_get_named_gpio_flags(pdev->dev.of_node,
-						 buf, 0, NULL);
-					pr_inf("%s: %d\n", buf, config.ant_power_gpio);
-				} else {
-					config.ant_power_gpio = -1;
-					pr_error("cannot find resource \"%s\"\n", buf);
-				}
-
-				memset(buf, 0, 32);
-				snprintf(buf, sizeof(buf), "fe%d_ant_poweron_value", i);
-				ret = of_property_read_u32(pdev->dev.of_node, buf, &config.ant_power_value);
-				if (ret) {
-					pr_error("ant_power_value error\n");
-					config.ant_power_value = 0;
-				}
-
 				memset(buf, 0, 32);
 				snprintf(buf, sizeof(buf), "fe%d_tuner0_i2c_addr",i);
 				ret = of_property_read_u32(pdev->dev.of_node, buf,&config.tuner0_i2c_addr);
 				if (ret) {
 					pr_error("no tuner0 i2c_addr define\n");
 				}
-
 				memset(buf, 0, 32);
 				snprintf(buf, sizeof(buf), "fe%d_tuner1_i2c_addr",i);
 				ret = of_property_read_u32(pdev->dev.of_node, buf,&config.tuner1_i2c_addr);
 				if (ret) {
 					pr_error("no tuner1 addr define\n");
 				}
-
 				memset(buf, 0, 32);
 				snprintf(buf, sizeof(buf), "fe%d_tuner0_code",i);
 				ret = of_property_read_u32(pdev->dev.of_node, buf,&config.tuner0_code);
 				if (ret) {
 					pr_error("no tuner0_code define\n");
 				}
-
 				memset(buf, 0, 32);
 				snprintf(buf, sizeof(buf), "fe%d_tuner1_code",i);
 				ret = of_property_read_u32(pdev->dev.of_node, buf,&config.tuner1_code);
@@ -2433,13 +2496,46 @@ static int aml_dvb_probe(struct platform_device *pdev)
 					config.ts_out_mode = 0;
 				}
 
-				frontend[i] = dvb_attach_demod(&config, &s_demod_type[i], name);
-				if (frontend[i] == NULL) {
-					pr_error("dvb attach demod error\n");
-					goto error_fe;
-				} else
-					pr_inf("dtvdemod attatch sucess\n");
-
+				if (!strcmp(name,"Atbm8881")) {
+					frontend[i] = dvb_attach(atbm8881_attach,&config);
+					if (frontend[i] == NULL) {
+						pr_error("dvb attach demod error\n");
+						goto error_fe;
+					} else {
+						pr_inf("dtvdemod attatch sucess\n");
+						s_demod_type[i] = DEMOD_ATBM8881;
+					}
+				}
+				if (!strcmp(name,"Si2168")) {
+					frontend[i] = dvb_attach(si2168_attach,&config);
+					if (frontend[i] == NULL) {
+						pr_error("dvb attach demod error\n");
+						goto error_fe;
+					} else {
+						pr_inf("dtvdemod attatch sucess\n");
+						s_demod_type[i] = DEMOD_SI2168;
+					}
+				}
+				if (!strcmp(name,"Si2168-1")) {
+					frontend[i] = dvb_attach(si2168_attach_1,&config);
+					if (frontend[i] == NULL) {
+						pr_error("dvb attach demod error\n");
+						goto error_fe;
+					} else {
+						pr_inf("si2168_1 dtvdemod attatch sucess\n");
+						s_demod_type[i] = DEMOD_SI2168_1;
+					}
+				}
+				if (!strcmp(name,"Avl6762")) {
+					frontend[i] = dvb_attach(avl6762_attach,&config);
+					if (frontend[i] == NULL) {
+						pr_error("dvb attach demod error\n");
+						goto error_fe;
+					} else {
+						pr_inf("dtvdemod attatch sucess\n");
+						s_demod_type[i] = DEMOD_AVL6762;
+					}
+				}
 				if (frontend[i]) {
 					ret = dvb_register_frontend(&advb->dvb_adapter, frontend[i]);
 					if (ret) {
@@ -2452,14 +2548,44 @@ static int aml_dvb_probe(struct platform_device *pdev)
 		return 0;
 error_fe:
 		for (i=0; i<FE_DEV_COUNT; i++) {
-			dvb_detach_demod(&s_demod_type[i]);
-			frontend[i] = NULL;
-			s_demod_type[i] = AM_DTV_DEMOD_NONE;
-
-			dvb_detach_tuner(&s_tuner_type[i]);
-			s_tuner_type[i] = AM_TUNER_NONE;
+			if (s_demod_type[i] == DEMOD_INTERNAL) {
+				dvb_detach(aml_dtvdm_attach);
+				frontend[i] = NULL;
+				s_demod_type[i] = DEMOD_INVALID;
+			}else if (s_demod_type[i] == DEMOD_ATBM8881) {
+				dvb_detach(atbm8881_attach);
+				frontend[i] = NULL;
+				s_demod_type[i] = DEMOD_INVALID;
+			}else if (s_demod_type[i] == DEMOD_SI2168) {
+				dvb_detach(si2168_attach);
+				frontend[i] = NULL;
+				s_demod_type[i] = DEMOD_INVALID;
+			}else if (s_demod_type[i] == DEMOD_SI2168_1) {
+				dvb_detach(si2168_attach_1);
+				frontend[i] = NULL;
+				s_demod_type[i] = DEMOD_INVALID;
+			}else if (s_demod_type[i] == DEMOD_AVL6762) {
+				dvb_detach(avl6762_attach);
+				frontend[i] = NULL;
+				s_demod_type[i] = DEMOD_INVALID;
+			}
+			if (s_tuner_type[i] == TUNER_SI2151) {
+				dvb_detach(si2151_attach);
+				s_tuner_type[i] = TUNER_INVALID;
+			}else if (s_tuner_type[i] == TUNER_MXL661) {
+				dvb_detach(mxl661_attach);
+				s_tuner_type[i] = TUNER_INVALID;
+			}else if (s_tuner_type[i] == TUNER_SI2159) {
+				dvb_detach(si2159_attach);
+				s_tuner_type[i] = TUNER_INVALID;
+			}else if (s_tuner_type[i] == TUNER_R842) {
+				dvb_detach(r842_attach);
+				s_tuner_type[i] = TUNER_INVALID;
+			}else if (s_tuner_type[i] == TUNER_R840) {
+				dvb_detach(r840_attach);
+				s_tuner_type[i] = TUNER_INVALID;
+			}
 		}
-
 		return 0;
 	}
 
@@ -2493,26 +2619,41 @@ static int aml_dvb_remove(struct platform_device *pdev)
 	int i;
 
 	for (i=0; i<FE_DEV_COUNT; i++) {
-		dvb_detach_demod(&s_demod_type[i]);
-
-		dvb_detach_tuner(&s_tuner_type[i]);
+		if (s_demod_type[i] == DEMOD_INTERNAL) {
+			dvb_detach(aml_dtvdm_attach);
+		}else if (s_demod_type[i] == DEMOD_ATBM8881) {
+			dvb_detach(atbm8881_attach);
+		}else if (s_demod_type[i] == DEMOD_SI2168) {
+			dvb_detach(si2168_attach);
+		}else if (s_demod_type[i] == DEMOD_SI2168_1) {
+			dvb_detach(si2168_attach_1);
+		}else if (s_demod_type[i] == DEMOD_AVL6762) {
+			dvb_detach(avl6762_attach);
+		}
+		if (s_tuner_type[i] == TUNER_SI2151) {
+			dvb_detach(si2151_attach);
+		}else if (s_tuner_type[i] == TUNER_MXL661) {
+			dvb_detach(mxl661_attach);
+		}else if (s_tuner_type[i] == TUNER_SI2159) {
+			dvb_detach(si2159_attach);
+		}else if (s_tuner_type[i] == TUNER_R842) {
+			dvb_detach(r842_attach);
+		}else if (s_tuner_type[i] == TUNER_R840) {
+			dvb_detach(r840_attach);
+		}
 
-		if (frontend[i] &&
-			((s_tuner_type[i] == AM_TUNER_SI2151)
-			|| (s_tuner_type[i] == AM_TUNER_MXL661)
-			|| (s_tuner_type[i] == AM_TUNER_SI2159)
-			|| (s_tuner_type[i] == AM_TUNER_R842)
-			|| (s_tuner_type[i] == AM_TUNER_R840)
-			|| (s_tuner_type[i] == AM_TUNER_ATBM2040))) {
+		if (frontend[i] && \
+			( (s_tuner_type[i] == TUNER_SI2151) || (s_tuner_type[i] == TUNER_MXL661) || (s_tuner_type[i] == TUNER_SI2159) || (s_tuner_type[i] == TUNER_R842) || (s_tuner_type[i] == TUNER_R840)) \
+			)
+		{
 			dvb_unregister_frontend(frontend[i]);
 			dvb_frontend_detach(frontend[i]);
 		}
-
 		frontend[i] = NULL;
-		s_demod_type[i] = AM_DTV_DEMOD_NONE;
-		s_tuner_type[i] = AM_TUNER_NONE;
-	}
+		s_demod_type[i] = DEMOD_INVALID;
+		s_tuner_type[i] = TUNER_INVALID;
 
+	}
 	tsdemux_set_ops(NULL);
 
 	aml_unregist_dmx_class();
diff --git a/drivers/stream_input/parser/hw_demux/aml_dvb.h b/drivers/stream_input/parser/hw_demux/aml_dvb.h
index 5c943c8..41c7d0f 100644
--- a/drivers/stream_input/parser/hw_demux/aml_dvb.h
+++ b/drivers/stream_input/parser/hw_demux/aml_dvb.h
@@ -49,6 +49,7 @@
 #include <dvb_filter.h>
 #include <dvb_net.h>
 #include <dvb_ringbuffer.h>
+#include <dvb_frontend.h>
 
 #include <linux/of.h>
 #include <linux/pinctrl/consumer.h>
@@ -307,6 +308,12 @@ struct aml_swfilter {
 	int    track_dmx;
 };
 
+struct aml_tuner {
+	struct tuner_config cfg;
+	unsigned int i2c_adapter_id;
+	struct i2c_adapter *i2c_adp;
+};
+
 struct aml_dvb {
 	struct dvb_device    dvb_dev;
 	int ts_in_total_count;
diff --git a/drivers/stream_input/tv_frontend/Makefile b/drivers/stream_input/tv_frontend/Makefile
new file mode 100644
index 0000000..404c513
--- /dev/null
+++ b/drivers/stream_input/tv_frontend/Makefile
@@ -0,0 +1,16 @@
+obj-m	+= aml_hardware_fe.o
+
+ccflags-y += -I$(srctree)/drivers/media/dvb-core -I$(srctree)/drivers/gpio -I$(srctree)/include
+
+aml_hardware_fe-objs += aml_fe.o
+
+# aml_atvdemod-objs += atv_demod/atvdemod_frontend.o
+# aml_atvdemod-objs += atv_demod/atvdemod_func.o
+
+# aml_dtvdemod-objs += dtv_demod/aml_demod.o
+# aml_dtvdemod-objs += dtv_demod/amlfrontend.o
+# aml_dtvdemod-objs += dtv_demod/demod_func.o
+# aml_dtvdemod-objs += dtv_demod/dvbc_func.o
+# aml_dtvdemod-objs += dtv_demod/dvbt_func.o
+# aml_dtvdemod-objs += dtv_demod/i2c_func.o
+# aml_dtvdemod-objs += dtv_demod/tuner_func.o
diff --git a/drivers/stream_input/tv_frontend/aml_fe.c b/drivers/stream_input/tv_frontend/aml_fe.c
new file mode 100644
index 0000000..6253def
--- /dev/null
+++ b/drivers/stream_input/tv_frontend/aml_fe.c
@@ -0,0 +1,1372 @@
+/*
+* Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT
+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+* more details.
+*
+* You should have received a copy of the GNU General Public License along
+* with this program; if not, write to the Free Software Foundation, Inc.,
+* 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+*
+* Description:
+*/
+/*
+ * AMLOGIC DVB frontend driver.
+ */
+
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/wait.h>
+#include <linux/string.h>
+#include <linux/interrupt.h>
+#include <linux/fs.h>
+#include <linux/cdev.h>
+#include <linux/device.h>
+#include <linux/spinlock.h>
+#include <linux/fcntl.h>
+#include <asm/irq.h>
+#include <linux/uaccess.h>
+#include <linux/poll.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/gpio/consumer.h>
+#include <linux/gpio.h>
+#include <linux/dma-contiguous.h>
+#include <linux/of_gpio.h>
+/*add for gpio api by hualing.chen*/
+#include <gpiolib.h>
+
+#include "aml_fe.h"
+
+#ifdef pr_dbg
+#undef pr_dbg
+#endif
+
+#define pr_dbg(fmt, args ...) \
+	pr_info("FE: " fmt, ## args)
+#define pr_error(fmt, args ...) pr_err("FE: " fmt, ## args)
+#define pr_inf(fmt, args ...) pr_info("FE: " fmt, ## args)
+
+static DEFINE_SPINLOCK(lock);
+static struct aml_fe_drv *tuner_drv_list;
+static struct aml_fe_drv *atv_demod_drv_list;
+static struct aml_fe_drv *dtv_demod_drv_list;
+static struct aml_fe_man fe_man;
+static long aml_fe_suspended;
+
+static int aml_fe_set_sys(struct dvb_frontend *dev,
+			enum fe_delivery_system sys);
+
+static struct aml_fe_drv **aml_get_fe_drv_list(enum aml_fe_dev_type_t type)
+{
+	switch (type) {
+	case AM_DEV_TUNER:
+		return &tuner_drv_list;
+	case AM_DEV_ATV_DEMOD:
+		return &atv_demod_drv_list;
+	case AM_DEV_DTV_DEMOD:
+		return &dtv_demod_drv_list;
+	default:
+		return NULL;
+	}
+}
+
+
+
+int amlogic_gpio_direction_output(unsigned int pin, int value,
+				  const char *owner)
+{
+	gpio_direction_output(pin, value);
+	return 0;
+}
+EXPORT_SYMBOL(amlogic_gpio_direction_output);
+int amlogic_gpio_request(unsigned int pin, const char *label)
+{
+	return 0;
+}
+EXPORT_SYMBOL(amlogic_gpio_request);
+int aml_register_fe_drv(enum aml_fe_dev_type_t type, struct aml_fe_drv *drv)
+{
+	if (drv) {
+		struct aml_fe_drv **list = aml_get_fe_drv_list(type);
+		unsigned long flags;
+
+		spin_lock_irqsave(&lock, flags);
+
+		drv->next = *list;
+		*list = drv;
+
+		drv->ref = 0;
+
+		spin_unlock_irqrestore(&lock, flags);
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(aml_register_fe_drv);
+
+int aml_unregister_fe_drv(enum aml_fe_dev_type_t type, struct aml_fe_drv *drv)
+{
+	int ret = 0;
+
+	if (drv) {
+		struct aml_fe_drv *pdrv, *pprev;
+		struct aml_fe_drv **list = aml_get_fe_drv_list(type);
+		unsigned long flags;
+
+		spin_lock_irqsave(&lock, flags);
+
+		if (!drv->ref) {
+			for (pprev = NULL, pdrv = *list;
+			     pdrv; pprev = pdrv, pdrv = pdrv->next) {
+				if (pdrv == drv) {
+					if (pprev)
+						pprev->next = pdrv->next;
+					else
+						*list = pdrv->next;
+					break;
+				}
+			}
+		} else {
+			pr_error("fe driver %d is inused\n", drv->id);
+			ret = -1;
+		}
+
+		spin_unlock_irqrestore(&lock, flags);
+	}
+
+	return ret;
+}
+EXPORT_SYMBOL(aml_unregister_fe_drv);
+
+static int aml_fe_support_sys(struct aml_fe *fe,
+			enum fe_delivery_system sys)
+{
+	if (fe->dtv_demod
+			&& fe->dtv_demod->drv
+			&& fe->dtv_demod->drv->support) {
+		if (!fe->dtv_demod->drv->support(fe->dtv_demod, sys))
+			return 0;
+	}
+
+	if (fe->atv_demod
+			&& fe->atv_demod->drv
+			&& fe->atv_demod->drv->support) {
+		if (!fe->atv_demod->drv->support(fe->atv_demod, sys))
+			return 0;
+	}
+
+	if (fe->tuner
+			&& fe->tuner->drv
+			&& fe->tuner->drv->support) {
+		if (!fe->tuner->drv->support(fe->tuner, sys))
+			return 0;
+	}
+
+	return 1;
+}
+/*
+ *#define DTV_START_BLIND_SCAN            71
+ *#define DTV_CANCEL_BLIND_SCAN           72
+ *#define DTV_BLIND_SCAN_MIN_FRE          73
+ *#define DTV_BLIND_SCAN_MAX_FRE          74
+ *#define DTV_BLIND_SCAN_MIN_SRATE        75
+ *#define DTV_BLIND_SCAN_MAX_SRATE        76
+ *#define DTV_BLIND_SCAN_FRE_RANGE        77
+ *#define DTV_BLIND_SCAN_FRE_STEP         78
+ *#define DTV_BLIND_SCAN_TIMEOUT          79
+ */
+static int aml_fe_blind_cmd(struct dvb_frontend *dev,
+			struct dtv_property *tvp)
+{
+	struct aml_fe *fe;
+	int ret = 0;
+
+	fe = dev->demodulator_priv;
+	pr_error("fe blind cmd into cmd:[%d]\n", tvp->cmd);
+	switch (tvp->cmd) {
+	case DTV_START_BLIND_SCAN:
+		if (fe->dtv_demod
+			&& fe->dtv_demod->drv
+			&& fe->dtv_demod->drv->start_blind_scan) {
+			ret = fe->dtv_demod->drv->start_blind_scan(
+					fe->dtv_demod);
+		} else {
+			pr_error("fe dtv_demod not surport blind start\n");
+		}
+		break;
+	case DTV_CANCEL_BLIND_SCAN:
+		if (fe->dtv_demod
+			&& fe->dtv_demod->drv
+			&& fe->dtv_demod->drv->stop_blind_scan) {
+			ret = fe->dtv_demod->drv->stop_blind_scan(
+				fe->dtv_demod);
+		} else {
+			pr_error("fe dtv_demod not surport blind stop\n");
+		}
+		break;
+	case DTV_BLIND_SCAN_MIN_FRE:
+		fe->blind_scan_para.minfrequency = tvp->u.data;
+		break;
+	case DTV_BLIND_SCAN_MAX_FRE:
+		fe->blind_scan_para.maxfrequency = tvp->u.data;
+		break;
+	case DTV_BLIND_SCAN_MIN_SRATE:
+		fe->blind_scan_para.minSymbolRate = tvp->u.data;
+		break;
+	case DTV_BLIND_SCAN_MAX_SRATE:
+		fe->blind_scan_para.maxSymbolRate = tvp->u.data;
+		break;
+	case DTV_BLIND_SCAN_FRE_RANGE:
+		fe->blind_scan_para.frequencyRange = tvp->u.data;
+		break;
+	case DTV_BLIND_SCAN_FRE_STEP:
+		fe->blind_scan_para.frequencyStep = tvp->u.data;
+		break;
+	case DTV_BLIND_SCAN_TIMEOUT:
+		fe->blind_scan_para.timeout = tvp->u.data;
+		break;
+	default:
+		ret = 0;
+		break;
+	}
+	return ret;
+}
+
+static int aml_fe_set_property(struct dvb_frontend *dev,
+			struct dtv_property *tvp)
+{
+	struct aml_fe *fe;
+	int r = 0;
+
+	fe = dev->demodulator_priv;
+
+	if (tvp->cmd == DTV_DELIVERY_SYSTEM) {
+		enum fe_delivery_system sys = tvp->u.data;
+
+		pr_error("fe aml_fe_set_property %d\n", sys);
+		r = aml_fe_set_sys(dev, sys);
+		if (r < 0)
+			return r;
+	}
+
+	if (tvp->cmd == DTV_DELIVERY_SUB_SYSTEM) {
+		int sub_sys = tvp->u.data;
+
+		pr_error("fe aml_fe_set_property sub_sys: %d\n", sub_sys);
+		fe->sub_sys = sub_sys;
+		r = 0;
+	}
+	pr_error("fe aml_fe_set_property -tvp->cmd[%d]\n", tvp->cmd);
+	switch (tvp->cmd) {
+	case DTV_START_BLIND_SCAN:
+	case DTV_CANCEL_BLIND_SCAN:
+	case DTV_BLIND_SCAN_MIN_FRE:
+	case DTV_BLIND_SCAN_MAX_FRE:
+	case DTV_BLIND_SCAN_MIN_SRATE:
+	case DTV_BLIND_SCAN_MAX_SRATE:
+	case DTV_BLIND_SCAN_FRE_RANGE:
+	case DTV_BLIND_SCAN_FRE_STEP:
+	case DTV_BLIND_SCAN_TIMEOUT:
+		r = aml_fe_blind_cmd(dev, tvp);
+		if (r < 0)
+			return r;
+	default:
+		break;
+	}
+
+	if (fe->set_property) {
+		pr_error("fe fe->set_property -0\n");
+		return fe->set_property(dev, tvp);
+	}
+	pr_error("fe aml_fe_set_property -2\n");
+	return r;
+}
+
+static int aml_fe_get_property(struct dvb_frontend *dev,
+			struct dtv_property *tvp)
+{
+	struct aml_fe *fe;
+	int r = 0;
+
+	fe = dev->demodulator_priv;
+
+	if (tvp->cmd == DTV_TS_INPUT)
+		tvp->u.data = fe->ts;
+	if (tvp->cmd == DTV_DELIVERY_SUB_SYSTEM) {
+		tvp->u.data = fe->sub_sys;
+		pr_error("fe aml_fe_get_property sub_sys: %d\n", fe->sub_sys);
+		r = 0;
+	}
+	if (fe->get_property)
+		return fe->get_property(dev, tvp);
+
+	return r;
+}
+
+static int aml_fe_set_sys(struct dvb_frontend *dev,
+			enum fe_delivery_system sys)
+{
+	struct aml_fe *fe = dev->demodulator_priv;
+	unsigned long flags;
+	int ret = -1;
+
+	if (fe->sys == sys) {
+		pr_dbg("[%s]:the mode is not change!!!!\n", __func__);
+		return 0;
+	}
+	/*set dvb-t or dvb-t2
+	 * if dvb-t or t2 is set
+	 * we only set sys value, not init sys
+	 */
+	if (fe->sys != SYS_UNDEFINED) {
+		pr_dbg("release system %d\n", fe->sys);
+
+		if (fe->dtv_demod
+				&& fe->dtv_demod->drv
+				&& fe->dtv_demod->drv->release_sys)
+			fe->dtv_demod->drv->release_sys(fe->dtv_demod, fe->sys);
+		if (fe->atv_demod
+				&& fe->atv_demod->drv
+				&& fe->atv_demod->drv->release_sys)
+			fe->atv_demod->drv->release_sys(fe->atv_demod, fe->sys);
+		if (fe->tuner
+				&& fe->tuner->drv
+				&& fe->tuner->drv->release_sys)
+			fe->tuner->drv->release_sys(fe->tuner, fe->sys);
+
+		fe->set_property = NULL;
+		fe->get_property = NULL;
+
+		fe->sys = SYS_UNDEFINED;
+	}
+
+	if (sys == SYS_UNDEFINED)
+		return 0;
+
+	if (!aml_fe_support_sys(fe, sys)) {
+		int i;
+
+		spin_lock_irqsave(&lock, flags);
+		for (i = 0; i < FE_DEV_COUNT; i++) {
+			if (aml_fe_support_sys(&fe_man.fe[i], sys)
+					&& (fe_man.fe[i].dev_id == fe->dev_id))
+				break;
+		}
+		spin_unlock_irqrestore(&lock, flags);
+
+		if (i >= FE_DEV_COUNT) {
+			pr_error("do not support delivery system %d\n", sys);
+			return -1;
+		}
+
+		fe = &fe_man.fe[i];
+		dev->demodulator_priv = fe;
+	}
+
+	spin_lock_irqsave(&fe->slock, flags);
+
+	memset(&fe->fe->ops.tuner_ops, 0, sizeof(fe->fe->ops.tuner_ops));
+	memset(&fe->fe->ops.analog_ops, 0, sizeof(fe->fe->ops.analog_ops));
+	memset(&fe->fe->ops.info, 0, sizeof(fe->fe->ops.info));
+	fe->fe->ops.release = NULL;
+	fe->fe->ops.release_sec = NULL;
+	fe->fe->ops.init = NULL;
+	fe->fe->ops.sleep = NULL;
+	fe->fe->ops.write = NULL;
+	fe->fe->ops.tune = NULL;
+	fe->fe->ops.get_frontend_algo = NULL;
+	fe->fe->ops.set_frontend = NULL;
+	fe->fe->ops.get_tune_settings = NULL;
+	fe->fe->ops.get_frontend = NULL;
+	fe->fe->ops.read_status = NULL;
+	fe->fe->ops.read_ber = NULL;
+	fe->fe->ops.read_signal_strength = NULL;
+	fe->fe->ops.read_snr = NULL;
+	fe->fe->ops.read_ucblocks = NULL;
+	fe->fe->ops.diseqc_reset_overload = NULL;
+	fe->fe->ops.diseqc_send_master_cmd = NULL;
+	fe->fe->ops.diseqc_recv_slave_reply = NULL;
+	fe->fe->ops.diseqc_send_burst = NULL;
+	fe->fe->ops.set_tone = NULL;
+	fe->fe->ops.set_voltage = NULL;
+	fe->fe->ops.enable_high_lnb_voltage = NULL;
+	fe->fe->ops.dishnetwork_send_legacy_command = NULL;
+	fe->fe->ops.i2c_gate_ctrl = NULL;
+	fe->fe->ops.ts_bus_ctrl = NULL;
+	fe->fe->ops.search = NULL;
+	fe->fe->ops.set_property = NULL;
+	fe->fe->ops.get_property = NULL;
+
+	if (fe->tuner
+			&& fe->tuner->drv
+			&& fe->tuner->drv->get_ops)
+		fe->tuner->drv->get_ops(fe->tuner, sys, &fe->fe->ops);
+
+	if (fe->atv_demod
+			&& fe->atv_demod->drv
+			&& fe->atv_demod->drv->get_ops)
+		fe->atv_demod->drv->get_ops(fe->atv_demod, sys, &fe->fe->ops);
+
+	if (fe->dtv_demod
+			&& fe->dtv_demod->drv
+			&& fe->dtv_demod->drv->get_ops)
+		fe->dtv_demod->drv->get_ops(fe->dtv_demod, sys, &fe->fe->ops);
+
+	spin_unlock_irqrestore(&fe->slock, flags);
+
+	pr_dbg("init system %d\n", sys);
+
+	if (fe->dtv_demod
+			&& fe->dtv_demod->drv
+			&& fe->dtv_demod->drv->init_sys)
+		ret = fe->dtv_demod->drv->init_sys(fe->dtv_demod, sys);
+	if (fe->atv_demod
+			&& fe->atv_demod->drv
+			&& fe->atv_demod->drv->init_sys)
+		ret = fe->atv_demod->drv->init_sys(fe->atv_demod, sys);
+	if (fe->tuner
+			&& fe->tuner->drv
+			&& fe->tuner->drv->init_sys)
+		ret = fe->tuner->drv->init_sys(fe->tuner, sys);
+
+	if (ret != 0) {
+		pr_error("init system, %d fail, ret %d\n", sys, ret);
+		goto end;
+	}
+
+	fe->set_property = fe->fe->ops.set_property;
+	fe->get_property = fe->fe->ops.get_property;
+
+	strcpy(fe->fe->ops.info.name, "amlogic dvb frontend");
+	fe->sys = sys;
+	pr_dbg("set mode ok\n");
+
+end:
+	fe->fe->ops.set_property = aml_fe_set_property;
+	fe->fe->ops.get_property = aml_fe_get_property;
+
+	return 0;
+}
+
+static const char *aml_fe_dev_type_str(struct aml_fe_dev *dev)
+{
+	switch (dev->type) {
+	case AM_DEV_TUNER:
+		return "tuner";
+	case AM_DEV_ATV_DEMOD:
+		return "atv_demod";
+	case AM_DEV_DTV_DEMOD:
+		return "dtv_demod";
+	}
+
+	return "";
+}
+
+static void aml_fe_property_name(struct aml_fe_dev *dev, const char *name,
+			char *buf)
+{
+	const char *tstr;
+
+	tstr = aml_fe_dev_type_str(dev);
+
+	if (name)
+		sprintf(buf, "%s%d_%s", tstr, dev->dev_id, name);
+	else
+		sprintf(buf, "%s%d", tstr, dev->dev_id);
+}
+
+int aml_fe_of_property_string(struct aml_fe_dev *dev,
+			const char *name, const char **str)
+{
+	struct platform_device *pdev = dev->man->pdev;
+	//char   buf[128];
+	int    r;
+
+	//aml_fe_property_name(dev, name, buf);
+	pr_error("start find resource: \"%s\" --\n", name);
+	r = of_property_read_string(pdev->dev.of_node, name, str);
+	if (r)
+		pr_error("cannot find resource: \"%s\"\n", name);
+
+	return r;
+}
+EXPORT_SYMBOL(aml_fe_of_property_string);
+
+int aml_fe_of_property_u32(struct aml_fe_dev *dev,
+			const char *name, u32 *v)
+{
+	struct platform_device *pdev = dev->man->pdev;
+	//char   buf[128];
+	int    r;
+
+	//aml_fe_property_name(dev, name, buf);
+	r = of_property_read_u32(pdev->dev.of_node, name, v);
+	if (r)
+		pr_error("cannot find resource \"%s\"\n", name);
+
+	return r;
+}
+EXPORT_SYMBOL(aml_fe_of_property_u32);
+
+static int aml_fe_dev_init(struct aml_fe_man *man,
+			   enum aml_fe_dev_type_t type,
+			   struct aml_fe_dev *dev,
+			   int id)
+{
+	struct aml_fe_drv **list = aml_get_fe_drv_list(type);
+	struct aml_fe_drv *drv;
+	unsigned long flags;
+	char  buf[128];
+	const char *str;
+	char *name = NULL;
+	u32 value;
+	int ret;
+	struct device_node *node;
+
+	dev->man    = man;
+	dev->dev_id = id;
+	dev->type   = type;
+	dev->drv    = NULL;
+	dev->fe     = NULL;
+	dev->priv_data = NULL;
+
+	memset(buf, 0, 128);
+	name = NULL;
+	aml_fe_property_name(dev, name, buf);
+	pr_dbg("get string: %s\n", buf);
+	ret = aml_fe_of_property_string(dev, buf, &str);
+	if (ret) {
+		pr_dbg("get string: %s error\n", buf);
+		return 0;
+	}
+
+
+	spin_lock_irqsave(&lock, flags);
+
+	for (drv = *list; drv; drv = drv->next)
+		if (!strcmp(drv->name, str))
+			break;
+
+	if (dev->drv != drv) {
+		if (dev->drv) {
+			dev->drv->ref--;
+			if (dev->drv->owner)
+				module_put(dev->drv->owner);
+		}
+		if (drv) {
+			drv->ref++;
+			if (drv->owner)
+				try_module_get(drv->owner);
+		}
+		dev->drv = drv;
+	}
+
+	spin_unlock_irqrestore(&lock, flags);
+
+	if (drv) {
+		pr_inf("found driver: %s\n", str);
+	} else {
+		pr_err("cannot find driver: %s\n", str);
+		return -1;
+	}
+	/*get i2c adap and i2c addr*/
+	memset(buf, 0, 128);
+	name = "i2c_adap";
+	aml_fe_property_name(dev, name, buf);
+	pr_dbg("get u32: %s\n", buf);
+	//ret = aml_fe_of_property_u32(dev, buf, &value);
+	node = of_parse_phandle(dev->man->pdev->dev.of_node, buf, 0);
+	if (node) {
+		dev->i2c_adap = of_find_i2c_adapter_by_node(node);
+		pr_inf("%s:[%p]\n", buf, dev->i2c_adap);
+		of_node_put(node);
+	} else {
+		dev->i2c_adap_id = -1;
+		pr_error("cannot find resource \"%s\"\n", buf);
+	}
+	memset(buf, 0, 128);
+	name = "i2c_addr";
+	aml_fe_property_name(dev, name, buf);
+	pr_dbg("get u32: %s\n", buf);
+	ret = aml_fe_of_property_u32(dev, buf, &value);
+	if (!ret) {
+		dev->i2c_addr = value;
+		pr_inf("%s: %d\n", buf, dev->i2c_addr);
+	} else {
+		dev->i2c_addr = -1;
+		pr_error("cannot find resource \"%s\"\n", buf);
+	}
+	/*get i2c reset and reset value*/
+	memset(buf, 0, 128);
+	name = "reset_gpio";
+	aml_fe_property_name(dev, name, buf);
+	pr_dbg("get string: %s\n", buf);
+	ret = aml_fe_of_property_string(dev, buf, &str);
+	if (!ret) {
+		dev->reset_gpio =
+		     of_get_named_gpio_flags(dev->man->pdev->dev.of_node,
+		     buf, 0, NULL);
+		pr_inf("%s: %s\n", buf, str);
+	} else {
+		dev->reset_gpio = -1;
+		pr_error("cannot find resource \"%s\"\n", buf);
+	}
+	memset(buf, 0, 128);
+	name = "reset_value";
+	aml_fe_property_name(dev, name, buf);
+	pr_dbg("get u32: %s\n", buf);
+	ret = aml_fe_of_property_u32(dev, buf, &value);
+	if (!ret) {
+		dev->reset_value = value;
+		pr_inf("%s: %d\n", buf, dev->reset_value);
+	} else {
+		dev->reset_value = -1;
+	}
+
+	if (dev->drv && dev->drv->init) {
+		int ret;
+
+		ret = dev->drv->init(dev);
+		if (ret != 0) {
+			dev->drv = NULL;
+			pr_error("[aml_fe..]%s error.\n", __func__);
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
+static int aml_fe_dev_release(struct aml_fe_dev *dev)
+{
+	if (dev->drv) {
+		if (dev->drv->owner)
+			module_put(dev->drv->owner);
+		dev->drv->ref--;
+		if (dev->drv->release)
+			dev->drv->release(dev);
+	}
+
+	dev->drv = NULL;
+	return 0;
+}
+
+static void aml_fe_man_run(struct aml_fe *fe)
+{
+	if (fe->init)
+		return;
+
+	if (fe->tuner && fe->tuner->drv)
+		fe->init = 1;
+
+	if (fe->atv_demod && fe->atv_demod->drv)
+		fe->init = 1;
+
+	if (fe->dtv_demod && fe->dtv_demod->drv)
+		fe->init = 1;
+
+	if (fe->init) {
+		struct aml_dvb *dvb = fe->man->dvb;
+		int reg = 1;
+		int ret;
+		int id;
+
+		spin_lock_init(&fe->slock);
+
+		fe->sys = SYS_UNDEFINED;
+
+		pr_dbg("fe: %p\n", fe);
+
+		for (id = 0; id < FE_DEV_COUNT; id++) {
+			struct aml_fe *prev_fe = &fe_man.fe[id];
+
+			if (prev_fe == fe)
+				continue;
+			if (prev_fe->init && (prev_fe->dev_id == fe->dev_id)) {
+				reg = 0;
+				break;
+			}
+		}
+
+		fe->fe = &fe_man.dev[fe->dev_id];
+		if (reg) {
+			fe->fe->demodulator_priv = fe;
+			fe->fe->ops.set_property = aml_fe_set_property;
+			fe->fe->ops.get_property = aml_fe_set_property;
+		}
+
+		if (fe->tuner)
+			fe->tuner->fe = fe;
+		if (fe->atv_demod)
+			fe->atv_demod->fe = fe;
+		if (fe->dtv_demod)
+			fe->dtv_demod->fe = fe;
+
+		ret = dvb_register_frontend(&dvb->dvb_adapter, fe->fe);
+		if (ret) {
+			pr_error("register fe%d failed\n", fe->dev_id);
+			return;
+		}
+	}
+}
+
+static void fe_property_name(struct aml_fe *fe, const char *name,
+			char *buf)
+{
+	if (name)
+		sprintf(buf, "fe%d_%s", fe->dev_id, name);
+	else
+		sprintf(buf, "fe%d", fe->dev_id);
+}
+
+static int fe_of_property_u32(struct aml_fe *fe,
+			const char *name, u32 *v)
+{
+	struct platform_device *pdev = fe->man->pdev;
+	char   buf[128];
+	int    r;
+
+	fe_property_name(fe, name, buf);
+	r = of_property_read_u32(pdev->dev.of_node, buf, v);
+	if (r)
+		pr_error("cannot find resource \"%s\"\n", buf);
+
+	return r;
+}
+
+static int aml_fe_man_init(struct aml_fe_man *man, struct aml_fe *fe, int id)
+{
+	u32 value;
+	int ret;
+
+	fe->sys    = SYS_UNDEFINED;
+	fe->man    = man;
+	fe->dev_id = id;
+	fe->init   = 0;
+	fe->ts     = AM_TS_SRC_TS0;
+	fe->work_running = 0;
+	fe->work_q       = NULL;
+	fe->tuner        = NULL;
+	fe->atv_demod    = NULL;
+	fe->dtv_demod    = NULL;
+	fe->do_work      = NULL;
+	fe->get_property = NULL;
+	fe->set_property = NULL;
+
+	init_waitqueue_head(&fe->wait_q);
+	spin_lock_init(&fe->slock);
+
+	ret = fe_of_property_u32(fe, "tuner", &value);
+	if (!ret) {
+		id = value;
+
+		if ((id < 0) || (id >= FE_DEV_COUNT) || !fe_man.tuner[id].drv) {
+			pr_error("invalid tuner device id %d\n", id);
+			return -1;
+		}
+
+		fe->tuner = &fe_man.tuner[id];
+		fe_man.tuner[id].fe = fe;
+	}
+
+	ret = fe_of_property_u32(fe, "atv_demod", &value);
+	if (!ret) {
+		id = value;
+
+		if ((id < 0) ||
+			(id >= FE_DEV_COUNT) ||
+			!fe_man.atv_demod[id].drv) {
+			pr_error("invalid ATV demod device id %d\n", id);
+			return -1;
+		}
+
+		fe->atv_demod = &fe_man.atv_demod[id];
+		fe_man.atv_demod[id].fe = fe;
+	}
+
+	ret = fe_of_property_u32(fe, "dtv_demod", &value);
+	if (!ret) {
+		id = value;
+
+		if ((id < 0) ||
+			(id >= FE_DEV_COUNT) ||
+			!fe_man.dtv_demod[id].drv) {
+			pr_error("invalid DTV demod device id %d\n", id);
+			return -1;
+		}
+
+		fe->dtv_demod = &fe_man.dtv_demod[id];
+		fe_man.dtv_demod[id].fe = fe;
+	}
+
+	ret = fe_of_property_u32(fe, "ts", &value);
+	if (!ret) {
+		enum aml_ts_source_t ts = AM_TS_SRC_TS0;
+
+		switch (value) {
+		case 0:
+			ts = AM_TS_SRC_TS0;
+			break;
+		case 1:
+			ts = AM_TS_SRC_TS1;
+			break;
+		case 2:
+			ts = AM_TS_SRC_TS2;
+			break;
+		default:
+			break;
+		}
+
+		fe->ts = ts;
+	}
+
+	ret = fe_of_property_u32(fe, "dev", &value);
+	if (!ret) {
+		id = value;
+
+		if ((id >= 0) && (id < FE_DEV_COUNT))
+			fe->dev_id = id;
+		else
+			fe->dev_id = 0;
+	}
+
+	aml_fe_man_run(fe);
+
+	return 0;
+}
+
+static int aml_fe_man_release(struct aml_fe *fe)
+{
+	if (fe->init) {
+		aml_fe_cancel_work(fe);
+
+		if (fe->work_q)
+			destroy_workqueue(fe->work_q);
+
+		aml_fe_set_sys(fe->fe, SYS_UNDEFINED);
+		dvb_unregister_frontend(fe->fe);
+		dvb_frontend_detach(fe->fe);
+
+		fe->tuner = NULL;
+		fe->atv_demod = NULL;
+		fe->dtv_demod = NULL;
+		fe->init = 0;
+	}
+
+	return 0;
+}
+
+void aml_fe_set_pdata(struct aml_fe_dev *dev, void *pdata)
+{
+	dev->priv_data = pdata;
+}
+EXPORT_SYMBOL(aml_fe_set_pdata);
+
+void *aml_fe_get_pdata(struct aml_fe_dev *dev)
+{
+	return dev->priv_data;
+}
+EXPORT_SYMBOL(aml_fe_get_pdata);
+
+static void aml_fe_do_work(struct work_struct *work)
+{
+	struct aml_fe *fe;
+
+	fe = container_of(work, struct aml_fe, work);
+
+	if (fe->do_work)
+		fe->do_work(fe);
+
+	fe->work_running = 0;
+}
+
+void aml_fe_schedule_work(struct aml_fe *fe, void(*func)(struct aml_fe *fe))
+{
+	if (fe->work_running)
+		cancel_work_sync(&fe->work);
+
+	fe->work_running = 1;
+	fe->do_work      = func;
+
+	if (!fe->work_q) {
+		fe->work_q = create_singlethread_workqueue("amlfe");
+		INIT_WORK(&fe->work, aml_fe_do_work);
+	}
+
+	queue_work(fe->work_q, &fe->work);
+}
+EXPORT_SYMBOL(aml_fe_schedule_work);
+
+void aml_fe_cancel_work(struct aml_fe *fe)
+{
+	if (fe->work_running) {
+		fe->work_running = 0;
+		cancel_work_sync(&fe->work);
+	}
+
+	fe->do_work = NULL;
+}
+EXPORT_SYMBOL(aml_fe_cancel_work);
+
+
+int aml_fe_work_cancelled(struct aml_fe *fe)
+{
+	return fe->work_running ? 0 : 1;
+}
+EXPORT_SYMBOL(aml_fe_work_cancelled);
+
+int aml_fe_work_sleep(struct aml_fe *fe, unsigned long delay)
+{
+	wait_event_interruptible_timeout(fe->wait_q, !fe->work_running, delay);
+	return aml_fe_work_cancelled(fe);
+}
+EXPORT_SYMBOL(aml_fe_work_sleep);
+
+static ssize_t tuner_name_show(struct class *cls, struct class_attribute *attr,
+			       char *buf)
+{
+	size_t len = 0;
+	struct aml_fe_drv *drv;
+	unsigned long flags;
+
+	struct aml_fe_drv **list = aml_get_fe_drv_list(AM_DEV_TUNER);
+
+	spin_lock_irqsave(&lock, flags);
+	for (drv = *list; drv; drv = drv->next)
+		len += sprintf(buf + len, "%s\n", drv->name);
+	spin_unlock_irqrestore(&lock, flags);
+	return len;
+}
+
+static ssize_t atv_demod_name_show(struct class *cls,
+				   struct class_attribute *attr, char *buf)
+{
+	size_t len = 0;
+	struct aml_fe_drv *drv;
+	unsigned long flags;
+
+	struct aml_fe_drv **list = aml_get_fe_drv_list(AM_DEV_ATV_DEMOD);
+
+	spin_lock_irqsave(&lock, flags);
+	for (drv = *list; drv; drv = drv->next)
+		len += sprintf(buf + len, "%s\n", drv->name);
+	spin_unlock_irqrestore(&lock, flags);
+	return len;
+}
+
+static ssize_t dtv_demod_name_show(struct class *cls,
+				   struct class_attribute *attr, char *buf)
+{
+	size_t len = 0;
+	struct aml_fe_drv *drv;
+	unsigned long flags;
+
+	struct aml_fe_drv **list = aml_get_fe_drv_list(AM_DEV_DTV_DEMOD);
+
+	spin_lock_irqsave(&lock, flags);
+	for (drv = *list; drv; drv = drv->next)
+		len += sprintf(buf + len, "%s\n", drv->name);
+	spin_unlock_irqrestore(&lock, flags);
+	return len;
+}
+
+static ssize_t setting_show(struct class *cls, struct class_attribute *attr,
+			    char *buf)
+{
+	int r, total = 0;
+	int i;
+	struct aml_fe_man *fm = &fe_man;
+
+	r = sprintf(buf, "tuner:\n");
+	buf += r;
+	total += r;
+	for (i = 0; i < FE_DEV_COUNT; i++) {
+		struct aml_fe_dev *dev = &fm->tuner[i];
+
+		if (dev->drv) {
+			r = sprintf(buf, "\t%d: %s\n", i, dev->drv->name);
+			buf += r;
+			total += r;
+		}
+	}
+
+	r = sprintf(buf, "atv_demod:\n");
+	buf += r;
+	total += r;
+	for (i = 0; i < FE_DEV_COUNT; i++) {
+		struct aml_fe_dev *dev = &fm->atv_demod[i];
+
+		if (dev->drv) {
+			r = sprintf(buf, "\t%d: %s\n", i, dev->drv->name);
+			buf += r;
+			total += r;
+		}
+	}
+
+	r = sprintf(buf, "dtv_demod:\n");
+	buf += r;
+	total += r;
+	for (i = 0; i < FE_DEV_COUNT; i++) {
+		struct aml_fe_dev *dev = &fm->dtv_demod[i];
+
+		if (dev->drv) {
+			r = sprintf(buf, "\t%d: %s\n", i, dev->drv->name);
+			buf += r;
+			total += r;
+		}
+	}
+
+	r = sprintf(buf, "frontend:\n");
+	buf += r;
+	total += r;
+	for (i = 0; i < FE_DEV_COUNT; i++) {
+		struct aml_fe *fe = &fm->fe[i];
+
+		r = sprintf(buf,
+			    "\t%d: %s device: %d ts: %d tuner: %s atv_demod: %s dtv_demod: %s\n",
+			    i, fe->init ? "enabled" : "disabled", fe->dev_id,
+			    fe->ts, fe->tuner ? fe->tuner->drv->name : "none",
+			    fe->atv_demod ? fe->atv_demod->drv->name : "none",
+			    fe->dtv_demod ? fe->dtv_demod->drv->name : "none");
+		buf += r;
+		total += r;
+	}
+
+	return total;
+}
+
+static void reset_drv(int id, enum aml_fe_dev_type_t type, const char *name)
+{
+	struct aml_fe_man *fm = &fe_man;
+	struct aml_fe_drv **list;
+	struct aml_fe_drv **pdrv;
+	struct aml_fe_drv *drv;
+	struct aml_fe_drv *old;
+
+	if ((id < 0) || (id >= FE_DEV_COUNT))
+		return;
+
+	if (fm->fe[id].init) {
+		pr_error("cannot reset driver when the device is inused\n");
+		return;
+	}
+
+	list = aml_get_fe_drv_list(type);
+	for (drv = *list; drv; drv = drv->next)
+		if (!strcmp(drv->name, name))
+			break;
+
+	switch (type) {
+	case AM_DEV_TUNER:
+		pdrv = &fm->tuner[id].drv;
+		break;
+	case AM_DEV_ATV_DEMOD:
+		pdrv = &fm->atv_demod[id].drv;
+		break;
+	case AM_DEV_DTV_DEMOD:
+		pdrv = &fm->dtv_demod[id].drv;
+		break;
+	default:
+		return;
+	}
+
+	old = *pdrv;
+	if (old == drv)
+		return;
+
+	if (old) {
+		old->ref--;
+		if (old->owner)
+			module_put(old->owner);
+	}
+
+	if (drv) {
+		drv->ref++;
+		if (drv->owner)
+			try_module_get(drv->owner);
+	}
+
+	*pdrv = drv;
+}
+
+static ssize_t setting_store(struct class *class, struct class_attribute *attr,
+			     const char *buf, size_t size)
+{
+	struct aml_fe_man *fm = &fe_man;
+	int id, val;
+	char dev_name[32];
+	unsigned long flags;
+
+	spin_lock_irqsave(&lock, flags);
+
+	if (sscanf(buf, "tuner %i driver %s", &id, dev_name) == 2) {
+		reset_drv(id, AM_DEV_TUNER, dev_name);
+	} else if (sscanf(buf, "atv_demod %i driver %s", &id, dev_name) == 2) {
+		reset_drv(id, AM_DEV_ATV_DEMOD, dev_name);
+	} else if (sscanf(buf, "dtv_demod %i driver %s", &id, dev_name) == 2) {
+		reset_drv(id, AM_DEV_DTV_DEMOD, dev_name);
+	} else if (sscanf(buf, "frontend %i device %i", &id, &val) == 2) {
+		if ((id >= 0) && (id < FE_DEV_COUNT))
+			fm->fe[id].dev_id = val;
+	} else if (sscanf(buf, "frontend %i ts %i", &id, &val) == 2) {
+		if ((id >= 0) && (id < FE_DEV_COUNT))
+			fm->fe[id].ts = val;
+	} else if (sscanf(buf, "frontend %i tuner %i", &id, &val) == 2) {
+		if ((id >= 0) && (id < FE_DEV_COUNT) && (val >= 0)
+		    && (val < FE_DEV_COUNT) && fm->tuner[val].drv)
+			fm->fe[id].tuner = &fm->tuner[val];
+	} else if (sscanf(buf, "frontend %i atv_demod %i", &id, &val) == 2) {
+		if ((id >= 0) && (id < FE_DEV_COUNT) && (val >= 0)
+		    && (val < FE_DEV_COUNT) && fm->atv_demod[val].drv)
+			fm->fe[id].atv_demod = &fm->atv_demod[val];
+	} else if (sscanf(buf, "frontend %i dtv_demod %i", &id, &val) == 2) {
+		if ((id >= 0) && (id < FE_DEV_COUNT) && (val >= 0)
+		    && (val < FE_DEV_COUNT) && fm->dtv_demod[val].drv)
+			fm->fe[id].dtv_demod = &fm->dtv_demod[val];
+	}
+
+	spin_unlock_irqrestore(&lock, flags);
+
+	if (sscanf(buf, "enable %i", &id) == 1) {
+		if ((id >= 0) && (id < FE_DEV_COUNT))
+			aml_fe_man_run(&fm->fe[id]);
+	} else if (sscanf(buf, "disable %i", &id) == 1) {
+		if ((id >= 0) && (id < FE_DEV_COUNT))
+			aml_fe_man_release(&fm->fe[id]);
+	} else if (strstr(buf, "autoload")) {
+		for (id = 0; id < FE_DEV_COUNT; id++) {
+			aml_fe_dev_init(fm, AM_DEV_TUNER,
+					&fm->tuner[id], id);
+			aml_fe_dev_init(fm, AM_DEV_ATV_DEMOD,
+					&fm->atv_demod[id], id);
+			aml_fe_dev_init(fm, AM_DEV_DTV_DEMOD,
+					&fm->dtv_demod[id], id);
+		}
+
+		for (id = 0; id < FE_DEV_COUNT; id++)
+			aml_fe_man_init(fm, &fm->fe[id], id);
+	} else if (strstr(buf, "disableall")) {
+		for (id = 0; id < FE_DEV_COUNT; id++)
+			aml_fe_man_release(&fm->fe[id]);
+
+		for (id = 0; id < FE_DEV_COUNT; id++) {
+			aml_fe_dev_release(&fm->dtv_demod[id]);
+			aml_fe_dev_release(&fm->atv_demod[id]);
+			aml_fe_dev_release(&fm->tuner[id]);
+		}
+	}
+
+	return size;
+}
+
+static ssize_t aml_fe_show_suspended_flag(struct class *class,
+					  struct class_attribute *attr,
+					  char *buf)
+{
+	ssize_t ret = 0;
+
+	ret = sprintf(buf, "%ld\n", aml_fe_suspended);
+
+	return ret;
+}
+
+static ssize_t aml_fe_store_suspended_flag(struct class *class,
+					   struct class_attribute *attr,
+					   const char *buf, size_t size)
+{
+	/*aml_fe_suspended = simple_strtol(buf, 0, 0); */
+	int ret = kstrtol(buf, 0, &aml_fe_suspended);
+
+	if (ret)
+		return ret;
+	return size;
+}
+
+static struct class_attribute aml_fe_cls_attrs[] = {
+	__ATTR(tuner_name,
+	       0644,
+	       tuner_name_show, NULL),
+	__ATTR(atv_demod_name,
+	       0644,
+	       atv_demod_name_show, NULL),
+	__ATTR(dtv_demod_name,
+	       0644,
+	       dtv_demod_name_show, NULL),
+	__ATTR(setting,
+	       0644,
+	       setting_show, setting_store),
+	__ATTR(aml_fe_suspended_flag,
+	       0644,
+	       aml_fe_show_suspended_flag,
+	       aml_fe_store_suspended_flag),
+	__ATTR_NULL
+};
+
+static struct class aml_fe_class = {
+	.name = "amlfe",
+	.class_attrs = aml_fe_cls_attrs,
+};
+
+static int aml_fe_probe(struct platform_device *pdev)
+{
+	struct aml_dvb *dvb = aml_get_dvb_device();
+	int i;
+
+	fe_man.dvb  = dvb;
+	fe_man.pdev = pdev;
+
+	platform_set_drvdata(pdev, &fe_man);
+
+	for (i = 0; i < FE_DEV_COUNT; i++) {
+		if (aml_fe_dev_init(&fe_man,
+					AM_DEV_TUNER,
+					&fe_man.tuner[i], i) < 0)
+			goto probe_end;
+
+		if (aml_fe_dev_init(&fe_man,
+					AM_DEV_ATV_DEMOD,
+					&fe_man.atv_demod[i], i) < 0)
+			goto probe_end;
+
+		if (aml_fe_dev_init(&fe_man,
+			AM_DEV_DTV_DEMOD,
+			&fe_man.dtv_demod[i], i) < 0)
+			goto probe_end;
+	}
+
+	for (i = 0; i < FE_DEV_COUNT; i++) {
+		if (aml_fe_man_init(&fe_man, &fe_man.fe[i], i) < 0)
+			goto probe_end;
+	}
+
+ probe_end:
+
+	fe_man.pinctrl = devm_pinctrl_get_select_default(&pdev->dev);
+
+	if (class_register(&aml_fe_class) < 0)
+		pr_error("[aml_fe..] register class error\n");
+
+	pr_dbg("[aml_fe..] probe ok.\n");
+
+	return 0;
+}
+
+static int aml_fe_remove(struct platform_device *pdev)
+{
+	struct aml_fe_man *fe_man = platform_get_drvdata(pdev);
+	int i;
+
+	if (fe_man) {
+		platform_set_drvdata(pdev, NULL);
+
+		for (i = 0; i < FE_DEV_COUNT; i++)
+			aml_fe_man_release(&fe_man->fe[i]);
+		for (i = 0; i < FE_DEV_COUNT; i++) {
+			aml_fe_dev_release(&fe_man->dtv_demod[i]);
+			aml_fe_dev_release(&fe_man->atv_demod[i]);
+			aml_fe_dev_release(&fe_man->tuner[i]);
+		}
+
+		if (fe_man->pinctrl)
+			devm_pinctrl_put(fe_man->pinctrl);
+	}
+
+	class_unregister(&aml_fe_class);
+
+	return 0;
+}
+
+static int aml_fe_suspend(struct platform_device *dev, pm_message_t state)
+{
+	int i;
+
+	for (i = 0; i < FE_DEV_COUNT; i++) {
+		struct aml_fe *fe = &fe_man.fe[i];
+
+		if (fe->tuner && fe->tuner->drv->suspend)
+			fe->tuner->drv->suspend(fe->tuner);
+
+		if (fe->atv_demod && fe->atv_demod->drv->suspend)
+			fe->atv_demod->drv->suspend(fe->atv_demod);
+
+		if (fe->dtv_demod && fe->dtv_demod->drv->suspend)
+			fe->dtv_demod->drv->suspend(fe->dtv_demod);
+	}
+
+	aml_fe_suspended = 1;
+
+	return 0;
+}
+
+static int aml_fe_resume(struct platform_device *dev)
+{
+	int i;
+
+	aml_fe_suspended = 0;
+
+	for (i = 0; i < FE_DEV_COUNT; i++) {
+		struct aml_fe *fe = &fe_man.fe[i];
+
+		if (fe->tuner && fe->tuner->drv->resume)
+			fe->tuner->drv->resume(fe->tuner);
+
+		if (fe->atv_demod && fe->atv_demod->drv->resume)
+			fe->atv_demod->drv->resume(fe->atv_demod);
+
+		if (fe->dtv_demod && fe->dtv_demod->drv->resume)
+			fe->dtv_demod->drv->resume(fe->dtv_demod);
+	}
+
+	return 0;
+}
+
+#ifdef CONFIG_OF
+static const struct of_device_id aml_fe_dt_match[] = {
+	{
+	 .compatible = "amlogic, dvbfe",
+	 },
+	{},
+};
+#endif				/*CONFIG_OF */
+
+static struct platform_driver aml_fe_driver = {
+	.probe   = aml_fe_probe,
+	.remove  = aml_fe_remove,
+	.suspend = aml_fe_suspend,
+	.resume  = aml_fe_resume,
+	.driver  = {
+		.name = "amlogic-dvb-fe",
+		.owner = THIS_MODULE,
+#ifdef CONFIG_OF
+		.of_match_table = aml_fe_dt_match,
+#endif
+	}
+};
+
+static int __init aml_fe_init(void)
+{
+	return platform_driver_register(&aml_fe_driver);
+}
+
+static void __exit aml_fe_exit(void)
+{
+	platform_driver_unregister(&aml_fe_driver);
+}
+
+module_init(aml_fe_init);
+module_exit(aml_fe_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("amlogic frontend driver");
+MODULE_AUTHOR("L+#= +0=1");
+
diff --git a/drivers/stream_input/tv_frontend/aml_fe.h b/drivers/stream_input/tv_frontend/aml_fe.h
new file mode 100644
index 0000000..f38c646
--- /dev/null
+++ b/drivers/stream_input/tv_frontend/aml_fe.h
@@ -0,0 +1,213 @@
+/*
+* Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT
+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+* more details.
+*
+* You should have received a copy of the GNU General Public License along
+* with this program; if not, write to the Free Software Foundation, Inc.,
+* 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+*
+* Description:
+*/
+#ifndef _AML_FE_H_
+#define _AML_FE_H_
+
+
+#include <linux/interrupt.h>
+#include <linux/socket.h>
+#include <linux/netdevice.h>
+#include <linux/i2c.h>
+
+#include <linux/dvb/video.h>
+#include <linux/dvb/audio.h>
+#include <linux/dvb/dmx.h>
+#include <linux/dvb/ca.h>
+#include <linux/dvb/osd.h>
+#include <linux/dvb/net.h>
+#include <linux/mutex.h>
+#include <linux/spinlock.h>
+#include <linux/interrupt.h>
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+#include <linux/earlysuspend.h>
+#endif
+
+#include <dvbdev.h>
+#include <demux.h>
+#include <dvb_demux.h>
+#include <dmxdev.h>
+#include <dvb_filter.h>
+#include <dvb_net.h>
+#include <dvb_ringbuffer.h>
+#include <dvb_frontend.h>
+
+#include <linux/videodev2.h>
+#include <linux/amlogic/aml_gpio_consumer.h>
+
+#include <linux/of.h>
+#include <linux/of_fdt.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/amlogic/cpu_version.h>
+#include <linux/of_reserved_mem.h>
+
+#include "../parser/hw_demux/aml_dvb.h"
+
+enum aml_tuner_type_t {
+	AM_TUNER_NONE = 0,
+	AM_TUNER_SI2176 = 1,
+	AM_TUNER_SI2196 = 2,
+	AM_TUNER_FQ1216 = 3,
+	AM_TUNER_HTM    = 4,
+	AM_TUNER_CTC703 = 5,
+	AM_TUNER_SI2177 = 6,
+	AM_TUNER_R840   = 7,
+	AM_TUNER_SI2157 = 8,
+	AM_TUNER_SI2151 = 9,
+	AM_TUNER_MXL661 = 10,
+	AM_TUNER_MXL608 = 11,
+	AM_TUNER_SI2159 = 12,
+	AM_TUNER_R842 = 13,
+	AM_TUNER_ATBM2040 = 14,
+};
+
+enum aml_atv_demod_type_t {
+	AM_ATV_DEMOD_SI2176 = 1,
+	AM_ATV_DEMOD_SI2196 = 2,
+	AM_ATV_DEMOD_FQ1216 = 3,
+	AM_ATV_DEMOD_HTM    = 4,
+	AM_ATV_DEMOD_CTC703 = 5,
+	AM_ATV_DEMOD_SI2177 = 6,
+	AM_ATV_DEMOD_AML    = 7,
+	AM_ATV_DEMOD_R840   = 8
+};
+
+enum aml_dtv_demod_type_t {
+	AM_DTV_DEMOD_M1       = 0,
+	AM_DTV_DEMOD_SI2176   = 1,
+	AM_DTV_DEMOD_MXL101   = 2,
+	AM_DTV_DEMOD_SI2196   = 3,
+	AM_DTV_DEMOD_AVL6211  = 4,
+	AM_DTV_DEMOD_SI2168   = 5,
+	AM_DTV_DEMOD_ITE9133  = 6,
+	AM_DTV_DEMOD_ITE9173  = 7,
+	AM_DTV_DEMOD_DIB8096  = 8,
+	AM_DTV_DEMOD_ATBM8869 = 9,
+	AM_DTV_DEMOD_MXL241   = 10,
+	AM_DTV_DEMOD_AVL68xx  = 11,
+	AM_DTV_DEMOD_MXL683   = 12,
+	AM_DTV_DEMOD_ATBM8881 = 13
+};
+
+enum aml_fe_dev_type_t {
+	AM_DEV_TUNER,
+	AM_DEV_ATV_DEMOD,
+	AM_DEV_DTV_DEMOD
+};
+
+struct aml_fe_dev;
+struct aml_fe_man;
+struct aml_fe;
+
+struct aml_fe_drv {
+	struct module          *owner;
+	struct aml_fe_drv      *next;
+	enum aml_tuner_type_t	id;
+	char                   *name;
+	int (*init)(struct aml_fe_dev *dev);
+	int (*release)(struct aml_fe_dev *dev);
+	int (*resume)(struct aml_fe_dev *dev);
+	int (*suspend)(struct aml_fe_dev *dev);
+	int (*support)(struct aml_fe_dev *dev, enum fe_delivery_system sys);
+	int (*get_ops)(struct aml_fe_dev *dev, enum fe_delivery_system sys,
+				struct dvb_frontend_ops  *ops);
+	int (*init_sys)(struct aml_fe_dev *dev, enum fe_delivery_system sys);
+	int (*release_sys)(struct aml_fe_dev *dev, enum fe_delivery_system sys);
+	int (*start_blind_scan)(struct aml_fe_dev *dev);
+	int (*stop_blind_scan)(struct aml_fe_dev *dev);
+	int			ref;
+};
+
+struct aml_fe_dev {
+	/*point to parent aml_fe */
+	enum aml_fe_dev_type_t  type;
+	int                     dev_id;
+	struct aml_fe           *fe;
+	struct aml_fe_man       *man;
+	struct aml_fe_drv       *drv;
+	void                    *priv_data;
+	/*i2c and reset gpio for all demod and tune*/
+	int						i2c_adap_id;
+	int						i2c_addr;
+	struct i2c_adapter		*i2c_adap;
+	int						reset_gpio;
+	int						reset_value;
+};
+
+struct aml_fe {
+	struct dvb_frontend            *fe;
+	struct aml_fe_man              *man;
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	struct early_suspend		es;
+#endif                          /*CONFIG_HAS_EARLYSUSPEND */
+	spinlock_t			slock;
+	int				init;
+	int				dev_id;
+	enum fe_delivery_system         sys;
+	int	sub_sys;
+/*used to identify T T2 OR C-A C-B C-C,S S2,ISDBT ISDBS ISDBC*/
+	enum aml_ts_source_t		ts;
+	struct aml_fe_dev              *tuner;
+	struct aml_fe_dev              *atv_demod;
+	struct aml_fe_dev              *dtv_demod;
+	struct workqueue_struct        *work_q;
+	wait_queue_head_t               wait_q;
+	struct work_struct              work;
+	int                             work_running;
+	struct dvbsx_blindscanpara		blind_scan_para;
+
+	/*Driver's work function.*/
+	void (*do_work)(struct aml_fe *fe);
+	/*Driver's property function.*/
+	int (*get_property)(struct dvb_frontend *fe, struct dtv_property *tvp);
+	int (*set_property)(struct dvb_frontend *fe, struct dtv_property *tvp);
+};
+
+struct aml_fe_man {
+	struct aml_dvb         *dvb;
+	struct aml_fe		fe[FE_DEV_COUNT];
+	struct aml_fe_dev	tuner[FE_DEV_COUNT];
+	struct aml_fe_dev	atv_demod[FE_DEV_COUNT];
+	struct aml_fe_dev	dtv_demod[FE_DEV_COUNT];
+	struct dvb_frontend	dev[FE_DEV_COUNT];
+	struct pinctrl         *pinctrl;
+	struct platform_device *pdev;
+};
+
+extern int aml_register_fe_drv(enum aml_fe_dev_type_t type,
+			struct aml_fe_drv *drv);
+extern int aml_unregister_fe_drv(enum aml_fe_dev_type_t type,
+			struct aml_fe_drv *drv);
+
+extern int aml_fe_of_property_string(struct aml_fe_dev *dev,
+			const char *name, const char **str);
+extern int aml_fe_of_property_u32(struct aml_fe_dev *dev,
+			const char *name, u32 *v);
+
+extern void  aml_fe_set_pdata(struct aml_fe_dev *dev, void *pdata);
+extern void *aml_fe_get_pdata(struct aml_fe_dev *dev);
+
+extern void aml_fe_schedule_work(struct aml_fe *fe,
+			void (*func)(struct aml_fe *fe));
+extern void aml_fe_cancel_work(struct aml_fe *fe);
+extern int  aml_fe_work_cancelled(struct aml_fe *fe);
+extern int  aml_fe_work_sleep(struct aml_fe *fe, unsigned long delay);
+
+#endif /*_AML_FE_H_*/
diff --git a/drivers/stream_input/tv_frontend/atv_demod/atvdemod_frontend.c b/drivers/stream_input/tv_frontend/atv_demod/atvdemod_frontend.c
new file mode 100644
index 0000000..964bc42
--- /dev/null
+++ b/drivers/stream_input/tv_frontend/atv_demod/atvdemod_frontend.c
@@ -0,0 +1,791 @@
+/*
+ * Silicon labs atvdemod Device Driver
+ *
+ * Author: dezhi.kong <dezhi.kong@amlogic.com>
+ *
+ *
+ * Copyright (C) 2014 Amlogic Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/* Standard Liniux Headers */
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/i2c.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/err.h>
+#include <linux/delay.h>
+#include <linux/jiffies.h>
+#include <linux/platform_device.h>
+#include <linux/io.h>
+
+/* Amlogic Headers */
+
+/* Local Headers */
+#include "atvdemod_func.h"
+#include "../aml_fe.h"
+#include <uapi/linux/dvb/frontend.h>
+#include <linux/amlogic/tvin/tvin.h>
+
+#define ATVDEMOD_DEVICE_NAME                "amlatvdemod"
+#define ATVDEMOD_DRIVER_NAME	"amlatvdemod"
+#define ATVDEMOD_MODULE_NAME	"amlatvdemod"
+#define ATVDEMOD_CLASS_NAME	"amlatvdemod"
+
+struct amlatvdemod_device_s *amlatvdemod_devp;
+#define AMLATVDEMOD_VER "Ref.2015/09/01a"
+
+static int afc_wave_cnt;
+static int last_frq, last_std;
+
+unsigned int reg_23cf = 0x88188832; /*IIR filter*/
+module_param(reg_23cf, uint, 0664);
+MODULE_PARM_DESC(reg_23cf, "\n reg_23cf\n");
+
+unsigned int atvdemod_scan_mode; /*IIR filter*/
+module_param(atvdemod_scan_mode, uint, 0664);
+MODULE_PARM_DESC(atvdemod_scan_mode, "\n atvdemod_scan_mode\n");
+
+/* used for resume */
+#define ATVDEMOD_STATE_IDEL 0
+#define ATVDEMOD_STATE_WORK 1
+#define ATVDEMOD_STATE_SLEEP 2
+static int atvdemod_state = ATVDEMOD_STATE_IDEL;
+
+int is_atvdemod_scan_mode(void)
+{
+	return atvdemod_scan_mode;
+}
+EXPORT_SYMBOL(is_atvdemod_scan_mode);
+
+static int aml_atvdemod_enter_mode(struct aml_fe *fe, int mode);
+/*static void sound_store(const char *buff, v4l2_std_id *std);*/
+static ssize_t aml_atvdemod_store(struct class *cls,
+				  struct class_attribute *attr, const char *buf,
+				  size_t count)
+{
+	int n = 0;
+	unsigned int ret = 0;
+	char *buf_orig, *ps, *token;
+	char *parm[4];
+	unsigned int data_snr[128];
+	unsigned int data_snr_avg;
+	int data_afc, block_addr, block_reg, block_val = 0;
+	int i, val = 0;
+	unsigned long tmp = 0;
+	struct aml_fe *atvdemod_fe = NULL;
+
+	buf_orig = kstrdup(buf, GFP_KERNEL);
+	ps = buf_orig;
+	block_addr = 0;
+	block_reg = 0;
+	while (1) {
+		token = strsep(&ps, "\n");
+		if (token == NULL)
+			break;
+		if (*token == '\0')
+			continue;
+		parm[n++] = token;
+	}
+	if (!strncmp(parm[0], "init", strlen("init"))) {
+		ret = aml_atvdemod_enter_mode(atvdemod_fe, 0);
+		if (ret)
+			pr_info("[tuner..] atv_restart error.\n");
+	} else if (!strcmp(parm[0], "tune")) {
+		/* val  = simple_strtol(parm[1], NULL, 10); */
+	} else if (!strcmp(parm[0], "set")) {
+		if (!strncmp(parm[1], "avout_gain", strlen("avout_gain"))) {
+			if (kstrtoul(buf+strlen("avout_offset")+1, 10,
+				&tmp) == 0)
+				val  = tmp;
+			atv_dmd_wr_byte(0x0c, 0x01, val&0xff);
+		} else if (!strncmp(parm[1], "avout_offset",
+			strlen("avout_offset"))) {
+			if (kstrtoul(buf+strlen("avout_offset")+1, 10,
+				&tmp) == 0)
+				val  = tmp;
+			atv_dmd_wr_byte(0x0c, 0x04, val&0xff);
+		} else if (!strncmp(parm[1], "atv_gain", strlen("atv_gain"))) {
+			if (kstrtoul(buf+strlen("atv_gain")+1, 10, &tmp) == 0)
+				val  = tmp;
+			atv_dmd_wr_byte(0x19, 0x01, val&0xff);
+		} else if (!strncmp(parm[1], "atv_offset",
+			strlen("atv_offset"))) {
+			if (kstrtoul(buf+strlen("atv_offset")+1, 10,
+				&tmp) == 0)
+				val  = tmp;
+			atv_dmd_wr_byte(0x19, 0x04, val&0xff);
+		}
+	} else if (!strcmp(parm[0], "get")) {
+		if (!strncmp(parm[1], "avout_gain", strlen("avout_gain"))) {
+			val = atv_dmd_rd_byte(0x0c, 0x01);
+			pr_dbg("avout_gain:0x%x\n", val);
+		} else if (!strncmp(parm[1], "avout_offset",
+			strlen("avout_offset"))) {
+			val = atv_dmd_rd_byte(0x0c, 0x04);
+			pr_dbg("avout_offset:0x%x\n", val);
+		} else if (!strncmp(parm[1], "atv_gain", strlen("atv_gain"))) {
+			val = atv_dmd_rd_byte(0x19, 0x01);
+			pr_dbg("atv_gain:0x%x\n", val);
+		} else if (!strncmp(parm[1], "atv_offset",
+			strlen("atv_offset"))) {
+			val = atv_dmd_rd_byte(0x19, 0x04);
+			pr_dbg("atv_offset:0x%x\n", val);
+		}
+	} else if (!strncmp(parm[0], "snr_hist", strlen("snr_hist"))) {
+		data_snr_avg = 0;
+		for (i = 0; i < 128; i++) {
+			data_snr[i] =
+			    (atv_dmd_rd_long(APB_BLOCK_ADDR_VDAGC, 0x50) >> 8);
+			usleep_range(50*1000, 50*1000+100);
+			data_snr_avg += data_snr[i];
+		}
+		data_snr_avg = data_snr_avg / 128;
+		pr_dbg("**********snr_hist_128avg:0x%x(%d)*********\n",
+		       data_snr_avg, data_snr_avg);
+	} else if (!strncmp(parm[0], "afc_info", strlen("afc_info"))) {
+		data_afc = retrieve_vpll_carrier_afc();
+		pr_dbg("[amlatvdemod..]afc %d Khz.\n", data_afc);
+	} else if (!strncmp(parm[0], "ver_info", strlen("ver_info"))) {
+		pr_dbg("[amlatvdemod..]aml_atvdemod_ver %s.\n",
+			AMLATVDEMOD_VER);
+	} else if (!strncmp(parm[0], "audio_autodet",
+		strlen("audio_autodet"))) {
+		aml_audiomode_autodet(NULL);
+	} else if (!strncmp(parm[0], "overmodule_det",
+			strlen("overmodule_det"))) {
+		/* unsigned long over_threshold, */
+		/* int det_mode = auto_det_mode; */
+		aml_atvdemod_overmodule_det();
+	} else if (!strncmp(parm[0], "audio_gain_set",
+			strlen("audio_gain_set"))) {
+		if (kstrtoul(buf+strlen("audio_gain_set")+1, 16, &tmp) == 0)
+			val = tmp;
+		aml_audio_valume_gain_set(val);
+		pr_dbg("audio_gain_set : %d\n", val);
+	} else if (!strncmp(parm[0], "audio_gain_get",
+			strlen("audio_gain_get"))) {
+		val = aml_audio_valume_gain_get();
+		pr_dbg("audio_gain_get : %d\n", val);
+	} else if (!strncmp(parm[0], "fix_pwm_adj", strlen("fix_pwm_adj"))) {
+		if (kstrtoul(parm[1], 10, &tmp) == 0) {
+			val = tmp;
+			aml_fix_PWM_adjust(val);
+		}
+	} else if (!strncmp(parm[0], "rs", strlen("rs"))) {
+		if (kstrtoul(parm[1], 16, &tmp) == 0)
+			block_addr  = tmp;
+		if (kstrtoul(parm[2], 16, &tmp) == 0)
+			block_reg  = tmp;
+		if (block_addr < APB_BLOCK_ADDR_TOP)
+			block_val = atv_dmd_rd_long(block_addr, block_reg);
+		pr_info("rs block_addr:0x%x,block_reg:0x%x,block_val:0x%x\n",
+			block_addr, block_reg, block_val);
+	} else if (!strncmp(parm[0], "ws", strlen("ws"))) {
+		if (kstrtoul(parm[1], 16, &tmp) == 0)
+			block_addr  = tmp;
+		if (kstrtoul(parm[2], 16, &tmp) == 0)
+			block_reg  = tmp;
+		if (kstrtoul(parm[3], 16, &tmp) == 0)
+			block_val  = tmp;
+		if (block_addr < APB_BLOCK_ADDR_TOP)
+			atv_dmd_wr_long(block_addr, block_reg, block_val);
+		pr_info("ws block_addr:0x%x,block_reg:0x%x,block_val:0x%x\n",
+			block_addr, block_reg, block_val);
+		block_val = atv_dmd_rd_long(block_addr, block_reg);
+		pr_info("readback_val:0x%x\n", block_val);
+	} else if (!strncmp(parm[0], "pin_mux", strlen("pin_mux"))) {
+		amlatvdemod_devp->pin =
+			devm_pinctrl_get_select(amlatvdemod_devp->dev,
+				amlatvdemod_devp->pin_name);
+		pr_dbg("atvdemod agc pinmux name:%s\n",
+				amlatvdemod_devp->pin_name);
+	} else if (!strncmp(parm[0], "snr_cur", strlen("snr_cur"))) {
+		data_snr_avg = aml_atvdemod_get_snr_ex();
+		pr_dbg("**********snr_cur:%d*********\n", data_snr_avg);
+	} else
+		pr_dbg("invalid command\n");
+	kfree(buf_orig);
+	return count;
+}
+
+static ssize_t aml_atvdemod_show(struct class *cls,
+	struct class_attribute *attr, char *buff)
+{
+	pr_dbg("\n usage:\n");
+	pr_dbg("[get soft version] echo ver_info > /sys/class/amlatvdemod/atvdemod_debug\n");
+	pr_dbg("[get afc value] echo afc_info > /sys/class/amlatvdemod/atvdemod_debug\n");
+	pr_dbg("[reinit atvdemod] echo init > /sys/class/amlatvdemod/atvdemod_debug\n");
+	pr_dbg("[get av-out-gain/av-out-offset/atv-gain/atv-offset]:\n"
+		"echo get av_gain/av_offset/atv_gain/atv_offset > /sys/class/amlatvdemod/atvdemod_debug\n");
+	pr_dbg("[set av-out-gain/av-out-offset/atv-gain/atv-offset]:\n"
+		"echo set av_gain/av_offset/atv_gain/atv_offset val(0~255) > /sys/class/amlatvdemod/atvdemod_debug\n");
+	return 0;
+}
+static CLASS_ATTR(atvdemod_debug, 0644, aml_atvdemod_show, aml_atvdemod_store);
+
+void aml_atvdemod_set_frequency(unsigned int freq)
+{
+}
+
+/*static void aml_atvdemod_set_std(void);*/
+
+/*try audmode B,CH,I,DK,return the sound level*/
+/*static unsigned char set_video_audio_mode(unsigned char color,
+ *unsigned char audmode);
+ */
+/*static void aml_atvdemod_get_status(struct dvb_frontend *fe,
+ *void *stat);
+ */
+/*static void aaaml_atvdemod_get_pll_status(struct dvb_frontend *fe,
+ *void *stat);
+ */
+
+static int aml_atvdemod_fe_init(struct aml_fe_dev *dev)
+{
+
+	int error_code = 0;
+
+	if (!dev) {
+		pr_dbg("[amlatvdemod..]%s: null pointer error.\n", __func__);
+		return -1;
+	}
+	return error_code;
+}
+
+static int aml_atvdemod_enter_mode(struct aml_fe *fe, int mode)
+{
+	int err_code;
+
+	if (amlatvdemod_devp->pin_name != NULL)
+		amlatvdemod_devp->pin =
+			devm_pinctrl_get_select(amlatvdemod_devp->dev,
+				amlatvdemod_devp->pin_name);
+	/* printk("\n%s: set atvdemod pll...\n",__func__); */
+	adc_set_pll_cntl(1, 0x1);
+	atvdemod_clk_init();
+	err_code = atvdemod_init();
+	if (err_code) {
+		pr_dbg("[amlatvdemod..]%s init atvdemod error.\n", __func__);
+		return err_code;
+	}
+
+	set_aft_thread_enable(1);
+	atvdemod_state = ATVDEMOD_STATE_WORK;
+	return 0;
+}
+
+static int aml_atvdemod_leave_mode(struct aml_fe *fe, int mode)
+{
+	set_aft_thread_enable(0);
+	atvdemod_uninit();
+	if (amlatvdemod_devp->pin != NULL) {
+		devm_pinctrl_put(amlatvdemod_devp->pin);
+		amlatvdemod_devp->pin = NULL;
+	}
+	/* reset adc pll flag */
+	/* printk("\n%s: init atvdemod flag...\n",__func__); */
+	adc_set_pll_cntl(0, 0x1);
+	atvdemod_state = ATVDEMOD_STATE_IDEL;
+	return 0;
+}
+
+static int aml_atvdemod_suspend(struct aml_fe_dev *dev)
+{
+	pr_info("%s\n", __func__);
+	if (atvdemod_state != ATVDEMOD_STATE_IDEL) {
+		aml_atvdemod_leave_mode(NULL, 0);
+		atvdemod_state = ATVDEMOD_STATE_SLEEP;
+	}
+	return 0;
+}
+
+static int aml_atvdemod_resume(struct aml_fe_dev *dev)
+{
+	pr_info("%s\n", __func__);
+	if (atvdemod_state == ATVDEMOD_STATE_SLEEP)
+		aml_atvdemod_enter_mode(NULL, 0);
+	return 0;
+}
+
+/*
+ *static int aml_atvdemod_get_afc(struct dvb_frontend *fe,int *afc)
+ *{
+ *	return 0;
+ *}
+ */
+
+/*ret:5~100;the val is bigger,the signal is better*/
+int aml_atvdemod_get_snr(struct dvb_frontend *fe)
+{
+#if 1
+	return get_atvdemod_snr_val();
+#else
+	unsigned int snr_val;
+	int ret;
+
+	snr_val = atv_dmd_rd_long(APB_BLOCK_ADDR_VDAGC, 0x50) >> 8;
+	/* snr_val:900000~0xffffff,ret:5~15 */
+	if (snr_val > 900000)
+		ret = 15 - (snr_val - 900000)*10/(0xffffff - 900000);
+	/* snr_val:158000~900000,ret:15~30 */
+	else if (snr_val > 158000)
+		ret = 30 - (snr_val - 158000)*15/(900000 - 158000);
+	/* snr_val:31600~158000,ret:30~50 */
+	else if (snr_val > 31600)
+		ret = 50 - (snr_val - 31600)*20/(158000 - 31600);
+	/* snr_val:316~31600,ret:50~80 */
+	else if (snr_val > 316)
+		ret = 80 - (snr_val - 316)*30/(31600 - 316);
+	/* snr_val:0~316,ret:80~100 */
+	else
+		ret = 100 - (316 - snr_val)*20/316;
+	return ret;
+#endif
+}
+EXPORT_SYMBOL(aml_atvdemod_get_snr);
+
+int aml_atvdemod_get_snr_ex(void)
+{
+#if 1
+	return get_atvdemod_snr_val();
+#else
+	unsigned int snr_val;
+	int ret;
+
+	snr_val = atv_dmd_rd_long(APB_BLOCK_ADDR_VDAGC, 0x50) >> 8;
+	/* snr_val:900000~0xffffff,ret:5~15 */
+	if (snr_val > 900000)
+		ret = 15 - (snr_val - 900000)*10/(0xffffff - 900000);
+	/* snr_val:158000~900000,ret:15~30 */
+	else if (snr_val > 158000)
+		ret = 30 - (snr_val - 158000)*15/(900000 - 158000);
+	/* snr_val:31600~158000,ret:30~50 */
+	else if (snr_val > 31600)
+		ret = 50 - (snr_val - 31600)*20/(158000 - 31600);
+	/* snr_val:316~31600,ret:50~80 */
+	else if (snr_val > 316)
+		ret = 80 - (snr_val - 316)*30/(31600 - 316);
+	/* snr_val:0~316,ret:80~100 */
+	else
+		ret = 100 - (316 - snr_val)*20/316;
+	return ret;
+#endif
+}
+EXPORT_SYMBOL(aml_atvdemod_get_snr_ex);
+
+/*tuner lock status & demod lock status should be same in silicon tuner*/
+static int aml_atvdemod_get_status(struct dvb_frontend *fe, void *stat)
+{
+	int video_lock;
+	fe_status_t *status = (fe_status_t *) stat;
+
+	retrieve_video_lock(&video_lock);
+	if ((video_lock & 0x1) == 0) {
+		/*  *status = FE_HAS_LOCK;*/
+		*status = FE_TIMEDOUT;
+		pr_info("video lock:locked\n");
+	} else {
+		pr_info("video lock:unlocked\n");
+		*status = FE_TIMEDOUT;
+		/*  *status = FE_HAS_LOCK;*/
+	}
+	return 0;
+}
+
+/*tuner lock status & demod lock status should be same in silicon tuner*/
+/* force return lock, for atvdemo status not sure */
+static void aml_atvdemod_get_pll_status(struct dvb_frontend *fe, void *stat)
+{
+	int vpll_lock;
+	fe_status_t *status = (fe_status_t *) stat;
+
+	retrieve_vpll_carrier_lock(&vpll_lock);
+	if ((vpll_lock&0x1) == 0) {
+		*status = FE_HAS_LOCK;
+		pr_info("visual carrier lock:locked\n");
+	} else {
+		pr_info("visual carrier lock:unlocked\n");
+		*status = FE_TIMEDOUT;
+		/*  *status = FE_HAS_LOCK;*/
+	}
+}
+
+static int aml_atvdemod_get_atv_status(struct dvb_frontend *fe,
+		struct atv_status_s *atv_status)
+{
+	int vpll_lock = 0, line_lock = 0;
+	int try_std = 1;
+	int loop_cnt = 5;
+	int cnt = 10;
+	int try_std_cnt = 0;
+	static int last_report_freq;
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
+
+	while (fe && atv_status && loop_cnt--) {
+		atv_status->afc = retrieve_vpll_carrier_afc();
+		retrieve_vpll_carrier_lock(&vpll_lock);
+		line_lock = atv_dmd_rd_byte(APB_BLOCK_ADDR_VDAGC, 0x4f)&0x10;
+		if ((vpll_lock&0x1) == 0 || line_lock == 0) {
+			atv_status->atv_lock = 1;
+			try_std_cnt = 2;
+			while (try_std_cnt--) {
+				atv_status->afc = retrieve_vpll_carrier_afc();
+				if (atv_status->afc > 1500
+					&& atvdemod_scan_mode) {
+					if ((c->analog.std & 0xff000000)
+						!= V4L2_COLOR_STD_PAL) {
+						c->analog.std =
+							V4L2_COLOR_STD_PAL
+							| V4L2_STD_PAL_BG;
+						c->frequency += 1;
+						fe->ops.set_frontend(fe);
+						msleep(20);
+					} else {
+						c->analog.std =
+							V4L2_COLOR_STD_NTSC
+							| V4L2_STD_NTSC_M;
+						c->frequency += 1;
+						fe->ops.set_frontend(fe);
+						usleep_range(20*1000,
+							20*1000+100);
+					}
+					atv_status->afc =
+						retrieve_vpll_carrier_afc();
+
+					cnt = 4;
+				while (cnt--) {
+					if (atv_status->afc < 1500)
+						break;
+					atv_status->afc =
+						retrieve_vpll_carrier_afc();
+					usleep_range(5*1000, 5*1000+100);
+				}
+					if (atv_status->afc < 1500)
+						break;
+				}
+			}
+
+			if (atv_status->afc > 4000 && !atvdemod_scan_mode)
+				atv_status->atv_lock = 0;
+
+			if (last_report_freq != c->frequency)
+				last_report_freq = c->frequency;
+
+			if (atvdemod_scan_mode)
+				pr_err("%s,lock freq:%d, afc:%d\n", __func__,
+					c->frequency, atv_status->afc);
+			break;
+
+		} else if (try_std%3 == 0 && atvdemod_scan_mode) {
+			if ((c->analog.std & 0xff000000)
+				!= V4L2_COLOR_STD_PAL) {
+				c->analog.std =
+					V4L2_COLOR_STD_PAL | V4L2_STD_PAL_DK;
+			}
+			if (abs(c->frequency - last_report_freq) > 1000000) {
+				c->frequency -= 500000;
+				pr_err("@@@ %s freq:%d unlock,try back 0.5M\n",
+					__func__, c->frequency);
+			} else
+				c->frequency += 1;
+			fe->ops.set_frontend(fe);
+			usleep_range(10*1000, 10*1000+100);
+		}
+		if (atvdemod_scan_mode)
+			pr_err("@@@ %s freq:%d unlock, read lock again\n",
+				__func__, c->frequency);
+		if (atvdemod_scan_mode == 0)
+			usleep_range(10*1000, 10*1000+100);
+		else
+			usleep_range(1000, 1200);
+
+		atv_status->atv_lock = 0;
+		try_std++;
+	}
+	if (atvdemod_scan_mode == 0) {
+		if (abs(atv_status->afc) < 20)
+			afc_wave_cnt = 0;
+		if (500*1000 > abs(last_frq - c->frequency)
+				&& 20 < abs(atv_status->afc)
+				&& 200 > abs(atv_status->afc)) {
+			afc_wave_cnt++;
+			pr_err("%s play mode,afc_wave_cnt:%d\n",
+				__func__, afc_wave_cnt);
+			if (afc_wave_cnt < 20) {
+				atv_status->afc = 0;
+				pr_err("%s, afc is wave,ignore\n", __func__);
+			}
+		}
+	}
+	return 0;
+}
+
+void aml_atvdemod_set_params(struct dvb_frontend *fe,
+				struct analog_parameters *p)
+{
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
+
+	if (fe->ops.info.type == FE_ANALOG) {
+		if ((p->std != amlatvdemod_devp->parm.std) ||
+			(p->tuner_id == AM_TUNER_R840) ||
+			(p->tuner_id == AM_TUNER_SI2151) ||
+			(p->tuner_id == AM_TUNER_MXL661)) {
+			amlatvdemod_devp->parm.std  = p->std;
+			amlatvdemod_devp->parm.if_freq = p->if_freq;
+			amlatvdemod_devp->parm.if_inv = p->if_inv;
+			amlatvdemod_devp->parm.tuner_id = p->tuner_id;
+			/* open AGC if needed */
+			if (amlatvdemod_devp->pin != NULL)
+				devm_pinctrl_put(amlatvdemod_devp->pin);
+			if (amlatvdemod_devp->pin_name)
+				amlatvdemod_devp->pin =
+				devm_pinctrl_get_select(amlatvdemod_devp->dev,
+						amlatvdemod_devp->pin_name);
+			atv_dmd_set_std();
+			last_frq = c->frequency;
+			last_std = c->analog.std;
+			pr_info("[amlatvdemod..]%s set std color %s, audio type %s.\n",
+				__func__,
+			v4l2_std_to_str(0xff000000&amlatvdemod_devp->parm.std),
+			v4l2_std_to_str(0xffffff&amlatvdemod_devp->parm.std));
+			pr_info("[amlatvdemod..]%s set if_freq 0x%x, if_inv 0x%x.\n",
+				__func__, amlatvdemod_devp->parm.if_freq,
+				amlatvdemod_devp->parm.if_inv);
+		}
+	}
+}
+static int aml_atvdemod_get_afc(struct dvb_frontend *fe, s32 *afc)
+{
+	*afc = retrieve_vpll_carrier_afc();
+	pr_info("[amlatvdemod..]%s afc %d.\n", __func__, *afc);
+	return 0;
+}
+
+static int aml_atvdemod_get_ops(struct aml_fe_dev *dev, int mode, void *ops)
+{
+	struct analog_demod_ops *aml_analog_ops =
+	    (struct analog_demod_ops *)ops;
+	if (!ops) {
+		pr_dbg("[amlatvdemod..]%s null pointer error.\n", __func__);
+		return -1;
+	}
+	aml_analog_ops->get_afc = aml_atvdemod_get_afc;
+	aml_analog_ops->get_snr = aml_atvdemod_get_snr;
+	aml_analog_ops->get_status = aml_atvdemod_get_status;
+	aml_analog_ops->set_params = aml_atvdemod_set_params;
+	aml_analog_ops->get_pll_status = aml_atvdemod_get_pll_status;
+	aml_analog_ops->get_atv_status = aml_atvdemod_get_atv_status;
+	return 0;
+}
+
+static struct aml_fe_drv aml_atvdemod_drv = {
+	.name = "aml_atv_demod",
+	.capability = AM_FE_ANALOG,
+	.id = AM_ATV_DEMOD_AML,
+	.get_ops = aml_atvdemod_get_ops,
+	.init = aml_atvdemod_fe_init,
+	.enter_mode = aml_atvdemod_enter_mode,
+	.leave_mode = aml_atvdemod_leave_mode,
+	.suspend = aml_atvdemod_suspend,
+	.resume = aml_atvdemod_resume,
+};
+
+struct class *aml_atvdemod_clsp;
+
+static void aml_atvdemod_dt_parse(struct platform_device *pdev)
+{
+	struct device_node *node;
+	unsigned int val;
+	int ret;
+
+	node = pdev->dev.of_node;
+	/* get integer value */
+	if (node) {
+		ret = of_property_read_u32(node, "reg_23cf", &val);
+		if (ret)
+			pr_dbg("Can't find  reg_23cf.\n");
+		else
+			reg_23cf = val;
+		ret = of_property_read_u32(node, "audio_gain_val", &val);
+		if (ret)
+			pr_dbg("Can't find  audio_gain_val.\n");
+		else
+			set_audio_gain_val(val);
+		ret = of_property_read_u32(node, "video_gain_val", &val);
+		if (ret)
+			pr_dbg("Can't find  video_gain_val.\n");
+		else
+			set_video_gain_val(val);
+		/* agc pin mux */
+		ret = of_property_read_string(node, "pinctrl-names",
+			&amlatvdemod_devp->pin_name);
+		if (!ret) {
+			/* amlatvdemod_devp->pin = */
+			/* devm_pinctrl_get_select(&pdev->dev, */
+			/* amlatvdemod_devp->pin_name); */
+			pr_dbg("atvdemod agc pinmux name:%s\n",
+				amlatvdemod_devp->pin_name);
+		}
+	}
+}
+static struct resource amlatvdemod_memobj;
+void __iomem *amlatvdemod_reg_base;
+void __iomem *amlatvdemod_hiu_reg_base;
+void __iomem *amlatvdemod_periphs_reg_base;
+int amlatvdemod_reg_read(unsigned int reg, unsigned int *val)
+{
+	*val = readl(amlatvdemod_reg_base + reg);
+	return 0;
+}
+
+int amlatvdemod_reg_write(unsigned int reg, unsigned int val)
+{
+	writel(val, (amlatvdemod_reg_base + reg));
+	return 0;
+}
+
+int amlatvdemod_hiu_reg_read(unsigned int reg, unsigned int *val)
+{
+	*val = readl(amlatvdemod_hiu_reg_base + ((reg - 0x1000)<<2));
+	return 0;
+}
+
+int amlatvdemod_hiu_reg_write(unsigned int reg, unsigned int val)
+{
+	writel(val, (amlatvdemod_hiu_reg_base + ((reg - 0x1000)<<2)));
+	return 0;
+}
+int amlatvdemod_periphs_reg_read(unsigned int reg, unsigned int *val)
+{
+	*val = readl(amlatvdemod_periphs_reg_base + ((reg - 0x1000)<<2));
+	return 0;
+}
+
+int amlatvdemod_periphs_reg_write(unsigned int reg, unsigned int val)
+{
+	writel(val, (amlatvdemod_periphs_reg_base + ((reg - 0x1000)<<2)));
+	return 0;
+}
+
+static int aml_atvdemod_probe(struct platform_device *pdev)
+{
+	int ret = 0;
+	struct resource *res;
+	int size_io_reg;
+
+	res = &amlatvdemod_memobj;
+	amlatvdemod_devp = kmalloc(sizeof(struct amlatvdemod_device_s),
+		GFP_KERNEL);
+	if (!amlatvdemod_devp)
+		goto fail_alloc_region;
+	memset(amlatvdemod_devp, 0, sizeof(struct amlatvdemod_device_s));
+	amlatvdemod_devp->clsp = class_create(THIS_MODULE,
+		ATVDEMOD_DEVICE_NAME);
+	if (!amlatvdemod_devp->clsp)
+		goto fail_create_class;
+	ret = class_create_file(amlatvdemod_devp->clsp,
+		&class_attr_atvdemod_debug);
+	if (ret)
+		goto fail_class_create_file;
+	amlatvdemod_devp->dev = &pdev->dev;
+
+	/*reg mem*/
+	pr_info("%s:amlatvdemod start get  ioremap .\n", __func__);
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(&pdev->dev, "missing memory resource\n");
+		return -ENODEV;
+	}
+	size_io_reg = resource_size(res);
+	pr_info("amlatvdemod_probe reg=%p,size=%x\n",
+			(void *)res->start, size_io_reg);
+	amlatvdemod_reg_base =
+		devm_ioremap_nocache(&pdev->dev, res->start, size_io_reg);
+	if (!amlatvdemod_reg_base) {
+		dev_err(&pdev->dev, "amlatvdemod ioremap failed\n");
+		return -ENOMEM;
+	}
+	pr_info("%s: amlatvdemod maped reg_base =%p, size=%x\n",
+			__func__, amlatvdemod_reg_base, size_io_reg);
+	/*remap hiu mem*/
+	amlatvdemod_hiu_reg_base = ioremap(0xc883c000, 0x2000);
+	/*remap periphs mem*/
+	amlatvdemod_periphs_reg_base = ioremap(0xc8834000, 0x2000);
+
+	/*initialize the tuner common struct and register*/
+	aml_register_fe_drv(AM_DEV_ATV_DEMOD, &aml_atvdemod_drv);
+
+	aml_atvdemod_dt_parse(pdev);
+	pr_dbg("[amlatvdemod.] : probe ok.\n");
+	return 0;
+
+fail_class_create_file:
+	pr_dbg("[amlatvdemod.] : atvdemod class file create error.\n");
+	class_destroy(amlatvdemod_devp->clsp);
+fail_create_class:
+	pr_dbg("[amlatvdemod.] : atvdemod class create error.\n");
+	kfree(amlatvdemod_devp);
+fail_alloc_region:
+	pr_dbg("[amlatvdemod.] : atvdemod alloc error.\n");
+	pr_dbg("[amlatvdemod.] : atvdemod_init fail.\n");
+	return ret;
+}
+
+static int __exit aml_atvdemod_remove(struct platform_device *pdev)
+{
+	if (amlatvdemod_devp == NULL)
+		return -1;
+	class_destroy(amlatvdemod_devp->clsp);
+	aml_unregister_fe_drv(AM_DEV_ATV_DEMOD, &aml_atvdemod_drv);
+	kfree(amlatvdemod_devp);
+	pr_dbg("[amlatvdemod.] : amvecm_remove.\n");
+	return 0;
+}
+
+
+static const struct of_device_id aml_atvdemod_dt_match[] = {
+	{
+		.compatible = "amlogic, aml_atv_demod",
+	},
+	{},
+};
+
+static struct platform_driver aml_atvdemod_driver = {
+	.driver = {
+		.name = "aml_atv_demod",
+		.owner = THIS_MODULE,
+		.of_match_table = aml_atvdemod_dt_match,
+	},
+	.probe = aml_atvdemod_probe,
+	.remove = __exit_p(aml_atvdemod_remove),
+};
+
+
+static int __init aml_atvdemod_init(void)
+{
+	if (platform_driver_register(&aml_atvdemod_driver)) {
+		pr_err("failed to register amlatvdemod driver module\n");
+		return -ENODEV;
+	}
+	pr_dbg("[amlatvdemod..]%s.\n", __func__);
+	return 0;
+}
+
+static void __exit aml_atvdemod_exit(void)
+{
+	platform_driver_unregister(&aml_atvdemod_driver);
+	pr_dbg("[amlatvdemod..]%s: driver removed ok.\n", __func__);
+}
+
+MODULE_AUTHOR("dezhi.kong <dezhi.kong@amlogic.com>");
+MODULE_DESCRIPTION("aml atv demod device driver");
+MODULE_LICENSE("GPL");
+
+fs_initcall(aml_atvdemod_init);
+module_exit(aml_atvdemod_exit);
diff --git a/drivers/stream_input/tv_frontend/atv_demod/atvdemod_func.c b/drivers/stream_input/tv_frontend/atv_demod/atvdemod_func.c
new file mode 100644
index 0000000..f5a086e
--- /dev/null
+++ b/drivers/stream_input/tv_frontend/atv_demod/atvdemod_func.c
@@ -0,0 +1,2163 @@
+/*
+ * Silicon labs amlogic Atvdemod Device Driver
+ *
+ * Author: dezhi kong <dezhi.kong@amlogic.com>
+ *
+ *
+ * Copyright (C) 2014 Amlogic Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/* Standard Liniux Headers */
+#include <linux/module.h>
+#include <linux/i2c.h>
+#include <linux/delay.h>
+#include <linux/timer.h>
+#include <linux/mutex.h>
+#include <linux/interrupt.h>
+#include <linux/time.h>
+
+#include "atvdemod_func.h"
+#include "../aml_dvb_reg.h"
+
+static int broad_std = AML_ATV_DEMOD_VIDEO_MODE_PROP_NTSC;
+module_param(broad_std, int, 0644);
+MODULE_PARM_DESC(broad_std, "\n broad_std\n");
+
+static unsigned long over_threshold = 0xffff;
+module_param(over_threshold, ulong, 0644);
+MODULE_PARM_DESC(over_threshold, "\n over_threshold\n");
+
+static unsigned long input_amplitude = 0xffff;
+module_param(input_amplitude, ulong, 0644);
+MODULE_PARM_DESC(input_amplitude, "\n input_amplitude\n");
+
+static bool audio_det_en;
+module_param(audio_det_en, bool, 0644);
+MODULE_PARM_DESC(audio_det_en, "\n audio_det_en\n");
+
+static bool non_std_en;
+module_param(non_std_en, bool, 0644);
+MODULE_PARM_DESC(non_std__en, "\n non_std_en\n");
+
+static int atv_video_gain;
+module_param(atv_video_gain, int, 0644);
+MODULE_PARM_DESC(atv_video_gain, "\n atv_video_gain\n");
+
+static int audio_det_mode = AUDIO_AUTO_DETECT;
+module_param(audio_det_mode, int, 0644);
+MODULE_PARM_DESC(audio_det_mode, "\n audio_det_mode\n");
+
+static int aud_dmd_jilinTV;
+module_param(aud_dmd_jilinTV, int, 0644);
+MODULE_PARM_DESC(aud_dmd_jilinTV, "\naud dmodulation setting for jilin TV\n");
+
+static unsigned int if_freq = 4250000;	/*PAL-DK:3250000;NTSC-M:4250000*/
+module_param(if_freq, uint, 0644);
+MODULE_PARM_DESC(if_freq, "\n if_freq\n");
+
+static int if_inv;
+module_param(if_inv, int, 0644);
+MODULE_PARM_DESC(if_inv, "\n if_inv\n");
+
+static int afc_default = CARR_AFC_DEFAULT_VAL;
+module_param(afc_default, int, 0644);
+MODULE_PARM_DESC(afc_default, "\n afc_default\n");
+
+/*GDE_Curve
+ *			0: CURVE-M
+ *			1: CURVE-A
+ *			2: CURVE-B
+ *			3: CURVE-CHINA
+ *			4: BYPASS
+ *BG --> CURVE-B(BYPASS)
+ *DK --> CURVE-CHINA
+ *NM --> CURVE-M
+ *I --> BYPASS
+ *SECAM --> BYPASS
+ */
+static int gde_curve;
+module_param(gde_curve, int, 0644);
+MODULE_PARM_DESC(gde_curve, "\n gde_curve\n");
+
+static int sound_format;
+module_param(sound_format, int, 0644);
+MODULE_PARM_DESC(sound_format, "\n sound_format\n");
+
+static unsigned int freq_hz_cvrt = AML_ATV_DEMOD_FREQ_60HZ_VERT;
+module_param(freq_hz_cvrt, int, 0644);
+MODULE_PARM_DESC(freq_hz_cvrt, "\n freq_hz\n");
+
+int atvdemod_debug_en;
+module_param(atvdemod_debug_en, int, 0644);
+MODULE_PARM_DESC(atvdemod_debug_en, "\n atvdemod_debug_en\n");
+
+/*1:gpio mode output low;2:pwm mode*/
+static unsigned int atvdemod_agc_pinmux = 2;
+module_param(atvdemod_agc_pinmux, int, 0644);
+MODULE_PARM_DESC(atvdemod_agc_pinmux, "\n atvdemod_agc_pinmux\n");
+
+static unsigned int atvdemod_afc_range = 5;
+module_param(atvdemod_afc_range, uint, 0644);
+MODULE_PARM_DESC(atvdemod_afc_range, "\n atvdemod_afc_range\n");
+
+static unsigned int atvdemod_afc_offset = 500;
+module_param(atvdemod_afc_offset, uint, 0644);
+MODULE_PARM_DESC(atvdemod_afc_offset, "\n atvdemod_afc_offset\n");
+
+static unsigned int atvdemod_timer_en = 1;
+module_param(atvdemod_timer_en, uint, 0644);
+MODULE_PARM_DESC(atvdemod_timer_en, "\n atvdemod_timer_en\n");
+
+static unsigned int atvdemod_afc_en;
+module_param(atvdemod_afc_en, uint, 0644);
+MODULE_PARM_DESC(atvdemod_afc_en, "\n atvdemod_afc_en\n");
+
+static unsigned int atvdemod_monitor_en;
+module_param(atvdemod_monitor_en, uint, 0644);
+MODULE_PARM_DESC(atvdemod_monitor_en, "\n atvdemod_monitor_en\n");
+
+static unsigned int atvdemod_det_snr_en = 1;
+module_param(atvdemod_det_snr_en, uint, 0644);
+MODULE_PARM_DESC(atvdemod_det_snr_en, "\n atvdemod_det_snr_en\n");
+
+static unsigned int pwm_kp = 0x19;
+module_param(pwm_kp, uint, 0644);
+MODULE_PARM_DESC(pwm_kp, "\n pwm_kp\n");
+
+static unsigned int reg_dbg_en;
+module_param(reg_dbg_en, uint, 0644);
+MODULE_PARM_DESC(reg_dbg_en, "\n reg_dbg_en\n");
+
+static unsigned int audio_gain_val = 512;
+module_param(audio_gain_val, uint, 0644);
+MODULE_PARM_DESC(audio_gain_val, "\n audio_gain_val\n");
+
+enum AUDIO_SCAN_ID {
+	ID_PAL_I = 0,
+	ID_PAL_M,
+	ID_PAL_DK,
+	ID_PAL_BG,
+	ID_MAX,
+};
+
+static unsigned int mix1_freq;
+static unsigned int timer_init_flag;
+struct timer_list atvdemod_timer;
+static int snr_val;
+int broad_std_except_pal_m;
+
+int get_atvdemod_snr_val(void)
+{
+	return snr_val;
+}
+EXPORT_SYMBOL(get_atvdemod_snr_val);
+
+void amlatvdemod_set_std(int val)
+{
+	broad_std = val;
+}
+EXPORT_SYMBOL(amlatvdemod_set_std);
+
+void atv_dmd_wr_reg(unsigned char block, unsigned char reg, unsigned long data)
+{
+	/* unsigned long data_tmp; */
+	unsigned long reg_addr = (block<<8) + reg * 4;
+
+	amlatvdemod_reg_write(reg_addr, data);
+}
+
+unsigned long atv_dmd_rd_reg(unsigned char block, unsigned char reg)
+{
+	unsigned long data = 0;
+	unsigned long reg_addr = (block<<8) + reg * 4;
+
+	amlatvdemod_reg_read(reg_addr, (unsigned int *)&data);
+	return data;
+}
+
+unsigned long atv_dmd_rd_byte(unsigned long block_addr, unsigned long reg_addr)
+{
+	unsigned long data;
+
+	data = atv_dmd_rd_long(block_addr, reg_addr);
+	/*R_APB_REG((((block_addr & 0xff) <<6) + ((reg_addr & 0xff) >>2)) << 2);
+	 *((volatile unsigned long *) (ATV_DMD_APB_BASE_ADDR+
+	((((block_addr & 0xff) <<6) + ((reg_addr & 0xff) >>2)) << 2)));
+	 */
+	if ((reg_addr & 0x3) == 0)
+		data = data >> 24;
+	else if ((reg_addr & 0x3) == 1)
+		data = (data >> 16 & 0xff);
+	else if ((reg_addr & 0x3) == 2)
+		data = (data >> 8 & 0xff);
+	else if ((reg_addr & 0x3) == 3)
+		data = (data >> 0 & 0xff);
+	return data;
+}
+
+unsigned long atv_dmd_rd_word(unsigned long block_addr, unsigned long reg_addr)
+{
+	unsigned long data;
+
+	data = atv_dmd_rd_long(block_addr, reg_addr);
+	/*R_APB_REG((((block_addr & 0xff) <<6) + ((reg_addr & 0xff) >>2)) << 2);
+	 *((volatile unsigned long *) (ATV_DMD_APB_BASE_ADDR+
+	((((block_addr & 0xff) <<6) + ((reg_addr & 0xff) >>2)) << 2)));
+	 */
+	if ((reg_addr & 0x3) == 0)
+		data = data >> 16;
+	else if ((reg_addr & 0x3) == 1)
+		data = (data >> 8 & 0xffff);
+	else if ((reg_addr & 0x3) == 2)
+		data = (data >> 0 & 0xffff);
+	else if ((reg_addr & 0x3) == 3)
+		data = (((data & 0xff) << 8) | ((data >> 24) & 0xff));
+	return data;
+}
+
+unsigned long atv_dmd_rd_long(unsigned long block_addr, unsigned long reg_addr)
+{
+	unsigned long data;
+	/*data = *((volatile unsigned long *) (ATV_DMD_APB_BASE_ADDR+
+	 *((((block_addr & 0xff) <<6) + ((reg_addr & 0xff) >>2)) << 2)));
+	 */
+	data =
+	    R_ATVDEMOD_REG((((block_addr & 0xff) << 6) +
+	    ((reg_addr & 0xff) >> 2)) << 2);
+
+	return data;
+}
+EXPORT_SYMBOL(atv_dmd_rd_long);
+
+void atv_dmd_wr_long(unsigned long block_addr, unsigned long reg_addr,
+		     unsigned long data)
+{
+	W_ATVDEMOD_REG((((block_addr & 0xff) << 6) +
+		((reg_addr & 0xff) >> 2)) << 2, data);
+	if (reg_dbg_en)
+		pr_dbg("block_addr:0x%x,reg_addr:0x%x;data:0x%x\n",
+		(unsigned int)block_addr, (unsigned int)reg_addr,
+		(unsigned int)data);
+	/**((volatile unsigned long *)
+	 *	(ATV_DMD_APB_BASE_ADDR+((((block_addr & 0xff) << 6) +
+	 *	((reg_addr & 0xff) >> 2)) << 2))) = data;
+	 */
+
+}
+EXPORT_SYMBOL(atv_dmd_wr_long);
+
+void atv_dmd_wr_word(unsigned long block_addr, unsigned long reg_addr,
+		     unsigned long data)
+{
+	unsigned long data_tmp;
+
+	data_tmp = atv_dmd_rd_long(block_addr, reg_addr);
+	data = data & 0xffff;
+	if ((reg_addr & 0x3) == 0)
+		data = (data << 16 | (data_tmp & 0xffff));
+	else if ((reg_addr & 0x3) == 1)
+		data =
+		    ((data_tmp & 0xff000000) | (data << 8) | (data_tmp & 0xff));
+	else if ((reg_addr & 0x3) == 2)
+		data = (data | (data_tmp & 0xffff0000));
+	else if ((reg_addr & 0x3) == 3)
+		data =
+		    (((data & 0xff) << 24) | ((data_tmp & 0xffff0000) >> 8) |
+		     ((data & 0xff00) >> 8));
+
+	/**((volatile unsigned long *) (ATV_DMD_APB_BASE_ADDR+
+	 *((((block_addr & 0xff) <<6) + ((reg_addr & 0xff) >>2)) << 2))) = data;
+	 */
+	atv_dmd_wr_long(block_addr, reg_addr, data);
+	/*W_ATVDEMOD_REG(((((block_addr & 0xff) <<6) +
+	 *((reg_addr & 0xff) >>2)) << 2), data);
+	 */
+
+}
+
+void atv_dmd_wr_byte(unsigned long block_addr, unsigned long reg_addr,
+		     unsigned long data)
+{
+	unsigned long data_tmp;
+
+	data_tmp = atv_dmd_rd_long(block_addr, reg_addr);
+
+	/*pr_info("atv demod wr byte, read block addr %lx\n",block_addr);*/
+	/*pr_info("atv demod wr byte, read reg addr %lx\n", reg_addr);*/
+	/*pr_info("atv demod wr byte, wr data %lx\n",data);*/
+	/*pr_info("atv demod wr byte, read data out %lx\n",data_tmp);*/
+
+	data = data & 0xff;
+	/*pr_info("atv demod wr byte, data & 0xff %lx\n",data);*/
+	if ((reg_addr & 0x3) == 0) {
+		data = (data << 24 | (data_tmp & 0xffffff));
+		/*pr_info("atv demod wr byte, reg_addr & 0x3 == 0,
+		 *wr data %lx\n",data);
+		 */
+	} else if ((reg_addr & 0x3) == 1)
+		data =
+		    ((data_tmp & 0xff000000) | (data << 16) |
+		     (data_tmp & 0xffff));
+	else if ((reg_addr & 0x3) == 2)
+		data =
+		    ((data_tmp & 0xffff0000) | (data << 8) | (data_tmp & 0xff));
+	else if ((reg_addr & 0x3) == 3)
+		data = ((data_tmp & 0xffffff00) | (data & 0xff));
+
+	/*pr_info("atv demod wr byte, wr data %lx\n",data);*/
+
+	/**((volatile unsigned long *) (ATV_DMD_APB_BASE_ADDR+
+	 *((((block_addr & 0xff) <<6) + ((reg_addr & 0xff) >>2)) << 2))) = data;
+	 */
+	atv_dmd_wr_long(block_addr, reg_addr, data);
+	/*W_ATVDEMOD_REG(((((block_addr & 0xff) <<6) +
+	 *((reg_addr & 0xff) >>2)) << 2), data);
+	 */
+}
+
+void set_audio_gain_val(int val)
+{
+	audio_gain_val = val;
+}
+
+void set_video_gain_val(int val)
+{
+	atv_video_gain = val;
+}
+
+void atv_dmd_soft_reset(void)
+{
+	atv_dmd_wr_long(0x1d, 0x0, 0x1035);/* disable dac */
+	atv_dmd_wr_byte(APB_BLOCK_ADDR_SYSTEM_MGT, 0x0, 0x0);
+	atv_dmd_wr_byte(APB_BLOCK_ADDR_SYSTEM_MGT, 0x0, 0x1);
+	atv_dmd_wr_long(0x1d, 0x0, 0x1037);/* enable dac */
+}
+
+void atv_dmd_input_clk_32m(void)
+{
+	atv_dmd_wr_byte(APB_BLOCK_ADDR_ADC_MGR, 0x2, 0x1);
+}
+
+void read_version_register(void)
+{
+	unsigned long data, Byte1, Byte2, Word;
+
+	pr_info("ATV-DMD read version register\n");
+	Byte1 = atv_dmd_rd_byte(APB_BLOCK_ADDR_VERS_REGISTER, 0x0);
+	Byte2 = atv_dmd_rd_byte(APB_BLOCK_ADDR_VERS_REGISTER, 0x1);
+	Word = atv_dmd_rd_word(APB_BLOCK_ADDR_VERS_REGISTER, 0x2);
+	data = atv_dmd_rd_long(APB_BLOCK_ADDR_VERS_REGISTER, 0x0);
+
+	pr_info("atv demod read version register data out %lx\n", data);
+
+	if ((data != 0x516EAB13)
+	    || (((Byte1 << 24) | (Byte2 << 16) | Word) != 0x516EAB13))
+		pr_info("atv demod read version reg failed\n");
+}
+
+void check_communication_interface(void)
+{
+	unsigned long data_tmp;
+
+	pr_info("ATV-DMD check communication intf\n");
+	atv_dmd_wr_long(APB_BLOCK_ADDR_VERS_REGISTER, 0x0, 0xA1B2C3D4);
+	atv_dmd_wr_byte(APB_BLOCK_ADDR_VERS_REGISTER, 0x1, 0x34);
+	atv_dmd_wr_word(APB_BLOCK_ADDR_VERS_REGISTER, 0x2, 0xBCDE);
+	data_tmp = atv_dmd_rd_long(APB_BLOCK_ADDR_VERS_REGISTER, 0x0);
+	pr_info("atv demod check communication intf data out %lx\n", data_tmp);
+
+	if (data_tmp != 0xa134bcde)
+		pr_info("atv demod check communication intf failed\n");
+	atv_dmd_wr_long(APB_BLOCK_ADDR_VERS_REGISTER, 0x0, 0x516EAB13);
+}
+
+void power_on_receiver(void)
+{
+	atv_dmd_wr_byte(APB_BLOCK_ADDR_ADC_MGR, 0x2, 0x11);
+}
+
+void atv_dmd_misc(void)
+{
+	atv_dmd_wr_byte(APB_BLOCK_ADDR_AGC_PWM, 0x08, 0x38);	/*zhuangwei*/
+	/*cpu.write_byte(8'h1A,8'h0E,8'h06);//zhuangwei*/
+	/*cpu.write_byte(8'h19,8'h01,8'h7f);//zhuangwei*/
+	atv_dmd_wr_byte(0x0f, 0x45, 0x90);	/*zhuangwei*/
+
+	atv_dmd_wr_long(0x0f, 0x44, 0x5c8808c1);/*zhuangwei*/
+	if (amlatvdemod_devp->parm.tuner_id == AM_TUNER_R840) {
+		atv_dmd_wr_long(0x0f, 0x3c, reg_23cf);/*zhuangwei*/
+		/*guanzhong@20150804a*/
+		atv_dmd_wr_byte(APB_BLOCK_ADDR_SIF_STG_2, 0x00, 0x1);
+		atv_dmd_wr_long(APB_BLOCK_ADDR_AGC_PWM, 0x08, 0x60180200);
+		/*dezhi@20150610a 0x1a maybe better?!*/
+		/* atv_dmd_wr_byte(APB_BLOCK_ADDR_AGC_PWM, 0x09, 0x19); */
+	} else {
+		atv_dmd_wr_long(0x0f, 0x3c, 0x88188832);/*zhuangwei*/
+		atv_dmd_wr_long(APB_BLOCK_ADDR_AGC_PWM, 0x08, 0x46170200);
+	}
+
+	if (amlatvdemod_devp->parm.tuner_id == AM_TUNER_MXL661) {
+		atv_dmd_wr_long(0x0c, 0x04, 0xbffa0000) ;/*test in sky*/
+		atv_dmd_wr_long(0x0c, 0x00, 0x5a4000);/*test in sky*/
+		/*guanzhong@20151013 fix nonstd def is:0x0c010301;0x0c020601*/
+		atv_dmd_wr_long(APB_BLOCK_ADDR_CARR_RCVY, 0x24, 0x0c030901);
+	} else {
+		/*zhuangwei 0xdafa0000*/
+		atv_dmd_wr_long(0x0c, 0x04, 0xc8fa0000);
+		atv_dmd_wr_long(0x0c, 0x00, 0x554000);/*zhuangwei*/
+	}
+	atv_dmd_wr_long(0x19, 0x04, 0xdafa0000);/*zhuangwei*/
+	atv_dmd_wr_long(0x19, 0x00, 0x4a4000);/*zhuangwei*/
+	/*atv_dmd_wr_byte(0x0c,0x01,0x28);//pwd-out gain*/
+	/*atv_dmd_wr_byte(0x0c,0x04,0xc0);//pwd-out offset*/
+
+	aml_audio_valume_gain_set(audio_gain_val);
+	/* 20160121 fix audio demodulation over */
+	atv_dmd_wr_long(0x09, 0x00, 0x1030501);
+	atv_dmd_wr_long(0x09, 0x04, 0x1900000);
+	if (aud_dmd_jilinTV)
+		atv_dmd_wr_long(0x09, 0x00, 0x2030503);
+	if (non_std_en == 1) {
+		atv_dmd_wr_long(0x09, 0x00, 0x2030503);
+		atv_dmd_wr_long(0x0f, 0x44, 0x7c8808c1);
+		atv_dmd_wr_long(0x06, 0x24, 0x0c010801);
+	} else {
+		atv_dmd_wr_long(0x09, 0x00, 0x1030501);
+		if (atv_video_gain)
+			atv_dmd_wr_long(0x0f, 0x44, atv_video_gain);
+		else
+			atv_dmd_wr_long(0x0f, 0x44, 0xfc0808c1);
+		atv_dmd_wr_long(0x06, 0x24, 0xc030901);
+	}
+
+}
+
+/*Broadcast_Standard*/
+/*                      0: NTSC*/
+/*                      1: NTSC-J*/
+/*                      2: PAL-M,*/
+/*                      3: PAL-BG*/
+/*                      4: DTV*/
+/*                      5: SECAM- DK2*/
+/*                      6: SECAM -DK3*/
+/*                      7: PAL-BG, NICAM*/
+/*                      8: PAL-DK-CHINA*/
+/*                      9: SECAM-L / SECAM-DK3*/
+/*                      10: PAL-I*/
+/*                      11: PAL-DK1*/
+/*GDE_Curve*/
+/*                      0: CURVE-M*/
+/*                      1: CURVE-A*/
+/*                      2: CURVE-B*/
+/*                      3: CURVE-CHINA*/
+/*                      4: BYPASS*/
+/*sound format 0: MONO;1:NICAM*/
+void configure_receiver(int Broadcast_Standard, unsigned int Tuner_IF_Frequency,
+			int Tuner_Input_IF_inverted, int GDE_Curve,
+			int sound_format)
+{
+	int tmp_int;
+	int mixer1 = 0;
+	int mixer3 = 0;
+	int mixer3_bypass = 0;
+	int cv = 0;
+	/*int if_freq = 0;*/
+
+	int i = 0;
+	int super_coef0 = 0;
+	int super_coef1 = 0;
+	int super_coef2 = 0;
+	int gp_coeff_1[37];
+	int gp_coeff_2[37];
+	int gp_cv_g1 = 0;
+	int gp_cv_g2 = 0;
+	int crvy_reg_1 = 0;
+	int crvy_reg_2 = 0;
+	int sif_co_mx = 0;
+	int sif_fi_mx = 0;
+	int sif_ic_bw = 0;
+	int sif_bb_bw = 0;
+	int sif_deemp = 0;
+	int sif_cfg_demod = 0;
+	int sif_fm_gain = 0;
+	int gd_coeff[6];
+	int gd_bypass;
+
+	pr_info("ATV-DMD configure receiver register\n");
+
+	if ((Broadcast_Standard == AML_ATV_DEMOD_VIDEO_MODE_PROP_NTSC) ||
+		(Broadcast_Standard == AML_ATV_DEMOD_VIDEO_MODE_PROP_NTSC_J) ||
+		(Broadcast_Standard == AML_ATV_DEMOD_VIDEO_MODE_PROP_PAL_M) ||
+		(Broadcast_Standard == AML_ATV_DEMOD_VIDEO_MODE_PROP_NTSC_DK) ||
+		(Broadcast_Standard == AML_ATV_DEMOD_VIDEO_MODE_PROP_NTSC_BG) ||
+		(Broadcast_Standard == AML_ATV_DEMOD_VIDEO_MODE_PROP_NTSC_I)) {
+		gp_coeff_1[0] = 0x57777;
+		gp_coeff_1[1] = 0xdd777;
+		gp_coeff_1[2] = 0x7d777;
+		gp_coeff_1[3] = 0x75777;
+		gp_coeff_1[4] = 0x75777;
+		gp_coeff_1[5] = 0x7c777;
+		gp_coeff_1[6] = 0x5c777;
+		gp_coeff_1[7] = 0x44777;
+		gp_coeff_1[8] = 0x54777;
+		gp_coeff_1[9] = 0x47d77;
+		gp_coeff_1[10] = 0x55d77;
+		gp_coeff_1[11] = 0x55577;
+		gp_coeff_1[12] = 0x77577;
+		gp_coeff_1[13] = 0xc4c77;
+		gp_coeff_1[14] = 0xd7d77;
+		gp_coeff_1[15] = 0x75477;
+		gp_coeff_1[16] = 0xcc477;
+		gp_coeff_1[17] = 0x575d7;
+		gp_coeff_1[18] = 0xc4c77;
+		gp_coeff_1[19] = 0xdd757;
+		gp_coeff_1[20] = 0xdd477;
+		gp_coeff_1[21] = 0x77dd7;
+		gp_coeff_1[22] = 0x5dc77;
+		gp_coeff_1[23] = 0x47c47;
+		gp_coeff_1[24] = 0x57477;
+		gp_coeff_1[25] = 0x5c7c7;
+		gp_coeff_1[26] = 0xccc77;
+		gp_coeff_1[27] = 0x5ddd5;
+		gp_coeff_1[28] = 0x54477;
+		gp_coeff_1[29] = 0x7757d;
+		gp_coeff_1[30] = 0x755d7;
+		gp_coeff_1[31] = 0x47cc4;
+		gp_coeff_1[32] = 0x57d57;
+		gp_coeff_1[33] = 0x554cc;
+		gp_coeff_1[34] = 0x755d7;
+		gp_coeff_1[35] = 0x7d3b2;
+		gp_coeff_1[36] = 0x73a91;
+		gp_coeff_2[0] = 0xd5777;
+		gp_coeff_2[1] = 0x77777;
+		gp_coeff_2[2] = 0x7c777;
+		gp_coeff_2[3] = 0xcc777;
+		gp_coeff_2[4] = 0xc7777;
+		gp_coeff_2[5] = 0xdd777;
+		gp_coeff_2[6] = 0x44c77;
+		gp_coeff_2[7] = 0x54c77;
+		gp_coeff_2[8] = 0xdd777;
+		gp_coeff_2[9] = 0x7c777;
+		gp_coeff_2[10] = 0xc7c77;
+		gp_coeff_2[11] = 0x75c77;
+		gp_coeff_2[12] = 0xdd577;
+		gp_coeff_2[13] = 0x44777;
+		gp_coeff_2[14] = 0xd5c77;
+		gp_coeff_2[15] = 0xdc777;
+		gp_coeff_2[16] = 0xd7757;
+		gp_coeff_2[17] = 0x4c757;
+		gp_coeff_2[18] = 0x7d777;
+		gp_coeff_2[19] = 0x75477;
+		gp_coeff_2[20] = 0x57547;
+		gp_coeff_2[21] = 0xdc747;
+		gp_coeff_2[22] = 0x74777;
+		gp_coeff_2[23] = 0x75757;
+		gp_coeff_2[24] = 0x4cc75;
+		gp_coeff_2[25] = 0xd4747;
+		gp_coeff_2[26] = 0x7d7d7;
+		gp_coeff_2[27] = 0xd5577;
+		gp_coeff_2[28] = 0xc4c75;
+		gp_coeff_2[29] = 0xcc477;
+		gp_coeff_2[30] = 0xdd54c;
+		gp_coeff_2[31] = 0x7547d;
+		gp_coeff_2[32] = 0x55547;
+		gp_coeff_2[33] = 0x5575c;
+		gp_coeff_2[34] = 0xd543a;
+		gp_coeff_2[35] = 0x57b3a;
+		gp_coeff_2[36] = 0x77777;
+		gp_cv_g1 = 0x2b062d;
+		gp_cv_g2 = 0x40fa2d;
+	} else if ((Broadcast_Standard ==
+	AML_ATV_DEMOD_VIDEO_MODE_PROP_PAL_BG) ||
+	(Broadcast_Standard == AML_ATV_DEMOD_VIDEO_MODE_PROP_SECAM_DK2) ||
+	(Broadcast_Standard == AML_ATV_DEMOD_VIDEO_MODE_PROP_SECAM_DK3) ||
+	(Broadcast_Standard == AML_ATV_DEMOD_VIDEO_MODE_PROP_PAL_BG_NICAM)) {
+		gp_coeff_1[0] = 0x75777;
+		gp_coeff_1[1] = 0x57777;
+		gp_coeff_1[2] = 0x7d777;
+		gp_coeff_1[3] = 0x75777;
+		gp_coeff_1[4] = 0x75777;
+		gp_coeff_1[5] = 0x7c777;
+		gp_coeff_1[6] = 0x47777;
+		gp_coeff_1[7] = 0x74777;
+		gp_coeff_1[8] = 0xd5d77;
+		gp_coeff_1[9] = 0xc7777;
+		gp_coeff_1[10] = 0x77577;
+		gp_coeff_1[11] = 0xd7d77;
+		gp_coeff_1[12] = 0x75d77;
+		gp_coeff_1[13] = 0xdd477;
+		gp_coeff_1[14] = 0x77d77;
+		gp_coeff_1[15] = 0x75c77;
+		gp_coeff_1[16] = 0xc4477;
+		gp_coeff_1[17] = 0x4c777;
+		gp_coeff_1[18] = 0x5d5d7;
+		gp_coeff_1[19] = 0xd7d57;
+		gp_coeff_1[20] = 0x47577;
+		gp_coeff_1[21] = 0xd7dd7;
+		gp_coeff_1[22] = 0xd7d57;
+		gp_coeff_1[23] = 0xdd757;
+		gp_coeff_1[24] = 0xc75c7;
+		gp_coeff_1[25] = 0x7d477;
+		gp_coeff_1[26] = 0x5d747;
+		gp_coeff_1[27] = 0x7ddc7;
+		gp_coeff_1[28] = 0xc4c77;
+		gp_coeff_1[29] = 0xd4c75;
+		gp_coeff_1[30] = 0xc755d;
+		gp_coeff_1[31] = 0x47cc7;
+		gp_coeff_1[32] = 0xdd7d4;
+		gp_coeff_1[33] = 0x4c75d;
+		gp_coeff_1[34] = 0xc7dcc;
+		gp_coeff_1[35] = 0xd52a2;
+		gp_coeff_1[36] = 0x555a1;
+		gp_coeff_2[0] = 0x5d777;
+		gp_coeff_2[1] = 0x47777;
+		gp_coeff_2[2] = 0x7d777;
+		gp_coeff_2[3] = 0xcc777;
+		gp_coeff_2[4] = 0xd7777;
+		gp_coeff_2[5] = 0x7c777;
+		gp_coeff_2[6] = 0x7dd77;
+		gp_coeff_2[7] = 0xdd777;
+		gp_coeff_2[8] = 0x7c777;
+		gp_coeff_2[9] = 0x57c77;
+		gp_coeff_2[10] = 0x7c777;
+		gp_coeff_2[11] = 0xd5777;
+		gp_coeff_2[12] = 0xd7c77;
+		gp_coeff_2[13] = 0xdd777;
+		gp_coeff_2[14] = 0x77477;
+		gp_coeff_2[15] = 0xc7d77;
+		gp_coeff_2[16] = 0xc4777;
+		gp_coeff_2[17] = 0x57557;
+		gp_coeff_2[18] = 0xd5577;
+		gp_coeff_2[19] = 0xd5577;
+		gp_coeff_2[20] = 0x7d547;
+		gp_coeff_2[21] = 0x74757;
+		gp_coeff_2[22] = 0xc7577;
+		gp_coeff_2[23] = 0xcc7d5;
+		gp_coeff_2[24] = 0x4c747;
+		gp_coeff_2[25] = 0xddc77;
+		gp_coeff_2[26] = 0x54447;
+		gp_coeff_2[27] = 0xcc447;
+		gp_coeff_2[28] = 0x5755d;
+		gp_coeff_2[29] = 0x5dd57;
+		gp_coeff_2[30] = 0x54747;
+		gp_coeff_2[31] = 0x5747c;
+		gp_coeff_2[32] = 0xc77dd;
+		gp_coeff_2[33] = 0x47557;
+		gp_coeff_2[34] = 0x7a22a;
+		gp_coeff_2[35] = 0xc73aa;
+		gp_coeff_2[36] = 0x77777;
+		gp_cv_g1 = 0x2b2834;
+		gp_cv_g2 = 0x3f6c2e;
+	} else if ((Broadcast_Standard ==
+	AML_ATV_DEMOD_VIDEO_MODE_PROP_PAL_DK) ||
+	(Broadcast_Standard == AML_ATV_DEMOD_VIDEO_MODE_PROP_SECAM_DK3)) {
+		gp_coeff_1[0] = 0x47777;
+		gp_coeff_1[1] = 0x77777;
+		gp_coeff_1[2] = 0x5d777;
+		gp_coeff_1[3] = 0x47777;
+		gp_coeff_1[4] = 0x75777;
+		gp_coeff_1[5] = 0x5c777;
+		gp_coeff_1[6] = 0x57777;
+		gp_coeff_1[7] = 0x44777;
+		gp_coeff_1[8] = 0x55d77;
+		gp_coeff_1[9] = 0x7d777;
+		gp_coeff_1[10] = 0x55577;
+		gp_coeff_1[11] = 0xd5d77;
+		gp_coeff_1[12] = 0xd7d77;
+		gp_coeff_1[13] = 0x47477;
+		gp_coeff_1[14] = 0xdc777;
+		gp_coeff_1[15] = 0x4cc77;
+		gp_coeff_1[16] = 0x77d57;
+		gp_coeff_1[17] = 0xc4777;
+		gp_coeff_1[18] = 0xdd7d7;
+		gp_coeff_1[19] = 0x7c757;
+		gp_coeff_1[20] = 0xd4477;
+		gp_coeff_1[21] = 0x755c7;
+		gp_coeff_1[22] = 0x47d57;
+		gp_coeff_1[23] = 0xd7c47;
+		gp_coeff_1[24] = 0xd4cc7;
+		gp_coeff_1[25] = 0x47577;
+		gp_coeff_1[26] = 0x5c7d5;
+		gp_coeff_1[27] = 0x4c75d;
+		gp_coeff_1[28] = 0xd57d7;
+		gp_coeff_1[29] = 0x44755;
+		gp_coeff_1[30] = 0x7557d;
+		gp_coeff_1[31] = 0xc477d;
+		gp_coeff_1[32] = 0xd5d44;
+		gp_coeff_1[33] = 0xdd77d;
+		gp_coeff_1[34] = 0x5d75b;
+		gp_coeff_1[35] = 0x74332;
+		gp_coeff_1[36] = 0xd4311;
+		gp_coeff_2[0] = 0xd7777;
+		gp_coeff_2[1] = 0x77777;
+		gp_coeff_2[2] = 0xdd777;
+		gp_coeff_2[3] = 0xdc777;
+		gp_coeff_2[4] = 0xc7777;
+		gp_coeff_2[5] = 0xdd777;
+		gp_coeff_2[6] = 0x77d77;
+		gp_coeff_2[7] = 0x77777;
+		gp_coeff_2[8] = 0x55777;
+		gp_coeff_2[9] = 0xc7d77;
+		gp_coeff_2[10] = 0xd4777;
+		gp_coeff_2[11] = 0xc7477;
+		gp_coeff_2[12] = 0x7c777;
+		gp_coeff_2[13] = 0xd5577;
+		gp_coeff_2[14] = 0xdd557;
+		gp_coeff_2[15] = 0x47577;
+		gp_coeff_2[16] = 0xd7477;
+		gp_coeff_2[17] = 0x55747;
+		gp_coeff_2[18] = 0xdd757;
+		gp_coeff_2[19] = 0xd7477;
+		gp_coeff_2[20] = 0x7d7d5;
+		gp_coeff_2[21] = 0xddd47;
+		gp_coeff_2[22] = 0xdd777;
+		gp_coeff_2[23] = 0x575d5;
+		gp_coeff_2[24] = 0x47547;
+		gp_coeff_2[25] = 0x555c7;
+		gp_coeff_2[26] = 0x7d447;
+		gp_coeff_2[27] = 0xd7447;
+		gp_coeff_2[28] = 0x757dd;
+		gp_coeff_2[29] = 0x7dc77;
+		gp_coeff_2[30] = 0x54747;
+		gp_coeff_2[31] = 0xc743b;
+		gp_coeff_2[32] = 0xd7c7c;
+		gp_coeff_2[33] = 0xd7557;
+		gp_coeff_2[34] = 0x55c7a;
+		gp_coeff_2[35] = 0x4cc29;
+		gp_coeff_2[36] = 0x77777;
+		gp_cv_g1 = 0x20682b;
+		gp_cv_g2 = 0x29322f;
+	} else if (Broadcast_Standard == AML_ATV_DEMOD_VIDEO_MODE_PROP_PAL_I) {
+		gp_coeff_1[0] = 0x77777;
+		gp_coeff_1[1] = 0x75777;
+		gp_coeff_1[2] = 0x7d777;
+		gp_coeff_1[3] = 0xd7777;
+		gp_coeff_1[4] = 0x74777;
+		gp_coeff_1[5] = 0xcc777;
+		gp_coeff_1[6] = 0x57777;
+		gp_coeff_1[7] = 0x5d577;
+		gp_coeff_1[8] = 0x5dd77;
+		gp_coeff_1[9] = 0x74777;
+		gp_coeff_1[10] = 0x77577;
+		gp_coeff_1[11] = 0x77c77;
+		gp_coeff_1[12] = 0xdc477;
+		gp_coeff_1[13] = 0x5d577;
+		gp_coeff_1[14] = 0x575d7;
+		gp_coeff_1[15] = 0xc7d57;
+		gp_coeff_1[16] = 0x77777;
+		gp_coeff_1[17] = 0x557d7;
+		gp_coeff_1[18] = 0xc7557;
+		gp_coeff_1[19] = 0x75c77;
+		gp_coeff_1[20] = 0x477d7;
+		gp_coeff_1[21] = 0xcc747;
+		gp_coeff_1[22] = 0x47dd7;
+		gp_coeff_1[23] = 0x775d7;
+		gp_coeff_1[24] = 0x47447;
+		gp_coeff_1[25] = 0x75cc7;
+		gp_coeff_1[26] = 0xc7777;
+		gp_coeff_1[27] = 0xc75d5;
+		gp_coeff_1[28] = 0x44c7d;
+		gp_coeff_1[29] = 0x74c47;
+		gp_coeff_1[30] = 0x47d75;
+		gp_coeff_1[31] = 0x7d57c;
+		gp_coeff_1[32] = 0xd5dc4;
+		gp_coeff_1[33] = 0xdd575;
+		gp_coeff_1[34] = 0xdb3bb;
+		gp_coeff_1[35] = 0x5c752;
+		gp_coeff_1[36] = 0x90880;
+		gp_coeff_2[0] = 0x5d777;
+		gp_coeff_2[1] = 0xd7777;
+		gp_coeff_2[2] = 0x77777;
+		gp_coeff_2[3] = 0xd5d77;
+		gp_coeff_2[4] = 0xc7777;
+		gp_coeff_2[5] = 0xd7777;
+		gp_coeff_2[6] = 0xddd77;
+		gp_coeff_2[7] = 0x55777;
+		gp_coeff_2[8] = 0x57777;
+		gp_coeff_2[9] = 0x54c77;
+		gp_coeff_2[10] = 0x4c477;
+		gp_coeff_2[11] = 0x74777;
+		gp_coeff_2[12] = 0xd5d77;
+		gp_coeff_2[13] = 0x47757;
+		gp_coeff_2[14] = 0x75577;
+		gp_coeff_2[15] = 0xc7577;
+		gp_coeff_2[16] = 0x4c747;
+		gp_coeff_2[17] = 0x7d477;
+		gp_coeff_2[18] = 0x7c757;
+		gp_coeff_2[19] = 0x55dd5;
+		gp_coeff_2[20] = 0x57577;
+		gp_coeff_2[21] = 0x44c47;
+		gp_coeff_2[22] = 0x5cc75;
+		gp_coeff_2[23] = 0x4cc77;
+		gp_coeff_2[24] = 0x47547;
+		gp_coeff_2[25] = 0x777d5;
+		gp_coeff_2[26] = 0xcccc7;
+		gp_coeff_2[27] = 0x57447;
+		gp_coeff_2[28] = 0xdc757;
+		gp_coeff_2[29] = 0x5755c;
+		gp_coeff_2[30] = 0x44747;
+		gp_coeff_2[31] = 0x5d5dd;
+		gp_coeff_2[32] = 0x5747b;
+		gp_coeff_2[33] = 0x77557;
+		gp_coeff_2[34] = 0xdcb2a;
+		gp_coeff_2[35] = 0xd5779;
+		gp_coeff_2[36] = 0x77777;
+		gp_cv_g1 = 0x72242f;
+		gp_cv_g2 = 0x28822a;
+	}
+
+	if ((Broadcast_Standard == AML_ATV_DEMOD_VIDEO_MODE_PROP_NTSC)  ||
+		(Broadcast_Standard == AML_ATV_DEMOD_VIDEO_MODE_PROP_NTSC_J)) {
+		sif_co_mx = 0xb8;
+		sif_fi_mx = 0x0;
+		sif_ic_bw = 0x1;
+		sif_bb_bw = 0x1;
+		sif_deemp = 0x1;
+		sif_cfg_demod = (sound_format == 0) ? 0x0:0x2;
+		sif_fm_gain = 0x4;
+	} else if ((Broadcast_Standard == AML_ATV_DEMOD_VIDEO_MODE_PROP_PAL_BG)
+	|| (Broadcast_Standard == AML_ATV_DEMOD_VIDEO_MODE_PROP_NTSC_BG)) {
+		sif_co_mx = 0xa6;
+		sif_fi_mx = 0x10;
+		sif_ic_bw = 0x2;
+		sif_bb_bw = 0x0;
+		sif_deemp = 0x2;
+		sif_cfg_demod = (sound_format == 0) ? 0x0:0x2;
+		sif_fm_gain = 0x3;
+	} else if (Broadcast_Standard ==
+		AML_ATV_DEMOD_VIDEO_MODE_PROP_PAL_DK1) {
+		sif_co_mx = 154;
+		sif_fi_mx = 240;
+		sif_ic_bw = 2;
+		sif_bb_bw = 0;
+		sif_deemp = 2;
+		sif_cfg_demod = (sound_format == 0) ? 0:2;
+		sif_fm_gain = 3;
+	} else if (Broadcast_Standard ==
+		AML_ATV_DEMOD_VIDEO_MODE_PROP_SECAM_DK2) {
+		sif_co_mx = 150;
+		sif_fi_mx = 16;
+		sif_ic_bw = 2;
+		sif_bb_bw = 0;
+		sif_deemp = 2;
+		sif_cfg_demod = (sound_format == 0) ? 0:2;
+		sif_fm_gain = 3;
+	} else if (Broadcast_Standard ==
+		AML_ATV_DEMOD_VIDEO_MODE_PROP_SECAM_DK3) {
+		sif_co_mx = 158;
+		sif_fi_mx = 208;
+		sif_ic_bw = 3;
+		sif_bb_bw = 0;
+		sif_deemp = 2;
+		sif_cfg_demod = (sound_format == 0) ? 0:2;
+		sif_fm_gain = 3;
+	} else if ((Broadcast_Standard == AML_ATV_DEMOD_VIDEO_MODE_PROP_PAL_I)
+	|| (Broadcast_Standard == AML_ATV_DEMOD_VIDEO_MODE_PROP_NTSC_I)) {
+		sif_co_mx = 153;
+		sif_fi_mx = 56;
+		sif_ic_bw = 3;
+		sif_bb_bw = 0;
+		sif_deemp = 2;
+		sif_cfg_demod = (sound_format == 0) ? 0:2;
+		sif_fm_gain = 3;
+	} else if (Broadcast_Standard ==
+		AML_ATV_DEMOD_VIDEO_MODE_PROP_PAL_BG_NICAM) {
+		sif_co_mx = 163;
+		sif_fi_mx = 40;
+		sif_ic_bw = 0;
+		sif_bb_bw = 0;
+		sif_deemp = 2;
+		sif_cfg_demod = (sound_format == 0) ? 0:2;
+		sif_fm_gain = 3;
+	} else if (Broadcast_Standard ==
+		AML_ATV_DEMOD_VIDEO_MODE_PROP_SECAM_L) {
+		sif_co_mx = 159;
+		sif_fi_mx = 200;
+		sif_ic_bw = 3;
+		sif_bb_bw = 0;
+		sif_deemp = 0;
+		sif_cfg_demod = (sound_format == 0) ? 1:2;
+		sif_fm_gain = 5;
+	} else if ((Broadcast_Standard == AML_ATV_DEMOD_VIDEO_MODE_PROP_PAL_DK)
+	|| (Broadcast_Standard == AML_ATV_DEMOD_VIDEO_MODE_PROP_NTSC_DK)) {
+		sif_co_mx = 159;
+		sif_fi_mx = 200;
+		sif_ic_bw = 3;
+		sif_bb_bw = 0;
+		sif_deemp = 2;
+		sif_cfg_demod = (sound_format == 0) ? 0:2;
+		sif_fm_gain = 3;
+	} else if (Broadcast_Standard == AML_ATV_DEMOD_VIDEO_MODE_PROP_PAL_M) {
+		sif_co_mx = 182;
+		sif_fi_mx = 16;
+		sif_ic_bw = 1;
+		sif_bb_bw = 0;
+		sif_deemp = 1;
+		sif_cfg_demod = (sound_format == 0) ? 0:2;
+		sif_fm_gain = 3;
+	}
+	sif_fm_gain -= 2;	/*avoid sound overflow@guanzhong*/
+	/*FE PATH*/
+	pr_info("ATV-DMD configure mixer\n");
+	if (Broadcast_Standard == AML_ATV_DEMOD_VIDEO_MODE_PROP_DTV) {
+		tmp_int = (Tuner_IF_Frequency/125000);
+		if (Tuner_Input_IF_inverted == 0x0)
+			mixer1 = -tmp_int;
+		else
+			mixer1 = tmp_int;
+
+		mixer3 = 0;
+		mixer3_bypass = 0;
+	} else {
+		tmp_int = (Tuner_IF_Frequency/125000);
+		pr_info("ATV-DMD configure mixer 1\n");
+
+		if (Tuner_Input_IF_inverted == 0x0)
+			mixer1 = 0xe8 - tmp_int;
+		else
+			mixer1 = tmp_int - 0x18;
+
+		pr_info("ATV-DMD configure mixer 2\n");
+		mixer3 = 0x30;
+		mixer3_bypass = 0x1;
+	}
+
+	pr_info("ATV-DMD configure mixer 3\n");
+	atv_dmd_wr_byte(APB_BLOCK_ADDR_MIXER_1, 0x0, mixer1);
+	atv_dmd_wr_word(APB_BLOCK_ADDR_MIXER_3, 0x0,
+			(((mixer3 & 0xff) << 8) | (mixer3_bypass & 0xff)));
+
+	if (Broadcast_Standard == AML_ATV_DEMOD_VIDEO_MODE_PROP_SECAM_L)
+		atv_dmd_wr_long(APB_BLOCK_ADDR_ADC_SE, 0x0, 0x03180e0f);
+	else
+		atv_dmd_wr_long(APB_BLOCK_ADDR_ADC_SE, 0x0, 0x03150e0f);
+	if (amlatvdemod_devp->parm.tuner_id == AM_TUNER_R840) {
+		/*config pwm for tuner r840*/
+		atv_dmd_wr_byte(APB_BLOCK_ADDR_ADC_SE, 1, 0xf);
+	}
+
+	/*GP Filter*/
+	pr_info("ATV-DMD configure GP_filter\n");
+	if (Broadcast_Standard == AML_ATV_DEMOD_VIDEO_MODE_PROP_DTV) {
+		cv = gp_cv_g1;
+		atv_dmd_wr_long(APB_BLOCK_ADDR_GP_VD_FLT, 0x0,
+				(0x08000000 | (cv & 0x7fffff)));
+		atv_dmd_wr_byte(APB_BLOCK_ADDR_GP_VD_FLT, 0x4, 0x04);
+		for (i = 0; i < 9; i = i + 1) {
+			/*super_coef = {gp_coeff_1[i*4],gp_coeff_1[i*4+1],
+			 *gp_coeff_1[i*4+2],gp_coeff_1[i*4+3]};
+			 */
+			super_coef0 =
+			    (((gp_coeff_1[i * 4 + 2] & 0xfff) << 20) |
+			     (gp_coeff_1[i * 4 + 3] & 0xfffff));
+			super_coef1 =
+			    (((gp_coeff_1[i * 4] & 0xf) << 28) |
+			     ((gp_coeff_1[i * 4 + 1] & 0xfffff) << 8) |
+			     ((gp_coeff_1[i * 4 + 2] >> 12) & 0xff));
+			super_coef2 = ((gp_coeff_1[i * 4] >> 4) & 0xffff);
+
+			/*atv_dmd_wr_long(APB_BLOCK_ADDR_GP_VD_FLT,
+			 *0x8,super_coef[79:48]);
+			 */
+			/*atv_dmd_wr_long(APB_BLOCK_ADDR_GP_VD_FLT,
+			 *0xC,super_coef[47:16]);
+			 */
+			/*atv_dmd_wr_word(APB_BLOCK_ADDR_GP_VD_FLT,
+			 *0x10,super_coef[15:0]);
+			 */
+			atv_dmd_wr_long(APB_BLOCK_ADDR_GP_VD_FLT, 0x8,
+					(((super_coef2 & 0xffff) << 16) |
+					 ((super_coef1 & 0xffff0000) >> 16)));
+			atv_dmd_wr_long(APB_BLOCK_ADDR_GP_VD_FLT, 0xC,
+					(((super_coef1 & 0xffff) << 16) |
+					 ((super_coef0 & 0xffff0000) >> 16)));
+			atv_dmd_wr_word(APB_BLOCK_ADDR_GP_VD_FLT, 0x10,
+					(super_coef0 & 0xffff));
+			atv_dmd_wr_byte(APB_BLOCK_ADDR_GP_VD_FLT, 0x05, i);
+		}
+		/*atv_dmd_wr_long
+		 *(APB_BLOCK_ADDR_GP_VD_FLT,0x8,{gp_coeff_1[36],12'd0});
+		 */
+		atv_dmd_wr_long(APB_BLOCK_ADDR_GP_VD_FLT, 0x8,
+				((gp_coeff_1[36] & 0xfffff) << 12));
+		atv_dmd_wr_byte(APB_BLOCK_ADDR_GP_VD_FLT, 0x05, 0x09);
+
+	} else {
+		cv = gp_cv_g1 - gp_cv_g2;
+		atv_dmd_wr_long(APB_BLOCK_ADDR_GP_VD_FLT, 0x0, cv & 0x7fffff);
+		atv_dmd_wr_byte(APB_BLOCK_ADDR_GP_VD_FLT, 0x4, 0x00);
+		for (i = 0; i < 9; i = i + 1) {
+			/*super_coef = {gp_coeff_1[i*4],gp_coeff_1[i*4+1],
+			 *gp_coeff_1[i*4+2],gp_coeff_1[i*4+3]};
+			 */
+			super_coef0 =
+			    (((gp_coeff_1[i * 4 + 2] & 0xfff) << 20) |
+			     (gp_coeff_1[i * 4 + 3] & 0xfffff));
+			super_coef1 =
+			    (((gp_coeff_1[i * 4] & 0xf) << 28) |
+			     ((gp_coeff_1[i * 4 + 1] & 0xfffff) << 8) |
+			     ((gp_coeff_1[i * 4 + 2] >> 12) & 0xff));
+			super_coef2 = ((gp_coeff_1[i * 4] >> 4) & 0xffff);
+
+			/*atv_dmd_wr_long(APB_BLOCK_ADDR_GP_VD_FLT,
+			 *0x8,super_coef[79:48]);
+			 */
+			/*atv_dmd_wr_long(APB_BLOCK_ADDR_GP_VD_FLT,
+			 *0xC,super_coef[47:16]);
+			 */
+			/*atv_dmd_wr_word(APB_BLOCK_ADDR_GP_VD_FLT,
+			 *0x10,super_coef[15:0]);
+			 */
+			atv_dmd_wr_long(APB_BLOCK_ADDR_GP_VD_FLT, 0x8,
+					(((super_coef2 & 0xffff) << 16) |
+					 ((super_coef1 & 0xffff0000) >> 16)));
+			atv_dmd_wr_long(APB_BLOCK_ADDR_GP_VD_FLT, 0xC,
+					(((super_coef1 & 0xffff) << 16) |
+					 ((super_coef0 & 0xffff0000) >> 16)));
+			atv_dmd_wr_word(APB_BLOCK_ADDR_GP_VD_FLT, 0x10,
+					(super_coef0 & 0xffff));
+			atv_dmd_wr_byte(APB_BLOCK_ADDR_GP_VD_FLT, 0x05, i);
+
+			/*atv_dmd_wr_long(APB_BLOCK_ADDR_GP_VD_FLT,
+			 *0x8,{gp_coeff_1[36],12'd0});
+			 */
+		}
+		atv_dmd_wr_long(APB_BLOCK_ADDR_GP_VD_FLT, 0x8,
+				((gp_coeff_1[36] & 0xfffff) << 12));
+		atv_dmd_wr_byte(APB_BLOCK_ADDR_GP_VD_FLT, 0x05, 9);
+		atv_dmd_wr_byte(APB_BLOCK_ADDR_GP_VD_FLT, 0x4, 0x01);
+
+		for (i = 0; i < 9; i = i + 1) {
+			/*super_coef = {gp_coeff_2[i*4],gp_coeff_2[i*4+1],
+			 *gp_coeff_2[i*4+2],gp_coeff_2[i*4+3]};
+			 */
+			super_coef0 =
+			    (((gp_coeff_2[i * 4 + 2] & 0xfff) << 20) |
+			     (gp_coeff_2[i * 4 + 3] & 0xfffff));
+			super_coef1 =
+			    (((gp_coeff_2[i * 4] & 0xf) << 28) |
+			     ((gp_coeff_2[i * 4 + 1] & 0xfffff) << 8) |
+			     ((gp_coeff_2[i * 4 + 2] >> 12) & 0xff));
+			super_coef2 = ((gp_coeff_2[i * 4] >> 4) & 0xffff);
+
+			atv_dmd_wr_long(APB_BLOCK_ADDR_GP_VD_FLT, 0x8,
+					(((super_coef2 & 0xffff) << 16) |
+					 ((super_coef1 & 0xffff0000) >> 16)));
+			atv_dmd_wr_long(APB_BLOCK_ADDR_GP_VD_FLT, 0xC,
+					(((super_coef1 & 0xffff) << 16) |
+					 ((super_coef0 & 0xffff0000) >> 16)));
+			atv_dmd_wr_word(APB_BLOCK_ADDR_GP_VD_FLT, 0x10,
+					(super_coef0 & 0xffff));
+			atv_dmd_wr_byte(APB_BLOCK_ADDR_GP_VD_FLT, 0x05, i);
+		}
+
+		atv_dmd_wr_long(APB_BLOCK_ADDR_GP_VD_FLT, 0x8,
+				((gp_coeff_2[36] & 0xfffff) << 12));
+		atv_dmd_wr_byte(APB_BLOCK_ADDR_GP_VD_FLT, 0x05, 0x09);
+	}
+
+	/*CRVY*/
+	pr_info("ATV-DMD configure CRVY\n");
+	if (Broadcast_Standard == AML_ATV_DEMOD_VIDEO_MODE_PROP_DTV) {
+		crvy_reg_1 = 0xFF;
+		crvy_reg_2 = 0x00;
+	} else {
+		crvy_reg_1 = 0x04;
+		crvy_reg_2 = 0x01;
+	}
+
+	atv_dmd_wr_byte(APB_BLOCK_ADDR_CARR_RCVY, 0x29, crvy_reg_1);
+	pr_info("ATV-DMD configure rcvy 2\n");
+	pr_info("ATV-DMD configure rcvy, crvy_reg_2 = %x\n", crvy_reg_2);
+	atv_dmd_wr_byte(APB_BLOCK_ADDR_CARR_RCVY, 0x20, crvy_reg_2);
+
+	/*SOUND SUPPRESS*/
+	pr_info("ATV-DMD configure sound suppress\n");
+
+	if ((Broadcast_Standard == AML_ATV_DEMOD_VIDEO_MODE_PROP_DTV) ||
+		(sound_format == 0))
+		atv_dmd_wr_byte(APB_BLOCK_ADDR_SIF_VD_IF, 0x02, 0x01);
+	else
+		atv_dmd_wr_byte(APB_BLOCK_ADDR_SIF_VD_IF, 0x02, 0x00);
+
+	/*SIF*/
+	pr_info("ATV-DMD configure sif\n");
+	if (!(Broadcast_Standard == AML_ATV_DEMOD_VIDEO_MODE_PROP_DTV)) {
+		atv_dmd_wr_byte(APB_BLOCK_ADDR_SIF_IC_STD, 0x03, sif_ic_bw);
+		atv_dmd_wr_byte(APB_BLOCK_ADDR_SIF_IC_STD, 0x01, sif_fi_mx);
+		atv_dmd_wr_byte(APB_BLOCK_ADDR_SIF_IC_STD, 0x02, sif_co_mx);
+
+		atv_dmd_wr_long(APB_BLOCK_ADDR_SIF_STG_2, 0x00,
+				(((sif_bb_bw & 0xff) << 24) |
+				 ((sif_deemp & 0xff) << 16) | 0x0500 |
+				 sif_fm_gain));
+		atv_dmd_wr_byte(APB_BLOCK_ADDR_SIF_STG_2, 0x06, sif_cfg_demod);
+		atv_dmd_wr_long(APB_BLOCK_ADDR_SIF_STG_2, 0x24,
+				(((sif_bb_bw & 0xff) << 24) |
+				 0xfffff));
+		atv_dmd_wr_long(APB_BLOCK_ADDR_SIF_STG_2, 0x1c, 0x1f000);
+	}
+
+	if (Broadcast_Standard != AML_ATV_DEMOD_VIDEO_MODE_PROP_DTV) {
+		if (sound_format == 0) {
+			tmp_int = 0;
+			atv_dmd_wr_long(APB_BLOCK_ADDR_SIF_STG_3, 0x00,
+					(0x01000000 | (tmp_int & 0xffffff)));
+		} else {
+			tmp_int = (256 - sif_co_mx) << 13;
+			atv_dmd_wr_long(APB_BLOCK_ADDR_SIF_STG_3, 0x00,
+					(tmp_int & 0xffffff));
+		}
+	}
+
+	if (Broadcast_Standard == AML_ATV_DEMOD_VIDEO_MODE_PROP_DTV) {
+		atv_dmd_wr_long(APB_BLOCK_ADDR_IC_AGC, 0x00, 0x02040E0A);
+		atv_dmd_wr_word(APB_BLOCK_ADDR_IC_AGC, 0x04, 0x0F0D);
+	} else if (sound_format == 0)
+		atv_dmd_wr_byte(APB_BLOCK_ADDR_IC_AGC, 0x00, 0x04);
+	else if (Broadcast_Standard ==
+		AML_ATV_DEMOD_VIDEO_MODE_PROP_SECAM_L) {
+		atv_dmd_wr_long(APB_BLOCK_ADDR_IC_AGC, 0x00, 0x0003140A);
+		atv_dmd_wr_word(APB_BLOCK_ADDR_IC_AGC, 0x04, 0x1244);
+	} else {
+		atv_dmd_wr_long(APB_BLOCK_ADDR_IC_AGC, 0x00, 0x00040E0A);
+		atv_dmd_wr_word(APB_BLOCK_ADDR_IC_AGC, 0x04, 0x0D68);
+	}
+
+	/*VAGC*/
+	pr_info("ATV-DMD configure vagc\n");
+	atv_dmd_wr_long(APB_BLOCK_ADDR_VDAGC, 0x48, 0x9B6F2C00);
+	/*bw select mode*/
+	atv_dmd_wr_byte(APB_BLOCK_ADDR_VDAGC, 0x37, 0x1C);
+	/*disable prefilter*/
+
+	if (Broadcast_Standard == AML_ATV_DEMOD_VIDEO_MODE_PROP_SECAM_L) {
+		atv_dmd_wr_word(APB_BLOCK_ADDR_VDAGC, 0x44, 0x4450);
+		atv_dmd_wr_byte(APB_BLOCK_ADDR_VDAGC, 0x46, 0x44);
+		atv_dmd_wr_long(APB_BLOCK_ADDR_VDAGC, 0x4, 0x3E04FC);
+		atv_dmd_wr_word(APB_BLOCK_ADDR_VDAGC, 0x3C, 0x4848);
+		atv_dmd_wr_byte(APB_BLOCK_ADDR_VDAGC, 0x3E, 0x48);
+	} else {
+		atv_dmd_wr_word(APB_BLOCK_ADDR_VDAGC, 0x44, 0xB800);
+		atv_dmd_wr_byte(APB_BLOCK_ADDR_VDAGC, 0x46, 0x08);
+		atv_dmd_wr_long(APB_BLOCK_ADDR_VDAGC, 0x4, 0x3C04FC);
+		atv_dmd_wr_word(APB_BLOCK_ADDR_VDAGC, 0x3C, 0x1818);
+		atv_dmd_wr_byte(APB_BLOCK_ADDR_VDAGC, 0x3E, 0x10);
+	}
+
+	/*tmp_real = $itor(Hz_Freq)/0.23841858; //TODO*/
+	/*tmp_int = $rtoi(tmp_real); //TODO*/
+	/*tmp_int = Hz_Freq/0.23841858; //TODO*/
+	/*tmp_int_2 = ((unsigned long)15625)*10000/23841858;*/
+	/*tmp_int_2 = ((unsigned long)Hz_Freq)*10000/23841858;*/
+	atv_dmd_wr_word(APB_BLOCK_ADDR_VDAGC, 0x10,
+			(freq_hz_cvrt >> 8) & 0xffff);
+	atv_dmd_wr_byte(APB_BLOCK_ADDR_VDAGC, 0x12, (freq_hz_cvrt & 0xff));
+
+	/*OUTPUT STAGE*/
+	pr_info("ATV-DMD configure output stage\n");
+	if (Broadcast_Standard != AML_ATV_DEMOD_VIDEO_MODE_PROP_DTV) {
+		atv_dmd_wr_byte(APB_BLOCK_ADDR_DAC_UPS, 0x0, 0x00);
+		atv_dmd_wr_byte(APB_BLOCK_ADDR_DAC_UPS, 0x1, 0x40);
+		atv_dmd_wr_byte(APB_BLOCK_ADDR_DAC_UPS, 0x2, 0x40);
+		atv_dmd_wr_byte(APB_BLOCK_ADDR_DAC_UPS, 0x4, 0xFA);
+		atv_dmd_wr_byte(APB_BLOCK_ADDR_DAC_UPS, 0x5, 0xFA);
+	}
+
+	/*GDE FILTER*/
+	pr_info("ATV-DMD configure gde filter\n");
+	if (GDE_Curve == 0) {
+		gd_coeff[0] = 0x020;	/*12'sd32;*/
+		gd_coeff[1] = 0xf5f;	/*-12'sd161;*/
+		gd_coeff[2] = 0x1fe;	/*12'sd510;*/
+		gd_coeff[3] = 0xc0b;	/*-12'sd1013;*/
+		gd_coeff[4] = 0x536;	/*12'sd1334;*/
+		gd_coeff[5] = 0xb34;	/*-12'sd1228;*/
+		gd_bypass = 0x1;
+	} else if (GDE_Curve == 1) {
+		gd_coeff[0] = 0x8;	/*12'sd8;*/
+		gd_coeff[1] = 0xfd5;	/*-12'sd43;*/
+		gd_coeff[2] = 0x8d;	/*12'sd141;*/
+		gd_coeff[3] = 0xe69;	/*-12'sd407;*/
+		gd_coeff[4] = 0x1f1;	/*12'sd497;*/
+		gd_coeff[5] = 0xe7e;	/*-12'sd386;*/
+		gd_bypass = 0x1;
+	} else if (GDE_Curve == 2) {
+		gd_coeff[0] = 0x35;	/*12'sd53;*/
+		gd_coeff[1] = 0xf41;	/*-12'sd191;*/
+		gd_coeff[2] = 0x68;	/*12'sd104;*/
+		gd_coeff[3] = 0xea5;	/*-12'sd347;*/
+		gd_coeff[4] = 0x322;	/*12'sd802;*/
+		gd_coeff[5] = 0x1bb;	/*12'sd443;*/
+		gd_bypass = 0x1;
+	} else if (GDE_Curve == 3) {
+		gd_coeff[0] = 0xf;	/*12'sd15;*/
+		gd_coeff[1] = 0xfb5;	/*-12'sd75;*/
+		gd_coeff[2] = 0xcc;	/*12'sd204;*/
+		gd_coeff[3] = 0xe51;
+		gd_coeff[4] = 0x226;	/*12'sd550;*/
+		gd_coeff[5] = 0xd02;
+		gd_bypass = 0x1;
+	} else
+		gd_bypass = 0x0;
+
+	if (gd_bypass == 0x0)
+		atv_dmd_wr_byte(APB_BLOCK_ADDR_GDE_EQUAL, 0x0D, gd_bypass);
+	else {
+		for (i = 0; i < 6; i = i + 1)
+			atv_dmd_wr_word(APB_BLOCK_ADDR_GDE_EQUAL, i << 1,
+					gd_coeff[i]);
+		atv_dmd_wr_byte(APB_BLOCK_ADDR_GDE_EQUAL, 0x0C, 0x01);
+		atv_dmd_wr_byte(APB_BLOCK_ADDR_GDE_EQUAL, 0x0D, gd_bypass);
+	}
+
+	/*PWM*/
+	pr_info("ATV-DMD configure pwm\n");
+	atv_dmd_wr_long(APB_BLOCK_ADDR_AGC_PWM, 0x00, 0x1f40);	/*4KHz*/
+	atv_dmd_wr_long(APB_BLOCK_ADDR_AGC_PWM, 0x04, 0xc8);
+	/*26 dB dynamic range*/
+	atv_dmd_wr_byte(APB_BLOCK_ADDR_AGC_PWM, 0x09, 0xa);
+	if (amlatvdemod_devp->parm.tuner_id == AM_TUNER_R840) {
+		/*config pwm for tuner r840*/
+		atv_dmd_wr_long(APB_BLOCK_ADDR_AGC_PWM, 0, 0xc80);
+		/* guanzhong for Tuner AGC shock */
+		atv_dmd_wr_long(APB_BLOCK_ADDR_AGC_PWM, 0x08, 0x46180200);
+		/* atv_dmd_wr_byte(APB_BLOCK_ADDR_ADC_SE,1,0xf);//Kd = 0xf */
+	}
+}
+
+void retrieve_adc_power(int *adc_level)
+{
+	*adc_level = atv_dmd_rd_long(APB_BLOCK_ADDR_ADC_SE, 0x0c);
+	/*adc_level = adc_level/32768*100;*/
+	*adc_level = (*adc_level) * 100 / 32768;
+}
+
+void retrieve_vpll_carrier_lock(int *lock)
+{
+	unsigned int data;
+
+	data = atv_dmd_rd_byte(APB_BLOCK_ADDR_CARR_RCVY, 0x43);
+	*lock = (data & 0x1);
+}
+int retrieve_vpll_carrier_afc(void)
+{
+	int data_ret, pll_lock, field_lock, line_lock, line_lock_strong;
+	unsigned int data_h, data_l, data_exg = 0;
+
+	pll_lock = atv_dmd_rd_byte(APB_BLOCK_ADDR_CARR_RCVY, 0x43)&0x1;
+	field_lock = atv_dmd_rd_byte(APB_BLOCK_ADDR_VDAGC, 0x4f)&0x4;
+	line_lock = atv_dmd_rd_byte(APB_BLOCK_ADDR_VDAGC, 0x4f)&0x10;
+	line_lock_strong = atv_dmd_rd_byte(APB_BLOCK_ADDR_VDAGC, 0x4f)&0x8;
+	/* if((atv_dmd_rd_byte(APB_BLOCK_ADDR_CARR_RCVY,0x43)&0x1) == 1){ */
+	if ((pll_lock == 1) || (line_lock == 0x10)) {
+		/*if pll unlock, afc is invalid*/
+		data_ret = 0xffff;/* 500; */
+		return data_ret;
+	}
+	data_h = atv_dmd_rd_byte(APB_BLOCK_ADDR_CARR_RCVY, 0x40);
+	data_l = atv_dmd_rd_byte(APB_BLOCK_ADDR_CARR_RCVY, 0x41);
+	data_exg = ((data_h&0x7) << 8) | data_l;
+	if (data_h&0x8) {
+		data_ret = (((~data_exg)&0x7ff) - 1);
+		data_ret = data_ret*488*(-1)/1000;
+	} else {
+		data_ret = data_exg;
+		data_ret = data_ret*488/1000;
+	}
+	if ((abs(data_ret) < 50) && (line_lock_strong == 0x8) &&
+		(field_lock == 0x4)) {
+		data_ret = 100;
+		return data_ret;
+	}
+	return data_ret;
+}
+void set_pll_lpf(unsigned int lock)
+{
+	atv_dmd_wr_byte(APB_BLOCK_ADDR_CARR_RCVY, 0x24, lock);
+}
+
+void retrieve_frequency_offset(int *freq_offset)
+{
+	/*unsigned int data;
+	 *data = atv_dmd_rd_word(APB_BLOCK_ADDR_CARR_RCVY,0x40);
+	 **freq_offset = (int)data;
+	 */
+	unsigned int data_h, data_l, data_exg;
+	int data_ret;
+
+	data_h = atv_dmd_rd_byte(APB_BLOCK_ADDR_CARR_RCVY, 0x40);
+	data_l = atv_dmd_rd_byte(APB_BLOCK_ADDR_CARR_RCVY, 0x41);
+	data_exg = ((data_h&0x7)<<8) | data_l;
+	if (data_h&0x8) {
+		data_ret = (((~data_exg) & 0x7ff)  - 1);
+		data_ret = data_ret*(-1);
+		/* data_ret = data_ret*488*(-1) /1000; */
+	} else
+		data_ret = data_exg;/* data_ret = data_ret*488/100; */
+	*freq_offset = data_ret;
+}
+EXPORT_SYMBOL(retrieve_frequency_offset);
+void retrieve_video_lock(int *lock)
+{
+	unsigned int data, wlock, slock;
+
+	data = atv_dmd_rd_byte(APB_BLOCK_ADDR_VDAGC, 0x4f);
+	wlock = data & 0x10;
+	slock = data & 0x80;
+	*lock = wlock & slock;
+}
+
+void retrieve_fh_frequency(int *fh)
+{
+	unsigned long data1, data2;
+
+	data1 = atv_dmd_rd_word(APB_BLOCK_ADDR_VDAGC, 0x58);
+	data2 = atv_dmd_rd_long(APB_BLOCK_ADDR_VDAGC, 0x10);
+	data1 = data1 >> 11;
+	data2 = data2 >> 3;
+	*fh = data1 + data2;
+}
+/*tune mix to adapt afc*/
+void atvdemod_afc_tune(void)
+{
+	/* int adc_level,lock,freq_offset,fh; */
+	int freq_offset, lock, mix1_freq_cur, delta_mix1_freq;
+
+	/* retrieve_adc_power(&adc_level); */
+	/* pr_info("adc_level: 0x%x\n",adc_level); */
+	retrieve_vpll_carrier_lock(&lock);
+	mix1_freq_cur = atv_dmd_rd_byte(APB_BLOCK_ADDR_MIXER_1, 0x0);
+	delta_mix1_freq = abs(mix1_freq_cur - mix1_freq);
+	if ((lock&0x1) == 0)
+		pr_info("%s visual carrier lock:locked\n", __func__);
+	else
+		pr_info("%s visual carrier lock:unlocked\n", __func__);
+	/* set_pll_lpf(lock); */
+	retrieve_frequency_offset(&freq_offset);
+	freq_offset = freq_offset*488/1000;
+	/* pr_info("visual carrier offset:%d Hz\n",
+	 *freq_offset*48828125/100000);
+	 */
+	/* retrieve_video_lock(&lock); */
+	if ((lock&0x1) == 1) {
+		if (delta_mix1_freq == atvdemod_afc_range)
+			atv_dmd_wr_byte(APB_BLOCK_ADDR_MIXER_1, 0x0, mix1_freq);
+		else if ((freq_offset >= atvdemod_afc_offset) &&
+			(delta_mix1_freq < atvdemod_afc_range))
+			atv_dmd_wr_byte(APB_BLOCK_ADDR_MIXER_1, 0x0,
+				mix1_freq_cur-1);
+		else if ((freq_offset <= (-1)*atvdemod_afc_offset) &&
+			(delta_mix1_freq < atvdemod_afc_range-1))
+			atv_dmd_wr_byte(APB_BLOCK_ADDR_MIXER_1, 0x0,
+				mix1_freq_cur+1);
+		/* pr_info("video lock:locked\n"); */
+	}
+	/* retrieve_fh_frequency(&fh); */
+	/* pr_info("horizontal frequency:%d Hz\n",fh*190735/100000); */
+}
+static enum amlatvdemod_snr_level_e aml_atvdemod_get_snr_level(void)
+{
+	unsigned int snr_val, i, snr_d[8];
+	enum amlatvdemod_snr_level_e ret;
+	unsigned long fsnr;
+
+	snr_val = atv_dmd_rd_long(APB_BLOCK_ADDR_VDAGC, 0x50)>>8;
+	fsnr = snr_val;
+	for (i = 1; i < 8; i++) {
+		snr_d[i] = snr_d[i-1];
+		fsnr = fsnr + snr_d[i];
+	}
+	snr_d[0] = snr_val;
+	fsnr = fsnr >> 3;
+	if (fsnr < 316)
+		ret = high;
+	else if (fsnr < 31600)
+		ret = ok_plus;
+	else if (fsnr < 158000)
+		ret = ok_minus;
+	else if (fsnr < 700000)
+		ret = low;
+	else
+		ret = very_low;
+	return ret;
+}
+
+void atvdemod_monitor_serice(void)
+{
+	enum amlatvdemod_snr_level_e snr_level;
+	unsigned int vagc_bw_typ, vagc_bw_fast, vpll_kptrack, vpll_kitrack;
+	unsigned int agc_register, vfmat_reg, agc_pll_kptrack, agc_pll_kitrack;
+	/*1.get current snr*/
+	snr_level = aml_atvdemod_get_snr_level();
+	/*2.*/
+	if (snr_level > very_low) {
+		vagc_bw_typ = 0x1818;
+		vagc_bw_fast = (snr_level == low) ? 0x18:0x10;
+		vpll_kptrack = 0x05;
+		vpll_kitrack = 0x0c;
+		agc_pll_kptrack = 0x6;
+		agc_pll_kitrack = 0xc;
+	} else {
+		vagc_bw_typ = 0x6f6f;
+		vagc_bw_fast = 0x6f;
+		vpll_kptrack = 0x06;
+		vpll_kitrack = 0x0e;
+		agc_pll_kptrack = 0x8;
+		agc_pll_kitrack = 0xf;
+	}
+	atv_dmd_wr_word(APB_BLOCK_ADDR_VDAGC, 0x3c, vagc_bw_typ);
+	atv_dmd_wr_byte(APB_BLOCK_ADDR_VDAGC, 0x3e, vagc_bw_fast);
+	atv_dmd_wr_byte(APB_BLOCK_ADDR_CARR_RCVY, 0x23, vpll_kptrack);
+	atv_dmd_wr_byte(APB_BLOCK_ADDR_CARR_RCVY, 0x24, vpll_kitrack);
+	atv_dmd_wr_byte(APB_BLOCK_ADDR_VDAGC, 0x0c,
+		((atv_dmd_rd_byte(APB_BLOCK_ADDR_VDAGC, 0x0c) & 0xf0)|
+		agc_pll_kptrack));
+	atv_dmd_wr_byte(APB_BLOCK_ADDR_VDAGC, 0x0d,
+		((atv_dmd_rd_byte(APB_BLOCK_ADDR_VDAGC, 0x0d) & 0xf0)|
+		agc_pll_kitrack));
+	/*3.*/
+	agc_register = atv_dmd_rd_long(APB_BLOCK_ADDR_VDAGC, 0x28);
+	if (snr_level < low) {
+		agc_register = ((agc_register&0xff80fe03) | (25 << 16) |
+			(15 << 2));
+		atv_dmd_wr_long(APB_BLOCK_ADDR_VDAGC, 0x28, agc_register);
+	} else if (snr_level > low) {
+		agc_register = ((agc_register&0xff80fe03) | (38 << 16) |
+			(30 << 2));
+		atv_dmd_wr_long(APB_BLOCK_ADDR_VDAGC, 0x28, agc_register);
+	}
+	/*4.*/
+	if (snr_level < ok_minus)
+		atv_dmd_wr_byte(APB_BLOCK_ADDR_VDAGC, 0x47,
+			(atv_dmd_rd_byte(APB_BLOCK_ADDR_VDAGC, 0x47) & 0x7f));
+	else
+		atv_dmd_wr_byte(APB_BLOCK_ADDR_VDAGC, 0x47,
+			(atv_dmd_rd_byte(APB_BLOCK_ADDR_VDAGC, 0x47) | 0x80));
+	/*5.vformat*/
+	if (snr_level < ok_minus) {
+		if (atv_dmd_rd_byte(APB_BLOCK_ADDR_VFORMAT, 0xe) != 0xf)
+			atv_dmd_wr_byte(APB_BLOCK_ADDR_VFORMAT, 0xe, 0xf);
+	} else if (snr_level > ok_minus) {
+		vfmat_reg = atv_dmd_rd_word(APB_BLOCK_ADDR_VFORMAT, 0x16);
+		if ((vfmat_reg << 4) < 0xf000) {
+			if (atv_dmd_rd_byte(APB_BLOCK_ADDR_VFORMAT, 0xe) ==
+				0x0f)
+				atv_dmd_wr_byte(APB_BLOCK_ADDR_VFORMAT, 0xe,
+					0x6);
+			else
+				atv_dmd_wr_byte(APB_BLOCK_ADDR_VFORMAT, 0xe,
+					0x6);
+		}
+	} else {
+		if (atv_dmd_rd_byte(APB_BLOCK_ADDR_VFORMAT, 0xe) == 0x0f)
+			atv_dmd_wr_byte(APB_BLOCK_ADDR_VFORMAT, 0xe, 0xe);
+		else
+			atv_dmd_wr_byte(APB_BLOCK_ADDR_VFORMAT, 0xe, 0xe);
+	}
+}
+
+static int atvdemod_get_snr(struct dvb_frontend *fe)
+{
+	unsigned int snr_val = 0;
+	int ret = 0;
+
+	snr_val = atv_dmd_rd_long(APB_BLOCK_ADDR_VDAGC, 0x50) >> 8;
+	/* snr_val:900000~0xffffff,ret:5~15 */
+	if (snr_val > 900000)
+		ret = 15 - (snr_val - 900000)*10/(0xffffff - 900000);
+	/* snr_val:158000~900000,ret:15~30 */
+	else if (snr_val > 158000)
+		ret = 30 - (snr_val - 158000)*15/(900000 - 158000);
+	/* snr_val:31600~158000,ret:30~50 */
+	else if (snr_val > 31600)
+		ret = 50 - (snr_val - 31600)*20/(158000 - 31600);
+	/* snr_val:316~31600,ret:50~80 */
+	else if (snr_val > 316)
+		ret = 80 - (snr_val - 316)*30/(31600 - 316);
+	/* snr_val:0~316,ret:80~100 */
+	else
+		ret = 100 - (316 - snr_val)*20/316;
+	return ret;
+}
+
+void atvdemod_det_snr_serice(void)
+{
+	snr_val = atvdemod_get_snr(NULL);
+}
+
+void atvdemod_timer_handler(unsigned long arg)
+{
+	if (atvdemod_timer_en == 0)
+		return;
+	atvdemod_timer.expires = jiffies + ATVDEMOD_INTERVAL*10;/*100ms timer*/
+	add_timer(&atvdemod_timer);
+	if (atvdemod_afc_en)
+		atvdemod_afc_tune();
+	if (atvdemod_monitor_en)
+		atvdemod_monitor_serice();
+	if (audio_det_en)
+		aml_atvdemod_overmodule_det();
+	if (atvdemod_det_snr_en)
+		atvdemod_det_snr_serice();
+}
+
+int atvdemod_clk_init(void)
+{
+	/* clocks_set_hdtv (); */
+	/* 1.set system clock */
+#if 0 /* now set pll in tvafe_general.c */
+	if (is_meson_txl_cpu()) {
+		amlatvdemod_hiu_reg_write(HHI_VDAC_CNTL0, 0x6e0201);
+		amlatvdemod_hiu_reg_write(HHI_VDAC_CNTL1, 0x8);
+		/* for TXL(T962)  */
+		pr_err("%s in TXL\n", __func__);
+
+		/* W_HIU_REG(HHI_ADC_PLL_CNTL,  0x30c54260); */
+	#if 0
+		W_HIU_REG(HHI_ADC_PLL_CNTL,  0x30f14250);
+		W_HIU_REG(HHI_ADC_PLL_CNTL1, 0x22000442);
+		W_HIU_REG(HHI_ADC_PLL_CNTL2, 0x5ba00380);
+		W_HIU_REG(HHI_ADC_PLL_CNTL3, 0xac6a2114);
+		W_HIU_REG(HHI_ADC_PLL_CNTL4, 0x02953004);
+		W_HIU_REG(HHI_ADC_PLL_CNTL5, 0x00030a00);
+		W_HIU_REG(HHI_ADC_PLL_CNTL6, 0x00005000);
+		W_HIU_REG(HHI_ADC_PLL_CNTL3, 0x2c6a2114);
+	#else /* get from feijun 2015/07/19 */
+		W_HIU_REG(HHI_ADC_PLL_CNTL3, 0x4a6a2110);
+		W_HIU_REG(HHI_ADC_PLL_CNTL, 0x30f14250);
+		W_HIU_REG(HHI_ADC_PLL_CNTL1, 0x22000442);
+		/*0x5ba00380 from pll;0x5ba00384 clk
+		 *form crystal
+		 */
+		W_HIU_REG(HHI_ADC_PLL_CNTL2, 0x5ba00384);
+		W_HIU_REG(HHI_ADC_PLL_CNTL3, 0x4a6a2110);
+		W_HIU_REG(HHI_ADC_PLL_CNTL4, 0x02913004);
+		W_HIU_REG(HHI_ADC_PLL_CNTL5, 0x00034a00);
+		W_HIU_REG(HHI_ADC_PLL_CNTL6, 0x00005000);
+		W_HIU_REG(HHI_ADC_PLL_CNTL3, 0xca6a2110);
+		W_HIU_REG(HHI_ADC_PLL_CNTL3, 0x4a6a2110);
+	#endif
+		W_HIU_REG(HHI_DADC_CNTL,  0x00102038);
+		W_HIU_REG(HHI_DADC_CNTL2, 0x00000406);
+		W_HIU_REG(HHI_DADC_CNTL3, 0x00082183);
+
+	} else {
+		W_HIU_REG(HHI_ADC_PLL_CNTL3, 0xca2a2110);
+		W_HIU_REG(HHI_ADC_PLL_CNTL4, 0x2933800);
+		W_HIU_REG(HHI_ADC_PLL_CNTL, 0xe0644220);
+		W_HIU_REG(HHI_ADC_PLL_CNTL2, 0x34e0bf84);
+		W_HIU_REG(HHI_ADC_PLL_CNTL3, 0x4a2a2110);
+
+		W_HIU_REG(HHI_ATV_DMD_SYS_CLK_CNTL, 0x80);
+		/* TVFE reset */
+		W_HIU_BIT(RESET1_REGISTER, 1, 7, 1);
+	}
+#endif
+	W_HIU_REG(HHI_ATV_DMD_SYS_CLK_CNTL, 0x80);
+
+	/* read_version_register(); */
+
+	/*2.set atv demod top page control register*/
+	atv_dmd_input_clk_32m();
+	atv_dmd_wr_long(APB_BLOCK_ADDR_TOP, ATV_DMD_TOP_CTRL, 0x1037);
+	atv_dmd_wr_long(APB_BLOCK_ADDR_TOP, (ATV_DMD_TOP_CTRL1 << 2), 0x1f);
+
+	/*3.configure atv demod*/
+	check_communication_interface();
+	power_on_receiver();
+	pr_err("%s done\n", __func__);
+
+	return 0;
+}
+
+int atvdemod_init(void)
+{
+	/* unsigned long data32; */
+	if (atvdemod_timer_en == 1) {
+		if (timer_init_flag == 1) {
+			del_timer_sync(&atvdemod_timer);
+			timer_init_flag = 0;
+		}
+	}
+
+	/* 1.set system clock when atv enter*/
+
+	configure_receiver(broad_std, if_freq, if_inv, gde_curve, sound_format);
+	atv_dmd_misc();
+	/*4.software reset*/
+	atv_dmd_soft_reset();
+	atv_dmd_soft_reset();
+	atv_dmd_soft_reset();
+	atv_dmd_soft_reset();
+
+	/* ?????
+	 *while (!all_lock) {
+	 *	data32 = atv_dmd_rd_long(APB_BLOCK_ADDR_VDAGC,0x13<<2);
+	 *	if ((data32 & 0x1c) == 0x0) {
+	 *		all_lock = 1;
+	 *	}
+	 *	delay_us(400);
+	 *}
+	 */
+	#if 1/* temp mark */
+	if (atvdemod_timer_en == 1) {
+		/*atvdemod timer handler*/
+		init_timer(&atvdemod_timer);
+		/* atvdemod_timer.data = (ulong) devp; */
+		atvdemod_timer.function = atvdemod_timer_handler;
+		/* after 3s enable demod auto detect */
+		atvdemod_timer.expires = jiffies + ATVDEMOD_INTERVAL*300;
+		add_timer(&atvdemod_timer);
+		mix1_freq = atv_dmd_rd_byte(APB_BLOCK_ADDR_MIXER_1, 0x0);
+		timer_init_flag = 1;
+	}
+	#endif
+	pr_info("%s done\n", __func__);
+	return 0;
+}
+void atvdemod_uninit(void)
+{
+	/* del the timer */
+	if (atvdemod_timer_en == 1) {
+		if (timer_init_flag == 1) {
+			del_timer_sync(&atvdemod_timer);
+			timer_init_flag = 0;
+		}
+	}
+}
+
+void atv_dmd_set_std(void)
+{
+	v4l2_std_id ptstd = amlatvdemod_devp->parm.std;
+	/* set broad standard of tuner*/
+	if ((ptstd & V4L2_COLOR_STD_PAL) && ((ptstd & V4L2_STD_B) ||
+		(ptstd & V4L2_STD_G))) {
+		amlatvdemod_devp->fre_offset = 2250000;
+		freq_hz_cvrt = AML_ATV_DEMOD_FREQ_50HZ_VERT;
+		broad_std = AML_ATV_DEMOD_VIDEO_MODE_PROP_PAL_BG;
+		if_freq = 3250000;
+		gde_curve = 2;
+	} else if ((ptstd & V4L2_COLOR_STD_PAL) && (ptstd & V4L2_STD_DK)) {
+		amlatvdemod_devp->fre_offset = 2250000;
+		freq_hz_cvrt = AML_ATV_DEMOD_FREQ_50HZ_VERT;
+		if_freq = 3250000;
+		broad_std = AML_ATV_DEMOD_VIDEO_MODE_PROP_PAL_DK;
+		gde_curve = 3;
+	} else if ((ptstd & V4L2_COLOR_STD_PAL) && (ptstd & V4L2_STD_PAL_M)) {
+		amlatvdemod_devp->fre_offset = 2250000;
+		freq_hz_cvrt = AML_ATV_DEMOD_FREQ_60HZ_VERT;
+		broad_std = AML_ATV_DEMOD_VIDEO_MODE_PROP_PAL_M;
+		if_freq = 4250000;
+		gde_curve = 0;
+	} else if ((ptstd & V4L2_COLOR_STD_NTSC) && (ptstd & V4L2_STD_NTSC_M)) {
+		amlatvdemod_devp->fre_offset = 1750000;
+		freq_hz_cvrt = AML_ATV_DEMOD_FREQ_60HZ_VERT;
+		if_freq = 4250000;
+		broad_std = AML_ATV_DEMOD_VIDEO_MODE_PROP_NTSC;
+		gde_curve = 0;
+	} else if ((ptstd & V4L2_COLOR_STD_NTSC) && (ptstd & V4L2_STD_DK)) {
+		amlatvdemod_devp->fre_offset = 1750000;
+		freq_hz_cvrt = AML_ATV_DEMOD_FREQ_60HZ_VERT;
+		if_freq = 4250000;
+		broad_std = AML_ATV_DEMOD_VIDEO_MODE_PROP_NTSC_DK;
+		gde_curve = 0;
+	} else if ((ptstd & V4L2_COLOR_STD_NTSC) && (ptstd & V4L2_STD_BG)) {
+		amlatvdemod_devp->fre_offset = 1750000;
+		freq_hz_cvrt = AML_ATV_DEMOD_FREQ_60HZ_VERT;
+		if_freq = 4250000;
+		broad_std = AML_ATV_DEMOD_VIDEO_MODE_PROP_NTSC_BG;
+		gde_curve = 0;
+	} else if ((ptstd & V4L2_COLOR_STD_NTSC) && (ptstd & V4L2_STD_PAL_I)) {
+		amlatvdemod_devp->fre_offset = 1750000;
+		freq_hz_cvrt = AML_ATV_DEMOD_FREQ_60HZ_VERT;
+		if_freq = 4250000;
+		broad_std = AML_ATV_DEMOD_VIDEO_MODE_PROP_NTSC_I;
+		gde_curve = 0;
+	} else if ((ptstd & V4L2_COLOR_STD_NTSC) &&
+		(ptstd & V4L2_STD_NTSC_M_JP)) {
+		amlatvdemod_devp->fre_offset = 1750000;
+		freq_hz_cvrt = AML_ATV_DEMOD_FREQ_50HZ_VERT;
+		broad_std = AML_ATV_DEMOD_VIDEO_MODE_PROP_NTSC_J;
+		if_freq = 4250000;
+		gde_curve = 0;
+	} else if ((ptstd & V4L2_COLOR_STD_PAL) && (ptstd & V4L2_STD_PAL_I)) {
+		amlatvdemod_devp->fre_offset = 2750000;
+		freq_hz_cvrt = AML_ATV_DEMOD_FREQ_50HZ_VERT;
+		broad_std = AML_ATV_DEMOD_VIDEO_MODE_PROP_PAL_I;
+		if_freq = 3250000;
+		gde_curve = 4;
+	} else if (ptstd & (V4L2_STD_SECAM_L | V4L2_STD_SECAM_LC)) {
+		amlatvdemod_devp->fre_offset = 2750000;
+		freq_hz_cvrt = AML_ATV_DEMOD_FREQ_50HZ_VERT;
+		broad_std = AML_ATV_DEMOD_VIDEO_MODE_PROP_SECAM_L;
+		gde_curve = 4;
+	}
+	if (amlatvdemod_devp->parm.tuner_id == AM_TUNER_R840) {
+		if_freq = amlatvdemod_devp->parm.if_freq;
+		if_inv = amlatvdemod_devp->parm.if_inv;
+	} else if (amlatvdemod_devp->parm.tuner_id == AM_TUNER_MXL661) {
+		if_freq = amlatvdemod_devp->parm.if_freq;
+		if_inv = amlatvdemod_devp->parm.if_inv;
+	} else if (amlatvdemod_devp->parm.tuner_id == AM_TUNER_SI2151) {
+		if_freq = amlatvdemod_devp->parm.if_freq;
+		if_inv = amlatvdemod_devp->parm.if_inv;
+	}
+	pr_info
+	    ("[atvdemod..]%s: broad_std %d,freq_hz_cvrt:0x%x,fre_offset:%d.\n",
+	     __func__, broad_std, freq_hz_cvrt, amlatvdemod_devp->fre_offset);
+	if (atvdemod_init())
+		pr_info("[atvdemod..]%s: atv restart error.\n", __func__);
+}
+
+int aml_audiomode_autodet(struct dvb_frontend *fe)
+{
+	unsigned long carrier_power = 0;
+	unsigned long carrier_power_max = 0;
+	unsigned long carrier_power_average_max = 0;
+	unsigned long carrier_power_average[4] = {0};
+	unsigned long reg_addr = 0x03, temp_data;
+	int carrier_lock_count = 0;
+	int lock = 0;
+	int broad_std_final = 0;
+	int num = 0, i = 0, final_id = 0;
+	int delay_ms = 10, delay_ms_default = 10;
+	int cur_std = ID_PAL_DK;
+	struct dtv_frontend_properties
+		*p = fe != NULL ? &fe->dtv_property_cache:NULL;
+#if 0
+	temp_data = atv_dmd_rd_reg(APB_BLOCK_ADDR_SIF_STG_2, 0x02);
+	temp_data = temp_data | 0x80;/* 0x40 */
+	atv_dmd_wr_reg(APB_BLOCK_ADDR_SIF_STG_2, 0x02, temp_data);
+#endif
+
+	switch (broad_std) {
+	case AML_ATV_DEMOD_VIDEO_MODE_PROP_PAL_DK:
+	case AML_ATV_DEMOD_VIDEO_MODE_PROP_PAL_I:
+	case AML_ATV_DEMOD_VIDEO_MODE_PROP_PAL_BG:
+	case AML_ATV_DEMOD_VIDEO_MODE_PROP_PAL_M:
+		broad_std = AML_ATV_DEMOD_VIDEO_MODE_PROP_PAL_M;
+		break;
+	case AML_ATV_DEMOD_VIDEO_MODE_PROP_NTSC_DK:
+	case AML_ATV_DEMOD_VIDEO_MODE_PROP_NTSC_I:
+	case AML_ATV_DEMOD_VIDEO_MODE_PROP_NTSC_BG:
+	case AML_ATV_DEMOD_VIDEO_MODE_PROP_NTSC_M:
+	case AML_ATV_DEMOD_VIDEO_MODE_PROP_NTSC:
+
+		broad_std = AML_ATV_DEMOD_VIDEO_MODE_PROP_NTSC_M;
+		atvdemod_init();
+		temp_data = atv_dmd_rd_reg(APB_BLOCK_ADDR_SIF_STG_2, 0x02);
+		temp_data = temp_data & (~0x80); /* 0xbf; */
+		atv_dmd_wr_reg(APB_BLOCK_ADDR_SIF_STG_2, 0x02, temp_data);
+		/* pr_err("%s, SECAM ,audio set SECAM_L\n", __func__); */
+		return broad_std;
+
+	case AML_ATV_DEMOD_VIDEO_MODE_PROP_SECAM_L:
+	case AML_ATV_DEMOD_VIDEO_MODE_PROP_SECAM_DK2:
+	case AML_ATV_DEMOD_VIDEO_MODE_PROP_SECAM_DK3:
+		broad_std = AML_ATV_DEMOD_VIDEO_MODE_PROP_SECAM_L;
+		atvdemod_init();
+		temp_data = atv_dmd_rd_reg(APB_BLOCK_ADDR_SIF_STG_2, 0x02);
+
+		temp_data = temp_data & (~0x80); /* 0xbf; */
+
+		atv_dmd_wr_reg(APB_BLOCK_ADDR_SIF_STG_2, 0x02, temp_data);
+		/* pr_err("%s, SECAM ,audio set SECAM_L\n", __func__); */
+		return broad_std;
+	default:
+		pr_err("unsupport broadcast_standard!!!\n");
+		temp_data = atv_dmd_rd_reg(APB_BLOCK_ADDR_SIF_STG_2, 0x02);
+		temp_data = temp_data & (~0x80); /* 0xbf; */
+		atv_dmd_wr_reg(APB_BLOCK_ADDR_SIF_STG_2, 0x02, temp_data);
+		return broad_std;
+	}
+	/* ----------------read carrier_power--------------------- */
+	/* SIF_STG_2[0x09],address 0x03 */
+	while (1) {
+		if (num >= 4) {
+			temp_data =
+				atv_dmd_rd_reg(APB_BLOCK_ADDR_SIF_STG_2, 0x02);
+			temp_data = temp_data & (~0x80);
+			atv_dmd_wr_reg(APB_BLOCK_ADDR_SIF_STG_2, 0x02,
+					temp_data);
+			carrier_power_max = carrier_power_average[0];
+			for (i = 0; i < ID_MAX; i++) {
+				if (carrier_power_max
+					< carrier_power_average[i]) {
+					carrier_power_max =
+						carrier_power_average[i];
+					final_id = i;
+				}
+			}
+			switch (final_id) {
+			case ID_PAL_I:
+				broad_std_final =
+					AML_ATV_DEMOD_VIDEO_MODE_PROP_PAL_I;
+				break;
+			case ID_PAL_BG:
+				broad_std_final =
+					AML_ATV_DEMOD_VIDEO_MODE_PROP_PAL_BG;
+				break;
+			case ID_PAL_M:
+				broad_std_final =
+					AML_ATV_DEMOD_VIDEO_MODE_PROP_PAL_M;
+				break;
+			case ID_PAL_DK:
+				broad_std_final =
+					AML_ATV_DEMOD_VIDEO_MODE_PROP_PAL_DK;
+				break;
+			}
+			carrier_power_average_max = carrier_power_max;
+			broad_std = broad_std_final;
+			pr_err("%s:broad_std:%d,carrier_power_average_max:%lu\n",
+				__func__, broad_std, carrier_power_average_max);
+			if (carrier_power_average_max < 150)
+				pr_err("%s,carrier too low error\n", __func__);
+			if (broad_std == AML_ATV_DEMOD_VIDEO_MODE_PROP_PAL_M) {
+				/*the max except palm*/
+				carrier_power_average[final_id] = 0;
+				final_id = 0;
+				carrier_power_max = carrier_power_average[0];
+				for (i = 0; i < ID_MAX; i++) {
+					if (carrier_power_max
+						< carrier_power_average[i]) {
+						carrier_power_max =
+						carrier_power_average[i];
+						final_id = i;
+					}
+				}
+			switch (final_id) {
+			case ID_PAL_I:
+				broad_std_except_pal_m =
+					AML_ATV_DEMOD_VIDEO_MODE_PROP_PAL_I;
+				break;
+			case ID_PAL_BG:
+				broad_std_except_pal_m =
+					AML_ATV_DEMOD_VIDEO_MODE_PROP_PAL_BG;
+				break;
+			case ID_PAL_DK:
+				broad_std_except_pal_m =
+					AML_ATV_DEMOD_VIDEO_MODE_PROP_PAL_DK;
+				break;
+			}
+			}
+			if (p != NULL) {
+				p->analog.std = V4L2_COLOR_STD_PAL;
+				switch (broad_std) {
+				case AML_ATV_DEMOD_VIDEO_MODE_PROP_PAL_DK:
+					p->analog.std |= V4L2_STD_PAL_DK;
+					p->analog.audmode = V4L2_STD_PAL_DK;
+				break;
+				case AML_ATV_DEMOD_VIDEO_MODE_PROP_PAL_I:
+					p->analog.std |= V4L2_STD_PAL_I;
+					p->analog.audmode = V4L2_STD_PAL_I;
+				break;
+				case AML_ATV_DEMOD_VIDEO_MODE_PROP_PAL_BG:
+					p->analog.std |= V4L2_STD_PAL_BG;
+					p->analog.audmode = V4L2_STD_PAL_BG;
+				break;
+				case AML_ATV_DEMOD_VIDEO_MODE_PROP_PAL_M:
+					p->analog.std |= V4L2_STD_PAL_M;
+					p->analog.audmode = V4L2_STD_PAL_M;
+				break;
+				default:
+					p->analog.std |= V4L2_STD_PAL_DK;
+					p->analog.audmode = V4L2_STD_PAL_DK;
+				}
+				p->frequency += 1;
+				fe->ops.set_frontend(fe);
+			}
+			return broad_std;
+		}
+		switch (broad_std) {
+		case AML_ATV_DEMOD_VIDEO_MODE_PROP_PAL_DK:
+			broad_std = AML_ATV_DEMOD_VIDEO_MODE_PROP_PAL_I;
+			cur_std = ID_PAL_I;
+			if (p != NULL) {
+				p->analog.std =
+					V4L2_COLOR_STD_PAL | V4L2_STD_PAL_I;
+				p->frequency += 1;
+				p->analog.audmode = V4L2_STD_PAL_I;
+			}
+			delay_ms = delay_ms_default;
+			break;
+		case AML_ATV_DEMOD_VIDEO_MODE_PROP_PAL_I:
+			broad_std = AML_ATV_DEMOD_VIDEO_MODE_PROP_PAL_BG;
+			cur_std = ID_PAL_BG;
+			if (p != NULL) {
+				p->analog.std =
+					V4L2_COLOR_STD_PAL | V4L2_STD_PAL_BG;
+				p->frequency += 1;
+				p->analog.audmode = V4L2_STD_PAL_BG;
+			}
+			delay_ms = delay_ms_default;
+			break;
+		case AML_ATV_DEMOD_VIDEO_MODE_PROP_PAL_BG:
+			broad_std = AML_ATV_DEMOD_VIDEO_MODE_PROP_PAL_M;
+			cur_std = ID_PAL_M;
+			if (p != NULL) {
+				p->analog.std =
+					V4L2_COLOR_STD_PAL | V4L2_STD_PAL_M;
+				p->frequency += 1;
+				p->analog.audmode = V4L2_STD_PAL_M;
+			}
+			delay_ms = delay_ms_default;
+			break;
+		case AML_ATV_DEMOD_VIDEO_MODE_PROP_PAL_M:
+			broad_std = AML_ATV_DEMOD_VIDEO_MODE_PROP_PAL_DK;
+			cur_std = ID_PAL_DK;
+			if (p != NULL) {
+				p->analog.std =
+					V4L2_COLOR_STD_PAL | V4L2_STD_PAL_DK;
+				p->frequency += 1;
+				p->analog.audmode = V4L2_STD_PAL_DK;
+			}
+			delay_ms = delay_ms_default;
+			break;
+
+		default:
+			pr_err("unsupport broadcast_standard!!!\n");
+			break;
+		}
+		if (p != NULL)
+			fe->ops.set_frontend(fe);
+		/* atvdemod_init(); //set_frontend has already been called it */
+
+		/* enable audio detect function */
+		temp_data = atv_dmd_rd_reg(APB_BLOCK_ADDR_SIF_STG_2, 0x02);
+		temp_data = temp_data | 0x80;/* 0x40 */
+		atv_dmd_wr_reg(APB_BLOCK_ADDR_SIF_STG_2, 0x02, temp_data);
+
+		usleep_range(delay_ms*1000, delay_ms*1000+100);
+
+		carrier_lock_count = 0;
+		i = 4;
+		while (i--) {
+			retrieve_vpll_carrier_lock(&lock);
+			if (lock == 0)
+				break;
+			carrier_lock_count++;
+			if (carrier_lock_count >= 20) {
+				pr_err("%s step2, retrieve_vpll_carrier_lock failed\n",
+					__func__);
+			/* return broad_std; */
+			}
+			usleep_range(6000, 9000);
+		}
+		/* ----------------read carrier_power--------------------- */
+		for (i = 0; i < 100; i++) {
+			carrier_power =
+				atv_dmd_rd_reg(APB_BLOCK_ADDR_SIF_STG_2,
+					reg_addr);
+			carrier_power_max += carrier_power;
+		}
+		carrier_power = carrier_power_max/i;
+		carrier_power_max = 0;
+		pr_err("[amlatvdemod.. %d,std:%d ]%s: atvdemo audio carrier power report:%lu. @@@@@@@@@@\n",
+			num, broad_std, __func__, carrier_power);
+		carrier_power_average[cur_std] += carrier_power;
+		num++;
+	}
+
+	return broad_std;
+}
+
+void aml_audio_valume_gain_set(unsigned int audio_gain)
+{
+	unsigned long audio_gain_data, temp_data;
+
+	if (audio_gain > 0xfff) {
+		pr_err("Error: atv in gain max 7.998, min 0.002! gain = value/512\n");
+		pr_err("value (0~0xfff)\n");
+		return;
+	}
+	audio_gain_data = audio_gain & 0xfff;
+	temp_data = atv_dmd_rd_word(APB_BLOCK_ADDR_MONO_PROC, 0x52);
+	temp_data = (temp_data & 0xf000) | audio_gain_data;
+	atv_dmd_wr_word(APB_BLOCK_ADDR_MONO_PROC, 0x52, temp_data);
+}
+
+unsigned int aml_audio_valume_gain_get(void)
+{
+	unsigned long audio_gain_data;
+
+	audio_gain_data = atv_dmd_rd_word(APB_BLOCK_ADDR_MONO_PROC, 0x52);
+	audio_gain_data = audio_gain_data & 0xfff;
+	return audio_gain_data;
+}
+
+void aml_atvdemod_overmodule_det(void)
+{
+	unsigned long temp_data, temp_data2;/* , temp_data3 , temp_data4; */
+	unsigned long counter_report;
+	int  carrier_lock_count = 0;
+	int vlock = 0;
+
+	switch (audio_det_mode) {
+	case AUDIO_AUTO_DETECT:
+		aml_audiomode_autodet(NULL);
+		return;
+#if 0
+		while (1) {
+			retrieve_vpll_carrier_lock(&vlock);
+			if (vlock)
+				break;
+			carrier_lock_count++;
+			if (carrier_lock_count >= 1000)
+				return;
+	/* ------------whether need timer delays between the detect lock---- */
+		}
+	/* -----------------enable auto_adjust_en------------- */
+		temp_data = atv_dmd_rd_word(APB_BLOCK_ADDR_SIF_STG_2, 0x02);
+		temp_data = temp_data | 0x100;
+		/* set the bit 9 of the temp_data to 1 */
+		atv_dmd_wr_word(APB_BLOCK_ADDR_SIF_STG_2, 0x02, temp_data);
+	/* -----------------enable auto_adjust_en end----------------- */
+	/* -----------------begain to set ov_cnt_en enable------------- */
+		temp_data2 = atv_dmd_rd_word(APB_BLOCK_ADDR_SIF_STG_2, 0x02);
+		temp_data2 = temp_data2 | 0x80;
+		/* set the bit 8 of the temp_data to 1 */
+		atv_dmd_wr_word(APB_BLOCK_ADDR_SIF_STG_2, 0x02, temp_data2);
+	/* ------------------set ov_cnt_en enable end---------------- */
+		udelay(1000);/* timer delay needed , */
+	/* ------------------------------------------------------------ */
+		/* -----------------disable auto_adjust_en------------- */
+		temp_data3 = atv_dmd_rd_word(APB_BLOCK_ADDR_SIF_STG_2, 0x02);
+		temp_data3 = temp_data3 & 0xfeff;
+		/* set the bit 9 of the temp_data to 0 */
+		atv_dmd_wr_word(APB_BLOCK_ADDR_SIF_STG_2, 0x02, temp_data3);
+	/* -----------------disable auto_adjust_en end------------ */
+	/* -----------------begain to set ov_cnt_en disable------------- */
+		temp_data4 = atv_dmd_rd_word(APB_BLOCK_ADDR_SIF_STG_2, 0x02);
+		temp_data4 = temp_data4 & 0xff7f;
+		/* set the bit 8 of the temp_data to 0 */
+		atv_dmd_wr_word(APB_BLOCK_ADDR_SIF_STG_2, 0x02, temp_data4);
+		break;
+	/* ------------------set ov_cnt_en disable end------ */
+#endif
+	case AUDIO_MANUAL_DETECT:
+		while (1) {
+			retrieve_vpll_carrier_lock(&vlock);
+			if (vlock)
+				break;
+			carrier_lock_count++;
+			if (carrier_lock_count >= 1000)
+				return;
+		}
+
+		/* -----------------begain to set ov_cnt_en enable---- */
+		temp_data = atv_dmd_rd_word(APB_BLOCK_ADDR_SIF_STG_2, 0x02);
+		temp_data = temp_data | 0x80;
+		/* set the bit 8 of the temp_data to 1 */
+		atv_dmd_wr_word(APB_BLOCK_ADDR_SIF_STG_2, 0x02, temp_data);
+	/* ------------------set ov_cnt_en enable end--------------- */
+	/* -----------------disable auto_adjust_en------------- */
+		temp_data2 = atv_dmd_rd_word(APB_BLOCK_ADDR_SIF_STG_2, 0x02);
+		temp_data2 = temp_data2 & 0xfeff;
+		/* set the bit 9 of the temp_data to 0 */
+		atv_dmd_wr_word(APB_BLOCK_ADDR_SIF_STG_2, 0x02, temp_data2);
+	/* -----------------disable auto_adjust_en end------------ */
+			udelay(1000);/* timer delay needed , */
+	/* ------------------------------------------------------- */
+		counter_report =
+			atv_dmd_rd_word(APB_BLOCK_ADDR_SIF_STG_2, 0x04);
+
+		while (counter_report > over_threshold) {
+			unsigned long shift_gain, shift_gain_report;
+
+			temp_data2 = atv_dmd_rd_byte(
+				APB_BLOCK_ADDR_SIF_STG_2, 0x00);
+			shift_gain = temp_data2 & 0x07;
+			shift_gain--;
+			temp_data2 = (temp_data2 & 0xf8) | shift_gain;
+			atv_dmd_wr_byte(APB_BLOCK_ADDR_SIF_STG_2, 0x00,
+					temp_data2);
+			shift_gain_report = (
+			(atv_dmd_rd_long(APB_BLOCK_ADDR_SIF_STG_2, 0x04)
+					& 0x00070000) >> 16);
+			if (shift_gain_report != shift_gain)
+				pr_info("[atvdemo...]:set shift_gain error\n");
+			/* ------------------timer delay needed- */
+			udelay(1000);/* timer delay needed , */
+			/* ----------------------- */
+			counter_report =
+			atv_dmd_rd_word(APB_BLOCK_ADDR_SIF_STG_2, 0x04);
+		}
+		break;
+	default:
+		pr_info("invalid over_module_det mode!!!\n");
+		break;
+	}
+}
+
+void aml_fix_PWM_adjust(int enable)
+{
+	unsigned long  temp_data;
+	/*
+	 *temp_data = atv_dmd_rd_byte(APB_BLOCK_ADDR_AGC_PWM, 0x08);
+	 *temp_data = temp_data | 0x01;
+	 *atv_dmd_wr_byte(APB_BLOCK_ADDR_AGC_PWM, 0x08, temp_data);
+	 */
+	temp_data = atv_dmd_rd_reg(APB_BLOCK_ADDR_SIF_STG_2, 0x02);
+	if (enable)
+		temp_data = temp_data & ~((0x3)<<8);
+	else
+		temp_data = temp_data & ~((0x1)<<9);
+
+	atv_dmd_wr_reg(APB_BLOCK_ADDR_SIF_STG_2, 0x02, temp_data);
+	if (enable) {
+		temp_data = temp_data | ((0x3)<<8);
+		atv_dmd_wr_reg(APB_BLOCK_ADDR_SIF_STG_2, 0x02, temp_data);
+	}
+}
+
+void aml_audio_overmodulation(int enable)
+{
+	static int ov_flag;
+	unsigned long tmp_v;
+	unsigned long tmp_v1;
+	u32 Broadcast_Standard = broad_std;
+
+	if (enable && Broadcast_Standard ==
+		AML_ATV_DEMOD_VIDEO_MODE_PROP_PAL_DK) {
+		tmp_v = atv_dmd_rd_long(APB_BLOCK_ADDR_SIF_STG_2, 0x28);
+		tmp_v = tmp_v&0xffff;
+		if (tmp_v >= 0x10 && ov_flag == 0) {
+			tmp_v1 =
+				atv_dmd_rd_long(APB_BLOCK_ADDR_SIF_STG_2, 0);
+			tmp_v1 = (tmp_v1&0xffffff)|(1<<24);
+			atv_dmd_wr_long(APB_BLOCK_ADDR_SIF_STG_2, 0, tmp_v1);
+			atv_dmd_wr_long(APB_BLOCK_ADDR_SIF_STG_2,
+					0x14, 0x8000015);
+			atv_dmd_wr_long(APB_BLOCK_ADDR_SIF_STG_2,
+					0x1c, 0x0f000);
+		} else if (tmp_v >= 0x2500 && ov_flag == 0) {
+			tmp_v1 = atv_dmd_rd_long(APB_BLOCK_ADDR_SIF_STG_2, 0);
+			tmp_v1 = (tmp_v1&0xffffff)|(1<<24);
+			atv_dmd_wr_long(APB_BLOCK_ADDR_SIF_STG_2, 0, tmp_v1);
+			atv_dmd_wr_long(APB_BLOCK_ADDR_SIF_STG_2,
+					0x14, 0xf400015);
+			atv_dmd_wr_long(APB_BLOCK_ADDR_SIF_STG_2,
+					0x18, 0xc000);
+			atv_dmd_wr_long(APB_BLOCK_ADDR_SIF_STG_2,
+					0x1c, 0x0f000);
+			ov_flag = 1;
+		} else if (tmp_v <= 0x10 && ov_flag == 1) {
+			tmp_v1 = atv_dmd_rd_long(APB_BLOCK_ADDR_SIF_STG_2, 0);
+			tmp_v1 = (tmp_v1&0xffffff)|(0<<24);
+			atv_dmd_wr_long(APB_BLOCK_ADDR_SIF_STG_2, 0, tmp_v1);
+			atv_dmd_wr_long(APB_BLOCK_ADDR_SIF_STG_2,
+					0x14, 0xf400000);
+			atv_dmd_wr_long(APB_BLOCK_ADDR_SIF_STG_2,
+					0x18, 0xc000);
+			atv_dmd_wr_long(APB_BLOCK_ADDR_SIF_STG_2,
+					0x1c, 0x1f000);
+			ov_flag = 0;
+		}
+	}
+}
+
diff --git a/drivers/stream_input/tv_frontend/atv_demod/atvdemod_func.h b/drivers/stream_input/tv_frontend/atv_demod/atvdemod_func.h
new file mode 100644
index 0000000..8072392
--- /dev/null
+++ b/drivers/stream_input/tv_frontend/atv_demod/atvdemod_func.h
@@ -0,0 +1,323 @@
+/*
+ * ATVDEMOD Device Driver
+ *
+ * Author: dezhi kong <dezhi.kong@amlogic.com>
+ *
+ *
+ * Copyright (C) 2014 Amlogic Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __ATVDEMOD_FUN_H
+#define __ATVDEMOD_FUN_H
+
+/*#include "../aml_fe.h"*/
+#include <linux/amlogic/tvin/tvin.h>
+#include "../aml_fe.h"
+#include <linux/amlogic/iomap.h>
+
+/*#define TVFE_APB_BASE_ADDR 0xd0046000*/
+#define ATV_DMD_APB_BASE_ADDR 0xc8008000
+#define ATV_DMD_APB_BASE_ADDR_GXTVBB 0xc8840000
+
+#define HHI_ATV_DMD_SYS_CLK_CNTL		0x10f3
+
+extern int atvdemod_debug_en;
+extern struct amlatvdemod_device_s *amlatvdemod_devp;
+extern unsigned int reg_23cf; /* IIR filter */
+extern int broad_std_except_pal_m;
+#undef pr_info
+#define pr_info(args...)\
+	do {\
+		if (atvdemod_debug_en)\
+			printk(args);\
+	} while (0)
+#undef pr_dbg
+#define pr_dbg(a...) \
+	do {\
+		if (1)\
+			printk(a);\
+	} while (0)
+
+#define ATVDEMOD_INTERVAL	(HZ/100)	/*10ms, #define HZ 100*/
+
+extern int amlatvdemod_reg_read(unsigned int reg, unsigned int *val);
+extern int amlatvdemod_reg_write(unsigned int reg, unsigned int val);
+extern int amlatvdemod_hiu_reg_read(unsigned int reg, unsigned int *val);
+extern int amlatvdemod_hiu_reg_write(unsigned int reg, unsigned int val);
+
+static inline uint32_t R_ATVDEMOD_REG(uint32_t reg)
+{
+	unsigned int val;
+
+	amlatvdemod_reg_read(reg, &val);
+	return val;
+}
+
+static inline void W_ATVDEMOD_REG(uint32_t reg,
+				 const uint32_t val)
+{
+	amlatvdemod_reg_write(reg, val);
+}
+
+static inline void W_ATVDEMOD_BIT(uint32_t reg,
+				    const uint32_t value,
+				    const uint32_t start,
+				    const uint32_t len)
+{
+	W_ATVDEMOD_REG(reg, ((R_ATVDEMOD_REG(reg) &
+			     ~(((1L << (len)) - 1) << (start))) |
+			    (((value) & ((1L << (len)) - 1)) << (start))));
+}
+
+static inline uint32_t R_ATVDEMOD_BIT(uint32_t reg,
+				    const uint32_t start,
+				    const uint32_t len)
+{
+	uint32_t val;
+
+	val = ((R_ATVDEMOD_REG(reg) >> (start)) & ((1L << (len)) - 1));
+
+	return val;
+}
+
+static inline uint32_t R_HIU_REG(uint32_t reg)
+{
+	unsigned int val;
+
+	amlatvdemod_hiu_reg_read(reg, &val);
+	return val;
+}
+
+static inline void W_HIU_REG(uint32_t reg,
+				 const uint32_t val)
+{
+	amlatvdemod_hiu_reg_write(reg, val);
+}
+
+static inline void W_HIU_BIT(uint32_t reg,
+				    const uint32_t value,
+				    const uint32_t start,
+				    const uint32_t len)
+{
+	W_HIU_REG(reg, ((R_HIU_REG(reg) &
+			     ~(((1L << (len)) - 1) << (start))) |
+			    (((value) & ((1L << (len)) - 1)) << (start))));
+}
+
+static inline uint32_t R_HIU_BIT(uint32_t reg,
+				    const uint32_t start,
+				    const uint32_t len)
+{
+	uint32_t val;
+
+	val = ((R_HIU_REG(reg) >> (start)) & ((1L << (len)) - 1));
+
+	return val;
+}
+
+enum broadcast_standard_e {
+	ATVDEMOD_STD_NTSC = 0,
+	ATVDEMOD_STD_NTSC_J,
+	ATVDEMOD_STD_PAL_M,
+	ATVDEMOD_STD_PAL_BG,
+	ATVDEMOD_STD_DTV,
+	ATVDEMOD_STD_SECAM_DK2,
+	ATVDEMOD_STD_SECAM_DK3,
+	ATVDEMOD_STD_PAL_BG_NICAM,
+	ATVDEMOD_STD_PAL_DK_CHINA,
+	ATVDEMOD_STD_SECAM_L,
+	ATVDEMOD_STD_PAL_I,
+	ATVDEMOD_STD_PAL_DK1,
+	ATVDEMOD_STD_MAX,
+};
+enum gde_curve_e {
+	ATVDEMOD_CURVE_M = 0,
+	ATVDEMOD_CURVE_A,
+	ATVDEMOD_CURVE_B,
+	ATVDEMOD_CURVE_CHINA,
+	ATVDEMOD_CURVE_MAX,
+};
+enum sound_format_e {
+	ATVDEMOD_SOUND_STD_MONO = 0,
+	ATVDEMOD_SOUND_STD_NICAM,
+	ATVDEMOD_SOUND_STD_MAX,
+};
+extern void atv_dmd_wr_reg(unsigned char block, unsigned char reg,
+	unsigned long data);
+extern unsigned long atv_dmd_rd_reg(unsigned char block, unsigned char reg);
+extern unsigned long atv_dmd_rd_byte(unsigned long block_address,
+				     unsigned long reg_addr);
+extern unsigned long atv_dmd_rd_word(unsigned long block_address,
+				     unsigned long reg_addr);
+extern unsigned long atv_dmd_rd_long(unsigned long block_address,
+				     unsigned long reg_addr);
+extern void atv_dmd_wr_long(unsigned long block_address,
+				unsigned long reg_addr,
+				unsigned long data);
+extern void atv_dmd_wr_word(unsigned long block_address,
+				unsigned long reg_addr,
+				unsigned long data);
+extern void atv_dmd_wr_byte(unsigned long block_address,
+				unsigned long reg_addr,
+				unsigned long data);
+extern void set_audio_gain_val(int val);
+extern void set_video_gain_val(int val);
+extern void atv_dmd_soft_reset(void);
+extern void atv_dmd_input_clk_32m(void);
+extern void read_version_register(void);
+extern void check_communication_interface(void);
+extern void power_on_receiver(void);
+extern void atv_dmd_misc(void);
+extern void configure_receiver(int Broadcast_Standard,
+			       unsigned int Tuner_IF_Frequency,
+			       int Tuner_Input_IF_inverted, int GDE_Curve,
+			       int sound_format);
+extern int atvdemod_clk_init(void);
+extern int atvdemod_init(void);
+extern void atvdemod_uninit(void);
+extern void atv_dmd_set_std(void);
+extern void retrieve_vpll_carrier_lock(int *lock);
+extern void retrieve_video_lock(int *lock);
+extern int retrieve_vpll_carrier_afc(void);
+
+extern int get_atvdemod_snr_val(void);
+extern int aml_atvdemod_get_snr(struct dvb_frontend *fe);
+
+/*atv demod block address*/
+/*address interval is 4, because it's 32bit interface,
+ * but the address is in byte
+ */
+#define ATV_DMD_TOP_CTRL			0x0
+#define ATV_DMD_TOP_CTRL1			0x4
+#define ATV_DMD_RST_CTRL			0x8
+
+#define APB_BLOCK_ADDR_SYSTEM_MGT			0x0
+#define APB_BLOCK_ADDR_AA_LP_NOTCH			0x1
+#define APB_BLOCK_ADDR_MIXER_1				0x2
+#define APB_BLOCK_ADDR_MIXER_3				0x3
+#define APB_BLOCK_ADDR_ADC_SE				0x4
+#define APB_BLOCK_ADDR_PWR_ANL				0x5
+#define APB_BLOCK_ADDR_CARR_RCVY			0x6
+#define APB_BLOCK_ADDR_FE_DROOP_MDF			0x7
+#define APB_BLOCK_ADDR_SIF_IC_STD			0x8
+#define APB_BLOCK_ADDR_SIF_STG_2			0x9
+#define APB_BLOCK_ADDR_SIF_STG_3			0xa
+#define APB_BLOCK_ADDR_IC_AGC				0xb
+#define APB_BLOCK_ADDR_DAC_UPS				0xc
+#define APB_BLOCK_ADDR_GDE_EQUAL			0xd
+#define APB_BLOCK_ADDR_VFORMAT				0xe
+#define APB_BLOCK_ADDR_VDAGC				0xf
+#define APB_BLOCK_ADDR_VERS_REGISTER			0x10
+#define APB_BLOCK_ADDR_INTERPT_MGT			0x11
+#define APB_BLOCK_ADDR_ADC_MGR				0x12
+#define APB_BLOCK_ADDR_GP_VD_FLT			0x13
+#define APB_BLOCK_ADDR_CARR_DMD				0x14
+#define APB_BLOCK_ADDR_SIF_VD_IF			0x15
+#define APB_BLOCK_ADDR_VD_PKING				0x16
+#define APB_BLOCK_ADDR_FE_DR_SMOOTH			0x17
+#define APB_BLOCK_ADDR_AGC_PWM				0x18
+#define APB_BLOCK_ADDR_DAC_UPS_24M			0x19
+#define APB_BLOCK_ADDR_VFORMAT_DP			0x1a
+#define APB_BLOCK_ADDR_VD_PKING_DAC			0x1b
+#define APB_BLOCK_ADDR_MONO_PROC			0x1c
+#define APB_BLOCK_ADDR_TOP				0x1d
+
+#define SLAVE_BLOCKS_NUMBER 0x1d	/*indeed totals 0x1e, adding top*/
+
+/*Broadcast_Standard*/
+/*                      0: NTSC*/
+/*                      1: NTSC-J*/
+/*                      2: PAL-M,*/
+/*                      3: PAL-BG*/
+/*                      4: DTV*/
+/*                      5: SECAM- DK2*/
+/*                      6: SECAM -DK3*/
+/*                      7: PAL-BG, NICAM*/
+/*                      8: PAL-DK-CHINA*/
+/*                      9: SECAM-L / SECAM-DK3*/
+/*                      10: PAL-I*/
+/*                      11: PAL-DK1*/
+#define AML_ATV_DEMOD_VIDEO_MODE_PROP_NTSC		0
+#define AML_ATV_DEMOD_VIDEO_MODE_PROP_NTSC_J		1
+#define AML_ATV_DEMOD_VIDEO_MODE_PROP_PAL_M		2
+#define AML_ATV_DEMOD_VIDEO_MODE_PROP_PAL_BG		3
+#define AML_ATV_DEMOD_VIDEO_MODE_PROP_DTV		4
+#define AML_ATV_DEMOD_VIDEO_MODE_PROP_SECAM_DK2		5
+#define AML_ATV_DEMOD_VIDEO_MODE_PROP_SECAM_DK3		6
+#define AML_ATV_DEMOD_VIDEO_MODE_PROP_PAL_BG_NICAM	7
+#define AML_ATV_DEMOD_VIDEO_MODE_PROP_PAL_DK		8
+#define AML_ATV_DEMOD_VIDEO_MODE_PROP_SECAM_L	9
+#define AML_ATV_DEMOD_VIDEO_MODE_PROP_PAL_I	10
+#define AML_ATV_DEMOD_VIDEO_MODE_PROP_PAL_DK1	11
+/* new add @20150813 begin */
+#define AML_ATV_DEMOD_VIDEO_MODE_PROP_NTSC_DK		12
+#define AML_ATV_DEMOD_VIDEO_MODE_PROP_NTSC_BG	13
+#define AML_ATV_DEMOD_VIDEO_MODE_PROP_NTSC_I	14
+#define AML_ATV_DEMOD_VIDEO_MODE_PROP_NTSC_M    15
+/* new add @20150813 end */
+
+/*GDE_Curve*/
+/*                      0: CURVE-M*/
+/*                      1: CURVE-A*/
+/*                      2: CURVE-B*/
+/*                      3: CURVE-CHINA*/
+/*                      4: BYPASS*/
+#define AML_ATV_DEMOD_VIDEO_MODE_PROP_CURVE_M		0
+#define AML_ATV_DEMOD_VIDEO_MODE_PROP_CURVE_A		1
+#define AML_ATV_DEMOD_VIDEO_MODE_PROP_CURVE_B		2
+#define AML_ATV_DEMOD_VIDEO_MODE_PROP_CURVE_CHINA	3
+#define AML_ATV_DEMOD_VIDEO_MODE_PROP_CURVE_BYPASS	4
+
+/*sound format 0: MONO;1:NICAM*/
+#define AML_ATV_DEMOD_SOUND_MODE_PROP_MONO	0
+#define AML_ATV_DEMOD_SOUND_MODE_PROP_NICAM	1
+/**
+ *freq_hz:hs_freq
+ *freq_hz_cvrt=hs_freq/0.23841858
+ *vs_freq==50,freq_hz=15625;freq_hz_cvrt=0xffff
+ *vs_freq==60,freq_hz=15734,freq_hz_cvrt=0x101c9
+ **
+ */
+#define AML_ATV_DEMOD_FREQ_50HZ_VERT	0xffff	/*65535*/
+#define AML_ATV_DEMOD_FREQ_60HZ_VERT	0x101c9	/*65993*/
+
+#define CARR_AFC_DEFAULT_VAL 0xffff
+
+enum amlatvdemod_snr_level_e {
+	very_low = 1,
+	low,
+	ok_minus,
+	ok_plus,
+	high,
+};
+
+enum audio_detect_mode {
+	AUDIO_AUTO_DETECT = 0,
+	AUDIO_MANUAL_DETECT,
+};
+
+struct amlatvdemod_device_s {
+	struct class *clsp;
+	struct device *dev;
+	struct analog_parameters parm;
+	int fre_offset;
+	struct pinctrl *pin;
+	const char *pin_name;
+};
+
+extern void aml_audio_overmodulation(int enable);
+extern void amlatvdemod_set_std(int val);
+extern struct amlatvdemod_device_s *amlatvdemod_devp;
+extern void aml_fix_PWM_adjust(int enable);
+extern void aml_audio_valume_gain_set(unsigned int audio_gain);
+extern unsigned int aml_audio_valume_gain_get(void);
+extern void aml_atvdemod_overmodule_det(void);
+extern int aml_audiomode_autodet(struct dvb_frontend *fe);
+extern void retrieve_frequency_offset(int *freq_offset);
+extern int aml_atvdemod_get_snr_ex(void);
+
+#endif /* __ATVDEMOD_FUN_H */
diff --git a/drivers/stream_input/tv_frontend/dtv_demod/aml_demod.c b/drivers/stream_input/tv_frontend/dtv_demod/aml_demod.c
new file mode 100644
index 0000000..7ccdfae
--- /dev/null
+++ b/drivers/stream_input/tv_frontend/dtv_demod/aml_demod.c
@@ -0,0 +1,725 @@
+/*
+* Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT
+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+* more details.
+*
+* You should have received a copy of the GNU General Public License along
+* with this program; if not, write to the Free Software Foundation, Inc.,
+* 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+*
+* Description:
+*/
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/ioport.h>
+#include <linux/platform_device.h>
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/spinlock.h>
+#include <linux/interrupt.h>
+#include <linux/fs.h>
+#include <linux/string.h>
+#include <linux/io.h>
+#include <linux/mm.h>
+#include <linux/major.h>
+#include <linux/err.h>
+#include <linux/mutex.h>
+#include <linux/ctype.h>
+#include <linux/sched.h>
+#include <linux/poll.h>
+#include <linux/i2c.h>
+#include <linux/delay.h>
+/* #include <mach/am_regs.h> */
+#include <linux/device.h>
+#include <linux/cdev.h>
+
+/* #include <asm/fiq.h> */
+#include <linux/uaccess.h>
+#include <linux/dvb/aml_demod.h>
+#include "demod_func.h"
+
+#include <linux/slab.h>
+#ifdef CONFIG_COMPAT
+#include <linux/compat.h>
+#endif
+/*#include "sdio/sdio_init.h"*/
+#define DRIVER_NAME "aml_demod"
+#define MODULE_NAME "aml_demod"
+#define DEVICE_NAME "aml_demod"
+#define DEVICE_UI_NAME "aml_demod_ui"
+
+#define pr_dbg(a ...) \
+	do { \
+		if (1) { \
+			printk(a); \
+		} \
+	} while (0)
+
+
+const char aml_demod_dev_id[] = "aml_demod";
+
+/*#ifndef CONFIG_AM_DEMOD_DVBAPI
+ * static struct aml_demod_i2c demod_i2c;
+ * static struct aml_demod_sta demod_sta;
+ * #else
+ * extern struct aml_demod_i2c demod_i2c;
+ * extern struct aml_demod_sta demod_sta;
+ #endif
+*/
+
+static struct aml_demod_i2c demod_i2c;
+static struct aml_demod_sta demod_sta;
+static int read_start;
+
+int sdio_read_ddr(unsigned long sdio_addr, unsigned long byte_count,
+		  unsigned char *data_buf)
+{
+	return 0;
+}
+
+int sdio_write_ddr(unsigned long sdio_addr, unsigned long byte_count,
+		   unsigned char *data_buf)
+{
+	return 0;
+}
+
+int read_reg(int addr)
+{
+	addr = addr + DEMOD_BASE;
+	return apb_read_reg(addr);
+}
+
+void wait_capture(int cap_cur_addr, int depth_MB, int start)
+{
+	int readfirst;
+	int tmp;
+	int time_out;
+	int last = 0x90000000;
+
+	time_out = readfirst = 0;
+	tmp = depth_MB << 20;
+	while (tmp && (time_out < 1000)) {      /*10seconds time out */
+		time_out = time_out + 1;
+		msleep(20);
+		readfirst = app_apb_read_reg(cap_cur_addr);
+		if ((last - readfirst) > 0)
+			tmp = 0;
+		else
+			last = readfirst;
+		/*      usleep(1000); */
+		/*      readsecond= app_apb_read_reg(cap_cur_addr); */
+
+		/*      if((readsecond-start)>tmp) */
+/*                      tmp=0;*/
+/*              if((readsecond-readfirst)<0)  // turn around*/
+/*                      tmp=0;*/
+		pr_dbg("First  %x = [%08x],[%08x]%x\n", cap_cur_addr, readfirst,
+		       last, (last - readfirst));
+/*              printf("Second %x = [%08x]\n",cap_cur_addr, readsecond);*/
+		msleep(20);
+	}
+	read_start = readfirst + 0x40000000;
+	pr_dbg("read_start is %x\n", read_start);
+}
+
+int cap_adc_data(struct aml_cap_data *cap)
+{
+	int tmp;
+	int tb_depth;
+
+	pr_dbg("capture ADC\n ");
+	/*      printf("set mem_start (you can read in kernel start log
+	 * (memstart is ).(hex)  :  ");
+	 */
+	/*      scanf("%x",&tmp);*/
+	tmp = 0x94400000;
+	app_apb_write_reg(0x9d, cap->cap_addr);
+	app_apb_write_reg(0x9e, cap->cap_addr + cap->cap_size * 0x100000);
+	/*0x8000000-128m, 0x400000-4m */
+	read_start = tmp + 0x40000000;
+	/*printf("set afifo rate. (hex)(adc_clk/demod_clk)*256+2 :  ");   //
+	 * (adc_clk/demod_clk)*256+2
+	 */
+	/*  scanf("%x",&tmp); */
+	cap->cap_afifo = 0x60;
+	app_apb_write_reg(0x15, 0x18715f2);
+	app_apb_write_reg(0x15, (app_apb_read_reg(0x15) & 0xfff00fff) |
+			  ((cap->cap_afifo & 0xff) << 12));     /* set afifo */
+	app_apb_write_reg(0x9b, 0x1c9);	/* capture ADC 10bits */
+	app_apb_write_reg(0x7f, 0x00008000);	/* enable testbus 0x8000 */
+
+	tb_depth = cap->cap_size;                               /*127; */
+	tmp = 9;
+	app_apb_write_reg(0x9b, (app_apb_read_reg(0x9b) & ~0x1f) | tmp);
+	/* set testbus width */
+
+	tmp = 0x100000;
+	app_apb_write_reg(0x9c, tmp);   /* by ADC data enable */
+	/*  printf("Set test mode. (0 is normal ,1 is testmode) :  ");  //0 */
+	/*  scanf("%d",&tmp); */
+	tmp = 0;
+	if (tmp == 1)
+		app_apb_write_reg(0x9b, app_apb_read_reg(0x9b) | (1 << 10));
+	/* set test mode; */
+	else
+		app_apb_write_reg(0x9b, app_apb_read_reg(0x9b) & ~(1 << 10));
+	/* close test mode; */
+
+	app_apb_write_reg(0x9b, app_apb_read_reg(0x9b) & ~(1 << 9));
+	/* close cap; */
+	app_apb_write_reg(0x9b, app_apb_read_reg(0x9b) | (1 << 9));
+	/* open  cap; */
+
+	app_apb_write_reg(0x9b, app_apb_read_reg(0x9b) | (1 << 7));
+	/* close tb; */
+	app_apb_write_reg(0x9b, app_apb_read_reg(0x9b) & ~(1 << 7));
+	/* open  tb; */
+
+	app_apb_write_reg(0x9b, app_apb_read_reg(0x9b) | (1 << 5));
+	/* close intlv; */
+
+	app_apb_write_reg(0x303, 0x8);  /* open dc_arbit */
+
+	tmp = 0;
+	if (tmp)
+		app_apb_write_reg(0x9b, app_apb_read_reg(0x9b) & ~(1 << 5));
+	/* open  intlv; */
+
+	app_apb_write_reg(0x9b, app_apb_read_reg(0x9b) & ~(1 << 8));
+	/* go  tb; */
+
+	wait_capture(0x9f, tb_depth, app_apb_read_reg(0x9d));
+
+	app_apb_write_reg(0x9b, app_apb_read_reg(0x9b) | (1 << 8));
+	/* stop  tb; */
+	app_apb_write_reg(0x9b, app_apb_read_reg(0x9b) | (1 << 7));
+	/* close tb; */
+	return 0;
+}
+
+static DECLARE_WAIT_QUEUE_HEAD(lock_wq);
+
+static ssize_t aml_demod_info(struct class *cla,
+			      struct class_attribute *attr, char *buf)
+{
+	return 0;
+}
+
+static struct class_attribute aml_demod_class_attrs[] = {
+	__ATTR(info,
+	       0644,
+	       aml_demod_info,
+	       NULL),
+	__ATTR_NULL
+};
+
+static struct class aml_demod_class = {
+	.name		= "aml_demod",
+	.class_attrs	= aml_demod_class_attrs,
+};
+
+#if 0
+
+static irqreturn_t aml_demod_isr(int irq, void *dev_id)
+{
+	if (demod_sta.dvb_mode == 0) {
+		/*dvbc_isr(&demod_sta); */
+		if (dvbc_isr_islock()) {
+			pr_dbg("sync4\n");
+			/*if (waitqueue_active(&lock_wq))
+			 *wake_up_interruptible(&lock_wq);
+			 */
+		}
+	} else {
+		dvbt_isr(&demod_sta);
+	}
+
+	return IRQ_HANDLED;
+}
+#endif
+
+static int aml_demod_open(struct inode *inode, struct file *file)
+{
+	pr_dbg("Amlogic Demod DVB-T/C Open\n");
+	return 0;
+}
+
+static int aml_demod_release(struct inode *inode, struct file *file)
+{
+	pr_dbg("Amlogic Demod DVB-T/C Release\n");
+	return 0;
+}
+
+#if 0
+static int amdemod_islock(void)
+{
+	struct aml_demod_sts demod_sts;
+
+	if (demod_sta.dvb_mode == 0) {
+		dvbc_status(&demod_sta, &demod_i2c, &demod_sts);
+		return demod_sts.ch_sts & 0x1;
+	} else if (demod_sta.dvb_mode == 1) {
+		dvbt_status(&demod_sta, &demod_i2c, &demod_sts);
+		return demod_sts.ch_sts >> 12 & 0x1;
+	}
+	return 0;
+}
+#endif
+
+void mem_read(struct aml_demod_mem *arg)
+{
+	int data;
+	int addr;
+
+	addr = arg->addr;
+	data = arg->dat;
+/*      memcpy(mem_buf[addr],data,1);*/
+	pr_dbg("[addr %x] data is %x\n", addr, data);
+}
+static long aml_demod_ioctl(struct file *file,
+			    unsigned int cmd, unsigned long arg)
+{
+	int strength = 0;
+	struct dvb_frontend *dvbfe;
+	struct aml_tuner_sys *tuner;
+
+	switch (cmd) {
+	case AML_DEMOD_GET_RSSI:
+		pr_dbg("Ioctl Demod GET_RSSI.\n");
+		dvbfe = get_si2177_tuner();
+		if (dvbfe != NULL)
+			strength = dvbfe->ops.tuner_ops.get_strength(dvbfe);
+		pr_dbg("[si2177] strength is %d\n", strength - 256);
+		if (strength < 0)
+			strength = 0 - strength;
+		tuner = (struct aml_tuner_sys *)arg;
+		tuner->rssi = strength;
+		break;
+
+	case AML_DEMOD_SET_TUNER:
+		pr_dbg("Ioctl Demod Set Tuner.\n");
+		dvbfe = get_si2177_tuner();
+		if (dvbfe != NULL)
+			dvbfe->ops.tuner_ops.set_tuner(dvbfe, &demod_sta,
+						       &demod_i2c,
+						       (struct aml_tuner_sys *)
+						       arg);
+		break;
+
+	case AML_DEMOD_SET_SYS:
+		pr_dbg("Ioctl Demod Set System\n");
+		demod_set_sys(&demod_sta, &demod_i2c,
+			      (struct aml_demod_sys *)arg);
+		break;
+
+	case AML_DEMOD_GET_SYS:
+		pr_dbg("Ioctl Demod Get System\n");
+
+		/*demod_get_sys(&demod_i2c, (struct aml_demod_sys *)arg); */
+		break;
+
+	case AML_DEMOD_TEST:
+		pr_dbg("Ioctl Demod Test. It is blank now\n");
+		/*demod_msr_clk(13); */
+		/*demod_msr_clk(14); */
+		/*demod_calc_clk(&demod_sta); */
+		break;
+
+	case AML_DEMOD_TURN_ON:
+		pr_dbg("Ioctl Demod Turn ON.It is blank now\n");
+		/*demod_turn_on(&demod_sta, (struct aml_demod_sys *)arg); */
+		break;
+
+	case AML_DEMOD_TURN_OFF:
+		pr_dbg("Ioctl Demod Turn OFF.It is blank now\n");
+		/*demod_turn_off(&demod_sta, (struct aml_demod_sys *)arg); */
+		break;
+
+	case AML_DEMOD_DVBC_SET_CH:
+		pr_dbg("Ioctl DVB-C Set Channel.\n");
+		dvbc_set_ch(&demod_sta, &demod_i2c,
+			    (struct aml_demod_dvbc *)arg);
+		break;
+
+	case AML_DEMOD_DVBC_GET_CH:
+		/*      pr_dbg("Ioctl DVB-C Get Channel. It is blank\n"); */
+		dvbc_status(&demod_sta, &demod_i2c,
+			    (struct aml_demod_sts *)arg);
+		break;
+	case AML_DEMOD_DVBC_TEST:
+		pr_dbg("Ioctl DVB-C Test. It is blank\n");
+		/*dvbc_get_test_out(0xb, 1000, (u32 *)arg); */
+		break;
+	case AML_DEMOD_DVBT_SET_CH:
+		pr_dbg("Ioctl DVB-T Set Channel\n");
+		dvbt_set_ch(&demod_sta, &demod_i2c,
+			    (struct aml_demod_dvbt *)arg);
+		break;
+
+	case AML_DEMOD_DVBT_GET_CH:
+		pr_dbg("Ioctl DVB-T Get Channel\n");
+		/*dvbt_status(&demod_sta, &demod_i2c,
+		 * (struct aml_demod_sts *)arg);
+		 */
+		break;
+
+	case AML_DEMOD_DVBT_TEST:
+		pr_dbg("Ioctl DVB-T Test. It is blank\n");
+		/*dvbt_get_test_out(0x1e, 1000, (u32 *)arg); */
+		break;
+
+	case AML_DEMOD_DTMB_SET_CH:
+		dtmb_set_ch(&demod_sta, &demod_i2c,
+			    (struct aml_demod_dtmb *)arg);
+		break;
+
+	case AML_DEMOD_DTMB_GET_CH:
+		break;
+
+	case AML_DEMOD_DTMB_TEST:
+		break;
+
+	case AML_DEMOD_ATSC_SET_CH:
+		atsc_set_ch(&demod_sta, &demod_i2c,
+			    (struct aml_demod_atsc *)arg);
+		break;
+
+	case AML_DEMOD_ATSC_GET_CH:
+		check_atsc_fsm_status();
+		break;
+
+	case AML_DEMOD_ATSC_TEST:
+		break;
+
+	case AML_DEMOD_SET_REG:
+		/*      pr_dbg("Ioctl Set Register\n"); */
+		demod_set_reg((struct aml_demod_reg *)arg);
+		break;
+
+	case AML_DEMOD_GET_REG:
+		/*      pr_dbg("Ioctl Get Register\n"); */
+		demod_get_reg((struct aml_demod_reg *)arg);
+		break;
+
+/* case AML_DEMOD_SET_REGS: */
+/* break; */
+
+/* case AML_DEMOD_GET_REGS: */
+/* break; */
+
+	case AML_DEMOD_RESET_MEM:
+		pr_dbg("set mem ok\n");
+		break;
+
+	case AML_DEMOD_READ_MEM:
+		break;
+	case AML_DEMOD_SET_MEM:
+		/*step=(struct aml_demod_mem)arg;
+		 * pr_dbg("[%x]0x%x------------------\n",i,mem_buf[step]);
+		 * for(i=step;i<1024-1;i++){
+		 * pr_dbg("0x%x,",mem_buf[i]);
+		 * }
+		 */
+		mem_read((struct aml_demod_mem *)arg);
+		break;
+
+	case AML_DEMOD_ATSC_IRQ:
+		atsc_read_iqr_reg();
+		break;
+
+	default:
+		pr_dbg("Enter Default ! 0x%X\n", cmd);
+/* pr_dbg("AML_DEMOD_GET_REGS=0x%08X\n", AML_DEMOD_GET_REGS); */
+/* pr_dbg("AML_DEMOD_SET_REGS=0x%08X\n", AML_DEMOD_SET_REGS); */
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+#ifdef CONFIG_COMPAT
+
+static long aml_demod_compat_ioctl(struct file *file, unsigned int cmd,
+				   ulong arg)
+{
+	return aml_demod_ioctl(file, cmd, (ulong)compat_ptr(arg));
+}
+
+#endif
+
+
+static const struct file_operations aml_demod_fops = {
+	.owner		= THIS_MODULE,
+	.open		= aml_demod_open,
+	.release	= aml_demod_release,
+	.unlocked_ioctl = aml_demod_ioctl,
+#ifdef CONFIG_COMPAT
+	.compat_ioctl	= aml_demod_compat_ioctl,
+#endif
+};
+
+static int aml_demod_ui_open(struct inode *inode, struct file *file)
+{
+	pr_dbg("Amlogic aml_demod_ui_open Open\n");
+	return 0;
+}
+
+static int aml_demod_ui_release(struct inode *inode, struct file *file)
+{
+	pr_dbg("Amlogic aml_demod_ui_open Release\n");
+	return 0;
+}
+char buf_all[100];
+static ssize_t aml_demod_ui_read(struct file *file, char __user *buf,
+				 size_t count, loff_t *ppos)
+{
+	char *capture_buf = buf_all;
+	int res = 0;
+
+	if (count >= 4 * 1024 * 1024)
+		count = 4 * 1024 * 1024;
+	else if (count == 0)
+		return 0;
+
+	res = copy_to_user((void *)buf, (char *)capture_buf, count);
+	if (res < 0) {
+		pr_dbg("[aml_demod_ui_read]res is %d", res);
+		return res;
+	}
+
+	return count;
+}
+
+static ssize_t aml_demod_ui_write(struct file *file, const char *buf,
+				  size_t count, loff_t *ppos)
+{
+	return 0;
+}
+
+static struct device *aml_demod_ui_dev;
+static dev_t aml_demod_devno_ui;
+static struct cdev *aml_demod_cdevp_ui;
+static const struct file_operations aml_demod_ui_fops = {
+	.owner		= THIS_MODULE,
+	.open		= aml_demod_ui_open,
+	.release	= aml_demod_ui_release,
+	.read		= aml_demod_ui_read,
+	.write		= aml_demod_ui_write,
+	/*   .unlocked_ioctl    = aml_demod_ui_ioctl, */
+};
+
+#if 0
+static ssize_t aml_demod_ui_info(struct class *cla,
+				 struct class_attribute *attr, char *buf)
+{
+	return 0;
+}
+
+static struct class_attribute aml_demod_ui_class_attrs[] = {
+	__ATTR(info,
+	       0644,
+	       aml_demod_ui_info,
+	       NULL),
+	__ATTR_NULL
+};
+#endif
+
+static struct class aml_demod_ui_class = {
+	.name	= "aml_demod_ui",
+/*    .class_attrs = aml_demod_ui_class_attrs,*/
+};
+
+int aml_demod_ui_init(void)
+{
+	int r = 0;
+
+	r = class_register(&aml_demod_ui_class);
+	if (r) {
+		pr_dbg("create aml_demod class fail\r\n");
+		class_unregister(&aml_demod_ui_class);
+		return r;
+	}
+
+	r = alloc_chrdev_region(&aml_demod_devno_ui, 0, 1, DEVICE_UI_NAME);
+	if (r < 0) {
+		pr_dbg("aml_demod_ui: failed to alloc major number\n");
+		r = -ENODEV;
+		unregister_chrdev_region(aml_demod_devno_ui, 1);
+		class_unregister(&aml_demod_ui_class);
+		return r;
+	}
+
+	aml_demod_cdevp_ui = kmalloc(sizeof(struct cdev), GFP_KERNEL);
+	if (!aml_demod_cdevp_ui) {
+		r = -ENOMEM;
+		unregister_chrdev_region(aml_demod_devno_ui, 1);
+		kfree(aml_demod_cdevp_ui);
+		class_unregister(&aml_demod_ui_class);
+		return r;
+	}
+	/* connect the file operation with cdev */
+	cdev_init(aml_demod_cdevp_ui, &aml_demod_ui_fops);
+	aml_demod_cdevp_ui->owner = THIS_MODULE;
+	/* connect the major/minor number to cdev */
+	r = cdev_add(aml_demod_cdevp_ui, aml_demod_devno_ui, 1);
+	if (r) {
+		pr_dbg("aml_demod_ui:failed to add cdev\n");
+		unregister_chrdev_region(aml_demod_devno_ui, 1);
+		cdev_del(aml_demod_cdevp_ui);
+		kfree(aml_demod_cdevp_ui);
+		class_unregister(&aml_demod_ui_class);
+		return r;
+	}
+
+	aml_demod_ui_dev = device_create(&aml_demod_ui_class, NULL,
+					 MKDEV(MAJOR(aml_demod_devno_ui), 0),
+					 NULL, DEVICE_UI_NAME);
+
+	if (IS_ERR(aml_demod_ui_dev)) {
+		pr_dbg("Can't create aml_demod device\n");
+		unregister_chrdev_region(aml_demod_devno_ui, 1);
+		cdev_del(aml_demod_cdevp_ui);
+		kfree(aml_demod_cdevp_ui);
+		class_unregister(&aml_demod_ui_class);
+		return r;
+	}
+
+	return r;
+}
+
+void aml_demod_exit_ui(void)
+{
+	unregister_chrdev_region(aml_demod_devno_ui, 1);
+	cdev_del(aml_demod_cdevp_ui);
+	kfree(aml_demod_cdevp_ui);
+	class_unregister(&aml_demod_ui_class);
+}
+
+static struct device *aml_demod_dev;
+static dev_t aml_demod_devno;
+static struct cdev *aml_demod_cdevp;
+
+#ifdef CONFIG_AM_DEMOD_DVBAPI
+int aml_demod_init(void)
+#else
+static int __init aml_demod_init(void)
+#endif
+{
+	int r = 0;
+
+	pr_dbg("Amlogic Demod DVB-T/C DebugIF Init\n");
+
+	init_waitqueue_head(&lock_wq);
+
+	/* hook demod isr */
+	/* r = request_irq(INT_DEMOD, &aml_demod_isr,
+	 *              IRQF_SHARED, "aml_demod",
+	 *              (void *)aml_demod_dev_id);
+	 * if (r) {
+	 *      pr_dbg("aml_demod irq register error.\n");
+	 *      r = -ENOENT;
+	 *      goto err0;
+	 * }
+	 */
+
+	/* sysfs node creation */
+	r = class_register(&aml_demod_class);
+	if (r) {
+		pr_dbg("create aml_demod class fail\r\n");
+		goto err1;
+	}
+
+	r = alloc_chrdev_region(&aml_demod_devno, 0, 1, DEVICE_NAME);
+	if (r < 0) {
+		pr_dbg("aml_demod: failed to alloc major number\n");
+		r = -ENODEV;
+		goto err2;
+	}
+
+	aml_demod_cdevp = kmalloc(sizeof(struct cdev), GFP_KERNEL);
+	if (!aml_demod_cdevp) {
+		r = -ENOMEM;
+		goto err3;
+	}
+	/* connect the file operation with cdev */
+	cdev_init(aml_demod_cdevp, &aml_demod_fops);
+	aml_demod_cdevp->owner = THIS_MODULE;
+	/* connect the major/minor number to cdev */
+	r = cdev_add(aml_demod_cdevp, aml_demod_devno, 1);
+	if (r) {
+		pr_dbg("aml_demod:failed to add cdev\n");
+		goto err4;
+	}
+
+	aml_demod_dev = device_create(&aml_demod_class, NULL,
+				      MKDEV(MAJOR(aml_demod_devno), 0), NULL,
+				      DEVICE_NAME);
+
+	if (IS_ERR(aml_demod_dev)) {
+		pr_dbg("Can't create aml_demod device\n");
+		goto err5;
+	}
+	pr_dbg("Amlogic Demod DVB-T/C DebugIF Init ok----------------\n");
+#if defined(CONFIG_AM_AMDEMOD_FPGA_VER) && !defined(CONFIG_AM_DEMOD_DVBAPI)
+	pr_dbg("sdio_init\n");
+	sdio_init();
+#endif
+	aml_demod_ui_init();
+
+	return 0;
+
+err5:
+	cdev_del(aml_demod_cdevp);
+err4:
+	kfree(aml_demod_cdevp);
+
+err3:
+	unregister_chrdev_region(aml_demod_devno, 1);
+
+err2:
+/*    free_irq(INT_DEMOD, (void *)aml_demod_dev_id);*/
+
+err1:
+	class_unregister(&aml_demod_class);
+
+/*  err0:*/
+	return r;
+}
+
+#ifdef CONFIG_AM_DEMOD_DVBAPI
+void aml_demod_exit(void)
+#else
+static void __exit aml_demod_exit(void)
+#endif
+{
+	pr_dbg("Amlogic Demod DVB-T/C DebugIF Exit\n");
+
+	unregister_chrdev_region(aml_demod_devno, 1);
+	device_destroy(&aml_demod_class, MKDEV(MAJOR(aml_demod_devno), 0));
+	cdev_del(aml_demod_cdevp);
+	kfree(aml_demod_cdevp);
+
+	/*   free_irq(INT_DEMOD, (void *)aml_demod_dev_id); */
+
+	class_unregister(&aml_demod_class);
+
+	aml_demod_exit_ui();
+}
+
+#ifndef CONFIG_AM_DEMOD_DVBAPI
+module_init(aml_demod_init);
+module_exit(aml_demod_exit);
+
+MODULE_LICENSE("GPL");
+/*MODULE_AUTHOR(DRV_AUTHOR);*/
+/*MODULE_DESCRIPTION(DRV_DESC);*/
+#endif
diff --git a/drivers/stream_input/tv_frontend/dtv_demod/amlfrontend.c b/drivers/stream_input/tv_frontend/dtv_demod/amlfrontend.c
new file mode 100644
index 0000000..357b6db
--- /dev/null
+++ b/drivers/stream_input/tv_frontend/dtv_demod/amlfrontend.c
@@ -0,0 +1,1402 @@
+/*****************************************************************
+ **
+ **  Copyright (C) 2009 Amlogic,Inc.
+ **  All rights reserved
+ **        Filename : amlfrontend.c
+ **
+ **  comment:
+ **        Driver for m6_demod demodulator
+ **  author :
+ **	    Shijie.Rong@amlogic
+ **  version :
+ **	    v1.0	 12/3/13
+ **          v2.0     15/10/12
+ ****************************************************************
+ */
+
+/*
+ *  Driver for gxtv_demod demodulator
+ */
+
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/string.h>
+#include <linux/delay.h>
+#include <linux/jiffies.h>
+#include <linux/slab.h>
+#include <linux/platform_device.h>
+#ifdef ARC_700
+#include <asm/arch/am_regs.h>
+#else
+/* #include <mach/am_regs.h> */
+#endif
+#include <linux/i2c.h>
+#include <linux/gpio.h>
+#include "../aml_fe.h"
+
+#include <linux/dma-contiguous.h>
+#include <linux/dvb/aml_demod.h>
+#include "demod_func.h"
+#include "../aml_dvb.h"
+#include "amlfrontend.h"
+
+MODULE_PARM_DESC(debug_aml, "\n\t\t Enable frontend debug information");
+static int debug_aml;
+module_param(debug_aml, int, 0644);
+
+#define pr_dbg(a ...) \
+	do { \
+		if (debug_aml) { \
+			printk(a); \
+		} \
+	} while (0)
+#define pr_error(fmt, args ...) pr_err("GXTV_DEMOD: "fmt, ## args)
+#define pr_inf(fmt, args...)  pr_err("GXTV_DEMOD: " fmt, ## args)
+
+static int last_lock = -1;
+#define DEMOD_DEVICE_NAME  "gxtv_demod"
+static int cci_thread;
+static int freq_dvbc;
+static struct aml_demod_sta demod_status;
+static fe_modulation_t atsc_mode = VSB_8;
+
+long *mem_buf;
+
+MODULE_PARM_DESC(frontend_mode, "\n\t\t Frontend mode 0-DVBC, 1-DVBT");
+static int frontend_mode = -1;
+module_param(frontend_mode, int, 0444);
+
+MODULE_PARM_DESC(frontend_i2c, "\n\t\t IIc adapter id of frontend");
+static int frontend_i2c = -1;
+module_param(frontend_i2c, int, 0444);
+
+MODULE_PARM_DESC(frontend_tuner,
+		 "\n\t\t Frontend tuner type 0-NULL, 1-DCT7070, 2-Maxliner, 3-FJ2207, 4-TD1316");
+static int frontend_tuner = -1;
+module_param(frontend_tuner, int, 0444);
+
+MODULE_PARM_DESC(frontend_tuner_addr, "\n\t\t Tuner IIC address of frontend");
+static int frontend_tuner_addr = -1;
+module_param(frontend_tuner_addr, int, 0444);
+static int autoflags, autoFlagsTrig;
+static struct mutex aml_lock;
+
+static int Gxtv_Demod_Dvbc_Init(struct aml_fe_dev *dev, int mode);
+
+static ssize_t dvbc_auto_sym_show(struct class *cls,
+				  struct class_attribute *attr, char *buf)
+{
+	return sprintf(buf, "dvbc_autoflags: %s\n", autoflags ? "on" : "off");
+}
+
+static ssize_t dvbc_auto_sym_store(struct class *cls,
+				   struct class_attribute *attr,
+				   const char *buf, size_t count)
+{
+
+	return 0;
+}
+
+static unsigned int dtmb_mode;
+
+enum {
+	DTMB_READ_STRENGTH = 0,
+	DTMB_READ_SNR = 1,
+	DTMB_READ_LOCK = 2,
+	DTMB_READ_BCH = 3,
+};
+
+
+
+int convert_snr(int in_snr)
+{
+	int out_snr;
+	static int calce_snr[40] = {
+		5, 6, 8, 10, 13,
+		16, 20, 25, 32, 40,
+		50, 63, 80, 100, 126,
+		159, 200, 252, 318, 400,
+		504, 634, 798, 1005, 1265,
+		1592, 2005, 2524, 3177, 4000,
+		5036, 6340, 7981, 10048, 12649,
+		15924, 20047, 25238, 31773, 40000};
+	for (out_snr = 1 ; out_snr <= 40; out_snr++)
+		if (in_snr <= calce_snr[out_snr])
+			break;
+
+	return out_snr;
+}
+
+
+static ssize_t dtmb_para_show(struct class *cls,
+				  struct class_attribute *attr, char *buf)
+{
+	int snr, lock_status, bch, agc_if_gain;
+	struct dvb_frontend *dvbfe;
+	int strength = 0;
+
+	if (dtmb_mode == DTMB_READ_STRENGTH) {
+		dvbfe = get_si2177_tuner();
+		if (dvbfe != NULL)
+			if (dvbfe->ops.tuner_ops.get_strength) {
+				strength =
+				dvbfe->ops.tuner_ops.get_strength(dvbfe);
+			}
+		if (strength <= -56) {
+			agc_if_gain =
+				((dtmb_read_reg(DTMB_TOP_FRONT_AGC))&0x3ff);
+			strength = dtmb_get_power_strength(agc_if_gain);
+		}
+		return sprintf(buf, "strength is %d\n", strength);
+	} else if (dtmb_mode == DTMB_READ_SNR) {
+		snr = dtmb_read_reg(DTMB_TOP_FEC_LOCK_SNR) & 0x3fff;
+		snr = convert_snr(snr);
+		return sprintf(buf, "snr is %d\n", snr);
+	} else if (dtmb_mode == DTMB_READ_LOCK) {
+		lock_status =
+			(dtmb_read_reg(DTMB_TOP_FEC_LOCK_SNR) >> 14) & 0x1;
+		return sprintf(buf, "lock_status is %d\n", lock_status);
+	} else if (dtmb_mode == DTMB_READ_BCH) {
+		bch = dtmb_read_reg(DTMB_TOP_FEC_BCH_ACC);
+		return sprintf(buf, "bch is %d\n", bch);
+	} else {
+		return sprintf(buf, "dtmb_para_show can't match mode\n");
+	}
+}
+
+
+
+static ssize_t dtmb_para_store(struct class *cls,
+				   struct class_attribute *attr,
+				   const char *buf, size_t count)
+{
+	if (buf[0] == '0')
+		dtmb_mode = DTMB_READ_STRENGTH;
+	else if (buf[0] == '1')
+		dtmb_mode = DTMB_READ_SNR;
+	else if (buf[0] == '2')
+		dtmb_mode = DTMB_READ_LOCK;
+	else if (buf[0] == '3')
+		dtmb_mode = DTMB_READ_BCH;
+
+	return count;
+}
+
+static int readregdata;
+
+static ssize_t dvbc_reg_show(struct class *cls, struct class_attribute *attr,
+			     char *buf)
+{
+/*      int readregaddr=0;*/
+	char *pbuf = buf;
+
+	pbuf += sprintf(pbuf, "%x", readregdata);
+
+	pr_dbg("read dvbc_reg\n");
+	return pbuf - buf;
+}
+
+static ssize_t dvbc_reg_store(struct class *cls, struct class_attribute *attr,
+			      const char *buf, size_t count)
+{
+	return 0;
+}
+
+static CLASS_ATTR(auto_sym, 0644, dvbc_auto_sym_show, dvbc_auto_sym_store);
+static CLASS_ATTR(dtmb_para, 0644, dtmb_para_show, dtmb_para_store);
+static CLASS_ATTR(dvbc_reg, 0644, dvbc_reg_show, dvbc_reg_store);
+
+#if 0
+static irqreturn_t amdemod_isr(int irq, void *data)
+{
+/*	struct aml_fe_dev *state = data;
+ *
+ * #define dvb_isr_islock() (((frontend_mode==0)&&dvbc_isr_islock()) \
+ * ||((frontend_mode==1)&&dvbt_isr_islock()))
+ * #define dvb_isr_monitor() do {\
+ *              if(frontend_mode==1) dvbt_isr_monitor(); }while(0)
+ * #define dvb_isr_cancel() do { if(frontend_mode==1) dvbt_isr_cancel(); \
+ *              else if(frontend_mode==0) dvbc_isr_cancel();}while(0)
+ *
+ *      dvb_isr_islock();
+ *      {
+ *              if(waitqueue_active(&state->lock_wq))
+ *                      wake_up_interruptible(&state->lock_wq);
+ *      }
+ *
+ *      dvb_isr_monitor();
+ *
+ *      dvb_isr_cancel();
+ */
+
+	return IRQ_HANDLED;
+}
+#endif
+
+static int install_isr(struct aml_fe_dev *state)
+{
+	int r = 0;
+
+	/* hook demod isr */
+/*	pr_dbg("amdemod irq register[IRQ(%d)].\n", INT_DEMOD);
+ *      r = request_irq(INT_DEMOD, &amdemod_isr,
+ *                              IRQF_SHARED, "amldemod",
+ *                              (void *)state);
+ *      if (r) {
+ *              pr_error("amdemod irq register error.\n");
+ *      }
+ */
+	return r;
+}
+
+
+static int amdemod_qam(fe_modulation_t qam)
+{
+	switch (qam) {
+	case QAM_16:
+		return 0;
+	case QAM_32:
+		return 1;
+	case QAM_64:
+		return 2;
+	case QAM_128:
+		return 3;
+	case QAM_256:
+		return 4;
+	case VSB_8:
+		return 5;
+	case QAM_AUTO:
+		return 6;
+	default:
+		return 2;
+	}
+	return 2;
+}
+
+static int amdemod_stat_islock(struct aml_fe_dev *dev, int mode)
+{
+	struct aml_demod_sts demod_sts;
+	int lock_status;
+	int dvbt_status1;
+
+	if (mode == 0) {
+		/*DVBC*/
+		/*dvbc_status(state->sta, state->i2c, &demod_sts);*/
+		demod_sts.ch_sts = apb_read_reg(QAM_BASE + 0x18);
+		return demod_sts.ch_sts & 0x1;
+	} else if (mode == 1) {
+		/*DVBT*/
+		dvbt_status1 =
+			((apb_read_reg(DVBT_BASE + (0x0a << 2)) >> 20) & 0x3ff);
+		lock_status = (apb_read_reg(DVBT_BASE + (0x2a << 2))) & 0xf;
+		if ((((lock_status) == 9) || ((lock_status) == 10))
+		    && ((dvbt_status1) != 0))
+			return 1;
+		else
+			return 0;
+		/*((apb_read_reg(DVBT_BASE+0x0)>>12)&0x1);//
+		 * dvbt_get_status_ops()->get_status(&demod_sts, &demod_sta);
+		 */
+	} else if (mode == 2) {
+		/*ISDBT*/
+		/*return dvbt_get_status_ops()->get_status
+		 * (demod_sts, demod_sta);
+		 */
+	} else if (mode == 3) {
+		/*ATSC*/
+		if ((atsc_mode == QAM_64) || (atsc_mode == QAM_256))
+			return (atsc_read_iqr_reg() >> 16) == 0x1f;
+		else if (atsc_mode == VSB_8)
+			return atsc_read_reg(0x0980) == 0x79;
+		else
+			return (atsc_read_iqr_reg() >> 16) == 0x1f;
+	} else if (mode == 4) {
+		/*DTMB*/
+	/*	pr_dbg("DTMB lock status is %u\n",
+	 *	       ((dtmb_read_reg(DTMB_BASE + (0x0e3 << 2)) >> 14) &
+	 *		0x1));
+	 */
+		return (dtmb_read_reg(DTMB_BASE + (0x0e3 << 2)) >> 14) & 0x1;
+	}
+	return 0;
+}
+
+#define amdemod_dvbc_stat_islock(dev)  amdemod_stat_islock((dev), 0)
+#define amdemod_dvbt_stat_islock(dev)  amdemod_stat_islock((dev), 1)
+#define amdemod_isdbt_stat_islock(dev)  amdemod_stat_islock((dev), 2)
+#define amdemod_atsc_stat_islock(dev)  amdemod_stat_islock((dev), 3)
+#define amdemod_dtmb_stat_islock(dev)  amdemod_stat_islock((dev), 4)
+
+static int gxtv_demod_dvbc_set_qam_mode(struct dvb_frontend *fe)
+{
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
+	struct aml_demod_dvbc param;    /*mode 0:16, 1:32, 2:64, 3:128, 4:256*/
+
+	memset(&param, 0, sizeof(param));
+	param.mode = amdemod_qam(c->modulation);
+	dvbc_set_qam_mode(param.mode);
+	return 0;
+}
+
+static void gxtv_demod_dvbc_release(struct dvb_frontend *fe)
+{
+/*
+ *	struct aml_fe_dev *state = fe->demodulator_priv;
+ *
+ *	uninstall_isr(state);
+ *
+ *	kfree(state);
+ */
+}
+
+static int gxtv_demod_dvbc_read_status
+	(struct dvb_frontend *fe, fe_status_t *status)
+{
+/*      struct aml_fe_dev *dev = afe->dtv_demod;*/
+	struct aml_demod_sts demod_sts;
+/*      struct aml_demod_sta demod_sta;*/
+/*      struct aml_demod_i2c demod_i2c;*/
+	int ilock;
+
+	demod_sts.ch_sts = apb_read_reg(QAM_BASE + 0x18);
+/*      dvbc_status(&demod_sta, &demod_i2c, &demod_sts);*/
+	if (demod_sts.ch_sts & 0x1) {
+		ilock = 1;
+		*status =
+			FE_HAS_LOCK | FE_HAS_SIGNAL | FE_HAS_CARRIER |
+			FE_HAS_VITERBI | FE_HAS_SYNC;
+	} else {
+		ilock = 0;
+		*status = FE_TIMEDOUT;
+	}
+	if (last_lock != ilock) {
+		pr_error("%s.\n",
+			 ilock ? "!!  >> LOCK << !!" : "!! >> UNLOCK << !!");
+		last_lock = ilock;
+	}
+
+	return 0;
+}
+
+static int gxtv_demod_dvbc_read_ber(struct dvb_frontend *fe, u32 *ber)
+{
+	/*struct aml_fe_dev *dev = afe->dtv_demod;*/
+	struct aml_demod_sts demod_sts;
+	struct aml_demod_i2c demod_i2c;
+	struct aml_demod_sta demod_sta;
+
+	dvbc_status(&demod_sta, &demod_i2c, &demod_sts);
+	*ber = demod_sts.ch_ber;
+	return 0;
+}
+
+static int gxtv_demod_dvbc_read_signal_strength
+	(struct dvb_frontend *fe, u16 *strength)
+{
+	struct aml_fe *afe = fe->demodulator_priv;
+	struct aml_fe_dev *dev = afe->dtv_demod;
+
+	*strength = 256 - tuner_get_ch_power(dev);
+
+	return 0;
+}
+
+static int gxtv_demod_dvbc_read_snr(struct dvb_frontend *fe, u16 *snr)
+{
+	struct aml_demod_sts demod_sts;
+	struct aml_demod_i2c demod_i2c;
+	struct aml_demod_sta demod_sta;
+
+	dvbc_status(&demod_sta, &demod_i2c, &demod_sts);
+	*snr = demod_sts.ch_snr / 100;
+	return 0;
+}
+
+static int gxtv_demod_dvbc_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)
+{
+	*ucblocks = 0;
+	return 0;
+}
+
+/*extern int aml_fe_analog_set_frontend(struct dvb_frontend *fe);*/
+
+static int gxtv_demod_dvbc_set_frontend(struct dvb_frontend *fe)
+{
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
+	struct aml_demod_dvbc param;    /*mode 0:16, 1:32, 2:64, 3:128, 4:256*/
+	struct aml_demod_sts demod_sts;
+	struct aml_demod_i2c demod_i2c;
+	struct aml_fe *afe = fe->demodulator_priv;
+	struct aml_fe_dev *dev = afe->dtv_demod;
+	int error, times;
+
+	demod_i2c.tuner = dev->drv->id;
+	demod_i2c.addr = dev->i2c_addr;
+	times = 2;
+	memset(&param, 0, sizeof(param));
+	param.ch_freq = c->frequency / 1000;
+	param.mode = amdemod_qam(c->modulation);
+	param.symb_rate = c->symbol_rate / 1000;
+	if ((param.mode == 3) && (demod_status.tmp != Adc_mode)) {
+		Gxtv_Demod_Dvbc_Init(dev, Adc_mode);
+		pr_dbg("Gxtv_Demod_Dvbc_Init,Adc_mode\n");
+	} else {
+		/*Gxtv_Demod_Dvbc_Init(dev,Cry_mode);*/
+	}
+	if (autoflags == 0) {
+		/*pr_dbg("QAM_TUNING mode\n");*/
+		/*flag=0;*/
+	}
+	if ((autoflags == 1) && (autoFlagsTrig == 0)
+	    && (freq_dvbc == param.ch_freq)) {
+		pr_dbg("now is auto symbrating\n");
+		return 0;
+	}
+	autoFlagsTrig = 0;
+	last_lock = -1;
+	pr_dbg("[gxtv_demod_dvbc_set_frontend]PARA\t"
+	       "demod_i2c.tuner is %d||||demod_i2c.addr is %d||||\t"
+	       "param.ch_freq is %d||||param.symb_rate is %d,\t"
+	       "param.mode is %d\n",
+	       demod_i2c.tuner, demod_i2c.addr, param.ch_freq,
+	       param.symb_rate, param.mode);
+retry:
+	aml_dmx_before_retune(afe->ts, fe);
+	aml_fe_analog_set_frontend(fe);
+	dvbc_set_ch(&demod_status, &demod_i2c, &param);
+	if (autoflags == 1) {
+		pr_dbg("QAM_PLAYING mode,start auto sym\n");
+		dvbc_set_auto_symtrack();
+		/*      flag=1;*/
+	}
+/*rsj_debug*/
+
+	dvbc_status(&demod_status, &demod_i2c, &demod_sts);
+	freq_dvbc = param.ch_freq;
+
+	times--;
+	if (amdemod_dvbc_stat_islock(dev) && times) {
+		int lock;
+
+		aml_dmx_start_error_check(afe->ts, fe);
+		msleep(20);
+		error = aml_dmx_stop_error_check(afe->ts, fe);
+		lock = amdemod_dvbc_stat_islock(dev);
+		if ((error > 200) || !lock) {
+			pr_error
+				("amlfe too many error, error count:%d\t"
+				"lock statuc:%d, retry\n",
+				error, lock);
+			goto retry;
+		}
+	}
+
+	aml_dmx_after_retune(afe->ts, fe);
+
+	afe->params = *c;
+/*	afe->params.frequency = c->frequency;
+ *      afe->params.u.qam.symbol_rate = c->symbol_rate;
+ *      afe->params.u.qam.modulation = c->modulation;
+ */
+
+	pr_dbg("AML amldemod => frequency=%d,symbol_rate=%d\r\n", c->frequency,
+	       c->symbol_rate);
+	return 0;
+}
+
+static int gxtv_demod_dvbc_get_frontend(struct dvb_frontend *fe)
+{                               /*these content will be writed into eeprom .*/
+	struct aml_fe *afe = fe->demodulator_priv;
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
+	int qam_mode;
+
+	qam_mode = apb_read_reg(QAM_BASE + 0x008);
+	afe->params.modulation = (qam_mode & 7) + 1;
+	pr_dbg("[mode] is %d\n", afe->params.modulation);
+
+	*c = afe->params;
+/*	c->modulation= afe->params.u.qam.modulation;
+ *      c->frequency= afe->params.frequency;
+ *      c->symbol_rate= afe->params.u.qam.symbol_rate;
+ */
+	return 0;
+}
+
+static int Gxtv_Demod_Dvbc_Init(struct aml_fe_dev *dev, int mode)
+{
+	struct aml_demod_sys sys;
+	struct aml_demod_i2c i2c;
+
+	pr_dbg("AML Demod DVB-C init\r\n");
+	memset(&sys, 0, sizeof(sys));
+	memset(&i2c, 0, sizeof(i2c));
+	i2c.tuner = dev->drv->id;
+	i2c.addr = dev->i2c_addr;
+	/* 0 -DVBC, 1-DVBT, ISDBT, 2-ATSC*/
+	demod_status.dvb_mode = Gxtv_Dvbc;
+
+	if (mode == Adc_mode) {
+		sys.adc_clk = Adc_Clk_25M;
+		sys.demod_clk = Demod_Clk_200M;
+		demod_status.tmp = Adc_mode;
+	} else {
+		sys.adc_clk = Adc_Clk_24M;
+		sys.demod_clk = Demod_Clk_72M;
+		demod_status.tmp = Cry_mode;
+	}
+	demod_status.ch_if = Si2176_5M_If * 1000;
+	pr_dbg("[%s]adc_clk is %d,demod_clk is %d\n", __func__, sys.adc_clk,
+	       sys.demod_clk);
+	autoFlagsTrig = 0;
+	demod_set_sys(&demod_status, &i2c, &sys);
+	return 0;
+}
+
+static void gxtv_demod_dvbt_release(struct dvb_frontend *fe)
+{
+/*
+ *	struct aml_fe_dev *state = fe->demodulator_priv;
+ *
+ *	uninstall_isr(state);
+ *
+ *	kfree(state);
+ */
+}
+
+static int gxtv_demod_dvbt_read_status
+	(struct dvb_frontend *fe, fe_status_t *status)
+{
+/*      struct aml_fe *afe = fe->demodulator_priv;*/
+	struct aml_demod_i2c demod_i2c;
+	struct aml_demod_sta demod_sta;
+	int ilock;
+	unsigned char s = 0;
+
+	s = dvbt_get_status_ops()->get_status(&demod_sta, &demod_i2c);
+	if (s == 1) {
+		ilock = 1;
+		*status =
+			FE_HAS_LOCK | FE_HAS_SIGNAL | FE_HAS_CARRIER |
+			FE_HAS_VITERBI | FE_HAS_SYNC;
+	} else {
+		ilock = 0;
+		*status = FE_TIMEDOUT;
+	}
+	if (last_lock != ilock) {
+		pr_error("%s.\n",
+			 ilock ? "!!  >> LOCK << !!" : "!! >> UNLOCK << !!");
+		last_lock = ilock;
+	}
+
+	return 0;
+}
+
+static int gxtv_demod_dvbt_read_ber(struct dvb_frontend *fe, u32 *ber)
+{
+/*      struct aml_fe *afe = fe->demodulator_priv;*/
+	struct aml_demod_i2c demod_i2c;
+	struct aml_demod_sta demod_sta;
+
+	*ber = dvbt_get_status_ops()->get_ber(&demod_sta, &demod_i2c) & 0xffff;
+	return 0;
+}
+
+static int gxtv_demod_dvbt_read_signal_strength
+	(struct dvb_frontend *fe, u16 *strength)
+{
+	struct aml_fe *afe = fe->demodulator_priv;
+	struct aml_fe_dev *dev = afe->dtv_demod;
+
+	*strength = 256 - tuner_get_ch_power(dev);
+	pr_dbg("[RSJ]tuner strength is %d dbm\n", *strength);
+	return 0;
+}
+
+static int gxtv_demod_dvbt_read_snr(struct dvb_frontend *fe, u16 *snr)
+{
+/*      struct aml_fe *afe = fe->demodulator_priv;*/
+/*      struct aml_demod_sts demod_sts;*/
+	struct aml_demod_i2c demod_i2c;
+	struct aml_demod_sta demod_sta;
+
+	*snr = dvbt_get_status_ops()->get_snr(&demod_sta, &demod_i2c);
+	*snr /= 8;
+	pr_dbg("[RSJ]snr is %d dbm\n", *snr);
+	return 0;
+}
+
+static int gxtv_demod_dvbt_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)
+{
+	*ucblocks = 0;
+	return 0;
+}
+
+static int gxtv_demod_dvbt_set_frontend(struct dvb_frontend *fe)
+{
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
+	/*struct aml_demod_sts demod_sts;*/
+	struct aml_demod_i2c demod_i2c;
+	int error, times;
+	struct aml_demod_dvbt param;
+	struct aml_fe *afe = fe->demodulator_priv;
+	struct aml_fe_dev *dev = afe->dtv_demod;
+
+	demod_i2c.tuner = dev->drv->id;
+	demod_i2c.addr = dev->i2c_addr;
+
+	times = 2;
+
+	/*////////////////////////////////////*/
+	/* bw == 0 : 8M*/
+	/*       1 : 7M*/
+	/*       2 : 6M*/
+	/*       3 : 5M*/
+	/* agc_mode == 0: single AGC*/
+	/*             1: dual AGC*/
+	/*////////////////////////////////////*/
+	memset(&param, 0, sizeof(param));
+	param.ch_freq = c->frequency / 1000;
+	param.bw = c->bandwidth_hz;
+	param.agc_mode = 1;
+	/*ISDBT or DVBT : 0 is QAM, 1 is DVBT, 2 is ISDBT,
+	 * 3 is DTMB, 4 is ATSC
+	 */
+	param.dat0 = 1;
+	last_lock = -1;
+
+retry:
+	aml_dmx_before_retune(AM_TS_SRC_TS2, fe);
+	aml_fe_analog_set_frontend(fe);
+	dvbt_set_ch(&demod_status, &demod_i2c, &param);
+
+	/*      for(count=0;count<10;count++){
+	 * if(amdemod_dvbt_stat_islock(dev)){
+	 * pr_dbg("first lock success\n");
+	 * break;
+	 * }
+	 *
+	 * msleep(200);
+	 * }
+	 */
+/*rsj_debug*/
+
+/**/
+
+	times--;
+	if (amdemod_dvbt_stat_islock(dev) && times) {
+		int lock;
+
+		aml_dmx_start_error_check(AM_TS_SRC_TS2, fe);
+		msleep(20);
+		error = aml_dmx_stop_error_check(AM_TS_SRC_TS2, fe);
+		lock = amdemod_dvbt_stat_islock(dev);
+		if ((error > 200) || !lock) {
+			pr_error
+				("amlfe too many error,\t"
+				"error count:%d lock statuc:%d, retry\n",
+				error, lock);
+			goto retry;
+		}
+	}
+
+	aml_dmx_after_retune(AM_TS_SRC_TS2, fe);
+
+	afe->params = *c;
+
+	/*pr_dbg("AML amldemod => frequency=%d,symbol_rate=%d\r\n",
+	 * p->frequency,p->u.qam.symbol_rate);
+	 */
+	return 0;
+}
+
+static int gxtv_demod_dvbt_get_frontend(struct dvb_frontend *fe)
+{                               /*these content will be writed into eeprom .*/
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
+	struct aml_fe *afe = fe->demodulator_priv;
+
+	*c = afe->params;
+	return 0;
+}
+
+int Gxtv_Demod_Dvbt_Init(struct aml_fe_dev *dev)
+{
+	struct aml_demod_sys sys;
+	struct aml_demod_i2c i2c;
+
+	pr_dbg("AML Demod DVB-T init\r\n");
+
+	memset(&sys, 0, sizeof(sys));
+	memset(&i2c, 0, sizeof(i2c));
+	memset(&demod_status, 0, sizeof(demod_status));
+	i2c.tuner = dev->drv->id;
+	i2c.addr = dev->i2c_addr;
+	/* 0 -DVBC, 1-DVBT, ISDBT, 2-ATSC*/
+	demod_status.dvb_mode = Gxtv_Dvbt_Isdbt;
+	sys.adc_clk = Adc_Clk_24M;
+	sys.demod_clk = Demod_Clk_60M;
+	demod_status.ch_if = Si2176_5M_If * 1000;
+	demod_set_sys(&demod_status, &i2c, &sys);
+	return 0;
+}
+
+static void gxtv_demod_atsc_release(struct dvb_frontend *fe)
+{
+/*
+ *	struct aml_fe_dev *state = fe->demodulator_priv;
+ *
+ *	uninstall_isr(state);
+ *
+ *	kfree(state);
+ */
+}
+
+static int gxtv_demod_atsc_set_qam_mode(struct dvb_frontend *fe)
+{
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
+	struct aml_demod_atsc param;    /*mode  3:64,  5:256, 7:vsb*/
+	fe_modulation_t mode;
+
+	memset(&param, 0, sizeof(param));
+	mode = c->modulation;
+	pr_dbg("mode is %d\n", mode);
+	atsc_qam_set(mode);
+	return 0;
+}
+
+static int gxtv_demod_atsc_read_status
+	(struct dvb_frontend *fe, fe_status_t *status)
+{
+	struct aml_fe *afe = fe->demodulator_priv;
+	struct aml_fe_dev *dev = afe->dtv_demod;
+/*      struct aml_demod_i2c demod_i2c;*/
+/*      struct aml_demod_sta demod_sta;*/
+	int ilock;
+	unsigned char s = 0;
+
+	s = amdemod_atsc_stat_islock(dev);
+	if (s == 1) {
+		ilock = 1;
+		*status =
+			FE_HAS_LOCK | FE_HAS_SIGNAL | FE_HAS_CARRIER |
+			FE_HAS_VITERBI | FE_HAS_SYNC;
+	} else {
+		ilock = 0;
+		*status = FE_TIMEDOUT;
+	}
+	if (last_lock != ilock) {
+		pr_error("%s.\n",
+			 ilock ? "!!  >> LOCK << !!" : "!! >> UNLOCK << !!");
+		last_lock = ilock;
+	}
+
+	return 0;
+}
+
+static int gxtv_demod_atsc_read_ber(struct dvb_frontend *fe, u32 *ber)
+{
+/*      struct aml_fe *afe = fe->demodulator_priv;*/
+/*      struct aml_fe_dev *dev = afe->dtv_demod;*/
+/*      struct aml_demod_sts demod_sts;*/
+/*      struct aml_demod_i2c demod_i2c;*/
+/*      struct aml_demod_sta demod_sta;*/
+
+/* check_atsc_fsm_status();*/
+	return 0;
+}
+
+static int gxtv_demod_atsc_read_signal_strength
+	(struct dvb_frontend *fe, u16 *strength)
+{
+	struct aml_fe *afe = fe->demodulator_priv;
+	struct aml_fe_dev *dev = afe->dtv_demod;
+
+	*strength = tuner_get_ch_power(dev);
+	return 0;
+}
+
+static int gxtv_demod_atsc_read_snr(struct dvb_frontend *fe, u16 *snr)
+{
+/*      struct aml_fe *afe = fe->demodulator_priv;*/
+/*      struct aml_fe_dev *dev = afe->dtv_demod;*/
+
+/*      struct aml_demod_sts demod_sts;*/
+/*      struct aml_demod_i2c demod_i2c;*/
+/*      struct aml_demod_sta demod_sta;*/
+
+/*      * snr=check_atsc_fsm_status();*/
+	return 0;
+}
+
+static int gxtv_demod_atsc_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)
+{
+	*ucblocks = 0;
+	return 0;
+}
+
+static int gxtv_demod_atsc_set_frontend(struct dvb_frontend *fe)
+{
+/*      struct amlfe_state *state = fe->demodulator_priv;*/
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
+	struct aml_demod_atsc param;
+/*      struct aml_demod_sta demod_sta;*/
+/*      struct aml_demod_sts demod_sts;*/
+	struct aml_demod_i2c demod_i2c;
+	int error, times;
+	struct aml_fe *afe = fe->demodulator_priv;
+	struct aml_fe_dev *dev = afe->dtv_demod;
+
+	demod_i2c.tuner = dev->drv->id;
+	demod_i2c.addr = dev->i2c_addr;
+	times = 2;
+
+	memset(&param, 0, sizeof(param));
+	param.ch_freq = c->frequency / 1000;
+
+	last_lock = -1;
+	/*p->u.vsb.modulation=QAM_64;*/
+	atsc_mode = c->modulation;
+	/* param.mode = amdemod_qam(p->u.vsb.modulation);*/
+	param.mode = c->modulation;
+
+retry:
+	aml_dmx_before_retune(AM_TS_SRC_TS2, fe);
+	aml_fe_analog_set_frontend(fe);
+	atsc_set_ch(&demod_status, &demod_i2c, &param);
+
+	/*{
+	 * int ret;
+	 * ret = wait_event_interruptible_timeout(
+	 *              dev->lock_wq, amdemod_atsc_stat_islock(dev), 4*HZ);
+	 * if(!ret)     pr_error("amlfe wait lock timeout.\n");
+	 * }
+	 */
+/*rsj_debug*/
+	/*      int count;
+	 * for(count=0;count<10;count++){
+	 * if(amdemod_atsc_stat_islock(dev)){
+	 * pr_dbg("first lock success\n");
+	 * break;
+	 * }
+	 *
+	 * msleep(200);
+	 * }
+	 */
+
+	times--;
+	if (amdemod_atsc_stat_islock(dev) && times) {
+		int lock;
+
+		aml_dmx_start_error_check(AM_TS_SRC_TS2, fe);
+		msleep(20);
+		error = aml_dmx_stop_error_check(AM_TS_SRC_TS2, fe);
+		lock = amdemod_atsc_stat_islock(dev);
+		if ((error > 200) || !lock) {
+			pr_error
+				("amlfe too many error,\t"
+				"error count:%d lock statuc:%d, retry\n",
+				error, lock);
+			goto retry;
+		}
+	}
+
+	aml_dmx_after_retune(AM_TS_SRC_TS2, fe);
+
+	afe->params = *c;
+	/*pr_dbg("AML amldemod => frequency=%d,symbol_rate=%d\r\n",
+	 * p->frequency,p->u.qam.symbol_rate);
+	 */
+	return 0;
+}
+
+static int gxtv_demod_atsc_get_frontend(struct dvb_frontend *fe)
+{                               /*these content will be writed into eeprom .*/
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
+	struct aml_fe *afe = fe->demodulator_priv;
+
+	pr_dbg("c->frequency is %d\n", c->frequency);
+	*c = afe->params;
+	return 0;
+}
+
+int Gxtv_Demod_Atsc_Init(struct aml_fe_dev *dev)
+{
+	struct aml_demod_sys sys;
+	struct aml_demod_i2c i2c;
+
+	pr_dbg("AML Demod ATSC init\r\n");
+
+	memset(&sys, 0, sizeof(sys));
+	memset(&i2c, 0, sizeof(i2c));
+	memset(&demod_status, 0, sizeof(demod_status));
+	/* 0 -DVBC, 1-DVBT, ISDBT, 2-ATSC*/
+	demod_status.dvb_mode = Gxtv_Atsc;
+	sys.adc_clk = Adc_Clk_25_2M;    /*Adc_Clk_26M;*/
+	sys.demod_clk = Demod_Clk_75M;  /*Demod_Clk_71M;//Demod_Clk_78M;*/
+	demod_status.ch_if = 6350;
+	demod_status.tmp = Adc_mode;
+	demod_set_sys(&demod_status, &i2c, &sys);
+	return 0;
+}
+
+static void gxtv_demod_dtmb_release(struct dvb_frontend *fe)
+{
+/*
+ *	struct aml_fe_dev *state = fe->demodulator_priv;
+ *
+ *	uninstall_isr(state);
+ *
+ *	kfree(state);
+ */
+}
+
+static int gxtv_demod_dtmb_read_status
+	(struct dvb_frontend *fe, fe_status_t *status)
+{
+	struct aml_fe *afe = fe->demodulator_priv;
+	struct aml_fe_dev *dev = afe->dtv_demod;
+/*      struct aml_demod_i2c demod_i2c;*/
+/*      struct aml_demod_sta demod_sta;*/
+	int ilock;
+	unsigned char s = 0;
+
+/*      s = amdemod_dtmb_stat_islock(dev);*/
+/*      if(s==1)*/
+	if (is_meson_txl_cpu())
+		s = dtmb_check_status_txl(fe);
+	else
+		s = dtmb_check_status_gxtv(fe);
+	s = amdemod_dtmb_stat_islock(dev);
+/*      s=1;*/
+	if (s == 1) {
+		ilock = 1;
+		*status =
+			FE_HAS_LOCK | FE_HAS_SIGNAL | FE_HAS_CARRIER |
+			FE_HAS_VITERBI | FE_HAS_SYNC;
+	} else {
+		ilock = 0;
+		*status = FE_TIMEDOUT;
+	}
+	if (last_lock != ilock) {
+		pr_error("%s.\n",
+			 ilock ? "!!  >> LOCK << !!" : "!! >> UNLOCK << !!");
+		last_lock = ilock;
+	}
+
+	return 0;
+}
+
+static int gxtv_demod_dtmb_read_ber(struct dvb_frontend *fe, u32 *ber)
+{
+/*      struct aml_fe *afe = fe->demodulator_priv;*/
+/*      struct aml_fe_dev *dev = afe->dtv_demod;*/
+/*      struct aml_demod_sts demod_sts;*/
+/*      struct aml_demod_i2c demod_i2c;*/
+/*      struct aml_demod_sta demod_sta;*/
+
+/* check_atsc_fsm_status();*/
+/* int fec_bch_add; */
+/* fec_bch_add = dtmb_read_reg(0xdf); */
+/* *ber = fec_bch_add; */
+	return 0;
+}
+
+static int gxtv_demod_dtmb_read_signal_strength
+		(struct dvb_frontend *fe, u16 *strength)
+{
+	struct aml_fe *afe = fe->demodulator_priv;
+	struct aml_fe_dev *dev = afe->dtv_demod;
+
+	*strength = tuner_get_ch_power(dev);
+	return 0;
+}
+
+static int gxtv_demod_dtmb_read_snr(struct dvb_frontend *fe, u16 *snr)
+{
+/*      struct aml_fe *afe = fe->demodulator_priv;*/
+/*      struct aml_fe_dev *dev = afe->dtv_demod;*/
+#if 1
+	int tmp, snr_avg;
+
+	tmp = snr_avg = 0;
+	tmp = dtmb_read_reg(DTMB_TOP_FEC_LOCK_SNR);
+/*	snr_avg = (tmp >> 16) & 0x3fff;
+ *	if (snr_avg >= 2048)
+ *		snr_avg = snr_avg - 4096;
+ *	snr_avg = snr_avg / 32;
+ */
+	*snr = tmp&0xff;
+#endif
+	return 0;
+}
+
+static int gxtv_demod_dtmb_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)
+{
+	*ucblocks = 0;
+	return 0;
+}
+
+static int gxtv_demod_dtmb_read_fsm(struct dvb_frontend *fe, u32 *fsm_status)
+{
+	int tmp;
+
+	tmp = dtmb_read_reg(DTMB_TOP_CTRL_FSM_STATE0);
+	*fsm_status =  tmp&0xffffffff;
+	pr_dbg("[rsj] fsm_status is %x\n", *fsm_status);
+	return 0;
+}
+
+
+static int gxtv_demod_dtmb_set_frontend(struct dvb_frontend *fe)
+{
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
+	struct aml_demod_dtmb param;
+/*      struct aml_demod_sta demod_sta;*/
+/*      struct aml_demod_sts demod_sts;*/
+	struct aml_demod_i2c demod_i2c;
+	int times;
+	struct aml_fe *afe = fe->demodulator_priv;
+	struct aml_fe_dev *dev = afe->dtv_demod;
+
+	demod_i2c.tuner = dev->drv->id;
+	demod_i2c.addr = dev->i2c_addr;
+	times = 2;
+	pr_dbg("gxtv_demod_dtmb_set_frontend,freq is %d\n", c->frequency);
+	memset(&param, 0, sizeof(param));
+	param.ch_freq = c->frequency / 1000;
+
+	last_lock = -1;
+/* demod_power_switch(PWR_OFF); */
+	aml_fe_analog_set_frontend(fe);
+	msleep(100);
+/* demod_power_switch(PWR_ON); */
+	dtmb_set_ch(&demod_status, &demod_i2c, &param);
+	afe->params = *c;
+	/*      pr_dbg("AML amldemod => frequency=%d,symbol_rate=%d\r\n",
+	 * p->frequency,p->u.qam.symbol_rate);
+	 */
+	return 0;
+}
+
+static int gxtv_demod_dtmb_get_frontend(struct dvb_frontend *fe)
+{                               /*these content will be writed into eeprom .*/
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
+	struct aml_fe *afe = fe->demodulator_priv;
+
+	*c = afe->params;
+/*      pr_dbg("[get frontend]c->frequency is %d\n",c->frequency);*/
+	return 0;
+}
+
+int Gxtv_Demod_Dtmb_Init(struct aml_fe_dev *dev)
+{
+	struct aml_demod_sys sys;
+	struct aml_demod_i2c i2c;
+
+	pr_dbg("AML Demod DTMB init\r\n");
+
+	memset(&sys, 0, sizeof(sys));
+	memset(&i2c, 0, sizeof(i2c));
+	memset(&demod_status, 0, sizeof(demod_status));
+	/* 0 -DVBC, 1-DVBT, ISDBT, 2-ATSC*/
+	demod_status.dvb_mode = Gxtv_Dtmb;
+	if (is_meson_txl_cpu()) {
+		sys.adc_clk = Adc_Clk_25M;      /*Adc_Clk_26M;*/
+		sys.demod_clk = Demod_Clk_225M;
+	} else {
+		sys.adc_clk = Adc_Clk_25M;      /*Adc_Clk_26M;*/
+		sys.demod_clk = Demod_Clk_200M;
+	}
+	demod_status.ch_if = Si2176_5M_If;
+	demod_status.tmp = Adc_mode;
+	demod_status.spectrum = dev->spectrum;
+	demod_set_sys(&demod_status, &i2c, &sys);
+	return 0;
+}
+
+static int gxtv_demod_fe_get_ops(struct aml_fe_dev *dev, int mode, void *ops)
+{
+	struct dvb_frontend_ops *fe_ops = (struct dvb_frontend_ops *)ops;
+
+	if (mode == AM_FE_OFDM) {
+		fe_ops->info.frequency_min = 51000000;
+		fe_ops->info.frequency_max = 858000000;
+		fe_ops->info.frequency_stepsize = 0;
+		fe_ops->info.frequency_tolerance = 0;
+		fe_ops->info.caps =
+			FE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 | FE_CAN_FEC_3_4 |
+			FE_CAN_FEC_5_6 | FE_CAN_FEC_7_8 | FE_CAN_FEC_AUTO |
+			FE_CAN_QPSK | FE_CAN_QAM_16 | FE_CAN_QAM_64 |
+			FE_CAN_QAM_AUTO | FE_CAN_TRANSMISSION_MODE_AUTO |
+			FE_CAN_GUARD_INTERVAL_AUTO | FE_CAN_HIERARCHY_AUTO |
+			FE_CAN_RECOVER | FE_CAN_MUTE_TS;
+		fe_ops->release = gxtv_demod_dvbt_release;
+		fe_ops->set_frontend = gxtv_demod_dvbt_set_frontend;
+		fe_ops->get_frontend = gxtv_demod_dvbt_get_frontend;
+		fe_ops->read_status = gxtv_demod_dvbt_read_status;
+		fe_ops->read_ber = gxtv_demod_dvbt_read_ber;
+		fe_ops->read_signal_strength =
+			gxtv_demod_dvbt_read_signal_strength;
+		fe_ops->read_snr = gxtv_demod_dvbt_read_snr;
+		fe_ops->read_ucblocks = gxtv_demod_dvbt_read_ucblocks;
+		fe_ops->read_dtmb_fsm = NULL;
+
+		pr_dbg("=========================dvbt demod init\r\n");
+		Gxtv_Demod_Dvbt_Init(dev);
+	} else if (mode == AM_FE_QAM) {
+		fe_ops->info.frequency_min = 51000000;
+		fe_ops->info.frequency_max = 858000000;
+		fe_ops->info.frequency_stepsize = 0;
+		fe_ops->info.frequency_tolerance = 0;
+		fe_ops->info.caps =
+			FE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 | FE_CAN_FEC_3_4 |
+			FE_CAN_FEC_5_6 | FE_CAN_FEC_7_8 | FE_CAN_FEC_AUTO |
+			FE_CAN_QPSK | FE_CAN_QAM_16 | FE_CAN_QAM_32 |
+			FE_CAN_QAM_128 | FE_CAN_QAM_256 | FE_CAN_QAM_64 |
+			FE_CAN_QAM_AUTO | FE_CAN_TRANSMISSION_MODE_AUTO |
+			FE_CAN_GUARD_INTERVAL_AUTO | FE_CAN_HIERARCHY_AUTO |
+			FE_CAN_RECOVER | FE_CAN_MUTE_TS;
+
+		fe_ops->release = gxtv_demod_dvbc_release;
+		fe_ops->set_frontend = gxtv_demod_dvbc_set_frontend;
+		fe_ops->get_frontend = gxtv_demod_dvbc_get_frontend;
+		fe_ops->read_status = gxtv_demod_dvbc_read_status;
+		fe_ops->read_ber = gxtv_demod_dvbc_read_ber;
+		fe_ops->read_signal_strength =
+			gxtv_demod_dvbc_read_signal_strength;
+		fe_ops->read_snr = gxtv_demod_dvbc_read_snr;
+		fe_ops->read_ucblocks = gxtv_demod_dvbc_read_ucblocks;
+		fe_ops->set_qam_mode = gxtv_demod_dvbc_set_qam_mode;
+		fe_ops->read_dtmb_fsm = NULL;
+		install_isr(dev);
+		pr_dbg("=========================dvbc demod init\r\n");
+		Gxtv_Demod_Dvbc_Init(dev, Adc_mode);
+	} else if (mode == AM_FE_ATSC) {
+		fe_ops->info.frequency_min = 51000000;
+		fe_ops->info.frequency_max = 858000000;
+		fe_ops->info.frequency_stepsize = 0;
+		fe_ops->info.frequency_tolerance = 0;
+		fe_ops->info.caps =
+			FE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 | FE_CAN_FEC_3_4 |
+			FE_CAN_FEC_5_6 | FE_CAN_FEC_7_8 | FE_CAN_FEC_AUTO |
+			FE_CAN_QPSK | FE_CAN_QAM_16 | FE_CAN_QAM_64 |
+			FE_CAN_QAM_AUTO | FE_CAN_TRANSMISSION_MODE_AUTO |
+			FE_CAN_GUARD_INTERVAL_AUTO | FE_CAN_HIERARCHY_AUTO |
+			FE_CAN_RECOVER | FE_CAN_MUTE_TS;
+
+		fe_ops->release = gxtv_demod_atsc_release;
+		fe_ops->set_frontend = gxtv_demod_atsc_set_frontend;
+		fe_ops->get_frontend = gxtv_demod_atsc_get_frontend;
+		fe_ops->read_status = gxtv_demod_atsc_read_status;
+		fe_ops->read_ber = gxtv_demod_atsc_read_ber;
+		fe_ops->read_signal_strength =
+			gxtv_demod_atsc_read_signal_strength;
+		fe_ops->read_snr = gxtv_demod_atsc_read_snr;
+		fe_ops->read_ucblocks = gxtv_demod_atsc_read_ucblocks;
+		fe_ops->set_qam_mode = gxtv_demod_atsc_set_qam_mode;
+		fe_ops->read_dtmb_fsm = NULL;
+		Gxtv_Demod_Atsc_Init(dev);
+	} else if (mode == AM_FE_DTMB) {
+		fe_ops->info.frequency_min = 51000000;
+		fe_ops->info.frequency_max = 900000000;
+		fe_ops->info.frequency_stepsize = 0;
+		fe_ops->info.frequency_tolerance = 0;
+		fe_ops->info.caps =
+			FE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 | FE_CAN_FEC_3_4 |
+			FE_CAN_FEC_5_6 | FE_CAN_FEC_7_8 | FE_CAN_FEC_AUTO |
+			FE_CAN_QPSK | FE_CAN_QAM_16 | FE_CAN_QAM_64 |
+			FE_CAN_QAM_AUTO | FE_CAN_TRANSMISSION_MODE_AUTO |
+			FE_CAN_GUARD_INTERVAL_AUTO | FE_CAN_HIERARCHY_AUTO |
+			FE_CAN_RECOVER | FE_CAN_MUTE_TS;
+
+		fe_ops->release = gxtv_demod_dtmb_release;
+		fe_ops->set_frontend = gxtv_demod_dtmb_set_frontend;
+		fe_ops->get_frontend = gxtv_demod_dtmb_get_frontend;
+		fe_ops->read_status = gxtv_demod_dtmb_read_status;
+		fe_ops->read_ber = gxtv_demod_dtmb_read_ber;
+		fe_ops->read_signal_strength =
+			gxtv_demod_dtmb_read_signal_strength;
+		fe_ops->read_snr = gxtv_demod_dtmb_read_snr;
+		fe_ops->read_ucblocks = gxtv_demod_dtmb_read_ucblocks;
+		fe_ops->read_dtmb_fsm = gxtv_demod_dtmb_read_fsm;
+		Gxtv_Demod_Dtmb_Init(dev);
+	}
+	return 0;
+}
+
+static int gxtv_demod_fe_resume(struct aml_fe_dev *dev)
+{
+	int memstart_dtmb;
+
+	pr_inf("gxtv_demod_fe_resume\n");
+/*	demod_power_switch(PWR_ON);*/
+	Gxtv_Demod_Dtmb_Init(dev);
+	memstart_dtmb = dev->fe->dtv_demod->mem_start;
+	pr_dbg("[im]memstart is %x\n", memstart_dtmb);
+	dtmb_write_reg(DTMB_FRONT_MEM_ADDR, memstart_dtmb);
+	pr_dbg("[dtmb]mem_buf is 0x%x\n",
+	dtmb_read_reg(DTMB_FRONT_MEM_ADDR));
+	return 0;
+}
+
+static int gxtv_demod_fe_suspend(struct aml_fe_dev *dev)
+{
+	pr_inf("gxtv_demod_fe_suspend\n");
+/*	demod_power_switch(PWR_OFF);*/
+	return 0;
+}
+
+#ifdef CONFIG_CMA
+void dtmb_cma_alloc(struct aml_fe_dev *devp)
+{
+	unsigned int mem_size = devp->cma_mem_size;
+
+	devp->venc_pages =
+			dma_alloc_from_contiguous(&(devp->this_pdev->dev),
+			mem_size >> PAGE_SHIFT, 0);
+		pr_dbg("[cma]mem_size is %d,%d\n",
+			mem_size, mem_size >> PAGE_SHIFT);
+		if (devp->venc_pages) {
+			devp->mem_start = page_to_phys(devp->venc_pages);
+			devp->mem_size  = mem_size;
+			pr_dbg("demod mem_start = 0x%x, mem_size = 0x%x\n",
+				devp->mem_start, devp->mem_size);
+			pr_dbg("demod cma alloc ok!\n");
+		} else {
+			pr_dbg("demod cma mem undefined2.\n");
+		}
+}
+
+void dtmb_cma_release(struct aml_fe_dev *devp)
+{
+	dma_release_from_contiguous(&(devp->this_pdev->dev),
+			devp->venc_pages,
+			devp->cma_mem_size>>PAGE_SHIFT);
+		pr_dbg("demod cma release ok!\n");
+	devp->mem_start = 0;
+	devp->mem_size = 0;
+}
+#endif
+
+
+static int gxtv_demod_fe_enter_mode(struct aml_fe *fe, int mode)
+{
+	struct aml_fe_dev *dev = fe->dtv_demod;
+	int memstart_dtmb;
+
+	/* must enable the adc ref signal for demod, */
+	vdac_enable(1, 0x2);
+
+	autoFlagsTrig = 1;
+	if (cci_thread)
+		if (dvbc_get_cci_task() == 1)
+			dvbc_create_cci_task();
+	/*mem_buf = (long *)phys_to_virt(memstart);*/
+	if (mode == AM_FE_DTMB) {
+		Gxtv_Demod_Dtmb_Init(dev);
+	if (fe->dtv_demod->cma_flag == 1) {
+		pr_dbg("CMA MODE, cma flag is %d,mem size is %d",
+			fe->dtv_demod->cma_flag, fe->dtv_demod->cma_mem_size);
+		dtmb_cma_alloc(dev);
+		memstart_dtmb = dev->mem_start;
+	} else {
+		memstart_dtmb = fe->dtv_demod->mem_start;
+	}
+		pr_dbg("[im]memstart is %x\n", memstart_dtmb);
+		dtmb_write_reg(DTMB_FRONT_MEM_ADDR, memstart_dtmb);
+		pr_dbg("[dtmb]mem_buf is 0x%x\n",
+			dtmb_read_reg(DTMB_FRONT_MEM_ADDR));
+		/* open arbit */
+		demod_set_demod_reg(0x8, DEMOD_REG4);
+	} else if (mode == AM_FE_QAM) {
+		Gxtv_Demod_Dvbc_Init(dev, Adc_mode);
+	}
+
+	return 0;
+}
+
+static int gxtv_demod_fe_leave_mode(struct aml_fe *fe, int mode)
+{
+	struct aml_fe_dev *dev = fe->dtv_demod;
+
+	dtvpll_init_flag(0);
+	/*dvbc_timer_exit();*/
+	if (cci_thread)
+		dvbc_kill_cci_task();
+	if (mode == AM_FE_DTMB) {
+		/* close arbit */
+		demod_set_demod_reg(0x0, DEMOD_REG4);
+		if (fe->dtv_demod->cma_flag == 1)
+			dtmb_cma_release(dev);
+	}
+
+	/* should disable the adc ref signal for demod */
+	vdac_enable(0, 0x2);
+
+	return 0;
+}
+
+static struct aml_fe_drv gxtv_demod_dtv_demod_drv = {
+	.id		= AM_DTV_DEMOD_M1,
+	.name		= "AMLDEMOD",
+	.capability	=
+		AM_FE_QPSK | AM_FE_QAM | AM_FE_ATSC | AM_FE_OFDM | AM_FE_DTMB,
+	.get_ops	= gxtv_demod_fe_get_ops,
+	.suspend	= gxtv_demod_fe_suspend,
+	.resume		= gxtv_demod_fe_resume,
+	.enter_mode	= gxtv_demod_fe_enter_mode,
+	.leave_mode	= gxtv_demod_fe_leave_mode
+};
+
+struct class *gxtv_clsp;
+struct class *gxtv_para_clsp;
+
+static int __init gxtvdemodfrontend_init(void)
+{
+	int ret;
+
+	pr_dbg("register gxtv_demod demod driver\n");
+	ret = 0;
+
+	dtvpll_lock_init();
+	mutex_init(&aml_lock);
+
+	gxtv_clsp = class_create(THIS_MODULE, DEMOD_DEVICE_NAME);
+	if (!gxtv_clsp) {
+		pr_error("[gxtv demod]%s:create class error.\n", __func__);
+		return PTR_ERR(gxtv_clsp);
+	}
+	ret = class_create_file(gxtv_clsp, &class_attr_auto_sym);
+	if (ret)
+		pr_error("[gxtv demod]%s create class error.\n", __func__);
+
+	ret = class_create_file(gxtv_clsp, &class_attr_dtmb_para);
+	if (ret)
+		pr_error("[gxtv demod]%s create class error.\n", __func__);
+
+	ret = class_create_file(gxtv_clsp, &class_attr_dvbc_reg);
+	if (ret)
+		pr_error("[gxtv demod]%s create class error.\n", __func__);
+
+	return aml_register_fe_drv(AM_DEV_DTV_DEMOD, &gxtv_demod_dtv_demod_drv);
+}
+
+static void __exit gxtvdemodfrontend_exit(void)
+{
+	pr_dbg("unregister gxtv_demod demod driver\n");
+
+	mutex_destroy(&aml_lock);
+
+	class_remove_file(gxtv_clsp, &class_attr_auto_sym);
+	class_remove_file(gxtv_clsp, &class_attr_dtmb_para);
+	class_remove_file(gxtv_clsp, &class_attr_dvbc_reg);
+	class_destroy(gxtv_clsp);
+	aml_unregister_fe_drv(AM_DEV_DTV_DEMOD, &gxtv_demod_dtv_demod_drv);
+}
+
+fs_initcall(gxtvdemodfrontend_init);
+module_exit(gxtvdemodfrontend_exit);
+
+MODULE_DESCRIPTION("gxtv_demod DVB-T/DVB-C/DTMB Demodulator driver");
+MODULE_AUTHOR("RSJ");
+MODULE_LICENSE("GPL");
diff --git a/drivers/stream_input/tv_frontend/dtv_demod/demod_func.c b/drivers/stream_input/tv_frontend/dtv_demod/demod_func.c
new file mode 100644
index 0000000..a54d82c
--- /dev/null
+++ b/drivers/stream_input/tv_frontend/dtv_demod/demod_func.c
@@ -0,0 +1,2996 @@
+/*
+* Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT
+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+* more details.
+*
+* You should have received a copy of the GNU General Public License along
+* with this program; if not, write to the Free Software Foundation, Inc.,
+* 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+*
+* Description:
+*/
+/*#include "register.h"*/
+/*#include "c_arc_pointer_reg.h"*/
+/*#include "a9_func.h"*/
+/*#include "clk_util.h"*/
+/*#include "c_stimulus.h"*/
+/*#include "a9_l2_func.h"*/
+
+#include "demod_func.h"
+#include <linux/dvb/aml_demod.h>
+#include <linux/string.h>
+#include <linux/kernel.h>
+#include "acf_filter_coefficient.h"
+#include <linux/mutex.h>
+
+#define M6D
+
+/* static void __iomem * demod_meson_reg_map[4]; */
+
+#define pr_dbg(fmt, args ...) \
+	do { \
+		if (debug_demod) \
+			pr_info("FE: " fmt, ## args); \
+	} while (0)
+#define pr_error(fmt, args ...) pr_info("FE: " fmt, ## args)
+
+MODULE_PARM_DESC(debug_demod, "\n\t\t Enable frontend debug information");
+static int debug_demod;
+module_param(debug_demod, int, 0644);
+
+MODULE_PARM_DESC(demod_timeout, "\n\t\t timeout debug information");
+static int demod_timeout = 120;
+module_param(demod_timeout, int, 0644);
+
+MODULE_PARM_DESC(demod_sync_count, "\n\t\t timeout debug information");
+static int demod_sync_count = 60;
+module_param(demod_sync_count, int, 0644);
+
+MODULE_PARM_DESC(demod_sync_delay_time, "\n\t\t timeout debug information");
+static int demod_sync_delay_time = 8;
+module_param(demod_sync_delay_time, int, 0644);
+
+
+
+MODULE_PARM_DESC(demod_mobile_power, "\n\t\t demod_mobile_power debug information");
+static int demod_mobile_power = 100;
+module_param(demod_mobile_power, int, 0644);
+
+MODULE_PARM_DESC(demod_enable_performance, "\n\t\t demod_enable_performance information");
+static int demod_enable_performance = 1;
+module_param(demod_enable_performance, int, 0644);
+
+
+static struct mutex mp;
+static struct mutex dtvpll_init_lock;
+static int dtvpll_init;
+static int dtmb_spectrum = 2;
+
+
+/* 8vsb */
+static struct atsc_cfg list_8vsb[22] = {
+	{0x0733, 0x00, 0},
+	{0x0734, 0xff, 0},
+	{0x0716, 0x02, 0},	/* F06[7] invert spectrum  0x02 0x06 */
+	{0x05e7, 0x00, 0},
+	{0x05e8, 0x00, 0},
+	{0x0f06, 0x80, 0},
+	{0x0f09, 0x04, 0},
+	{0x070c, 0x18, 0},
+	{0x070d, 0x9d, 0},
+	{0x070e, 0x89, 0},
+	{0x070f, 0x6a, 0},
+	{0x0710, 0x75, 0},
+	{0x0711, 0x6f, 0},
+	{0x072a, 0x02, 0},
+	{0x072c, 0x02, 0},
+	{0x090d, 0x03, 0},
+	{0x090e, 0x02, 0},
+	{0x090f, 0x00, 0},
+	{0x0900, 0x01, 0},
+	{0x0900, 0x00, 0},
+	{0x0f00, 0x01, 0},
+	{0x0000, 0x00, 1}
+};
+
+/* 64qam */
+static struct atsc_cfg list_qam64[111] = {
+	{0x0900, 0x01, 0},
+	{0x0f04, 0x08, 0},
+	{0x0f06, 0x80, 0},
+	{0x0f07, 0x00, 0},
+	{0x0f00, 0xe0, 0},
+	{0x0f00, 0xec, 0},
+	{0x0001, 0x05, 0},
+	{0x0002, 0x61, 0},	/* /0x61 invert spectrum */
+	{0x0003, 0x3e, 0},
+	{0x0004, 0xed, 0},	/* 0x9d */
+	{0x0005, 0x10, 0},
+	{0x0006, 0xc0, 0},
+	{0x0007, 0x5c, 0},
+	{0x0008, 0x0f, 0},
+	{0x0009, 0x4f, 0},
+	{0x000a, 0xfc, 0},
+	{0x000b, 0x0c, 0},
+	{0x000c, 0x6c, 0},
+	{0x000d, 0x3a, 0},
+	{0x000e, 0x10, 0},
+	{0x000f, 0x02, 0},
+	{0x0011, 0x00, 0},
+	{0x0012, 0xf5, 0},
+	{0x0013, 0x74, 0},
+	{0x0014, 0xb9, 0},
+	{0x0015, 0x1f, 0},
+	{0x0016, 0x80, 0},
+	{0x0017, 0x1f, 0},
+	{0x0018, 0x0f, 0},
+	{0x001e, 0x00, 0},
+	{0x001f, 0x00, 0},
+	{0x0023, 0x03, 0},
+	{0x0025, 0x20, 0},
+	{0x0026, 0xff, 0},
+	{0x0027, 0xff, 0},
+	{0x0028, 0xf8, 0},
+	{0x0200, 0x20, 0},
+	{0x0201, 0x62, 0},
+	{0x0202, 0x23, 0},
+	{0x0204, 0x19, 0},
+	{0x0205, 0x74, 0},
+	{0x0206, 0xab, 0},
+	{0x0207, 0xff, 0},
+	{0x0208, 0xc0, 0},
+	{0x0209, 0xff, 0},
+	{0x0211, 0xc0, 0},
+	{0x0212, 0xb0, 0},
+	{0x0213, 0x05, 0},
+	{0x0215, 0x08, 0},
+	{0x0222, 0xe0, 0},
+	{0x0223, 0xf0, 0},
+	{0x0226, 0x40, 0},
+	{0x0229, 0x23, 0},
+	{0x022a, 0x02, 0},
+	{0x022c, 0x01, 0},
+	{0x022e, 0x01, 0},
+	{0x022f, 0x25, 0},
+	{0x0230, 0x40, 0},
+	{0x0231, 0x01, 0},
+	{0x0734, 0xff, 0},
+	{0x073a, 0xff, 0},
+	{0x073b, 0x04, 0},
+	{0x073c, 0x08, 0},
+	{0x073d, 0x08, 0},
+	{0x073e, 0x01, 0},
+	{0x073f, 0xf8, 0},
+	{0x0740, 0xf1, 0},
+	{0x0741, 0xf3, 0},
+	{0x0742, 0xff, 0},
+	{0x0743, 0x0f, 0},
+	{0x0744, 0x1a, 0},
+	{0x0745, 0x16, 0},
+	{0x0746, 0x00, 0},
+	{0x0747, 0xe3, 0},
+	{0x0748, 0xce, 0},
+	{0x0749, 0xd4, 0},
+	{0x074a, 0x00, 0},
+	{0x074b, 0x4b, 0},
+	{0x074c, 0x00, 0},
+	{0x074d, 0xa2, 0},
+	{0x074e, 0x00, 0},
+	{0x074f, 0xe6, 0},
+	{0x0750, 0x00, 0},
+	{0x0751, 0x00, 0},
+	{0x0752, 0x01, 0},
+	{0x0753, 0x03, 0},
+	{0x0400, 0x00, 0},
+	{0x0408, 0x04, 0},
+	{0x040e, 0xe0, 0},
+	{0x0500, 0x02, 0},
+	{0x05e7, 0x00, 0},
+	{0x05e8, 0x00, 0},
+	{0x0f09, 0x18, 0},
+	{0x070c, 0x20, 0},
+	{0x070d, 0x41, 0},	/* 0x49 */
+	{0x070e, 0x04, 0},	/* 0x37 */
+	{0x070f, 0x00, 0},
+	{0x0710, 0x00, 0},
+	{0x0711, 0x00, 0},
+	{0x0716, 0xf0, 0},
+	{0x090f, 0x00, 0},
+	{0x0900, 0x01, 1},
+	{0x0900, 0x00, 0},
+	{0x0001, 0xf5, 0},
+	{0x0001, 0xf5, 1},
+	{0x0001, 0xf5, 1},
+	{0x0001, 0xf5, 1},
+	{0x0001, 0xf5, 1},
+	{0x0001, 0x05, 0},
+	{0x0001, 0x05, 1},
+	{0x0000, 0x00, 1}
+};
+
+/* 256qam */
+static struct atsc_cfg list_qam256[113] = {
+	{0x0900, 0x01, 0},
+	{0x0f04, 0x08, 0},
+	{0x0f06, 0x80, 0},
+	{0x0f00, 0xe0, 0},
+	{0x0f00, 0xec, 0},
+	{0x0001, 0x05, 0},
+	{0x0002, 0x01, 0},	/* 0x09 */
+	{0x0003, 0x2c, 0},
+	{0x0004, 0x91, 0},
+	{0x0005, 0x10, 0},
+	{0x0006, 0xc0, 0},
+	{0x0007, 0x5c, 0},
+	{0x0008, 0x0f, 0},
+	{0x0009, 0x4f, 0},
+	{0x000a, 0xfc, 0},
+	{0x000b, 0x0c, 0},
+	{0x000c, 0x6c, 0},
+	{0x000d, 0x3a, 0},
+	{0x000e, 0x10, 0},
+	{0x000f, 0x02, 0},
+	{0x0011, 0x80, 0},
+	{0x0012, 0xf5, 0},	/* a5 */
+	{0x0013, 0x74, 0},
+	{0x0014, 0xb9, 0},
+	{0x0015, 0x1f, 0},
+	{0x0016, 0x80, 0},
+	{0x0017, 0x1f, 0},
+	{0x0018, 0x0f, 0},
+	{0x001e, 0x00, 0},
+	{0x001f, 0x00, 0},
+	{0x0023, 0x03, 0},
+	{0x0025, 0x20, 0},
+	{0x0026, 0xff, 0},
+	{0x0027, 0xff, 0},
+	{0x0028, 0xf8, 0},
+	{0x0200, 0x20, 0},
+	{0x0201, 0x62, 0},
+	{0x0202, 0x23, 0},
+	{0x0204, 0x19, 0},
+	{0x0205, 0x76, 0},
+	{0x0206, 0xd2, 0},
+	{0x0207, 0xff, 0},
+	{0x0208, 0xc0, 0},
+	{0x0209, 0xff, 0},
+	{0x0211, 0xc0, 0},
+	{0x0212, 0xb0, 0},
+	{0x0213, 0x05, 0},
+	{0x0215, 0x08, 0},
+	{0x0222, 0xf0, 0},
+	{0x0223, 0xff, 0},
+	{0x0226, 0x40, 0},
+	{0x0229, 0x23, 0},
+	{0x022a, 0x02, 0},
+	{0x022c, 0x01, 0},
+	{0x022e, 0x01, 0},
+	{0x022f, 0x05, 0},
+	{0x0230, 0x40, 0},
+	{0x0231, 0x01, 0},
+	{0x0400, 0x02, 0},
+	{0x0401, 0x30, 0},
+	{0x0402, 0x13, 0},
+	{0x0406, 0x06, 0},
+	{0x0408, 0x04, 0},
+	{0x040e, 0xe0, 0},
+	{0x0411, 0x02, 0},
+	{0x073a, 0x02, 0},
+	{0x073b, 0x09, 0},
+	{0x073c, 0x0c, 0},
+	{0x073d, 0x08, 0},
+	{0x073e, 0xfd, 0},
+	{0x073f, 0xf2, 0},
+	{0x0740, 0xed, 0},
+	{0x0741, 0xf4, 0},
+	{0x0742, 0x03, 0},
+	{0x0743, 0x15, 0},
+	{0x0744, 0x1d, 0},
+	{0x0745, 0x15, 0},
+	{0x0746, 0xfc, 0},
+	{0x0747, 0xde, 0},
+	{0x0748, 0xcc, 0},
+	{0x0749, 0xd6, 0},
+	{0x074a, 0x04, 0},
+	{0x074b, 0x4f, 0},
+	{0x074c, 0x00, 0},
+	{0x074d, 0xa2, 0},
+	{0x074e, 0x00, 0},
+	{0x074f, 0xe3, 0},
+	{0x0750, 0x00, 0},
+	{0x0751, 0xfc, 0},
+	{0x0752, 0x00, 0},
+	{0x0753, 0x03, 0},
+	{0x0500, 0x02, 0},
+	{0x05e7, 0x00, 0},
+	{0x05e8, 0x00, 0},
+	{0x0f09, 0x18, 0},
+	{0x070c, 0x20, 0},
+	{0x070d, 0x49, 0},
+	{0x070e, 0x37, 0},
+	{0x070f, 0x00, 0},
+	{0x0710, 0x00, 0},
+	{0x0711, 0x00, 0},
+	{0x0716, 0xf0, 0},
+	{0x090f, 0x00, 0},
+	{0x0900, 0x01, 1},
+	{0x0900, 0x00, 0},
+	{0x0001, 0xf5, 0},
+	{0x0001, 0xf5, 1},
+	{0x0001, 0xf5, 1},
+	{0x0001, 0xf5, 1},
+	{0x0001, 0xf5, 1},
+	{0x0001, 0x05, 0},
+	{0x0001, 0x05, 1},
+	{0x0000, 0x00, 1}
+};
+
+void dtvpll_lock_init(void)
+{
+	mutex_init(&dtvpll_init_lock);
+}
+
+void dtvpll_init_flag(int on)
+{
+	mutex_lock(&dtvpll_init_lock);
+	dtvpll_init = on;
+	mutex_unlock(&dtvpll_init_lock);
+	pr_err("%s %d\n", __func__, on);
+}
+
+int get_dtvpll_init_flag(void)
+{
+	int val;
+
+	mutex_lock(&dtvpll_init_lock);
+	val = dtvpll_init;
+	mutex_unlock(&dtvpll_init_lock);
+	if (!val)
+		pr_err("%s: %d\n", __func__, val);
+	return val;
+}
+
+void adc_dpll_setup(int clk_a, int clk_b, int clk_sys)
+{
+	int unit, found, ena, enb, div2;
+	int pll_m, pll_n, pll_od_a, pll_od_b, pll_xd_a, pll_xd_b;
+	long freq_osc, freq_dco, freq_b, freq_a, freq_sys;
+	long freq_b_act, freq_a_act, freq_sys_act, err_tmp, best_err;
+	union adc_pll_cntl adc_pll_cntl;
+	union adc_pll_cntl2 adc_pll_cntl2;
+	union adc_pll_cntl3 adc_pll_cntl3;
+	union adc_pll_cntl4 adc_pll_cntl4;
+	union demod_dig_clk dig_clk_cfg;
+
+	adc_pll_cntl.d32 = 0;
+	adc_pll_cntl2.d32 = 0;
+	adc_pll_cntl3.d32 = 0;
+	adc_pll_cntl4.d32 = 0;
+
+	pr_dbg("target clk_a %d  clk_b %d\n", clk_a, clk_b);
+
+	unit = 10000;		/* 10000 as 1 MHz, 0.1 kHz resolution. */
+	freq_osc = 24 * unit;
+
+	if (clk_a < 1000)
+		freq_a = clk_a * unit;
+	else
+		freq_a = clk_a * (unit / 1000);
+
+	if (clk_b < 1000)
+		freq_b = clk_b * unit;
+	else
+		freq_b = clk_b * (unit / 1000);
+
+	ena = clk_a > 0 ? 1 : 0;
+	enb = clk_b > 0 ? 1 : 0;
+
+	if (ena || enb)
+		adc_pll_cntl3.b.enable = 1;
+	adc_pll_cntl3.b.reset = 1;
+
+	found = 0;
+	best_err = 100 * unit;
+	pll_od_a = 1;
+	pll_od_b = 1;
+	pll_n = 1;
+	for (pll_m = 1; pll_m < 512; pll_m++) {
+		/* for (pll_n=1; pll_n<=5; pll_n++) { */
+		if (is_meson_txl_cpu()) {
+			freq_dco = freq_osc * pll_m / pll_n / 2;/*txl add div2*/
+			if (freq_dco < 700 * unit || freq_dco > 1000 * unit)
+				continue;
+		} else {
+			freq_dco = freq_osc * pll_m / pll_n;
+			if (freq_dco < 750 * unit || freq_dco > 1550 * unit)
+				continue;
+		}
+		pll_xd_a = freq_dco / (1 << pll_od_a) / freq_a;
+		pll_xd_b = freq_dco / (1 << pll_od_b) / freq_b;
+
+		freq_a_act = freq_dco / (1 << pll_od_a) / pll_xd_a;
+		freq_b_act = freq_dco / (1 << pll_od_b) / pll_xd_b;
+
+		err_tmp = (freq_a_act - freq_a) * ena + (freq_b_act - freq_b) *
+		    enb;
+
+		if (err_tmp >= best_err)
+			continue;
+
+		adc_pll_cntl.b.pll_m = pll_m;
+		adc_pll_cntl.b.pll_n = pll_n;
+		adc_pll_cntl.b.pll_od0 = pll_od_b;
+		adc_pll_cntl.b.pll_od1 = pll_od_a;
+		adc_pll_cntl.b.pll_xd0 = pll_xd_b;
+		adc_pll_cntl.b.pll_xd1 = pll_xd_a;
+		if (is_meson_txl_cpu()) {
+			adc_pll_cntl4.b.pll_od3 = 0;
+			adc_pll_cntl.b.pll_od2 = 0;
+		} else {
+			adc_pll_cntl2.b.div2_ctrl =
+				freq_dco > 1000 * unit ? 1 : 0;
+		}
+		found = 1;
+		best_err = err_tmp;
+		/* } */
+	}
+
+	pll_m = adc_pll_cntl.b.pll_m;
+	pll_n = adc_pll_cntl.b.pll_n;
+	pll_od_b = adc_pll_cntl.b.pll_od0;
+	pll_od_a = adc_pll_cntl.b.pll_od1;
+	pll_xd_b = adc_pll_cntl.b.pll_xd0;
+	pll_xd_a = adc_pll_cntl.b.pll_xd1;
+
+	if (is_meson_txl_cpu())
+		div2 = 1;
+	else
+		div2 = adc_pll_cntl2.b.div2_ctrl;
+	/*
+	 * p_adc_pll_cntl  =  adc_pll_cntl.d32;
+	 * p_adc_pll_cntl2 = adc_pll_cntl2.d32;
+	 * p_adc_pll_cntl3 = adc_pll_cntl3.d32;
+	 * p_adc_pll_cntl4 = adc_pll_cntl4.d32;
+	 */
+	adc_pll_cntl3.b.reset = 0;
+	/* *p_adc_pll_cntl3 = adc_pll_cntl3.d32; */
+	if (!found) {
+		pr_dbg(" ERROR can't setup %7ld kHz %7ld kHz\n",
+		       freq_b / (unit / 1000), freq_a / (unit / 1000));
+	} else {
+		if (is_meson_txl_cpu())
+			freq_dco = freq_osc * pll_m / pll_n / 2;
+		else
+			freq_dco = freq_osc * pll_m / pll_n;
+		pr_dbg(" ADC PLL  M %3d   N %3d\n", pll_m, pll_n);
+		pr_dbg(" ADC PLL DCO %ld kHz\n", freq_dco / (unit / 1000));
+
+		pr_dbg(" ADC PLL XD %3d  OD %3d\n", pll_xd_b, pll_od_b);
+		pr_dbg(" ADC PLL XD %3d  OD %3d\n", pll_xd_a, pll_od_a);
+
+		freq_a_act = freq_dco / (1 << pll_od_a) / pll_xd_a;
+		freq_b_act = freq_dco / (1 << pll_od_b) / pll_xd_b;
+
+		pr_dbg(" B %7ld kHz %7ld kHz\n",
+		       freq_b / (unit / 1000), freq_b_act / (unit / 1000));
+		pr_dbg(" A %7ld kHz %7ld kHz\n",
+		       freq_a / (unit / 1000), freq_a_act / (unit / 1000));
+
+		if (clk_sys > 0) {
+			dig_clk_cfg.b.demod_clk_en = 1;
+			dig_clk_cfg.b.demod_clk_sel = 3;
+			if (clk_sys < 1000)
+				freq_sys = clk_sys * unit;
+			else
+				freq_sys = clk_sys * (unit / 1000);
+
+			dig_clk_cfg.b.demod_clk_div = freq_dco / (1 + div2) /
+			    freq_sys - 1;
+			freq_sys_act = freq_dco / (1 + div2) /
+			    (dig_clk_cfg.b.demod_clk_div + 1);
+			pr_dbg(" SYS %7ld kHz div %d+1  %7ld kHz\n",
+			       freq_sys / (unit / 1000),
+			       dig_clk_cfg.b.demod_clk_div,
+			       freq_sys_act / (unit / 1000));
+		} else {
+			dig_clk_cfg.b.demod_clk_en = 0;
+		}
+
+		/* *p_demod_dig_clk = dig_clk_cfg.d32; */
+	}
+	if (is_meson_txl_cpu()) {
+		demod_set_demod_reg(TXLTV_ADC_RESET_VALUE, ADC_REG3);
+		demod_set_demod_reg(adc_pll_cntl.d32, ADC_REG1);
+		demod_set_demod_reg(dig_clk_cfg.d32, ADC_REG6);
+		demod_set_demod_reg(TXLTV_ADC_REG3_VALUE, ADC_REG3);
+		/* debug */
+		pr_dbg("[adc][%x]%x\n", ADC_REG1,
+				demod_read_demod_reg(ADC_REG1));
+		pr_dbg("[adc][%x]%x\n", ADC_REG2,
+				demod_read_demod_reg(ADC_REG2));
+		pr_dbg("[adc][%x]%x\n", ADC_REG3,
+				demod_read_demod_reg(ADC_REG3));
+		pr_dbg("[adc][%x]%x\n", ADC_REG4,
+				demod_read_demod_reg(ADC_REG4));
+		pr_dbg("[adc][%x]%x\n", ADC_REG5,
+				demod_read_demod_reg(ADC_REG5));
+		pr_dbg("[adc][%x]%x\n", ADC_REG6,
+				demod_read_demod_reg(ADC_REG6));
+		pr_dbg("[adc][%x]%x\n", ADC_REG7,
+				demod_read_demod_reg(ADC_REG7));
+		pr_dbg("[adc][%x]%x\n", ADC_REG8,
+				demod_read_demod_reg(ADC_REG8));
+		pr_dbg("[adc][%x]%x\n", ADC_REG9,
+				demod_read_demod_reg(ADC_REG9));
+		pr_dbg("[adc][%x]%x\n", ADC_REGB,
+				demod_read_demod_reg(ADC_REGB));
+		pr_dbg("[adc][%x]%x\n", ADC_REGC,
+				demod_read_demod_reg(ADC_REGC));
+		pr_dbg("[adc][%x]%x\n", ADC_REGD,
+				demod_read_demod_reg(ADC_REGD));
+		pr_dbg("[adc][%x]%x\n", ADC_REGE,
+				demod_read_demod_reg(ADC_REGE));
+		pr_dbg("[demod][%x]%x\n", DEMOD_REG1,
+				demod_read_demod_reg(DEMOD_REG1));
+		pr_dbg("[demod][%x]%x\n", DEMOD_REG2,
+				demod_read_demod_reg(DEMOD_REG2));
+		pr_dbg("[demod][%x]%x\n", DEMOD_REG3,
+				demod_read_demod_reg(DEMOD_REG3));
+	} else {
+		demod_set_demod_reg(ADC_RESET_VALUE, ADC_REG3);	/* adc reset */
+		demod_set_demod_reg(adc_pll_cntl.d32, ADC_REG1);
+		demod_set_demod_reg(dig_clk_cfg.d32, ADC_REG6);
+		demod_set_demod_reg(ADC_REG3_VALUE, ADC_REG3);
+		/* debug */
+		pr_dbg("[adc][%x]%x\n", ADC_REG1,
+				demod_read_demod_reg(ADC_REG1));
+		pr_dbg("[adc][%x]%x\n", ADC_REG2,
+				demod_read_demod_reg(ADC_REG2));
+		pr_dbg("[adc][%x]%x\n", ADC_REG3,
+				demod_read_demod_reg(ADC_REG3));
+		pr_dbg("[adc][%x]%x\n", ADC_REG4,
+				demod_read_demod_reg(ADC_REG4));
+		pr_dbg("[adc][%x]%x\n", ADC_REG6,
+				demod_read_demod_reg(ADC_REG6));
+		pr_dbg("[demod][%x]%x\n", DEMOD_REG1,
+				demod_read_demod_reg(DEMOD_REG1));
+		pr_dbg("[demod][%x]%x\n", DEMOD_REG2,
+				demod_read_demod_reg(DEMOD_REG2));
+		pr_dbg("[demod][%x]%x\n", DEMOD_REG3,
+				demod_read_demod_reg(DEMOD_REG3));
+	}
+	dtvpll_init_flag(1);
+}
+
+void demod_set_adc_core_clk(int adc_clk, int sys_clk, int dvb_mode)
+{
+	adc_dpll_setup(25, adc_clk, sys_clk);
+}
+
+void demod_set_cbus_reg(unsigned int data, unsigned int addr)
+{
+	void __iomem *vaddr;
+
+	pr_dbg("[cbus][write]%x\n", (IO_CBUS_PHY_BASE + (addr << 2)));
+	vaddr = ioremap((IO_CBUS_PHY_BASE + (addr << 2)), 0x4);
+	writel(data, vaddr);
+	iounmap(vaddr);
+}
+
+unsigned int demod_read_cbus_reg(unsigned int addr)
+{
+/* return __raw_readl(CBUS_REG_ADDR(addr)); */
+	unsigned int tmp;
+	void __iomem *vaddr;
+
+	vaddr = ioremap((IO_CBUS_PHY_BASE + (addr << 2)), 0x4);
+	tmp = readl(vaddr);
+	iounmap(vaddr);
+/* tmp = aml_read_cbus(addr); */
+	pr_dbg("[cbus][read]%x,data is %x\n",
+	(IO_CBUS_PHY_BASE + (addr << 2)), tmp);
+	return tmp;
+}
+
+void demod_set_ao_reg(unsigned int data, unsigned int addr)
+{
+	void __iomem *vaddr;
+
+/* pr_dbg("[ao][write]%x,data is %x\n",(IO_AOBUS_BASE+addr),data); */
+	vaddr = ioremap((IO_AOBUS_BASE + addr), 0x4);
+	writel(data, vaddr);
+	iounmap(vaddr);
+}
+
+unsigned int demod_read_ao_reg(unsigned int addr)
+{
+	unsigned int tmp;
+	void __iomem *vaddr;
+
+/* pr_dbg("[ao][read]%x\n",(IO_AOBUS_BASE+addr)); */
+	vaddr = ioremap((IO_AOBUS_BASE + addr), 0x4);
+	tmp = readl(vaddr);
+/* pr_dbg("[ao][read]%x,data is %x\n",(IO_AOBUS_BASE+addr),tmp); */
+	iounmap(vaddr);
+	return tmp;
+}
+
+void demod_set_demod_reg(unsigned int data, unsigned int addr)
+{
+	void __iomem *vaddr;
+
+	mutex_lock(&mp);
+/* printk("[demod][write]%x,data is %x\n",(addr),data); */
+	vaddr = ioremap((addr), 0x4);
+	writel(data, vaddr);
+	iounmap(vaddr);
+	mutex_unlock(&mp);
+}
+
+unsigned int demod_read_demod_reg(unsigned int addr)
+{
+	unsigned int tmp;
+	void __iomem *vaddr;
+
+	mutex_lock(&mp);
+	vaddr = ioremap((addr), 0x4);
+	tmp = readl(vaddr);
+	iounmap(vaddr);
+	mutex_unlock(&mp);
+/* printk("[demod][read]%x,data is %x\n",(addr),tmp); */
+	return tmp;
+}
+
+void demod_power_switch(int pwr_cntl)
+{
+	int reg_data;
+#if 1
+	if (pwr_cntl == PWR_ON) {
+		pr_dbg("[PWR]: Power on demod_comp %x,%x\n",
+		       AO_RTI_GEN_PWR_SLEEP0, AO_RTI_GEN_PWR_ISO0);
+		/* Powerup demod_comb */
+		reg_data = demod_read_ao_reg(AO_RTI_GEN_PWR_SLEEP0);
+		demod_set_ao_reg((reg_data & (~(0x1 << 10))),
+				 AO_RTI_GEN_PWR_SLEEP0);
+		/* [10] power on */
+		pr_dbg("[PWR]: Power on demod_comp %x,%x\n",
+		       HHI_DEMOD_MEM_PD_REG, RESET0_LEVEL);
+		/* Power up memory */
+		demod_set_demod_reg((demod_read_demod_reg(HHI_DEMOD_MEM_PD_REG)
+				     & (~0x2fff)), HHI_DEMOD_MEM_PD_REG);
+		/* reset */
+		demod_set_demod_reg((demod_read_demod_reg(RESET0_LEVEL) &
+				     (~(0x1 << 8))), RESET0_LEVEL);
+	/*	msleep(20);*/
+
+		/* remove isolation */
+			demod_set_ao_reg(
+				(demod_read_ao_reg(AO_RTI_GEN_PWR_ISO0) &
+				  (~(0x3 << 14))), AO_RTI_GEN_PWR_ISO0);
+		/* pull up reset */
+		demod_set_demod_reg((demod_read_demod_reg(RESET0_LEVEL) |
+				     (0x1 << 8)), RESET0_LEVEL);
+/* *P_RESET0_LEVEL |= (0x1<<8); */
+	} else {
+		pr_dbg("[PWR]: Power off demod_comp\n");
+		/* add isolation */
+
+			demod_set_ao_reg(
+				(demod_read_ao_reg(AO_RTI_GEN_PWR_ISO0) |
+				  (0x3 << 14)), AO_RTI_GEN_PWR_ISO0);
+
+		/* power down memory */
+		demod_set_demod_reg((demod_read_demod_reg(HHI_DEMOD_MEM_PD_REG)
+			 | 0x2fff), HHI_DEMOD_MEM_PD_REG);
+		/* power down demod_comb */
+		reg_data = demod_read_ao_reg(AO_RTI_GEN_PWR_SLEEP0);
+		demod_set_ao_reg((reg_data | (0x1 << 10)),
+				 AO_RTI_GEN_PWR_SLEEP0);
+		/* [10] power on */
+	}
+#endif
+}
+
+static void clocks_set_sys_defaults(unsigned char dvb_mode)
+{
+	union demod_cfg0 cfg0;
+	union demod_cfg2 cfg2;
+
+	demod_power_switch(PWR_ON);
+
+	if (is_meson_gxtvbb_cpu()) {
+		pr_dbg("GX_TV config\n");
+		demod_set_demod_reg(ADC_RESET_VALUE, ADC_REG3);
+		demod_set_demod_reg(ADC_REG1_VALUE, ADC_REG1);
+		demod_set_demod_reg(ADC_REG2_VALUE, ADC_REG2);
+		demod_set_demod_reg(ADC_REG4_VALUE, ADC_REG4);
+		demod_set_demod_reg(ADC_REG3_VALUE, ADC_REG3);
+		/* dadc */
+		demod_set_demod_reg(ADC_REG7_VALUE, ADC_REG7);
+		demod_set_demod_reg(ADC_REG8_VALUE, ADC_REG8);
+		demod_set_demod_reg(ADC_REG9_VALUE, ADC_REG9);
+		demod_set_demod_reg(ADC_REGA_VALUE, ADC_REGA);
+	} else if (is_meson_txl_cpu()) {
+		pr_dbg("TXL_TV config\n");
+		demod_set_demod_reg(TXLTV_ADC_REG3_VALUE, ADC_REG3);
+		demod_set_demod_reg(TXLTV_ADC_REG1_VALUE, ADC_REG1);
+		demod_set_demod_reg(TXLTV_ADC_REGB_VALUE, ADC_REGB);
+		demod_set_demod_reg(TXLTV_ADC_REG2_VALUE, ADC_REG2);
+		demod_set_demod_reg(TXLTV_ADC_REG3_VALUE, ADC_REG3);
+		demod_set_demod_reg(TXLTV_ADC_REG4_VALUE, ADC_REG4);
+		demod_set_demod_reg(TXLTV_ADC_REGC_VALUE, ADC_REGC);
+		demod_set_demod_reg(TXLTV_ADC_REGD_VALUE, ADC_REGD);
+		demod_set_demod_reg(TXLTV_ADC_RESET_VALUE, ADC_REG3);
+		demod_set_demod_reg(TXLTV_ADC_REG3_VALUE, ADC_REG3);
+
+		/* dadc */
+		demod_set_demod_reg(TXLTV_ADC_REG7_VALUE, ADC_REG7);
+		demod_set_demod_reg(TXLTV_ADC_REG8_VALUE, ADC_REG8);
+		demod_set_demod_reg(TXLTV_ADC_REG9_VALUE, ADC_REG9);
+		demod_set_demod_reg(TXLTV_ADC_REGE_VALUE, ADC_REGE);
+	}
+
+	demod_set_demod_reg(DEMOD_REG1_VALUE, DEMOD_REG1);
+	demod_set_demod_reg(DEMOD_REG2_VALUE, DEMOD_REG2);
+	demod_set_demod_reg(DEMOD_REG3_VALUE, DEMOD_REG3);
+	cfg0.b.mode = 7;
+	cfg0.b.adc_format = 1;
+	if (dvb_mode == Gxtv_Dvbc) {	/* // 0 -DVBC, 1-DVBT, ISDBT, 2-ATSC */
+		cfg0.b.ts_sel = 2;
+	} else if ((dvb_mode == Gxtv_Dvbt_Isdbt) || (dvb_mode == Gxtv_Dtmb)) {
+		cfg0.b.ts_sel = 1;
+		cfg0.b.adc_regout = 1;
+	} else if (dvb_mode == Gxtv_Atsc) {
+		cfg0.b.ts_sel = 4;
+	}
+	demod_set_demod_reg(cfg0.d32, DEMOD_REG1);
+	cfg2.b.biasgen_en = 1;
+	cfg2.b.en_adc = 1;
+	demod_set_demod_reg(cfg2.d32, DEMOD_REG3);
+	pr_dbg("0xc8020c00 is %x,dvb_mode is %d\n",
+	       demod_read_demod_reg(DEMOD_REG1), dvb_mode);
+}
+
+void dtmb_write_reg(int reg_addr, int reg_data)
+{
+	if (!get_dtvpll_init_flag())
+		return;
+	demod_set_demod_reg(reg_data, reg_addr);
+/* apb_write_reg(reg_addr,reg_data); */
+}
+
+int dtmb_read_reg(int reg_addr)
+{
+	if (!get_dtvpll_init_flag())
+		return 0;
+	return demod_read_demod_reg(reg_addr);	/* apb_read_reg(reg_addr); */
+}
+
+void atsc_write_reg(int reg_addr, int reg_data)
+{
+	if (!get_dtvpll_init_flag())
+		return;
+	apb_write_reg(ATSC_BASE, (reg_addr & 0xffff) << 8 | (reg_data & 0xff));
+}
+
+unsigned long atsc_read_reg(int reg_addr)
+{
+	unsigned long tmp;
+
+	if (!get_dtvpll_init_flag())
+		return 0;
+	apb_write_reg(ATSC_BASE + 4, (reg_addr & 0xffff) << 8);
+	tmp = apb_read_reg(ATSC_BASE);
+
+	return tmp & 0xff;
+}
+
+unsigned long atsc_read_iqr_reg(void)
+{
+	unsigned long tmp;
+
+	tmp = apb_read_reg(ATSC_BASE + 8);
+	pr_dbg("[atsc irq] is %lx\n", tmp);
+	return tmp & 0xffffffff;
+}
+
+int atsc_qam_set(fe_modulation_t mode)
+{
+	int i, j;
+
+	if (mode == VSB_8) {	/* 5-8vsb, 2-64qam, 4-256qam */
+		for (i = 0; list_8vsb[i].adr != 0; i++) {
+			if (list_8vsb[i].rw)
+				atsc_read_reg(list_8vsb[i].adr);
+			/* msleep(20); */
+			else
+				atsc_write_reg(list_8vsb[i].adr,
+					       list_8vsb[i].dat);
+			/* msleep(20); */
+		}
+		j = 15589;
+		pr_dbg("8-vsb mode\n");
+	} else if (mode == QAM_64) {
+		for (i = 0; list_qam64[i].adr != 0; i++) {
+			if (list_qam64[i].rw) {
+				atsc_read_reg(list_qam64[i].adr);
+				msleep(20);
+			} else {
+				atsc_write_reg(list_qam64[i].adr,
+					       list_qam64[i].dat);
+				msleep(20);
+			}
+		}
+		j = 16588;	/* 33177; */
+		pr_dbg("64qam mode\n");
+	} else if (mode == QAM_256) {
+		for (i = 0; list_qam256[i].adr != 0; i++) {
+			if (list_qam256[i].rw) {
+				atsc_read_reg(list_qam256[i].adr);
+				msleep(20);
+			} else {
+				atsc_write_reg(list_qam256[i].adr,
+					       list_qam256[i].dat);
+				msleep(20);
+			}
+		}
+		j = 15649;	/* 31298; */
+		pr_dbg("256qam mode\n");
+	} else {
+		for (i = 0; list_qam256[i].adr != 0; i++) {
+			if (list_qam256[i].rw) {
+				atsc_read_reg(list_qam256[i].adr);
+				msleep(20);
+			} else {
+				atsc_write_reg(list_qam256[i].adr,
+					       list_qam256[i].dat);
+				msleep(20);
+			}
+		}
+		j = 15649;	/* 31298; */
+		pr_dbg("256qam mode\n");
+	}
+	return j;
+}
+
+void atsc_initial(struct aml_demod_sta *demod_sta)
+{
+	int fc, fs, cr, ck, j;
+	fe_modulation_t mode;
+
+	mode = demod_sta->ch_mode;
+
+	j = atsc_qam_set(mode);	/* set mode */
+
+	fs = demod_sta->adc_freq;	/* KHZ 25200 */
+	fc = demod_sta->ch_if;	/* KHZ 6350 */
+
+	cr = (fc * (1 << 17) / fs) * (1 << 6);
+	ck = fs * j / 10 - (1 << 25);
+	/* ck_rate = (f_samp / f_vsb /2 -1)*(1<<25);
+	 *double f_vsb = 10.76238;// double f_64q = 5.056941;
+	 * // double f_256q = 5.360537;
+	 */
+
+	atsc_write_reg(0x070e, cr & 0xff);
+	atsc_write_reg(0x070d, (cr >> 8) & 0xff);
+	atsc_write_reg(0x070c, (cr >> 16) & 0xff);
+
+	if (demod_sta->ch_mode == VSB_8) {
+		atsc_write_reg(0x0711, ck & 0xff);
+		atsc_write_reg(0x0710, (ck >> 8) & 0xff);
+		atsc_write_reg(0x070f, (ck >> 16) & 0xff);
+	}
+	pr_dbg("0x70e is %x, 0x70d is %x, 0x70c is %x\n", cr & 0xff,
+	       (cr >> 8) & 0xff, (cr >> 16) & 0xff);
+	pr_dbg("fs is %d(SR),fc is %d(IF),cr is %x,ck is %x\n", fs, fc, cr, ck);
+}
+
+int atsc_set_ch(struct aml_demod_sta *demod_sta,
+		struct aml_demod_i2c *demod_i2c,
+		struct aml_demod_atsc *demod_atsc)
+{
+	int ret = 0;
+	u8 demod_mode;
+	u8 bw, sr, ifreq, agc_mode;
+	u32 ch_freq;
+
+	bw = demod_atsc->bw;
+	sr = demod_atsc->sr;
+	ifreq = demod_atsc->ifreq;
+	agc_mode = demod_atsc->agc_mode;
+	ch_freq = demod_atsc->ch_freq;
+	demod_mode = demod_atsc->dat0;
+	demod_sta->ch_mode = demod_atsc->mode;	/* TODO */
+	demod_sta->agc_mode = agc_mode;
+	demod_sta->ch_freq = ch_freq;
+	demod_sta->dvb_mode = demod_mode;
+	demod_sta->ch_bw = (8 - bw) * 1000;
+	atsc_initial(demod_sta);
+	pr_dbg("ATSC mode\n");
+	return ret;
+}
+
+#if 0
+static dtmb_cfg_t list_dtmb_v1[99] = {
+	{0x00000000, 0x01, 0},
+	{0x00001000, 0x02, 0},
+	{0x00000000, 0x03, 0},
+	{0x00000000, 0x04, 0},
+	{0x00000000, 0x05, 0},
+	{0x00000000, 0x06, 0},
+	{0x007fffff, 0x07, 0},
+	{0x0000000f, 0x08, 0},
+	{0x00003000, 0x09, 0},
+	{0x00000001, 0x0a, 0},
+	{0x0c403006, 0x0b, 0},
+	{0x44444400, 0x0c, 0},
+	{0x1412c320, 0x0d, 0},
+	{0x00000152, 0x10, 0},
+	{0x47080137, 0x11, 0},
+	{0x02200a16, 0x12, 0},
+	{0x42190190, 0x13, 0},
+	{0x7f807f80, 0x14, 0},
+	{0x0000199a, 0x15, 0},
+	{0x000a1466, 0x18, 0},
+	{0x00274217, 0x1a, 0},
+	{0x00131036, 0x1b, 1},
+	{0x00000396, 0x1c, 0},
+	{0x0037f3cc, 0x1d, 0},
+	{0x00000029, 0x1e, 0},
+	{0x0004f031, 0x1f, 0},
+	{0x00f3cbd4, 0x20, 0},
+	{0x0000007e, 0x21, 0},
+	{0x23270b6a, 0x22, 0},
+	{0x5f700c1b, 0x23, 0},
+	{0x00133c2b, 0x24, 0},
+	{0x2d3e0f12, 0x25, 0},
+	{0x06363038, 0x26, 0},
+	{0x060e0a3e, 0x27, 0},
+	{0x0015161f, 0x28, 0},
+	{0x0809031b, 0x29, 0},
+	{0x181c0307, 0x2a, 0},
+	{0x051f1a1b, 0x2b, 0},
+	{0x00451dce, 0x2c, 0},
+	{0x242fde12, 0x2d, 0},
+	{0x0034e8fa, 0x2e, 0},
+	{0x00000007, 0x30, 0},
+	{0x16000d0c, 0x31, 0},
+	{0x0000011f, 0x32, 0},
+	{0x01000200, 0x33, 0},
+	{0x10bbf376, 0x34, 0},
+	{0x00000044, 0x35, 0},
+	{0x00000000, 0x36, 0},
+	{0x00000000, 0x37, 0},
+	{0x00000000, 0x38, 0},
+	{0x00000000, 0x39, 0},
+	{0x00000031, 0x3a, 0},
+	{0x4d6b0a58, 0x3b, 0},
+	{0x00000c04, 0x3c, 0},
+	{0x0d3b0a50, 0x3d, 0},
+	{0x03140480, 0x3e, 0},
+	{0x05e60452, 0x3f, 0},
+	{0x05780400, 0x40, 0},
+	{0x0063c025, 0x41, 0},
+	{0x05050202, 0x42, 0},
+	{0x5e4a0a14, 0x43, 0},
+	{0x00003b42, 0x44, 0},
+	{0xa53080ff, 0x45, 0},
+	{0x00000000, 0x46, 0},
+	{0x00133202, 0x47, 0},
+	{0x01f00000, 0x48, 0},
+	{0x00000000, 0x49, 0},
+	{0x00000000, 0x4a, 0},
+	{0x00000000, 0x4b, 0},
+	{0x00000000, 0x4c, 0},
+	{0x20405dc8, 0x4d, 0},
+	{0x00000000, 0x4e, 0},
+	{0x1f0205df, 0x4f, 0},
+	{0x00001120, 0x50, 0},
+	{0x4f190803, 0x51, 0},
+	{0x00000000, 0x52, 0},
+	{0x00000040, 0x53, 0},
+	{0x00100050, 0x54, 0},
+	{0x00cd1000, 0x55, 0},
+	{0x00010fab, 0x56, 0},
+	{0x03f0fc3f, 0x58, 0},
+	{0x02005014, 0x59, 0},
+	{0x01405014, 0x5a, 0},
+	{0x00014284, 0x5b, 0},
+	{0x00000320, 0x5c, 0},
+	{0x14130e05, 0x5d, 0},
+	{0x4321c963, 0x5f, 0},
+	{0x624668f8, 0x60, 0},
+	{0xccc08888, 0x61, 0},
+	{0x13212111, 0x62, 0},
+	{0x21100000, 0x63, 0},
+	{0x624668f8, 0x64, 0},
+	{0xccc08888, 0x65, 0},
+	{0x13212111, 0x66, 0},
+	{0x21100000, 0x67, 0},
+	{0x624668f8, 0x68, 0},
+	{0xccc08888, 0x69, 0},
+	{0x0, 0x0, 0}
+};
+#endif
+
+void dtmb_all_reset(void)
+{
+	int temp_data = 0;
+
+	if (is_meson_txl_cpu()) {
+		dtmb_write_reg(DTMB_FRONT_AFIFO_ADC, 0x1f);
+		/*modified bu xiaotong*/
+		dtmb_write_reg(DTMB_CHE_TPS_CONFIG, 0xc00000);
+		dtmb_write_reg(DTMB_CHE_EQ_CONFIG, 0x1a027719);
+		dtmb_write_reg(DTMB_FRONT_AGC_CONFIG1, 0x101a7);
+		dtmb_write_reg(DTMB_FRONT_47_CONFIG, 0x131a31);
+		/*detect 64qam 420 595 problems*/
+		dtmb_write_reg(DTMB_FRONT_19_CONFIG, 0x300);
+		dtmb_write_reg(DTMB_FRONT_4d_CONFIG, 0x12ffbe0);
+		/*fix fsm b bug*/
+		dtmb_write_reg(DTMB_FRONT_DEBUG_CFG, 0x5680000);
+		/*fix agc problem,skip warm_up status*/
+		dtmb_write_reg(DTMB_FRONT_46_CONFIG, 0x1a000f0f);
+		dtmb_write_reg(DTMB_FRONT_ST_FREQ, 0xf2400000);
+	} else {
+		dtmb_write_reg(DTMB_FRONT_AGC_CONFIG1, 0x10127);
+		dtmb_write_reg(DTMB_CHE_IBDFE_CONFIG6, 0x943228cc);
+		dtmb_write_reg(DTMB_CHE_IBDFE_CONFIG7, 0xc09aa8cd);
+		dtmb_write_reg(DTMB_CHE_FD_TD_COEFF, 0x0);
+		dtmb_write_reg(DTMB_CHE_EQ_CONFIG, 0x9dc59);
+		/*0x2 is auto,0x406 is  invert spectrum*/
+		if (dtmb_spectrum == 0)
+			dtmb_write_reg(DTMB_TOP_CTRL_TPS, 0x406);
+		else if (dtmb_spectrum == 1)
+			dtmb_write_reg(DTMB_TOP_CTRL_TPS, 0x402);
+		else
+			dtmb_write_reg(DTMB_TOP_CTRL_TPS, 0x2);
+
+		pr_dbg("dtmb_spectrum is %d\n", dtmb_spectrum);
+		dtmb_write_reg(DTMB_TOP_CTRL_FEC, 0x41444400);
+		dtmb_write_reg(DTMB_TOP_CTRL_INTLV_TIME, 0x180300);
+		dtmb_write_reg(DTMB_FRONT_DDC_BYPASS, 0x662ca0);
+		dtmb_write_reg(DTMB_FRONT_AFIFO_ADC, 0x29);
+		dtmb_write_reg(DTMB_FRONT_DC_HOLD, 0xa1066);
+		/*cci para*/
+		dtmb_write_reg(DTMB_CHE_M_CCI_THR_CONFIG3, 0x80201f6);
+		dtmb_write_reg(DTMB_CHE_M_CCI_THR_CONFIG2, 0x3f20080);
+		dtmb_write_reg(DTMB_CHE_TPS_CONFIG, 0xc00000);
+		dtmb_write_reg(DTMB_TOP_CTRL_AGC, 0x3);
+		dtmb_write_reg(DTMB_TOP_CTRL_TS_SFO_CFO, 0x20403006);
+		dtmb_write_reg(DTMB_FRONT_AGC_CONFIG2, 0x7200a16);
+		dtmb_write_reg(DTMB_FRONT_DEBUG_CFG, 0x1e00000);
+		dtmb_write_reg(DTMB_TOP_CTRL_ENABLE, 0x7fffff);
+		/*close ts3 timing loop*/
+		dtmb_write_reg(DTMB_TOP_CTRL_DAGC_CCI, 0x305);
+		/*dektec card issue,close f case snr drop*/
+		dtmb_write_reg(DTMB_CHE_MC_SC_TIMING_POWTHR, 0xc06100a);
+		if (demod_enable_performance) {
+			dtmb_write_reg(DTMB_CHE_IBDFE_CONFIG1, 0x4040002);
+			temp_data = dtmb_read_reg(DTMB_CHE_FD_TD_COEFF);
+		    temp_data = (temp_data & ~0x3fff)|(0x241f & 0x3fff);
+		    temp_data = temp_data | (1<<21);
+			/*Set freeze_mode and reset coeff*/
+		    dtmb_write_reg(DTMB_CHE_FD_TD_COEFF, temp_data);
+		    temp_data = temp_data & ~(1<<21);
+			/*Set freeze_mode and reset coeff*/
+		    dtmb_write_reg(DTMB_CHE_FD_TD_COEFF, temp_data);
+		}
+	}
+}
+
+void dtmb_initial(struct aml_demod_sta *demod_sta)
+{
+/* dtmb_write_reg(0x049, memstart);		//only for init */
+	dtmb_spectrum = 1;
+	dtmb_spectrum = demod_sta->spectrum;
+	dtmb_register_reset();
+	dtmb_all_reset();
+#if 0
+	int i;
+
+	for (i = 0; list_dtmb_v1[i].adr != 0; i++) {
+		if (list_dtmb_v1[i].rw)
+			apb_read_reg(DTMB_BASE + ((list_dtmb_v1[i].adr) << 2));
+		/* msleep(20); */
+		else
+			apb_write_reg(DTMB_BASE + ((list_dtmb_v1[i].adr) << 2),
+				      list_dtmb_v1[i].dat);
+		/* msleep(20); */
+	}
+#endif
+}
+
+int check_dtmb_fec_lock(void)
+{
+	int fec_lock, snr, status;
+
+	fec_lock = (dtmb_read_reg(DTMB_TOP_FEC_LOCK_SNR) >> 14) & 0x1;
+	snr = dtmb_read_reg(DTMB_TOP_FEC_LOCK_SNR) & 0x3fff;
+	if (fec_lock && (snr > 4))
+		status = 1;
+	else
+		status = 0;
+	return status;
+}
+
+int check_dtmb_mobile_det(void)
+{
+	int mobile_det = 0;
+
+	mobile_det = (dtmb_read_reg(DTMB_TOP_CTRL_SYS_OFDM_CNT) >> 8) & 0x7ffff;
+	return mobile_det;
+
+}
+
+
+int dtmb_information(void)
+{
+	int tps, snr, fec_lock, fec_bch_add, fec_ldpc_unc_acc, fec_ldpc_it_avg,
+	    tmp, che_snr;
+	struct aml_fe_dev *dev;
+
+	dev = NULL;
+	tps = dtmb_read_reg(DTMB_TOP_CTRL_CHE_WORKCNT);
+	tmp = dtmb_read_reg(DTMB_TOP_FEC_LOCK_SNR);
+	if (is_meson_txl_cpu())
+		che_snr = tmp & 0x3fff;
+	else
+		che_snr = tmp & 0xfff;
+	snr = che_snr;
+	snr = convert_snr(snr);
+	/*	if (che_snr >= 8192) */
+	/*		che_snr = che_snr - 16384;*/
+	/*	snr = che_snr / 32;*/
+	/* snr = 10*log10(snr)-6; */
+	fec_lock = (dtmb_read_reg(DTMB_TOP_FEC_LOCK_SNR) >> 14) & 0x1;
+	fec_bch_add = dtmb_read_reg(DTMB_TOP_FEC_BCH_ACC);
+	fec_ldpc_unc_acc = dtmb_read_reg(DTMB_TOP_FEC_LDPC_UNC_ACC);
+	fec_ldpc_it_avg = dtmb_read_reg(DTMB_TOP_FEC_LDPC_IT_AVG);
+	pr_dbg("FSM : %x %x %x %x\n",
+	       dtmb_read_reg(DTMB_TOP_CTRL_FSM_STATE0),
+	       dtmb_read_reg(DTMB_TOP_CTRL_FSM_STATE1),
+	       dtmb_read_reg(DTMB_TOP_CTRL_FSM_STATE2),
+	       dtmb_read_reg(DTMB_TOP_CTRL_FSM_STATE3));
+	pr_dbg
+	    ("AGC : agc_power %d,agc_if_gain %d,agc_rf_gain %d,",
+	     (-(((dtmb_read_reg(DTMB_TOP_FRONT_AGC) >> 22) & 0x3ff) / 16)),
+	     ((dtmb_read_reg(DTMB_TOP_FRONT_AGC)) & 0x3ff),
+	     ((dtmb_read_reg(DTMB_TOP_FRONT_AGC) >> 11) & 0x7ff));
+	pr_dbg
+	      ("dagc_power %3d,dagc_gain %3d mobi_det_power %d\n",
+	      ((dtmb_read_reg(DTMB_TOP_FRONT_DAGC) >> 0) & 0xff),
+	     ((dtmb_read_reg(DTMB_TOP_FRONT_DAGC) >> 8) & 0xfff),
+	     (dtmb_read_reg(DTMB_TOP_CTRL_SYS_OFDM_CNT) >> 8) & 0x7ffff);
+	pr_dbg
+	    ("TPS  SC or MC %2d,f_r %2d qam_nr %2d ",
+	     (dtmb_read_reg(DTMB_TOP_CHE_OBS_STATE1) >> 1) & 0x1,
+	     (tps >> 22) & 0x1, (tps >> 21) & 0x1);
+	pr_dbg
+		("intlv %2d,cr %2d constl %2d\n",
+		(tps >> 20) & 0x1,
+	     (tps >> 18) & 0x3, (tps >> 16) & 0x3);
+
+	pr_dbg
+	    ("[dtmb] snr is %d,fec_lock is %d,fec_bch_add is %d,",
+	     snr, fec_lock, fec_bch_add);
+	pr_dbg
+	    ("fec_ldpc_unc_acc is %d ,fec_ldpc_it_avg is %d\n",
+	     fec_ldpc_unc_acc,
+	     fec_ldpc_it_avg / 256);
+	pr_dbg
+	    ("------------------------------------------------------------\n");
+
+	tuner_get_ch_power(dev);
+
+	return 0;
+}
+
+int dtmb_check_cci(void)
+{
+	int cci_det = 0;
+
+	cci_det =
+	((dtmb_read_reg(DTMB_TOP_SYNC_CCI_NF2_POSITION) >> 22)
+		& 0x3);
+	if (cci_det > 0) {
+		pr_dbg("find cci\n");
+		dtmb_write_reg(DTMB_CHE_CCIDET_CONFIG, 0x20210290);
+		dtmb_write_reg(DTMB_CHE_M_CCI_THR_CONFIG3, 0x20081f6);
+		dtmb_write_reg(DTMB_CHE_M_CCI_THR_CONFIG2, 0x3f08020);
+	}
+	return cci_det;
+}
+
+int dtmb_bch_check(void)
+{
+	int fec_bch_add, i;
+
+	fec_bch_add = dtmb_read_reg(DTMB_TOP_FEC_BCH_ACC);
+	pr_dbg("[debug]fec lock,fec_bch_add is %d\n", fec_bch_add);
+	msleep(100);
+	if (((dtmb_read_reg(DTMB_TOP_FEC_BCH_ACC))-fec_bch_add) >= 50) {
+		pr_dbg("[debug]fec lock,but bch add ,need reset,wait not to reset\n");
+		dtmb_reset();
+		for (i = 0; i < 30; i++) {
+			msleep(100);
+			if (check_dtmb_fec_lock() == 1) {
+				pr_dbg("[debug]fec lock,but bch add ,need reset,now is lock\n");
+				return 0;
+			}
+		}
+	}
+	return 0;
+}
+
+int dtmb_constell_check(void)
+{
+	int constell;
+
+	constell = dtmb_read_reg(DTMB_TOP_CTRL_CHE_WORKCNT)>>16 & 0x3;
+	if (constell == 0)/*4qam*/
+		dtmb_write_reg(DTMB_FRONT_47_CONFIG, 0x133221);
+	else if (constell == 1)/*16qam*/
+		dtmb_write_reg(DTMB_FRONT_47_CONFIG, 0x132821);
+	else if (constell == 2)/*32qam*/
+		dtmb_write_reg(DTMB_FRONT_47_CONFIG, 0x131e21);
+	else if (constell == 3)/*64qam*/
+		dtmb_write_reg(DTMB_FRONT_47_CONFIG, 0x131a31);
+
+	return 0;
+}
+
+
+int dtmb_check_fsm(void)
+{
+	int tmp, fsm_status, i, has_singnal;
+
+	tmp = dtmb_read_reg(DTMB_TOP_CTRL_FSM_STATE0);
+	fsm_status =  tmp&0xffffffff;
+	has_singnal = 0;
+	pr_dbg("[rsj1] fsm_status is %x\n", fsm_status);
+	for (i = 0 ; i < 8 ; i++) {
+		if (((fsm_status >> (i*4)) & 0xf) > 3) {
+			/*has signal*/
+		/*	pr_dbg("has signal\n");*/
+			has_singnal = 1;
+		}
+	}
+	return has_singnal;
+
+}
+
+int patch_ts3(int delay1_us, int delay2_us)
+{
+	if (((dtmb_read_reg(DTMB_TOP_CTRL_FSM_STATE0)&0xf) == 0x7)&1) {
+		dtmb_write_reg(DTMB_TOP_CTRL_FSM, 0x300f);
+		dtmb_write_reg(DTMB_TOP_CTRL_FSM, 0x310f);
+		msleep(delay1_us);
+		dtmb_write_reg(DTMB_TOP_CTRL_ENABLE, 0xffdfff);
+		dtmb_write_reg(DTMB_TOP_CTRL_ENABLE, 0xffffff);
+		dtmb_write_reg(DTMB_TOP_CTRL_FSM, 0x3110);
+		dtmb_write_reg(DTMB_TOP_CTRL_FSM, 0x3010);
+		dtmb_write_reg(DTMB_TOP_CTRL_FSM, 0x3000);
+		return 1;
+	} else
+		return 0;
+}
+
+
+int read_cfo_all(void)
+{
+	int icfo_all, fcfo_all;
+
+	icfo_all = dtmb_read_reg(DTMB_TOP_CTRL_ICFO_ALL) & 0xfffff;
+	fcfo_all = dtmb_read_reg(DTMB_TOP_CTRL_FCFO_ALL) & 0x3fff;
+	if (icfo_all > (1 << 19))
+		icfo_all = icfo_all - (1 << 20);
+	if (fcfo_all > (1 << 13))
+		fcfo_all = fcfo_all - (1 << 14);
+
+	return (int)(icfo_all*4+fcfo_all);
+
+}
+
+
+int dtmb_v3_soft_sync(int cfo_init)
+{
+
+/*	int cfo_all;*/
+/*	int cfo_setting;*/
+
+	if (cfo_init == 0) {
+		cfo_init = patch_ts3(11, 0);
+		#if 0
+		if (cfo_init == 1) {
+			cfo_all = read_cfo_all();
+			cfo_setting = dtmb_read_reg(DTMB_FRONT_DDC_BYPASS);
+			dtmb_write_reg(DTMB_FRONT_DDC_BYPASS,
+			cfo_setting+cfo_all);
+			dtmb_write_reg(DTMB_TOP_CTRL_LOOP, 0x3);
+			dtmb_reset();
+		}
+		#endif
+	}
+	return cfo_init;
+
+}
+
+int dtmb_check_status_gxtv(struct dvb_frontend *fe)
+{
+	int local_state;
+	int time_cnt;/* cci_det, src_config;*/
+	int cfo_init, count;
+
+	dtmb_information();
+	time_cnt = 0;
+	local_state = 0;
+	cfo_init = 0;
+	if (check_dtmb_fec_lock() != 1) {
+		dtmb_register_reset();
+		dtmb_all_reset();
+		count = 15;
+		while ((count) &&
+		((dtmb_read_reg(DTMB_TOP_CTRL_FSM_STATE0)&0xf) < 0x6)) {
+			msleep(20);
+			count--;
+		}
+
+		count = demod_sync_count;
+		while ((count) && (cfo_init == 0)) {
+
+			cfo_init = dtmb_v3_soft_sync(cfo_init);
+
+			msleep(demod_sync_delay_time);
+			count--;
+		}
+		if ((cfo_init == 0) &&
+			((dtmb_read_reg(DTMB_TOP_CTRL_FSM_STATE0)&0xf) <= 7)) {
+			pr_dbg("over 400ms,status is %x, need reset\n",
+				(dtmb_read_reg(DTMB_TOP_CTRL_FSM_STATE0)&0xf));
+			return 0;
+		}
+		while ((time_cnt < 10) && (check_dtmb_fec_lock() != 1)) {
+			msleep(demod_timeout);
+			time_cnt++;
+			local_state = AMLOGIC_DTMB_STEP3;
+			dtmb_information();
+			dtmb_check_cci();
+			if (time_cnt > 8)
+				pr_dbg
+					("* local_state = %d\n", local_state);
+		}
+		if (time_cnt >= 10 && (check_dtmb_fec_lock() != 1)) {
+			local_state = AMLOGIC_DTMB_STEP4;
+			time_cnt = 0;
+			pr_dbg
+				("*all reset,timeout is %d\n", demod_timeout);
+		}
+	} else {
+		dtmb_check_cci();
+		dtmb_bch_check();
+	#if 0
+		cci_det = dtmb_check_cci();
+		if ((check_dtmb_mobile_det() <= demod_mobile_power)
+				&& (cci_det == 0)) {
+			/* open */
+			src_config = (dtmb_read_reg(DTMB_FRONT_SRC_CONFIG1));
+			dtmb_write_reg(DTMB_FRONT_SRC_CONFIG1,
+				src_config & (~(0x1 << 28)));
+		} else {
+			/* close */
+			src_config = (dtmb_read_reg(DTMB_FRONT_SRC_CONFIG1));
+			dtmb_write_reg(DTMB_FRONT_SRC_CONFIG1,
+				src_config | (0x1 << 28));
+		}
+	#endif
+	}
+	if (check_dtmb_fec_lock() == 1)
+		dtmb_write_reg(DTMB_TOP_CTRL_LOOP, 0xf);
+	return 0;
+}
+
+
+int dtmb_check_status_txl(struct dvb_frontend *fe)
+{
+	int time_cnt;
+
+	time_cnt = 0;
+	dtmb_information();
+	if (check_dtmb_fec_lock() != 1) {
+		while ((time_cnt < 10) && (check_dtmb_fec_lock() != 1)) {
+			msleep(demod_timeout);
+			time_cnt++;
+			dtmb_information();
+			if (((dtmb_read_reg(DTMB_TOP_CTRL_CHE_WORKCNT)
+				>> 21) & 0x1) == 0x1) {
+				pr_dbg("4qam-nr,need set spectrum\n");
+				if (dtmb_spectrum == 1) {
+					dtmb_write_reg
+					(DTMB_TOP_CTRL_TPS, 0x1010406);
+				} else if (dtmb_spectrum == 0) {
+					dtmb_write_reg
+					(DTMB_TOP_CTRL_TPS, 0x1010402);
+				} else {
+					dtmb_write_reg
+					(DTMB_TOP_CTRL_TPS, 0x1010002);
+				}
+			}
+			if (time_cnt > 8)
+				pr_dbg
+					("* time_cnt = %d\n", time_cnt);
+		}
+		if (time_cnt >= 10 && (check_dtmb_fec_lock() != 1)) {
+			time_cnt = 0;
+			dtmb_register_reset();
+			dtmb_all_reset();
+			if	(dtmb_spectrum == 0)
+				dtmb_spectrum = 1;
+			else
+				dtmb_spectrum = 0;
+			pr_dbg
+				("*all reset,timeout is %d\n", demod_timeout);
+		}
+	} else {
+		dtmb_bch_check();
+		dtmb_constell_check();
+	}
+	return 0;
+}
+
+
+void dtmb_reset(void)
+{
+	union DTMB_TOP_CTRL_SW_RST_BITS sw_rst;
+
+	sw_rst.b.ctrl_sw_rst = 1;
+	sw_rst.b.ctrl_sw_rst_noreg = 1;
+	dtmb_write_reg(DTMB_TOP_CTRL_SW_RST, sw_rst.d32);
+	sw_rst.b.ctrl_sw_rst = 0;
+	sw_rst.b.ctrl_sw_rst_noreg = 0;
+	dtmb_write_reg(DTMB_TOP_CTRL_SW_RST, sw_rst.d32);
+}
+
+void dtmb_register_reset(void)
+{
+	union DTMB_TOP_CTRL_SW_RST_BITS sw_rst;
+
+	sw_rst.b.ctrl_sw_rst = 1;
+	dtmb_write_reg(DTMB_TOP_CTRL_SW_RST, sw_rst.d32);
+	sw_rst.b.ctrl_sw_rst = 0;
+	dtmb_write_reg(DTMB_TOP_CTRL_SW_RST, sw_rst.d32);
+}
+
+int dtmb_set_ch(struct aml_demod_sta *demod_sta,
+		struct aml_demod_i2c *demod_i2c,
+		struct aml_demod_dtmb *demod_dtmb)
+{
+	int ret = 0;
+	u8 demod_mode;
+	u8 bw, sr, ifreq, agc_mode;
+	u32 ch_freq;
+
+	bw = demod_dtmb->bw;
+	sr = demod_dtmb->sr;
+	ifreq = demod_dtmb->ifreq;
+	agc_mode = demod_dtmb->agc_mode;
+	ch_freq = demod_dtmb->ch_freq;
+	demod_mode = demod_dtmb->dat0;
+	demod_sta->ch_mode = demod_dtmb->mode;	/* TODO */
+	demod_sta->agc_mode = agc_mode;
+	demod_sta->ch_freq = ch_freq;
+	demod_sta->dvb_mode = demod_mode;
+	demod_sta->ch_bw = (8 - bw) * 1000;
+	dtmb_initial(demod_sta);
+	pr_dbg("DTMB mode\n");
+	return ret;
+}
+
+int dvbt_set_ch(struct aml_demod_sta *demod_sta,
+		struct aml_demod_i2c *demod_i2c,
+		struct aml_demod_dvbt *demod_dvbt)
+{
+	int ret = 0;
+	u8_t demod_mode = 1;
+	u8_t bw, sr, ifreq, agc_mode;
+	u32_t ch_freq;
+
+	bw = demod_dvbt->bw;
+	sr = demod_dvbt->sr;
+	ifreq = demod_dvbt->ifreq;
+	agc_mode = demod_dvbt->agc_mode;
+	ch_freq = demod_dvbt->ch_freq;
+	demod_mode = demod_dvbt->dat0;
+	if (ch_freq < 1000 || ch_freq > 900000000) {
+		/* pr_dbg("Error: Invalid Channel Freq option %d\n",
+		 *ch_freq);
+		 */
+		ch_freq = 474000;
+		ret = -1;
+	}
+
+	if (demod_mode < 0 || demod_mode > 4) {
+		/* pr_dbg("Error: Invalid demod mode option %d\n",
+		 *demod_mode);
+		 */
+		demod_mode = 1;
+		ret = -1;
+	}
+
+	/* demod_sta->dvb_mode  = 1; */
+	demod_sta->ch_mode = 0;	/* TODO */
+	demod_sta->agc_mode = agc_mode;
+	demod_sta->ch_freq = ch_freq;
+	demod_sta->dvb_mode = demod_mode;
+	/*   if (demod_i2c->tuner == 1)
+	 *     demod_sta->ch_if = 36130;
+	 * else if (demod_i2c->tuner == 2)
+	 *     demod_sta->ch_if = 4570;
+	 * else if (demod_i2c->tuner == 3)
+	 *     demod_sta->ch_if = 4000;// It is nouse.(alan)
+	 * else if (demod_i2c->tuner == 7)
+	 *     demod_sta->ch_if = 5000;//silab 5000kHz IF
+	 */
+
+	demod_sta->ch_bw = (8 - bw) * 1000;
+	demod_sta->symb_rate = 0;	/* TODO */
+
+/* bw=0; */
+	demod_mode = 1;
+	/* for si2176 IF:5M   sr 28.57 */
+	sr = 4;
+	ifreq = 4;
+	if (bw == BANDWIDTH_AUTO)
+		demod_mode = 2;
+	ofdm_initial(bw,
+			/* 00:8M 01:7M 10:6M 11:5M */
+		     sr,
+		     /* 00:45M 01:20.8333M 10:20.7M 11:28.57  100:24m */
+		     ifreq,
+		     /* 000:36.13M 001:-5.5M 010:4.57M 011:4M 100:5M */
+		     demod_mode - 1,
+		     /* 00:DVBT,01:ISDBT */
+		     1
+		     /* 0: Unsigned, 1:TC */
+	    );
+	pr_dbg("DVBT/ISDBT mode\n");
+
+	return ret;
+}
+
+int demod_set_sys(struct aml_demod_sta *demod_sta,
+		  struct aml_demod_i2c *demod_i2c,
+		  struct aml_demod_sys *demod_sys)
+{
+/* int adc_clk; */
+/* demod_sta->tmp=Adc_mode; */
+	unsigned char dvb_mode;
+	int clk_adc, clk_dem;
+	int gpioDV_2;
+	int gpiW_2;
+
+	dvb_mode = demod_sta->dvb_mode;
+	clk_adc = demod_sys->adc_clk;
+	clk_dem = demod_sys->demod_clk;
+	pr_dbg
+	    ("demod_set_sys,clk_adc is %d,clk_demod is %d\n",
+	     clk_adc, clk_dem);
+	mutex_init(&mp);
+	clocks_set_sys_defaults(dvb_mode);
+	/* open dtv adc pinmux */
+	if (is_meson_txl_cpu()) {
+		gpioDV_2 = demod_read_demod_reg(0xc8834400 + (0x2e << 2));
+		pr_dbg("[R840]set adc pinmux,gpioDV_2 %x\n", gpioDV_2);
+		gpioDV_2 = gpioDV_2 | (0x1 << 22);
+		gpioDV_2 = gpioDV_2 & ~(0x3 << 19);
+		gpioDV_2 = gpioDV_2 & ~(0x1 << 23);
+		gpioDV_2 = gpioDV_2 & ~(0x1 << 31);
+		demod_set_demod_reg(gpioDV_2, 0xc8834400 + (0x2e << 2));
+		pr_dbg("[R840]set adc pinmux,gpioDV_2 %x\n", gpioDV_2);
+	} else {
+		gpiW_2 = demod_read_demod_reg(0xc88344c4);
+		gpiW_2 = gpiW_2 | (0x1 << 25);
+		gpiW_2 = gpiW_2 & ~(0xd << 24);
+		demod_set_demod_reg(gpiW_2, 0xc88344c4);
+		pr_dbg("[R840]set adc pinmux,gpiW_2 %x\n", gpiW_2);
+	}
+	/* set adc clk */
+	demod_set_adc_core_clk(clk_adc, clk_dem, dvb_mode);
+	/* init for dtmb */
+	if (dvb_mode == Gxtv_Dtmb) {
+		/* open arbit */
+	/*	demod_set_demod_reg(0x8, DEMOD_REG4);*/
+	}
+	demod_sta->adc_freq = clk_adc;
+	demod_sta->clk_freq = clk_dem;
+	return 0;
+}
+
+void demod_set_reg(struct aml_demod_reg *demod_reg)
+{
+	switch (demod_reg->mode) {
+	case 0:
+		demod_reg->addr = demod_reg->addr + QAM_BASE;
+		break;
+	case 1:
+	case 2:
+		demod_reg->addr = DTMB_TOP_ADDR(demod_reg->addr);
+		break;
+	case 3:
+		/* demod_reg->addr=ATSC_BASE; */
+		break;
+	case 4:
+		demod_reg->addr = demod_reg->addr * 4 + DEMOD_CFG_BASE;
+		break;
+	case 5:
+		demod_reg->addr = demod_reg->addr + DEMOD_BASE;
+		break;
+	case 6:
+		/* demod_reg->addr=demod_reg->addr*4+DEMOD_CFG_BASE; */
+		break;
+	case 11:
+		demod_reg->addr = demod_reg->addr;
+		break;
+	case 10:
+		/* demod_reg->addr=(u32_t)phys_to_virt(demod_reg->addr); */
+		break;
+	}
+
+	if (demod_reg->mode == 3)
+		atsc_write_reg(demod_reg->addr, demod_reg->val);
+	else if (demod_reg->mode == 11)
+		demod_set_cbus_reg(demod_reg->val, demod_reg->addr);
+	else if (demod_reg->mode == 10)
+		apb_write_reg_collect(demod_reg->addr, demod_reg->val);
+	/* demod_reg->val_high = apb_read_reg_high(demod_reg->addr); */
+	else
+		demod_set_demod_reg(demod_reg->val, demod_reg->addr);
+}
+
+void demod_get_reg(struct aml_demod_reg *demod_reg)
+{
+	if (demod_reg->mode == 0) {
+		demod_reg->addr = demod_reg->addr + QAM_BASE;
+	} else if ((demod_reg->mode == 1) || (demod_reg->mode == 2)) {
+		demod_reg->addr = DTMB_TOP_ADDR(demod_reg->addr);
+	} else if (demod_reg->mode == 3) {
+		/* demod_reg->addr=demod_reg->addr+ATSC_BASE; */
+	} else if (demod_reg->mode == 4) {
+		demod_reg->addr = demod_reg->addr * 4 + DEMOD_CFG_BASE;
+	} else if (demod_reg->mode == 5) {
+		demod_reg->addr = demod_reg->addr + DEMOD_BASE;
+	} else if (demod_reg->mode == 6) {
+		/* demod_reg->addr=demod_reg->addr*4+DEMOD_CFG_BASE; */
+	} else if (demod_reg->mode == 11) {
+		demod_reg->addr = demod_reg->addr;
+	} else if (demod_reg->mode == 10) {
+		/* printk("demod_reg->addr is %x\n",demod_reg->addr); */
+		/* test=(unsigned long)phys_to_virt(test); */
+/* demod_reg->addr=(unsigned long)phys_to_virt(demod_reg->addr); */
+/* printk("demod_reg->addr is %lx %x\n",test,demod_reg->addr); */
+	}
+
+	if (demod_reg->mode == 3) {
+		demod_reg->val = atsc_read_reg(demod_reg->addr);
+		/* apb_write_reg(ATSC_BASE+4, (demod_reg->addr&0xffff)<<8); */
+		/* demod_reg->val = apb_read_reg(ATSC_BASE)&0xff; */
+	} else if (demod_reg->mode == 6) {
+		demod_reg->val = atsc_read_iqr_reg();
+		/* apb_write_reg(ATSC_BASE+4, (demod_reg->addr&0xffff)<<8); */
+		/* demod_reg->val = apb_read_reg(ATSC_BASE)&0xff; */
+	} else if (demod_reg->mode == 11) {
+		demod_reg->val = demod_read_cbus_reg(demod_reg->addr);
+	} else if (demod_reg->mode == 10) {
+		demod_reg->val = apb_read_reg_collect(demod_reg->addr);
+	/*	demod_reg->val_high = apb_read_reg_high(demod_reg->addr);*/
+	} else {
+		demod_reg->val = demod_read_demod_reg(demod_reg->addr);
+	}
+}
+
+void apb_write_reg_collect(unsigned int addr, unsigned int data)
+{
+	writel(data, ((void __iomem *)(phys_to_virt(addr))));
+/* *(volatile unsigned int*)addr = data; */
+}
+
+unsigned long apb_read_reg_collect(unsigned long addr)
+{
+	unsigned long tmp;
+/*	void __iomem *vaddr;
+ *	vaddr = ioremap(((unsigned long)phys_to_virt(addr)), 0x4);
+ *	tmp = readl(vaddr);
+ *	iounmap(vaddr);
+ */
+	tmp = readl((void __iomem *)(phys_to_virt(addr)));
+/*tmp = *(volatile unsigned long *)((unsigned long)phys_to_virt(addr));*/
+/* printk("[all][read]%lx,data is %lx\n",addr,tmp); */
+	return tmp & 0xffffffff;
+}
+
+
+
+void apb_write_reg(unsigned int addr, unsigned int data)
+{
+	demod_set_demod_reg(data, addr);
+}
+
+unsigned long apb_read_reg_high(unsigned long addr)
+{
+	unsigned long tmp;
+
+	tmp = 0;
+	return (tmp >> 32) & 0xffffffff;
+}
+
+unsigned long apb_read_reg(unsigned long addr)
+{
+	return demod_read_demod_reg(addr);
+}
+
+void apb_write_regb(unsigned long addr, int index, unsigned long data)
+{
+	/*to achieve write func*/
+}
+
+void enable_qam_int(int idx)
+{
+	unsigned long mask;
+
+	mask = apb_read_reg(QAM_BASE + 0xd0);
+	mask |= (1 << idx);
+	apb_write_reg(QAM_BASE + 0xd0, mask);
+}
+
+void disable_qam_int(int idx)
+{
+	unsigned long mask;
+
+	mask = apb_read_reg(QAM_BASE + 0xd0);
+	mask &= ~(1 << idx);
+	apb_write_reg(QAM_BASE + 0xd0, mask);
+}
+
+char *qam_int_name[] = { "      ADC",
+	"   Symbol",
+	"       RS",
+	" In_Sync0",
+	" In_Sync1",
+	" In_Sync2",
+	" In_Sync3",
+	" In_Sync4",
+	"Out_Sync0",
+	"Out_Sync1",
+	"Out_Sync2",
+	"Out_Sync3",
+	"Out_Sync4",
+	"In_SyncCo",
+	"OutSyncCo",
+	"  In_Dagc",
+	" Out_Dagc",
+	"  Eq_Mode",
+	"RS_Uncorr"
+};
+
+#define OFDM_INT_STS         0
+#define OFDM_INT_EN          0
+
+void enable_ofdm_int(int ofdm_irq)
+{
+
+}
+
+void disable_ofdm_int(int ofdm_irq)
+{
+
+}
+
+char *ofdm_int_name[] = { "PFS_FCFO",
+	"PFS_ICFO",
+	" CS_FCFO",
+	" PFS_SFO",
+	" PFS_TPS",
+	"      SP",
+	"     CCI",
+	"  Symbol",
+	" In_Sync",
+	"Out_Sync",
+	"FSM Stat"
+};
+
+unsigned long read_ofdm_int(void)
+{
+
+	return 0;
+}
+
+#define PHS_LOOP_OPEN
+
+void qam_read_all_regs(void)
+{
+
+}
+
+void ini_icfo_pn_index(int mode)
+{				/* 00:DVBT,01:ISDBT */
+	if (mode == 0) {
+		apb_write_reg(DVBT_BASE + 0x3f8, 0x00000031);
+		apb_write_reg(DVBT_BASE + 0x3fc, 0x00030000);
+		apb_write_reg(DVBT_BASE + 0x3f8, 0x00000032);
+		apb_write_reg(DVBT_BASE + 0x3fc, 0x00057036);
+		apb_write_reg(DVBT_BASE + 0x3f8, 0x00000033);
+		apb_write_reg(DVBT_BASE + 0x3fc, 0x0009c08d);
+		apb_write_reg(DVBT_BASE + 0x3f8, 0x00000034);
+		apb_write_reg(DVBT_BASE + 0x3fc, 0x000c90c0);
+		apb_write_reg(DVBT_BASE + 0x3f8, 0x00000035);
+		apb_write_reg(DVBT_BASE + 0x3fc, 0x001170ff);
+		apb_write_reg(DVBT_BASE + 0x3f8, 0x00000036);
+		apb_write_reg(DVBT_BASE + 0x3fc, 0x0014d11a);
+	} else if (mode == 1) {
+		apb_write_reg(DVBT_BASE + 0x3f8, 0x00000031);
+		apb_write_reg(DVBT_BASE + 0x3fc, 0x00085046);
+		apb_write_reg(DVBT_BASE + 0x3f8, 0x00000032);
+		apb_write_reg(DVBT_BASE + 0x3fc, 0x0019a0e9);
+		apb_write_reg(DVBT_BASE + 0x3f8, 0x00000033);
+		apb_write_reg(DVBT_BASE + 0x3fc, 0x0024b1dc);
+		apb_write_reg(DVBT_BASE + 0x3f8, 0x00000034);
+		apb_write_reg(DVBT_BASE + 0x3fc, 0x003b3313);
+		apb_write_reg(DVBT_BASE + 0x3f8, 0x00000035);
+		apb_write_reg(DVBT_BASE + 0x3fc, 0x0048d409);
+		apb_write_reg(DVBT_BASE + 0x3f8, 0x00000036);
+		apb_write_reg(DVBT_BASE + 0x3fc, 0x00527509);
+	}
+}
+
+static int coef[] = {
+	0xf900, 0xfe00, 0x0000, 0x0000, 0x0100, 0x0100, 0x0000, 0x0000,
+	0xfd00, 0xf700, 0x0000, 0x0000, 0x4c00, 0x0000, 0x0000, 0x0000,
+	0x2200, 0x0c00, 0x0000, 0x0000, 0xf700, 0xf700, 0x0000, 0x0000,
+	0x0300, 0x0900, 0x0000, 0x0000, 0x0600, 0x0600, 0x0000, 0x0000,
+	0xfc00, 0xf300, 0x0000, 0x0000, 0x2e00, 0x0000, 0x0000, 0x0000,
+	0x3900, 0x1300, 0x0000, 0x0000, 0xfa00, 0xfa00, 0x0000, 0x0000,
+	0x0100, 0x0200, 0x0000, 0x0000, 0xf600, 0x0000, 0x0000, 0x0000,
+	0x0700, 0x0700, 0x0000, 0x0000, 0xfe00, 0xfb00, 0x0000, 0x0000,
+	0x0900, 0x0000, 0x0000, 0x0000, 0x3200, 0x1100, 0x0000, 0x0000,
+	0x0400, 0x0400, 0x0000, 0x0000, 0xfe00, 0xfb00, 0x0000, 0x0000,
+	0x0e00, 0x0000, 0x0000, 0x0000, 0xfb00, 0xfb00, 0x0000, 0x0000,
+	0x0100, 0x0200, 0x0000, 0x0000, 0xf400, 0x0000, 0x0000, 0x0000,
+	0x3900, 0x1300, 0x0000, 0x0000, 0x1700, 0x1700, 0x0000, 0x0000,
+	0xfc00, 0xf300, 0x0000, 0x0000, 0x0c00, 0x0000, 0x0000, 0x0000,
+	0x0300, 0x0900, 0x0000, 0x0000, 0xee00, 0x0000, 0x0000, 0x0000,
+	0x2200, 0x0c00, 0x0000, 0x0000, 0x2600, 0x2600, 0x0000, 0x0000,
+	0xfd00, 0xf700, 0x0000, 0x0000, 0x0200, 0x0000, 0x0000, 0x0000,
+	0xf900, 0xfe00, 0x0000, 0x0000, 0x0400, 0x0b00, 0x0000, 0x0000,
+	0xf900, 0x0000, 0x0000, 0x0000, 0x0700, 0x0200, 0x0000, 0x0000,
+	0x2100, 0x2100, 0x0000, 0x0000, 0x0200, 0x0700, 0x0000, 0x0000,
+	0xf900, 0x0000, 0x0000, 0x0000, 0x0b00, 0x0400, 0x0000, 0x0000,
+	0xfe00, 0xf900, 0x0000, 0x0000, 0x0200, 0x0000, 0x0000, 0x0000,
+	0xf700, 0xfd00, 0x0000, 0x0000, 0x2600, 0x2600, 0x0000, 0x0000,
+	0x0c00, 0x2200, 0x0000, 0x0000, 0xee00, 0x0000, 0x0000, 0x0000,
+	0x0900, 0x0300, 0x0000, 0x0000, 0x0c00, 0x0000, 0x0000, 0x0000,
+	0xf300, 0xfc00, 0x0000, 0x0000, 0x1700, 0x1700, 0x0000, 0x0000,
+	0x1300, 0x3900, 0x0000, 0x0000, 0xf400, 0x0000, 0x0000, 0x0000,
+	0x0200, 0x0100, 0x0000, 0x0000, 0xfb00, 0xfb00, 0x0000, 0x0000,
+	0x0e00, 0x0000, 0x0000, 0x0000, 0xfb00, 0xfe00, 0x0000, 0x0000,
+	0x0400, 0x0400, 0x0000, 0x0000, 0x1100, 0x3200, 0x0000, 0x0000,
+	0x0900, 0x0000, 0x0000, 0x0000, 0xfb00, 0xfe00, 0x0000, 0x0000,
+	0x0700, 0x0700, 0x0000, 0x0000, 0xf600, 0x0000, 0x0000, 0x0000,
+	0x0200, 0x0100, 0x0000, 0x0000, 0xfa00, 0xfa00, 0x0000, 0x0000,
+	0x1300, 0x3900, 0x0000, 0x0000, 0x2e00, 0x0000, 0x0000, 0x0000,
+	0xf300, 0xfc00, 0x0000, 0x0000, 0x0600, 0x0600, 0x0000, 0x0000,
+	0x0900, 0x0300, 0x0000, 0x0000, 0xf700, 0xf700, 0x0000, 0x0000,
+	0x0c00, 0x2200, 0x0000, 0x0000, 0x4c00, 0x0000, 0x0000, 0x0000,
+	0xf700, 0xfd00, 0x0000, 0x0000, 0x0100, 0x0100, 0x0000, 0x0000,
+	0xfe00, 0xf900, 0x0000, 0x0000, 0x0b00, 0x0400, 0x0000, 0x0000,
+	0xfc00, 0xfc00, 0x0000, 0x0000, 0x0200, 0x0700, 0x0000, 0x0000,
+	0x4200, 0x0000, 0x0000, 0x0000, 0x0700, 0x0200, 0x0000, 0x0000,
+	0xfc00, 0xfc00, 0x0000, 0x0000, 0x0400, 0x0b00, 0x0000, 0x0000
+};
+
+void tfd_filter_coff_ini(void)
+{
+	int i = 0;
+
+	for (i = 0; i < 336; i++) {
+		apb_write_reg(DVBT_BASE + 0x99 * 4, (i << 16) | coef[i]);
+		apb_write_reg(DVBT_BASE + 0x03 * 4, (1 << 12));
+	}
+}
+
+void ofdm_initial(int bandwidth,
+		/* 00:8M 01:7M 10:6M 11:5M */
+		int samplerate,
+		/* 00:45M 01:20.8333M 10:20.7M 11:28.57 100: 24.00 */
+		int IF,
+		/* 000:36.13M 001:-5.5M 010:4.57M 011:4M 100:5M */
+		int mode,
+		/* 00:DVBT,01:ISDBT */
+		int tc_mode
+		/* 0: Unsigned, 1:TC */
+		)
+{
+#if 0
+	int tmp;
+	int ch_if;
+	int adc_freq;
+
+	pr_dbg
+	    ("[ofdm_initial]bandwidth is %d,samplerate is %d",
+	     bandwidth, samplerate);
+	pr_dbg
+	    ("IF is %d, mode is %d,tc_mode is %d\n",
+	    IF, mode, tc_mode);
+	switch (IF) {
+	case 0:
+		ch_if = 36130;
+		break;
+	case 1:
+		ch_if = -5500;
+		break;
+	case 2:
+		ch_if = 4570;
+		break;
+	case 3:
+		ch_if = 4000;
+		break;
+	case 4:
+		ch_if = 5000;
+		break;
+	default:
+		ch_if = 4000;
+		break;
+	}
+	switch (samplerate) {
+	case 0:
+		adc_freq = 45000;
+		break;
+	case 1:
+		adc_freq = 20833;
+		break;
+	case 2:
+		adc_freq = 20700;
+		break;
+	case 3:
+		adc_freq = 28571;
+		break;
+	case 4:
+		adc_freq = 24000;
+		break;
+	default:
+		adc_freq = 28571;
+		break;
+	}
+
+	apb_write_reg(DVBT_BASE + (0x02 << 2), 0x00800000);
+	/* SW reset bit[23] ; write anything to zero */
+	apb_write_reg(DVBT_BASE + (0x00 << 2), 0x00000000);
+
+	apb_write_reg(DVBT_BASE + (0xe << 2), 0xffff);
+	/* enable interrupt */
+
+	if (mode == 0) {	/* DVBT */
+		switch (samplerate) {
+		case 0:
+			apb_write_reg(DVBT_BASE + (0x08 << 2), 0x00005a00);
+			break;	/* 45MHz */
+		case 1:
+			apb_write_reg(DVBT_BASE + (0x08 << 2), 0x000029aa);
+			break;	/* 20.833 */
+		case 2:
+			apb_write_reg(DVBT_BASE + (0x08 << 2), 0x00002966);
+			break;	/* 20.7   SAMPLERATE*512 */
+		case 3:
+			apb_write_reg(DVBT_BASE + (0x08 << 2), 0x00003924);
+			break;	/* 28.571 */
+		case 4:
+			apb_write_reg(DVBT_BASE + (0x08 << 2), 0x00003000);
+			break;	/* 24 */
+		default:
+			apb_write_reg(DVBT_BASE + (0x08 << 2), 0x00003924);
+			break;	/* 28.571 */
+		}
+	} else {		/* ISDBT */
+		switch (samplerate) {
+		case 0:
+			apb_write_reg(DVBT_BASE + (0x08 << 2), 0x0000580d);
+			break;	/* 45MHz */
+		case 1:
+			apb_write_reg(DVBT_BASE + (0x08 << 2), 0x0000290d);
+			break;	/* 20.833 = 56/7 * 20.8333 / (512/63)*512 */
+		case 2:
+			apb_write_reg(DVBT_BASE + (0x08 << 2), 0x000028da);
+			break;	/* 20.7 */
+		case 3:
+			apb_write_reg(DVBT_BASE + (0x08 << 2), 0x0000383F);
+			break;	/* 28.571  3863 */
+		case 4:
+			apb_write_reg(DVBT_BASE + (0x08 << 2), 0x00002F40);
+			break;	/* 24 */
+		default:
+			apb_write_reg(DVBT_BASE + (0x08 << 2), 0x00003863);
+			break;	/* 28.571 */
+		}
+	}
+/* memstart=0x93900000; */
+	pr_dbg("memstart is %x\n", memstart);
+	apb_write_reg(DVBT_BASE + (0x10 << 2), memstart);
+	/* 0x8f300000 */
+
+	apb_write_reg(DVBT_BASE + (0x14 << 2), 0xe81c4ff6);
+	/* AGC_TARGET 0xf0121385 */
+
+	switch (samplerate) {
+	case 0:
+		apb_write_reg(DVBT_BASE + (0x15 << 2), 0x018c2df2);
+		break;
+	case 1:
+		apb_write_reg(DVBT_BASE + (0x15 << 2), 0x0185bdf2);
+		break;
+	case 2:
+		apb_write_reg(DVBT_BASE + (0x15 << 2), 0x0185bdf2);
+		break;
+	case 3:
+		apb_write_reg(DVBT_BASE + (0x15 << 2), 0x0187bdf2);
+		break;
+	case 4:
+		apb_write_reg(DVBT_BASE + (0x15 << 2), 0x0187bdf2);
+		break;
+	default:
+		apb_write_reg(DVBT_BASE + (0x15 << 2), 0x0187bdf2);
+		break;
+	}
+	if (tc_mode == 1)
+		apb_write_regb(DVBT_BASE + (0x15 << 2), 11, 0);
+	/* For TC mode. Notice, For ADC input is Unsigned,
+	 *For Capture Data, It is TC.
+	 */
+	apb_write_regb(DVBT_BASE + (0x15 << 2), 26, 1);
+	/* [19:0] = [I , Q], I is high, Q is low. This bit is swap I/Q. */
+
+	apb_write_reg(DVBT_BASE + (0x16 << 2), 0x00047f80);
+	/* AGC_IFGAIN_CTRL */
+	apb_write_reg(DVBT_BASE + (0x17 << 2), 0x00027f80);
+	/* AGC_RFGAIN_CTRL */
+	apb_write_reg(DVBT_BASE + (0x18 << 2), 0x00000190);
+	/* AGC_IFGAIN_ACCUM */
+	apb_write_reg(DVBT_BASE + (0x19 << 2), 0x00000190);
+	/* AGC_RFGAIN_ACCUM */
+	if (ch_if < 0)
+		ch_if += adc_freq;
+	if (ch_if > adc_freq)
+		ch_if -= adc_freq;
+
+	tmp = ch_if * (1 << 15) / adc_freq;
+	apb_write_reg(DVBT_BASE + (0x20 << 2), tmp);
+
+	apb_write_reg(DVBT_BASE + (0x21 << 2), 0x001ff000);
+	/* DDC CS_FCFO_ADJ_CTRL */
+	apb_write_reg(DVBT_BASE + (0x22 << 2), 0x00000000);
+	/* DDC ICFO_ADJ_CTRL */
+	apb_write_reg(DVBT_BASE + (0x23 << 2), 0x00004000);
+	/* DDC TRACK_FCFO_ADJ_CTRL */
+
+	apb_write_reg(DVBT_BASE + (0x27 << 2), (1 << 23)
+	| (3 << 19) | (3 << 15) |  (1000 << 4) | 9);
+	/* {8'd0,1'd1,4'd3,4'd3,11'd50,4'd9});//FSM_1 */
+	apb_write_reg(DVBT_BASE + (0x28 << 2), (100 << 13) | 1000);
+	/* {8'd0,11'd40,13'd50});//FSM_2 */
+	apb_write_reg(DVBT_BASE + (0x29 << 2), (31 << 20) | (1 << 16) |
+	(24 << 9) | (3 << 6) | 20);
+	/* {5'd0,7'd127,1'd0,3'd0,7'd24,3'd5,6'd20}); */
+
+	if (mode == 0) {	/* DVBT */
+		if (bandwidth == 0) {	/* 8M */
+			switch (samplerate) {
+			case 0:
+				ini_acf_iireq_src_45m_8m();
+				apb_write_reg(DVBT_BASE + (0x44 << 2),
+					      0x004ebf2e);
+				break;	/* 45M */
+			case 1:
+				ini_acf_iireq_src_207m_8m();
+				apb_write_reg(DVBT_BASE + (0x44 << 2),
+					      0x00247551);
+				break;	/* 20.833M */
+			case 2:
+				ini_acf_iireq_src_207m_8m();
+				apb_write_reg(DVBT_BASE + (0x44 << 2),
+					      0x00243999);
+				break;	/* 20.7M */
+			case 3:
+				ini_acf_iireq_src_2857m_8m();
+				apb_write_reg(DVBT_BASE + (0x44 << 2),
+					      0x0031ffcd);
+				break;	/* 28.57M */
+			case 4:
+				ini_acf_iireq_src_24m_8m();
+				apb_write_reg(DVBT_BASE + (0x44 << 2),
+					      0x002A0000);
+				break;	/* 24M */
+			default:
+				ini_acf_iireq_src_2857m_8m();
+				apb_write_reg(DVBT_BASE + (0x44 << 2),
+					      0x0031ffcd);
+				break;	/* 28.57M */
+			}
+		} else if (bandwidth == 1) {	/* 7M */
+			switch (samplerate) {
+			case 0:
+				ini_acf_iireq_src_45m_7m();
+				apb_write_reg(DVBT_BASE + (0x44 << 2),
+					      0x0059ff10);
+				break;	/* 45M */
+			case 1:
+				ini_acf_iireq_src_207m_7m();
+				apb_write_reg(DVBT_BASE + (0x44 << 2),
+					      0x0029aaa6);
+				break;	/* 20.833M */
+			case 2:
+				ini_acf_iireq_src_207m_7m();
+				apb_write_reg(DVBT_BASE + (0x44 << 2),
+					      0x00296665);
+				break;	/* 20.7M */
+			case 3:
+				ini_acf_iireq_src_2857m_7m();
+				apb_write_reg(DVBT_BASE + (0x44 << 2),
+					      0x00392491);
+				break;	/* 28.57M */
+			case 4:
+				ini_acf_iireq_src_24m_7m();
+				apb_write_reg(DVBT_BASE + (0x44 << 2),
+					      0x00300000);
+				break;	/* 24M */
+			default:
+				ini_acf_iireq_src_2857m_7m();
+				apb_write_reg(DVBT_BASE + (0x44 << 2),
+					      0x00392491);
+				break;	/* 28.57M */
+			}
+		} else if (bandwidth == 2) {	/* 6M */
+			switch (samplerate) {
+			case 0:
+				ini_acf_iireq_src_45m_6m();
+				apb_write_reg(DVBT_BASE + (0x44 << 2),
+					      0x00690000);
+				break;	/* 45M */
+			case 1:
+				ini_acf_iireq_src_207m_6m();
+				apb_write_reg(DVBT_BASE + (0x44 << 2),
+					      0x00309c3e);
+				break;	/* 20.833M */
+			case 2:
+				ini_acf_iireq_src_207m_6m();
+				apb_write_reg(DVBT_BASE + (0x44 << 2),
+					      0x002eaaaa);
+				break;	/* 20.7M */
+			case 3:
+				ini_acf_iireq_src_2857m_6m();
+				apb_write_reg(DVBT_BASE + (0x44 << 2),
+					      0x0042AA69);
+				break;	/* 28.57M */
+			case 4:
+				ini_acf_iireq_src_24m_6m();
+				apb_write_reg(DVBT_BASE + (0x44 << 2),
+					      0x00380000);
+				break;	/* 24M */
+			default:
+				ini_acf_iireq_src_2857m_6m();
+				apb_write_reg(DVBT_BASE + (0x44 << 2),
+					      0x0042AA69);
+				break;	/* 28.57M */
+			}
+		} else {	/* 5M */
+			switch (samplerate) {
+			case 0:
+				ini_acf_iireq_src_45m_5m();
+				apb_write_reg(DVBT_BASE + (0x44 << 2),
+					      0x007dfbe0);
+				break;	/* 45M */
+			case 1:
+				ini_acf_iireq_src_207m_5m();
+				apb_write_reg(DVBT_BASE + (0x44 << 2),
+					      0x003a554f);
+				break;	/* 20.833M */
+			case 2:
+				ini_acf_iireq_src_207m_5m();
+				apb_write_reg(DVBT_BASE + (0x44 << 2),
+					      0x0039f5c0);
+				break;	/* 20.7M */
+			case 3:
+				ini_acf_iireq_src_2857m_5m();
+				apb_write_reg(DVBT_BASE + (0x44 << 2),
+					      0x004FFFFE);
+				break;	/* 28.57M */
+			case 4:
+				ini_acf_iireq_src_24m_5m();
+				apb_write_reg(DVBT_BASE + (0x44 << 2),
+					      0x00433333);
+				break;	/* 24M */
+			default:
+				ini_acf_iireq_src_2857m_5m();
+				apb_write_reg(DVBT_BASE + (0x44 << 2),
+					      0x004FFFFE);
+				break;	/* 28.57M */
+			}
+		}
+	} else {		/* ISDBT */
+		switch (samplerate) {
+		case 0:
+			ini_acf_iireq_src_45m_6m();
+			apb_write_reg(DVBT_BASE + (0x44 << 2), 0x00589800);
+			break;
+
+/*  45M
+ *			SampleRate/(symbolRate)*2^20,
+ *			symbolRate = 512/63 for isdbt
+ */
+		case 1:
+			ini_acf_iireq_src_207m_6m();
+			apb_write_reg(DVBT_BASE + (0x44 << 2), 0x002903d4);
+			break;	/* 20.833M */
+		case 2:
+			ini_acf_iireq_src_207m_6m();
+			apb_write_reg(DVBT_BASE + (0x44 << 2), 0x00280ccc);
+			break;	/* 20.7M */
+		case 3:
+			ini_acf_iireq_src_2857m_6m();
+			apb_write_reg(DVBT_BASE + (0x44 << 2), 0x00383fc8);
+			break;	/* 28.57M */
+		case 4:
+			ini_acf_iireq_src_24m_6m();
+			apb_write_reg(DVBT_BASE + (0x44 << 2), 0x002F4000);
+			break;	/* 24M */
+		default:
+			ini_acf_iireq_src_2857m_6m();
+			apb_write_reg(DVBT_BASE + (0x44 << 2), 0x00383fc8);
+			break;	/* 28.57M */
+		}
+	}
+
+	if (mode == 0)		/* DVBT */
+		apb_write_reg(DVBT_BASE + (0x02 << 2),
+			      (bandwidth << 20) | 0x10002);
+	else			/* ISDBT */
+		apb_write_reg(DVBT_BASE + (0x02 << 2), (1 << 20) | 0x1001a);
+	/* {0x000,2'h1,20'h1_001a});    // For ISDBT , bandwidth should be 1, */
+
+	apb_write_reg(DVBT_BASE + (0x45 << 2), 0x00000000);
+	/* SRC SFO_ADJ_CTRL */
+	apb_write_reg(DVBT_BASE + (0x46 << 2), 0x02004000);
+	/* SRC SFO_ADJ_CTRL */
+	apb_write_reg(DVBT_BASE + (0x48 << 2), 0x000c0287);
+	/* DAGC_CTRL1 */
+	apb_write_reg(DVBT_BASE + (0x49 << 2), 0x00000005);
+	/* DAGC_CTRL2 */
+	apb_write_reg(DVBT_BASE + (0x4c << 2), 0x00000bbf);
+	/* CCI_RP */
+	apb_write_reg(DVBT_BASE + (0x4d << 2), 0x00000376);
+	/* CCI_RPSQ */
+	apb_write_reg(DVBT_BASE + (0x4e << 2), 0x0f0f1d09);
+	/* CCI_CTRL */
+	apb_write_reg(DVBT_BASE + (0x4f << 2), 0x00000000);
+	/* CCI DET_INDX1 */
+	apb_write_reg(DVBT_BASE + (0x50 << 2), 0x00000000);
+	/* CCI DET_INDX2 */
+	apb_write_reg(DVBT_BASE + (0x51 << 2), 0x00000000);
+	/* CCI_NOTCH1_A1 */
+	apb_write_reg(DVBT_BASE + (0x52 << 2), 0x00000000);
+	/* CCI_NOTCH1_A2 */
+	apb_write_reg(DVBT_BASE + (0x53 << 2), 0x00000000);
+	/* CCI_NOTCH1_B1 */
+	apb_write_reg(DVBT_BASE + (0x54 << 2), 0x00000000);
+	/* CCI_NOTCH2_A1 */
+	apb_write_reg(DVBT_BASE + (0x55 << 2), 0x00000000);
+	/* CCI_NOTCH2_A2 */
+	apb_write_reg(DVBT_BASE + (0x56 << 2), 0x00000000);
+	/* CCI_NOTCH2_B1 */
+	apb_write_reg(DVBT_BASE + (0x58 << 2), 0x00000885);
+	/* MODE_DETECT_CTRL // 582 */
+	if (mode == 0)		/* DVBT */
+		apb_write_reg(DVBT_BASE + (0x5c << 2), 0x00001011);	/*  */
+	else
+		apb_write_reg(DVBT_BASE + (0x5c << 2), 0x00000753);
+	/* ICFO_EST_CTRL ISDBT ICFO thres = 2 */
+
+	apb_write_reg(DVBT_BASE + (0x5f << 2), 0x0ffffe10);
+	/* TPS_FCFO_CTRL */
+	apb_write_reg(DVBT_BASE + (0x61 << 2), 0x0000006c);
+	/* FWDT ctrl */
+	apb_write_reg(DVBT_BASE + (0x68 << 2), 0x128c3929);
+	apb_write_reg(DVBT_BASE + (0x69 << 2), 0x91017f2d);
+	/* 0x1a8 */
+	apb_write_reg(DVBT_BASE + (0x6b << 2), 0x00442211);
+	/* 0x1a8 */
+	apb_write_reg(DVBT_BASE + (0x6c << 2), 0x01fc400a);
+	/* 0x */
+	apb_write_reg(DVBT_BASE + (0x6d << 2), 0x0030303f);
+	/* 0x */
+	apb_write_reg(DVBT_BASE + (0x73 << 2), 0xffffffff);
+	/* CCI0_PILOT_UPDATE_CTRL */
+	apb_write_reg(DVBT_BASE + (0x74 << 2), 0xffffffff);
+	/* CCI0_DATA_UPDATE_CTRL */
+	apb_write_reg(DVBT_BASE + (0x75 << 2), 0xffffffff);
+	/* CCI1_PILOT_UPDATE_CTRL */
+	apb_write_reg(DVBT_BASE + (0x76 << 2), 0xffffffff);
+	/* CCI1_DATA_UPDATE_CTRL */
+
+	tmp = mode == 0 ? 0x000001a2 : 0x00000da2;
+	apb_write_reg(DVBT_BASE + (0x78 << 2), tmp);	/* FEC_CTR */
+
+	apb_write_reg(DVBT_BASE + (0x7d << 2), 0x0000009d);
+	apb_write_reg(DVBT_BASE + (0x7e << 2), 0x00004000);
+	apb_write_reg(DVBT_BASE + (0x7f << 2), 0x00008000);
+
+	apb_write_reg(DVBT_BASE + ((0x8b + 0) << 2), 0x20002000);
+	apb_write_reg(DVBT_BASE + ((0x8b + 1) << 2), 0x20002000);
+	apb_write_reg(DVBT_BASE + ((0x8b + 2) << 2), 0x20002000);
+	apb_write_reg(DVBT_BASE + ((0x8b + 3) << 2), 0x20002000);
+	apb_write_reg(DVBT_BASE + ((0x8b + 4) << 2), 0x20002000);
+	apb_write_reg(DVBT_BASE + ((0x8b + 5) << 2), 0x20002000);
+	apb_write_reg(DVBT_BASE + ((0x8b + 6) << 2), 0x20002000);
+	apb_write_reg(DVBT_BASE + ((0x8b + 7) << 2), 0x20002000);
+
+	apb_write_reg(DVBT_BASE + (0x93 << 2), 0x31);
+	apb_write_reg(DVBT_BASE + (0x94 << 2), 0x00);
+	apb_write_reg(DVBT_BASE + (0x95 << 2), 0x7f1);
+	apb_write_reg(DVBT_BASE + (0x96 << 2), 0x20);
+
+	apb_write_reg(DVBT_BASE + (0x98 << 2), 0x03f9115a);
+	apb_write_reg(DVBT_BASE + (0x9b << 2), 0x000005df);
+
+	apb_write_reg(DVBT_BASE + (0x9c << 2), 0x00100000);
+	/* TestBus write valid, 0 is system clk valid */
+	apb_write_reg(DVBT_BASE + (0x9d << 2), 0x01000000);
+	/* DDR Start address */
+	apb_write_reg(DVBT_BASE + (0x9e << 2), 0x02000000);
+	/* DDR End   address */
+
+	apb_write_regb(DVBT_BASE + (0x9b << 2), 7, 0);
+	/* Enable Testbus dump to DDR */
+	apb_write_regb(DVBT_BASE + (0x9b << 2), 8, 0);
+	/* Run Testbus dump to DDR */
+
+	apb_write_reg(DVBT_BASE + (0xd6 << 2), 0x00000003);
+	/* apb_write_reg(DVBT_BASE+(0xd7<<2), 0x00000008); */
+	apb_write_reg(DVBT_BASE + (0xd8 << 2), 0x00000120);
+	apb_write_reg(DVBT_BASE + (0xd9 << 2), 0x01010101);
+
+	ini_icfo_pn_index(mode);
+	tfd_filter_coff_ini();
+
+	calculate_cordic_para();
+	msleep(20);
+	/* delay_us(1); */
+
+	apb_write_reg(DVBT_BASE + (0x02 << 2),
+		      apb_read_reg(DVBT_BASE + (0x02 << 2)) | (1 << 0));
+	apb_write_reg(DVBT_BASE + (0x02 << 2),
+		      apb_read_reg(DVBT_BASE + (0x02 << 2)) | (1 << 24));
+#endif
+/* dvbt_check_status(); */
+}
+
+void calculate_cordic_para(void)
+{
+	apb_write_reg(DVBT_BASE + 0x0c, 0x00000040);
+}
+
+char *ofdm_fsm_name[] = { "    IDLE",
+	"     AGC",
+	"     CCI",
+	"     ACQ",
+	"    SYNC",
+	"TRACKING",
+	"  TIMING",
+	" SP_SYNC",
+	" TPS_DEC",
+	"FEC_LOCK",
+	"FEC_LOST"
+};
+
+void check_fsm_state(void)
+{
+	unsigned long tmp;
+
+	tmp = apb_read_reg(DVBT_BASE + 0xa8);
+	/* printk(">>>>>>>>>>>>>>>>>>>>>>>>> OFDM FSM From %d
+	 *to %d\n", tmp>>4&0xf, tmp&0xf);
+	 */
+
+	if ((tmp & 0xf) == 3) {
+		apb_write_regb(DVBT_BASE + (0x9b << 2), 8, 1);
+		/* Stop dump testbus; */
+		apb_write_regb(DVBT_BASE + (0x0f << 2), 0, 1);
+		tmp = apb_read_reg(DVBT_BASE + (0x9f << 2));
+		/* printk(">>>>>>>>>>>>>>>>>>>>>>>>> STOP DUMP DATA To DDR :
+		 *End Addr %d,Is it overflow?%d\n", tmp>>1, tmp&0x1);
+		 */
+	}
+}
+
+void ofdm_read_all_regs(void)
+{
+	int i;
+	unsigned long tmp;
+
+	for (i = 0; i < 0xff; i++)
+		tmp = apb_read_reg(DVBT_BASE + 0x00 + i * 4);
+	/* printk("OFDM Reg (0x%x) is 0x%x\n", i, tmp); */
+
+}
+
+static int dvbt_get_status(struct aml_demod_sta *demod_sta,
+			   struct aml_demod_i2c *demod_i2c)
+{
+	return apb_read_reg(DVBT_BASE + 0x0) >> 12 & 1;
+}
+
+static int dvbt_get_ber(struct aml_demod_sta *demod_sta,
+			struct aml_demod_i2c *demod_i2c)
+{
+/* pr_dbg("[RSJ]per is %u\n",apb_read_reg(DVBT_BASE+(0xbf<<2))); */
+	return apb_read_reg(DVBT_BASE + (0xbf << 2));
+}
+
+static int dvbt_get_snr(struct aml_demod_sta *demod_sta,
+			struct aml_demod_i2c *demod_i2c)
+{
+/* pr_dbg("2snr is %u\n",((apb_read_reg(DVBT_BASE+(0x0a<<2)))>>20)&0x3ff); */
+	return ((apb_read_reg(DVBT_BASE + (0x0a << 2))) >> 20) & 0x3ff;
+	/*dBm: bit0~bit2=decimal */
+}
+
+static int dvbt_get_strength(struct aml_demod_sta *demod_sta,
+			     struct aml_demod_i2c *demod_i2c)
+{
+/* int dbm = dvbt_get_ch_power(demod_sta, demod_i2c); */
+/* return dbm; */
+	return 0;
+}
+
+static int dvbt_get_ucblocks(struct aml_demod_sta *demod_sta,
+			     struct aml_demod_i2c *demod_i2c)
+{
+	return 0;
+/* return dvbt_get_per(); */
+}
+
+struct demod_status_ops *dvbt_get_status_ops(void)
+{
+	static struct demod_status_ops ops = {
+		.get_status = dvbt_get_status,
+		.get_ber = dvbt_get_ber,
+		.get_snr = dvbt_get_snr,
+		.get_strength = dvbt_get_strength,
+		.get_ucblocks = dvbt_get_ucblocks,
+	};
+
+	return &ops;
+}
+
+int app_apb_read_reg(int addr)
+{
+	addr = DTMB_TOP_ADDR(addr);
+	return (int)demod_read_demod_reg(addr);
+}
+
+int app_apb_write_reg(int addr, int data)
+{
+	addr = DTMB_TOP_ADDR(addr);
+	demod_set_demod_reg(data, addr);
+	return 0;
+}
+
+void monitor_isdbt(void)
+{
+	int SNR;
+	int SNR_SP = 500;
+	int SNR_TPS = 0;
+	int SNR_CP = 0;
+	int timeStamp = 0;
+	int SFO_residual = 0;
+	int SFO_esti = 0;
+	int FCFO_esti = 0;
+	int FCFO_residual = 0;
+	int AGC_Gain = 0;
+	int RF_AGC = 0;
+	int Signal_power = 0;
+	int FECFlag = 0;
+	int EQ_seg_ratio = 0;
+	int tps_0 = 0;
+	int tps_1 = 0;
+	int tps_2 = 0;
+
+	int time_stamp;
+	int SFO;
+	int FCFO;
+	int timing_adj;
+	int RS_CorrectNum;
+
+	int cnt;
+	int tmpAGCGain;
+
+	tmpAGCGain = 0;
+	cnt = 0;
+
+/* app_apb_write_reg(0x8, app_apb_read_reg(0x8) & ~(1 << 17));
+ * // TPS symbol index update : active high
+ */
+	time_stamp = app_apb_read_reg(0x07) & 0xffff;
+	SNR = app_apb_read_reg(0x0a);
+	FECFlag = (app_apb_read_reg(0x00) >> 11) & 0x3;
+	SFO = app_apb_read_reg(0x47) & 0xfff;
+	SFO_esti = app_apb_read_reg(0x60) & 0xfff;
+	FCFO_esti = (app_apb_read_reg(0x60) >> 11) & 0xfff;
+	FCFO = (app_apb_read_reg(0x26)) & 0xffffff;
+	RF_AGC = app_apb_read_reg(0x0c) & 0x1fff;
+	timing_adj = app_apb_read_reg(0x6f) & 0x1fff;
+	RS_CorrectNum = app_apb_read_reg(0xc1) & 0xfffff;
+	Signal_power = (app_apb_read_reg(0x1b)) & 0x1ff;
+	EQ_seg_ratio = app_apb_read_reg(0x6e) & 0x3ffff;
+	tps_0 = app_apb_read_reg(0x64);
+	tps_1 = app_apb_read_reg(0x65);
+	tps_2 = app_apb_read_reg(0x66) & 0xf;
+
+	timeStamp = (time_stamp >> 8) * 68 + (time_stamp & 0x7f);
+	SFO_residual = (SFO > 0x7ff) ? (SFO - 0x1000) : SFO;
+	FCFO_residual = (FCFO > 0x7fffff) ? (FCFO - 0x1000000) : FCFO;
+	/* RF_AGC          = (RF_AGC>0x3ff)? (RF_AGC - 0x800): RF_AGC; */
+	FCFO_esti = (FCFO_esti > 0x7ff) ? (FCFO_esti - 0x1000) : FCFO_esti;
+	SNR_CP = (SNR) & 0x3ff;
+	SNR_TPS = (SNR >> 10) & 0x3ff;
+	SNR_SP = (SNR >> 20) & 0x3ff;
+	SNR_SP = (SNR_SP > 0x1ff) ? SNR_SP - 0x400 : SNR_SP;
+	SNR_TPS = (SNR_TPS > 0x1ff) ? SNR_TPS - 0x400 : SNR_TPS;
+	SNR_CP = (SNR_CP > 0x1ff) ? SNR_CP - 0x400 : SNR_CP;
+	AGC_Gain = tmpAGCGain >> 4;
+	tmpAGCGain = (AGC_Gain > 0x3ff) ? AGC_Gain - 0x800 : AGC_Gain;
+	timing_adj = (timing_adj > 0xfff) ? timing_adj - 0x2000 : timing_adj;
+	EQ_seg_ratio =
+	    (EQ_seg_ratio > 0x1ffff) ? EQ_seg_ratio - 0x40000 : EQ_seg_ratio;
+
+	pr_dbg
+	    ("T %4x SP %3d TPS %3d CP %3d EQS %8x RSC %4d",
+	     app_apb_read_reg(0xbf)
+	     , SNR_SP, SNR_TPS, SNR_CP
+/* ,EQ_seg_ratio */
+	     , app_apb_read_reg(0x62)
+	     , RS_CorrectNum);
+	pr_dbg
+	    ("SFO %4d FCFO %4d Vit %4x Timing %3d SigP %3x",
+	    SFO_residual, FCFO_residual, RF_AGC, timing_adj,
+	     Signal_power);
+	pr_dbg
+	    ("FEC %x RSErr %8x ReSyn %x tps %03x%08x",
+	    FECFlag, app_apb_read_reg(0x0b)
+	     , (app_apb_read_reg(0xc0) >> 20) & 0xff,
+	     app_apb_read_reg(0x05) & 0xfff, app_apb_read_reg(0x04)
+	    );
+	pr_dbg("\n");
+}
+
+int find_2(int data, int *table, int len)
+{
+	int end;
+	int index;
+	int start;
+	int cnt = 0;
+
+	start = 0;
+	end = len;
+	/* printf("data is %d\n",data); */
+	while ((len > 1) && (cnt < 10)) {
+		cnt++;
+		index = (len / 2);
+		if (data > table[start + index]) {
+			start = start + index;
+			len = len - index - 1;
+		}
+		if (data < table[start + index]) {
+			len = index + 1;
+		} else if (data == table[start + index]) {
+			start = start + index;
+			break;
+		}
+	}
+	return start;
+}
+
+int read_atsc_all_reg(void)
+{
+	return 0;
+#if 0
+	int i, j, k;
+
+	j = 4;
+	unsigned long data;
+
+	pr_dbg("system agc is:");	/* system agc */
+	for (i = 0xc00; i <= 0xc0c; i++) {
+		data = atsc_read_reg(i);
+		if (j == 4) {
+			pr_dbg("\n[addr:0x%x]", i);
+			j = 0;
+		}
+		pr_dbg("%02x   ", data);
+		j++;
+	}
+	j = 4;
+	for (i = 0xc80; i <= 0xc87; i++) {
+		data = atsc_read_reg(i);
+		if (j == 4) {
+			pr_dbg("\n[addr:0x%x]", i);
+			j = 0;
+		}
+		pr_dbg("%02x   ", data);
+		j++;
+	}
+	pr_dbg("\n vsb control is:");	/*vsb control */
+	j = 4;
+	for (i = 0x900; i <= 0x905; i++) {
+		data = atsc_read_reg(i);
+		if (j == 4) {
+			pr_dbg("\n[addr:0x%x]", i);
+			j = 0;
+		}
+		pr_dbg("%02x   ", data);
+		j++;
+	}
+	j = 4;
+	for (i = 0x908; i <= 0x912; i++) {
+		data = atsc_read_reg(i);
+		if (j == 4) {
+			pr_dbg("\n[addr:0x%x]", i);
+			j = 0;
+		}
+		pr_dbg("%02x   ", data);
+		j++;
+	}
+	j = 4;
+	for (i = 0x917; i <= 0x91b; i++) {
+		data = atsc_read_reg(i);
+		if (j == 4) {
+			pr_dbg("\n[addr:0x%x]", i);
+			j = 0;
+		}
+		pr_dbg("%02x   ", data);
+		j++;
+	}
+	j = 4;
+	for (i = 0x980; i <= 0x992; i++) {
+		data = atsc_read_reg(i);
+		if (j == 4) {
+			pr_dbg("\n[addr:0x%x]", i);
+			j = 0;
+		}
+		pr_dbg("%02x   ", data);
+		j++;
+	}
+	pr_dbg("\n vsb demod is:");	/*vsb demod */
+	j = 4;
+	for (i = 0x700; i <= 0x711; i++) {
+		data = atsc_read_reg(i);
+		if (j == 4) {
+			pr_dbg("\n[addr:0x%x]", i);
+			j = 0;
+		}
+		pr_dbg("%02x   ", data);
+		j++;
+	}
+	j = 4;
+	for (i = 0x716; i <= 0x720; i++) {
+		data = atsc_read_reg(i);
+		if (j == 4) {
+			pr_dbg("\n[addr:0x%x]", i);
+			j = 0;
+		}
+		pr_dbg("%02x   ", data);
+		j++;
+	}
+	j = 4;
+	for (i = 0x722; i <= 0x724; i++) {
+		data = atsc_read_reg(i);
+		if (j == 4) {
+			pr_dbg("\n[addr:0x%x]", i);
+			j = 0;
+		}
+		pr_dbg("%02x   ", data);
+		j++;
+	}
+	j = 4;
+	for (i = 0x726; i <= 0x72c; i++) {
+		data = atsc_read_reg(i);
+		if (j == 4) {
+			pr_dbg("\n[addr:0x%x]", i);
+			j = 0;
+		}
+		pr_dbg("%02x   ", data);
+		j++;
+	}
+	j = 4;
+	for (i = 0x730; i <= 0x732; i++) {
+		data = atsc_read_reg(i);
+		if (j == 4) {
+			pr_dbg("\n[addr:0x%x]", i);
+			j = 0;
+		}
+		pr_dbg("%02x   ", data);
+		j++;
+	}
+	j = 4;
+	for (i = 0x735; i <= 0x751; i++) {
+		data = atsc_read_reg(i);
+		if (j == 4) {
+			pr_dbg("\n[addr:0x%x]", i);
+			j = 0;
+		}
+		pr_dbg("%02x   ", data);
+		j++;
+	}
+	j = 4;
+	for (i = 0x780; i <= 0x795; i++) {
+		data = atsc_read_reg(i);
+		if (j == 4) {
+			pr_dbg("\n[addr:0x%x]", i);
+			j = 0;
+		}
+		pr_dbg("%02x   ", data);
+		j++;
+	}
+	j = 4;
+	for (i = 0x752; i <= 0x755; i++) {
+		data = atsc_read_reg(i);
+		if (j == 4) {
+			pr_dbg("\n[addr:0x%x]", i);
+			j = 0;
+		}
+		pr_dbg("%02x   ", data);
+		j++;
+	}
+	pr_dbg("\n vsb equalizer is:");	/*vsb equalizer */
+	j = 4;
+	for (i = 0x501; i <= 0x5ff; i++) {
+		data = atsc_read_reg(i);
+		if (j == 4) {
+			pr_dbg("\n[addr:0x%x]", i);
+			j = 0;
+		}
+		pr_dbg("%02x   ", data);
+		j++;
+	}
+	pr_dbg("\n vsb fec is:");	/*vsb fec */
+	j = 4;
+	for (i = 0x601; i <= 0x601; i++) {
+		data = atsc_read_reg(i);
+		if (j == 4) {
+			pr_dbg("\n[addr:0x%x]", i);
+			j = 0;
+		}
+		pr_dbg("%02x   ", data);
+		j++;
+	}
+	j = 4;
+	for (i = 0x682; i <= 0x685; i++) {
+		data = atsc_read_reg(i);
+		if (j == 4) {
+			pr_dbg("\n[addr:0x%x]", i);
+			j = 0;
+		}
+		pr_dbg("%02x   ", data);
+		j++;
+	}
+	pr_dbg("\n qam demod is:");	/*qam demod */
+	j = 4;
+	for (i = 0x1; i <= 0x1a; i++) {
+		data = atsc_read_reg(i);
+		if (j == 4) {
+			pr_dbg("\n[addr:0x%x]", i);
+			j = 0;
+		}
+		pr_dbg("%02x   ", data);
+		j++;
+	}
+	j = 4;
+	for (i = 0x25; i <= 0x28; i++) {
+		data = atsc_read_reg(i);
+		if (j == 4) {
+			pr_dbg("\n[addr:0x%x]", i);
+			j = 0;
+		}
+		pr_dbg("%02x   ", data);
+		j++;
+	}
+	j = 4;
+	for (i = 0x101; i <= 0x10b; i++) {
+		data = atsc_read_reg(i);
+		if (j == 4) {
+			pr_dbg("\n[addr:0x%x]", i);
+			j = 0;
+		}
+		pr_dbg("%02x   ", data);
+		j++;
+	}
+	j = 4;
+	for (i = 0x206; i <= 0x207; i++) {
+		data = atsc_read_reg(i);
+		if (j == 4) {
+			pr_dbg("\n[addr:0x%x]", i);
+			j = 0;
+		}
+		pr_dbg("%02x   ", data);
+		j++;
+	}
+	pr_dbg("\n qam equalize is:");	/*qam equalize */
+	j = 4;
+	for (i = 0x200; i <= 0x23d; i++) {
+		data = atsc_read_reg(i);
+		if (j == 4) {
+			pr_dbg("\n[addr:0x%x]", i);
+			j = 0;
+		}
+		pr_dbg("%02x   ", data);
+		j++;
+	}
+	j = 4;
+	for (i = 0x260; i <= 0x275; i++) {
+		data = atsc_read_reg(i);
+		if (j == 4) {
+			pr_dbg("\n[addr:0x%x]", i);
+			j = 0;
+		}
+		pr_dbg("%02x   ", data);
+		j++;
+	}
+	pr_dbg("\n qam fec is:");	/*qam fec */
+	j = 4;
+	for (i = 0x400; i <= 0x418; i++) {
+		data = atsc_read_reg(i);
+		if (j == 4) {
+			pr_dbg("\n[addr:0x%x]", i);
+			j = 0;
+		}
+		pr_dbg("%02x   ", data);
+		j++;
+	}
+	pr_dbg("\n system mpeg formatter is:");	/*system mpeg formatter */
+	j = 4;
+	for (i = 0xf00; i <= 0xf09; i++) {
+		data = atsc_read_reg(i);
+		if (j == 4) {
+			pr_dbg("\n[addr:0x%x]", i);
+			j = 0;
+		}
+		pr_dbg("%02x   ", data);
+		j++;
+	}
+	pr_dbg("\n\n");
+	return 0;
+#endif
+}
+
+int check_atsc_fsm_status(void)
+{
+	int SNR;
+	int atsc_snr = 0;
+	int SNR_dB;
+	int SNR_table[56] = { 0, 7, 9, 11, 14,
+		17,
+		22,
+		27, 34, 43, 54,
+		68, 86, 108, 136, 171,
+		215,
+		271, 341,
+		429, 540,
+		566, 592, 620, 649, 680,
+		712,
+		746, 781,
+		818, 856,
+		896, 939, 983, 1029, 1078,
+		1182,
+		1237,
+		1237, 1296, 1357,
+		1708, 2150, 2707, 3408, 4291,
+		5402,
+		6800,
+		8561, 10778, 13568,
+		16312, 17081, 18081, 19081, 65536
+	};
+	int SNR_dB_table[56] = { 360, 350, 340, 330, 320, 310, 300,
+		290,
+		280,
+		270, 260,
+		250, 240, 230, 220, 210, 200, 190,
+		180,
+		170,
+		160,
+		158, 156, 154, 152, 150, 148, 146,
+		144,
+		142,
+		140,
+		138, 136, 134, 132, 130, 128, 126,
+		124,
+		122,
+		120,
+		110, 100, 90, 80, 70, 60, 50,
+		40,
+		30,
+		20,
+		12, 10, 4, 2, 0
+	};
+
+	int tmp[3];
+	int cr;
+	int ck;
+	int SM;
+	int tni;
+	int ber;
+	int per;
+
+	int cnt;
+
+	cnt = 0;
+	ber = 0;
+	per = 0;
+
+/* g_demod_mode    = 2; */
+	tni = atsc_read_reg((0x08) >> 16);
+/* g_demod_mode    = 4; */
+	tmp[0] = atsc_read_reg(0x0511);
+	tmp[1] = atsc_read_reg(0x0512);
+	SNR = (tmp[0] << 8) + tmp[1];
+	SNR_dB = SNR_dB_table[find_2(SNR, SNR_table, 56)];
+
+	tmp[0] = atsc_read_reg(0x0780);
+	tmp[1] = atsc_read_reg(0x0781);
+	tmp[2] = atsc_read_reg(0x0782);
+	cr = tmp[0] + (tmp[1] << 8) + (tmp[2] << 16);
+	tmp[0] = atsc_read_reg(0x0786);
+	tmp[1] = atsc_read_reg(0x0787);
+	tmp[2] = atsc_read_reg(0x0788);
+	ck = (tmp[0] << 16) + (tmp[1] << 8) + tmp[2];
+	ck = (ck > 8388608) ? ck - 16777216 : ck;
+	SM = atsc_read_reg(0x0980);
+/* ber per */
+	atsc_write_reg(0x0601, atsc_read_reg(0x0601) & (~(1 << 3)));
+	atsc_write_reg(0x0601, atsc_read_reg(0x0601) | (1 << 3));
+	ber = atsc_read_reg(0x0683) + (atsc_read_reg(0x0682) << 8);
+	per = atsc_read_reg(0x0685) + (atsc_read_reg(0x0684) << 8);
+
+/* read_atsc_all_reg(); */
+
+	pr_dbg
+	    ("INT %x SNR %x SNRdB %d.%d FSM %x cr %d ck %d",
+	     tni, SNR, (SNR_dB / 10)
+	     , (SNR_dB - (SNR_dB / 10) * 10)
+	     , SM, cr, ck);
+	pr_dbg
+		("ber is %d, per is %d\n",
+		ber, per);
+
+	atsc_snr = (SNR_dB / 10);
+	return atsc_snr;
+
+	/*   unsigned long sm,snr1,snr2,snr;
+	 * static int fec_lock_cnt = 0;
+	 *
+	 * delay_us(10000);
+	 * sm = atsc_read_reg(0x0980);
+	 * snr1 = atsc_read_reg(0x0511)&0xff;
+	 * snr2 = atsc_read_reg(0x0512)&0xff;
+	 * snr  = (snr1 << 8) + snr2;
+	 *
+	 * printk(">>>>>>>>>>>>>>>>>>>>>>>>>
+	 OFDM FSM %x    SNR %x\n", sm&0xff, snr);
+	 *
+	 * if (sm == 0x79) stimulus_finish_pass();
+	 */
+}
diff --git a/drivers/stream_input/tv_frontend/dtv_demod/dvbc_func.c b/drivers/stream_input/tv_frontend/dtv_demod/dvbc_func.c
new file mode 100644
index 0000000..cf2ea81
--- /dev/null
+++ b/drivers/stream_input/tv_frontend/dtv_demod/dvbc_func.c
@@ -0,0 +1,1331 @@
+/*
+* Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT
+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+* more details.
+*
+* You should have received a copy of the GNU General Public License along
+* with this program; if not, write to the Free Software Foundation, Inc.,
+* 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+*
+* Description:
+*/
+#include <linux/kernel.h>
+#include <linux/i2c.h>
+#include <linux/delay.h>
+#include <linux/dvb/aml_demod.h>
+#include "demod_func.h"
+#include <linux/kthread.h>
+
+static int debug_amldvbc = 1;
+#define dprintk(a ...) do { if (debug_amldvbc) printk(a); } while (0)
+
+static struct task_struct *cci_task;
+int cciflag;
+struct timer_list mytimer;
+
+static void dvbc_cci_timer(unsigned long data)
+{
+#if 0
+	int count;
+	int maxCCI_p, re, im, j, i, times, maxCCI, sum, sum1, reg_0xf0, tmp1,
+	    tmp, tmp2, reg_0xa8, reg_0xac;
+	int reg_0xa8_t, reg_0xac_t;
+
+	count = 100;
+	if ((((apb_read_reg(QAM_BASE + 0x18)) & 0x1) == 1)) {
+		dprintk("[cci]lock ");
+		if (cciflag == 0) {
+			apb_write_reg(QAM_BASE + 0xa8, 0);
+
+			cciflag = 0;
+		}
+		dprintk("\n");
+		mdelay(500);
+		mod_timer(&mytimer, jiffies + 2 * HZ);
+		return;
+	}
+	if (cciflag == 1) {
+		dprintk("[cci]cciflag is 1,wait 20\n");
+		mdelay(20000);
+	}
+	times = 300;
+	tmp = 0x2be2be3;
+	/*0x2ae4772;  IF = 6M, fs = 35M, dec2hex(round(8*IF/fs*2^25)) */
+	tmp2 = 0x2000;
+	tmp1 = 8;
+	reg_0xa8 = 0xc0000000;	/* bypass CCI */
+	reg_0xac = 0xc0000000;	/* bypass CCI */
+
+	maxCCI = 0;
+	maxCCI_p = 0;
+	for (i = 0; i < times; i++) {
+		/*reg_0xa8 = app_apb_read_reg(0xa8); */
+		reg_0xa8_t = reg_0xa8 + tmp + i * tmp2;
+		apb_write_reg(QAM_BASE + 0xa8, reg_0xa8_t);
+		reg_0xac_t = reg_0xac + tmp - i * tmp2;
+		apb_write_reg(QAM_BASE + 0xac, reg_0xac_t);
+		sum = 0;
+		sum1 = 0;
+		for (j = 0; j < tmp1; j++) {
+			/* msleep(20); */
+			/* mdelay(20); */
+			reg_0xf0 = apb_read_reg(QAM_BASE + 0xf0);
+			re = (reg_0xf0 >> 24) & 0xff;
+			im = (reg_0xf0 >> 16) & 0xff;
+			if (re > 127)
+				/*re = re - 256; */
+				re = 256 - re;
+			if (im > 127)
+				/*im = im - 256; */
+				im = 256 - im;
+
+			sum += re + im;
+			re = (reg_0xf0 >> 8) & 0xff;
+			im = (reg_0xf0 >> 0) & 0xff;
+			if (re > 127)
+				/*re = re - 256; */
+				re = 256 - re;
+			if (im > 127)
+				/*im = im - 256; */
+				im = 256 - im;
+
+			sum1 += re + im;
+		}
+		sum = sum / tmp1;
+		sum1 = sum1 / tmp1;
+		if (sum1 > sum) {
+			sum = sum1;
+			reg_0xa8_t = reg_0xac_t;
+		}
+		if (sum > maxCCI) {
+			maxCCI = sum;
+			if (maxCCI > 24)
+				maxCCI_p = reg_0xa8_t & 0x7fffffff;
+		}
+		if ((sum < 24) && (maxCCI_p > 0))
+			break;	/* stop CCI detect. */
+	}
+
+	if (maxCCI_p > 0) {
+		apb_write_reg(QAM_BASE + 0xa8, maxCCI_p & 0x7fffffff);
+		/* enable CCI */
+		apb_write_reg(QAM_BASE + 0xac, maxCCI_p & 0x7fffffff);
+		/* enable CCI */
+		/*     if(dvbc.mode == 4) // 256QAM */
+		apb_write_reg(QAM_BASE + 0x54, 0xa25705fa);
+		/**/ cciflag = 1;
+		mdelay(1000);
+	} else {
+		dprintk
+		    ("[cci] ------------  find NO CCI -------------------\n");
+		cciflag = 0;
+	}
+
+	dprintk("[cci][%s]--------------------------\n", __func__);
+	mod_timer(&mytimer, jiffies + 2 * HZ);
+	return;
+/*      }*/
+#endif
+}
+
+int dvbc_timer_init(void)
+{
+	dprintk("%s\n", __func__);
+	setup_timer(&mytimer, dvbc_cci_timer, (unsigned long)"Hello, world!");
+	mytimer.expires = jiffies + 2 * HZ;
+	add_timer(&mytimer);
+	return 0;
+}
+
+void dvbc_timer_exit(void)
+{
+	dprintk("%s\n", __func__);
+	del_timer(&mytimer);
+}
+
+int dvbc_cci_task(void *data)
+{
+	int count;
+	int maxCCI_p, re, im, j, i, times, maxCCI, sum, sum1, reg_0xf0, tmp1,
+	    tmp, tmp2, reg_0xa8, reg_0xac;
+	int reg_0xa8_t, reg_0xac_t;
+
+	count = 100;
+	while (1) {
+		msleep(200);
+		if ((((apb_read_reg(QAM_BASE + 0x18)) & 0x1) == 1)) {
+			dprintk("[cci]lock ");
+			if (cciflag == 0) {
+				apb_write_reg(QAM_BASE + 0xa8, 0);
+				apb_write_reg(QAM_BASE + 0xac, 0);
+				dprintk("no cci ");
+				cciflag = 0;
+			}
+			dprintk("\n");
+			msleep(500);
+			continue;
+		}
+
+		if (cciflag == 1) {
+			dprintk("[cci]cciflag is 1,wait 20\n");
+			msleep(20000);
+		}
+		times = 300;
+		tmp = 0x2be2be3;
+		/*0x2ae4772; IF = 6M,fs = 35M, dec2hex(round(8*IF/fs*2^25)) */
+		tmp2 = 0x2000;
+		tmp1 = 8;
+		reg_0xa8 = 0xc0000000;	/* bypass CCI */
+		reg_0xac = 0xc0000000;	/* bypass CCI */
+
+		maxCCI = 0;
+		maxCCI_p = 0;
+		for (i = 0; i < times; i++) {
+			/*reg_0xa8 = app_apb_read_reg(0xa8); */
+			reg_0xa8_t = reg_0xa8 + tmp + i * tmp2;
+			apb_write_reg(QAM_BASE + 0xa8, reg_0xa8_t);
+			reg_0xac_t = reg_0xac + tmp - i * tmp2;
+			apb_write_reg(QAM_BASE + 0xac, reg_0xac_t);
+			sum = 0;
+			sum1 = 0;
+			for (j = 0; j < tmp1; j++) {
+				/*         msleep(1); */
+				reg_0xf0 = apb_read_reg(QAM_BASE + 0xf0);
+				re = (reg_0xf0 >> 24) & 0xff;
+				im = (reg_0xf0 >> 16) & 0xff;
+				if (re > 127)
+					/*re = re - 256; */
+					re = 256 - re;
+				if (im > 127)
+					/*im = im - 256; */
+					im = 256 - im;
+
+				sum += re + im;
+
+				re = (reg_0xf0 >> 8) & 0xff;
+				im = (reg_0xf0 >> 0) & 0xff;
+				if (re > 127)
+					/*re = re - 256; */
+					re = 256 - re;
+				if (im > 127)
+					/*im = im - 256; */
+					im = 256 - im;
+
+				sum1 += re + im;
+			}
+			sum = sum / tmp1;
+			sum1 = sum1 / tmp1;
+			if (sum1 > sum) {
+				sum = sum1;
+				reg_0xa8_t = reg_0xac_t;
+			}
+			if (sum > maxCCI) {
+				maxCCI = sum;
+				if (maxCCI > 24)
+					maxCCI_p = reg_0xa8_t & 0x7fffffff;
+			}
+
+			if ((sum < 24) && (maxCCI_p > 0))
+				break;	/* stop CCI detect. */
+		}
+
+		if (maxCCI_p > 0) {
+			apb_write_reg(QAM_BASE + 0xa8, maxCCI_p & 0x7fffffff);
+			/* enable CCI */
+			apb_write_reg(QAM_BASE + 0xac, maxCCI_p & 0x7fffffff);
+			/* enable CCI */
+			/*     if(dvbc.mode == 4) // 256QAM */
+			apb_write_reg(QAM_BASE + 0x54, 0xa25705fa);
+			/**/ cciflag = 1;
+			msleep(1000);
+		} else {
+			cciflag = 0;
+		}
+
+		dprintk("[cci][%s]--------------------------\n", __func__);
+	}
+	return 0;
+}
+
+int dvbc_get_cci_task(void)
+{
+	if (cci_task)
+		return 0;
+	else
+		return 1;
+}
+
+void dvbc_create_cci_task(void)
+{
+	int ret;
+
+	/*apb_write_reg(QAM_BASE+0xa8, 0x42b2ebe3); // enable CCI */
+	/* apb_write_reg(QAM_BASE+0xac, 0x42b2ebe3); // enable CCI */
+/*     if(dvbc.mode == 4) // 256QAM*/
+	/* apb_write_reg(QAM_BASE+0x54, 0xa25705fa); // */
+	ret = 0;
+	cci_task = kthread_create(dvbc_cci_task, NULL, "cci_task");
+	if (ret != 0) {
+		dprintk("[%s]Create cci kthread error!\n", __func__);
+		cci_task = NULL;
+		return;
+	}
+	wake_up_process(cci_task);
+	dprintk("[%s]Create cci kthread and wake up!\n", __func__);
+}
+
+void dvbc_kill_cci_task(void)
+{
+	if (cci_task) {
+		kthread_stop(cci_task);
+		cci_task = NULL;
+		dprintk("[%s]kill cci kthread !\n", __func__);
+	}
+}
+
+u32 dvbc_set_qam_mode(unsigned char mode)
+{
+	dprintk("auto change mode ,now mode is %d\n", mode);
+	apb_write_reg(QAM_BASE + 0x008, (mode & 7));
+	/* qam mode */
+	switch (mode) {
+	case 0:		/* 16 QAM */
+		apb_write_reg(QAM_BASE + 0x054, 0x23460224);
+		/* EQ_FIR_CTL, */
+		apb_write_reg(QAM_BASE + 0x068, 0x00c000c0);
+		/* EQ_CRTH_SNR */
+		apb_write_reg(QAM_BASE + 0x074, 0x50001a0);
+		/* EQ_TH_LMS  40db      13db */
+		apb_write_reg(QAM_BASE + 0x07c, 0x003001e9);
+		/* EQ_NORM and EQ_TH_MMA */
+		/*apb_write_reg(QAM_BASE+0x080, 0x000be1ff);
+		 * // EQ_TH_SMMA0
+		 */
+		apb_write_reg(QAM_BASE + 0x080, 0x000e01fe);
+		/* EQ_TH_SMMA0 */
+		apb_write_reg(QAM_BASE + 0x084, 0x00000000);
+		/* EQ_TH_SMMA1 */
+		apb_write_reg(QAM_BASE + 0x088, 0x00000000);
+		/* EQ_TH_SMMA2 */
+		apb_write_reg(QAM_BASE + 0x08c, 0x00000000);
+		/* EQ_TH_SMMA3 */
+		/*apb_write_reg(QAM_BASE+0x094, 0x7f800d2b);
+		 * // AGC_CTRL  ALPS tuner
+		 */
+		/*apb_write_reg(QAM_BASE+0x094, 0x7f80292b);
+		 * // Pilips Tuner
+		 */
+		/*apb_write_reg(QAM_BASE+0x094, 0x7f80292d);
+		 * // Pilips Tuner
+		 */
+		apb_write_reg(QAM_BASE + 0x094, 0x7f80092d);
+		/* Pilips Tuner */
+		apb_write_reg(QAM_BASE + 0x0c0, 0x061f2f66);
+		/* by raymond 20121213 */
+		break;
+
+	case 1:		/* 32 QAM */
+		apb_write_reg(QAM_BASE + 0x054, 0x24560506);
+		/* EQ_FIR_CTL, */
+		apb_write_reg(QAM_BASE + 0x068, 0x00c000c0);
+		/* EQ_CRTH_SNR */
+		/*apb_write_reg(QAM_BASE+0x074, 0x5000260);
+		 * // EQ_TH_LMS      40db  19db
+		 */
+		apb_write_reg(QAM_BASE + 0x074, 0x50001f0);
+		/* EQ_TH_LMS  40db      17.5db */
+		apb_write_reg(QAM_BASE + 0x07c, 0x00500102);
+		/* EQ_TH_MMA  0x000001cc */
+		apb_write_reg(QAM_BASE + 0x080, 0x00077140);
+		/* EQ_TH_SMMA0 */
+		apb_write_reg(QAM_BASE + 0x084, 0x001fb000);
+		/* EQ_TH_SMMA1 */
+		apb_write_reg(QAM_BASE + 0x088, 0x00000000);
+		/* EQ_TH_SMMA2 */
+		apb_write_reg(QAM_BASE + 0x08c, 0x00000000);
+		/* EQ_TH_SMMA3 */
+		/*apb_write_reg(QAM_BASE+0x094, 0x7f800d2b);
+		 * // AGC_CTRL  ALPS tuner
+		 */
+		/*apb_write_reg(QAM_BASE+0x094, 0x7f80292b);
+		 * // Pilips Tuner
+		 */
+		apb_write_reg(QAM_BASE + 0x094, 0x7f80092b);
+		/* Pilips Tuner */
+		apb_write_reg(QAM_BASE + 0x0c0, 0x061f2f66);
+		/* by raymond 20121213 */
+		break;
+
+	case 2:		/* 64 QAM */
+		/*apb_write_reg(QAM_BASE+0x054, 0x2256033a);
+		 * // EQ_FIR_CTL,
+		 */
+		apb_write_reg(QAM_BASE + 0x054, 0x2336043a);
+		/* EQ_FIR_CTL, by raymond */
+		apb_write_reg(QAM_BASE + 0x068, 0x00c000c0);
+		/* EQ_CRTH_SNR */
+		/*apb_write_reg(QAM_BASE+0x074, 0x5000260);
+		 * // EQ_TH_LMS  40db  19db
+		 */
+		apb_write_reg(QAM_BASE + 0x074, 0x5000230);
+		/* EQ_TH_LMS  40db      17.5db */
+		apb_write_reg(QAM_BASE + 0x07c, 0x007001bd);
+		/* EQ_TH_MMA */
+		apb_write_reg(QAM_BASE + 0x080, 0x000580ed);
+		/* EQ_TH_SMMA0 */
+		apb_write_reg(QAM_BASE + 0x084, 0x001771fb);
+		/* EQ_TH_SMMA1 */
+		apb_write_reg(QAM_BASE + 0x088, 0x00000000);
+		/* EQ_TH_SMMA2 */
+		apb_write_reg(QAM_BASE + 0x08c, 0x00000000);
+		/* EQ_TH_SMMA3 */
+		/*apb_write_reg(QAM_BASE+0x094, 0x7f800d2c);
+		 * // AGC_CTRL  ALPS tuner
+		 */
+		/*apb_write_reg(QAM_BASE+0x094, 0x7f80292c);
+		 * // Pilips & maxlinear Tuner
+		 */
+		apb_write_reg(QAM_BASE + 0x094, 0x7f802b3d);
+		/* Pilips Tuner & maxlinear Tuner */
+		/*apb_write_reg(QAM_BASE+0x094, 0x7f802b3a);
+		 * // Pilips Tuner & maxlinear Tuner
+		 */
+		apb_write_reg(QAM_BASE + 0x0c0, 0x061f2f66);
+		/* by raymond 20121213 */
+		break;
+
+	case 3:		/* 128 QAM */
+		/*apb_write_reg(QAM_BASE+0x054, 0x2557046a);
+		 * // EQ_FIR_CTL,
+		 */
+		apb_write_reg(QAM_BASE + 0x054, 0x2437067a);
+		/* EQ_FIR_CTL, by raymond 20121213 */
+		apb_write_reg(QAM_BASE + 0x068, 0x00c000d0);
+		/* EQ_CRTH_SNR */
+		/* apb_write_reg(QAM_BASE+0x074, 0x02440240);
+		 * // EQ_TH_LMS  18.5db  18db
+		 */
+		/* apb_write_reg(QAM_BASE+0x074, 0x04000400);
+		 * // EQ_TH_LMS  22db  22.5db
+		 */
+		apb_write_reg(QAM_BASE + 0x074, 0x5000260);
+		/* EQ_TH_LMS  40db      19db */
+		/*apb_write_reg(QAM_BASE+0x07c, 0x00b000f2);
+		 * // EQ_TH_MMA0x000000b2
+		 */
+		apb_write_reg(QAM_BASE + 0x07c, 0x00b00132);
+		/* EQ_TH_MMA0x000000b2 by raymond 20121213 */
+		apb_write_reg(QAM_BASE + 0x080, 0x0003a09d);
+		/* EQ_TH_SMMA0 */
+		apb_write_reg(QAM_BASE + 0x084, 0x000f8150);
+		/* EQ_TH_SMMA1 */
+		apb_write_reg(QAM_BASE + 0x088, 0x001a51f8);
+		/* EQ_TH_SMMA2 */
+		apb_write_reg(QAM_BASE + 0x08c, 0x00000000);
+		/* EQ_TH_SMMA3 */
+		/*apb_write_reg(QAM_BASE+0x094, 0x7f800d2c);
+		 * // AGC_CTRL  ALPS tuner
+		 */
+		/*apb_write_reg(QAM_BASE+0x094, 0x7f80292c);
+		 * // Pilips Tuner
+		 */
+		apb_write_reg(QAM_BASE + 0x094, 0x7f80092c);
+		/* Pilips Tuner */
+		apb_write_reg(QAM_BASE + 0x0c0, 0x061f2f66);
+		/* by raymond 20121213 */
+		break;
+
+	case 4:		/* 256 QAM */
+		/*apb_write_reg(QAM_BASE+0x054, 0xa2580588);
+		 * // EQ_FIR_CTL,
+		 */
+		apb_write_reg(QAM_BASE + 0x054, 0xa25905f9);
+		/* EQ_FIR_CTL, by raymond 20121213 */
+		apb_write_reg(QAM_BASE + 0x068, 0x01e00220);
+		/* EQ_CRTH_SNR */
+		/*apb_write_reg(QAM_BASE+0x074,  0x50002a0);
+		 * // EQ_TH_LMS      40db  19db
+		 */
+		apb_write_reg(QAM_BASE + 0x074, 0x5000270);
+		/* EQ_TH_LMS  40db      19db by raymond 201211213 */
+		apb_write_reg(QAM_BASE + 0x07c, 0x00f001a5);
+		/* EQ_TH_MMA */
+		apb_write_reg(QAM_BASE + 0x080, 0x0002c077);
+		/* EQ_TH_SMMA0 */
+		apb_write_reg(QAM_BASE + 0x084, 0x000bc0fe);
+		/* EQ_TH_SMMA1 */
+		apb_write_reg(QAM_BASE + 0x088, 0x0013f17e);
+		/* EQ_TH_SMMA2 */
+		apb_write_reg(QAM_BASE + 0x08c, 0x01bc01f9);
+		/* EQ_TH_SMMA3 */
+		/*apb_write_reg(QAM_BASE+0x094, 0x7f800d2c);
+		 * // AGC_CTRL  ALPS tuner
+		 */
+		/*apb_write_reg(QAM_BASE+0x094, 0x7f80292c);
+		 * // Pilips Tuner
+		 */
+		/*apb_write_reg(QAM_BASE+0x094, 0x7f80292d);
+		 * // Maxlinear Tuner
+		 */
+		apb_write_reg(QAM_BASE + 0x094, 0x7f80092d);
+		/* Maxlinear Tuner */
+		apb_write_reg(QAM_BASE + 0x0c0, 0x061f2f67);
+		/* by raymond 20121213, when adc=35M,sys=70M,
+		 * its better than 0x61f2f66
+		 */
+		break;
+	default:		/*64qam */
+		/*apb_write_reg(QAM_BASE+0x054, 0x2256033a);
+		 * // EQ_FIR_CTL,
+		 */
+		apb_write_reg(QAM_BASE + 0x054, 0x2336043a);
+		/* EQ_FIR_CTL, by raymond */
+		apb_write_reg(QAM_BASE + 0x068, 0x00c000c0);
+		/* EQ_CRTH_SNR */
+		/*apb_write_reg(QAM_BASE+0x074, 0x5000260);
+		 * // EQ_TH_LMS  40db  19db
+		 */
+		apb_write_reg(QAM_BASE + 0x074, 0x5000230);
+		/* EQ_TH_LMS  40db      17.5db */
+		apb_write_reg(QAM_BASE + 0x07c, 0x007001bd);
+		/* EQ_TH_MMA */
+		apb_write_reg(QAM_BASE + 0x080, 0x000580ed);
+		/* EQ_TH_SMMA0 */
+		apb_write_reg(QAM_BASE + 0x084, 0x001771fb);
+		/* EQ_TH_SMMA1 */
+		apb_write_reg(QAM_BASE + 0x088, 0x00000000);
+		/* EQ_TH_SMMA2 */
+		apb_write_reg(QAM_BASE + 0x08c, 0x00000000);
+		/* EQ_TH_SMMA3 */
+		/*apb_write_reg(QAM_BASE+0x094, 0x7f800d2c);
+		 * // AGC_CTRL  ALPS tuner
+		 */
+		/*apb_write_reg(QAM_BASE+0x094, 0x7f80292c);
+		 * // Pilips & maxlinear Tuner
+		 */
+		apb_write_reg(QAM_BASE + 0x094, 0x7f802b3d);
+		/* Pilips Tuner & maxlinear Tuner */
+		/*apb_write_reg(QAM_BASE+0x094, 0x7f802b3a);
+		 * // Pilips Tuner & maxlinear Tuner
+		 */
+		apb_write_reg(QAM_BASE + 0x0c0, 0x061f2f66);
+		/* by raymond 20121213 */
+		break;
+	}
+	return 0;
+}
+
+u32 dvbc_get_status(void)
+{
+/* dprintk("c4 is %x\n",apb_read_reg(QAM_BASE+0xc4));*/
+	return apb_read_reg(QAM_BASE + 0xc4) & 0xf;
+}
+EXPORT_SYMBOL(dvbc_get_status);
+
+static u32 dvbc_get_ch_power(void)
+{
+	u32 tmp;
+	u32 ad_power;
+	u32 agc_gain;
+	u32 ch_power;
+
+	tmp = apb_read_reg(QAM_BASE + 0x09c);
+
+	ad_power = (tmp >> 22) & 0x1ff;
+	agc_gain = (tmp >> 0) & 0x7ff;
+
+	ad_power = ad_power >> 4;
+	/* ch_power = lookuptable(agc_gain) + ad_power; TODO */
+	ch_power = (ad_power & 0xffff) + ((agc_gain & 0xffff) << 16);
+
+	return ch_power;
+}
+
+static u32 dvbc_get_snr(void)
+{
+	u32 tmp, snr;
+
+	tmp = apb_read_reg(QAM_BASE + 0x14) & 0xfff;
+	snr = tmp * 100 / 32;	/* * 1e2 */
+
+	return snr;
+}
+
+static u32 dvbc_get_ber(void)
+{
+	u32 rs_ber;
+	u32 rs_packet_len;
+
+	rs_packet_len = apb_read_reg(QAM_BASE + 0x10) & 0xffff;
+	rs_ber = apb_read_reg(QAM_BASE + 0x14) >> 12 & 0xfffff;
+
+	/* rs_ber = rs_ber / 204.0 / 8.0 / rs_packet_len; */
+	if (rs_packet_len == 0)
+		rs_ber = 1000000;
+	else
+		rs_ber = rs_ber * 613 / rs_packet_len;	/* 1e-6 */
+
+	return rs_ber;
+}
+
+static u32 dvbc_get_per(void)
+{
+	u32 rs_per;
+	u32 rs_packet_len;
+	u32 acc_rs_per_times;
+
+	rs_packet_len = apb_read_reg(QAM_BASE + 0x10) & 0xffff;
+	rs_per = apb_read_reg(QAM_BASE + 0x18) >> 16 & 0xffff;
+
+	acc_rs_per_times = apb_read_reg(QAM_BASE + 0xcc) & 0xffff;
+	/*rs_per = rs_per / rs_packet_len; */
+
+	if (rs_packet_len == 0)
+		rs_per = 10000;
+	else
+		rs_per = 10000 * rs_per / rs_packet_len;	/* 1e-4 */
+
+	/*return rs_per; */
+	return acc_rs_per_times;
+}
+
+static u32 dvbc_get_symb_rate(void)
+{
+	u32 tmp;
+	u32 adc_freq;
+	u32 symb_rate;
+
+	adc_freq = apb_read_reg(QAM_BASE + 0x34) >> 16 & 0xffff;
+	tmp = apb_read_reg(QAM_BASE + 0xb8);
+
+	if ((tmp >> 15) == 0)
+		symb_rate = 0;
+	else
+		symb_rate = 10 * (adc_freq << 12) / (tmp >> 15);
+	/* 1e4 */
+
+	return symb_rate;
+}
+
+static int dvbc_get_freq_off(void)
+{
+	int tmp;
+	int symb_rate;
+	int freq_off;
+
+	symb_rate = dvbc_get_symb_rate();
+	tmp = apb_read_reg(QAM_BASE + 0xe0) & 0x3fffffff;
+	if (tmp >> 29 & 1)
+		tmp -= (1 << 30);
+
+	freq_off = ((tmp >> 16) * 25 * (symb_rate >> 10)) >> 3;
+
+	return freq_off;
+}
+
+static void dvbc_set_test_bus(u8 sel)
+{
+	u32 tmp;
+
+	tmp = apb_read_reg(QAM_BASE + 0x08);
+	tmp &= ~(0x1f << 4);
+	tmp |= ((sel & 0x1f) << 4) | (1 << 3);
+	apb_write_reg(QAM_BASE + 0x08, tmp);
+}
+
+void dvbc_get_test_out(u8 sel, u32 len, u32 *buf)
+{
+	int i, cnt;
+
+	dvbc_set_test_bus(sel);
+
+	for (i = 0, cnt = 0; i < len - 4 && cnt < 1000000; i++) {
+		buf[i] = apb_read_reg(QAM_BASE + 0xb0);
+		if (buf[i] >> 11 & 1) {
+			buf[i++] = apb_read_reg(QAM_BASE + 0xb0);
+			buf[i++] = apb_read_reg(QAM_BASE + 0xb0);
+			buf[i++] = apb_read_reg(QAM_BASE + 0xb0);
+			buf[i++] = apb_read_reg(QAM_BASE + 0xb0);
+		} else {
+			i--;
+		}
+
+		cnt++;
+	}
+}
+
+#if 0
+static void dvbc_sw_reset(int addr, int idx)
+{
+	u32 tmp;
+
+	tmp = apb_read_reg(QAM_BASE + addr);
+
+	tmp &= ~(1 << idx);
+	apb_write_reg(QAM_BASE + addr, tmp);
+
+	udelay(1);
+
+	tmp |= (1 << idx);
+	apb_write_reg(QAM_BASE + addr, tmp);
+}
+
+static void dvbc_reset(void)
+{
+	dvbc_sw_reset(0x04, 0);
+}
+
+static void dvbc_eq_reset(void)
+{
+	dvbc_sw_reset(0x50, 3);
+}
+
+static void dvbc_eq_smma_reset(void)
+{
+	dvbc_sw_reset(0xe8, 0);
+}
+#endif
+static void dvbc_reg_initial(struct aml_demod_sta *demod_sta)
+{
+	u32 clk_freq;
+	u32 adc_freq;
+	u8 tuner;
+	u8 ch_mode;
+	u8 agc_mode;
+	u32 ch_freq;
+	u16 ch_if;
+	u16 ch_bw;
+	u16 symb_rate;
+	u32 phs_cfg;
+	int afifo_ctr;
+	int max_frq_off, tmp;
+
+	clk_freq = demod_sta->clk_freq;	/* kHz */
+	adc_freq = demod_sta->adc_freq;	/* kHz */
+/*    adc_freq  = 25414;*/
+	tuner = demod_sta->tuner;
+	ch_mode = demod_sta->ch_mode;
+	agc_mode = demod_sta->agc_mode;
+	ch_freq = demod_sta->ch_freq;	/* kHz */
+	ch_if = demod_sta->ch_if;	/* kHz */
+	ch_bw = demod_sta->ch_bw;	/* kHz */
+	symb_rate = demod_sta->symb_rate;	/* k/sec */
+	dprintk("ch_if is %d,  %d,  %d,  %d, %d\n",
+		ch_if, ch_mode, ch_freq, ch_bw, symb_rate);
+/*    ch_mode=4;*/
+/*      apb_write_reg(DEMOD_CFG_BASE,0x00000007);*/
+	/* disable irq */
+	apb_write_reg(QAM_BASE + 0xd0, 0);
+
+	/* reset */
+	/*dvbc_reset(); */
+	apb_write_reg(QAM_BASE + 0x4, apb_read_reg(QAM_BASE + 0x4) & ~(1 << 4));
+	/* disable fsm_en */
+	apb_write_reg(QAM_BASE + 0x4, apb_read_reg(QAM_BASE + 0x4) & ~(1 << 0));
+	/* Sw disable demod */
+	apb_write_reg(QAM_BASE + 0x4, apb_read_reg(QAM_BASE + 0x4) | (1 << 0));
+	/* Sw enable demod */
+
+	apb_write_reg(QAM_BASE + 0x000, 0x00000000);
+	/* QAM_STATUS */
+	apb_write_reg(QAM_BASE + 0x004, 0x00000f00);
+	/* QAM_GCTL0 */
+	apb_write_reg(QAM_BASE + 0x008, (ch_mode & 7));
+	/* qam mode */
+
+	switch (ch_mode) {
+	case 0:		/* 16 QAM */
+		apb_write_reg(QAM_BASE + 0x054, 0x23460224);
+		/* EQ_FIR_CTL, */
+		apb_write_reg(QAM_BASE + 0x068, 0x00c000c0);
+		/* EQ_CRTH_SNR */
+		apb_write_reg(QAM_BASE + 0x074, 0x50001a0);
+		/* EQ_TH_LMS  40db  13db */
+		apb_write_reg(QAM_BASE + 0x07c, 0x003001e9);
+		/* EQ_NORM and EQ_TH_MMA */
+		/*apb_write_reg(QAM_BASE+0x080, 0x000be1ff);
+		 * // EQ_TH_SMMA0
+		 */
+		apb_write_reg(QAM_BASE + 0x080, 0x000e01fe);
+		/* EQ_TH_SMMA0 */
+		apb_write_reg(QAM_BASE + 0x084, 0x00000000);
+		/* EQ_TH_SMMA1 */
+		apb_write_reg(QAM_BASE + 0x088, 0x00000000);
+		/* EQ_TH_SMMA2 */
+		apb_write_reg(QAM_BASE + 0x08c, 0x00000000);
+		/* EQ_TH_SMMA3 */
+		/*apb_write_reg(QAM_BASE+0x094, 0x7f800d2b);
+		 * // AGC_CTRL  ALPS tuner
+		 */
+		/*apb_write_reg(QAM_BASE+0x094, 0x7f80292b);
+		 * // Pilips Tuner
+		 */
+		/*apb_write_reg(QAM_BASE+0x094, 0x7f80292d);
+		 * // Pilips Tuner
+		 */
+		apb_write_reg(QAM_BASE + 0x094, 0x7f80092d);
+		/* Pilips Tuner */
+		apb_write_reg(QAM_BASE + 0x0c0, 0x061f2f67);
+		/* by raymond 20121213 */
+		break;
+
+	case 1:		/* 32 QAM */
+		apb_write_reg(QAM_BASE + 0x054, 0x24560506);
+		/* EQ_FIR_CTL, */
+		apb_write_reg(QAM_BASE + 0x068, 0x00c000c0);
+		/* EQ_CRTH_SNR */
+		/*apb_write_reg(QAM_BASE+0x074, 0x5000260);
+		 * // EQ_TH_LMS  40db  19db
+		 */
+		apb_write_reg(QAM_BASE + 0x074, 0x50001f0);
+		/* EQ_TH_LMS  40db  17.5db */
+		apb_write_reg(QAM_BASE + 0x07c, 0x00500102);
+		/* EQ_TH_MMA  0x000001cc */
+		apb_write_reg(QAM_BASE + 0x080, 0x00077140);
+		/* EQ_TH_SMMA0 */
+		apb_write_reg(QAM_BASE + 0x084, 0x001fb000);
+		/* EQ_TH_SMMA1 */
+		apb_write_reg(QAM_BASE + 0x088, 0x00000000);
+		/* EQ_TH_SMMA2 */
+		apb_write_reg(QAM_BASE + 0x08c, 0x00000000);
+		/* EQ_TH_SMMA3 */
+		/*apb_write_reg(QAM_BASE+0x094, 0x7f800d2b);
+		 * // AGC_CTRL  ALPS tuner
+		 */
+		/*apb_write_reg(QAM_BASE+0x094, 0x7f80292b);
+		 * // Pilips Tuner
+		 */
+		apb_write_reg(QAM_BASE + 0x094, 0x7f80092b);
+		/* Pilips Tuner */
+		apb_write_reg(QAM_BASE + 0x0c0, 0x061f2f67);
+		/* by raymond 20121213 */
+		break;
+
+	case 2:		/* 64 QAM */
+		/*apb_write_reg(QAM_BASE+0x054, 0x2256033a);
+		 * // EQ_FIR_CTL,
+		 */
+		apb_write_reg(QAM_BASE + 0x054, 0x2336043a);
+		/* EQ_FIR_CTL, by raymond */
+		apb_write_reg(QAM_BASE + 0x068, 0x00c000c0);
+		/* EQ_CRTH_SNR */
+		/*apb_write_reg(QAM_BASE+0x074, 0x5000260);
+		 * // EQ_TH_LMS  40db  19db
+		 */
+		apb_write_reg(QAM_BASE + 0x074, 0x5000230);
+		/* EQ_TH_LMS  40db  17.5db */
+		apb_write_reg(QAM_BASE + 0x07c, 0x007001bd);
+		/* EQ_TH_MMA */
+		apb_write_reg(QAM_BASE + 0x080, 0x000580ed);
+		/* EQ_TH_SMMA0 */
+		apb_write_reg(QAM_BASE + 0x084, 0x001771fb);
+		/* EQ_TH_SMMA1 */
+		apb_write_reg(QAM_BASE + 0x088, 0x00000000);
+		/* EQ_TH_SMMA2 */
+		apb_write_reg(QAM_BASE + 0x08c, 0x00000000);
+		/* EQ_TH_SMMA3 */
+		/*apb_write_reg(QAM_BASE+0x094, 0x7f800d2c);
+		 * // AGC_CTRL  ALPS tuner
+		 */
+		/*apb_write_reg(QAM_BASE+0x094, 0x7f80292c);
+		 * // Pilips & maxlinear Tuner
+		 */
+		apb_write_reg(QAM_BASE + 0x094, 0x7f802b3d);
+		/* Pilips Tuner & maxlinear Tuner */
+		/*apb_write_reg(QAM_BASE+0x094, 0x7f802b3a);
+		 * // Pilips Tuner & maxlinear Tuner
+		 */
+		apb_write_reg(QAM_BASE + 0x0c0, 0x061f2f67);
+		/* by raymond 20121213 */
+		break;
+
+	case 3:		/* 128 QAM */
+		/*apb_write_reg(QAM_BASE+0x054, 0x2557046a);
+		 * // EQ_FIR_CTL,
+		 */
+		apb_write_reg(QAM_BASE + 0x054, 0x2437067a);
+		/* EQ_FIR_CTL, by raymond 20121213 */
+		apb_write_reg(QAM_BASE + 0x068, 0x00c000d0);
+		/* EQ_CRTH_SNR */
+		/* apb_write_reg(QAM_BASE+0x074, 0x02440240);
+		 * // EQ_TH_LMS  18.5db  18db
+		 */
+		/* apb_write_reg(QAM_BASE+0x074, 0x04000400);
+		 * // EQ_TH_LMS  22db  22.5db
+		 */
+		apb_write_reg(QAM_BASE + 0x074, 0x5000260);
+		/* EQ_TH_LMS  40db  19db */
+		/*apb_write_reg(QAM_BASE+0x07c, 0x00b000f2);
+		 * // EQ_TH_MMA0x000000b2
+		 */
+		apb_write_reg(QAM_BASE + 0x07c, 0x00b00132);
+		/* EQ_TH_MMA0x000000b2 by raymond 20121213 */
+		apb_write_reg(QAM_BASE + 0x080, 0x0003a09d);
+		/* EQ_TH_SMMA0 */
+		apb_write_reg(QAM_BASE + 0x084, 0x000f8150);
+		/* EQ_TH_SMMA1 */
+		apb_write_reg(QAM_BASE + 0x088, 0x001a51f8);
+		/* EQ_TH_SMMA2 */
+		apb_write_reg(QAM_BASE + 0x08c, 0x00000000);
+		/* EQ_TH_SMMA3 */
+		/*apb_write_reg(QAM_BASE+0x094, 0x7f800d2c);
+		 * // AGC_CTRL  ALPS tuner
+		 */
+		/*apb_write_reg(QAM_BASE+0x094, 0x7f80292c);
+		 * // Pilips Tuner
+		 */
+		apb_write_reg(QAM_BASE + 0x094, 0x7f80092c);
+		/* Pilips Tuner */
+		apb_write_reg(QAM_BASE + 0x0c0, 0x061f2f67);
+		/* by raymond 20121213 */
+		break;
+
+	case 4:		/* 256 QAM */
+		/*apb_write_reg(QAM_BASE+0x054, 0xa2580588);
+		 * // EQ_FIR_CTL,
+		 */
+		apb_write_reg(QAM_BASE + 0x054, 0xa25905f9);
+		/* EQ_FIR_CTL, by raymond 20121213 */
+		apb_write_reg(QAM_BASE + 0x068, 0x01e00220);
+		/* EQ_CRTH_SNR */
+		/*apb_write_reg(QAM_BASE+0x074,  0x50002a0);
+		 * // EQ_TH_LMS  40db  19db
+		 */
+		apb_write_reg(QAM_BASE + 0x074, 0x5000270);
+		/* EQ_TH_LMS  40db  19db by raymond 201211213 */
+		apb_write_reg(QAM_BASE + 0x07c, 0x00f001a5);
+		/* EQ_TH_MMA */
+		apb_write_reg(QAM_BASE + 0x080, 0x0002c077);
+		/* EQ_TH_SMMA0 */
+		apb_write_reg(QAM_BASE + 0x084, 0x000bc0fe);
+		/* EQ_TH_SMMA1 */
+		apb_write_reg(QAM_BASE + 0x088, 0x0013f17e);
+		/* EQ_TH_SMMA2 */
+		apb_write_reg(QAM_BASE + 0x08c, 0x01bc01f9);
+		/* EQ_TH_SMMA3 */
+		/*apb_write_reg(QAM_BASE+0x094, 0x7f800d2c);
+		 * // AGC_CTRL  ALPS tuner
+		 */
+		/*apb_write_reg(QAM_BASE+0x094, 0x7f80292c);
+		 * // Pilips Tuner
+		 */
+		/*apb_write_reg(QAM_BASE+0x094, 0x7f80292d);
+		 * // Maxlinear Tuner
+		 */
+		apb_write_reg(QAM_BASE + 0x094, 0x7f80092d);
+		/* Maxlinear Tuner */
+		apb_write_reg(QAM_BASE + 0x0c0, 0x061f2f67);
+		/* by raymond 20121213, when adc=35M,sys=70M,
+		 * its better than 0x61f2f66
+		 */
+		break;
+	default:		/*64qam */
+		/*apb_write_reg(QAM_BASE+0x054, 0x2256033a);
+		 * // EQ_FIR_CTL,
+		 */
+		apb_write_reg(QAM_BASE + 0x054, 0x2336043a);
+		/* EQ_FIR_CTL, by raymond */
+		apb_write_reg(QAM_BASE + 0x068, 0x00c000c0);
+		/* EQ_CRTH_SNR */
+		/* EQ_TH_LMS  40db  19db */
+		apb_write_reg(QAM_BASE + 0x074, 0x5000230);
+		/* EQ_TH_LMS  40db  17.5db */
+		apb_write_reg(QAM_BASE + 0x07c, 0x007001bd);
+		/* EQ_TH_MMA */
+		apb_write_reg(QAM_BASE + 0x080, 0x000580ed);
+		/* EQ_TH_SMMA0 */
+		apb_write_reg(QAM_BASE + 0x084, 0x001771fb);
+		/* EQ_TH_SMMA1 */
+		apb_write_reg(QAM_BASE + 0x088, 0x00000000);
+		/* EQ_TH_SMMA2 */
+		apb_write_reg(QAM_BASE + 0x08c, 0x00000000);
+		/* EQ_TH_SMMA3 */
+		/*apb_write_reg(QAM_BASE+0x094, 0x7f800d2c);
+		 * // AGC_CTRL  ALPS tuner
+		 */
+		/*apb_write_reg(QAM_BASE+0x094, 0x7f80292c);
+		 * // Pilips & maxlinear Tuner
+		 */
+		apb_write_reg(QAM_BASE + 0x094, 0x7f802b3d);
+		/* Pilips Tuner & maxlinear Tuner */
+		/*apb_write_reg(QAM_BASE+0x094, 0x7f802b3a);
+		 * // Pilips Tuner & maxlinear Tuner
+		 */
+		apb_write_reg(QAM_BASE + 0x0c0, 0x061f2f67);
+		/* by raymond 20121213 */
+		break;
+	}
+
+	/*apb_write_reg(QAM_BASE+0x00c, 0xfffffffe);
+	 * // adc_cnt, symb_cnt
+	 */
+	apb_write_reg(QAM_BASE + 0x00c, 0xffff8ffe);
+	/* adc_cnt, symb_cnt    by raymond 20121213 */
+	if (clk_freq == 0)
+		afifo_ctr = 0;
+	else
+		afifo_ctr = (adc_freq * 256 / clk_freq) + 2;
+	if (afifo_ctr > 255)
+		afifo_ctr = 255;
+	apb_write_reg(QAM_BASE + 0x010, (afifo_ctr << 16) | 8000);
+	/* afifo, rs_cnt_cfg */
+
+	/*apb_write_reg(QAM_BASE+0x020, 0x21353e54);
+	 * // PHS_reset & TIM_CTRO_ACCURATE  sw_tim_select=0
+	 */
+	/*apb_write_reg(QAM_BASE+0x020, 0x21b53e54);
+	 * //modified by qiancheng
+	 */
+	apb_write_reg(QAM_BASE + 0x020, 0x61b53e54);
+	/*modified by qiancheng by raymond 20121208  0x63b53e54 for cci */
+	/*  apb_write_reg(QAM_BASE+0x020, 0x6192bfe2);
+	 * //modifed by ligg 20130613 auto symb_rate scan
+	 */
+	if (adc_freq == 0)
+		phs_cfg = 0;
+	else
+		phs_cfg = (1 << 31) / adc_freq * ch_if / (1 << 8);
+	/*  8*fo/fs*2^20 fo=36.125, fs = 28.57114, = 21d775 */
+	/* dprintk("phs_cfg = %x\n", phs_cfg); */
+	apb_write_reg(QAM_BASE + 0x024, 0x4c000000 | (phs_cfg & 0x7fffff));
+	/* PHS_OFFSET, IF offset, */
+
+	if (adc_freq == 0) {
+		max_frq_off = 0;
+	} else {
+		max_frq_off = (1 << 29) / symb_rate;
+		/* max_frq_off = (400KHz * 2^29) /
+		 *   (AD=28571 * symbol_rate=6875)
+		 */
+		tmp = 40000000 / adc_freq;
+		max_frq_off = tmp * max_frq_off;
+	}
+	dprintk("max_frq_off is %x,\n", max_frq_off);
+	apb_write_reg(QAM_BASE + 0x02c, max_frq_off & 0x3fffffff);
+	/* max frequency offset, by raymond 20121208 */
+
+	/*apb_write_reg(QAM_BASE+0x030, 0x011bf400);
+	 * // TIM_CTL0 start speed is 0,  when know symbol rate
+	 */
+	apb_write_reg(QAM_BASE + 0x030, 0x245cf451);
+	/*MODIFIED BY QIANCHENG */
+/*      apb_write_reg(QAM_BASE+0x030, 0x245bf451);
+ * //modified by ligg 20130613 --auto symb_rate scan
+ */
+	apb_write_reg(QAM_BASE + 0x034,
+		      ((adc_freq & 0xffff) << 16) | (symb_rate & 0xffff));
+
+	apb_write_reg(QAM_BASE + 0x038, 0x00400000);
+	/* TIM_SWEEP_RANGE 16000 */
+
+/************* hw state machine config **********/
+	apb_write_reg(QAM_BASE + 0x040, 0x003c);
+/* configure symbol rate step step 0*/
+
+	/* modified 0x44 0x48 */
+	apb_write_reg(QAM_BASE + 0x044, (symb_rate & 0xffff) * 256);
+	/* blind search, configure max symbol_rate      for 7218  fb=3.6M */
+	/*apb_write_reg(QAM_BASE+0x048, 3600*256);
+	 * // configure min symbol_rate fb = 6.95M
+	 */
+	apb_write_reg(QAM_BASE + 0x048, 3400 * 256);
+	/* configure min symbol_rate fb = 6.95M */
+
+	/*apb_write_reg(QAM_BASE+0x0c0, 0xffffff68); // threshold */
+	/*apb_write_reg(QAM_BASE+0x0c0, 0xffffff6f); // threshold */
+	/*apb_write_reg(QAM_BASE+0x0c0, 0xfffffd68); // threshold */
+	/*apb_write_reg(QAM_BASE+0x0c0, 0xffffff68); // threshold */
+	/*apb_write_reg(QAM_BASE+0x0c0, 0xffffff68); // threshold */
+	/*apb_write_reg(QAM_BASE+0x0c0, 0xffff2f67);
+	 * // threshold for skyworth
+	 */
+	/* apb_write_reg(QAM_BASE+0x0c0, 0x061f2f67); // by raymond 20121208 */
+	/* apb_write_reg(QAM_BASE+0x0c0, 0x061f2f66);
+	 * // by raymond 20121213, remove it to every constellation
+	 */
+/************* hw state machine config **********/
+
+	apb_write_reg(QAM_BASE + 0x04c, 0x00008800);	/* reserved */
+
+	/*apb_write_reg(QAM_BASE+0x050, 0x00000002);  // EQ_CTL0 */
+	apb_write_reg(QAM_BASE + 0x050, 0x01472002);
+	/* EQ_CTL0 by raymond 20121208 */
+
+	/*apb_write_reg(QAM_BASE+0x058, 0xff550e1e);  // EQ_FIR_INITPOS */
+	apb_write_reg(QAM_BASE + 0x058, 0xff100e1e);
+	/* EQ_FIR_INITPOS for skyworth */
+
+	apb_write_reg(QAM_BASE + 0x05c, 0x019a0000);	/* EQ_FIR_INITVAL0 */
+	apb_write_reg(QAM_BASE + 0x060, 0x019a0000);	/* EQ_FIR_INITVAL1 */
+
+	/*apb_write_reg(QAM_BASE+0x064, 0x01101128);  // EQ_CRTH_TIMES */
+	apb_write_reg(QAM_BASE + 0x064, 0x010a1128);
+	/* EQ_CRTH_TIMES for skyworth */
+	apb_write_reg(QAM_BASE + 0x06c, 0x00041a05);	/* EQ_CRTH_PPM */
+
+	apb_write_reg(QAM_BASE + 0x070, 0xffb9aa01);	/* EQ_CRLP */
+
+	/*apb_write_reg(QAM_BASE+0x090, 0x00020bd5); // agc control */
+	apb_write_reg(QAM_BASE + 0x090, 0x00000bd5);	/* agc control */
+
+	/* agc control */
+	/* apb_write_reg(QAM_BASE+0x094, 0x7f800d2c);// AGC_CTRL  ALPS tuner */
+	/* apb_write_reg(QAM_BASE+0x094, 0x7f80292c);     // Pilips Tuner */
+	if ((agc_mode & 1) == 0)
+		/* freeze if agc */
+		apb_write_reg(QAM_BASE + 0x094,
+			      apb_read_reg(QAM_BASE + 0x94) | (0x1 << 10));
+	if ((agc_mode & 2) == 0) {
+		/* IF control */
+		/*freeze rf agc */
+		apb_write_reg(QAM_BASE + 0x094,
+			      apb_read_reg(QAM_BASE + 0x94) | (0x1 << 13));
+	}
+	/*Maxlinear Tuner */
+	/*apb_write_reg(QAM_BASE+0x094, 0x7f80292d); */
+	apb_write_reg(QAM_BASE + 0x098, 0x9fcc8190);
+	/* AGC_IFGAIN_CTRL */
+	/*apb_write_reg(QAM_BASE+0x0a0, 0x0e028c00);
+	 * // AGC_RFGAIN_CTRL 0x0e020800
+	 */
+	/*apb_write_reg(QAM_BASE+0x0a0, 0x0e03cc00);
+	 * // AGC_RFGAIN_CTRL 0x0e020800
+	 */
+	/*apb_write_reg(QAM_BASE+0x0a0, 0x0e028700);
+	 * // AGC_RFGAIN_CTRL 0x0e020800 now
+	 */
+	/*apb_write_reg(QAM_BASE+0x0a0, 0x0e03cd00);
+	 * // AGC_RFGAIN_CTRL 0x0e020800
+	 */
+	/*apb_write_reg(QAM_BASE+0x0a0, 0x0603cd11);
+	 * // AGC_RFGAIN_CTRL 0x0e020800 by raymond,
+	 * if Adjcent channel test, maybe it need change.20121208 ad invert
+	 */
+	apb_write_reg(QAM_BASE + 0x0a0, 0x0603cd10);
+	/* AGC_RFGAIN_CTRL 0x0e020800 by raymond,
+	 * if Adjcent channel test, maybe it need change.
+	 * 20121208 ad invert,20130221, suit for two path channel.
+	 */
+
+	apb_write_reg(QAM_BASE + 0x004, apb_read_reg(QAM_BASE + 0x004) | 0x33);
+	/* IMQ, QAM Enable */
+
+	/* start hardware machine */
+	/*dvbc_sw_reset(0x004, 4); */
+	apb_write_reg(QAM_BASE + 0x4, apb_read_reg(QAM_BASE + 0x4) | (1 << 4));
+	apb_write_reg(QAM_BASE + 0x0e8,
+		      (apb_read_reg(QAM_BASE + 0x0e8) | (1 << 2)));
+
+	/* clear irq status */
+	apb_read_reg(QAM_BASE + 0xd4);
+
+	/* enable irq */
+	apb_write_reg(QAM_BASE + 0xd0, 0x7fff << 3);
+
+/*auto track*/
+	/*      dvbc_set_auto_symtrack(); */
+}
+
+u32 dvbc_set_auto_symtrack(void)
+{
+	apb_write_reg(QAM_BASE + 0x030, 0x245bf45c);	/*open track */
+	apb_write_reg(QAM_BASE + 0x020, 0x61b2bf5c);
+	apb_write_reg(QAM_BASE + 0x044, (7000 & 0xffff) * 256);
+	apb_write_reg(QAM_BASE + 0x038, 0x00220000);
+	apb_write_reg(QAM_BASE + 0x4, apb_read_reg(QAM_BASE + 0x4) & ~(1 << 0));
+	/* Sw disable demod */
+	apb_write_reg(QAM_BASE + 0x4, apb_read_reg(QAM_BASE + 0x4) | (1 << 0));
+	/* Sw enable demod */
+	return 0;
+}
+
+int dvbc_set_ch(struct aml_demod_sta *demod_sta,
+		struct aml_demod_i2c *demod_i2c,
+		struct aml_demod_dvbc *demod_dvbc)
+{
+	int ret = 0;
+	u16 symb_rate;
+	u8 mode;
+	u32 ch_freq;
+
+	dprintk("f=%d, s=%d, q=%d\n",
+		demod_dvbc->ch_freq, demod_dvbc->symb_rate, demod_dvbc->mode);
+	demod_i2c->tuner = 7;
+	mode = demod_dvbc->mode;
+	symb_rate = demod_dvbc->symb_rate;
+	ch_freq = demod_dvbc->ch_freq;
+	if (mode > 4) {
+		dprintk("Error: Invalid QAM mode option %d\n", mode);
+		mode = 2;
+		ret = -1;
+	}
+
+	if (symb_rate < 1000 || symb_rate > 7000) {
+		dprintk("Error: Invalid Symbol Rate option %d\n", symb_rate);
+		symb_rate = 6875;
+		ret = -1;
+	}
+
+	if (ch_freq < 1000 || ch_freq > 900000) {
+		dprintk("Error: Invalid Channel Freq option %d\n", ch_freq);
+		ch_freq = 474000;
+		ret = -1;
+	}
+	/* if (ret != 0) return ret; */
+	demod_sta->dvb_mode = 0;
+	demod_sta->ch_mode = mode;
+	/* 0:16, 1:32, 2:64, 3:128, 4:256 */
+	demod_sta->agc_mode = 1;
+	/* 0:NULL, 1:IF, 2:RF, 3:both */
+	demod_sta->ch_freq = ch_freq;
+	demod_sta->tuner = demod_i2c->tuner;
+
+	if (demod_i2c->tuner == 1)
+		demod_sta->ch_if = 36130;	/* TODO  DCT tuner */
+	else if (demod_i2c->tuner == 2)
+		demod_sta->ch_if = 4570;	/* TODO  Maxlinear tuner */
+	else if (demod_i2c->tuner == 7)
+		/*   demod_sta->ch_if     = 5000; // TODO  Si2176 tuner */
+
+	demod_sta->ch_bw = 8000;	/* TODO */
+	if (demod_sta->ch_if == 0)
+		demod_sta->ch_if = 5000;
+	demod_sta->symb_rate = symb_rate;
+	dvbc_reg_initial(demod_sta);
+
+	return ret;
+}
+
+int dvbc_status(struct aml_demod_sta *demod_sta,
+		struct aml_demod_i2c *demod_i2c,
+		struct aml_demod_sts *demod_sts)
+{
+	struct aml_fe_dev *dev;
+
+/* int ftmp, tmp; */
+	dev = NULL;
+	demod_sts->ch_sts = apb_read_reg(QAM_BASE + 0x18);
+	demod_sts->ch_pow = dvbc_get_ch_power();
+	demod_sts->ch_snr = dvbc_get_snr();
+	demod_sts->ch_ber = dvbc_get_ber();
+	demod_sts->ch_per = dvbc_get_per();
+	demod_sts->symb_rate = dvbc_get_symb_rate();
+	demod_sts->freq_off = dvbc_get_freq_off();
+	/*demod_sts->dat0 = apb_read_reg(QAM_BASE+0x28); */
+/*    demod_sts->dat0 = tuner_get_ch_power(demod_i2c);*/
+	demod_sts->dat1 = tuner_get_ch_power(dev);
+#if 0
+
+	ftmp = demod_sts->ch_sts;
+	dprintk("[dvbc debug] ch_sts is %x\n", ftmp);
+	ftmp = demod_sts->ch_snr;
+	ftmp /= 100;
+	dprintk("snr %d dB ", ftmp);
+	ftmp = demod_sts->ch_ber;
+	dprintk("ber %.d ", ftmp);
+	tmp = demod_sts->ch_per;
+	dprintk("per %d ", tmp);
+	ftmp = demod_sts->symb_rate;
+	dprintk("srate %.d ", ftmp);
+	ftmp = demod_sts->freq_off;
+	dprintk("freqoff %.d kHz ", ftmp);
+	tmp = demod_sts->dat1;
+	dprintk("strength %ddb  0xe0 status is %lu ,b4 status is %lu", tmp,
+		(apb_read_reg(QAM_BASE + 0xe0) & 0xffff),
+		(apb_read_reg(QAM_BASE + 0xb4) & 0xffff));
+	dprintk("dagc_gain is %lu ", apb_read_reg(QAM_BASE + 0xa4) & 0x7f);
+	tmp = demod_sts->ch_pow;
+	dprintk("power is %ddb\n", (tmp & 0xffff));
+
+#endif
+
+	return 0;
+}
+
+void dvbc_enable_irq(int dvbc_irq)
+{
+	u32 mask;
+
+	/* clear status */
+	apb_read_reg(QAM_BASE + 0xd4);
+	/* enable irq */
+	mask = apb_read_reg(QAM_BASE + 0xd0);
+	mask |= (1 << dvbc_irq);
+	apb_write_reg(QAM_BASE + 0xd0, mask);
+}
+
+void dvbc_disable_irq(int dvbc_irq)
+{
+	u32 mask;
+
+	/* disable irq */
+	mask = apb_read_reg(QAM_BASE + 0xd0);
+	mask &= ~(1 << dvbc_irq);
+	apb_write_reg(QAM_BASE + 0xd0, mask);
+	/* clear status */
+	apb_read_reg(QAM_BASE + 0xd4);
+}
+
+char *dvbc_irq_name[] = {
+	"      ADC",
+	"   Symbol",
+	"       RS",
+	" In_Sync0",
+	" In_Sync1",
+	" In_Sync2",
+	" In_Sync3",
+	" In_Sync4",
+	"Out_Sync0",
+	"Out_Sync1",
+	"Out_Sync2",
+	"Out_Sync3",
+	"Out_Sync4",
+	"In_SyncCo",
+	"OutSyncCo",
+	"  In_Dagc",
+	" Out_Dagc",
+	"  Eq_Mode",
+	"RS_Uncorr"
+};
+
+void dvbc_isr(struct aml_demod_sta *demod_sta)
+{
+	u32 stat, mask;
+	int dvbc_irq;
+
+	stat = apb_read_reg(QAM_BASE + 0xd4);
+	mask = apb_read_reg(QAM_BASE + 0xd0);
+	stat &= mask;
+
+	for (dvbc_irq = 0; dvbc_irq < 20; dvbc_irq++) {
+		if (stat >> dvbc_irq & 1) {
+			if (demod_sta->debug)
+				dprintk("irq: dvbc %2d %s %8x\n",
+					dvbc_irq, dvbc_irq_name[dvbc_irq],
+					stat);
+			/* dvbc_disable_irq(dvbc_irq); */
+		}
+	}
+}
+
+int dvbc_isr_islock(void)
+{
+#define IN_SYNC4_MASK (0x80)
+
+	u32 stat, mask;
+
+	stat = apb_read_reg(QAM_BASE + 0xd4);
+	apb_write_reg(QAM_BASE + 0xd4, 0);
+	mask = apb_read_reg(QAM_BASE + 0xd0);
+	stat &= mask;
+
+	return (stat & IN_SYNC4_MASK) == IN_SYNC4_MASK;
+}
diff --git a/drivers/stream_input/tv_frontend/dtv_demod/dvbt_func.c b/drivers/stream_input/tv_frontend/dtv_demod/dvbt_func.c
new file mode 100644
index 0000000..7654aae
--- /dev/null
+++ b/drivers/stream_input/tv_frontend/dtv_demod/dvbt_func.c
@@ -0,0 +1,2188 @@
+/*
+* Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT
+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+* more details.
+*
+* You should have received a copy of the GNU General Public License along
+* with this program; if not, write to the Free Software Foundation, Inc.,
+* 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+*
+* Description:
+*/
+#include <linux/kernel.h>
+#include <linux/i2c.h>
+#include <linux/delay.h>
+#include <linux/dvb/aml_demod.h>
+#include "demod_func.h"
+
+static int debug_amldvbt;
+
+module_param(debug_amldvbt, int, 0644);
+MODULE_PARM_DESC(debug_amldvbt, "turn on debugging (default: 0)");
+#define dprintk(args ...) do { if (debug_amldvbt) printk(args); } while (0)
+
+static int tuner_type = 3;
+
+static void set_ACF_coef(int ADsample, int bandwidth)
+{
+	if (ADsample == 45) {
+		/* Set ACF and IIREQ */
+		if (bandwidth == 0) {
+			/*8M Hz */
+			apb_write_reg(2, 0x2c, 0x255);  /* ACF_STAGE1_A1 */
+			apb_write_reg(2, 0x2d, 0x0B5);  /* ACF_STAGE1_A2 */
+			apb_write_reg(2, 0x2e, 0x091);  /* ACF_STAGE1_B1 */
+			apb_write_reg(2, 0x2f, 0x02E);  /* ACF_STAGE1_GAIN */
+			apb_write_reg(2, 0x30, 0x253);  /* ACF_STAGE2_A1 */
+			apb_write_reg(2, 0x31, 0x0CB);  /* ACF_STAGE2_A2 */
+			apb_write_reg(2, 0x32, 0x2CD);  /* ACF_STAGE2_B1 */
+			apb_write_reg(2, 0x33, 0x07C);  /* ACF_STAGE2_GAIN */
+			apb_write_reg(2, 0x34, 0x250);  /* ACF_STAGE3_A1 */
+			apb_write_reg(2, 0x35, 0x0E4);  /* ACF_STAGE3_A2 */
+			apb_write_reg(2, 0x36, 0x276);  /* ACF_STAGE3_B1 */
+			apb_write_reg(2, 0x37, 0x05D);  /* ACF_STAGE3_GAIN */
+			apb_write_reg(2, 0x38, 0x24D);  /* ACF_STAGE4_A1 */
+			apb_write_reg(2, 0x39, 0x0F3);  /* ACF_STAGE4_A2 */
+			apb_write_reg(2, 0x3a, 0x25E);  /* ACF_STAGE4_B1 */
+			apb_write_reg(2, 0x3b, 0x05A);  /* ACF_STAGE4_GAIN */
+			apb_write_reg(2, 0x3c, 0x24A);  /* ACF_STAGE5_A1 */
+			apb_write_reg(2, 0x3d, 0x0FD);  /* ACF_STAGE5_A2 */
+			apb_write_reg(2, 0x3e, 0x256);  /* ACF_STAGE5_B1 */
+			apb_write_reg(2, 0x3f, 0x04B);  /* ACF_STAGE5_GAIN */
+
+			apb_write_reg(2, 0xfe, 0x000);
+			apb_write_reg(2, 0xff, 0x003effff);
+			apb_write_reg(2, 0xfe, 0x001);
+			apb_write_reg(2, 0xff, 0x003cefbe);
+			apb_write_reg(2, 0xfe, 0x002);
+			apb_write_reg(2, 0xff, 0x003adf7c);
+			apb_write_reg(2, 0xfe, 0x003);
+			apb_write_reg(2, 0xff, 0x0038bf39);
+			apb_write_reg(2, 0xfe, 0x004);
+			apb_write_reg(2, 0xff, 0x003696f5);
+			apb_write_reg(2, 0xfe, 0x005);
+			apb_write_reg(2, 0xff, 0x003466b0);
+			apb_write_reg(2, 0xfe, 0x006);
+			apb_write_reg(2, 0xff, 0x00322e69);
+			apb_write_reg(2, 0xfe, 0x007);
+			apb_write_reg(2, 0xff, 0x002fee21);
+			apb_write_reg(2, 0xfe, 0x008);
+			apb_write_reg(2, 0xff, 0x002dadd9);
+			apb_write_reg(2, 0xfe, 0x009);
+			apb_write_reg(2, 0xff, 0x002b6d91);
+			apb_write_reg(2, 0xfe, 0x00a);
+			apb_write_reg(2, 0xff, 0x00291d48);
+			apb_write_reg(2, 0xfe, 0x00b);
+			apb_write_reg(2, 0xff, 0x0026ccfe);
+			apb_write_reg(2, 0xfe, 0x00c);
+			apb_write_reg(2, 0xff, 0x00245cb2);
+			apb_write_reg(2, 0xfe, 0x00d);
+			apb_write_reg(2, 0xff, 0x0021d463);
+			apb_write_reg(2, 0xfe, 0x00e);
+			apb_write_reg(2, 0xff, 0x001f2410);
+			apb_write_reg(2, 0xfe, 0x00f);
+			apb_write_reg(2, 0xff, 0x001c3bb6);
+			apb_write_reg(2, 0xfe, 0x010);
+			apb_write_reg(2, 0xff, 0x00192b57);
+			apb_write_reg(2, 0xfe, 0x011);
+			apb_write_reg(2, 0xff, 0x0015e2f1);
+			apb_write_reg(2, 0xfe, 0x012);
+			apb_write_reg(2, 0xff, 0x00127285);
+			apb_write_reg(2, 0xfe, 0x013);
+			apb_write_reg(2, 0xff, 0x000eca14);
+			apb_write_reg(2, 0xfe, 0x014);
+			apb_write_reg(2, 0xff, 0x000ac99b);
+			apb_write_reg(2, 0xfe, 0x015);
+			apb_write_reg(2, 0xff, 0x00063913);
+			apb_write_reg(2, 0xfe, 0x016);
+			apb_write_reg(2, 0xff, 0x0000c073);
+			apb_write_reg(2, 0xfe, 0x017);
+			apb_write_reg(2, 0xff, 0x003a3fb4);
+			apb_write_reg(2, 0xfe, 0x018);
+			apb_write_reg(2, 0xff, 0x00347ecf);
+			apb_write_reg(2, 0xfe, 0x019);
+			apb_write_reg(2, 0xff, 0x002ff649);
+			apb_write_reg(2, 0xfe, 0x01a);
+			apb_write_reg(2, 0xff, 0x002a8dab);
+			apb_write_reg(2, 0xfe, 0x01b);
+			apb_write_reg(2, 0xff, 0x002444f0);
+			apb_write_reg(2, 0xfe, 0x01c);
+			apb_write_reg(2, 0xff, 0x001d0c1b);
+			apb_write_reg(2, 0xfe, 0x01d);
+			apb_write_reg(2, 0xff, 0x000fc300);
+			apb_write_reg(2, 0xfe, 0x01e);
+			apb_write_reg(2, 0xff, 0x000118ce);
+			apb_write_reg(2, 0xfe, 0x01f);
+			apb_write_reg(2, 0xff, 0x003c17c3);
+			apb_write_reg(2, 0xfe, 0x020);
+			apb_write_reg(2, 0xff, 0x00000751);
+		} else if (bandwidth == 1) {
+			/* 7Mhz */
+			apb_write_reg(2, 0x2c, 0x24B);  /* ACF_STAGE1_A1 */
+			apb_write_reg(2, 0x2d, 0x0BD);  /* ACF_STAGE1_A2 */
+			apb_write_reg(2, 0x2e, 0x04B);  /* ACF_STAGE1_B1 */
+			apb_write_reg(2, 0x2f, 0x03E);  /* ACF_STAGE1_GAIN */
+			apb_write_reg(2, 0x30, 0x246);  /* ACF_STAGE2_A1 */
+			apb_write_reg(2, 0x31, 0x0D1);  /* ACF_STAGE2_A2 */
+			apb_write_reg(2, 0x32, 0x2A2);  /* ACF_STAGE2_B1 */
+			apb_write_reg(2, 0x33, 0x07C);  /* ACF_STAGE2_GAIN */
+			apb_write_reg(2, 0x34, 0x241);  /* ACF_STAGE3_A1 */
+			apb_write_reg(2, 0x35, 0x0E7);  /* ACF_STAGE3_A2 */
+			apb_write_reg(2, 0x36, 0x25B);  /* ACF_STAGE3_B1 */
+			apb_write_reg(2, 0x37, 0x05D);  /* ACF_STAGE3_GAIN */
+			apb_write_reg(2, 0x38, 0x23D);  /* ACF_STAGE4_A1 */
+			apb_write_reg(2, 0x39, 0x0F5);  /* ACF_STAGE4_A2 */
+			apb_write_reg(2, 0x3a, 0x248);  /* ACF_STAGE4_B1 */
+			apb_write_reg(2, 0x3b, 0x05A);  /* ACF_STAGE4_GAIN */
+			apb_write_reg(2, 0x3c, 0x23A);  /* ACF_STAGE5_A1 */
+			apb_write_reg(2, 0x3d, 0x0FD);  /* ACF_STAGE5_A2 */
+			apb_write_reg(2, 0x3e, 0x242);  /* ACF_STAGE5_B1 */
+			apb_write_reg(2, 0x3f, 0x04B);  /* ACF_STAGE5_GAIN */
+			apb_write_reg(2, 0xfe, 0x000);
+			apb_write_reg(2, 0xff, 0x003f07ff);
+			apb_write_reg(2, 0xfe, 0x001);
+			apb_write_reg(2, 0xff, 0x003cffbf);
+			apb_write_reg(2, 0xfe, 0x002);
+			apb_write_reg(2, 0xff, 0x003aef7e);
+			apb_write_reg(2, 0xfe, 0x003);
+			apb_write_reg(2, 0xff, 0x0038d73c);
+			apb_write_reg(2, 0xfe, 0x004);
+			apb_write_reg(2, 0xff, 0x0036b6f9);
+			apb_write_reg(2, 0xfe, 0x005);
+			apb_write_reg(2, 0xff, 0x003486b3);
+			apb_write_reg(2, 0xfe, 0x006);
+			apb_write_reg(2, 0xff, 0x00324e6d);
+			apb_write_reg(2, 0xfe, 0x007);
+			apb_write_reg(2, 0xff, 0x00300e25);
+			apb_write_reg(2, 0xfe, 0x008);
+			apb_write_reg(2, 0xff, 0x002dcddd);
+			apb_write_reg(2, 0xfe, 0x009);
+			apb_write_reg(2, 0xff, 0x002b8594);
+			apb_write_reg(2, 0xfe, 0x00a);
+			apb_write_reg(2, 0xff, 0x00292d4b);
+			apb_write_reg(2, 0xfe, 0x00b);
+			apb_write_reg(2, 0xff, 0x0026d500);
+			apb_write_reg(2, 0xfe, 0x00c);
+			apb_write_reg(2, 0xff, 0x00245cb3);
+			apb_write_reg(2, 0xfe, 0x00d);
+			apb_write_reg(2, 0xff, 0x0021cc62);
+			apb_write_reg(2, 0xfe, 0x00e);
+			apb_write_reg(2, 0xff, 0x001f0c0d);
+			apb_write_reg(2, 0xfe, 0x00f);
+			apb_write_reg(2, 0xff, 0x001c1bb3);
+			apb_write_reg(2, 0xfe, 0x010);
+			apb_write_reg(2, 0xff, 0x0018fb52);
+			apb_write_reg(2, 0xfe, 0x011);
+			apb_write_reg(2, 0xff, 0x0015b2eb);
+			apb_write_reg(2, 0xfe, 0x012);
+			apb_write_reg(2, 0xff, 0x00123a7f);
+			apb_write_reg(2, 0xfe, 0x013);
+			apb_write_reg(2, 0xff, 0x000e9a0e);
+			apb_write_reg(2, 0xfe, 0x014);
+			apb_write_reg(2, 0xff, 0x000a9995);
+			apb_write_reg(2, 0xfe, 0x015);
+			apb_write_reg(2, 0xff, 0x0006090d);
+			apb_write_reg(2, 0xfe, 0x016);
+			apb_write_reg(2, 0xff, 0x0000a06e);
+			apb_write_reg(2, 0xfe, 0x017);
+			apb_write_reg(2, 0xff, 0x003a57b3);
+			apb_write_reg(2, 0xfe, 0x018);
+			apb_write_reg(2, 0xff, 0x0034ded8);
+			apb_write_reg(2, 0xfe, 0x019);
+			apb_write_reg(2, 0xff, 0x00309659);
+			apb_write_reg(2, 0xfe, 0x01a);
+			apb_write_reg(2, 0xff, 0x002b75c4);
+			apb_write_reg(2, 0xfe, 0x01b);
+			apb_write_reg(2, 0xff, 0x0025350e);
+			apb_write_reg(2, 0xfe, 0x01c);
+			apb_write_reg(2, 0xff, 0x001dec37);
+			apb_write_reg(2, 0xfe, 0x01d);
+			apb_write_reg(2, 0xff, 0x00126b28);
+			apb_write_reg(2, 0xfe, 0x01e);
+			apb_write_reg(2, 0xff, 0x00031130);
+			apb_write_reg(2, 0xfe, 0x01f);
+			apb_write_reg(2, 0xff, 0x003cffec);
+			apb_write_reg(2, 0xfe, 0x020);
+			apb_write_reg(2, 0xff, 0x00000767);
+		} else if (bandwidth == 2) {
+			/* 6MHz */
+			apb_write_reg(2, 0x2c, 0x240);  /* ACF_STAGE1_A1 */
+			apb_write_reg(2, 0x2d, 0x0C6);  /* ACF_STAGE1_A2 */
+			apb_write_reg(2, 0x2e, 0x3F9);  /* ACF_STAGE1_B1 */
+			apb_write_reg(2, 0x2f, 0x03E);  /* ACF_STAGE1_GAIN */
+			apb_write_reg(2, 0x30, 0x23A);  /* ACF_STAGE2_A1 */
+			apb_write_reg(2, 0x31, 0x0D7);  /* ACF_STAGE2_A2 */
+			apb_write_reg(2, 0x32, 0x27B);  /* ACF_STAGE2_B1 */
+			apb_write_reg(2, 0x33, 0x07C);  /* ACF_STAGE2_GAIN */
+			apb_write_reg(2, 0x34, 0x233);  /* ACF_STAGE3_A1 */
+			apb_write_reg(2, 0x35, 0x0EA);  /* ACF_STAGE3_A2 */
+			apb_write_reg(2, 0x36, 0x244);  /* ACF_STAGE3_B1 */
+			apb_write_reg(2, 0x37, 0x05D);  /* ACF_STAGE3_GAIN */
+			apb_write_reg(2, 0x38, 0x22F);  /* ACF_STAGE4_A1 */
+			apb_write_reg(2, 0x39, 0x0F6);  /* ACF_STAGE4_A2 */
+			apb_write_reg(2, 0x3a, 0x235);  /* ACF_STAGE4_B1 */
+			apb_write_reg(2, 0x3b, 0x05A);  /* ACF_STAGE4_GAIN */
+			apb_write_reg(2, 0x3c, 0x22B);  /* ACF_STAGE5_A1 */
+			apb_write_reg(2, 0x3d, 0x0FD);  /* ACF_STAGE5_A2 */
+			apb_write_reg(2, 0x3e, 0x231);  /* ACF_STAGE5_B1 */
+			apb_write_reg(2, 0x3f, 0x04B);  /* ACF_STAGE5_GAIN */
+			apb_write_reg(2, 0xfe, 0x000);
+			apb_write_reg(2, 0xff, 0x003f07ff);
+			apb_write_reg(2, 0xfe, 0x001);
+			apb_write_reg(2, 0xff, 0x003cffbf);
+			apb_write_reg(2, 0xfe, 0x002);
+			apb_write_reg(2, 0xff, 0x003aef7e);
+			apb_write_reg(2, 0xfe, 0x003);
+			apb_write_reg(2, 0xff, 0x0038d73c);
+			apb_write_reg(2, 0xfe, 0x004);
+			apb_write_reg(2, 0xff, 0x0036b6f8);
+			apb_write_reg(2, 0xfe, 0x005);
+			apb_write_reg(2, 0xff, 0x003486b3);
+			apb_write_reg(2, 0xfe, 0x006);
+			apb_write_reg(2, 0xff, 0x0032466c);
+			apb_write_reg(2, 0xfe, 0x007);
+			apb_write_reg(2, 0xff, 0x002ffe24);
+			apb_write_reg(2, 0xfe, 0x008);
+			apb_write_reg(2, 0xff, 0x002dadda);
+			apb_write_reg(2, 0xfe, 0x009);
+			apb_write_reg(2, 0xff, 0x002b5d90);
+			apb_write_reg(2, 0xfe, 0x00a);
+			apb_write_reg(2, 0xff, 0x0028fd45);
+			apb_write_reg(2, 0xfe, 0x00b);
+			apb_write_reg(2, 0xff, 0x002694f9);
+			apb_write_reg(2, 0xfe, 0x00c);
+			apb_write_reg(2, 0xff, 0x002414ab);
+			apb_write_reg(2, 0xfe, 0x00d);
+			apb_write_reg(2, 0xff, 0x00217458);
+			apb_write_reg(2, 0xfe, 0x00e);
+			apb_write_reg(2, 0xff, 0x001ea402);
+			apb_write_reg(2, 0xfe, 0x00f);
+			apb_write_reg(2, 0xff, 0x001ba3a5);
+			apb_write_reg(2, 0xfe, 0x010);
+			apb_write_reg(2, 0xff, 0x00187342);
+			apb_write_reg(2, 0xfe, 0x011);
+			apb_write_reg(2, 0xff, 0x00151ad9);
+			apb_write_reg(2, 0xfe, 0x012);
+			apb_write_reg(2, 0xff, 0x0011926b);
+			apb_write_reg(2, 0xfe, 0x013);
+			apb_write_reg(2, 0xff, 0x000dc9f6);
+			apb_write_reg(2, 0xfe, 0x014);
+			apb_write_reg(2, 0xff, 0x0009a178);
+			apb_write_reg(2, 0xfe, 0x015);
+			apb_write_reg(2, 0xff, 0x0004d8eb);
+			apb_write_reg(2, 0xfe, 0x016);
+			apb_write_reg(2, 0xff, 0x003f4045);
+			apb_write_reg(2, 0xfe, 0x017);
+			apb_write_reg(2, 0xff, 0x0038e785);
+			apb_write_reg(2, 0xfe, 0x018);
+			apb_write_reg(2, 0xff, 0x00337eab);
+			apb_write_reg(2, 0xfe, 0x019);
+			apb_write_reg(2, 0xff, 0x002f3e2d);
+			apb_write_reg(2, 0xfe, 0x01a);
+			apb_write_reg(2, 0xff, 0x002a1599);
+			apb_write_reg(2, 0xfe, 0x01b);
+			apb_write_reg(2, 0xff, 0x0023ace1);
+			apb_write_reg(2, 0xfe, 0x01c);
+			apb_write_reg(2, 0xff, 0x001b33fb);
+			apb_write_reg(2, 0xfe, 0x01d);
+			apb_write_reg(2, 0xff, 0x000cd29c);
+			apb_write_reg(2, 0xfe, 0x01e);
+			apb_write_reg(2, 0xff, 0x0001c0c1);
+			apb_write_reg(2, 0xfe, 0x01f);
+			apb_write_reg(2, 0xff, 0x003cefde);
+			apb_write_reg(2, 0xfe, 0x020);
+			apb_write_reg(2, 0xff, 0x0000076a);
+		} else {
+			/* 5MHz */
+			apb_write_reg(2, 0x2c, 0x236);  /* ACF_STAGE1_A1 */
+			apb_write_reg(2, 0x2d, 0x0CE);  /* ACF_STAGE1_A2 */
+			apb_write_reg(2, 0x2e, 0x39A);  /* ACF_STAGE1_B1 */
+			apb_write_reg(2, 0x2f, 0x03E);  /* ACF_STAGE1_GAIN */
+			apb_write_reg(2, 0x30, 0x22F);  /* ACF_STAGE2_A1 */
+			apb_write_reg(2, 0x31, 0x0DE);  /* ACF_STAGE2_A2 */
+			apb_write_reg(2, 0x32, 0x257);  /* ACF_STAGE2_B1 */
+			apb_write_reg(2, 0x33, 0x07C);  /* ACF_STAGE2_GAIN */
+			apb_write_reg(2, 0x34, 0x227);  /* ACF_STAGE3_A1 */
+			apb_write_reg(2, 0x35, 0x0EE);  /* ACF_STAGE3_A2 */
+			apb_write_reg(2, 0x36, 0x230);  /* ACF_STAGE3_B1 */
+			apb_write_reg(2, 0x37, 0x05D);  /* ACF_STAGE3_GAIN */
+			apb_write_reg(2, 0x38, 0x222);  /* ACF_STAGE4_A1 */
+			apb_write_reg(2, 0x39, 0x0F8);  /* ACF_STAGE4_A2 */
+			apb_write_reg(2, 0x3a, 0x225);  /* ACF_STAGE4_B1 */
+			apb_write_reg(2, 0x3b, 0x05A);  /* ACF_STAGE4_GAIN */
+			apb_write_reg(2, 0x3c, 0x21E);  /* ACF_STAGE5_A1 */
+			apb_write_reg(2, 0x3d, 0x0FE);  /* ACF_STAGE5_A2 */
+			apb_write_reg(2, 0x3e, 0x222);  /* ACF_STAGE5_B1 */
+			apb_write_reg(2, 0x3f, 0x04B);  /* ACF_STAGE5_GAIN */
+			apb_write_reg(2, 0xfe, 0x000);
+			apb_write_reg(2, 0xff, 0x003effff);
+			apb_write_reg(2, 0xfe, 0x001);
+			apb_write_reg(2, 0xff, 0x003ce7bd);
+			apb_write_reg(2, 0xfe, 0x002);
+			apb_write_reg(2, 0xff, 0x003ac77a);
+			apb_write_reg(2, 0xfe, 0x003);
+			apb_write_reg(2, 0xff, 0x0038a737);
+			apb_write_reg(2, 0xfe, 0x004);
+			apb_write_reg(2, 0xff, 0x00367ef2);
+			apb_write_reg(2, 0xfe, 0x005);
+			apb_write_reg(2, 0xff, 0x00344eac);
+			apb_write_reg(2, 0xfe, 0x006);
+			apb_write_reg(2, 0xff, 0x00321e66);
+			apb_write_reg(2, 0xfe, 0x007);
+			apb_write_reg(2, 0xff, 0x002fee20);
+			apb_write_reg(2, 0xfe, 0x008);
+			apb_write_reg(2, 0xff, 0x002dbdda);
+			apb_write_reg(2, 0xfe, 0x009);
+			apb_write_reg(2, 0xff, 0x002b8d94);
+			apb_write_reg(2, 0xfe, 0x00a);
+			apb_write_reg(2, 0xff, 0x00295d4e);
+			apb_write_reg(2, 0xfe, 0x00b);
+			apb_write_reg(2, 0xff, 0x00272508);
+			apb_write_reg(2, 0xfe, 0x00c);
+			apb_write_reg(2, 0xff, 0x0024dcc0);
+			apb_write_reg(2, 0xfe, 0x00d);
+			apb_write_reg(2, 0xff, 0x00227475);
+			apb_write_reg(2, 0xfe, 0x00e);
+			apb_write_reg(2, 0xff, 0x001fe426);
+			apb_write_reg(2, 0xfe, 0x00f);
+			apb_write_reg(2, 0xff, 0x001d1bd1);
+			apb_write_reg(2, 0xfe, 0x010);
+			apb_write_reg(2, 0xff, 0x001a2374);
+			apb_write_reg(2, 0xfe, 0x011);
+			apb_write_reg(2, 0xff, 0x0016e311);
+			apb_write_reg(2, 0xfe, 0x012);
+			apb_write_reg(2, 0xff, 0x00136aa6);
+			apb_write_reg(2, 0xfe, 0x013);
+			apb_write_reg(2, 0xff, 0x000fba33);
+			apb_write_reg(2, 0xfe, 0x014);
+			apb_write_reg(2, 0xff, 0x000ba9b8);
+			apb_write_reg(2, 0xfe, 0x015);
+			apb_write_reg(2, 0xff, 0x0007092e);
+			apb_write_reg(2, 0xfe, 0x016);
+			apb_write_reg(2, 0xff, 0x0001988e);
+			apb_write_reg(2, 0xfe, 0x017);
+			apb_write_reg(2, 0xff, 0x003b37d0);
+			apb_write_reg(2, 0xfe, 0x018);
+			apb_write_reg(2, 0xff, 0x0035aef3);
+			apb_write_reg(2, 0xfe, 0x019);
+			apb_write_reg(2, 0xff, 0x00316673);
+			apb_write_reg(2, 0xfe, 0x01a);
+			apb_write_reg(2, 0xff, 0x002c45de);
+			apb_write_reg(2, 0xfe, 0x01b);
+			apb_write_reg(2, 0xff, 0x0025e527);
+			apb_write_reg(2, 0xfe, 0x01c);
+			apb_write_reg(2, 0xff, 0x001da444);
+			apb_write_reg(2, 0xfe, 0x01d);
+			apb_write_reg(2, 0xff, 0x000deaea);
+			apb_write_reg(2, 0xfe, 0x01e);
+			apb_write_reg(2, 0xff, 0x000178bf);
+			apb_write_reg(2, 0xfe, 0x01f);
+			apb_write_reg(2, 0xff, 0x003cb7d6);
+			apb_write_reg(2, 0xfe, 0x020);
+			apb_write_reg(2, 0xff, 0x00000765);
+		}
+	} else if (ADsample == 28) {
+		/* 28.5714 MHz Set ACF */
+		if (bandwidth == 0) {
+			/*8M Hz */
+			apb_write_reg(2, 0x2c, 0x2DB);  /* ACF_STAGE1_A1 */
+			apb_write_reg(2, 0x2d, 0x05B);  /* ACF_STAGE1_A2 */
+			apb_write_reg(2, 0x2e, 0x163);  /* ACF_STAGE1_B1 */
+			apb_write_reg(2, 0x2f, 0x00E);  /* ACF_STAGE1_GAIN */
+			apb_write_reg(2, 0x30, 0x2D5);  /* ACF_STAGE2_A1 */
+			apb_write_reg(2, 0x31, 0x08B);  /* ACF_STAGE2_A2 */
+			apb_write_reg(2, 0x32, 0x3BC);  /* ACF_STAGE2_B1 */
+			apb_write_reg(2, 0x33, 0x06D);  /* ACF_STAGE2_GAIN */
+			apb_write_reg(2, 0x34, 0x2CF);  /* ACF_STAGE3_A1 */
+			apb_write_reg(2, 0x35, 0x0BF);  /* ACF_STAGE3_A2 */
+			apb_write_reg(2, 0x36, 0x321);  /* ACF_STAGE3_B1 */
+			apb_write_reg(2, 0x37, 0x008);  /* ACF_STAGE3_GAIN */
+			apb_write_reg(2, 0x38, 0x2C9);  /* ACF_STAGE4_A1 */
+			apb_write_reg(2, 0x39, 0x0E3);  /* ACF_STAGE4_A2 */
+			apb_write_reg(2, 0x3a, 0x2EE);  /* ACF_STAGE4_B1 */
+			apb_write_reg(2, 0x3b, 0x058);  /* ACF_STAGE4_GAIN */
+			apb_write_reg(2, 0x3c, 0x2C3);  /* ACF_STAGE5_A1 */
+			apb_write_reg(2, 0x3d, 0x0F8);  /* ACF_STAGE5_A2 */
+			apb_write_reg(2, 0x3e, 0x2DD);  /* ACF_STAGE5_B1 */
+			apb_write_reg(2, 0x3f, 0x04D);  /* ACF_STAGE5_GAIN */
+
+			apb_write_reg(2, 0xfe, 0x000);
+			apb_write_reg(2, 0xff, 0x003ef7ff);
+			apb_write_reg(2, 0xfe, 0x001);
+			apb_write_reg(2, 0xff, 0x003d37c0);
+			apb_write_reg(2, 0xfe, 0x002);
+			apb_write_reg(2, 0xff, 0x003c3f94);
+			apb_write_reg(2, 0xfe, 0x003);
+			apb_write_reg(2, 0xff, 0x003b0f78);
+			apb_write_reg(2, 0xfe, 0x004);
+			apb_write_reg(2, 0xff, 0x0038c73f);
+			apb_write_reg(2, 0xfe, 0x005);
+			apb_write_reg(2, 0xff, 0x00369ef1);
+			apb_write_reg(2, 0xfe, 0x006);
+			apb_write_reg(2, 0xff, 0x003576be);
+			apb_write_reg(2, 0xfe, 0x007);
+			apb_write_reg(2, 0xff, 0x0033b698);
+			apb_write_reg(2, 0xfe, 0x008);
+			apb_write_reg(2, 0xff, 0x0031164d);
+			apb_write_reg(2, 0xfe, 0x009);
+			apb_write_reg(2, 0xff, 0x002f1dfd);
+			apb_write_reg(2, 0xfe, 0x00a);
+			apb_write_reg(2, 0xff, 0x002de5cf);
+			apb_write_reg(2, 0xfe, 0x00b);
+			apb_write_reg(2, 0xff, 0x002c15a2);
+			apb_write_reg(2, 0xfe, 0x00c);
+			apb_write_reg(2, 0xff, 0x0029f560);
+			apb_write_reg(2, 0xfe, 0x00d);
+			apb_write_reg(2, 0xff, 0x0027bd1b);
+			apb_write_reg(2, 0xfe, 0x00e);
+			apb_write_reg(2, 0xff, 0x00252ccf);
+			apb_write_reg(2, 0xfe, 0x00f);
+			apb_write_reg(2, 0xff, 0x0022bc7c);
+			apb_write_reg(2, 0xfe, 0x010);
+			apb_write_reg(2, 0xff, 0x00207c34);
+			apb_write_reg(2, 0xfe, 0x011);
+			apb_write_reg(2, 0xff, 0x001da3e5);
+			apb_write_reg(2, 0xfe, 0x012);
+			apb_write_reg(2, 0xff, 0x001a9b83);
+			apb_write_reg(2, 0xfe, 0x013);
+			apb_write_reg(2, 0xff, 0x0017db27);
+			apb_write_reg(2, 0xfe, 0x014);
+			apb_write_reg(2, 0xff, 0x001432c6);
+			apb_write_reg(2, 0xfe, 0x015);
+			apb_write_reg(2, 0xff, 0x000fa23e);
+			apb_write_reg(2, 0xfe, 0x016);
+			apb_write_reg(2, 0xff, 0x000b91af);
+			apb_write_reg(2, 0xfe, 0x017);
+			apb_write_reg(2, 0xff, 0x00077136);
+			apb_write_reg(2, 0xfe, 0x018);
+			apb_write_reg(2, 0xff, 0x0002c090);
+			apb_write_reg(2, 0xfe, 0x019);
+			apb_write_reg(2, 0xff, 0x003ec01a);
+			apb_write_reg(2, 0xfe, 0x01a);
+			apb_write_reg(2, 0xff, 0x003a3f92);
+			apb_write_reg(2, 0xfe, 0x01b);
+			apb_write_reg(2, 0xff, 0x00354efa);
+			apb_write_reg(2, 0xfe, 0x01c);
+			apb_write_reg(2, 0xff, 0x002fee54);
+			apb_write_reg(2, 0xfe, 0x01d);
+			apb_write_reg(2, 0xff, 0x002a35a3);
+			apb_write_reg(2, 0xfe, 0x01e);
+			apb_write_reg(2, 0xff, 0x0023f4e4);
+			apb_write_reg(2, 0xfe, 0x01f);
+			apb_write_reg(2, 0xff, 0x001cdc12);
+			apb_write_reg(2, 0xfe, 0x020);
+			apb_write_reg(2, 0xff, 0x00000316);
+		} else if (bandwidth == 1) {
+			apb_write_reg(2, 0x2c, 0x2C2);  /* ACF_STAGE1_A1 */
+			apb_write_reg(2, 0x2d, 0x069);  /* ACF_STAGE1_A2 */
+			apb_write_reg(2, 0x2e, 0x134);  /* ACF_STAGE1_B1 */
+			apb_write_reg(2, 0x2f, 0x00E);  /* ACF_STAGE1_GAIN */
+			apb_write_reg(2, 0x30, 0x2B7);  /* ACF_STAGE2_A1 */
+			apb_write_reg(2, 0x31, 0x095);  /* ACF_STAGE2_A2 */
+			apb_write_reg(2, 0x32, 0x36F);  /* ACF_STAGE2_B1 */
+			apb_write_reg(2, 0x33, 0x06D);  /* ACF_STAGE2_GAIN */
+			apb_write_reg(2, 0x34, 0x2AA);  /* ACF_STAGE3_A1 */
+			apb_write_reg(2, 0x35, 0x0C6);  /* ACF_STAGE3_A2 */
+			apb_write_reg(2, 0x36, 0x2E5);  /* ACF_STAGE3_B1 */
+			apb_write_reg(2, 0x37, 0x008);  /* ACF_STAGE3_GAIN */
+			apb_write_reg(2, 0x38, 0x2A1);  /* ACF_STAGE4_A1 */
+			apb_write_reg(2, 0x39, 0x0E6);  /* ACF_STAGE4_A2 */
+			apb_write_reg(2, 0x3a, 0x2BA);  /* ACF_STAGE4_B1 */
+			apb_write_reg(2, 0x3b, 0x058);  /* ACF_STAGE4_GAIN */
+			apb_write_reg(2, 0x3c, 0x299);  /* ACF_STAGE5_A1 */
+			apb_write_reg(2, 0x3d, 0x0F9);  /* ACF_STAGE5_A2 */
+			apb_write_reg(2, 0x3e, 0x2AC);  /* ACF_STAGE5_B1 */
+			apb_write_reg(2, 0x3f, 0x04D);  /* ACF_STAGE5_GAIN */
+
+			apb_write_reg(2, 0xfe, 0x000);
+			apb_write_reg(2, 0xff, 0x003ee7ff);
+			apb_write_reg(2, 0xfe, 0x001);
+			apb_write_reg(2, 0xff, 0x003d1fbc);
+			apb_write_reg(2, 0xfe, 0x002);
+			apb_write_reg(2, 0xff, 0x003bf790);
+			apb_write_reg(2, 0xfe, 0x003);
+			apb_write_reg(2, 0xff, 0x003a876a);
+			apb_write_reg(2, 0xfe, 0x004);
+			apb_write_reg(2, 0xff, 0x00388f31);
+			apb_write_reg(2, 0xfe, 0x005);
+			apb_write_reg(2, 0xff, 0x0036c6f3);
+			apb_write_reg(2, 0xfe, 0x006);
+			apb_write_reg(2, 0xff, 0x003536bf);
+			apb_write_reg(2, 0xfe, 0x007);
+			apb_write_reg(2, 0xff, 0x00334689);
+			apb_write_reg(2, 0xfe, 0x008);
+			apb_write_reg(2, 0xff, 0x00310644);
+			apb_write_reg(2, 0xfe, 0x009);
+			apb_write_reg(2, 0xff, 0x002ef5fd);
+			apb_write_reg(2, 0xfe, 0x00a);
+			apb_write_reg(2, 0xff, 0x002d45c2);
+			apb_write_reg(2, 0xfe, 0x00b);
+			apb_write_reg(2, 0xff, 0x002b7d8c);
+			apb_write_reg(2, 0xfe, 0x00c);
+			apb_write_reg(2, 0xff, 0x00298550);
+			apb_write_reg(2, 0xfe, 0x00d);
+			apb_write_reg(2, 0xff, 0x00278510);
+			apb_write_reg(2, 0xfe, 0x00e);
+			apb_write_reg(2, 0xff, 0x00252ccc);
+			apb_write_reg(2, 0xfe, 0x00f);
+			apb_write_reg(2, 0xff, 0x0022847c);
+			apb_write_reg(2, 0xfe, 0x010);
+			apb_write_reg(2, 0xff, 0x00201427);
+			apb_write_reg(2, 0xfe, 0x011);
+			apb_write_reg(2, 0xff, 0x001e03e0);
+			apb_write_reg(2, 0xfe, 0x012);
+			apb_write_reg(2, 0xff, 0x001b6b9b);
+			apb_write_reg(2, 0xfe, 0x013);
+			apb_write_reg(2, 0xff, 0x0017c336);
+			apb_write_reg(2, 0xfe, 0x014);
+			apb_write_reg(2, 0xff, 0x0013e2b8);
+			apb_write_reg(2, 0xfe, 0x015);
+			apb_write_reg(2, 0xff, 0x0010b246);
+			apb_write_reg(2, 0xfe, 0x016);
+			apb_write_reg(2, 0xff, 0x000d81e8);
+			apb_write_reg(2, 0xfe, 0x017);
+			apb_write_reg(2, 0xff, 0x00084966);
+			apb_write_reg(2, 0xfe, 0x018);
+			apb_write_reg(2, 0xff, 0x0003089c);
+			apb_write_reg(2, 0xfe, 0x019);
+			apb_write_reg(2, 0xff, 0x003f0022);
+			apb_write_reg(2, 0xfe, 0x01a);
+			apb_write_reg(2, 0xff, 0x003aaf9c);
+			apb_write_reg(2, 0xfe, 0x01b);
+			apb_write_reg(2, 0xff, 0x00360f0c);
+			apb_write_reg(2, 0xfe, 0x01c);
+			apb_write_reg(2, 0xff, 0x00312e74);
+			apb_write_reg(2, 0xfe, 0x01d);
+			apb_write_reg(2, 0xff, 0x002c05d3);
+			apb_write_reg(2, 0xfe, 0x01e);
+			apb_write_reg(2, 0xff, 0x00268d2a);
+			apb_write_reg(2, 0xfe, 0x01f);
+			apb_write_reg(2, 0xff, 0x0020bc76);
+			apb_write_reg(2, 0xfe, 0x020);
+			apb_write_reg(2, 0xff, 0x000003b3);
+		} else if (bandwidth == 2) {
+			/* 6MHz */
+			apb_write_reg(2, 0x2c, 0x2A9);  /* ACF_STAGE1_A1 */
+			apb_write_reg(2, 0x2d, 0x078);  /* ACF_STAGE1_A2 */
+			apb_write_reg(2, 0x2e, 0x0F4);  /* ACF_STAGE1_B1 */
+			apb_write_reg(2, 0x2f, 0x01E);  /* ACF_STAGE1_GAIN */
+			apb_write_reg(2, 0x30, 0x299);  /* ACF_STAGE2_A1 */
+			apb_write_reg(2, 0x31, 0x0A1);  /* ACF_STAGE2_A2 */
+			apb_write_reg(2, 0x32, 0x321);  /* ACF_STAGE2_B1 */
+			apb_write_reg(2, 0x33, 0x078);  /* ACF_STAGE2_GAIN */
+			apb_write_reg(2, 0x34, 0x288);  /* ACF_STAGE3_A1 */
+			apb_write_reg(2, 0x35, 0x0CD);  /* ACF_STAGE3_A2 */
+			apb_write_reg(2, 0x36, 0x2AE);  /* ACF_STAGE3_B1 */
+			apb_write_reg(2, 0x37, 0x05F);  /* ACF_STAGE3_GAIN */
+			apb_write_reg(2, 0x38, 0x27C);  /* ACF_STAGE4_A1 */
+			apb_write_reg(2, 0x39, 0x0E9);  /* ACF_STAGE4_A2 */
+			apb_write_reg(2, 0x3a, 0x28B);  /* ACF_STAGE4_B1 */
+			apb_write_reg(2, 0x3b, 0x058);  /* ACF_STAGE4_GAIN */
+			apb_write_reg(2, 0x3c, 0x273);  /* ACF_STAGE5_A1 */
+			apb_write_reg(2, 0x3d, 0x0FA);  /* ACF_STAGE5_A2 */
+			apb_write_reg(2, 0x3e, 0x281);  /* ACF_STAGE5_B1 */
+			apb_write_reg(2, 0x3f, 0x04D);  /* ACF_STAGE5_GAIN */
+
+			apb_write_reg(2, 0xfe, 0x000);
+			apb_write_reg(2, 0xff, 0x003f17ff);
+			apb_write_reg(2, 0xfe, 0x001);
+			apb_write_reg(2, 0xff, 0x003d3fc4);
+			apb_write_reg(2, 0xfe, 0x002);
+			apb_write_reg(2, 0xff, 0x003b7f8a);
+			apb_write_reg(2, 0xfe, 0x003);
+			apb_write_reg(2, 0xff, 0x0039df55);
+			apb_write_reg(2, 0xfe, 0x004);
+			apb_write_reg(2, 0xff, 0x00381720);
+			apb_write_reg(2, 0xfe, 0x005);
+			apb_write_reg(2, 0xff, 0x00360ee2);
+			apb_write_reg(2, 0xfe, 0x006);
+			apb_write_reg(2, 0xff, 0x00342ea1);
+			apb_write_reg(2, 0xfe, 0x007);
+			apb_write_reg(2, 0xff, 0x0032ee6e);
+			apb_write_reg(2, 0xfe, 0x008);
+			apb_write_reg(2, 0xff, 0x0031e64e);
+			apb_write_reg(2, 0xfe, 0x009);
+			apb_write_reg(2, 0xff, 0x00300e22);
+			apb_write_reg(2, 0xfe, 0x00a);
+			apb_write_reg(2, 0xff, 0x002daddc);
+			apb_write_reg(2, 0xfe, 0x00b);
+			apb_write_reg(2, 0xff, 0x002b758f);
+			apb_write_reg(2, 0xfe, 0x00c);
+			apb_write_reg(2, 0xff, 0x0029ad51);
+			apb_write_reg(2, 0xfe, 0x00d);
+			apb_write_reg(2, 0xff, 0x0027ad18);
+			apb_write_reg(2, 0xfe, 0x00e);
+			apb_write_reg(2, 0xff, 0x00250ccd);
+			apb_write_reg(2, 0xfe, 0x00f);
+			apb_write_reg(2, 0xff, 0x00227476);
+			apb_write_reg(2, 0xfe, 0x010);
+			apb_write_reg(2, 0xff, 0x00204c2a);
+			apb_write_reg(2, 0xfe, 0x011);
+			apb_write_reg(2, 0xff, 0x001de3e6);
+			apb_write_reg(2, 0xfe, 0x012);
+			apb_write_reg(2, 0xff, 0x001a838a);
+			apb_write_reg(2, 0xfe, 0x013);
+			apb_write_reg(2, 0xff, 0x0016ab12);
+			apb_write_reg(2, 0xfe, 0x014);
+			apb_write_reg(2, 0xff, 0x00137a9d);
+			apb_write_reg(2, 0xfe, 0x015);
+			apb_write_reg(2, 0xff, 0x00113a4a);
+			apb_write_reg(2, 0xfe, 0x016);
+			apb_write_reg(2, 0xff, 0x000db1f8);
+			apb_write_reg(2, 0xfe, 0x017);
+			apb_write_reg(2, 0xff, 0x0007c15f);
+			apb_write_reg(2, 0xfe, 0x018);
+			apb_write_reg(2, 0xff, 0x00022883);
+			apb_write_reg(2, 0xfe, 0x019);
+			apb_write_reg(2, 0xff, 0x003df803);
+			apb_write_reg(2, 0xfe, 0x01a);
+			apb_write_reg(2, 0xff, 0x00398f79);
+			apb_write_reg(2, 0xfe, 0x01b);
+			apb_write_reg(2, 0xff, 0x0034d6e6);
+			apb_write_reg(2, 0xfe, 0x01c);
+			apb_write_reg(2, 0xff, 0x002fd64b);
+			apb_write_reg(2, 0xfe, 0x01d);
+			apb_write_reg(2, 0xff, 0x002a8da7);
+			apb_write_reg(2, 0xfe, 0x01e);
+			apb_write_reg(2, 0xff, 0x002504fa);
+			apb_write_reg(2, 0xfe, 0x01f);
+			apb_write_reg(2, 0xff, 0x001f2443);
+			apb_write_reg(2, 0xfe, 0x020);
+			apb_write_reg(2, 0xff, 0x00000382);
+		} else {
+			apb_write_reg(2, 0x2c, 0x28F);  /* ACF_STAGE1_A1 */
+			apb_write_reg(2, 0x2d, 0x088);  /* ACF_STAGE1_A2 */
+			apb_write_reg(2, 0x2e, 0x09E);  /* ACF_STAGE1_B1 */
+			apb_write_reg(2, 0x2f, 0x01E);  /* ACF_STAGE1_GAIN */
+			apb_write_reg(2, 0x30, 0x27C);  /* ACF_STAGE2_A1 */
+			apb_write_reg(2, 0x31, 0x0AD);  /* ACF_STAGE2_A2 */
+			apb_write_reg(2, 0x32, 0x2D6);  /* ACF_STAGE2_B1 */
+			apb_write_reg(2, 0x33, 0x078);  /* ACF_STAGE2_GAIN */
+			apb_write_reg(2, 0x34, 0x268);  /* ACF_STAGE3_A1 */
+			apb_write_reg(2, 0x35, 0x0D4);  /* ACF_STAGE3_A2 */
+			apb_write_reg(2, 0x36, 0x27C);  /* ACF_STAGE3_B1 */
+			apb_write_reg(2, 0x37, 0x05F);  /* ACF_STAGE3_GAIN */
+			apb_write_reg(2, 0x38, 0x25B);  /* ACF_STAGE4_A1 */
+			apb_write_reg(2, 0x39, 0x0ED);  /* ACF_STAGE4_A2 */
+			apb_write_reg(2, 0x3a, 0x262);  /* ACF_STAGE4_B1 */
+			apb_write_reg(2, 0x3b, 0x058);  /* ACF_STAGE4_GAIN */
+			apb_write_reg(2, 0x3c, 0x252);  /* ACF_STAGE5_A1 */
+			apb_write_reg(2, 0x3d, 0x0FB);  /* ACF_STAGE5_A2 */
+			apb_write_reg(2, 0x3e, 0x25A);  /* ACF_STAGE5_B1 */
+			apb_write_reg(2, 0x3f, 0x04D);  /* ACF_STAGE5_GAIN */
+
+			apb_write_reg(2, 0xfe, 0x000);
+			apb_write_reg(2, 0xff, 0x003f17ff);
+			apb_write_reg(2, 0xfe, 0x001);
+			apb_write_reg(2, 0xff, 0x003d4fc5);
+			apb_write_reg(2, 0xfe, 0x002);
+			apb_write_reg(2, 0xff, 0x003baf8e);
+			apb_write_reg(2, 0xfe, 0x003);
+			apb_write_reg(2, 0xff, 0x003a3f5d);
+			apb_write_reg(2, 0xfe, 0x004);
+			apb_write_reg(2, 0xff, 0x0038df32);
+			apb_write_reg(2, 0xfe, 0x005);
+			apb_write_reg(2, 0xff, 0x00374703);
+			apb_write_reg(2, 0xfe, 0x006);
+			apb_write_reg(2, 0xff, 0x00354ec9);
+			apb_write_reg(2, 0xfe, 0x007);
+			apb_write_reg(2, 0xff, 0x00333e88);
+			apb_write_reg(2, 0xfe, 0x008);
+			apb_write_reg(2, 0xff, 0x00314e47);
+			apb_write_reg(2, 0xfe, 0x009);
+			apb_write_reg(2, 0xff, 0x002f860c);
+			apb_write_reg(2, 0xfe, 0x00a);
+			apb_write_reg(2, 0xff, 0x002d9dd2);
+			apb_write_reg(2, 0xfe, 0x00b);
+			apb_write_reg(2, 0xff, 0x002b5590);
+			apb_write_reg(2, 0xfe, 0x00c);
+			apb_write_reg(2, 0xff, 0x0028cd42);
+			apb_write_reg(2, 0xfe, 0x00d);
+			apb_write_reg(2, 0xff, 0x00266cf2);
+			apb_write_reg(2, 0xfe, 0x00e);
+			apb_write_reg(2, 0xff, 0x00245cab);
+			apb_write_reg(2, 0xfe, 0x00f);
+			apb_write_reg(2, 0xff, 0x00225c6b);
+			apb_write_reg(2, 0xfe, 0x010);
+			apb_write_reg(2, 0xff, 0x00200427);
+			apb_write_reg(2, 0xfe, 0x011);
+			apb_write_reg(2, 0xff, 0x001d4bd5);
+			apb_write_reg(2, 0xfe, 0x012);
+			apb_write_reg(2, 0xff, 0x001a9b7d);
+			apb_write_reg(2, 0xfe, 0x013);
+			apb_write_reg(2, 0xff, 0x00183b2b);
+			apb_write_reg(2, 0xfe, 0x014);
+			apb_write_reg(2, 0xff, 0x0015b2e1);
+			apb_write_reg(2, 0xfe, 0x015);
+			apb_write_reg(2, 0xff, 0x00122a83);
+			apb_write_reg(2, 0xfe, 0x016);
+			apb_write_reg(2, 0xff, 0x000d49fc);
+			apb_write_reg(2, 0xfe, 0x017);
+			apb_write_reg(2, 0xff, 0x0007594e);
+			apb_write_reg(2, 0xfe, 0x018);
+			apb_write_reg(2, 0xff, 0x00024080);
+			apb_write_reg(2, 0xfe, 0x019);
+			apb_write_reg(2, 0xff, 0x003e980e);
+			apb_write_reg(2, 0xfe, 0x01a);
+			apb_write_reg(2, 0xff, 0x003ab796);
+			apb_write_reg(2, 0xfe, 0x01b);
+			apb_write_reg(2, 0xff, 0x00368f15);
+			apb_write_reg(2, 0xfe, 0x01c);
+			apb_write_reg(2, 0xff, 0x00320e8a);
+			apb_write_reg(2, 0xfe, 0x01d);
+			apb_write_reg(2, 0xff, 0x002d25f4);
+			apb_write_reg(2, 0xfe, 0x01e);
+			apb_write_reg(2, 0xff, 0x0027ad4f);
+			apb_write_reg(2, 0xfe, 0x01f);
+			apb_write_reg(2, 0xff, 0x00219496);
+			apb_write_reg(2, 0xfe, 0x020);
+			apb_write_reg(2, 0xff, 0x000003c9);
+		}
+	} else {
+		/* 20.7 MHz Set ACF */
+		if (bandwidth == 0) {
+			/*8M Hz */
+			apb_write_reg(2, 0x2c, 0x318);  /* ACF_STAGE1_A1 */
+			apb_write_reg(2, 0x2d, 0x03E);  /* ACF_STAGE1_A2 */
+			apb_write_reg(2, 0x2e, 0x1AE);  /* ACF_STAGE1_B1 */
+			apb_write_reg(2, 0x2f, 0x00E);  /* ACF_STAGE1_GAIN */
+			apb_write_reg(2, 0x30, 0x326);  /* ACF_STAGE2_A1 */
+			apb_write_reg(2, 0x31, 0x074);  /* ACF_STAGE2_A2 */
+			apb_write_reg(2, 0x32, 0x074);  /* ACF_STAGE2_B1 */
+			apb_write_reg(2, 0x33, 0x06F);  /* ACF_STAGE2_GAIN */
+			apb_write_reg(2, 0x34, 0x336);  /* ACF_STAGE3_A1 */
+			apb_write_reg(2, 0x35, 0x0B1);  /* ACF_STAGE3_A2 */
+			apb_write_reg(2, 0x36, 0x3C9);  /* ACF_STAGE3_B1 */
+			apb_write_reg(2, 0x37, 0x008);  /* ACF_STAGE3_GAIN */
+			apb_write_reg(2, 0x38, 0x33F);  /* ACF_STAGE4_A1 */
+			apb_write_reg(2, 0x39, 0x0DC);  /* ACF_STAGE4_A2 */
+			apb_write_reg(2, 0x3a, 0x384);  /* ACF_STAGE4_B1 */
+			apb_write_reg(2, 0x3b, 0x05A);  /* ACF_STAGE4_GAIN */
+			apb_write_reg(2, 0x3c, 0x340);  /* ACF_STAGE5_A1 */
+			apb_write_reg(2, 0x3d, 0x0F6);  /* ACF_STAGE5_A2 */
+			apb_write_reg(2, 0x3e, 0x36D);  /* ACF_STAGE5_B1 */
+			apb_write_reg(2, 0x3f, 0x04B);  /* ACF_STAGE5_GAIN */
+
+			apb_write_reg(2, 0xfe, 0x000);
+			apb_write_reg(2, 0xff, 0x003f37ff);
+			apb_write_reg(2, 0xfe, 0x001);
+			apb_write_reg(2, 0xff, 0x003d97cc);
+			apb_write_reg(2, 0xfe, 0x002);
+			apb_write_reg(2, 0xff, 0x003bf798);
+			apb_write_reg(2, 0xfe, 0x003);
+			apb_write_reg(2, 0xff, 0x003a4f64);
+			apb_write_reg(2, 0xfe, 0x004);
+			apb_write_reg(2, 0xff, 0x0038a72f);
+			apb_write_reg(2, 0xfe, 0x005);
+			apb_write_reg(2, 0xff, 0x0036f6f9);
+			apb_write_reg(2, 0xfe, 0x006);
+			apb_write_reg(2, 0xff, 0x003546c3);
+			apb_write_reg(2, 0xfe, 0x007);
+			apb_write_reg(2, 0xff, 0x0033868c);
+			apb_write_reg(2, 0xfe, 0x008);
+			apb_write_reg(2, 0xff, 0x0031be54);
+			apb_write_reg(2, 0xfe, 0x009);
+			apb_write_reg(2, 0xff, 0x002fe61a);
+			apb_write_reg(2, 0xfe, 0x00a);
+			apb_write_reg(2, 0xff, 0x002e05df);
+			apb_write_reg(2, 0xfe, 0x00b);
+			apb_write_reg(2, 0xff, 0x002c15a2);
+			apb_write_reg(2, 0xfe, 0x00c);
+			apb_write_reg(2, 0xff, 0x002a1562);
+			apb_write_reg(2, 0xfe, 0x00d);
+			apb_write_reg(2, 0xff, 0x0027f520);
+			apb_write_reg(2, 0xfe, 0x00e);
+			apb_write_reg(2, 0xff, 0x0025c4dc);
+			apb_write_reg(2, 0xfe, 0x00f);
+			apb_write_reg(2, 0xff, 0x00236c93);
+			apb_write_reg(2, 0xfe, 0x010);
+			apb_write_reg(2, 0xff, 0x0020f446);
+			apb_write_reg(2, 0xfe, 0x011);
+			apb_write_reg(2, 0xff, 0x001e4bf4);
+			apb_write_reg(2, 0xfe, 0x012);
+			apb_write_reg(2, 0xff, 0x001b739d);
+			apb_write_reg(2, 0xfe, 0x013);
+			apb_write_reg(2, 0xff, 0x00185b3d);
+			apb_write_reg(2, 0xfe, 0x014);
+			apb_write_reg(2, 0xff, 0x0014ead5);
+			apb_write_reg(2, 0xfe, 0x015);
+			apb_write_reg(2, 0xff, 0x00111a62);
+			apb_write_reg(2, 0xfe, 0x016);
+			apb_write_reg(2, 0xff, 0x000cb9df);
+			apb_write_reg(2, 0xfe, 0x017);
+			apb_write_reg(2, 0xff, 0x00079148);
+			apb_write_reg(2, 0xfe, 0x018);
+			apb_write_reg(2, 0xff, 0x00030093);
+			apb_write_reg(2, 0xfe, 0x019);
+			apb_write_reg(2, 0xff, 0x003f802a);
+			apb_write_reg(2, 0xfe, 0x01a);
+			apb_write_reg(2, 0xff, 0x003b77b2);
+			apb_write_reg(2, 0xfe, 0x01b);
+			apb_write_reg(2, 0xff, 0x0036a725);
+			apb_write_reg(2, 0xfe, 0x01c);
+			apb_write_reg(2, 0xff, 0x0030ae7b);
+			apb_write_reg(2, 0xfe, 0x01d);
+			apb_write_reg(2, 0xff, 0x00285d9f);
+			apb_write_reg(2, 0xfe, 0x01e);
+			apb_write_reg(2, 0xff, 0x001abc46);
+			apb_write_reg(2, 0xfe, 0x01f);
+			apb_write_reg(2, 0xff, 0x000f8a85);
+			apb_write_reg(2, 0xfe, 0x020);
+			apb_write_reg(2, 0xff, 0x00000187);
+		} else if (bandwidth == 1) {
+			apb_write_reg(2, 0x2c, 0x2F9);  /* ACF_STAGE1_A1 */
+			apb_write_reg(2, 0x2d, 0x04C);  /* ACF_STAGE1_A2 */
+			apb_write_reg(2, 0x2e, 0x18E);  /* ACF_STAGE1_B1 */
+			apb_write_reg(2, 0x2f, 0x00E);  /* ACF_STAGE1_GAIN */
+			apb_write_reg(2, 0x30, 0x2FD);  /* ACF_STAGE2_A1 */
+			apb_write_reg(2, 0x31, 0x07F);  /* ACF_STAGE2_A2 */
+			apb_write_reg(2, 0x32, 0x01A);  /* ACF_STAGE2_B1 */
+			apb_write_reg(2, 0x33, 0x06D);  /* ACF_STAGE2_GAIN */
+			apb_write_reg(2, 0x34, 0x300);  /* ACF_STAGE3_A1 */
+			apb_write_reg(2, 0x35, 0x0B8);  /* ACF_STAGE3_A2 */
+			apb_write_reg(2, 0x36, 0x372);  /* ACF_STAGE3_B1 */
+			apb_write_reg(2, 0x37, 0x05F);  /* ACF_STAGE3_GAIN */
+			apb_write_reg(2, 0x38, 0x301);  /* ACF_STAGE4_A1 */
+			apb_write_reg(2, 0x39, 0x0DF);  /* ACF_STAGE4_A2 */
+			apb_write_reg(2, 0x3a, 0x335);  /* ACF_STAGE4_B1 */
+			apb_write_reg(2, 0x3b, 0x05A);  /* ACF_STAGE4_GAIN */
+			apb_write_reg(2, 0x3c, 0x2FE);  /* ACF_STAGE5_A1 */
+			apb_write_reg(2, 0x3d, 0x0F7);  /* ACF_STAGE5_A2 */
+			apb_write_reg(2, 0x3e, 0x320);  /* ACF_STAGE5_B1 */
+			apb_write_reg(2, 0x3f, 0x04B);  /* ACF_STAGE5_GAIN */
+
+			apb_write_reg(2, 0xfe, 0x000);
+			apb_write_reg(2, 0xff, 0x003f37ff);
+			apb_write_reg(2, 0xfe, 0x001);
+			apb_write_reg(2, 0xff, 0x003d8fcc);
+			apb_write_reg(2, 0xfe, 0x002);
+			apb_write_reg(2, 0xff, 0x003bef97);
+			apb_write_reg(2, 0xfe, 0x003);
+			apb_write_reg(2, 0xff, 0x003a4762);
+			apb_write_reg(2, 0xfe, 0x004);
+			apb_write_reg(2, 0xff, 0x0038972d);
+			apb_write_reg(2, 0xfe, 0x005);
+			apb_write_reg(2, 0xff, 0x0036e6f7);
+			apb_write_reg(2, 0xfe, 0x006);
+			apb_write_reg(2, 0xff, 0x00352ec1);
+			apb_write_reg(2, 0xfe, 0x007);
+			apb_write_reg(2, 0xff, 0x00336e89);
+			apb_write_reg(2, 0xfe, 0x008);
+			apb_write_reg(2, 0xff, 0x00319e50);
+			apb_write_reg(2, 0xfe, 0x009);
+			apb_write_reg(2, 0xff, 0x002fce16);
+			apb_write_reg(2, 0xfe, 0x00a);
+			apb_write_reg(2, 0xff, 0x002de5db);
+			apb_write_reg(2, 0xfe, 0x00b);
+			apb_write_reg(2, 0xff, 0x002bf59d);
+			apb_write_reg(2, 0xfe, 0x00c);
+			apb_write_reg(2, 0xff, 0x0029ed5e);
+			apb_write_reg(2, 0xfe, 0x00d);
+			apb_write_reg(2, 0xff, 0x0027d51c);
+			apb_write_reg(2, 0xfe, 0x00e);
+			apb_write_reg(2, 0xff, 0x00259cd7);
+			apb_write_reg(2, 0xfe, 0x00f);
+			apb_write_reg(2, 0xff, 0x0023448e);
+			apb_write_reg(2, 0xfe, 0x010);
+			apb_write_reg(2, 0xff, 0x0020cc41);
+			apb_write_reg(2, 0xfe, 0x011);
+			apb_write_reg(2, 0xff, 0x001e23ef);
+			apb_write_reg(2, 0xfe, 0x012);
+			apb_write_reg(2, 0xff, 0x001b4b98);
+			apb_write_reg(2, 0xfe, 0x013);
+			apb_write_reg(2, 0xff, 0x00183339);
+			apb_write_reg(2, 0xfe, 0x014);
+			apb_write_reg(2, 0xff, 0x0014cad1);
+			apb_write_reg(2, 0xfe, 0x015);
+			apb_write_reg(2, 0xff, 0x0010fa5e);
+			apb_write_reg(2, 0xfe, 0x016);
+			apb_write_reg(2, 0xff, 0x000c99dc);
+			apb_write_reg(2, 0xfe, 0x017);
+			apb_write_reg(2, 0xff, 0x00078145);
+			apb_write_reg(2, 0xfe, 0x018);
+			apb_write_reg(2, 0xff, 0x0002f892);
+			apb_write_reg(2, 0xfe, 0x019);
+			apb_write_reg(2, 0xff, 0x003f802a);
+			apb_write_reg(2, 0xfe, 0x01a);
+			apb_write_reg(2, 0xff, 0x003b8fb3);
+			apb_write_reg(2, 0xfe, 0x01b);
+			apb_write_reg(2, 0xff, 0x0036d729);
+			apb_write_reg(2, 0xfe, 0x01c);
+			apb_write_reg(2, 0xff, 0x00310682);
+			apb_write_reg(2, 0xfe, 0x01d);
+			apb_write_reg(2, 0xff, 0x00290dae);
+			apb_write_reg(2, 0xfe, 0x01e);
+			apb_write_reg(2, 0xff, 0x001c0c67);
+			apb_write_reg(2, 0xfe, 0x01f);
+			apb_write_reg(2, 0xff, 0x0010a2ad);
+			apb_write_reg(2, 0xfe, 0x020);
+			apb_write_reg(2, 0xff, 0x000001a8);
+		} else if (bandwidth == 2) {
+			/* 6MHz */
+			apb_write_reg(2, 0x2c, 0x2D9);  /* ACF_STAGE1_A1 */
+			apb_write_reg(2, 0x2d, 0x05C);  /* ACF_STAGE1_A2 */
+			apb_write_reg(2, 0x2e, 0x161);  /* ACF_STAGE1_B1 */
+			apb_write_reg(2, 0x2f, 0x00E);  /* ACF_STAGE1_GAIN */
+			apb_write_reg(2, 0x30, 0x2D4);  /* ACF_STAGE2_A1 */
+			apb_write_reg(2, 0x31, 0x08B);  /* ACF_STAGE2_A2 */
+			apb_write_reg(2, 0x32, 0x3B8);  /* ACF_STAGE2_B1 */
+			apb_write_reg(2, 0x33, 0x06B);  /* ACF_STAGE2_GAIN */
+			apb_write_reg(2, 0x34, 0x2CD);  /* ACF_STAGE3_A1 */
+			apb_write_reg(2, 0x35, 0x0C0);  /* ACF_STAGE3_A2 */
+			apb_write_reg(2, 0x36, 0x31E);  /* ACF_STAGE3_B1 */
+			apb_write_reg(2, 0x37, 0x05F);  /* ACF_STAGE3_GAIN */
+			apb_write_reg(2, 0x38, 0x2C7);  /* ACF_STAGE4_A1 */
+			apb_write_reg(2, 0x39, 0x0E3);  /* ACF_STAGE4_A2 */
+			apb_write_reg(2, 0x3a, 0x2EB);  /* ACF_STAGE4_B1 */
+			apb_write_reg(2, 0x3b, 0x05A);  /* ACF_STAGE4_GAIN */
+			apb_write_reg(2, 0x3c, 0x2C1);  /* ACF_STAGE5_A1 */
+			apb_write_reg(2, 0x3d, 0x0F8);  /* ACF_STAGE5_A2 */
+			apb_write_reg(2, 0x3e, 0x2DA);  /* ACF_STAGE5_B1 */
+			apb_write_reg(2, 0x3f, 0x04B);  /* ACF_STAGE5_GAIN */
+			apb_write_reg(2, 0xfe, 0x000);
+			apb_write_reg(2, 0xff, 0x003f2fff);
+			apb_write_reg(2, 0xfe, 0x001);
+			apb_write_reg(2, 0xff, 0x003d87cb);
+			apb_write_reg(2, 0xfe, 0x002);
+			apb_write_reg(2, 0xff, 0x003bdf96);
+			apb_write_reg(2, 0xfe, 0x003);
+			apb_write_reg(2, 0xff, 0x003a2f60);
+			apb_write_reg(2, 0xfe, 0x004);
+			apb_write_reg(2, 0xff, 0x00387f2a);
+			apb_write_reg(2, 0xfe, 0x005);
+			apb_write_reg(2, 0xff, 0x0036c6f4);
+			apb_write_reg(2, 0xfe, 0x006);
+			apb_write_reg(2, 0xff, 0x00350ebd);
+			apb_write_reg(2, 0xfe, 0x007);
+			apb_write_reg(2, 0xff, 0x00334684);
+			apb_write_reg(2, 0xfe, 0x008);
+			apb_write_reg(2, 0xff, 0x0031764b);
+			apb_write_reg(2, 0xfe, 0x009);
+			apb_write_reg(2, 0xff, 0x002f9e11);
+			apb_write_reg(2, 0xfe, 0x00a);
+			apb_write_reg(2, 0xff, 0x002db5d4);
+			apb_write_reg(2, 0xfe, 0x00b);
+			apb_write_reg(2, 0xff, 0x002bbd97);
+			apb_write_reg(2, 0xfe, 0x00c);
+			apb_write_reg(2, 0xff, 0x0029b557);
+			apb_write_reg(2, 0xfe, 0x00d);
+			apb_write_reg(2, 0xff, 0x00279515);
+			apb_write_reg(2, 0xfe, 0x00e);
+			apb_write_reg(2, 0xff, 0x00255ccf);
+			apb_write_reg(2, 0xfe, 0x00f);
+			apb_write_reg(2, 0xff, 0x00230c87);
+			apb_write_reg(2, 0xfe, 0x010);
+			apb_write_reg(2, 0xff, 0x0020943a);
+			apb_write_reg(2, 0xfe, 0x011);
+			apb_write_reg(2, 0xff, 0x001debe8);
+			apb_write_reg(2, 0xfe, 0x012);
+			apb_write_reg(2, 0xff, 0x001b1b91);
+			apb_write_reg(2, 0xfe, 0x013);
+			apb_write_reg(2, 0xff, 0x00180b33);
+			apb_write_reg(2, 0xfe, 0x014);
+			apb_write_reg(2, 0xff, 0x0014aacc);
+			apb_write_reg(2, 0xfe, 0x015);
+			apb_write_reg(2, 0xff, 0x0010e25a);
+			apb_write_reg(2, 0xfe, 0x016);
+			apb_write_reg(2, 0xff, 0x000c91da);
+			apb_write_reg(2, 0xfe, 0x017);
+			apb_write_reg(2, 0xff, 0x00078945);
+			apb_write_reg(2, 0xfe, 0x018);
+			apb_write_reg(2, 0xff, 0x00031895);
+			apb_write_reg(2, 0xfe, 0x019);
+			apb_write_reg(2, 0xff, 0x003fa82e);
+			apb_write_reg(2, 0xfe, 0x01a);
+			apb_write_reg(2, 0xff, 0x003bbfb8);
+			apb_write_reg(2, 0xfe, 0x01b);
+			apb_write_reg(2, 0xff, 0x00371730);
+			apb_write_reg(2, 0xfe, 0x01c);
+			apb_write_reg(2, 0xff, 0x0031668c);
+			apb_write_reg(2, 0xfe, 0x01d);
+			apb_write_reg(2, 0xff, 0x00299dbc);
+			apb_write_reg(2, 0xfe, 0x01e);
+			apb_write_reg(2, 0xff, 0x001d1480);
+			apb_write_reg(2, 0xfe, 0x01f);
+			apb_write_reg(2, 0xff, 0x00119acf);
+			apb_write_reg(2, 0xfe, 0x020);
+			apb_write_reg(2, 0xff, 0x000001c4);
+		} else {
+			apb_write_reg(2, 0x2c, 0x2B9);  /* ACF_STAGE1_A1 */
+			apb_write_reg(2, 0x2d, 0x06E);  /* ACF_STAGE1_A2 */
+			apb_write_reg(2, 0x2e, 0x11E);  /* ACF_STAGE1_B1 */
+			apb_write_reg(2, 0x2f, 0x01E);  /* ACF_STAGE1_GAIN */
+			apb_write_reg(2, 0x30, 0x2AB);  /* ACF_STAGE2_A1 */
+			apb_write_reg(2, 0x31, 0x099);  /* ACF_STAGE2_A2 */
+			apb_write_reg(2, 0x32, 0x351);  /* ACF_STAGE2_B1 */
+			apb_write_reg(2, 0x33, 0x06B);  /* ACF_STAGE2_GAIN */
+			apb_write_reg(2, 0x34, 0x29D);  /* ACF_STAGE3_A1 */
+			apb_write_reg(2, 0x35, 0x0C8);  /* ACF_STAGE3_A2 */
+			apb_write_reg(2, 0x36, 0x2D0);  /* ACF_STAGE3_B1 */
+			apb_write_reg(2, 0x37, 0x05F);  /* ACF_STAGE3_GAIN */
+			apb_write_reg(2, 0x38, 0x292);  /* ACF_STAGE4_A1 */
+			apb_write_reg(2, 0x39, 0x0E7);  /* ACF_STAGE4_A2 */
+			apb_write_reg(2, 0x3a, 0x2A8);  /* ACF_STAGE4_B1 */
+			apb_write_reg(2, 0x3b, 0x05A);  /* ACF_STAGE4_GAIN */
+			apb_write_reg(2, 0x3c, 0x28A);  /* ACF_STAGE5_A1 */
+			apb_write_reg(2, 0x3d, 0x0F9);  /* ACF_STAGE5_A2 */
+			apb_write_reg(2, 0x3e, 0x29B);  /* ACF_STAGE5_B1 */
+			apb_write_reg(2, 0x3f, 0x04B);  /* ACF_STAGE5_GAIN */
+
+			apb_write_reg(2, 0xfe, 0x000);
+			apb_write_reg(2, 0xff, 0x003f2fff);
+			apb_write_reg(2, 0xfe, 0x001);
+			apb_write_reg(2, 0xff, 0x003d7fca);
+			apb_write_reg(2, 0xfe, 0x002);
+			apb_write_reg(2, 0xff, 0x003bcf94);
+			apb_write_reg(2, 0xfe, 0x003);
+			apb_write_reg(2, 0xff, 0x003a1f5e);
+			apb_write_reg(2, 0xfe, 0x004);
+			apb_write_reg(2, 0xff, 0x00386727);
+			apb_write_reg(2, 0xfe, 0x005);
+			apb_write_reg(2, 0xff, 0x0036a6f0);
+			apb_write_reg(2, 0xfe, 0x006);
+			apb_write_reg(2, 0xff, 0x0034e6b8);
+			apb_write_reg(2, 0xfe, 0x007);
+			apb_write_reg(2, 0xff, 0x0033167f);
+			apb_write_reg(2, 0xfe, 0x008);
+			apb_write_reg(2, 0xff, 0x00314645);
+			apb_write_reg(2, 0xfe, 0x009);
+			apb_write_reg(2, 0xff, 0x002f660a);
+			apb_write_reg(2, 0xfe, 0x00a);
+			apb_write_reg(2, 0xff, 0x002d75cd);
+			apb_write_reg(2, 0xfe, 0x00b);
+			apb_write_reg(2, 0xff, 0x002b758e);
+			apb_write_reg(2, 0xfe, 0x00c);
+			apb_write_reg(2, 0xff, 0x0029654e);
+			apb_write_reg(2, 0xfe, 0x00d);
+			apb_write_reg(2, 0xff, 0x0027450a);
+			apb_write_reg(2, 0xfe, 0x00e);
+			apb_write_reg(2, 0xff, 0x002504c4);
+			apb_write_reg(2, 0xfe, 0x00f);
+			apb_write_reg(2, 0xff, 0x0022a47b);
+			apb_write_reg(2, 0xfe, 0x010);
+			apb_write_reg(2, 0xff, 0x0020242d);
+			apb_write_reg(2, 0xfe, 0x011);
+			apb_write_reg(2, 0xff, 0x001d7bdb);
+			apb_write_reg(2, 0xfe, 0x012);
+			apb_write_reg(2, 0xff, 0x001aa383);
+			apb_write_reg(2, 0xfe, 0x013);
+			apb_write_reg(2, 0xff, 0x00178b24);
+			apb_write_reg(2, 0xfe, 0x014);
+			apb_write_reg(2, 0xff, 0x00142abd);
+			apb_write_reg(2, 0xfe, 0x015);
+			apb_write_reg(2, 0xff, 0x0010624a);
+			apb_write_reg(2, 0xfe, 0x016);
+			apb_write_reg(2, 0xff, 0x000c11ca);
+			apb_write_reg(2, 0xfe, 0x017);
+			apb_write_reg(2, 0xff, 0x00070935);
+			apb_write_reg(2, 0xfe, 0x018);
+			apb_write_reg(2, 0xff, 0x00029885);
+			apb_write_reg(2, 0xfe, 0x019);
+			apb_write_reg(2, 0xff, 0x003f281e);
+			apb_write_reg(2, 0xfe, 0x01a);
+			apb_write_reg(2, 0xff, 0x003b3fa9);
+			apb_write_reg(2, 0xfe, 0x01b);
+			apb_write_reg(2, 0xff, 0x00369720);
+			apb_write_reg(2, 0xfe, 0x01c);
+			apb_write_reg(2, 0xff, 0x0030ce7b);
+			apb_write_reg(2, 0xfe, 0x01d);
+			apb_write_reg(2, 0xff, 0x0028dda7);
+			apb_write_reg(2, 0xfe, 0x01e);
+			apb_write_reg(2, 0xff, 0x001c6464);
+			apb_write_reg(2, 0xfe, 0x01f);
+			apb_write_reg(2, 0xff, 0x0011b2c7);
+			apb_write_reg(2, 0xfe, 0x020);
+			apb_write_reg(2, 0xff, 0x000001cb);
+		}
+	}
+}
+
+static void dvbt_reg_initial(struct aml_demod_sta *demod_sta)
+{
+	u32 clk_freq;
+	u32 adc_freq;
+	u8 ch_mode;
+	u8 agc_mode;
+	u32 ch_freq;
+	u16 ch_if;
+	u16 ch_bw;
+	u16 symb_rate;
+
+	u8 bw;
+	u8 sr;
+	u8 ifreq;
+	u32 tmp;
+
+	clk_freq = demod_sta->clk_freq; /* kHz */
+	adc_freq = demod_sta->adc_freq; /* kHz */
+	ch_mode = demod_sta->ch_mode;
+	agc_mode = demod_sta->agc_mode;
+	ch_freq = demod_sta->ch_freq;           /* kHz */
+	ch_if = demod_sta->ch_if;               /* kHz */
+	ch_bw = demod_sta->ch_bw;               /* kHz */
+	symb_rate = demod_sta->symb_rate;       /* k/sec */
+
+	bw = 8 - ch_bw / 1000;
+	sr = adc_freq > 40000 ? 3 : adc_freq > 24000 ? 2 :
+	     adc_freq > 20770 ? 1 : 0;
+	ifreq = ch_if > 35000 ? 0 : 1;
+
+	/*//////////////////////////////////// */
+	/* bw == 0 : 8M */
+	/*       1 : 7M */
+	/*       2 : 6M */
+	/*       3 : 5M */
+	/* sr == 0 : 20.7M */
+	/*       1 : 20.8333M */
+	/*       2 : 28.5714M */
+	/*       3 : 45M */
+	/* ifreq == 0: 36.13MHz */
+	/*          1: 4.57MHz */
+	/* agc_mode == 0: single AGC */
+	/*             1: dual AGC */
+	/*//////////////////////////////////// */
+	apb_write_reg(2, 0x02, 0x00800000);
+	/* SW reset bit[23] ; write anything to zero */
+	apb_write_reg(2, 0x00, 0x00000000);
+
+	switch (sr) {
+	case 0:
+		apb_write_reg(2, 0x08, 0x00002966);
+		break;
+	case 1:
+		apb_write_reg(2, 0x08, 0x00002999);
+		break;
+	case 2:
+		apb_write_reg(2, 0x08, 0x00003924);
+		break;
+	case 3:
+		apb_write_reg(2, 0x08, 0x00005a00);
+		break;          /*sample_rate   /*45M */
+	default:
+		break;
+	}
+
+	apb_write_reg(2, 0x0d, 0x00000000);
+	apb_write_reg(2, 0x0e, 0x00000000);
+	dvbt_enable_irq(8);
+
+	apb_write_reg(2, 0x11, 0x00100002);     /* FSM [15:0] TIMER_FEC_LOST */
+	apb_write_reg(2, 0x12, 0x02100201);     /* FSM */
+	apb_write_reg(2, 0x14, 0xe81c4ff6);     /* AGC_TARGET 0xf0121385 */
+	apb_write_reg(2, 0x15, 0x02050ca6);     /* AGC_CTRL */
+
+	switch (sr) {
+	case 0:
+		apb_write_reg(2, 0x15, apb_read_reg(2, 0x15) | (0x5b << 12));
+		break;
+	case 1:
+		apb_write_reg(2, 0x15, apb_read_reg(2, 0x15) | (0x5b << 12));
+		break;
+	case 2:
+		apb_write_reg(2, 0x15, apb_read_reg(2, 0x15) | (0x7b << 12));
+		break;
+	case 3:
+		apb_write_reg(2, 0x15, apb_read_reg(2, 0x15) | (0xc2 << 12));
+		break;          /* sample_rate /*45M */
+	default:
+		break;
+	}
+
+	if (agc_mode == 0)
+		apb_write_reg(2, 0x16, 0x67f80);        /* AGC_IFGAIN_CTRL */
+	else if (agc_mode == 1)
+		apb_write_reg(2, 0x16, 0x07f80);        /* AGC_IFGAIN_CTRL */
+
+	apb_write_reg(2, 0x17, 0x07f80);                /* AGC_RFGAIN_CTRL */
+	apb_write_reg(2, 0x18, 0x00000000);             /* AGC_IFGAIN_ACCUM */
+	apb_write_reg(2, 0x19, 0x00000000);             /* AGC_RFGAIN_ACCUM */
+
+	if (ifreq == 0) {
+		switch (sr) {
+		case 0:
+			apb_write_reg(2, 0x20, 0x00002096);
+			break;
+		/* DDC NORM_PHASE 36.13M IF For 20.7M sample rate */
+		case 1:
+			apb_write_reg(2, 0x20, 0x000021a9);
+			break;
+		/* DDC NORM_PHASE 36.13M IF For 20.8333M sample rate*/
+		case 2:
+			apb_write_reg(2, 0x20, 0x000021dc);
+			break;
+		/* DDC NORM_PHASE 36.13M IF For 28.57142M sample rate*/
+		case 3:
+			apb_write_reg(2, 0x20, 0x000066e2);
+			break;
+		/* DDC NORM_PHASE    36.13M IF  For 45M sample rate */
+		default:
+			break;
+		}
+	} else if (ifreq == 1) {
+		switch (sr) {
+		case 0:
+			apb_write_reg(2, 0x20, 0x00001c42);
+			break;
+		/* DDC NORM_PHASE 4.57M IF For 20.7M sample rate */
+		case 1:
+			apb_write_reg(2, 0x20, 0x00001c1f);
+			break;
+		/* DDC NORM_PHASE 4.57M IF For 20.8333M sample rate */
+		case 2:
+			apb_write_reg(2, 0x20, 0x00001479);
+			break;
+		/* DDC NORM_PHASE 4.57M IF For 28.57142M sample rate*/
+		case 3:
+			apb_write_reg(2, 0x20, 0x0000d00);
+			break;
+		/* DDC NORM_PHASE    4.57M IF  For 45M sample rate */
+		default:
+			break;
+		}
+	}
+	*/tmp = ch_if * (1 << 15)/adc_freq;
+	tmp &= 0x3fff;
+	apb_write_reg(2, 0x20, tmp);
+	if (demod_sta->debug)
+		dprintk("IF: %d kHz  ADC: %d kHz  DDC: %04x\n", ch_if, adc_freq,
+			tmp);
+
+	apb_write_reg(2, 0x21, 0x001ff000);     /* DDC CS_FCFO_ADJ_CTRL */
+	apb_write_reg(2, 0x22, 0x00000000);     /* DDC ICFO_ADJ_CTRL */
+	apb_write_reg(2, 0x23, 0x00004000);     /* DDC TRACK_FCFO_ADJ_CTRL */
+	apb_write_reg(2, 0x27, 0x00a98200);
+	/*[23] agc state mode [22:19] icfo_time_limit ;[18:15] tps_time_limit ;
+	 * [14:4] cs_cfo_thres ;  [3:0] fsm_state_d;
+	 */
+	/*            1              010,1                   001,1
+	 *      000,0010,0000,                xxxx
+	 */
+	apb_write_reg(2, 0x28, 0x04028032);
+	/* [31:24] cs_Q_thres; [23:13] sfo_thres;  FSM [12:0] fcfo_thres;; */
+	/*      0000,0100,        0000,0010,100          0,0000,0011,0010 */
+	apb_write_reg(2, 0x29, 0x0051117F);
+	/*apb_write_reg(2, 0x29, 0x00010f7F); */
+	/*  [18:16] fec_rs_sh_ctrl ;[15:9] fsm_total_timer;
+	 * [8:6] modeDet_time_limit; FSM [5:0] sfo_time_limit; ;
+	 */
+	/*     01,     ()   0000,111 1,01                     11,1111 */
+
+	/* SRC NORM_INRATE */
+	switch (bw) {
+	case 0:
+		tmp = (1 << 14) * adc_freq / 125 / 8 * 7;
+		break;
+	case 1:
+		tmp = (1 << 14) * adc_freq / 125;
+		break;
+	case 2:
+		tmp = (1 << 14) * adc_freq / 125 / 6 * 7;
+		break;
+	case 3:
+		tmp = (1 << 14) * adc_freq / 125 / 5 * 7;
+		break;
+	default:
+		tmp = (1 << 14) * adc_freq / 125 / 8 * 7;
+		break;
+	}
+
+	apb_write_reg(2, 0x44, tmp & 0x7fffff);
+
+	apb_write_reg(2, 0x45, 0x00000000);     /* SRC SRC_PHASE_INI */
+	apb_write_reg(2, 0x46, 0x02004000);
+	/* SRC SFO_ADJ_CTRL SFO limit 0x100!! */
+	apb_write_reg(2, 0x48, 0xc0287);        /* DAGC_CTRL */
+	apb_write_reg(2, 0x49, 0x00000005);     /* DAGC_CTRL1 */
+	apb_write_reg(2, 0x4c, 0x00000bbf);     /* CCI_RP */
+	apb_write_reg(2, 0x4d, 0x00000376);     /* CCI_RPSQ */
+	apb_write_reg(2, 0x4e, 0x00202109);     /* CCI_CTRL */
+	apb_write_reg(2, 0x52, 0x00000000);     /* CCI_NOTCH1_A2 */
+	apb_write_reg(2, 0x53, 0x00000000);     /* CCI_NOTCH1_B1 */
+	apb_write_reg(2, 0x54, 0x00c00000);     /* CCI_NOTCH2_A1 */
+	apb_write_reg(2, 0x55, 0x00000000);     /* CCI_NOTCH2_A2 */
+	apb_write_reg(2, 0x56, 0x00000000);     /* CCI_NOTCH2_B1 */
+	apb_write_reg(2, 0x57, 0x00000000);     /* CCI_NOTCH2_B1 */
+	apb_write_reg(2, 0x58, 0x00000886);     /* MODE_DETECT_CTRL */
+	apb_write_reg(2, 0x5c, 0x00001011);     /* ICFO_EST_CTRL */
+	apb_write_reg(2, 0x5f, 0x00010503);     /* TPS_FCFO_CTRL */
+	apb_write_reg(2, 0x61, 0x00000003);     /* DE_PN_CTRL */
+	apb_write_reg(2, 0x61, apb_read_reg(2, 0x61) | (1 << 2));
+	/* DE_PN_CTRL SP sync close , Use TPS only ; */
+	apb_write_reg(2, 0x68, 0x004060c0);     /* CHAN_EST_CTRL0 */
+	apb_write_reg(2, 0x68, apb_read_reg(2, 0x68) & ~(1 << 7));
+	/* SNR report filter; */
+	/*apb_write_reg(2, 0x68, apb_read_reg(2, 0x68) &~(1<<13));  //
+	 * Timing Adjust Shutdown;
+	 */
+	apb_write_reg(2, 0x69, 0x148c3812);     /* CHAN_EST_CTRL1 */
+	/*apb_write_reg(2, 0x69, apb_read_reg(2, 0x69) | (1<<10));  //
+	 * Disable FD data update
+	 */
+	/*apb_write_reg(2, 0x69, apb_read_reg(2, 0x69) | (1<<9));  //
+	 * set FD coeff
+	 */
+	/*apb_write_reg(2, 0x69, apb_read_reg(2, 0x69) | (1<<8));  //
+	 * set TD coeff
+	 */
+	apb_write_reg(2, 0x6a, 0x9101012d);     /* CHAN_EST_CTRL2 */
+	apb_write_reg(2, 0x6b, 0x00442211);     /* CHAN_EST_CTRL2 */
+	apb_write_reg(2, 0x6c, 0x01fc040a);     /* CHAN_EST_CTRL3 */
+	apb_write_reg(2, 0x6d, 0x0030303f);     /* SET SNR THRESHOLD */
+	apb_write_reg(2, 0x73, 0xffffffff);     /* CCI0_PILOT_UPDATE_CTRL */
+	apb_write_reg(2, 0x74, 0xffffffff);     /* CCI0_DATA_UPDATE_CTRL */
+	apb_write_reg(2, 0x75, 0xffffffff);     /* CCI1_PILOT_UPDATE_CTRL */
+	apb_write_reg(2, 0x76, 0xffffffff);     /* CCI1_DATA_UPDATE_CTRL */
+
+	/* Set ACF and ACFEQ coeffecient */
+	switch (sr) {
+	case 0:
+		set_ACF_coef(21, bw);
+		break;
+	case 1:
+		set_ACF_coef(21, bw);
+		break;
+	case 2:
+		set_ACF_coef(28, bw);
+		break;
+	case 3:
+		set_ACF_coef(45, bw);
+		break;
+	default:
+		break;
+	}
+
+	apb_write_reg(2, 0x78, 0x000001a2);
+	/* FEC_CTRL  parallel mode ; [27:24] is TS clk/valid/sync/error */
+	apb_write_reg(2, 0x7d, 0x0000009d);
+	apb_write_reg(2, 0xd6, 0x00000003);
+	apb_write_reg(2, 0xd7, 0x00000008);
+	apb_write_reg(2, 0xd8, 0x00000120);
+	apb_write_reg(2, 0xd9, 0x01010101);
+	apb_write_reg(2, 0x04, 0x00000000);
+	/* TPS Current, QPSK, none Hierarchy, HP, LP 1/2 */
+
+	tmp = (1 << 25) | ((bw & 3) << 20) | (1 << 16) | (1 << 1);
+	apb_write_reg(2, 0x02, tmp);
+	apb_write_reg(2, 0x03, (1 << 6));       /* Cordic parameter Calc */
+
+	udelay(1);
+
+	tmp = apb_read_reg(2, 0x02);
+	tmp |= (1 << 24) | 1;   /* FSM, Demod enable. */
+	apb_write_reg(2, 0x02, tmp);
+}
+
+int dvbt_set_ch(struct aml_demod_sta *demod_sta,
+		struct aml_demod_i2c *demod_i2c,
+		struct aml_demod_dvbt *demod_dvbt)
+{
+	int ret = 0;
+	u8 bw, sr, ifreq, agc_mode;
+	u32 ch_freq;
+
+	bw = demod_dvbt->bw;
+	sr = demod_dvbt->sr;
+	ifreq = demod_dvbt->ifreq;
+	agc_mode = demod_dvbt->agc_mode;
+	ch_freq = demod_dvbt->ch_freq;
+
+	/* Set registers */
+	/*//////////////////////////////////// */
+	/* bw == 0 : 8M */
+	/*       1 : 7M */
+	/*       2 : 6M */
+	/*       3 : 5M */
+	/* sr == 0 : 20.7M */
+	/*       1 : 20.8333M */
+	/*       2 : 28.5714M */
+	/*       3 : 45M */
+	/* ifreq == 0: 36.13MHz */
+	/*          1: 4.57MHz */
+	/* agc_mode == 0: single AGC */
+	/*             1: dual AGC */
+	/*//////////////////////////////////// */
+	if (bw > 3) {
+		dprintk("Error: Invalid Bandwidth option %d\n", bw);
+		bw = 0;
+		ret = -1;
+	}
+
+	if (sr > 3) {
+		dprintk("Error: Invalid Sampling Freq option %d\n", sr);
+		sr = 2;
+		ret = -1;
+	}
+
+	if (ifreq > 1) {
+		dprintk("Error: Invalid IFreq option %d\n", ifreq);
+		ifreq = 0;
+		ret = -1;
+	}
+
+	if (agc_mode > 3) {
+		dprintk("Error: Invalid AGC mode option %d\n", agc_mode);
+		agc_mode = 0;
+		ret = -1;
+	}
+	/* if (ret != 0) return ret; */
+
+	/* Set DVB-T */
+	(*DEMOD_REG0) |= 1;
+
+	demod_sta->dvb_mode = 1;
+	demod_sta->ch_mode = 0; /* TODO */
+	demod_sta->agc_mode = agc_mode;
+	demod_sta->ch_freq = ch_freq;
+	if (demod_i2c->tuner == 1)
+		demod_sta->ch_if = 36130;
+	else if (demod_i2c->tuner == 2)
+		demod_sta->ch_if = 4570;
+
+	demod_sta->ch_bw = (8 - bw) * 1000;
+	demod_sta->symb_rate = 0;       /* TODO */
+
+	/* Set Tuner */
+	if (ch_freq < 1000 || ch_freq > 900000) {
+		dprintk
+		(
+			"Error: Invalid Channel Freq option %d, Skip Set tuner\n",
+			ch_freq);
+		/*ch_freq = 474000; */
+		ret = -1;
+	} else {
+		/*  tuner_set_ch(demod_sta, demod_i2c); */
+	}
+
+	if ((ch_freq % 100) == 2)
+		dprintk("Input frequency is XXX002, Skip initial demod\n");
+	else
+		dvbt_reg_initial(demod_sta);
+
+	dvbt_enable_irq(7);     /* open symbolhead int */
+
+	tuner_type = demod_i2c->tuner;
+
+	return ret;
+}
+
+static int dvbt_get_ch_power(struct aml_demod_sta *demod_sta,
+			     struct aml_demod_i2c *demod_i2c)
+{
+	u32 ad_power;
+
+	ad_power =
+		agc_power_to_dbm((apb_read_reg(2, 0x1c) & 0x7ff),
+				 apb_read_reg(2, 0x1b) & 0x1ff, 0,
+				 demod_i2c->tuner);
+	return ad_power;
+}
+
+int dvbt_sfo(void)
+{
+	int sfo;
+
+	sfo = apb_read_reg(2, 0x47) & 0xfff;
+	sfo = (sfo > 0x7ff) ? (sfo - 0x1000) : sfo;
+	return sfo;
+}
+
+int dvbt_fcfo(void)
+{
+	int fcfo;
+
+	fcfo = (apb_read_reg(2, 0x26)) & 0xffffff;
+	fcfo = (fcfo > 0x7fffff) ? (fcfo - 0x1000000) : fcfo;
+	return fcfo;
+}
+
+static int dvbt_total_packet_error(void)
+{
+	return apb_read_reg(2, 0xbf);
+}
+
+static int dvbt_super_frame_counter(void)
+{
+	return apb_read_reg(2, 0xc0) & 0xfffff;
+}
+
+static int dvbt_packet_correct_in_sframe(void)
+{
+	return apb_read_reg(2, 0xc1) & 0xfffff;
+}
+
+/*static int dvbt_resync_counter(void)
+ * {return((apb_read_reg(2, 0xc0)>>20)&0xff);}
+ */
+static int dvbt_packets_per_sframe(void)
+{
+	u32 tmp;
+	int hier_mode;
+	int constel;
+	int hp_code_rate;
+	int lp_code_rate;
+	int hier_sel;
+	int code_rate;
+	int ret;
+
+	tmp = apb_read_reg(2, 0x06);
+	constel = tmp >> 13 & 3;
+	hier_mode = tmp >> 10 & 7;
+	hp_code_rate = tmp >> 7 & 7;
+	lp_code_rate = tmp >> 4 & 7;
+
+	if (hier_mode == 0) {
+		code_rate = hp_code_rate;
+	} else {
+		tmp = apb_read_reg(2, 0x78);
+		hier_sel = tmp >> 9 & 1;
+		if (hier_sel == 0) {
+			constel = 0;    /* QPSK; */
+			code_rate = hp_code_rate;
+		} else {
+			constel = constel == 2 ? 1 : 0;
+			code_rate = lp_code_rate;
+		}
+	}
+
+	switch (code_rate) {
+	case 0:
+		ret = (constel == 0) ? 1008 : (constel == 1) ? 2016 : 3024;
+		break;
+	case 1:
+		ret = (constel == 0) ? 1344 : (constel == 1) ? 2688 : 4032;
+		break;
+	case 2:
+		ret = (constel == 0) ? 1512 : (constel == 1) ? 3024 : 4536;
+		break;
+	case 3:
+		ret = (constel == 0) ? 1680 : (constel == 1) ? 3360 : 5040;
+		break;
+	case 4:
+		ret = (constel == 0) ? 1764 : (constel == 1) ? 3528 : 5292;
+		break;
+	default:
+		ret = (constel == 0) ? 1008 : (constel == 1) ? 2016 : 3024;
+		break;
+	}
+	return ret;
+}
+
+static int dvbt_get_per(void)
+{
+	int packets_per_sframe;
+	int error;
+	int per;
+
+	packets_per_sframe = dvbt_packets_per_sframe();
+	error = packets_per_sframe - dvbt_packet_correct_in_sframe();
+	per = 1000 * error / packets_per_sframe;
+
+	return per;
+}
+
+static void dvbt_set_test_bus(u8 sel)
+{
+	u32 tmp;
+
+	tmp = apb_read_reg(2, 0x7f);
+	tmp &= ~(0x1f);
+	tmp |= ((1 << 15) | (1 << 5) | (sel & 0x1f));
+	apb_write_reg(2, 0x7f, tmp);
+}
+
+/*
+ * void dvbt_get_test_out(u8 sel, u32 len, u32 *buf)
+ * {
+ *  int i;
+ *
+ *  dvbt_set_test_bus(sel);
+ *
+ *  for (i=0; i<len; i++) {
+ *      buf[i] = apb_read_reg(2, 0x13);
+ *  }
+ * }
+ */
+void dvbt_get_test_out(u8 sel, u32 len, u32 *buf)
+{
+	int i, cnt;
+
+	dvbt_set_test_bus(sel);
+
+	for (i = 0, cnt = 0; i < len - 4 && cnt < 1000000; i++) {
+		buf[i] = apb_read_reg(2, 0x13);
+		if ((buf[i] >> 10) & 0x1) {
+			buf[i++] = apb_read_reg(2, 0x13);
+			buf[i++] = apb_read_reg(2, 0x13);
+			buf[i++] = apb_read_reg(2, 0x13);
+			buf[i++] = apb_read_reg(2, 0x13);
+			buf[i++] = apb_read_reg(2, 0x13);
+			buf[i++] = apb_read_reg(2, 0x13);
+			buf[i++] = apb_read_reg(2, 0x13);
+			buf[i++] = apb_read_reg(2, 0x13);
+		} else {
+			i--;
+		}
+
+		cnt++;
+	}
+}
+
+static int dvbt_get_avg_per(void)
+{
+	int packets_per_sframe;
+	static int err_last;
+	static int err_now;
+	static int rsnum_now;
+	static int rsnum_last;
+	int per;
+
+	packets_per_sframe = dvbt_packets_per_sframe();
+	rsnum_last = rsnum_now;
+	rsnum_now = dvbt_super_frame_counter();
+	err_last = err_now;
+	err_now = dvbt_total_packet_error();
+	if (rsnum_now != rsnum_last)
+		per = 1000 * (err_now - err_last) /
+		      ((rsnum_now - rsnum_last) * packets_per_sframe);
+	else
+		per = 123;
+
+	return per;
+}
+
+int dvbt_status(struct aml_demod_sta *demod_sta,
+		struct aml_demod_i2c *demod_i2c,
+		struct aml_demod_sts *demod_sts)
+{
+	/* if parameters are needed to calc, pass the struct to func. */
+	/* all small funcs like read_snr() should be static. */
+
+	demod_sts->ch_snr = apb_read_reg(2, 0x0a);
+	demod_sts->ch_per = dvbt_get_per();
+	demod_sts->ch_pow = dvbt_get_ch_power(demod_sta, demod_i2c);
+	demod_sts->ch_ber = apb_read_reg(2, 0x0b);
+	demod_sts->ch_sts = apb_read_reg(2, 0);
+	demod_sts->dat0 = dvbt_get_avg_per();
+	demod_sts->dat1 = apb_read_reg(2, 0x06);
+	return 0;
+}
+
+static int dvbt_get_status(struct aml_demod_sta *demod_sta,
+			   struct aml_demod_i2c *demod_i2c)
+{
+	return apb_read_reg(2, 0x0) >> 12 & 1;
+}
+
+static int dvbt_ber(void);
+
+static int dvbt_get_ber(struct aml_demod_sta *demod_sta,
+			struct aml_demod_i2c *demod_i2c)
+{
+	return dvbt_ber();      /*unit: 1e-7 */
+}
+
+static int dvbt_get_snr(struct aml_demod_sta *demod_sta,
+			struct aml_demod_i2c *demod_i2c)
+{
+	return apb_read_reg(2, 0x0a) & 0x3ff;   /*dBm: bit0~bit2=decimal */
+}
+
+static int dvbt_get_strength(struct aml_demod_sta *demod_sta,
+			     struct aml_demod_i2c *demod_i2c)
+{
+	int dbm = dvbt_get_ch_power(demod_sta, demod_i2c);
+
+	return dbm;
+}
+
+static int dvbt_get_ucblocks(struct aml_demod_sta *demod_sta,
+			     struct aml_demod_i2c *demod_i2c)
+{
+	return dvbt_get_per();
+}
+
+struct demod_status_ops *dvbt_get_status_ops(void)
+{
+	static struct demod_status_ops ops = {
+		.get_status	= dvbt_get_status,
+		.get_ber	= dvbt_get_ber,
+		.get_snr	= dvbt_get_snr,
+		.get_strength	= dvbt_get_strength,
+		.get_ucblocks	= dvbt_get_ucblocks,
+	};
+
+	return &ops;
+}
+
+void dvbt_enable_irq(int dvbt_irq)
+{
+	/* clear status & enable irq */
+	(*OFDM_INT_STS) &= ~(1 << dvbt_irq);
+	(*OFDM_INT_EN) |= (1 << dvbt_irq);
+}
+
+void dvbt_disable_irq(int dvbt_irq)
+{
+	/* disable irq & clear status */
+	(*OFDM_INT_EN) &= ~(1 << dvbt_irq);
+	(*OFDM_INT_STS) &= ~(1 << dvbt_irq);
+}
+
+char *dvbt_irq_name[] = {
+	"PFS_FCFO",
+	"PFS_ICFO",
+	" CS_FCFO",
+	" PFS_SFO",
+	" PFS_TPS",
+	"      SP",
+	"     CCI",
+	"  Symbol",
+	" In_Sync",
+	"Out_Sync",
+	"FSM Stat"
+};
+
+void dvbt_isr(struct aml_demod_sta *demod_sta)
+{
+	u32 stat, mask;
+	int dvbt_irq;
+
+	stat = (*OFDM_INT_STS);
+	mask = (*OFDM_INT_EN);
+	stat &= mask;
+
+	for (dvbt_irq = 0; dvbt_irq < 11; dvbt_irq++) {
+		if (stat >> dvbt_irq & 1) {
+			if (demod_sta->debug)
+				dprintk("irq: aml_demod dvbt %2d %s %8x %8x\n",
+					dvbt_irq, dvbt_irq_name[dvbt_irq], stat,
+					mask);
+			/* dvbt_disable_irq(dvbt_irq); */
+		}
+	}
+	/* clear status */
+	(*OFDM_INT_STS) = 0;
+}
+
+static int demod_monitor_ave(void);
+int dvbt_isr_islock(void)
+{
+#define IN_SYNC_MASK (0x100)
+
+	u32 stat, mask;
+
+	stat = (*OFDM_INT_STS);
+	*OFDM_INT_STS = stat & (~IN_SYNC_MASK);
+
+	mask = (*OFDM_INT_EN);
+	stat &= mask;
+
+	return (stat & IN_SYNC_MASK) == IN_SYNC_MASK;
+}
+
+int dvbt_isr_monitor(void)
+{
+#define SYM_HEAD_MASK (0x80)
+	u32 stat, mask;
+
+	stat = (*OFDM_INT_STS);
+	*OFDM_INT_STS = stat & (~SYM_HEAD_MASK);
+
+	mask = (*OFDM_INT_EN);
+	stat &= mask;
+	/* symbol_head int */
+	if ((stat & SYM_HEAD_MASK) == SYM_HEAD_MASK)
+		demod_monitor_ave();
+	return 0;
+}
+
+int dvbt_isr_cancel(void)
+{
+	*OFDM_INT_STS = 0;
+	*OFDM_INT_EN = 0;
+	return 0;
+}
+
+static int demod_monitor_instant(void)
+{
+	int SNR;
+	int SNR_SP = 500;
+	int SNR_TPS = 0;
+	int SNR_CP = 0;
+	int SFO_residual = 0;
+	int SFO_esti = 0;
+	int FCFO_esti = 0;
+	int FCFO_residual = 0;
+	int AGC_Gain = 0;
+	int be_vit_error = 0;
+	int Signal_power = 0;
+	int FECFlag = 0;
+	int EQ_seg_ratio = 0;
+	int tps_0 = 0;
+	int tps_1 = 0;
+	int tps_2 = 0;
+	int cci_blank = 0;
+
+	int SFO;
+	int FCFO;
+	int timing_adj;
+	int RS_CorrectNum;
+	int RS_Error_sum;
+	int resync_times;
+	int tps_summary;
+
+	int tps_window;
+	int tps_guard;
+	int tps_constell;
+	int tps_Hier_none;
+	int tps_Hier_alpha;
+	int tps_HP_cr;
+	int tps_LP_cr;
+
+	int tmpAGCGain;
+
+	/* Read Registers */
+	SNR = apb_read_reg(2, 0x0a);
+	FECFlag = (apb_read_reg(2, 0x00) >> 11) & 0x3;
+	SFO = apb_read_reg(2, 0x47) & 0xfff;
+	SFO_esti = apb_read_reg(2, 0x60) & 0xfff;
+	FCFO_esti = (apb_read_reg(2, 0x60) >> 11) & 0xfff;
+	FCFO = (apb_read_reg(2, 0x26)) & 0xffffff;
+	be_vit_error = apb_read_reg(2, 0x0c) & 0x1fff;
+	timing_adj = apb_read_reg(2, 0x6f) & 0x1fff;
+	RS_CorrectNum = apb_read_reg(2, 0xc1) & 0xfffff;
+	Signal_power = (apb_read_reg(2, 0x1b)) & 0x1ff;
+	EQ_seg_ratio = apb_read_reg(2, 0x6e) & 0x3ffff;
+	tps_0 = apb_read_reg(2, 0x64);
+	tps_1 = apb_read_reg(2, 0x65);
+	tps_2 = apb_read_reg(2, 0x66) & 0xf;
+	tps_summary = apb_read_reg(2, 0x04) & 0x7fff;
+	cci_blank = (apb_read_reg(2, 0x66) >> 16);
+	RS_Error_sum = apb_read_reg(2, 0xbf) & 0x3ffff;
+	resync_times = (apb_read_reg(2, 0xc0) >> 20) & 0xff;
+	AGC_Gain = apb_read_reg(2, 0x1c) & 0x7ff;
+
+	/* Calc */
+	SFO_residual = (SFO > 0x7ff) ? (SFO - 0x1000) : SFO;
+	FCFO_residual = (FCFO > 0x7fffff) ? (FCFO - 0x1000000) : FCFO;
+	FCFO_esti = (FCFO_esti > 0x7ff) ? (FCFO_esti - 0x1000) : FCFO_esti;
+	SNR_CP = (SNR) & 0x3ff;
+	SNR_TPS = (SNR >> 10) & 0x3ff;
+	SNR_SP = (SNR >> 20) & 0x3ff;
+	SNR_SP = (SNR_SP > 0x1ff) ? SNR_SP - 0x400 : SNR_SP;
+	SNR_TPS = (SNR_TPS > 0x1ff) ? SNR_TPS - 0x400 : SNR_TPS;
+	SNR_CP = (SNR_CP > 0x1ff) ? SNR_CP - 0x400 : SNR_CP;
+	tmpAGCGain = AGC_Gain;
+	timing_adj = (timing_adj > 0xfff) ? timing_adj - 0x2000 : timing_adj;
+
+	tps_window = (tps_summary & 0x3);
+	tps_guard = ((tps_summary >> 2) & 0x3);
+	tps_constell = ((tps_summary >> 13) & 0x3);
+	tps_Hier_none = (((tps_summary >> 10) & 0x7) == 0) ? 1 : 0;
+	tps_Hier_alpha = (tps_summary >> 11) & 0x3;
+	tps_Hier_alpha = (tps_Hier_alpha == 3) ? 4 : tps_Hier_alpha;
+	tps_LP_cr = (tps_summary >> 4) & 0x7;
+	tps_HP_cr = (tps_summary >> 7) & 0x7;
+
+	dprintk("\n\n");
+	switch (tps_window) {
+	case 0:
+		dprintk("2K ");
+		break;
+	case 1:
+		dprintk("8K ");
+		break;
+	case 2:
+		dprintk("4K ");
+		break;
+	default:
+		dprintk("UnWin ");
+		break;
+	}
+	switch (tps_guard) {
+	case 0:
+		dprintk("1/32 ");
+		break;
+	case 1:
+		dprintk("1/16 ");
+		break;
+	case 2:
+		dprintk("1/ 8 ");
+		break;
+	case 3:
+		dprintk("1/ 4 ");
+		break;
+	default:
+		dprintk("UnGuard ");
+		break;
+	}
+	switch (tps_constell) {
+	case 0:
+		dprintk(" QPSK ");
+		break;
+	case 1:
+		dprintk("16QAM ");
+		break;
+	case 2:
+		dprintk("64QAM ");
+		break;
+	default:
+		dprintk("UnConstl ");
+		break;
+	}
+	switch (tps_Hier_none) {
+	case 0:
+		dprintk("Hiera ");
+		break;
+	case 1:
+		dprintk("non-H ");
+		break;
+	default:
+		dprintk("UnHier ");
+		break;
+	}
+	dprintk("%d ", tps_Hier_alpha);
+	dprintk("HP ");
+	switch (tps_HP_cr) {
+	case 0:
+		dprintk("1/2 ");
+		break;
+	case 1:
+		dprintk("2/3 ");
+		break;
+	case 2:
+		dprintk("3/4 ");
+		break;
+	case 3:
+		dprintk("5/6 ");
+		break;
+	case 4:
+		dprintk("7/8 ");
+		break;
+	default:
+		dprintk("UnHCr ");
+		break;
+	}
+	dprintk("LP ");
+	switch (tps_LP_cr) {
+	case 0:
+		dprintk("1/2 ");
+		break;
+	case 1:
+		dprintk("2/3 ");
+		break;
+	case 2:
+		dprintk("3/4 ");
+		break;
+	case 3:
+		dprintk("5/6 ");
+		break;
+	case 4:
+		dprintk("7/8 ");
+		break;
+	default:
+		dprintk("UnLCr ");
+		break;
+	}
+	dprintk("\n");
+	dprintk("P %4x ", RS_Error_sum);
+	dprintk("SP %2d ", SNR_SP);
+	dprintk("TPS %2d ", SNR_TPS);
+	dprintk("CP %2d ", SNR_CP);
+	dprintk("EQS %2x ", EQ_seg_ratio);
+	dprintk("RSC %4d ", RS_CorrectNum);
+	dprintk("SFO %3d ", SFO_residual);
+	dprintk("FCFO %4d ", FCFO_residual);
+	dprintk("Vit %3x ", be_vit_error);
+	dprintk("Timing %3d ", timing_adj);
+	dprintk("SigP %3x ", Signal_power);
+	dprintk("AGC %d ", tmpAGCGain);
+	dprintk("SigP %d ",
+		agc_power_to_dbm(tmpAGCGain, Signal_power, 0, tuner_type));
+	dprintk("FEC %x ", FECFlag);
+	dprintk("ReSyn %x ", resync_times);
+	dprintk("cciB %x", cci_blank);
+
+	dprintk("\n");
+
+	return 0;
+}
+
+int serial_div(int a, int b)
+{
+	int c;
+	int cnt;
+	int b_buf;
+
+	if (b == 0)
+		return 0x7fffffff;
+	if (a == 0)
+		return 0;
+
+	c = 0;
+	cnt = 0;
+
+	a = (a < 0) ? -1 * a : a;
+	b = (b < 0) ? -1 * b : b;
+
+	b_buf = b;
+
+	while (a >= b) {
+		b = b << 1;
+		cnt++;
+	}
+	while (b > b_buf) {
+		b = b >> 1;
+		c = c << 1;
+		if (a > b) {
+			c = c + 1;
+			a = a - b;
+		}
+	}
+	return c;
+}
+
+static int ave0, bit_unit_L;
+
+static int dvbt_ber(void)
+{
+	int BER_e_n7 = serial_div(ave0 * 40, bit_unit_L);
+
+	return BER_e_n7;
+}
+
+static int demod_monitor_ave(void)
+{
+	static int i;
+	static int ave[3] = { 0, 0, 0 };
+
+	ave[0] = ave[0] + (apb_read_reg(2, 0x0b) & 0x7ff);
+	ave[1] = ave[1] + (apb_read_reg(2, 0x0a) & 0x3ff);
+	ave[2] = ave[2] + (apb_read_reg(2, 0x0c) & 0x1fff);
+
+	i++;
+
+	if (i >= 8192) {
+		int tps_mode;
+		int tps_constell;
+		int r_t;
+		int mode_L;
+		int const_L;
+		int SNR_Int;
+		int SNR_fra;
+
+		if (debug_amldvbt)
+			demod_monitor_instant();
+
+		r_t = apb_read_reg(2, 0x04);
+		tps_mode = r_t & 0x3;
+		tps_constell = (r_t >> 13) & 0x3;
+		mode_L = (tps_mode == 0) ? 1 : (tps_mode == 1) ? 4 : 2;
+		const_L = (tps_constell == 0) ? 2 : (tps_constell == 1) ? 4 : 6;
+		bit_unit_L = 189 * mode_L * const_L;
+		SNR_Int = (ave[1] >> 16);
+		switch ((ave[1] >> 13) & 0x7) {
+		case 0:
+			SNR_fra = 0;
+			break;
+		case 1:
+			SNR_fra = 125;
+			break;
+		case 2:
+			SNR_fra = 250;
+			break;
+		case 3:
+			SNR_fra = 375;
+			break;
+		case 4:
+			SNR_fra = 500;
+			break;
+		case 5:
+			SNR_fra = 625;
+			break;
+		case 6:
+			SNR_fra = 750;
+			break;
+		case 7:
+			SNR_fra = 875;
+			break;
+		default:
+			SNR_fra = 0;
+			break;
+		}
+
+		ave0 = ave[0];
+
+		if (debug_amldvbt)
+			dprintk("RSBi %d Thresh %d SNR %d.%d Vit %x\n\n",
+				(ave[0] >> 3) * 5, (bit_unit_L * 8), SNR_Int,
+				SNR_fra, (ave[2] >> 13));
+		i = 0;
+		ave[0] = ave[1] = ave[2] = 0;
+	}
+
+	return i;
+}
+
+int dvbt_switch_to_HP(void)
+{
+	apb_write_reg(2, 0x78, apb_read_reg(2, 0x78) & ~(1 << 9));
+	return 0;
+}
+
+int dvbt_switch_to_LP(void)
+{
+	apb_write_reg(2, 0x78, apb_read_reg(2, 0x78) | (1 << 9));
+	return 0;
+}
+
+int dvbt_shutdown(void)
+{
+	apb_write_reg(2, 0x02, 0x00800000);
+	/* SW reset bit[23] ; write anything to zero */
+	apb_write_reg(2, 0x00, 0x00000000);
+	return 0;
+}
+
+int dvbt_get_params(struct aml_demod_sta *demod_sta,
+		    struct aml_demod_i2c *adap, int *code_rate_HP,
+		    /* high priority stream code rate */
+			int *code_rate_LP,  /* low priority stream code rate */
+			int *constellation, /* modulation type (see above) */
+			int *transmission_mode,
+			int *guard_interval, int *hierarchy_information)
+{
+	int tps_summary, tps_window, tps_guard, tps_constell, tps_Hier_none;
+	int tps_Hier_alpha, tps_LP_cr, tps_HP_cr;
+
+	tps_summary = apb_read_reg(2, 0x04) & 0x7fff;
+	tps_window = (tps_summary & 0x3);
+	tps_guard = ((tps_summary >> 2) & 0x3);
+	tps_constell = ((tps_summary >> 13) & 0x3);
+	tps_Hier_none = (((tps_summary >> 10) & 0x7) == 0) ? 1 : 0;
+	tps_Hier_alpha = (tps_summary >> 11) & 0x3;
+	tps_Hier_alpha = (tps_Hier_alpha == 3) ? 4 : tps_Hier_alpha;
+	tps_LP_cr = (tps_summary >> 4) & 0x7;
+	tps_HP_cr = (tps_summary >> 7) & 0x7;
+	if (code_rate_HP)
+		*code_rate_HP = tps_HP_cr;	/*1/2:2/3:3/4:5/6:7/8 */
+	if (code_rate_LP)
+		*code_rate_LP = tps_LP_cr;	/*1/2:2/3:3/4:5/6:7/8 */
+	if (constellation)
+		*constellation = tps_constell;	/*QPSK/16QAM/64QAM */
+	if (transmission_mode)
+		*transmission_mode = tps_window;	/*2K/8K/4K */
+	if (guard_interval)
+		*guard_interval = tps_guard;	/*1/32:1/16:1/8:1/4 */
+	if (hierarchy_information)
+		*hierarchy_information = tps_Hier_alpha;	/*1/2/4 */
+	return 0;
+}
diff --git a/drivers/stream_input/tv_frontend/dtv_demod/i2c_func.c b/drivers/stream_input/tv_frontend/dtv_demod/i2c_func.c
new file mode 100644
index 0000000..68b214e
--- /dev/null
+++ b/drivers/stream_input/tv_frontend/dtv_demod/i2c_func.c
@@ -0,0 +1,42 @@
+/*
+* Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT
+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+* more details.
+*
+* You should have received a copy of the GNU General Public License along
+* with this program; if not, write to the Free Software Foundation, Inc.,
+* 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+*
+* Description:
+*/
+#include <linux/kernel.h>
+#include <linux/i2c.h>
+#include <linux/delay.h>
+#include <linux/dvb/aml_demod.h>
+#include "demod_func.h"
+
+int am_demod_i2c_xfer(struct aml_demod_i2c *adap, struct i2c_msg msgs[],
+		      int num)
+{
+	int ret = 0;
+
+	if (adap->scl_oe) {
+		/*      ret = aml_i2c_sw_bit_xfer(adap, msgs, num);*/
+	} else {
+		if (adap->i2c_priv)
+			ret = i2c_transfer((struct i2c_adapter *)adap->i2c_priv,
+					   msgs, num);
+		else
+			;
+		/*	printk("i2c error, no valid i2c\n");*/
+	}
+	return ret;
+}
diff --git a/drivers/stream_input/tv_frontend/dtv_demod/include/acf_filter_coefficient.h b/drivers/stream_input/tv_frontend/dtv_demod/include/acf_filter_coefficient.h
new file mode 100644
index 0000000..5744885
--- /dev/null
+++ b/drivers/stream_input/tv_frontend/dtv_demod/include/acf_filter_coefficient.h
@@ -0,0 +1,414 @@
+/*
+* Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT
+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+* more details.
+*
+* You should have received a copy of the GNU General Public License along
+* with this program; if not, write to the Free Software Foundation, Inc.,
+* 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+*
+* Description:
+*/
+void program_acf(int acf1[20], int acf2[33])
+{
+	int i;
+
+	for (i = 0; i < 20; i++)
+		apb_write_reg(DVBT_BASE + (0x2c + i) * 4, acf1[i]);
+	for (i = 0; i < 33; i++) {
+		apb_write_reg(DVBT_BASE + 0xfe * 4, i);
+		apb_write_reg(DVBT_BASE + 0xff * 4, acf2[i]);
+	}
+}
+
+void ini_acf_iireq_src_45m_8m(void)
+{
+	int acf1[] = { 0x294, 0x085, 0x076, 0x01e,
+		0x27c, 0x0af, 0x2bf, 0x06d,
+		0x265, 0x0d8, 0x270, 0x05e,
+		0x257, 0x0ef, 0x25b, 0x04b,
+		0x24f, 0x0fc, 0x254, 0x04d
+	};
+	int acf2[] = { 0x3f3fff, 0x3da7cd, 0x3c0f9b, 0x3a7768, 0x38df35,
+		0x373f01,
+		0x3596cd, 0x33ee98, 0x323e62, 0x307e2b, 0x2eb5f3,
+		0x2ce5b9,
+		0x2b057e, 0x290d41, 0x26fd00, 0x24dcbd, 0x229477,
+		0x202c2c,
+		0x1d93dc, 0x1ac386, 0x17b328, 0x144ac1, 0x106a4d,
+		0x0be1c8,
+		0x07e129, 0x04d0cc, 0x015064, 0x3d47ec, 0x38675e,
+		0x326eb1,
+		0x326e4d, 0x326e4d, 0x00064d
+	};
+
+	program_acf(acf1, acf2);
+}
+
+void ini_acf_iireq_src_45m_7m(void)
+{
+	int acf1[] = { 0x283, 0x091, 0x02f, 0x01e,
+		0x26a, 0x0b8, 0x296, 0x06d,
+		0x253, 0x0dc, 0x257, 0x05e,
+		0x245, 0x0f1, 0x246, 0x04b,
+		0x23d, 0x0fc, 0x241, 0x04d
+	};
+	int acf2[] = { 0x3f3fff, 0x3dafce, 0x3c1f9c, 0x3a8769, 0x38ef37,
+		0x374f03,
+		0x35aecf, 0x34069b, 0x325665, 0x30962e, 0x2ecdf6,
+		0x2cfdbc,
+		0x2b1581, 0x291d43, 0x271503, 0x24e4bf, 0x229c78,
+		0x202c2d,
+		0x1d8bdc, 0x1ab384, 0x179325, 0x141abc, 0x102a46,
+		0x0b81be,
+		0x07711c, 0x0448bd, 0x00b052, 0x3c7fd6, 0x374740,
+		0x308684,
+		0x308610, 0x308610, 0x000610
+	};
+
+	program_acf(acf1, acf2);
+}
+
+void ini_acf_iireq_src_45m_6m(void)
+{
+	int acf1[] = { 0x272, 0x09e, 0x3dc, 0x01e,
+		0x259, 0x0c0, 0x272, 0x06d,
+		0x242, 0x0e1, 0x240, 0x05e,
+		0x235, 0x0f3, 0x234, 0x04b,
+		0x22e, 0x0fd, 0x230, 0x04d
+	};
+	int acf2[] = { 0x3f47ff, 0x3dbfcf, 0x3c379e, 0x3aa76d, 0x391f3c,
+		0x378709,
+		0x35e6d6, 0x343ea2, 0x328e6d, 0x30d636, 0x2f0dfe,
+		0x2d35c4,
+		0x2b4d88, 0x294d49, 0x273d08, 0x2504c4, 0x22b47c,
+		0x203c2f,
+		0x1d9bde, 0x1ac386, 0x17a327, 0x1432bf, 0x104249,
+		0x0ba9c2,
+		0x07a922, 0x0490c5, 0x01185c, 0x3d0fe5, 0x383f58,
+		0x3286af,
+		0x328650, 0x328650, 0x000650
+	};
+
+	program_acf(acf1, acf2);
+}
+
+void ini_acf_iireq_src_45m_5m(void)
+{
+	int acf1[] = { 0x260, 0x0ab, 0x37e, 0x02e,
+		0x249, 0x0ca, 0x251, 0x06d,
+		0x233, 0x0e6, 0x22d, 0x05e,
+		0x227, 0x0f5, 0x224, 0x04b,
+		0x220, 0x0fd, 0x221, 0x04d
+	};
+	int acf2[] = { 0x3f3fff, 0x3db7cf, 0x3c279d, 0x3a9f6c, 0x39073a,
+		0x377707,
+		0x35d6d4, 0x3436a0, 0x328e6b, 0x30d636, 0x2f15ff,
+		0x2d4dc6,
+		0x2b758c, 0x29854f, 0x278511, 0x256ccf, 0x232c89,
+		0x20cc3f,
+		0x1e33f0, 0x1b6b9b, 0x185b3d, 0x14e2d5, 0x10f260,
+		0x0c51d7,
+		0x082934, 0x04f8d4, 0x014066, 0x3ccfe4, 0x372f46,
+		0x2f5673,
+		0x2f55ea, 0x2f55ea, 0x0005ea
+	};
+
+	program_acf(acf1, acf2);
+}
+
+void ini_acf_iireq_src_2857m_8m(void)
+{
+	int acf1[] = { 0x2df, 0x059, 0x144, 0x00e,
+		0x2d3, 0x08f, 0x38d, 0x06f,
+		0x2c6, 0x0c5, 0x302, 0x05e,
+		0x2be, 0x0e7, 0x2d6, 0x04b,
+		0x2b7, 0x0f9, 0x2c8, 0x04d
+	};
+	int acf2[] = { 0x3f3fff, 0x3dbfcf, 0x3c379e, 0x3aaf6d, 0x391f3c,
+		0x37870a,
+		0x35eed7, 0x344ea3, 0x32a66f, 0x30f639, 0x2f3602,
+		0x2d65c9,
+		0x2b858e, 0x299552, 0x278d12, 0x2564cf, 0x231c88,
+		0x20b43d,
+		0x1e13ec, 0x1b3395, 0x181336, 0x1492cc, 0x109254,
+		0x0be1cb,
+		0x07c127, 0x0498c7, 0x00f85b, 0x3cbfde, 0x377747,
+		0x309e88,
+		0x309e13, 0x309e13, 0x000613
+	};
+
+	program_acf(acf1, acf2);
+}
+
+void ini_acf_iireq_src_2857m_7m(void)
+{
+	int acf1[] = { 0x2c6, 0x067, 0x10f, 0x01e,
+		0x2b4, 0x099, 0x344, 0x06f,
+		0x2a2, 0x0cb, 0x2cb, 0x05e,
+		0x297, 0x0ea, 0x2a7, 0x04b,
+		0x28f, 0x0fa, 0x29c, 0x04d
+	};
+	int acf2[] = { 0x3f3fff, 0x3dbfcf, 0x3c379e, 0x3aa76d, 0x39173b,
+		0x378709,
+		0x35e6d6, 0x3446a2, 0x329e6d, 0x30e637, 0x2f2600,
+		0x2d4dc7,
+		0x2b6d8c, 0x297d4e, 0x276d0e, 0x2544cb, 0x22fc84,
+		0x208438,
+		0x1de3e7, 0x1b0b90, 0x17eb30, 0x146ac7, 0x107250,
+		0x0bc9c6,
+		0x07b124, 0x0490c5, 0x00f85b, 0x3cc7df, 0x37974a,
+		0x30ce8d,
+		0x30ce19, 0x30ce19, 0x000619
+	};
+
+	program_acf(acf1, acf2);
+}
+
+void ini_acf_iireq_src_2857m_6m(void)
+{
+	int acf1[] = { 0x2ac, 0x076, 0x0c9, 0x01e,
+		0x297, 0x0a4, 0x2fd, 0x06d,
+		0x281, 0x0d2, 0x299, 0x05e,
+		0x274, 0x0ed, 0x27d, 0x04b,
+		0x26c, 0x0fb, 0x274, 0x04d
+	};
+	int acf2[] = { 0x3f3fff, 0x3db7cf, 0x3c279d, 0x3a976b, 0x390739,
+		0x376f07,
+		0x35ced3, 0x342e9f, 0x327e6a, 0x30c634, 0x2f05fc,
+		0x2d35c4,
+		0x2b5d89, 0x29654c, 0x275d0c, 0x253cca, 0x22fc83,
+		0x209439,
+		0x1dfbe9, 0x1b2b93, 0x181b35, 0x14b2ce, 0x10ca5a,
+		0x0c41d4,
+		0x084935, 0x0538d9, 0x01c071, 0x3db7fa, 0x38bf6b,
+		0x327eb9,
+		0x327e4f, 0x327e4f, 0x00064f
+	};
+
+	program_acf(acf1, acf2);
+}
+
+void ini_acf_iireq_src_2857m_5m(void)
+{
+	int acf1[] = { 0x292, 0x087, 0x06e, 0x01e,
+		0x27a, 0x0b0, 0x2b9, 0x06d,
+		0x262, 0x0d8, 0x26d, 0x05e,
+		0x254, 0x0f0, 0x258, 0x04b,
+		0x24c, 0x0fc, 0x252, 0x04d
+	};
+	int acf2[] = { 0x3f3fff, 0x3db7ce, 0x3c279d, 0x3a976b, 0x38ff38,
+		0x376706,
+		0x35c6d2, 0x341e9d, 0x326e68, 0x30ae31, 0x2eedf9,
+		0x2d15c0,
+		0x2b2d84, 0x293546, 0x272506, 0x24fcc2, 0x22ac7b,
+		0x203c2f,
+		0x1d9bde, 0x1ac386, 0x17a327, 0x1422be, 0x103247,
+		0x0b91bf,
+		0x07891e, 0x0470c1, 0x00e858, 0x3ccfde, 0x37bf4d,
+		0x313e96,
+		0x313e27, 0x313e27, 0x000627
+	};
+
+	program_acf(acf1, acf2);
+}
+
+void ini_acf_iireq_src_24m_8m(void)
+{
+	int acf1[] = { 0x303, 0x048, 0x17e, 0x00e,
+		0x302, 0x081, 0x3f8, 0x00a,
+		0x300, 0x0bd, 0x35b, 0x05e,
+		0x2fe, 0x0e3, 0x325, 0x04b,
+		0x2fb, 0x0f8, 0x313, 0x04d
+	};
+	int acf2[] = { 0x3f47ff, 0x3dc7d0, 0x3c3fa0, 0x3abf6f, 0x392f3e,
+		0x37a70d,
+		0x360eda, 0x346ea7, 0x32c673, 0x31163d, 0x2f5606,
+		0x2d8dce,
+		0x2bad93, 0x29bd56, 0x27b517, 0x258cd4, 0x23448d,
+		0x20cc41,
+		0x1e2bf0, 0x1b4b98, 0x182338, 0x149ace, 0x109255,
+		0x0bd1ca,
+		0x07a123, 0x0468c2, 0x00b054, 0x3c5fd4, 0x37073a,
+		0x302e79,
+		0x302e05, 0x302e05, 0x000605
+	};
+
+	program_acf(acf1, acf2);
+}
+
+void ini_acf_iireq_src_24m_7m(void)
+{
+	int acf1[] = { 0x2e7, 0x055, 0x153, 0x00e,
+		0x2dd, 0x08b, 0x3a5, 0x06f,
+		0x2d2, 0x0c4, 0x315, 0x05e,
+		0x2cb, 0x0e6, 0x2e7, 0x04b,
+		0x2c5, 0x0f9, 0x2d8, 0x04d
+	};
+	int acf2[] = { 0x3f3fff, 0x3dbfcf, 0x3c379e, 0x3aaf6d, 0x391f3c,
+		0x37870a,
+		0x35eed7, 0x344ea3, 0x32a66f, 0x30ee39, 0x2f2e02,
+		0x2d65c9,
+		0x2b858e, 0x298d51, 0x278511, 0x255cce, 0x231487,
+		0x20a43c,
+		0x1e0beb, 0x1b3394, 0x181335, 0x1492cb, 0x109254,
+		0x0be1ca,
+		0x07b925, 0x0480c5, 0x00d858, 0x3c87d8, 0x373740,
+		0x305e80,
+		0x305e0b, 0x305e0b, 0x00060b
+	};
+
+	program_acf(acf1, acf2);
+}
+
+void ini_acf_iireq_src_24m_6m(void)
+{
+	int acf1[] = { 0x2c9, 0x065, 0x118, 0x01e,
+		0x2b9, 0x097, 0x34f, 0x06f,
+		0x2a7, 0x0ca, 0x2d3, 0x05e,
+		0x29c, 0x0e9, 0x2ae, 0x04b,
+		0x295, 0x0fa, 0x2a2, 0x04d
+	};
+	int acf2[] = { 0x3f3fff, 0x3db7cf, 0x3c2f9d, 0x3a9f6c, 0x390f3a,
+		0x377707,
+		0x35d6d4, 0x342ea0, 0x32866b, 0x30ce34, 0x2f05fd,
+		0x2d35c3,
+		0x2b5588, 0x295d4b, 0x27550b, 0x252cc8, 0x22dc80,
+		0x206c35,
+		0x1dcbe4, 0x1af38c, 0x17cb2d, 0x144ac3, 0x104a4b,
+		0x0b99c1,
+		0x07791d, 0x0448be, 0x00b052, 0x3c6fd4, 0x37473f,
+		0x30c686,
+		0x30c618, 0x30c618, 0x000618
+	};
+
+	program_acf(acf1, acf2);
+}
+
+void ini_acf_iireq_src_24m_5m(void)
+{
+	int acf1[] = { 0x2ab, 0x077, 0x0c6, 0x01e,
+		0x295, 0x0a5, 0x2fa, 0x06d,
+		0x27f, 0x0d2, 0x297, 0x05e,
+		0x272, 0x0ed, 0x27b, 0x04b,
+		0x26a, 0x0fb, 0x272, 0x04d
+	};
+	int acf2[] = { 0x3f3fff, 0x3db7cf, 0x3c2f9e, 0x3aa76c, 0x39173b,
+		0x377f08,
+		0x35ded5, 0x343ea1, 0x328e6c, 0x30de36, 0x2f15ff,
+		0x2d45c6,
+		0x2b658a, 0x29754d, 0x27650d, 0x253cca, 0x22f483,
+		0x208438,
+		0x1de3e7, 0x1b0b90, 0x17eb30, 0x1472c7, 0x107a51,
+		0x0bd9c8,
+		0x07c927, 0x04a8c9, 0x01205f, 0x3cf7e4, 0x37e752,
+		0x31669a,
+		0x31662c, 0x31662c, 0x00062c
+	};
+
+	program_acf(acf1, acf2);
+}
+
+void ini_acf_iireq_src_207m_8m(void)
+{
+	int acf1[] = { 0x327, 0x039, 0x1a5, 0x07b,
+		0x332, 0x076, 0x05c, 0x06e,
+		0x33e, 0x0b6, 0x3b8, 0x05e,
+		0x344, 0x0e0, 0x37a, 0x04b,
+		0x345, 0x0f7, 0x365, 0x04d
+	};
+	int acf2[] = { 0x3f47ff, 0x3dcfd1, 0x3c57a1, 0x3ad772, 0x394f42,
+		0x37c711,
+		0x3636df, 0x34a6ad, 0x32fe7a, 0x315645, 0x2f9e0f,
+		0x2dd5d7,
+		0x2bfd9d, 0x2a0d61, 0x280d21, 0x25e4df, 0x239c98,
+		0x212c4d,
+		0x1e8bfc, 0x1baba4, 0x188344, 0x14fad9, 0x10ea61,
+		0x0c29d4,
+		0x07e92d, 0x04a8cb, 0x00f05c, 0x3c87da, 0x371f3e,
+		0x30267a,
+		0x302604, 0x302604, 0x000604
+	};
+
+	program_acf(acf1, acf2);
+}
+
+void ini_acf_iireq_src_207m_7m(void)
+{
+	int acf1[] = { 0x307, 0x046, 0x182, 0x00e,
+		0x306, 0x080, 0x002, 0x00a,
+		0x306, 0x0bd, 0x364, 0x05e,
+		0x304, 0x0e3, 0x32d, 0x04b,
+		0x301, 0x0f8, 0x31b, 0x04d
+	};
+	int acf2[] = { 0x3f47ff, 0x3dc7d0, 0x3c47a0, 0x3abf6f, 0x39373f,
+		0x37a70d,
+		0x3616db, 0x3476a8, 0x32d674, 0x31263f, 0x2f6608,
+		0x2d9dd0,
+		0x2bbd96, 0x29d559, 0x27cd19, 0x25a4d7, 0x235c90,
+		0x20ec45,
+		0x1e53f4, 0x1b739d, 0x18533d, 0x14d2d4, 0x10d25c,
+		0x0c19d1,
+		0x07e12c, 0x04a8ca, 0x00f05c, 0x3c8fdb, 0x372740,
+		0x302e7c,
+		0x302e05, 0x302e05, 0x000605
+	};
+
+	program_acf(acf1, acf2);
+}
+
+void ini_acf_iireq_src_207m_6m(void)
+{
+	int acf1[] = { 0x2e6, 0x056, 0x151, 0x00e,
+		0x2db, 0x08c, 0x3a1, 0x06f,
+		0x2d0, 0x0c4, 0x312, 0x05e,
+		0x2c9, 0x0e6, 0x2e4, 0x04b,
+		0x2c3, 0x0f9, 0x2d6, 0x04d
+	};
+	int acf2[] = { 0x3f47ff, 0x3dbfd0, 0x3c3f9f, 0x3ab76e, 0x39273d,
+		0x37970b,
+		0x35fed9, 0x345ea5, 0x32b671, 0x31063b, 0x2f4604,
+		0x2d75cb,
+		0x2b9590, 0x29a553, 0x279513, 0x256cd0, 0x232489,
+		0x20b43d,
+		0x1e0bec, 0x1b3395, 0x180b35, 0x148acb, 0x108253,
+		0x0bd1c8,
+		0x07a123, 0x0470c2, 0x00c055, 0x3c77d6, 0x372f3e,
+		0x306e80,
+		0x306e0d, 0x306e0d, 0x00060d
+	};
+
+	program_acf(acf1, acf2);
+}
+
+void ini_acf_iireq_src_207m_5m(void)
+{
+	int acf1[] = { 0x2c3, 0x068, 0x109, 0x01e,
+		0x2b1, 0x09a, 0x33d, 0x06f,
+		0x29f, 0x0cc, 0x2c6, 0x05e,
+		0x293, 0x0ea, 0x2a3, 0x04b,
+		0x28c, 0x0fa, 0x298, 0x04d
+	};
+	int acf2[] = { 0x3f3fff, 0x3db7ce, 0x3c279d, 0x3a976b, 0x38ff38,
+		0x376706,
+		0x35c6d2, 0x341e9e, 0x327669, 0x30be32, 0x2ef5fb,
+		0x2d25c1,
+		0x2b4586, 0x295549, 0x274509, 0x251cc6, 0x22dc80,
+		0x206c34,
+		0x1dcbe4, 0x1afb8d, 0x17db2e, 0x1462c5, 0x106a4f,
+		0x0bc9c6,
+		0x07b124, 0x0488c5, 0x00e859, 0x3cafdc, 0x377f47,
+		0x30ee8c,
+		0x30ee1d, 0x30ee1d, 0x00061d
+	};
+
+	program_acf(acf1, acf2);
+}
diff --git a/drivers/stream_input/tv_frontend/dtv_demod/include/addr_dtmb_che.h b/drivers/stream_input/tv_frontend/dtv_demod/include/addr_dtmb_che.h
new file mode 100644
index 0000000..4b23132
--- /dev/null
+++ b/drivers/stream_input/tv_frontend/dtv_demod/include/addr_dtmb_che.h
@@ -0,0 +1,77 @@
+/*
+* Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT
+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+* more details.
+*
+* You should have received a copy of the GNU General Public License along
+* with this program; if not, write to the Free Software Foundation, Inc.,
+* 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+*
+* Description:
+*/
+#ifndef __ADDR_DTMB_CHE_H__
+#define __ADDR_DTMB_CHE_H__
+
+#include "addr_dtmb_top.h"
+
+#define  DTMB_CHE_ADDR(x) (DTMB_DEMOD_BASE + (x << 2))
+
+#define  DTMB_CHE_TE_HREB_SNR               DTMB_CHE_ADDR(0x8d)
+#define  DTMB_CHE_MC_SC_TIMING_POWTHR       DTMB_CHE_ADDR(0x8e)
+#define  DTMB_CHE_MC_SC_PROTECT_GD          DTMB_CHE_ADDR(0x8f)
+#define  DTMB_CHE_TIMING_LIMIT              DTMB_CHE_ADDR(0x90)
+#define  DTMB_CHE_TPS_CONFIG                DTMB_CHE_ADDR(0x91)
+#define  DTMB_CHE_FD_TD_STEPSIZE            DTMB_CHE_ADDR(0x92)
+#define  DTMB_CHE_QSTEP_SET                 DTMB_CHE_ADDR(0x93)
+#define  DTMB_CHE_SEG_CONFIG                DTMB_CHE_ADDR(0x94)
+#define  DTMB_CHE_FD_TD_LEAKSIZE_CONFIG1    DTMB_CHE_ADDR(0x95)
+#define  DTMB_CHE_FD_TD_LEAKSIZE_CONFIG2    DTMB_CHE_ADDR(0x96)
+#define  DTMB_CHE_FD_TD_COEFF               DTMB_CHE_ADDR(0x97)
+#define  DTMB_CHE_M_CCI_THR_CONFIG1         DTMB_CHE_ADDR(0x98)
+#define  DTMB_CHE_M_CCI_THR_CONFIG2         DTMB_CHE_ADDR(0x99)
+#define  DTMB_CHE_M_CCI_THR_CONFIG3         DTMB_CHE_ADDR(0x9a)
+#define  DTMB_CHE_CCIDET_CONFIG             DTMB_CHE_ADDR(0x9b)
+#define  DTMB_CHE_IBDFE_CONFIG1             DTMB_CHE_ADDR(0x9d)
+#define  DTMB_CHE_IBDFE_CONFIG2             DTMB_CHE_ADDR(0x9e)
+#define  DTMB_CHE_IBDFE_CONFIG3             DTMB_CHE_ADDR(0x9f)
+#define  DTMB_CHE_TD_COEFF                  DTMB_CHE_ADDR(0xa0)
+#define  DTMB_CHE_FD_TD_STEPSIZE_ADJ        DTMB_CHE_ADDR(0xa1)
+#define  DTMB_CHE_FD_COEFF_FRZ              DTMB_CHE_ADDR(0xa2)
+#define  DTMB_CHE_FD_COEFF                  DTMB_CHE_ADDR(0xa3)
+#define  DTMB_CHE_FD_LEAKSIZE               DTMB_CHE_ADDR(0xa4)
+#define  DTMB_CHE_IBDFE_CONFIG4             DTMB_CHE_ADDR(0xa5)
+#define  DTMB_CHE_IBDFE_CONFIG5             DTMB_CHE_ADDR(0xa6)
+#define  DTMB_CHE_IBDFE_CONFIG6             DTMB_CHE_ADDR(0xa7)
+#define  DTMB_CHE_IBDFE_CONFIG7             DTMB_CHE_ADDR(0xa8)
+#define  DTMB_CHE_DCM_SC_MC_GD_LEN          DTMB_CHE_ADDR(0xa9)
+#define  DTMB_CHE_EQMC_PICK_THR             DTMB_CHE_ADDR(0xaa)
+#define  DTMB_CHE_EQMC_THRESHOLD            DTMB_CHE_ADDR(0xab)
+#define  DTMB_CHE_EQSC_PICK_THR             DTMB_CHE_ADDR(0xad)
+#define  DTMB_CHE_EQSC_THRESHOLD            DTMB_CHE_ADDR(0xae)
+#define  DTMB_CHE_PROTECT_GD_TPS            DTMB_CHE_ADDR(0xaf)
+#define  DTMB_CHE_FD_TD_STEPSIZE_THR1       DTMB_CHE_ADDR(0xb0)
+#define  DTMB_CHE_TDFD_SWITCH_SYM1          DTMB_CHE_ADDR(0xb1)
+#define  DTMB_CHE_TDFD_SWITCH_SYM2          DTMB_CHE_ADDR(0xb2)
+#define  DTMB_CHE_EQ_CONFIG                 DTMB_CHE_ADDR(0xb3)
+#define  DTMB_CHE_EQSC_SNR_IMP_THR1         DTMB_CHE_ADDR(0xb4)
+#define  DTMB_CHE_EQSC_SNR_IMP_THR2         DTMB_CHE_ADDR(0xb5)
+#define  DTMB_CHE_EQMC_SNR_IMP_THR1         DTMB_CHE_ADDR(0xb6)
+#define  DTMB_CHE_EQMC_SNR_IMP_THR2         DTMB_CHE_ADDR(0xb7)
+#define  DTMB_CHE_EQSC_SNR_DROP_THR         DTMB_CHE_ADDR(0xb8)
+#define  DTMB_CHE_EQMC_SNR_DROP_THR         DTMB_CHE_ADDR(0xb9)
+#define  DTMB_CHE_M_CCI_THR                 DTMB_CHE_ADDR(0xba)
+#define  DTMB_CHE_TPS_MC                    DTMB_CHE_ADDR(0xbb)
+#define  DTMB_CHE_TPS_SC                    DTMB_CHE_ADDR(0xbc)
+#define  DTMB_CHE_CHE_SET_FSM               DTMB_CHE_ADDR(0xbd)
+#define  DTMB_CHE_ZERO_NUM_THR              DTMB_CHE_ADDR(0xbe)
+#define  DTMB_CHE_TIMING_READY              DTMB_CHE_ADDR(0xbf)
+
+#endif
diff --git a/drivers/stream_input/tv_frontend/dtv_demod/include/addr_dtmb_che_bit.h b/drivers/stream_input/tv_frontend/dtv_demod/include/addr_dtmb_che_bit.h
new file mode 100644
index 0000000..d81c477
--- /dev/null
+++ b/drivers/stream_input/tv_frontend/dtv_demod/include/addr_dtmb_che_bit.h
@@ -0,0 +1,266 @@
+/*
+* Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT
+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+* more details.
+*
+* You should have received a copy of the GNU General Public License along
+* with this program; if not, write to the Free Software Foundation, Inc.,
+* 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+*
+* Description:
+*/
+#ifndef __ADDR_DTMB_CHE_BIT_H__
+#define __ADDR_DTMB_CHE_BIT_H__
+
+struct DTMB_CHE_TE_HREB_SNR_BITS {
+	unsigned int te_hreb_snr:21, reserved0:11;
+};
+struct DTMB_CHE_MC_SC_TIMING_POWTHR_BITS {
+	unsigned int mc_timing_powthr1:5,
+	    reserved1:3,
+	    mc_timing_powthr0:5,
+	    reserved2:2,
+	    sc_timing_powthr1:5, reserved3:4, sc_timing_powthr0:5, reserved4:3;
+};
+struct DTMB_CHE_MC_SC_PROTECT_GD_BITS {
+	unsigned int h_valid:2,
+	    reserved5:2,
+	    dist:3,
+	    reserved6:1,
+	    ma_size:3,
+	    reserved7:1,
+	    mc_protect_gd:5, reserved8:3, sc_protect_gd:5, reserved9:7;
+};
+struct DTMB_CHE_TIMING_LIMIT_BITS {
+	unsigned int ncoh_thd:3,
+	    reserved10:1,
+	    coh_thd:3,
+	    reserved11:1,
+	    strong_loc_thd:8, reserved12:4, timing_limit:5, reserved13:7;
+};
+struct DTMB_CHE_TPS_CONFIG_BITS {
+	unsigned int tps_pst_num:5,
+	    reserved14:3,
+	    tps_pre_num:5, reserved15:3, chi_power_thr:8, reserved16:8;
+};
+struct DTMB_CHE_FD_TD_STEPSIZE_BITS {
+	unsigned int fd_stepsize_thr03:5,
+	    fd_stepsize_thr02:5,
+	    fd_stepsize_thr01:5,
+	    td_stepsize_thr03:5,
+	    td_stepsize_thr02:5, td_stepsize_thr01:5, reserved17:2;
+};
+struct DTMB_CHE_QSTEP_SET_BITS {
+	unsigned int factor_stable_thres:10,
+	    reserved18:2, qstep_set:13, qstep_set_val:1, reserved19:6;
+};
+struct DTMB_CHE_SEG_CONFIG_BITS {
+	unsigned int seg_bypass:1,
+	    seg_num_1seg_log2:3,
+	    seg_alpha:3,
+	    seg_read_val:1, seg_read_addr:12, noise_input_shift:4, reserved20:8;
+};
+struct DTMB_CHE_FD_TD_LEAKSIZE_CONFIG1_BITS {
+	unsigned int fd_leaksize_thr03:5,
+	    fd_leaksize_thr02:5,
+	    fd_leaksize_thr01:5,
+	    td_leaksize_thr03:5,
+	    td_leaksize_thr02:5, td_leaksize_thr01:5, reserved21:2;
+};
+struct DTMB_CHE_FD_TD_LEAKSIZE_CONFIG2_BITS {
+	unsigned int fd_leaksize_thr13:5,
+	    fd_leaksize_thr12:5,
+	    fd_leaksize_thr11:5,
+	    td_leaksize_thr13:5,
+	    td_leaksize_thr12:5, td_leaksize_thr11:5, reserved22:2;
+};
+struct DTMB_CHE_FD_TD_COEFF_BITS {
+	unsigned int td_coeff_frz:14,
+	    reserved23:2,
+	    td_coeff_addr:4,
+	    td_coeff_init:1,
+	    td_coeff_rst:1,
+	    fd_coeff_init:1,
+	    fd_coeff_done:1,
+	    fd_coeff_rst:1, td_coeff_done:1, fd_coeff_addr:5, reserved24:1;
+};
+struct DTMB_CHE_M_CCI_THR_CONFIG1_BITS {
+	unsigned int m_cci_thr_mc1:10,
+	    m_cci_thr_mc2:10, m_cci_thr_mc3:10, reserved25:2;
+};
+struct DTMB_CHE_M_CCI_THR_CONFIG2_BITS {
+	unsigned int m_cci_thr_sc2:10,
+	    m_cci_thr_sc3:10, m_cci_thr_mc0:10, reserved26:2;
+};
+struct DTMB_CHE_M_CCI_THR_CONFIG3_BITS {
+	unsigned int m_cci_thr_ma:10,
+	    m_cci_thr_sc0:10, m_cci_thr_sc1:10, reserved27:2;
+};
+struct DTMB_CHE_CCIDET_CONFIG_BITS {
+	unsigned int ccidet_dly:7,
+	    ccidet_malpha:3,
+	    ccidet_sc_mask_rng:5,
+	    ccidet_mc_mask_rng:5,
+	    ccidet_masize:4,
+	    ccidect_sat_sft:3,
+	    ccicnt_out_sel:2, tune_mask:1, m_cci_bypass:1, reserved28:1;
+};
+struct DTMB_CHE_IBDFE_CONFIG1_BITS {
+	unsigned int ibdfe_cci_just_thr:13,
+	    reserved29:3,
+	    ibdfe_dmsg_point:5, reserved30:3, ibdfe_dmsg_alp:3, reserved31:5;
+};
+struct DTMB_CHE_IBDFE_CONFIG2_BITS {
+	unsigned int ibdfe_rou_rat_1:10,
+	    reserved32:6, ibdfe_rou_rat_0:10, reserved33:6;
+};
+struct DTMB_CHE_IBDFE_CONFIG3_BITS {
+	unsigned int ibdfe_rou_rat_3:10,
+	    reserved34:6, ibdfe_rou_rat_2:10, reserved35:6;
+};
+struct DTMB_CHE_TD_COEFF_BITS {
+	unsigned int td_coeff:24, reserved36:8;
+};
+struct DTMB_CHE_FD_TD_STEPSIZE_ADJ_BITS {
+	unsigned int fd_stepsize_adj:3, td_stepsize_adj:3, reserved37:26;
+};
+struct DTMB_CHE_FD_COEFF_BITS {
+	unsigned int fd_coeff:24, reserved38:8;
+};
+struct DTMB_CHE_FD_LEAKSIZE_BITS {
+	unsigned int fd_leaksize:18, reserved39:14;
+};
+struct DTMB_CHE_IBDFE_CONFIG4_BITS {
+	unsigned int ibdfe_fdbk_iter:4,
+	    ibdfe_eqout_iter:4,
+	    eq_dist_thr_tps:4,
+	    eq_soft_slicer_en:1,
+	    reserved40:3,
+	    gd_len:5, ibdfe_blank_y:1, reserved41:1, ibdfe_dmsg_start_cnt:9;
+};
+struct DTMB_CHE_IBDFE_CONFIG5_BITS {
+	unsigned int ibdfe_init_snr:12,
+	    reserved42:4, eq_init_snr:12, reserved43:4;
+};
+struct DTMB_CHE_IBDFE_CONFIG6_BITS {
+	unsigned int ibdfe_const_thr3:4,
+	    ibdfe_const_thr2:4,
+	    ibdfe_const_thr1:4,
+	    ibdfe_const_thr0:4,
+	    ibdfe_threshold3:4,
+	    ibdfe_threshold2:4, ibdfe_threshold1:4, ibdfe_threshold0:4;
+};
+struct DTMB_CHE_IBDFE_CONFIG7_BITS {
+	unsigned int ibdfe_pick_thr3:8,
+	    ibdfe_pick_thr2:8, ibdfe_pick_thr1:8, ibdfe_pick_thr0:8;
+};
+struct DTMB_CHE_DCM_SC_MC_GD_LEN_BITS {
+	unsigned int dcm_mc_gd_len:6,
+	    reserved44:2, dcm_sc_gd_len:6, reserved45:2, eq_dsnr_slc2drm:16;
+};
+struct DTMB_CHE_EQMC_PICK_THR_BITS {
+	unsigned int eqmc_pick_thr3:8,
+	    eqmc_pick_thr2:8, eqmc_pick_thr1:8, eqmc_pick_thr0:8;
+};
+struct DTMB_CHE_EQMC_THRESHOLD_BITS {
+	unsigned int eqmc_const_thr3:4,
+	    eqmc_const_thr2:4,
+	    eqmc_const_thr1:4,
+	    eqmc_const_thr0:4,
+	    eqmc_threshold3:4,
+	    eqmc_threshold2:4, eqmc_threshold1:4, eqmc_threshold0:4;
+};
+struct DTMB_CHE_EQSC_PICK_THR_BITS {
+	unsigned int eqsc_pick_thr3:8,
+	    eqsc_pick_thr2:8, eqsc_pick_thr1:8, eqsc_pick_thr0:8;
+};
+struct DTMB_CHE_EQSC_THRESHOLD_BITS {
+	unsigned int eqsc_const_thr3:4,
+	    eqsc_const_thr2:4,
+	    eqsc_const_thr1:4,
+	    eqsc_const_thr0:4,
+	    eqsc_threshold3:4,
+	    eqsc_threshold2:4, eqsc_threshold1:4, eqsc_threshold0:4;
+};
+struct DTMB_CHE_PROTECT_GD_TPS_BITS {
+	unsigned int pow_norm:10,
+	    ncoh_thd_tps:3,
+	    coh_thd_tps:3, thr_max:10, protect_gd_tps:5, reserved46:1;
+};
+struct DTMB_CHE_FD_TD_STEPSIZE_THR1_BITS {
+	unsigned int fd_stepsize_thr13:5,
+	    fd_stepsize_thr12:5,
+	    fd_stepsize_thr11:5,
+	    td_stepsize_thr13:5,
+	    td_stepsize_thr12:5, td_stepsize_thr11:5, reserved47:2;
+};
+struct DTMB_CHE_TDFD_SWITCH_SYM1_BITS {
+	unsigned int tdfd_switch_sym00:16, tdfd_switch_sym01:16;
+};
+struct DTMB_CHE_TDFD_SWITCH_SYM2_BITS {
+	unsigned int tdfd_switch_sym10:16, tdfd_switch_sym11:16;
+};
+struct DTMB_CHE_EQ_CONFIG_BITS {
+	unsigned int eq_dsnr_h2drm:6,
+	    eq_cmp_en:1,
+	    eq_imp_setzero_en:1,
+	    dcm_sc_bypass:1,
+	    dcm_mc_bypass:1,
+	    dcm_sc_h_limit:4,
+	    dcm_mc_h_limit:4,
+	    eqsnr_imp_alp:3, eqsnr_avg_alp:3, dcm_alpha:2, reserved48:6;
+};
+struct DTMB_CHE_EQSC_SNR_IMP_THR1_BITS {
+	unsigned int eqsc_snr_imp_thr1:12, eqsc_snr_imp_thr0:12, reserved49:8;
+};
+struct DTMB_CHE_EQSC_SNR_IMP_THR2_BITS {
+	unsigned int eqsc_snr_imp_thr3:12, eqsc_snr_imp_thr2:12, reserved50:8;
+};
+struct DTMB_CHE_EQMC_SNR_IMP_THR1_BITS {
+	unsigned int eqmc_snr_imp_thr1:12, eqmc_snr_imp_thr0:12, reserved51:8;
+};
+struct DTMB_CHE_EQMC_SNR_IMP_THR2_BITS {
+	unsigned int eqmc_snr_imp_thr3:12, eqmc_snr_imp_thr2:12, reserved52:8;
+};
+struct DTMB_CHE_EQSC_SNR_DROP_THR_BITS {
+	unsigned int eqsc_snr_drop_thr3:8,
+	    eqsc_snr_drop_thr2:8, eqsc_snr_drop_thr1:8, eqsc_snr_drop_thr0:8;
+};
+struct DTMB_CHE_EQMC_SNR_DROP_THR_BITS {
+	unsigned int eqmc_snr_drop_thr3:8,
+	    eqmc_snr_drop_thr2:8, eqmc_snr_drop_thr1:8, eqmc_snr_drop_thr0:8;
+};
+struct DTMB_CHE_M_CCI_THR_BITS {
+	unsigned int ccidet_mask_rng_tps:5,
+	    m_cci_thr_tps:10, m_cci_thr_ma_tps:10, reserved53:7;
+};
+struct DTMB_CHE_TPS_MC_BITS {
+	unsigned int tps_mc_run_tim_limit:10,
+	    tps_mc_suc_limit:7, tps_mc_q_thr:7, tps_mc_alpha:3, reserved54:5;
+};
+struct DTMB_CHE_TPS_SC_BITS {
+	unsigned int tps_sc_run_tim_limit:10,
+	    tps_sc_suc_limit:7, tps_sc_q_thr:7, tps_sc_alpha:3, reserved55:5;
+};
+struct DTMB_CHE_CHE_SET_FSM_BITS {
+	unsigned int che_open_loop_len:12,
+	    reserved56:4,
+	    che_set_fsm_st:3, reserved57:1, che_set_fsm_en:1, reserved58:11;
+};
+struct DTMB_CHE_ZERO_NUM_THR_BITS {
+	unsigned int null_frame_thr:16, zero_num_thr:12, reserved59:4;
+};
+struct DTMB_CHE_TIMING_READY_BITS {
+	unsigned int timing_offset:11,
+	    reserved60:5, timing_ready:1, reserved61:15;
+};
+
+#endif
diff --git a/drivers/stream_input/tv_frontend/dtv_demod/include/addr_dtmb_front.h b/drivers/stream_input/tv_frontend/dtv_demod/include/addr_dtmb_front.h
new file mode 100644
index 0000000..bf2f524
--- /dev/null
+++ b/drivers/stream_input/tv_frontend/dtv_demod/include/addr_dtmb_front.h
@@ -0,0 +1,70 @@
+/*
+* Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT
+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+* more details.
+*
+* You should have received a copy of the GNU General Public License along
+* with this program; if not, write to the Free Software Foundation, Inc.,
+* 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+*
+* Description:
+*/
+#ifndef __ADDR_DTMB_FRONT_H__
+#define __ADDR_DTMB_FRONT_H__
+
+#include "addr_dtmb_top.h"
+
+#define  DTMB_FRONT_ADDR(x) (DTMB_DEMOD_BASE + (x << 2))
+
+#define  DTMB_FRONT_AFIFO_ADC                 DTMB_FRONT_ADDR(0x20)
+#define  DTMB_FRONT_AGC_CONFIG1               DTMB_FRONT_ADDR(0x21)
+#define  DTMB_FRONT_AGC_CONFIG2               DTMB_FRONT_ADDR(0x22)
+#define  DTMB_FRONT_AGC_CONFIG3               DTMB_FRONT_ADDR(0x23)
+#define  DTMB_FRONT_AGC_CONFIG4               DTMB_FRONT_ADDR(0x24)
+#define  DTMB_FRONT_DDC_BYPASS                DTMB_FRONT_ADDR(0x25)
+#define  DTMB_FRONT_DC_HOLD                   DTMB_FRONT_ADDR(0x28)
+#define  DTMB_FRONT_DAGC_TARGET_POWER         DTMB_FRONT_ADDR(0x29)
+#define  DTMB_FRONT_ACF_BYPASS                DTMB_FRONT_ADDR(0x2a)
+#define  DTMB_FRONT_COEF_SET1                 DTMB_FRONT_ADDR(0x2b)
+#define  DTMB_FRONT_COEF_SET2                 DTMB_FRONT_ADDR(0x2c)
+#define  DTMB_FRONT_COEF_SET3                 DTMB_FRONT_ADDR(0x2d)
+#define  DTMB_FRONT_COEF_SET4                 DTMB_FRONT_ADDR(0x2e)
+#define  DTMB_FRONT_COEF_SET5                 DTMB_FRONT_ADDR(0x2f)
+#define  DTMB_FRONT_COEF_SET6                 DTMB_FRONT_ADDR(0x30)
+#define  DTMB_FRONT_COEF_SET7                 DTMB_FRONT_ADDR(0x31)
+#define  DTMB_FRONT_COEF_SET8                 DTMB_FRONT_ADDR(0x32)
+#define  DTMB_FRONT_COEF_SET9                 DTMB_FRONT_ADDR(0x33)
+#define  DTMB_FRONT_COEF_SET10                DTMB_FRONT_ADDR(0x34)
+#define  DTMB_FRONT_COEF_SET11                DTMB_FRONT_ADDR(0x35)
+#define  DTMB_FRONT_COEF_SET12                DTMB_FRONT_ADDR(0x36)
+#define  DTMB_FRONT_COEF_SET13                DTMB_FRONT_ADDR(0x37)
+#define  DTMB_FRONT_COEF_SET14                DTMB_FRONT_ADDR(0x38)
+#define  DTMB_FRONT_COEF_SET15                DTMB_FRONT_ADDR(0x39)
+#define  DTMB_FRONT_COEF_SET16                DTMB_FRONT_ADDR(0x3a)
+#define  DTMB_FRONT_COEF_SET17                DTMB_FRONT_ADDR(0x3b)
+#define  DTMB_FRONT_COEF_SET18                DTMB_FRONT_ADDR(0x3c)
+#define  DTMB_FRONT_COEF_SET19                DTMB_FRONT_ADDR(0x3d)
+#define  DTMB_FRONT_SRC_CONFIG1               DTMB_FRONT_ADDR(0x3e)
+#define  DTMB_FRONT_SRC_CONFIG2               DTMB_FRONT_ADDR(0x3f)
+#define  DTMB_FRONT_SFIFO_OUT_LEN             DTMB_FRONT_ADDR(0x40)
+#define  DTMB_FRONT_DAGC_GAIN                 DTMB_FRONT_ADDR(0x41)
+#define  DTMB_FRONT_IQIB_STEP                 DTMB_FRONT_ADDR(0x42)
+#define  DTMB_FRONT_IQIB_CONFIG               DTMB_FRONT_ADDR(0x43)
+#define  DTMB_FRONT_ST_CONFIG                 DTMB_FRONT_ADDR(0x44)
+#define  DTMB_FRONT_ST_FREQ                   DTMB_FRONT_ADDR(0x45)
+#define  DTMB_FRONT_46_CONFIG                   DTMB_FRONT_ADDR(0x46)
+#define  DTMB_FRONT_47_CONFIG                   DTMB_FRONT_ADDR(0x47)
+#define  DTMB_FRONT_DEBUG_CFG                  DTMB_FRONT_ADDR(0x48)
+#define  DTMB_FRONT_MEM_ADDR                  DTMB_FRONT_ADDR(0x49)
+#define  DTMB_FRONT_19_CONFIG                   DTMB_FRONT_ADDR(0x19)
+#define  DTMB_FRONT_4d_CONFIG                   DTMB_FRONT_ADDR(0x4d)
+
+#endif
diff --git a/drivers/stream_input/tv_frontend/dtv_demod/include/addr_dtmb_front_bit.h b/drivers/stream_input/tv_frontend/dtv_demod/include/addr_dtmb_front_bit.h
new file mode 100644
index 0000000..ec74d23
--- /dev/null
+++ b/drivers/stream_input/tv_frontend/dtv_demod/include/addr_dtmb_front_bit.h
@@ -0,0 +1,331 @@
+/*
+* Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT
+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+* more details.
+*
+* You should have received a copy of the GNU General Public License along
+* with this program; if not, write to the Free Software Foundation, Inc.,
+* 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+*
+* Description:
+*/
+#ifndef __ADDR_DTMB_FRONT_BIT_H__
+#define __ADDR_DTMB_FRONT_BIT_H__
+
+union   DTMB_FRONT_AFIFO_ADC_BITS {
+	unsigned int d32;
+	struct {
+		unsigned int afifo_nco_rate:8,
+			     afifo_data_format:1,
+			     afifo_bypass:1,
+			     adc_sample:6,
+			     adc_IQ:1,
+			     reserved0:15;
+	} b;
+};
+struct  DTMB_FRONT_AGC_CONFIG1_BITS {
+	unsigned int agc_target:4,
+		     agc_cal_intv:2,
+		     reserved1:2,
+		     agc_gain_step2:6,
+		     reserved2:2,
+		     agc_gain_step1:6,
+		     reserved3:2,
+		     agc_a_filter_coef2:3,
+		     reserved4:1,
+		     agc_a_filter_coef1:3,
+		     reserved5:1;
+};
+struct  DTMB_FRONT_AGC_CONFIG2_BITS {
+	unsigned int agc_imp_thresh:4,
+		     agc_imp_en:1,
+		     agc_iq_exchange:1,
+		     reserved6:2,
+		     agc_clip_ratio:5,
+		     reserved7:3,
+		     agc_signal_clip_thr:6,
+		     reserved8:2,
+		     agc_sd_rate:7,
+		     reserved9:1;
+};
+struct  DTMB_FRONT_AGC_CONFIG3_BITS {
+	unsigned int agc_rffb_value:11,
+		     reserved10:1,
+		     agc_iffb_value:11,
+		     reserved11:1,
+		     agc_gain_step_rf:1,
+		     agc_rfgain_freeze:1,
+		     agc_tuning_slope:1,
+		     agc_rffb_set:1,
+		     agc_gain_step_if:1,
+		     agc_ifgain_freeze:1,
+		     agc_if_only:1,
+		     agc_iffb_set:1;
+};
+struct  DTMB_FRONT_AGC_CONFIG4_BITS {
+	unsigned int agc_rffb_gain_sat_i:8,
+		     agc_rffb_gain_sat:8,
+		     agc_iffb_gain_sat_i:8,
+		     agc_iffb_gain_sat:8;
+};
+struct  DTMB_FRONT_DDC_BYPASS_BITS {
+	unsigned int ddc_phase:25,
+		     reserved12:3,
+		     ddc_bypass:1,
+		     reserved13:3;
+};
+struct  DTMB_FRONT_DC_HOLD_BITS {
+	unsigned int dc_hold:1,
+		     dc_alpha:3,
+		     mobi_det_accu_len:3,
+		     reserved14:1,
+		     mobi_det_observe_len:3,
+		     reserved15:1,
+		     channel_static_th:4,
+		     channel_portable_th:4,
+		     dc_bypass:1,
+		     reserved16:3,
+		     dc_len:3,
+		     reserved17:5;
+};
+struct  DTMB_FRONT_DAGC_TARGET_POWER_BITS {
+	unsigned int dagc_target_power_l:8,
+		     dagc_target_power_h:8,
+		     dagc_target_power_ler:8,
+		     dagc_target_power_her:8;
+};
+struct  DTMB_FRONT_ACF_BYPASS_BITS {
+	unsigned int coef65:11,
+		     reserved18:1,
+		     coef66:11,
+		     reserved19:1,
+		     acf_bypass:1,
+		     reserved20:7;
+};
+struct  DTMB_FRONT_COEF_SET1_BITS {
+	unsigned int coef63:11,
+		     reserved21:1,
+		     coef64:11,
+		     reserved22:9;
+};
+struct  DTMB_FRONT_COEF_SET2_BITS {
+	unsigned int coef62:10,
+		     reserved23:22;
+};
+struct  DTMB_FRONT_COEF_SET3_BITS {
+	unsigned int coef60:10,
+		     reserved24:2,
+		     coef61:10,
+		     reserved25:10;
+};
+struct  DTMB_FRONT_COEF_SET4_BITS {
+	unsigned int coef59:9,
+		     reserved26:23;
+};
+struct  DTMB_FRONT_COEF_SET5_BITS {
+	unsigned int coef57:9,
+		     reserved27:3,
+		     coef58:9,
+		     reserved28:11;
+};
+struct  DTMB_FRONT_COEF_SET6_BITS {
+	unsigned int coef54:8,
+		     coef55:8,
+		     coef56:8,
+		     reserved29:8;
+};
+struct  DTMB_FRONT_COEF_SET7_BITS {
+	unsigned int coef53:7,
+		     reserved30:25;
+};
+struct  DTMB_FRONT_COEF_SET8_BITS {
+	unsigned int coef49:7,
+		     reserved31:1,
+		     coef50:7,
+		     reserved32:1,
+		     coef51:7,
+		     reserved33:1,
+		     coef52:7,
+		     reserved34:1;
+};
+struct  DTMB_FRONT_COEF_SET9_BITS {
+	unsigned int coef45:7,
+		     reserved35:1,
+		     coef46:7,
+		     reserved36:1,
+		     coef47:7,
+		     reserved37:1,
+		     coef48:7,
+		     reserved38:1;
+};
+struct  DTMB_FRONT_COEF_SET10_BITS {
+	unsigned int coef42:6,
+		     reserved39:2,
+		     coef43:6,
+		     reserved40:2,
+		     coef44:6,
+		     reserved41:10;
+};
+struct  DTMB_FRONT_COEF_SET11_BITS {
+	unsigned int coef38:6,
+		     reserved42:2,
+		     coef39:6,
+		     reserved43:2,
+		     coef40:6,
+		     reserved44:2,
+		     coef41:6,
+		     reserved45:2;
+};
+struct  DTMB_FRONT_COEF_SET12_BITS {
+	unsigned int coef34:6,
+		     reserved46:2,
+		     coef35:6,
+		     reserved47:2,
+		     coef36:6,
+		     reserved48:2,
+		     coef37:6,
+		     reserved49:2;
+};
+struct  DTMB_FRONT_COEF_SET13_BITS {
+	unsigned int coef30:6,
+		     reserved50:2,
+		     coef31:6,
+		     reserved51:2,
+		     coef32:6,
+		     reserved52:2,
+		     coef33:6,
+		     reserved53:2;
+};
+struct  DTMB_FRONT_COEF_SET14_BITS {
+	unsigned int coef27:5,
+		     reserved54:3,
+		     coef28:5,
+		     reserved55:3,
+		     coef29:5,
+		     reserved56:11;
+};
+struct  DTMB_FRONT_COEF_SET15_BITS {
+	unsigned int coef23:5,
+		     reserved57:3,
+		     coef24:5,
+		     reserved58:3,
+		     coef25:5,
+		     reserved59:3,
+		     coef26:5,
+		     reserved60:3;
+};
+struct  DTMB_FRONT_COEF_SET16_BITS {
+	unsigned int coef19:5,
+		     reserved61:3,
+		     coef20:5,
+		     reserved62:3,
+		     coef21:5,
+		     reserved63:3,
+		     coef22:5,
+		     reserved64:3;
+};
+struct  DTMB_FRONT_COEF_SET17_BITS {
+	unsigned int coef15:5,
+		     reserved65:3,
+		     coef16:5,
+		     reserved66:3,
+		     coef17:5,
+		     reserved67:3,
+		     coef18:5,
+		     reserved68:3;
+};
+struct  DTMB_FRONT_COEF_SET18_BITS {
+	unsigned int coef08:4,
+		     coef09:4,
+		     coef10:4,
+		     coef11:4,
+		     coef12:4,
+		     coef13:4,
+		     coef14:4,
+		     reserved69:4;
+};
+struct  DTMB_FRONT_COEF_SET19_BITS {
+	unsigned int coef00:4,
+		     coef01:4,
+		     coef02:4,
+		     coef03:4,
+		     coef04:4,
+		     coef05:4,
+		     coef06:4,
+		     coef07:4;
+};
+struct  DTMB_FRONT_SRC_CONFIG1_BITS {
+	unsigned int src_norm_inrate:24,
+		     src_tim_shr:4,
+		     src_ted_disable:1,
+		     reserved70:3;
+};
+struct  DTMB_FRONT_SRC_CONFIG2_BITS {
+	unsigned int src_stable_timeout:4,
+		     src_seg_len:3,
+		     reserved71:1,
+		     src_ted_beta:3,
+		     reserved72:1,
+		     src_time_err_thr:4,
+		     src_time_mu1:5,
+		     reserved73:3,
+		     src_time_mu2:5,
+		     reserved74:3;
+};
+struct  DTMB_FRONT_SFIFO_OUT_LEN_BITS {
+	unsigned int sfifo_out_len:4,
+		     reserved75:28;
+};
+struct  DTMB_FRONT_DAGC_GAIN_BITS {
+	unsigned int dagc_bypass:1,
+		     dagc_power_alpha:2,
+		     dagc_bw:3,
+		     dagc_gain_ctrl:12,
+		     dagc_gain_step_er:6,
+		     dagc_gain_step:6,
+		     reserved76:2;
+};
+struct  DTMB_FRONT_IQIB_STEP_BITS {
+	unsigned int iqib_step_b:2,
+		     iqib_step_a:2,
+		     iqib_period:3,
+		     reserved77:1,
+		     iqib_bypass:1,
+		     reserved78:23;
+};
+struct  DTMB_FRONT_IQIB_CONFIG_BITS {
+	unsigned int iqib_set_b:12,
+		     iqib_set_a:10,
+		     reserved79:2,
+		     iqib_set_val:1,
+		     iqib_hold:1,
+		     reserved80:6;
+};
+struct  DTMB_FRONT_ST_CONFIG_BITS {
+	unsigned int st_enable:1,
+		     reserved81:3,
+		     st_dc_len:3,
+		     reserved82:1,
+		     st_alpha:3,
+		     reserved83:1,
+		     st_Q_thrsh:8,
+		     st_dist:3,
+		     reserved84:1,
+		     st_len:5,
+		     reserved85:3;
+};
+struct  DTMB_FRONT_ST_FREQ_BITS {
+	unsigned int st_freq_v:1,
+		     st_freq_i:19,
+		     reserved86:12;
+};
+
+#endif
diff --git a/drivers/stream_input/tv_frontend/dtv_demod/include/addr_dtmb_sync.h b/drivers/stream_input/tv_frontend/dtv_demod/include/addr_dtmb_sync.h
new file mode 100644
index 0000000..0607b19
--- /dev/null
+++ b/drivers/stream_input/tv_frontend/dtv_demod/include/addr_dtmb_sync.h
@@ -0,0 +1,53 @@
+/*
+* Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT
+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+* more details.
+*
+* You should have received a copy of the GNU General Public License along
+* with this program; if not, write to the Free Software Foundation, Inc.,
+* 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+*
+* Description:
+*/
+#ifndef __ADDR_DTMB_SYNC_H__
+#define __ADDR_DTMB_SYNC_H__
+
+#include "addr_dtmb_top.h"
+#define  DTMB_SYNC_ADDR(x) (DTMB_DEMOD_BASE + (x << 2))
+
+#define  DTMB_SYNC_TS_CFO_PN_VALUE           DTMB_SYNC_ADDR(0x57)
+#define  DTMB_SYNC_TS_CFO_ERR_LIMIT          DTMB_SYNC_ADDR(0x58)
+#define  DTMB_SYNC_TS_CFO_PN_MODIFY          DTMB_SYNC_ADDR(0x59)
+#define  DTMB_SYNC_TS_GAIN                   DTMB_SYNC_ADDR(0x5a)
+#define  DTMB_SYNC_FE_CONFIG                 DTMB_SYNC_ADDR(0x5b)
+#define  DTMB_SYNC_PNPHASE_OFFSET            DTMB_SYNC_ADDR(0x5c)
+#define  DTMB_SYNC_PNPHASE_CONFIG            DTMB_SYNC_ADDR(0x5d)
+#define  DTMB_SYNC_SFO_SFO_PN0_MODIFY        DTMB_SYNC_ADDR(0x5e)
+#define  DTMB_SYNC_SFO_SFO_PN1_MODIFY        DTMB_SYNC_ADDR(0x5f)
+#define  DTMB_SYNC_SFO_SFO_PN2_MODIFY        DTMB_SYNC_ADDR(0x60)
+#define  DTMB_SYNC_SFO_CONFIG                DTMB_SYNC_ADDR(0x61)
+#define  DTMB_SYNC_FEC_CFG                   DTMB_SYNC_ADDR(0x67)
+#define  DTMB_SYNC_FEC_DEBUG_CFG             DTMB_SYNC_ADDR(0x68)
+#define  DTMB_SYNC_DATA_DDR_ADR              DTMB_SYNC_ADDR(0x69)
+#define  DTMB_SYNC_DEBUG_DDR_ADR             DTMB_SYNC_ADDR(0x6a)
+#define  DTMB_SYNC_FEC_SIM_CFG1              DTMB_SYNC_ADDR(0x6b)
+#define  DTMB_SYNC_FEC_SIM_CFG2              DTMB_SYNC_ADDR(0x6c)
+#define  DTMB_SYNC_TRACK_CFO_MAX             DTMB_SYNC_ADDR(0x6d)
+#define  DTMB_SYNC_CCI_DAGC_CONFIG1          DTMB_SYNC_ADDR(0x6e)
+#define  DTMB_SYNC_CCI_DAGC_CONFIG2          DTMB_SYNC_ADDR(0x6f)
+#define  DTMB_SYNC_CCI_RP                    DTMB_SYNC_ADDR(0x70)
+#define  DTMB_SYNC_CCI_DET_THRES             DTMB_SYNC_ADDR(0x71)
+#define  DTMB_SYNC_CCI_NOTCH1_CONFIG1        DTMB_SYNC_ADDR(0x72)
+#define  DTMB_SYNC_CCI_NOTCH1_CONFIG2        DTMB_SYNC_ADDR(0x73)
+#define  DTMB_SYNC_CCI_NOTCH2_CONFIG1        DTMB_SYNC_ADDR(0x74)
+#define  DTMB_SYNC_CCI_NOTCH2_CONFIG2        DTMB_SYNC_ADDR(0x75)
+
+#endif
diff --git a/drivers/stream_input/tv_frontend/dtv_demod/include/addr_dtmb_sync_bit.h b/drivers/stream_input/tv_frontend/dtv_demod/include/addr_dtmb_sync_bit.h
new file mode 100644
index 0000000..0aebdd1
--- /dev/null
+++ b/drivers/stream_input/tv_frontend/dtv_demod/include/addr_dtmb_sync_bit.h
@@ -0,0 +1,110 @@
+/*
+* Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT
+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+* more details.
+*
+* You should have received a copy of the GNU General Public License along
+* with this program; if not, write to the Free Software Foundation, Inc.,
+* 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+*
+* Description:
+*/
+#ifndef __ADDR_DTMB_SYNC_BIT_H__
+#define __ADDR_DTMB_SYNC_BIT_H__
+
+struct DTMB_SYNC_TS_CFO_PN_VALUE_BITS {
+	unsigned int ts_cfo_pn1_value:16, ts_cfo_pn0_value:16;
+};
+struct DTMB_SYNC_TS_CFO_ERR_LIMIT_BITS {
+	unsigned int ts_cfo_err_limit:16, ts_cfo_pn2_value:16;
+};
+struct DTMB_SYNC_TS_CFO_PN_MODIFY_BITS {
+	unsigned int ts_cfo_pn1_modify:16, ts_cfo_pn0_modify:16;
+};
+struct DTMB_SYNC_TS_GAIN_BITS {
+	unsigned int ts_gain:2,
+	    reserved0:2,
+	    ts_sat_shift:3,
+	    reserved1:1,
+	    ts_fixpn_en:1,
+	    ts_fixpn:2, reserved2:1, ts_cfo_cut:4, ts_cfo_pn2_modify:16;
+};
+struct DTMB_SYNC_FE_CONFIG_BITS {
+	unsigned int fe_lock_len:4,
+	    fe_sat_shift:3, reserved3:1, fe_cut:4, reserved4:4, fe_modify:16;
+};
+struct DTMB_SYNC_PNPHASE_OFFSET_BITS {
+	unsigned int pnphase_offset2:4,
+	    pnphase_offset1:4, pnphase_offset0:4, reserved5:20;
+};
+struct DTMB_SYNC_PNPHASE_CONFIG_BITS {
+	unsigned int pnphase_gain:2,
+	    reserved6:2,
+	    pnphase_sat_shift:4, pnphase_cut:4, reserved7:4, pnphase_modify:16;
+};
+struct DTMB_SYNC_SFO_SFO_PN0_MODIFY_BITS {
+	unsigned int sfo_cfo_pn0_modify:16, sfo_sfo_pn0_modify:16;
+};
+struct DTMB_SYNC_SFO_SFO_PN1_MODIFY_BITS {
+	unsigned int sfo_cfo_pn1_modify:16, sfo_sfo_pn1_modify:16;
+};
+struct DTMB_SYNC_SFO_SFO_PN2_MODIFY_BITS {
+	unsigned int sfo_cfo_pn2_modify:16, sfo_sfo_pn2_modify:16;
+};
+struct DTMB_SYNC_SFO_CONFIG_BITS {
+	unsigned int sfo_sat_shift:4,
+	    sfo_gain:2,
+	    reserved8:2,
+	    sfo_dist:2,
+	    reserved9:2,
+	    sfo_cfo_cut:4, sfo_sfo_cut:4, sfo_cci_th:4, reserved10:8;
+};
+struct DTMB_SYNC_TRACK_CFO_MAX_BITS {
+	unsigned int track_cfo_max:8,
+	    track_sfo_max:8, track_max_en:1, ctrl_fe_to_th:4, reserved11:11;
+};
+struct DTMB_SYNC_CCI_DAGC_CONFIG1_BITS {
+	unsigned int cci_dagc_bypass:1,
+	    cci_dagc_power_alpha:2,
+	    cci_dagc_bw:3,
+	    cci_dagc_gain_ctrl:12,
+	    cci_dagc_gain_step_er:6, cci_dagc_gain_step:6, reserved12:2;
+};
+struct DTMB_SYNC_CCI_DAGC_CONFIG2_BITS {
+	unsigned int cci_dagc_target_power_l:8,
+	    cci_dagc_target_power_h:8,
+	    cci_dagc_target_power_ler:8, cci_dagc_target_power_her:8;
+};
+struct DTMB_SYNC_CCI_RP_BITS {
+	unsigned int cci_rpsq_n:10, reserved13:2, cci_rp_n:13, reserved14:7;
+};
+struct DTMB_SYNC_CCI_DET_THRES_BITS {
+	unsigned int cci_avr_times:5,
+	    reserved15:3, cci_det_thres:3, reserved16:21;
+};
+struct DTMB_SYNC_CCI_NOTCH1_CONFIG1_BITS {
+	unsigned int cci_notch1_a1:10,
+	    reserved17:2, cci_notch1_en:1, reserved18:19;
+};
+struct DTMB_SYNC_CCI_NOTCH1_CONFIG2_BITS {
+	unsigned int cci_notch1_b1:10,
+	    reserved19:2, cci_notch1_a2:10, reserved20:10;
+};
+struct DTMB_SYNC_CCI_NOTCH2_CONFIG1_BITS {
+	unsigned int cci_notch2_a1:10,
+	    reserved21:2, cci_notch2_en:1, reserved22:3, cci_mpthres:16;
+};
+struct DTMB_SYNC_CCI_NOTCH2_CONFIG2_BITS {
+	unsigned int cci_notch2_b1:10,
+	    reserved23:2, cci_notch2_a2:10, reserved24:10;
+};
+
+#endif
diff --git a/drivers/stream_input/tv_frontend/dtv_demod/include/addr_dtmb_top.h b/drivers/stream_input/tv_frontend/dtv_demod/include/addr_dtmb_top.h
new file mode 100644
index 0000000..c12d26f
--- /dev/null
+++ b/drivers/stream_input/tv_frontend/dtv_demod/include/addr_dtmb_top.h
@@ -0,0 +1,90 @@
+/*
+* Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT
+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+* more details.
+*
+* You should have received a copy of the GNU General Public License along
+* with this program; if not, write to the Free Software Foundation, Inc.,
+* 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+*
+* Description:
+*/
+#ifndef __ADDR_DTMB_TOP_H__
+#define __ADDR_DTMB_TOP_H__
+
+#include "addr_dtmb_top_bit.h"
+#include "addr_dtmb_sync.h"
+#include "addr_dtmb_sync_bit.h"
+#include "addr_dtmb_che.h"
+#include "addr_dtmb_che_bit.h"
+#include "addr_dtmb_front.h"
+#include "addr_dtmb_front_bit.h"
+
+#define DTMB_DEMOD_BASE DEMOD_REG_ADDR(0x0)
+#define  DTMB_TOP_ADDR(x) (DTMB_DEMOD_BASE + (x << 2))
+
+#define  DTMB_TOP_CTRL_SW_RST               DTMB_TOP_ADDR(0x1)
+#define  DTMB_TOP_TESTBUS                   DTMB_TOP_ADDR(0x2)
+#define  DTMB_TOP_TB                        DTMB_TOP_ADDR(0x3)
+#define  DTMB_TOP_TB_V                      DTMB_TOP_ADDR(0x4)
+#define  DTMB_TOP_TB_ADDR_BEGIN             DTMB_TOP_ADDR(0x5)
+#define  DTMB_TOP_TB_ADDR_END               DTMB_TOP_ADDR(0x6)
+#define  DTMB_TOP_CTRL_ENABLE               DTMB_TOP_ADDR(0x7)
+#define  DTMB_TOP_CTRL_LOOP                 DTMB_TOP_ADDR(0x8)
+#define  DTMB_TOP_CTRL_FSM                  DTMB_TOP_ADDR(0x9)
+#define  DTMB_TOP_CTRL_AGC                  DTMB_TOP_ADDR(0xa)
+#define  DTMB_TOP_CTRL_TS_SFO_CFO           DTMB_TOP_ADDR(0xb)
+#define  DTMB_TOP_CTRL_FEC                  DTMB_TOP_ADDR(0xc)
+#define  DTMB_TOP_CTRL_INTLV_TIME           DTMB_TOP_ADDR(0xd)
+#define  DTMB_TOP_CTRL_DAGC_CCI             DTMB_TOP_ADDR(0xe)
+#define  DTMB_TOP_CTRL_TPS                  DTMB_TOP_ADDR(0xf)
+#define  DTMB_TOP_TPS_BIT                   DTMB_TOP_ADDR(0x10)
+#define  DTMB_TOP_CCI_FLG                   DTMB_TOP_ADDR(0xc7)
+#define  DTMB_TOP_TESTBUS_OUT               DTMB_TOP_ADDR(0xc8)
+#define  DTMB_TOP_TBUS_DC_ADDR              DTMB_TOP_ADDR(0xc9)
+#define  DTMB_TOP_FRONT_IQIB_CHECK          DTMB_TOP_ADDR(0xca)
+#define  DTMB_TOP_SYNC_TS                   DTMB_TOP_ADDR(0xcb)
+#define  DTMB_TOP_SYNC_PNPHASE              DTMB_TOP_ADDR(0xcd)
+#define  DTMB_TOP_CTRL_DDC_ICFO             DTMB_TOP_ADDR(0xd2)
+#define  DTMB_TOP_CTRL_DDC_FCFO             DTMB_TOP_ADDR(0xd3)
+#define  DTMB_TOP_CTRL_FSM_STATE0           DTMB_TOP_ADDR(0xd4)
+#define  DTMB_TOP_CTRL_FSM_STATE1           DTMB_TOP_ADDR(0xd5)
+#define  DTMB_TOP_CTRL_FSM_STATE2           DTMB_TOP_ADDR(0xd6)
+#define  DTMB_TOP_CTRL_FSM_STATE3           DTMB_TOP_ADDR(0xd7)
+#define  DTMB_TOP_CTRL_TS2                  DTMB_TOP_ADDR(0xd8)
+#define  DTMB_TOP_FRONT_AGC                 DTMB_TOP_ADDR(0xd9)
+#define  DTMB_TOP_FRONT_DAGC                DTMB_TOP_ADDR(0xda)
+#define  DTMB_TOP_FEC_TIME_STS              DTMB_TOP_ADDR(0xdb)
+#define  DTMB_TOP_FEC_LDPC_STS              DTMB_TOP_ADDR(0xdc)
+#define  DTMB_TOP_FEC_LDPC_IT_AVG           DTMB_TOP_ADDR(0xdd)
+#define  DTMB_TOP_FEC_LDPC_UNC_ACC          DTMB_TOP_ADDR(0xde)
+#define  DTMB_TOP_FEC_BCH_ACC               DTMB_TOP_ADDR(0xdf)
+#define  DTMB_TOP_CTRL_ICFO_ALL             DTMB_TOP_ADDR(0xe0)
+#define  DTMB_TOP_CTRL_FCFO_ALL             DTMB_TOP_ADDR(0xe1)
+#define  DTMB_TOP_CTRL_SFO_ALL              DTMB_TOP_ADDR(0xe2)
+#define  DTMB_TOP_FEC_LOCK_SNR              DTMB_TOP_ADDR(0xe3)
+#define  DTMB_TOP_CHE_SEG_FACTOR            DTMB_TOP_ADDR(0xe4)
+#define  DTMB_TOP_CTRL_CHE_WORKCNT          DTMB_TOP_ADDR(0xe5)
+#define  DTMB_TOP_CHE_OBS_STATE1            DTMB_TOP_ADDR(0xe6)
+#define  DTMB_TOP_CHE_OBS_STATE2            DTMB_TOP_ADDR(0xe7)
+#define  DTMB_TOP_CHE_OBS_STATE3            DTMB_TOP_ADDR(0xe8)
+#define  DTMB_TOP_CHE_OBS_STATE4            DTMB_TOP_ADDR(0xe9)
+#define  DTMB_TOP_CHE_OBS_STATE5            DTMB_TOP_ADDR(0xea)
+#define  DTMB_TOP_SYNC_CCI_NF1              DTMB_TOP_ADDR(0xee)
+#define  DTMB_TOP_SYNC_CCI_NF2              DTMB_TOP_ADDR(0xef)
+#define  DTMB_TOP_SYNC_CCI_NF2_POSITION     DTMB_TOP_ADDR(0xf0)
+#define  DTMB_TOP_CTRL_SYS_OFDM_CNT         DTMB_TOP_ADDR(0xf1)
+#define  DTMB_TOP_CTRL_TPS_Q_FINAL          DTMB_TOP_ADDR(0xf2)
+#define  DTMB_TOP_FRONT_DC                  DTMB_TOP_ADDR(0xf3)
+#define  DTMB_TOP_CHE_DEBUG                 DTMB_TOP_ADDR(0xf6)
+#define  DTMB_TOP_CTRL_TOTPS_READY_CNT      DTMB_TOP_ADDR(0xff)
+
+#endif
diff --git a/drivers/stream_input/tv_frontend/dtv_demod/include/addr_dtmb_top_bit.h b/drivers/stream_input/tv_frontend/dtv_demod/include/addr_dtmb_top_bit.h
new file mode 100644
index 0000000..63233c4
--- /dev/null
+++ b/drivers/stream_input/tv_frontend/dtv_demod/include/addr_dtmb_top_bit.h
@@ -0,0 +1,178 @@
+/*
+* Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT
+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+* more details.
+*
+* You should have received a copy of the GNU General Public License along
+* with this program; if not, write to the Free Software Foundation, Inc.,
+* 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+*
+* Description:
+*/
+#ifndef __ADDR_DTMB_TOP_BIT_H__
+#define __ADDR_DTMB_TOP_BIT_H__
+
+union DTMB_TOP_CTRL_SW_RST_BITS {
+	unsigned int d32;
+	struct {
+		unsigned int ctrl_sw_rst:1, ctrl_sw_rst_noreg:1, reserved0:30;
+	} b;
+};
+struct DTMB_TOP_TESTBUS_BITS {
+	unsigned int testbus_addr:16, testbus_en:1, reserved1:15;
+};
+struct DTMB_TOP_TB_BITS {
+	unsigned int tb_act_width:5,
+	    reserved2:3,
+	    tb_dc_mk:3,
+	    reserved3:1, tb_capture_stop:1, tb_self_test:1, reserved4:18;
+};
+struct DTMB_TOP_CTRL_ENABLE_BITS {
+	unsigned int ctrl_enable:24, reserved5:8;
+};
+struct DTMB_TOP_CTRL_LOOP_BITS {
+	unsigned int ctrl_src_pnphase_loop:1,
+	    ctrl_src_sfo_loop:1,
+	    ctrl_ddc_fcfo_loop:1, ctrl_ddc_icfo_loop:1, reserved6:28;
+};
+struct DTMB_TOP_CTRL_FSM_BITS {
+	unsigned int ctrl_fsm_state:5,
+	    reserved7:3,
+	    ctrl_fsm_v:1, reserved8:3, ctrl_reset_state:4, reserved9:16;
+};
+struct DTMB_TOP_CTRL_AGC_BITS {
+	unsigned int ctrl_fast_agc:1,
+	    ctrl_agc_bypass:1,
+	    ts_cfo_bypass:1, sfo_strong0_bypass:1, reserved10:28;
+};
+struct DTMB_TOP_CTRL_TS_SFO_CFO_BITS {
+	unsigned int ctrl_ts_q:10,
+	    reserved11:2,
+	    ctrl_pnphase_q:7, reserved12:1, ctrl_sfo_q:4, ctrl_cfo_q:8;
+};
+struct DTMB_TOP_CTRL_FEC_BITS {
+	unsigned int reserved13:8,
+	    ctrl_ts_to_th:4,
+	    ctrl_pnphase_to_th:4,
+	    ctrl_sfo_to_th:4,
+	    ctrl_fe_to_th:4, ctrl_che_to_th:4, ctrl_fec_to_th:4;
+};
+struct DTMB_TOP_CTRL_INTLV_TIME_BITS {
+	unsigned int ctrl_intlv720_time:12, ctrl_intlv240_time:12, reserved14:8;
+};
+struct DTMB_TOP_CTRL_DAGC_CCI_BITS {
+	unsigned int dagc_mode:2,
+	    cci_dagc_mode:2,
+	    cci_bypass:1,
+	    fe_bypass:1,
+	    reserved15:1,
+	    new_sync1:1, new_sync2:1, fec_inzero_check:1, reserved16:22;
+};
+struct DTMB_TOP_CTRL_TPS_BITS {
+	unsigned int sfo_gain:2,
+	    freq_reverse:1,
+	    qam4_nr:1,
+	    intlv_mode:1,
+	    code_rate:2,
+	    constell:2,
+	    tps_carrier_mode:1,
+	    freq_reverse_known:1, tps_known:1, ctrl_tps_to_th:4, reserved17:16;
+};
+struct DTMB_TOP_CCI_FLG_BITS {
+	unsigned int cci_flg_cnt:8, m_cci_ready:1, reserved18:23;
+};
+struct DTMB_TOP_FRONT_IQIB_CHECK_BITS {
+	unsigned int front_iqib_check_b:12,
+	    front_iqib_check_a:10, reserved19:10;
+};
+struct DTMB_TOP_SYNC_TS_BITS {
+	unsigned int sync_ts_idx:2, sync_ts_pos:13, sync_ts_q:10, reserved20:7;
+};
+struct DTMB_TOP_SYNC_PNPHASE_BITS {
+	unsigned int sync_pnphase_max_q_idx:2,
+	    sync_pnphase:8, sync_pnphase_max_q:7, reserved21:15;
+};
+struct DTMB_TOP_CTRL_DDC_ICFO_BITS {
+	unsigned int ctrl_ddc_icfo:20, reserved22:12;
+};
+struct DTMB_TOP_CTRL_DDC_FCFO_BITS {
+	unsigned int ctrl_src_sfo:17, ctrl_ddc_fcfo:14, reserved23:1;
+};
+struct DTMB_TOP_CTRL_TS2_BITS {
+	unsigned int ctrl_ts2_workcnt:8,
+	    ctrl_pnphase_workcnt:8, ctrl_sfo_workcnt:8, sync_fe_workcnt:8;
+};
+struct DTMB_TOP_FRONT_AGC_BITS {
+	unsigned int front_agc_if_gain:11,
+	    front_agc_rf_gain:11, front_agc_power:10;
+};
+struct DTMB_TOP_FRONT_DAGC_BITS {
+	unsigned int front_dagc_power:8, front_dagc_gain:12, reserved24:12;
+};
+struct DTMB_TOP_FEC_LDPC_IT_AVG_BITS {
+	unsigned int fec_ldpc_it_avg:16, fec_ldpc_per_rpt:13, reserved25:3;
+};
+struct DTMB_TOP_CTRL_ICFO_ALL_BITS {
+	unsigned int ctrl_icfo_all:20, reserved26:12;
+};
+struct DTMB_TOP_CTRL_FCFO_ALL_BITS {
+	unsigned int ctrl_fcfo_all:20, reserved27:12;
+};
+struct DTMB_TOP_CTRL_SFO_ALL_BITS {
+	unsigned int ctrl_sfo_all:25, reserved28:7;
+};
+struct DTMB_TOP_FEC_LOCK_SNR_BITS {
+	unsigned int che_snr:14,
+	    fec_lock:1, reserved29:1, che_snr_average:14, reserved30:2;
+};
+struct DTMB_TOP_CHE_SEG_FACTOR_BITS {
+	unsigned int che_seg_factor:14, reserved31:18;
+};
+struct DTMB_TOP_CTRL_CHE_WORKCNT_BITS {
+	unsigned int ctrl_che_workcnt:8,
+	    ctrl_fec_workcnt:8,
+	    ctrl_constell:2,
+	    ctrl_code_rate:2,
+	    ctrl_intlv_mode:1,
+	    ctrl_qam4_nr:1, ctrl_freq_reverse:1, reserved32:9;
+};
+struct DTMB_TOP_SYNC_CCI_NF1_BITS {
+	unsigned int sync_cci_nf1_b1:10,
+	    sync_cci_nf1_a2:10, sync_cci_nf1_a1:10, reserved33:2;
+};
+struct DTMB_TOP_SYNC_CCI_NF2_BITS {
+	unsigned int sync_cci_nf2_b1:10,
+	    sync_cci_nf2_a2:10, sync_cci_nf2_a1:10, reserved34:2;
+};
+struct DTMB_TOP_SYNC_CCI_NF2_POSITION_BITS {
+	unsigned int sync_cci_nf2_position:11,
+	    sync_cci_nf1_position:11,
+	    sync_cci_nf2_det:1, sync_cci_nf1_det:1, reserved35:8;
+};
+struct DTMB_TOP_CTRL_SYS_OFDM_CNT_BITS {
+	unsigned int ctrl_sys_ofdm_cnt:8,
+	    mobi_det_power_var:19,
+	    reserved36:1, ctrl_che_working_state:2, reserved37:2;
+};
+struct DTMB_TOP_CTRL_TPS_Q_FINAL_BITS {
+	unsigned int ctrl_tps_q_final:7, ctrl_tps_suc_cnt:7, reserved38:18;
+};
+struct DTMB_TOP_FRONT_DC_BITS {
+	unsigned int front_dc_q:10, front_dc_i:10, reserved39:12;
+};
+struct DTMB_TOP_CTRL_TOTPS_READY_CNT_BITS {
+	unsigned int ctrl_dead_lock_det:1,
+	    ctrl_dead_lock:1,
+	    reserved40:2,
+	    ctrl_dead_cnt:4, reserved41:8, ctrl_totps_ready_cnt:16;
+};
+
+#endif
diff --git a/drivers/stream_input/tv_frontend/dtv_demod/include/aml_dtv_demod_reg.h b/drivers/stream_input/tv_frontend/dtv_demod/include/aml_dtv_demod_reg.h
new file mode 100644
index 0000000..4f49fa7
--- /dev/null
+++ b/drivers/stream_input/tv_frontend/dtv_demod/include/aml_dtv_demod_reg.h
@@ -0,0 +1,28 @@
+/*
+* Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT
+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+* more details.
+*
+* You should have received a copy of the GNU General Public License along
+* with this program; if not, write to the Free Software Foundation, Inc.,
+* 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+*
+* Description:
+*/
+#ifndef _DTV_REG_H_
+#define _DTV_REG_H_
+
+#include <linux/amlogic/iomap.h>
+
+#define DTV_WRITE_CBUS_REG(_r, _v)   aml_write_cbus(_r, _v)
+#define DTV_READ_CBUS_REG(_r)        aml_read_cbus(_r)
+
+#endif	/*  */
diff --git a/drivers/stream_input/tv_frontend/dtv_demod/include/amlfrontend.h b/drivers/stream_input/tv_frontend/dtv_demod/include/amlfrontend.h
new file mode 100644
index 0000000..5df7b1c
--- /dev/null
+++ b/drivers/stream_input/tv_frontend/dtv_demod/include/amlfrontend.h
@@ -0,0 +1,86 @@
+/*
+* Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT
+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+* more details.
+*
+* You should have received a copy of the GNU General Public License along
+* with this program; if not, write to the Free Software Foundation, Inc.,
+* 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+*
+* Description:
+*/
+
+/*****************************************************************
+ **
+ **  Copyright (C) 2010 Amlogic,Inc.
+ **  All rights reserved
+ **        Filename : amlfrontend.h
+ **
+ **  comment:
+ **        Driver for aml demodulator
+ **
+ ****************************************************************
+ */
+
+#ifndef _AMLFRONTEND_H
+#define _AMLFRONTEND_H
+
+struct amlfe_config {
+	int fe_mode;
+	int i2c_id;
+	int tuner_type;
+	int tuner_addr;
+};
+enum Gxtv_Demod_Tuner_If {
+	Si2176_5M_If = 5,
+	Si2176_6M_If = 6
+};
+/* 0 -DVBC, 1-DVBT, ISDBT, 2-ATSC */
+enum Gxtv_Demod_Dvb_Mode {
+	Gxtv_Dvbc = 0,
+	Gxtv_Dvbt_Isdbt = 1,
+	Gxtv_Atsc = 2,
+	Gxtv_Dtmb = 3,
+};
+#define Adc_Clk_35M             35714	/* adc clk    dvbc */
+#define Demod_Clk_71M   71428	/* demod clk */
+
+#define Adc_Clk_24M             24000
+#define Demod_Clk_72M       72000
+#define Demod_Clk_60M       60000
+
+#define Adc_Clk_28M             28571	/* dvbt,isdbt */
+#define Demod_Clk_66M   66666
+
+#define Adc_Clk_26M                     26000	/* atsc  air */
+#define Demod_Clk_78M     78000	/*  */
+
+#define Adc_Clk_25_2M                   25200	/* atsc  cable */
+#define Demod_Clk_75M     75600	/*  */
+
+#define Adc_Clk_25M                     25000	/* dtmb */
+#define Demod_Clk_100M    100000	/*  */
+#define Demod_Clk_180M    180000	/*  */
+#define Demod_Clk_200M    200000	/*  */
+#define Demod_Clk_225M    225000
+
+#define Adc_Clk_27M                     27777	/* atsc */
+#define Demod_Clk_83M     83333	/*  */
+
+enum M6_Demod_Pll_Mode {
+	Cry_mode = 0,
+	Adc_mode = 1
+};
+
+int M6_Demod_Dtmb_Init(struct aml_fe_dev *dev);
+int convert_snr(int in_snr);
+
+#endif
diff --git a/drivers/stream_input/tv_frontend/dtv_demod/include/demod_func.h b/drivers/stream_input/tv_frontend/dtv_demod/include/demod_func.h
new file mode 100644
index 0000000..4c9d281
--- /dev/null
+++ b/drivers/stream_input/tv_frontend/dtv_demod/include/demod_func.h
@@ -0,0 +1,626 @@
+/*
+* Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT
+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+* more details.
+*
+* You should have received a copy of the GNU General Public License along
+* with this program; if not, write to the Free Software Foundation, Inc.,
+* 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+*
+* Description:
+*/
+#ifdef DEMOD_FUNC_H
+#else
+#define DEMOD_FUNC_H
+
+#include <linux/types.h>
+/* #include <mach/am_regs.h> */
+/*#include <mach/register.h>
+ * #include <mach/avosstyle_io.h>
+ #include <mach/io.h>
+*/
+#include <linux/dvb/aml_demod.h>
+#include "aml_fe.h"
+#include "amlfrontend.h"
+#include "addr_dtmb_top.h"
+#include "c_stb_define.h"
+#include "c_stb_regs_define.h"
+#include <linux/io.h>
+
+/* #define G9_TV */
+#define GX_TV
+#define safe_addr
+
+#define PWR_ON    1
+#define PWR_OFF   0
+
+#define dtmb_mobile_mode
+
+
+/* void __iomem *meson_reg_demod_map[1024]; */
+
+#define IO_CBUS_PHY_BASE        (0xc0800000)
+
+#ifdef safe_addr
+#define IO_DEMOD_BASE           (0xc8844000)
+#define IO_AOBUS_BASE           (0xc8100000)
+#define IO_HIU_BASE                     (0xc883c000)
+#else
+#define IO_DEMOD_BASE           (0xda844000)
+#define IO_AOBUS_BASE           (0xda100000)
+#define IO_HIU_BASE                     (0xda83c000)
+#endif
+
+#define DEMOD_REG_OFFSET(reg)           (reg & 0xfffff)
+#define DEMOD_REG_ADDR(reg)             (IO_DEMOD_BASE + DEMOD_REG_OFFSET(reg))
+
+#define DEMOD_CBUS_REG_OFFSET(reg)              (reg << 2)
+#define DEMOD_CBUS_REG_ADDR(reg)                (IO_CBUS_PHY_BASE + \
+						 DEMOD_CBUS_REG_OFFSET(reg))
+
+#define DEMOD_AOBUS_REG_OFFSET(reg)             ((reg))
+#define DEMOD_AOBUS_REG_ADDR(reg)               (IO_AOBUS_BASE + \
+						 DEMOD_AOBUS_REG_OFFSET(reg))
+
+/* #define DEMOD_BASE     APB_REG_ADDR(0x20000) */
+#define DEMOD_BASE DEMOD_REG_ADDR(0x0)	/* 0xc8020000 */
+
+/* #define DEMOD_BASE 0xc8020000 */
+#define DTMB_BASE  (DEMOD_BASE + 0x000)
+#define DVBT_BASE  (DEMOD_BASE + 0x000)
+#define ISDBT_BASE (DEMOD_BASE + 0x000)
+#define QAM_BASE   (DEMOD_BASE + 0x400)
+#define ATSC_BASE  (DEMOD_BASE + 0x800)
+#define DEMOD_CFG_BASE  (DEMOD_BASE + 0xC00)
+
+/* #ifdef TXL_TV */
+#define TXLTV_ADC_RESET_VALUE          0xca6a2110	/* 0xce7a2110 */
+#define TXLTV_ADC_REG1_VALUE           0x5d414260
+#define TXLTV_ADC_REG2_VALUE           0x5ba00384	/* 0x34e0bf81 */
+#define TXLTV_ADC_REG2_VALUE_CRY       0x34e0bf81
+#define TXLTV_ADC_REG3_VALUE           0x4a6a2110	/* 0x4e7a2110 */
+#define TXLTV_ADC_REG4_VALUE           0x02913004
+#define TXLTV_ADC_REG4_CRY_VALUE 0x301
+#define TXLTV_ADC_REG7_VALUE           0x00102038
+#define TXLTV_ADC_REG8_VALUE           0x00000406
+#define TXLTV_ADC_REG9_VALUE           0x00082183
+#define TXLTV_ADC_REGA_VALUE           0x80480240
+#define TXLTV_ADC_REGB_VALUE           0x22000442
+#define TXLTV_ADC_REGC_VALUE           0x00034a00
+#define TXLTV_ADC_REGD_VALUE           0x00005000
+#define TXLTV_ADC_REGE_VALUE           0x00000200
+
+
+/* DADC DPLL */
+#define ADC_REG1         (IO_HIU_BASE + (0xaa << 2))
+#define ADC_REG2         (IO_HIU_BASE + (0xab << 2))
+#define ADC_REG3         (IO_HIU_BASE + (0xac << 2))
+#define ADC_REG4         (IO_HIU_BASE + (0xad << 2))
+
+#define ADC_REG5         (IO_HIU_BASE + (0x73 << 2))
+#define ADC_REG6         (IO_HIU_BASE + (0x74 << 2))
+
+#define ADC_REGB         (IO_HIU_BASE + (0xaf << 2))
+#define ADC_REGC         (IO_HIU_BASE + (0x9e << 2))
+#define ADC_REGD         (IO_HIU_BASE + (0x9f << 2))
+
+/* DADC REG */
+#define ADC_REG7         (IO_HIU_BASE + (0x27 << 2))
+#define ADC_REG8         (IO_HIU_BASE + (0x28 << 2))
+#define ADC_REG9         (IO_HIU_BASE + (0x2a << 2))
+#define ADC_REGA         (IO_HIU_BASE + (0x2b << 2))
+#define ADC_REGE         (IO_HIU_BASE + (0xbd << 2))
+
+/* #endif  */
+
+
+/* #ifdef GX_TV */
+
+#define ADC_RESET_VALUE          0x8a2a2110	/* 0xce7a2110 */
+#define ADC_REG1_VALUE           0x00100228
+#define ADC_REG2_VALUE           0x34e0bf80	/* 0x34e0bf81 */
+#define ADC_REG2_VALUE_CRY       0x34e0bf81
+#define ADC_REG3_VALUE           0x0a2a2110	/* 0x4e7a2110 */
+#define ADC_REG4_VALUE           0x02933800
+#define ADC_REG4_CRY_VALUE 0x301
+#define ADC_REG7_VALUE           0x01411036
+#define ADC_REG8_VALUE           0x00000000
+#define ADC_REG9_VALUE           0x00430036
+#define ADC_REGA_VALUE           0x80480240
+#if 0
+/* DADC DPLL */
+#define ADC_REG1         (IO_HIU_BASE + (0xaa << 2))
+#define ADC_REG2         (IO_HIU_BASE + (0xab << 2))
+#define ADC_REG3         (IO_HIU_BASE + (0xac << 2))
+#define ADC_REG4         (IO_HIU_BASE + (0xad << 2))
+
+#define ADC_REG5         (IO_HIU_BASE + (0x73 << 2))
+#define ADC_REG6         (IO_HIU_BASE + (0x74 << 2))
+
+/* DADC REG */
+#define ADC_REG7         (IO_HIU_BASE + (0x27 << 2))
+#define ADC_REG8         (IO_HIU_BASE + (0x28 << 2))
+#define ADC_REG9         (IO_HIU_BASE + (0x2a << 2))
+#define ADC_REGA         (IO_HIU_BASE + (0x2b << 2))
+#endif
+/* #endif */
+
+#ifdef G9_TV
+
+#define ADC_RESET_VALUE          0x8a2a2110	/* 0xce7a2110 */
+#define ADC_REG1_VALUE           0x00100228
+#define ADC_REG2_VALUE           0x34e0bf80	/* 0x34e0bf81 */
+#define ADC_REG2_VALUE_CRY       0x34e0bf81
+#define ADC_REG3_VALUE           0x0a2a2110	/* 0x4e7a2110 */
+#define ADC_REG4_VALUE           0x02933800
+#define ADC_REG4_CRY_VALUE 0x301
+#define ADC_REG7_VALUE           0x01411036
+#define ADC_REG8_VALUE           0x00000000
+#define ADC_REG9_VALUE           0x00430036
+#define ADC_REGA_VALUE           0x80480240
+
+/* DADC DPLL */
+#define ADC_REG1         0x10aa
+#define ADC_REG2         0x10ab
+#define ADC_REG3         0x10ac
+#define ADC_REG4         0x10ad
+
+#define ADC_REG5         0x1073
+#define ADC_REG6         0x1074
+
+/* DADC REG */
+#define ADC_REG7         0x1027
+#define ADC_REG8         0x1028
+#define ADC_REG9         0x102a
+#define ADC_REGA         0x102b
+#endif
+
+#ifdef M6_TV
+#define ADC_REG1_VALUE           0x003b0232
+#define ADC_REG2_VALUE           0x814d3928
+#define ADC_REG3_VALUE           0x6b425012
+#define ADC_REG4_VALUE           0x101
+#define ADC_REG4_CRY_VALUE 0x301
+#define ADC_REG5_VALUE           0x70b
+#define ADC_REG6_VALUE           0x713
+
+#define ADC_REG1         0x10aa
+#define ADC_REG2         0x10ab
+#define ADC_REG3         0x10ac
+#define ADC_REG4         0x10ad
+#define ADC_REG5         0x1073
+#define ADC_REG6         0x1074
+#endif
+
+#define DEMOD_REG1_VALUE                 0x0000d007
+#define DEMOD_REG2_VALUE                 0x2e805400
+#define DEMOD_REG3_VALUE                 0x201
+
+#define DEMOD_REG1               (DEMOD_BASE + 0xc00)
+#define DEMOD_REG2               (DEMOD_BASE + 0xc04)
+#define DEMOD_REG3               (DEMOD_BASE + 0xc08)
+#define DEMOD_REG4               (DEMOD_BASE + 0xc0c)
+
+/* #define Wr(addr, data)   WRITE_CBUS_REG(addr, data)*/
+/* #define Rd(addr)             READ_CBUS_REG(addr)  */
+
+/*#define Wr(addr, data) *(volatile unsigned long *)(addr) = (data)*/
+/*#define Rd(addr) *(volatile unsigned long *)(addr)*/
+
+enum {
+	enable_mobile,
+	disable_mobile
+};
+
+enum {
+	OPEN_TIME_EQ,
+	CLOSE_TIME_EQ
+};
+
+enum {
+	AMLOGIC_DTMB_STEP0,
+	AMLOGIC_DTMB_STEP1,
+	AMLOGIC_DTMB_STEP2,
+	AMLOGIC_DTMB_STEP3,
+	AMLOGIC_DTMB_STEP4,
+	AMLOGIC_DTMB_STEP5,	/* time eq */
+	AMLOGIC_DTMB_STEP6,	/* set normal mode sc */
+	AMLOGIC_DTMB_STEP7,
+	AMLOGIC_DTMB_STEP8,	/* set time eq mode */
+	AMLOGIC_DTMB_STEP9,	/* reset */
+	AMLOGIC_DTMB_STEP10,	/* set normal mode mc */
+	AMLOGIC_DTMB_STEP11,
+};
+
+enum {
+	DTMB_IDLE = 0,
+	DTMB_AGC_READY = 1,
+	DTMB_TS1_READY = 2,
+	DTMB_TS2_READY = 3,
+	DTMB_FE_READY = 4,
+	DTMB_PNPHASE_READY = 5,
+	DTMB_SFO_INIT_READY = 6,
+	DTMB_TS3_READY = 7,
+	DTMB_PM_INIT_READY = 8,
+	DTMB_CHE_INIT_READY = 9,
+	DTMB_FEC_READY = 10
+};
+
+/* i2c functions */
+/* int aml_i2c_sw_test_bus(struct aml_demod_i2c *adap, char *name); */
+int am_demod_i2c_xfer(struct aml_demod_i2c *adap, struct i2c_msg *msgs,
+		      int num);
+int init_tuner_fj2207(struct aml_demod_sta *demod_sta,
+		      struct aml_demod_i2c *adap);
+int set_tuner_fj2207(struct aml_demod_sta *demod_sta,
+		     struct aml_demod_i2c *adap);
+
+int get_fj2207_ch_power(void);
+int tuner_get_ch_power(struct aml_fe_dev *adap);
+int tda18273_tuner_set_frequnecy(unsigned int dwFrequency,
+				unsigned int dwStandard);
+int dtmb_get_power_strength(int agc_gain);
+
+
+int tuner_set_ch(struct aml_demod_sta *demod_sta,
+		 struct aml_demod_i2c *demod_i2c);
+
+/* dvbt */
+int dvbt_set_ch(struct aml_demod_sta *demod_sta,
+		struct aml_demod_i2c *demod_i2c,
+		struct aml_demod_dvbt *demod_dvbt);
+
+struct demod_status_ops {
+	int (*get_status)(struct aml_demod_sta *demod_sta,
+			   struct aml_demod_i2c *demod_i2c);
+	int (*get_ber)(struct aml_demod_sta *demod_sta,
+			struct aml_demod_i2c *demod_i2c);
+	int (*get_snr)(struct aml_demod_sta *demod_sta,
+			struct aml_demod_i2c *demod_i2c);
+	int (*get_strength)(struct aml_demod_sta *demod_sta,
+			     struct aml_demod_i2c *demod_i2c);
+	int (*get_ucblocks)(struct aml_demod_sta *demod_sta,
+			     struct aml_demod_i2c *demod_i2c);
+};
+
+struct demod_status_ops *dvbt_get_status_ops(void);
+
+/* dvbc */
+
+int dvbc_set_ch(struct aml_demod_sta *demod_sta,
+		struct aml_demod_i2c *demod_i2c,
+		struct aml_demod_dvbc *demod_dvbc);
+int dvbc_status(struct aml_demod_sta *demod_sta,
+		struct aml_demod_i2c *demod_i2c,
+		struct aml_demod_sts *demod_sts);
+int dvbc_isr_islock(void);
+void dvbc_isr(struct aml_demod_sta *demod_sta);
+u32 dvbc_set_qam_mode(unsigned char mode);
+u32 dvbc_get_status(void);
+u32 dvbc_set_auto_symtrack(void);
+int dvbc_timer_init(void);
+void dvbc_timer_exit(void);
+int dvbc_cci_task(void *data);
+int dvbc_get_cci_task(void);
+void dvbc_create_cci_task(void);
+void dvbc_kill_cci_task(void);
+
+/* atsc */
+
+int atsc_set_ch(struct aml_demod_sta *demod_sta,
+		struct aml_demod_i2c *demod_i2c,
+		struct aml_demod_atsc *demod_atsc);
+int check_atsc_fsm_status(void);
+
+void atsc_write_reg(int reg_addr, int reg_data);
+
+unsigned long atsc_read_reg(int reg_addr);
+
+unsigned long atsc_read_iqr_reg(void);
+
+int atsc_qam_set(fe_modulation_t mode);
+
+void qam_initial(int qam_id);
+
+/* dtmb */
+
+int dtmb_set_ch(struct aml_demod_sta *demod_sta,
+		struct aml_demod_i2c *demod_i2c,
+		struct aml_demod_dtmb *demod_atsc);
+
+void dtmb_reset(void);
+
+int dtmb_check_status_gxtv(struct dvb_frontend *fe);
+int dtmb_check_status_txl(struct dvb_frontend *fe);
+
+
+void dtmb_write_reg(int reg_addr, int reg_data);
+int dtmb_read_reg(int reg_addr);
+void dtmb_register_reset(void);
+
+/* demod functions */
+unsigned long apb_read_reg_collect(unsigned long addr);
+void apb_write_reg_collect(unsigned int addr, unsigned int data);
+void apb_write_reg(unsigned int reg, unsigned int val);
+unsigned long apb_read_reg_high(unsigned long addr);
+unsigned long apb_read_reg(unsigned long reg);
+int app_apb_write_reg(int addr, int data);
+int app_apb_read_reg(int addr);
+
+void demod_set_cbus_reg(unsigned int data, unsigned int addr);
+unsigned int demod_read_cbus_reg(unsigned int addr);
+void demod_set_demod_reg(unsigned int data, unsigned int addr);
+unsigned int demod_read_demod_reg(unsigned int addr);
+
+/* extern int clk_measure(char index); */
+
+void ofdm_initial(int bandwidth,
+		  /* 00:8M 01:7M 10:6M 11:5M */
+		  int samplerate,
+		  /* 00:45M 01:20.8333M 10:20.7M 11:28.57 */
+		  int IF,
+		  /* 000:36.13M 001:-5.5M 010:4.57M 011:4M 100:5M */
+		  int mode,
+		  /* 00:DVBT,01:ISDBT */
+		  int tc_mode
+		  /* 0: Unsigned, 1:TC */);
+
+void monitor_isdbt(void);
+void demod_set_reg(struct aml_demod_reg *demod_reg);
+void demod_get_reg(struct aml_demod_reg *demod_reg);
+
+/* void demod_calc_clk(struct aml_demod_sta *demod_sta); */
+int demod_set_sys(struct aml_demod_sta *demod_sta,
+		  struct aml_demod_i2c *demod_i2c,
+		  struct aml_demod_sys *demod_sys);
+/* int demod_get_sys(struct aml_demod_i2c *demod_i2c, */
+/* struct aml_demod_sys *demod_sys); */
+/* int dvbt_set_ch(struct aml_demod_sta *demod_sta, */
+/* struct aml_demod_i2c *demod_i2c, */
+/* struct aml_demod_dvbt *demod_dvbt); */
+/* int tuner_set_ch (struct aml_demod_sta *demod_sta, */
+/* struct aml_demod_i2c *demod_i2c); */
+
+/* typedef char               int8_t; */
+/* typedef short int          int16_t; */
+/* typedef int                int32_t; */
+/* typedef long               int64_t; */
+/*typedef unsigned char      uint8_t;
+ * typedef unsigned short int uint16_t;
+ * typedef unsigned int       uint32_t;
+ * typedef unsigned long      uint64_t;
+ */
+
+/*typedef unsigned   char    u8_t;
+ * typedef signed     char    s8_t;
+ * typedef unsigned   short   u16_t;
+ * typedef signed     short   s16_t;
+ * typedef unsigned   int     u32_t;
+ * typedef signed     int     s32_t;
+ * typedef unsigned   long    u64_t;
+ * typedef signed     long    s64_t;
+ */
+
+/* #define extadc */
+
+/* for g9tv */
+void adc_dpll_setup(int clk_a, int clk_b, int clk_sys);
+void demod_power_switch(int pwr_cntl);
+
+union adc_pll_cntl {
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct {
+		unsigned pll_m:9;
+		unsigned pll_n:5;
+		unsigned pll_od0:2;
+		unsigned pll_od1:2;
+		unsigned pll_od2:2;
+		unsigned pll_xd0:6;
+		unsigned pll_xd1:6;
+	} b;
+};
+
+union adc_pll_cntl2 {
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct {
+		unsigned output_mux_ctrl:4;
+		unsigned div2_ctrl:1;
+		unsigned b_polar_control:1;
+		unsigned a_polar_control:1;
+		unsigned gate_ctrl:6;
+		unsigned tdc_buf:8;
+		unsigned lm_s:6;
+		unsigned lm_w:4;
+		unsigned reserved:1;
+	} b;
+};
+
+union adc_pll_cntl3 {
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct {
+		unsigned afc_dsel_in:1;
+		unsigned afc_dsel_bypass:1;
+		unsigned dco_sdmck_sel:2;
+		unsigned dc_vc_in:2;
+		unsigned dco_m_en:1;
+		unsigned dpfd_lmode:1;
+		unsigned filter_acq1:11;
+		unsigned enable:1;
+		unsigned filter_acq2:11;
+		unsigned reset:1;
+	} b;
+};
+
+union adc_pll_cntl4 {
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct {
+		unsigned reve:12;
+		unsigned tdc_en:1;
+		unsigned dco_sdm_en:1;
+		unsigned dco_iup:2;
+		unsigned pvt_fix_en:1;
+		unsigned iir_bypass_n:1;
+		unsigned pll_od3:2;
+		unsigned filter_pvt1:4;
+		unsigned filter_pvt2:4;
+		unsigned reserved:4;
+	} b;
+};
+
+/* ///////////////////////////////////////////////////////////////// */
+
+union demod_dig_clk {
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct {
+		unsigned demod_clk_div:7;
+		unsigned reserved0:1;
+		unsigned demod_clk_en:1;
+		unsigned demod_clk_sel:2;
+		unsigned reserved1:5;
+		unsigned adc_extclk_div:7;	/* 34 */
+		unsigned use_adc_extclk:1;	/* 1 */
+		unsigned adc_extclk_en:1;	/* 1 */
+		unsigned adc_extclk_sel:3;	/* 1 */
+		unsigned reserved2:4;
+	} b;
+};
+
+union demod_adc_clk {
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct {
+		unsigned pll_m:9;
+		unsigned pll_n:5;
+		unsigned pll_od:2;
+		unsigned pll_xd:5;
+		unsigned reserved0:3;
+		unsigned pll_ss_clk:4;
+		unsigned pll_ss_en:1;
+		unsigned reset:1;
+		unsigned pll_pd:1;
+		unsigned reserved1:1;
+	} b;
+};
+
+union demod_cfg0 {
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct {
+		unsigned mode:4;
+		unsigned ts_sel:4;
+		unsigned test_bus_clk:1;
+		unsigned adc_ext:1;
+		unsigned adc_rvs:1;
+		unsigned adc_swap:1;
+		unsigned adc_format:1;
+		unsigned adc_regout:1;
+		unsigned adc_regsel:1;
+		unsigned adc_regadj:5;
+		unsigned adc_value:10;
+		unsigned adc_test:1;
+		unsigned ddr_sel:1;
+	} b;
+};
+
+union demod_cfg1 {
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct {
+		unsigned reserved:8;
+		unsigned ref_top:2;
+		unsigned ref_bot:2;
+		unsigned cml_xs:2;
+		unsigned cml_1s:2;
+		unsigned vdda_sel:2;
+		unsigned bias_sel_sha:2;
+		unsigned bias_sel_mdac2:2;
+		unsigned bias_sel_mdac1:2;
+		unsigned fast_chg:1;
+		unsigned rin_sel:3;
+		unsigned en_ext_vbg:1;
+		unsigned en_cmlgen_res:1;
+		unsigned en_ext_vdd12:1;
+		unsigned en_ext_ref:1;
+	} b;
+};
+
+union demod_cfg2 {
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct {
+		unsigned en_adc:1;
+		unsigned biasgen_ibipt_sel:2;
+		unsigned biasgen_ibic_sel:2;
+		unsigned biasgen_rsv:4;
+		unsigned biasgen_en:1;
+		unsigned biasgen_bias_sel_adc:2;
+		unsigned biasgen_bias_sel_cml1:2;
+		unsigned biasgen_bias_sel_ref_op:2;
+		unsigned clk_phase_sel:1;
+		unsigned reserved:15;
+	} b;
+};
+
+union demod_cfg3 {
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct {
+		unsigned dc_arb_mask:3;
+		unsigned dc_arb_enable:1;
+		unsigned reserved:28;
+	} b;
+};
+
+struct atsc_cfg {
+	int adr;
+	int dat;
+	int rw;
+};
+
+struct agc_power_tab {
+	char name[128];
+	int level;
+	int ncalcE;
+	int *calcE;
+};
+
+struct dtmb_cfg {
+	int dat;
+	int adr;
+	int rw;
+};
+
+void dtvpll_lock_init(void);
+void dtvpll_init_flag(int on);
+void demod_set_irq_mask(void);
+void demod_clr_irq_stat(void);
+void demod_set_adc_core_clk(int adc_clk, int sys_clk, int dvb_mode);
+void demod_set_adc_core_clk_fix(int clk_adc, int clk_dem);
+void calculate_cordic_para(void);
+void ofdm_read_all_regs(void);
+extern int aml_fe_analog_set_frontend(struct dvb_frontend *fe);
+
+#endif
diff --git a/drivers/stream_input/tv_frontend/dtv_demod/tuner_func.c b/drivers/stream_input/tv_frontend/dtv_demod/tuner_func.c
new file mode 100644
index 0000000..f4c1a38
--- /dev/null
+++ b/drivers/stream_input/tv_frontend/dtv_demod/tuner_func.c
@@ -0,0 +1,189 @@
+/*
+* Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT
+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+* more details.
+*
+* You should have received a copy of the GNU General Public License along
+* with this program; if not, write to the Free Software Foundation, Inc.,
+* 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+*
+* Description:
+*/
+#include <linux/kernel.h>
+#include <linux/i2c.h>
+#include <linux/dvb/aml_demod.h>
+#include "demod_func.h"
+#include "../aml_fe.h"
+
+int tuner_get_ch_power(struct aml_fe_dev *adap)
+{
+	int strength = 0;
+	int agc_if_gain;
+
+	struct dvb_frontend *dvbfe;
+
+	dvbfe = get_si2177_tuner();
+	if (dvbfe != NULL)
+		if (dvbfe->ops.tuner_ops.get_strength)
+			strength = dvbfe->ops.tuner_ops.get_strength(dvbfe);
+	if (strength <= -56) {
+		agc_if_gain =
+			((dtmb_read_reg(DTMB_TOP_FRONT_AGC))&0x3ff);
+		strength = dtmb_get_power_strength(agc_if_gain);
+	}
+
+	return strength;
+}
+
+struct dvb_tuner_info *tuner_get_info(int type, int mode)
+{
+	/*type :  0-NULL, 1-DCT7070, 2-Maxliner, 3-FJ2207, 4-TD1316 */
+	/*mode: 0-DVBC 1-DVBT */
+	static struct dvb_tuner_info tinfo_null = { };
+
+	static struct dvb_tuner_info tinfo_MXL5003S[2] = {
+		[1] = { /*DVBT*/ .name		= "Maxliner",
+				 .frequency_min = 44000000,
+				 .frequency_max = 885000000, }
+	};
+	static struct dvb_tuner_info tinfo_FJ2207[2] = {
+		[0] = { /*DVBC*/ .name		= "FJ2207",
+				 .frequency_min = 54000000,
+				 .frequency_max = 870000000, },
+		[1] = { /*DVBT*/ .name		= "FJ2207",
+				 .frequency_min = 174000000,
+				 .frequency_max = 864000000, },
+	};
+	static struct dvb_tuner_info tinfo_DCT7070[2] = {
+		[0] = { /*DVBC*/ .name		= "DCT7070",
+				 .frequency_min = 51000000,
+				 .frequency_max = 860000000, }
+	};
+	static struct dvb_tuner_info tinfo_TD1316[2] = {
+		[1] = { /*DVBT*/ .name		= "TD1316",
+				 .frequency_min = 51000000,
+				 .frequency_max = 858000000, }
+	};
+	static struct dvb_tuner_info tinfo_SI2176[2] = {
+		[0] = { /*DVBC*/
+			/*#error please add SI2176 code*/
+			.name		= "SI2176",
+			.frequency_min	= 51000000,
+			.frequency_max	= 860000000,
+		}
+	};
+
+	struct dvb_tuner_info *tinfo[] = {
+		&tinfo_null,
+		tinfo_DCT7070,
+		tinfo_MXL5003S,
+		tinfo_FJ2207,
+		tinfo_TD1316,
+		tinfo_SI2176
+	};
+
+	if ((type < 0) || (type > 4) || (mode < 0) || (mode > 1))
+		return tinfo[0];
+
+	return &tinfo[type][mode];
+}
+
+struct agc_power_tab *tuner_get_agc_power_table(int type)
+{
+	/*type :  0-NULL, 1-DCT7070, 2-Maxliner, 3-FJ2207, 4-TD1316 */
+	static int calcE_FJ2207[31] = {
+		87, 118, 138, 154, 172, 197, 245,
+		273, 292, 312, 327, 354, 406, 430,
+		448, 464, 481, 505, 558, 583, 599,
+		616, 632, 653, 698, 725, 745, 762,
+		779, 801, 831 };
+	static int calcE_Maxliner[79] = {
+		543, 552, 562, 575, 586, 596, 608,
+		618, 627, 635, 645, 653, 662, 668,
+		678, 689, 696, 705, 715, 725, 733,
+		742, 752, 763, 769, 778, 789, 800,
+		807, 816, 826, 836, 844, 854, 864,
+		874, 884, 894, 904, 913, 923, 932,
+		942, 951, 961, 970, 980, 990, 1000,
+		1012, 1022, 1031, 1040, 1049, 1059,
+		1069, 1079, 1088, 1098, 1107, 1115,
+		1123, 1132, 1140, 1148, 1157, 1165,
+		1173, 1179, 1186, 1192, 1198, 1203,
+		1208, 1208, 1214, 1217, 1218, 1220 };
+
+	static struct agc_power_tab power_tab[] = {
+		[0] = { "null", 0, 0, NULL },
+		[1] = {
+			.name	= "DCT7070",
+			.level	= 0,
+			.ncalcE = 0,
+			.calcE	= NULL,
+		},
+		[2] = {
+			.name	= "Maxlear",
+			.level	= -22,
+			.ncalcE = sizeof(calcE_Maxliner) / sizeof(int),
+			.calcE	= calcE_Maxliner,
+		},
+		[3] = {
+			.name	= "FJ2207",
+			.level	= -62,
+			.ncalcE = sizeof(calcE_FJ2207) / sizeof(int),
+			.calcE	= calcE_FJ2207,
+		},
+		[4] = {
+			.name	= "TD1316",
+			.level	= 0,
+			.ncalcE = 0,
+			.calcE	= NULL,
+		},
+	};
+
+	if (type >= 2 && type <= 3)
+		return &power_tab[type];
+	else
+		return &power_tab[3];
+};
+
+int agc_power_to_dbm(int agc_gain, int ad_power, int offset, int tuner)
+{
+	struct agc_power_tab *ptab = tuner_get_agc_power_table(tuner);
+	int est_rf_power;
+	int j;
+
+	for (j = 0; j < ptab->ncalcE; j++)
+		if (agc_gain <= ptab->calcE[j])
+			break;
+
+	est_rf_power = ptab->level - j - (ad_power >> 4) + 12 + offset;
+
+	return est_rf_power;
+}
+
+int dtmb_get_power_strength(int agc_gain)
+{
+	int strength;
+	int j;
+	static int calcE_R840[13] = {
+		1010, 969, 890, 840, 800,
+		760, 720, 680, 670, 660,
+		510, 440, 368};
+	for (j = 0; j < sizeof(calcE_R840)/sizeof(int); j++)
+		if (agc_gain >= calcE_R840[j])
+			break;
+	if (agc_gain >= 440)
+		strength = -90+j*3;
+	else
+		strength = -56;
+	return strength;
+}
+
+
-- 
2.24.1

