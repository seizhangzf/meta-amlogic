From ae8c67c479b2494c6547b86bc5efa63a5046e3ab Mon Sep 17 00:00:00 2001
From: "wei.du" <wei.du@amlogic.com>
Date: Mon, 27 Sep 2021 10:43:53 +0800
Subject: [PATCH 1/2] asink: refine dts channel condition [1/1]

PD#SWPL-60330

Problem:
asink cannot support dtshd stream channel configure

Solution:
refine dts channel condition

Verify:
AP222

Change-Id: I99a6b8f634ccd685c5b6571f4198bbbfd9086b2f
Signed-off-by: wei.du <wei.du@amlogic.com>
---
 src/gstamlhalasink_new.c | 46 +++++++++++++++++++---------------------
 1 file changed, 22 insertions(+), 24 deletions(-)

diff --git a/src/gstamlhalasink_new.c b/src/gstamlhalasink_new.c
index f1184ed..82959b2 100644
--- a/src/gstamlhalasink_new.c
+++ b/src/gstamlhalasink_new.c
@@ -1365,14 +1365,6 @@ parse_caps (GstAudioRingBufferSpec * spec, GstCaps * caps)
     gst_structure_get_int (structure, "channels", &info.channels);
     spec->type = GST_AUDIO_RING_BUFFER_FORMAT_TYPE_EAC3;
     info.bpf = 1;
-  } else if (g_str_equal (mimetype, "audio/x-dts")) {
-    /* extract the needed information from the cap */
-    if (!(gst_structure_get_int (structure, "rate", &info.rate)))
-      goto parse_error;
-
-    gst_structure_get_int (structure, "channels", &info.channels);
-    spec->type = GST_AUDIO_RING_BUFFER_FORMAT_TYPE_DTS;
-    info.bpf = 4;
   } else if (g_str_equal (mimetype, "audio/mpeg")) {
     /* if cannot extract the needed information from the cap, set default value */
     if (!(gst_structure_get_int (structure, "rate", &info.rate)))
@@ -2844,6 +2836,7 @@ hal_parse_spec (GstAmlHalAsink * sink, GstAudioRingBufferSpec * spec)
 {
   GstAmlHalAsinkPrivate *priv = sink->priv;
   gint channels;
+  gboolean raw_data = is_raw_type(spec->type);
 
   switch (spec->type) {
     case GST_AUDIO_RING_BUFFER_FORMAT_TYPE_RAW:
@@ -2882,23 +2875,28 @@ hal_parse_spec (GstAmlHalAsink * sink, GstAudioRingBufferSpec * spec)
     goto error;
   }
 
-  if (channels == 1)
-    priv->channel_mask_ = AUDIO_CHANNEL_OUT_MONO;
-  else if (channels == 2)
+  if (raw_data) {
+    if (channels == 1)
+      priv->channel_mask_ = AUDIO_CHANNEL_OUT_MONO;
+    else if (channels == 2)
+      priv->channel_mask_ = AUDIO_CHANNEL_OUT_STEREO;
+    else if (channels == 3)
+      priv->channel_mask_ = AUDIO_CHANNEL_OUT_2POINT1;
+    else if (channels == 4)
+      priv->channel_mask_ = AUDIO_CHANNEL_OUT_2POINT0POINT2;
+    else if (channels == 5 || channels == 6)
+      priv->channel_mask_ = AUDIO_CHANNEL_OUT_5POINT1;
+    else if (channels == 7)
+      priv->channel_mask_ = AUDIO_CHANNEL_OUT_6POINT1;
+    else if (channels == 8)
+      priv->channel_mask_ = AUDIO_CHANNEL_OUT_7POINT1;
+    else {
+      GST_ERROR_OBJECT (sink, "unsupported channel number:%d", channels);
+      goto error;
+    }
+  } else {
+    //decoder gets channal mask from ES data.
     priv->channel_mask_ = AUDIO_CHANNEL_OUT_STEREO;
-  else if (channels == 3)
-    priv->channel_mask_ = AUDIO_CHANNEL_OUT_2POINT1;
-  else if (channels == 4)
-    priv->channel_mask_ = AUDIO_CHANNEL_OUT_2POINT0POINT2;
-  else if (channels == 5 || channels == 6)
-    priv->channel_mask_ = AUDIO_CHANNEL_OUT_5POINT1;
-  else if (channels == 7)
-    priv->channel_mask_ = AUDIO_CHANNEL_OUT_6POINT1;
-  else if (channels == 8)
-    priv->channel_mask_ = AUDIO_CHANNEL_OUT_7POINT1;
-  else {
-    GST_ERROR_OBJECT (sink, "unsupported channel number:%d", channels);
-    goto error;
   }
   GST_DEBUG_OBJECT (sink, "format:0x%x, sr:%d, ch:%d",
       priv->format_, priv->sr_, channels);
-- 
2.25.1

