From de58091019406260a6045aebbffd899085f53529 Mon Sep 17 00:00:00 2001
From: Tim Yao <tim.yao@amlogic.com>
Date: Thu, 26 Dec 2019 18:31:40 -0800
Subject: [PATCH] audio-hal: Add separate hal_data_processing for ms12
 callback.i [1/1]

PD#SWPL-17555

Problem:
With ms12v1, the output from ms12 is always 2 channel stereo and
the output goes through hal_data_processing and there is a 2ch
to 8ch conversion logic in the function before writing final output
to ALSA device. There are also some other post effects applied in
hal_data_processing. When ms12 is not enabled, the same function
is used.

With ms12v2, in order to support multi-channel speaker output after
DAP, the output from ms12 pipeline is set to fixed 8 channel 16 bit.
So the sharing of hal_data_processing caused problems.

Solution:
Before we have a mechanism to specify buffer channel numbers, a new
hal_data_processing_ms12v2 function is added and it's only used
by ms12v2 callbacks. The audio effects are skipped also.

Also this change includes a change to enable
MS12DREPLACE_OUTPUT_BUFFER_WITH_CALLBACK define and a logcat TAG
changes (from libms12 to libms12v2).

Verify:
Local on AB301_TV_REF board.

Change-Id: I711ad5d93c52e9f1217e1a1bac24abd7b84a2774
---
 CMakeLists.txt                             |   2 +
 audio_hal/audio_hw.c                       | 227 +++++++++++++++++++++++++++++
 audio_hal/audio_hw.h                       |  17 +++
 audio_hal/audio_hw_ms12.c                  |   6 +-
 libms12v2/CMakeLists.txt                   |   2 +
 libms12v2/src/DolbyMS12.cpp                |   2 +-
 libms12v2/src/DolbyMS12ConfigParams.cpp    |   2 +-
 libms12v2/src/DolbyMS12Status.cpp          |   2 +-
 libms12v2/src/aml_audio_ms12.c             |   2 +-
 libms12v2/src/dolby_ms12.cpp               |   4 +-
 libms12v2/src/dolby_ms12_config_params.cpp |   2 +-
 libms12v2/src/dolby_ms12_status.cpp        |   2 +-
 12 files changed, 259 insertions(+), 11 deletions(-)

diff --git a/CMakeLists.txt b/CMakeLists.txt
index 34559d8..fabbab2 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -77,6 +77,8 @@ add_library(audio_hal SHARED
 	utils/aml_configs/aml_conf_parser.c
 )
 
+add_definitions(-DREPLACE_OUTPUT_BUFFER_WITH_CALLBACK)
+
 set(PREBUILD_STATIC_LIBS
 	${CMAKE_SOURCE_DIR}/amlogic_AQ_tools/lib_aml_ng.a
 	${CMAKE_SOURCE_DIR}/amlogic_AQ_tools/Amlogic_DRC_Param_Generator.a
diff --git a/audio_hal/audio_hw.c b/audio_hal/audio_hw.c
index 1d762d7..8546af6 100644
--- a/audio_hal/audio_hw.c
+++ b/audio_hal/audio_hw.c
@@ -6817,6 +6817,233 @@ static void output_mute(struct audio_stream_out *stream, size_t *output_buffer_b
     return;
 }
 #define EQ_GAIN_DEFAULT (0.16)
+/* ms12v2 output format is 8 channel 16 bit */
+ssize_t audio_hal_data_processing_ms12v2(struct audio_stream_out *stream,
+                                const void *buffer,
+                                size_t bytes,
+                                void **output_buffer,
+                                size_t *output_buffer_bytes,
+                                audio_format_t output_format)
+{
+    struct aml_stream_out *aml_out = (struct aml_stream_out *)stream;
+    struct aml_audio_device *adev = aml_out->dev;
+    int16_t *tmp_buffer = (int16_t *) buffer;
+    int16_t *effect_tmp_buf = NULL;
+    int out_frames = bytes / 16; /* input is 8 channel 16 bit */
+    size_t i;
+    int j, ret;
+    uint32_t latency_frames = 0;
+    uint64_t total_frame = 0;
+
+    /* raw data need packet to IEC61937 format by spdif encoder */
+    if ((output_format == AUDIO_FORMAT_AC3) || (output_format == AUDIO_FORMAT_E_AC3) || (output_format == AUDIO_FORMAT_MAT)) {
+        //ALOGI("%s, aml_out->hal_format %x , is_iec61937_format = %d, \n", __func__, aml_out->hal_format,is_iec61937_format(stream));
+        if ((is_iec61937_format(stream) == true) ||
+            (adev->dolby_lib_type == eDolbyDcvLib)) {
+            *output_buffer = (void *) buffer;
+            *output_buffer_bytes = bytes;
+        } else {
+            if (adev->spdif_encoder_init_flag == false) {
+                ALOGI("%s, go to prepare spdif encoder, output_format %#x\n", __func__, output_format);
+                ret = get_the_spdif_encoder_prepared(output_format, aml_out);
+                if (ret) {
+                    ALOGE("%s() get_the_spdif_encoder_prepared failed", __func__);
+                    return ret;
+                }
+                aml_out->spdif_enc_init_frame_write_sum = aml_out->frame_write_sum;
+                adev->spdif_encoder_init_flag = true;
+            }
+            spdif_encoder_ad_write(buffer, bytes);
+            adev->temp_buf_pos = spdif_encoder_ad_get_current_position();
+            if (adev->temp_buf_pos <= 0) {
+                adev->temp_buf_pos = 0;
+            }
+            spdif_encoder_ad_flush_output_current_position();
+
+            //ALOGI("%s: SPDIF", __func__);
+            *output_buffer = adev->temp_buf;
+            *output_buffer_bytes = adev->temp_buf_pos;
+        }
+    } else {
+        /* 8 channel 16 bit PCM, and there is no effect applied after MS12 processing */
+        if (aml_out->is_tv_platform == 1) {
+            int16_t *tmp_buffer = (int16_t *)buffer;
+            size_t out_frames = bytes / 16; /* input is 8 ch 16 bit */
+
+            int16_t *effect_tmp_buf;
+            effect_descriptor_t tmpdesc;
+            int32_t *spk_tmp_buf;
+            float source_gain;
+            float gain_speaker = adev->eq_data.p_gain.speaker;
+
+            /* handling audio effect process here */
+            if (adev->effect_buf_size < bytes) {
+                adev->effect_buf = realloc(adev->effect_buf, bytes);
+                if (!adev->effect_buf) {
+                    ALOGE ("realloc effect buf failed size %zu format = %#x", bytes, output_format);
+                    return -ENOMEM;
+                } else {
+                    ALOGI("realloc effect_buf size from %zu to %zu format = %#x", adev->effect_buf_size, bytes, output_format);
+                }
+                adev->effect_buf_size = bytes;
+
+                /* double the size for spk_output_buf for 16->32 bit conversion */
+                adev->spk_output_buf = realloc(adev->spk_output_buf, bytes*2);
+                if (!adev->spk_output_buf) {
+                    ALOGE ("realloc headphone buf failed size %zu format = %#x", bytes, output_format);
+                    return -ENOMEM;
+                }
+            }
+
+            effect_tmp_buf = (int16_t *)adev->effect_buf;
+            spk_tmp_buf = (int32_t *)adev->spk_output_buf;
+
+#ifdef ENABLE_AVSYNC_TUNING
+            tuning_spker_latency(adev, effect_tmp_buf, tmp_buffer, bytes);
+#else
+            memcpy(effect_tmp_buf, tmp_buffer, bytes);
+#endif
+
+            /*apply dtv source gain for speaker*/
+            if (adev->patch_src == SRC_DTV && adev->audio_patching)
+                source_gain = adev->eq_data.s_gain.dtv;
+            else if (adev->patch_src == SRC_HDMIIN && adev->audio_patching)
+                source_gain = adev->eq_data.s_gain.hdmi;
+            else if (adev->patch_src == SRC_LINEIN && adev->audio_patching)
+                source_gain = adev->eq_data.s_gain.av;
+            else if (adev->patch_src == SRC_ATV && adev->audio_patching)
+                source_gain = adev->eq_data.s_gain.atv;
+            else
+                source_gain = 1.0;
+
+            if (source_gain != 1.0)
+                apply_volume(source_gain, effect_tmp_buf, sizeof(int16_t), bytes);
+
+            /*aduio effect process for speaker*/
+            if (adev->native_postprocess.num_postprocessors == adev->native_postprocess.total_postprocessors) {
+                /* no effect processing for ms12v2 */
+#if 0
+                for (j = 0; j < adev->native_postprocess.num_postprocessors; j++) {
+                    audio_post_process(adev->native_postprocess.postprocessors[j], effect_tmp_buf, out_frames);
+                }
+                /*
+                 according to dts profile2 block diagram: Trusurround:X->Truvolume->TBHDX->customer modules->MC Dynamics
+                 virtualx will be called twice,first implementation for process Trusurround:X->Truvolume->TBHDX
+                 final implementation for process MC Dynamics
+                */
+                if (adev->native_postprocess.postprocessors[0] != NULL) {
+                    (*(adev->native_postprocess.postprocessors[0]))->get_descriptor(adev->native_postprocess.postprocessors[0], &tmpdesc);
+                    if (0 == strcmp(tmpdesc.name,"VirtualX")) {
+                        audio_post_process(adev->native_postprocess.postprocessors[0], effect_tmp_buf, out_frames);
+                    }
+                }
+#endif
+            } else {
+                gain_speaker *= EQ_GAIN_DEFAULT;
+            }
+
+            if (aml_getprop_bool("media.audiohal.outdump")) {
+                FILE *fp1 = fopen("/data/audio/audio_spk.pcm", "a+");
+                if (fp1) {
+                    int flen = fwrite((char *)tmp_buffer, 1, bytes, fp1);
+                    ALOGV("%s buffer %p size %zu\n", __FUNCTION__, effect_tmp_buf, bytes);
+                    fclose(fp1);
+                }
+            }
+
+            /* skip aml_audio_switch_output_mode processing for 8 ch input */
+#if 0
+            if (adev->patch_src == SRC_DTV && adev->audio_patch != NULL) {
+                aml_audio_switch_output_mode((int16_t *)effect_tmp_buf, bytes, adev->audio_patch->mode);
+            } else if ( adev->audio_patch == NULL) {
+               if (adev->sound_track_mode == 3)
+                  adev->sound_track_mode = AM_AOUT_OUTPUT_LRMIX;
+               aml_audio_switch_output_mode((int16_t *)effect_tmp_buf, bytes, adev->sound_track_mode);
+            }
+#endif
+
+            /* apply volume for spk/hp, SPDIF/HDMI keep the max volume */
+            gain_speaker *= (adev->sink_gain[OUTPORT_SPEAKER]);
+            apply_volume_16to32(gain_speaker, effect_tmp_buf, spk_tmp_buf, bytes);
+
+            /* 8 ch 16 bit --> 8 ch 32 bit mapping, need 2X size of input buffer size */
+            if (aml_out->tmp_buffer_8ch_size < 2 * bytes) {
+                aml_out->tmp_buffer_8ch = realloc(aml_out->tmp_buffer_8ch, 2 * bytes);
+                if (!aml_out->tmp_buffer_8ch) {
+                    ALOGE("%s: realloc tmp_buffer_8ch buf failed size = %zu format = %#x",
+                        __func__, 8 * bytes, output_format);
+                    return -ENOMEM;
+                } else {
+                    ALOGI("%s: realloc tmp_buffer_8ch size from %zu to %zu format = %#x",
+                        __func__, aml_out->tmp_buffer_8ch_size, 8 * bytes, output_format);
+                }
+                aml_out->tmp_buffer_8ch_size = 2 * bytes;
+            }
+
+#if 0
+            if (alsa_device_is_auge()) {
+                for (i = 0; i < out_frames; i++) {
+                    aml_out->tmp_buffer_8ch[8 * i + 0] = (int32_t)spk_tmp_buf[2 * i];
+                    aml_out->tmp_buffer_8ch[8 * i + 1] = (int32_t)spk_tmp_buf[2 * i + 1];
+                    aml_out->tmp_buffer_8ch[8 * i + 2] = (int32_t)tmp_buffer[2 * i] << 16;
+                    aml_out->tmp_buffer_8ch[8 * i + 3] = (int32_t)tmp_buffer[2 * i + 1] << 16;
+                    aml_out->tmp_buffer_8ch[8 * i + 4] = (int32_t)tmp_buffer[2 * i] << 16;
+                    aml_out->tmp_buffer_8ch[8 * i + 5] = (int32_t)tmp_buffer[2 * i + 1] << 16;
+                    aml_out->tmp_buffer_8ch[8 * i + 6] = (int32_t)tmp_buffer[2 * i] << 16;
+                    aml_out->tmp_buffer_8ch[8 * i + 7] = (int32_t)tmp_buffer[2 * i + 1] << 16;
+                }
+            } else {
+                for (i = 0; i < out_frames; i++) {
+                    aml_out->tmp_buffer_8ch[8 * i + 0] = (int32_t)tmp_buffer[2 * i] << 16;
+                    aml_out->tmp_buffer_8ch[8 * i + 1] = (int32_t)tmp_buffer[2 * i + 1] << 16;
+                    aml_out->tmp_buffer_8ch[8 * i + 2] = (int32_t)spk_tmp_buf[2 * i];
+                    aml_out->tmp_buffer_8ch[8 * i + 3] = (int32_t)spk_tmp_buf[2 * i + 1];
+                    aml_out->tmp_buffer_8ch[8 * i + 4] = (int32_t)tmp_buffer[2 * i] << 16;
+                    aml_out->tmp_buffer_8ch[8 * i + 5] = (int32_t)tmp_buffer[2 * i + 1] << 16;
+                    aml_out->tmp_buffer_8ch[8 * i + 6] = 0;
+                    aml_out->tmp_buffer_8ch[8 * i + 7] = 0;
+                }
+            }
+#else
+            /* still need a copy because output_mute applies to tmp_buffer_8ch */
+            memcpy(aml_out->tmp_buffer_8ch, spk_tmp_buf, 2 * bytes);
+#endif
+            *output_buffer = aml_out->tmp_buffer_8ch;
+            *output_buffer_bytes = 2 * bytes; /* from 8 ch 16 bit to 8 ch 32 bit */
+        } else {
+            /* OTT case, output buffer is 8 channel 16 bit, apply gain only */
+            float gain_speaker = 1.0;
+            if (adev->is_STB)
+                gain_speaker = adev->sink_gain[adev->active_outport];
+            else
+                gain_speaker = adev->sink_gain[OUTPORT_SPEAKER];
+
+#if 0
+            if (adev->patch_src == SRC_DTV && adev->audio_patch != NULL) {
+                aml_audio_switch_output_mode((int16_t *)buffer, bytes, adev->audio_patch->mode);
+            }
+#endif
+            *output_buffer = (void *) buffer;
+            *output_buffer_bytes = bytes;
+            apply_volume(gain_speaker, *output_buffer, sizeof(uint16_t), bytes);
+        }
+    }
+
+#ifdef ENABLE_DTV_PATCH
+    /* TODO: ms12v2, need return 2 channel ms12 output for tuner2mix_patch */
+#if 0
+    if (adev->patch_src == SRC_DTV && adev->tuner2mix_patch == 1) {
+        dtv_in_write(stream,buffer, bytes);
+    }
+#endif
+#endif
+
+    if (adev->audio_patching) {
+        output_mute(stream, output_buffer_bytes);
+    }
+    return 0;
+}
+
 ssize_t audio_hal_data_processing(struct audio_stream_out *stream,
                                 const void *buffer,
                                 size_t bytes,
diff --git a/audio_hal/audio_hw.h b/audio_hal/audio_hw.h
index c1191e8..458ecc6 100644
--- a/audio_hal/audio_hw.h
+++ b/audio_hal/audio_hw.h
@@ -749,6 +749,23 @@ ssize_t audio_hal_data_processing(struct audio_stream_out *stream
                                   , audio_format_t output_format);
 
 /*
+ *@brief audio_hal_data_processing_ms12v2
+ * format:
+ *    if pcm-16bits-8ch, mapping to 8ch
+ *    if raw data, packet it to IEC61937 format with spdif encoder
+ *    if IEC61937 format, write them to hardware
+ * return
+ *    0, success
+ *    -1, fail
+ */
+ssize_t audio_hal_data_processing_ms12v2(struct audio_stream_out *stream
+                                  , const void *input_buffer
+                                  , size_t input_buffer_bytes
+                                  , void **output_buffer
+                                  , size_t *output_buffer_bytes
+                                  , audio_format_t output_format);
+
+/*
  *@brief hw_write the api to write the data to audio hardware
  */
 ssize_t hw_write(struct audio_stream_out *stream
diff --git a/audio_hal/audio_hw_ms12.c b/audio_hal/audio_hw_ms12.c
index 952901e..02371a2 100644
--- a/audio_hal/audio_hw_ms12.c
+++ b/audio_hal/audio_hw_ms12.c
@@ -460,7 +460,7 @@ MAIN_INPUT:
                     , ms12->dolby_ms12_out_max_size);
             if (ms12_output_size > 0) {
                 audio_format_t output_format = get_output_format(stream);
-                if (0 == audio_hal_data_processing(stream
+                if (0 == audio_hal_data_processing_ms12v2(stream
                                                    , ms12->dolby_ms12_out_data
                                                    , ms12_output_size
                                                    , &output_buffer
@@ -694,7 +694,7 @@ int pcm_output(void *buffer, void *priv_data, size_t size)
     /*dump ms12 pcm output*/
     dump_ms12_output_data(buffer, size, MS12_OUTPUT_PCM_FILE);
 
-    if (audio_hal_data_processing((struct audio_stream_out *)aml_out, buffer, size, &output_buffer, &output_buffer_bytes, output_format) == 0) {
+    if (audio_hal_data_processing_ms12v2((struct audio_stream_out *)aml_out, buffer, size, &output_buffer, &output_buffer_bytes, output_format) == 0) {
         ret = hw_write((struct audio_stream_out *)aml_out, output_buffer, output_buffer_bytes, output_format);
     }
 
@@ -733,7 +733,7 @@ int bitstream_output(void *buffer, void *priv_data, size_t size)
         ret = aml_audio_spdif_output(stream_out, buffer, size);
     } else {
         output_format = adev->sink_format;
-        if (audio_hal_data_processing((struct audio_stream_out *)aml_out, buffer, size, &output_buffer, &output_buffer_bytes, output_format) == 0) {
+        if (audio_hal_data_processing_ms12v2((struct audio_stream_out *)aml_out, buffer, size, &output_buffer, &output_buffer_bytes, output_format) == 0) {
             ret = hw_write((struct audio_stream_out *)aml_out, output_buffer, output_buffer_bytes, output_format);
         }
     }
diff --git a/libms12v2/CMakeLists.txt b/libms12v2/CMakeLists.txt
index 75449d2..a185e6b 100644
--- a/libms12v2/CMakeLists.txt
+++ b/libms12v2/CMakeLists.txt
@@ -15,6 +15,8 @@ add_library(ms12v2 SHARED
 	src/DolbyMS12Status.cpp
 )
 
+add_definitions(-DREPLACE_OUTPUT_BUFFER_WITH_CALLBACK)
+
 set_target_properties(ms12v2 PROPERTIES
 	VERSION ${PROJECT_VERSION}
 	SOVERSION 1)
diff --git a/libms12v2/src/DolbyMS12.cpp b/libms12v2/src/DolbyMS12.cpp
index 8cd6b15..8295f10 100644
--- a/libms12v2/src/DolbyMS12.cpp
+++ b/libms12v2/src/DolbyMS12.cpp
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-#define LOG_TAG "libms12"
+#define LOG_TAG "libms12v2"
 //#define LOG_NDEBUG 0
 //#define LOG_NALOGV 0
 
diff --git a/libms12v2/src/DolbyMS12ConfigParams.cpp b/libms12v2/src/DolbyMS12ConfigParams.cpp
index 3e74b65..0e169cb 100644
--- a/libms12v2/src/DolbyMS12ConfigParams.cpp
+++ b/libms12v2/src/DolbyMS12ConfigParams.cpp
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-#define LOG_TAG "libms12"
+#define LOG_TAG "libms12v2"
 // #define LOG_NDEBUG 0
 // #define LOG_NALOGV 0
 
diff --git a/libms12v2/src/DolbyMS12Status.cpp b/libms12v2/src/DolbyMS12Status.cpp
index 5b8a4ba..908acae 100644
--- a/libms12v2/src/DolbyMS12Status.cpp
+++ b/libms12v2/src/DolbyMS12Status.cpp
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-#define LOG_TAG "libms12"
+#define LOG_TAG "libms12v2"
 // #define LOG_NDEBUG 0
 // #define LOG_NALOGV 0
 
diff --git a/libms12v2/src/aml_audio_ms12.c b/libms12v2/src/aml_audio_ms12.c
index 9636ee1..49a7dc8 100644
--- a/libms12v2/src/aml_audio_ms12.c
+++ b/libms12v2/src/aml_audio_ms12.c
@@ -9,7 +9,7 @@
  */
 
 
-#define LOG_TAG "libms12"
+#define LOG_TAG "libms12v2"
 // #define LOG_NDEBUG 0
 
 #include <cutils/log.h>
diff --git a/libms12v2/src/dolby_ms12.cpp b/libms12v2/src/dolby_ms12.cpp
index 6ab2d83..0391b86 100644
--- a/libms12v2/src/dolby_ms12.cpp
+++ b/libms12v2/src/dolby_ms12.cpp
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-#define LOG_TAG "libms12"
+#define LOG_TAG "libms12v2"
 // #define LOG_NDEBUG 0
 // #define LOG_NALOGV 0
 
@@ -377,4 +377,4 @@ extern "C" int dolby_ms12_get_input_atmos_info()
     } else {
         return -1;
     }
-}
\ No newline at end of file
+}
diff --git a/libms12v2/src/dolby_ms12_config_params.cpp b/libms12v2/src/dolby_ms12_config_params.cpp
index becac7d..430d4d4 100644
--- a/libms12v2/src/dolby_ms12_config_params.cpp
+++ b/libms12v2/src/dolby_ms12_config_params.cpp
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-#define LOG_TAG "libms12"
+#define LOG_TAG "libms12v2"
 // #define LOG_NDEBUG 0
 // #define LOG_NALOGV 0
 
diff --git a/libms12v2/src/dolby_ms12_status.cpp b/libms12v2/src/dolby_ms12_status.cpp
index fb9dbaf..641bc64 100644
--- a/libms12v2/src/dolby_ms12_status.cpp
+++ b/libms12v2/src/dolby_ms12_status.cpp
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-#define LOG_TAG "libms12"
+#define LOG_TAG "libms12v2"
 // #define LOG_NDEBUG 0
 // #define LOG_NALOGV 0
 
-- 
2.7.4

