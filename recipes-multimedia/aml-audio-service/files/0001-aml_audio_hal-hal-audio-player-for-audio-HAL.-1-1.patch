From 3004646152faf8d92144994bd0949fca55d9e68c Mon Sep 17 00:00:00 2001
From: Tim Yao <tim.yao@amlogic.com>
Date: Mon, 20 Jan 2020 16:56:42 -0800
Subject: [PATCH] aml_audio_hal: hal audio player for audio HAL.[1/1]

PD#SWPL-20153

Problem:
This is a task to have a generic audio player based
on Linux audio hal/service. Previously the audio
HAL tests have two separate sample code for PCM and
Dolby AC3 format. We need a more generic player for
testing purpose.

Solution:
A generic audio player (halplayer) is provided so a
source file and format can be specified.

Verify:
Local on AB311 platform with PCM, Dolby and MAT PCM
input verified.

Change-Id: I0f3e5f3d29cda93393dd6feae949524dca8a6882
---
 Makefile      |   9 +-
 src/halplay.c | 256 ++++++++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 264 insertions(+), 1 deletion(-)
 create mode 100644 src/halplay.c

diff --git a/Makefile b/Makefile
index 5473319..46f1346 100644
--- a/Makefile
+++ b/Makefile
@@ -11,6 +11,7 @@ CLIENT_OBJS+=$(COMMON_OBJS) $(PROTO_OBJS)
 
 TEST_PCM_OBJS=src/test.o
 TEST_DOLBY_OBJS=src/test_ac3.o
+TEST_HALPLAY_OBJS=src/halplay.o
 
 PROTOC=$(HOST_DIR)/bin/protoc
 PROTOC_INC=$(HOST_DIR)/include
@@ -35,7 +36,7 @@ LDFLAGS+=-lgrpc++_unsecure -lprotobuf -lboost_system -llog -ldl -lrt -lpthread -
 %.o: %.c
 	$(CC) -c $(CFLAGS) -o $@ $<
 
-all: audio_server libaudio_client.so audio_client_test audio_client_test_ac3
+all: audio_server libaudio_client.so audio_client_test audio_client_test_ac3 halplay
 
 audio_server: $(SERVER_OBJS)
 	$(CC) $(CFLAGS) $(LDFLAGS) -o $@ $^
@@ -49,11 +50,15 @@ audio_client_test: $(TEST_PCM_OBJS) libaudio_client.so
 audio_client_test_ac3: $(TEST_DOLBY_OBJS) libaudio_client.so
 	$(CC) $(CFLAGS) $(LDFLAGS) -o $@ $^
 
+halplay: $(TEST_HALPLAY_OBJS) libaudio_client.so
+	$(CC) $(CFLAGS) $(LDFLAGS) -o $@ $^
+
 .PHONY: install
 install:
 	install -m 755 -D audio_server -t $(TARGET_DIR)/usr/bin/
 	install -m 755 -D audio_client_test -t $(TARGET_DIR)/usr/bin/
 	install -m 755 -D audio_client_test_ac3 $(TARGET_DIR)/usr/bin/
+	install -m 755 -D halplay $(TARGET_DIR)/usr/bin/
 	install -m 644 -D libaudio_client.so -t $(TARGET_DIR)/usr/lib/
 	install -m 644 -D libaudio_client.so -t $(STAGING_DIR)/usr/lib/
 	install -m 644 -D include/audio_if_client.h -t $(STAGING_DIR)/usr/include
@@ -70,12 +75,14 @@ clean:
 	rm -f audio_server
 	rm -f audio_client_test
 	rm -f audio_client_test_ac3
+	rm -f halplay
 	rm -rf $(STAGING_DIR)/usr/include/hardware
 	rm -rf $(STAGING_DIR)/usr/include/system
 	rm -f libaudio_client.so
 	rm -f $(TARGET_DIR)/usr/bin/audio_server
 	rm -f $(TARGET_DIR)/usr/bin/audio_client_test
 	rm -f $(TARGET_DIR)/usr/bin/audio_client_test_ac3
+	rm -f $(TARGET_DIR)/usr/bin/halplay
 	rm -f $(TARGET_DIR)/usr/lib/libaudio_client.so
 	rm -f $(STAGING_DIR)/usr/lib/libaudio_client.so
 	rm -f $(STAGING_DIR)/usr/include/audio_if_client.h
diff --git a/src/halplay.c b/src/halplay.c
new file mode 100644
index 0000000..e7fa855
--- /dev/null
+++ b/src/halplay.c
@@ -0,0 +1,256 @@
+/*
+ * Copyright (C) 2016 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/mman.h>
+#include <fcntl.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <unistd.h>
+#include "audio_if.h"
+
+#define min(a, b) ((a) < (b) ? (a) : (b))
+#define WRITE_UNIT 4096
+
+#define FORMAT_PCM16    0
+#define FORMAT_PCM32    1
+#define FORMAT_DD       2
+#define FORMAT_MAT      3
+#define FORMAT_IEC61937 4
+#define FORMAT_AC4      5
+#define FORMAT_MAX      6
+
+static int format_tab[] = {AUDIO_FORMAT_PCM_16_BIT, AUDIO_FORMAT_PCM_32_BIT, AUDIO_FORMAT_AC3, AUDIO_FORMAT_MAT, AUDIO_FORMAT_IEC61937, AUDIO_FORMAT_AC4};
+static const char *format_str[] = {
+    "PCM_16", "PCM_32", "DOLBY DD/DD+", "DOLBY MAT", "IEC_61937", "AC4"
+};
+
+static int format_is_pcm(int format)
+{
+    return (format == FORMAT_PCM16) || (format == FORMAT_PCM32);
+}
+
+static unsigned char *fmap(const char *fn, int *size, int *fd)
+{
+    int fd_r, r;
+    struct stat st;
+    unsigned char *p;
+
+    fd_r = open(fn, O_RDWR);
+
+    if (fd_r < 0)
+        return NULL;
+
+    *fd = fd_r;
+    r = fstat(fd_r, &st);
+    *size = st.st_size;
+    return mmap(0, st.st_size, PROT_READ|PROT_EXEC, MAP_SHARED, fd_r, 0);
+}
+
+static void funmap(unsigned char *p, int size, int fd)
+{
+    if (p && size > 0)
+        munmap(p, size);
+    if (fd >= 0)
+        close(fd);
+}
+
+static int test_stream(struct audio_stream_out *stream, unsigned char *buf, int size)
+{
+    int ret;
+    int len = size;
+    unsigned char *data = buf;
+
+    ret = stream->common.standby(&stream->common);
+    if (ret) {
+        fprintf(stderr, "%s %d, ret:%x\n",
+                __func__, __LINE__, ret);
+        return -1;
+    }
+
+    ret = stream->set_volume(stream, 1.0f, 1.0f);
+    if (ret) {
+        fprintf(stderr, "%s %d, ret:%x\n", __func__, __LINE__, ret);
+        return -1;
+    }
+
+    while (len > 0) {
+        ssize_t s = stream->write(stream, data, min(len, WRITE_UNIT));
+        if (s < 0) {
+            fprintf(stderr, "stream writing error %d\n", s);
+            break;
+        }
+
+        len -= s;
+        data += s;
+    }
+
+    return 0;
+}
+
+static void test_output_stream(audio_hw_device_t *device, unsigned char *buf, int size, struct audio_config *config)
+{
+    struct audio_stream_out *stream;
+    int ret;
+
+    printf("open output speaker...\n");
+    ret = device->open_output_stream(device,
+            0, AUDIO_DEVICE_OUT_SPEAKER,
+            AUDIO_OUTPUT_FLAG_PRIMARY, config,
+            &stream, NULL);
+    if (ret) {
+        printf("fail\n");
+        return;
+    } else {
+        printf("success\n");
+    }
+
+    test_stream(stream, buf, size);
+
+    printf("close output speaker...\n");
+    device->close_output_stream(device, stream);
+}
+
+int main(int argc, char **argv)
+{
+    audio_hw_device_t *device;
+    int ret, c = -1, format = FORMAT_MAX, ch = 0, sr = 0;
+    struct audio_config config;
+    const char *fn = NULL;
+    int size = 0;
+    unsigned char *buf;
+    int fd = -1;
+
+    if (argc == 1) {
+        printf("Usage: halplay -f <format> -c <channel number> -r <sample rate> <filename>\n");
+        return 0;
+    }
+
+    while ((c = getopt(argc, argv, "f:c:r:")) != -1) {
+        switch (c) {
+            case 'f':
+                format = atoi(optarg);
+                break;
+            case 'c':
+                ch = atoi(optarg);
+                break;
+            case 'r':
+                sr = atoi(optarg);
+                break;
+            case '?':
+                fprintf(stderr, "Error in an argument.\n");
+                return -1;
+            default:
+                return -1;
+        }
+    }
+
+    if (optind < argc) {
+        fn = argv[optind];
+    }
+
+    if (!fn) {
+        fprintf(stderr, "No file name specified\n");
+        return -1;
+    }
+
+    if ((format < 0) || (format >= FORMAT_MAX)) {
+        int i;
+        fprintf(stderr, "Wrong format, valid format:\n");
+        for (i = 0; i < FORMAT_MAX; i++)
+            fprintf(stderr, "\t%d: %s\n", i, format_str[i]);
+        return -1;
+    }
+
+    if (format_is_pcm(format)) {
+        if ((ch < 1) || (ch > 8)) {
+            fprintf(stderr, "Wrong channel number, valid range [1-8]\n");
+            return -1;
+        }
+        if ((sr != 32000) && (sr != 44100) && (sr != 48000)) {
+            fprintf(stderr, "Invalid sample rate, valid options [32000, 44100, 48000]\n");
+            return -1;
+        }
+        if ((ch != 1) && (ch != 2) && (ch != 6) && (ch != 8)) {
+            fprintf(stderr, "Invalid channel number, valid options [1, 2, 6, 8]\n");
+            return -1;
+        }
+    }
+
+    ret = audio_hw_load_interface(&device);
+    if (ret) {
+        fprintf(stderr, "%s %d error:%d\n", __func__, __LINE__, ret);
+        return ret;
+    }
+    printf("hw version: %x\n", device->common.version);
+    printf("hal api version: %x\n", device->common.module->hal_api_version);
+    printf("module id: %s\n", device->common.module->id);
+    printf("module name: %s\n", device->common.module->name);
+
+    if (device->get_supported_devices) {
+        uint32_t support_dev = 0;
+        support_dev = device->get_supported_devices(device);
+        printf("supported device: %x\n", support_dev);
+    }
+
+    int inited = device->init_check(device);
+    if (inited) {
+        printf("device not inited, quit\n");
+        goto exit;
+    }
+
+    buf = fmap(fn, &size, &fd);
+    if (!buf) {
+        fprintf(stderr, "Error, cannot open input file\n");
+        goto exit;
+    }
+
+    /* set audio config */
+    memset(&config, 0, sizeof(config));
+
+    if (format_is_pcm(format)) {
+        config.sample_rate = sr;
+        switch (ch) {
+            case 1:
+                config.channel_mask = AUDIO_CHANNEL_OUT_MONO;
+                break;
+            case 2:
+                config.channel_mask = AUDIO_CHANNEL_OUT_STEREO;
+                break;
+            case 6:
+                config.channel_mask = AUDIO_CHANNEL_OUT_5POINT1;
+                break;
+            case 8:
+                config.channel_mask = AUDIO_CHANNEL_OUT_7POINT1;
+                break;
+            default:
+                config.channel_mask = AUDIO_CHANNEL_OUT_STEREO;
+                break;
+        }
+    } else {
+        config.sample_rate = 48000;
+        config.channel_mask = AUDIO_CHANNEL_OUT_5POINT1;
+    }
+    config.format = format_tab[format];
+
+    test_output_stream(device, buf, size, &config);
+
+    funmap(buf, size, fd);
+
+exit:
+    audio_hw_unload_interface(device);
+    return 0;
+}
-- 
2.24.1

