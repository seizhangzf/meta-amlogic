From 6b7bf1727b2b95aeb664cd9e9d5095f34ad64a14 Mon Sep 17 00:00:00 2001
From: Pradeep Sriram <pradeep.sriram@amlogic.com>
Date: Sat, 14 Mar 2020 12:13:37 -0700
Subject: [PATCH] add headers

---
 .../include/cdm/include/cdm.h                 | 664 ++++++++++++++++++
 .../include/cdm/include/cdm_version.h         |   2 +
 .../include/cdm/include/properties_ce.h       |  31 +
 .../include/core/include/buffer_reader.h      |  70 ++
 .../core/include/cdm_client_property_set.h    |  28 +
 .../include/core/include/cdm_engine.h         | 345 +++++++++
 .../include/core/include/cdm_session.h        | 263 +++++++
 .../include/core/include/cdm_session_map.h    |  52 ++
 .../core/include/certificate_provisioning.h   |  64 ++
 .../include/core/include/clock.h              |  24 +
 .../include/core/include/crypto_key.h         |  60 ++
 .../include/core/include/crypto_session.h     | 303 ++++++++
 .../include/core/include/device_files.h       | 249 +++++++
 .../include/core/include/file_store.h         |  80 +++
 .../core/include/initialization_data.h        |  82 +++
 .../include/core/include/license.h            | 136 ++++
 .../include/core/include/license_key_status.h | 143 ++++
 .../include/core/include/lock.h               |  51 ++
 .../include/core/include/log.h                |  44 ++
 .../include/core/include/oemcrypto_adapter.h  |  85 +++
 .../include/core/include/override.h           |  18 +
 .../include/core/include/policy_engine.h      | 216 ++++++
 .../include/core/include/privacy_crypto.h     |  70 ++
 .../include/core/include/properties.h         | 130 ++++
 .../include/core/include/scoped_ptr.h         |  65 ++
 .../core/include/service_certificate.h        |  85 +++
 .../include/core/include/shared_ptr.h         | 222 ++++++
 .../include/core/include/string_conversions.h |  30 +
 .../include/core/include/usage_table_header.h | 136 ++++
 .../include/core/include/wv_cdm_constants.h   | 115 +++
 .../core/include/wv_cdm_event_listener.h      |  31 +
 .../include/core/include/wv_cdm_types.h       | 542 ++++++++++++++
 32 files changed, 4436 insertions(+)
 create mode 100644 widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/cdm/include/cdm.h
 create mode 100644 widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/cdm/include/cdm_version.h
 create mode 100644 widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/cdm/include/properties_ce.h
 create mode 100644 widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/core/include/buffer_reader.h
 create mode 100644 widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/core/include/cdm_client_property_set.h
 create mode 100644 widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/core/include/cdm_engine.h
 create mode 100644 widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/core/include/cdm_session.h
 create mode 100644 widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/core/include/cdm_session_map.h
 create mode 100644 widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/core/include/certificate_provisioning.h
 create mode 100644 widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/core/include/clock.h
 create mode 100644 widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/core/include/crypto_key.h
 create mode 100644 widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/core/include/crypto_session.h
 create mode 100644 widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/core/include/device_files.h
 create mode 100644 widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/core/include/file_store.h
 create mode 100644 widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/core/include/initialization_data.h
 create mode 100644 widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/core/include/license.h
 create mode 100644 widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/core/include/license_key_status.h
 create mode 100644 widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/core/include/lock.h
 create mode 100644 widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/core/include/log.h
 create mode 100644 widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/core/include/oemcrypto_adapter.h
 create mode 100644 widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/core/include/override.h
 create mode 100644 widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/core/include/policy_engine.h
 create mode 100644 widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/core/include/privacy_crypto.h
 create mode 100644 widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/core/include/properties.h
 create mode 100644 widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/core/include/scoped_ptr.h
 create mode 100644 widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/core/include/service_certificate.h
 create mode 100644 widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/core/include/shared_ptr.h
 create mode 100644 widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/core/include/string_conversions.h
 create mode 100644 widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/core/include/usage_table_header.h
 create mode 100644 widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/core/include/wv_cdm_constants.h
 create mode 100644 widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/core/include/wv_cdm_event_listener.h
 create mode 100644 widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/core/include/wv_cdm_types.h

diff --git a/widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/cdm/include/cdm.h b/widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/cdm/include/cdm.h
new file mode 100644
index 0000000..4993c9e
--- /dev/null
+++ b/widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/cdm/include/cdm.h
@@ -0,0 +1,664 @@
+// Copyright 2015 Google Inc. All Rights Reserved.
+// Based on the EME draft spec from 2016 June 10.
+// http://www.w3.org/TR/2016/WD-encrypted-media-20160610/"
+#ifndef WVCDM_CDM_CDM_H_
+#define WVCDM_CDM_CDM_H_
+
+#if defined(_MSC_VER)
+typedef unsigned char uint8_t;
+typedef unsigned int uint32_t;
+typedef int int32_t;
+typedef __int64 int64_t;
+#else
+# include <stdint.h>
+#endif
+
+#include <map>
+#include <string>
+#include <vector>
+
+// Define CDM_EXPORT to export functionality across shared library boundaries.
+#if defined(WIN32)
+# if defined(CDM_IMPLEMENTATION)
+#  define CDM_EXPORT __declspec(dllexport)
+# else
+#  define CDM_EXPORT __declspec(dllimport)
+# endif  // defined(CDM_IMPLEMENTATION)
+#else  // defined(WIN32)
+# if defined(CDM_IMPLEMENTATION)
+#  define CDM_EXPORT __attribute__((visibility("default")))
+# else
+#  define CDM_EXPORT
+# endif
+#endif  // defined(WIN32)
+
+namespace widevine {
+
+class CDM_EXPORT ITimerClient {
+ public:
+  // Called by ITimer when a timer expires.
+  virtual void onTimerExpired(void* context) = 0;
+
+ protected:
+  ITimerClient() {}
+  virtual ~ITimerClient() {}
+};
+
+class CDM_EXPORT Cdm : public ITimerClient {
+ public:
+  // Session types defined by EME.
+  typedef enum {
+    kTemporary = 0,
+    kPersistentLicense = 1,
+    kPersistent = kPersistentLicense,  // deprecated name from June 1 draft
+    kPersistentUsageRecord = 2,
+  } SessionType;
+
+  // Message types defined by EME.
+  typedef enum {
+    kLicenseRequest = 0,
+    kLicenseRenewal = 1,
+    kLicenseRelease = 2,
+    kIndividualizationRequest = 3,  // Not used. Direct Individualization
+                                    // is used instead of App-Assisted
+    kLicenseSub = 4                 // Used in loading sub licenses from
+                                    // embedded key data.
+  } MessageType;
+
+  // Status codes returned by CDM functions.
+  //
+  typedef enum {
+    kSuccess = 0,
+
+    // These are analogous to the exceptions defined in the EME specification.
+    // Client implementations that support the EME API should pass these
+    // directly to the client application.
+    // Note: kTypeError replaced kInvalidAccess in the 6/1/2015 EME spec.
+    kTypeError = 1,
+    kNotSupported = 2,
+    kInvalidState = 3,
+    kQuotaExceeded = 4,
+
+    // These are additional codes defined by Widevine. In client implementations
+    // that support the EME API, these codes should be handled in the system
+    // layer. If it is necessary to notify the client application of one of
+    // these statuses, it should be mapped to one of the exception codes defined
+    // in the EME specification.
+    kNeedsDeviceCertificate = 101,
+    kSessionNotFound = 102,
+    kDecryptError = 103,
+    kNoKey = 104,
+    kKeyUsageBlockedByPolicy = 105,
+    kRangeError = 106,
+
+    // The action could not be completed yet but has been scheduled to be done
+    // later.  A call to |event_listener.onDeferredComplete| will be made once
+    // the action is complete.
+    kDeferred = 99998,
+    // This covers errors that we do not expect (see logs for details):
+    kUnexpectedError = 99999,
+  } Status;
+
+  // These are the init data types defined by EME.
+  typedef enum {
+    kCenc = 0,
+    kKeyIds = 1,  // NOTE: not supported by Widevine at this time
+    kWebM = 2,
+
+    // This type is not defined by EME but is supported by Widevine
+    kHls = 10000,
+  } InitDataType;
+
+  // These are the crypto schemes supported by CENC 3.0.
+  typedef enum {
+    kClear = 0,
+    kAesCtr = 1,  // AES-CTR, for use with cenc and cens modes
+    kAesCbc = 2,  // AES-CBC, for use with cbc1 and cbcs modes
+  } EncryptionScheme;
+
+  // These are key statuses defined by EME.
+  typedef enum {
+    kUsable = 0,
+    kExpired = 1,
+    kOutputRestricted = 2,
+    kOutputNotAllowed = kOutputRestricted,  // deprecated name from June 1 draft
+    kStatusPending = 3,
+    kInternalError = 4,
+    kReleased = 5,
+  } KeyStatus;
+
+  // Permissible usages for a key. Returned as a set of flags; multiple
+  // flags may be set. The specific settings are defined in the license
+  // and the OEMCrypto Key Control Block. The CDM uses settings in the
+  // license to derive these flags.
+  typedef uint32_t KeyAllowedUsageFlags;
+  static const KeyAllowedUsageFlags kAllowNone = 0;
+  static const KeyAllowedUsageFlags kAllowDecryptToClearBuffer = 1;
+  static const KeyAllowedUsageFlags kAllowDecryptToSecureBuffer = 2;
+  static const KeyAllowedUsageFlags kAllowGenericEncrypt = 4;
+  static const KeyAllowedUsageFlags kAllowGenericDecrypt = 8;
+  static const KeyAllowedUsageFlags kAllowGenericSign = 16;
+  static const KeyAllowedUsageFlags kAllowGenericSignatureVerify = 32;
+
+  // These are defined by Widevine.  The CDM can be configured to decrypt in
+  // three modes (dependent on OEMCrypto support).
+  typedef enum {
+    // Data is decrypted to an opaque handle.
+    // Translates to OEMCrypto's OEMCrypto_BufferType_Secure.
+    kOpaqueHandle = 0,
+
+    // Decrypted data never returned to the caller, but is decoded and rendered
+    // by OEMCrypto.
+    // Translates to OEMCrypto's OEMCrypto_BufferType_Direct.
+    kDirectRender = 1,
+
+    // There is no secure output available, so all data is decrypted into a
+    // clear buffer in main memory.
+    // Translates to OEMCrypto's OEMCrypto_BufferType_Clear.
+    kNoSecureOutput = 2,
+  } SecureOutputType;
+
+  // Logging levels defined by Widevine.
+  // See Cdm::initialize().
+  typedef enum {
+    kSilent = -1,
+    kErrors = 0,
+    kWarnings = 1,
+    kInfo = 2,
+    kDebug = 3,
+    kVerbose = 4,
+  } LogLevel;
+
+  // A map of key statuses.
+  // See Cdm::getKeyStatuses().
+  typedef std::map<std::string, KeyStatus> KeyStatusMap;
+
+  // An event listener interface provided by the application and attached to
+  // each CDM session.
+  // See Cdm::createSession().
+  class IEventListener {
+   public:
+    // A message (license request, renewal, etc.) to be dispatched to the
+    // application's license server.
+    // The response, if successful, should be provided back to the CDM via a
+    // call to Cdm::update().
+    virtual void onMessage(const std::string& session_id,
+                           MessageType message_type,
+                           const std::string& message) = 0;
+
+    // There has been a change in the keys in the session or their status.
+    virtual void onKeyStatusesChange(const std::string& session_id) = 0;
+
+    // A remove() operation has been completed.
+    virtual void onRemoveComplete(const std::string& session_id) = 0;
+
+    // Called when a deferred action has completed.
+    virtual void onDeferredComplete(const std::string& session_id,
+                                    Status result) = 0;
+
+    // Called when the CDM requires a new device certificate
+    virtual void onDirectIndividualizationRequest(
+        const std::string& session_id, const std::string& request) = 0;
+
+   protected:
+    IEventListener() {}
+    virtual ~IEventListener() {}
+  };
+
+  // A storage interface provided by the application. This defines the "origin"
+  // that the CDM will operate in by the files it can access.  Passing different
+  // IStorage instances to Cdm::create will cause those CDM instances to be in
+  // different "origins" as defined by the IStorage instance.  For example,
+  // different IStorage instances could be tied to different folders for
+  // different origins.
+  //
+  // It is important for multi-origin hosts to verify the application's origin.
+  // This ensures that the application does not access files from another
+  // origin.
+  //
+  // NOTE: It is important for users of your application to be able to clear
+  // stored data.  Also, browsers or other multi-application systems should
+  // store data separately per-app or per-origin.
+  // See http://www.w3.org/TR/encrypted-media/#privacy-storedinfo.
+  class IStorage {
+   public:
+    virtual bool read(const std::string& name,
+                      std::string* data) = 0;
+    virtual bool write(const std::string& name,
+                       const std::string& data) = 0;
+    virtual bool exists(const std::string& name) = 0;
+    virtual bool remove(const std::string& name) = 0;
+    virtual int32_t size(const std::string& name) = 0;
+
+    // populates |file_names| with the name of each file in the file system.
+    // This is assumed to be a flat filename space (top level directory is
+    // unnamed, and there are no subdirectories).
+    virtual bool list(std::vector<std::string>* file_names) = 0;
+
+   protected:
+    IStorage() {}
+    virtual ~IStorage() {}
+  };
+
+  // A clock interface provided by the application, independent of CDM
+  // instances.
+  // See Cdm::initialize().
+  class IClock {
+   public:
+    // Returns the current time in milliseconds since 1970 UTC.
+    virtual int64_t now() = 0;
+
+   protected:
+    IClock() {}
+    virtual ~IClock() {}
+  };
+
+  // A timer interface provided by the application, independent of CDM
+  // instances.
+  // See Cdm::initialize().
+  class ITimer {
+   public:
+    // This typedef is for backward compatibility with v3.0.0.
+    typedef ITimerClient IClient;
+
+    // Call |client->onTimerExpired(context)| after a delay of |delay_ms| ms.
+    virtual void setTimeout(int64_t delay_ms,
+                            IClient* client,
+                            void* context) = 0;
+
+    // Cancel all timers associated with |client|.
+    virtual void cancel(IClient *client) = 0;
+
+   protected:
+    ITimer() {}
+    virtual ~ITimer() {}
+  };
+
+  // Client information, provided by the application, independent of CDM
+  // instances.
+  // See Cdm::initialize().
+  // These parameters end up as client identification in license requests.
+  // All fields may be used by a license server proxy to drive business logic.
+  // Some fields are required (indicated below), but please fill out as many
+  // as make sense for your application.
+  // No user-identifying information may be put in these fields!
+  struct ClientInfo {
+    // The name of the product or application, e.g. "TurtleTube"
+    // Required.
+    std::string product_name;
+
+    // The name of the company who makes the device, e.g. "Kubrick, Inc."
+    // Required.
+    std::string company_name;
+
+    // The name of the device, e.g. "HAL"
+    std::string device_name;
+
+    // The device model, e.g. "HAL 9000"
+    // Required.
+    std::string model_name;
+
+    // The architecture of the device, e.g. "x86-64"
+    std::string arch_name;
+
+    // Information about the build of the browser, application, or platform into
+    // which the CDM is integrated, e.g. "v2.71828, 2038-01-19-03:14:07"
+    std::string build_info;
+  };
+
+  // Initialize the CDM library and provide access to platform services.
+  // All platform interfaces are required.
+  // Logging is controlled by |verbosity|.
+  // Must be called and must return kSuccess before create() is called.
+  static Status initialize(
+      SecureOutputType secure_output_type,
+      const ClientInfo& client_info,
+      IStorage* storage,
+      IClock* clock,
+      ITimer* timer,
+      LogLevel verbosity);
+
+  // Query the CDM library version.
+  static const char* version();
+
+  // Constructs a new CDM instance.
+  // initialize() must be called first and must return kSuccess before a CDM
+  // instance may be constructed.
+  // The CDM may notify of events at any time via the provided |listener|,
+  // which may not be NULL.
+  // |storage| defines the storage to use for this instance.  This can be used
+  // to provide per-origin storage.  Passing NULL will use the storage passed
+  // to initialize().
+  // If |privacy_mode| is true, server certificates are required and will be
+  // used to encrypt messages to the license server.
+  // By using server certificates to encrypt communication with the license
+  // server, device-identifying information cannot be extracted from the
+  // license exchange process by an intermediate layer between the CDM and
+  // the server.
+  // This is particularly useful for browser environments, but is recommended
+  // for use whenever possible.
+  static Cdm* create(IEventListener* listener,
+                     IStorage* storage,
+                     bool privacy_mode);
+
+  virtual ~Cdm() {}
+
+  // Sets up a service certificate for the CDM. It is used to encrypt
+  // outgoing messages (the ClientIdentification portion of the license and
+  // provisioning requests). It also holds the provider ID setting, used in
+  // the provisioning request.
+  // If setServiceCertificate() is not called, provider ID will not be set
+  // in the provisioning request.  If this function is not called and
+  // privacy mode is enabled, a service certificate request will be initiated
+  // as a preliminary step in the license request.
+  virtual Status setServiceCertificate(const std::string& certificate) = 0;
+
+  // Create a Service Certificate Request message.
+  // This is used to fetch a service certificate from the license server.
+  // It is needed in cases where the system or application does not have
+  // a service certificate for the license server.
+  // The service certificate holds the RSA public key for the server and
+  // other fields needed for provisioning. It is also needed for privacy mode.
+  virtual Status getServiceCertificateRequest(std::string* message) = 0;
+
+  // Parse a Service Certificate Response message and extract the certificate.
+  // This is used when fetching a service certificate from the license server.
+  // The response input is the string returned by the license server
+  // (see getServiceCertificateRequest()). The service certificate is installed
+  // if no error is returned. The returned certificate string may be used in
+  // future sessions as the input to setServiceCertificate(), avoiding extra
+  // calls to the license server.
+  virtual Status parseServiceCertificateResponse(const std::string& response,
+                                                 std::string* certificate) = 0;
+
+  // Determine if the device has a Device Certificate (for the current origin).
+  // The Device Certificate is origin-specific, and the origin is
+  // dertermined by the CDM's current IStorage object.
+  virtual bool isProvisioned() = 0;
+
+  // Remove the device's Device Certificate (for the current origin).
+  // The Device Certificate is origin-specific, and the origin is
+  // determined by the CDM's current IStorage object.
+  virtual Status removeProvisioning() = 0;
+
+  // Remove the device's usage table.
+  // This calls on OEMCrypto to delete its usage records.
+  virtual Status removeUsageTable() = 0;
+
+  // Get the current list of offline licenses on the system.
+  // License storage is origin-specific, and the origin is determined by the
+  // CDM's current IStorage object.
+  virtual Status listStoredLicenses(std::vector<std::string>* key_set_ids) = 0;
+
+  // Get the current list of secure-stop licenses on the system.
+  // License storage is origin-specific, and the origin is determined by the
+  // CDM's current IStorage object. ksids receives list of KSIDs representing
+  // usage records or secure-stop licenses.
+  virtual Status listUsageRecords(std::vector<std::string>* ksids) = 0;
+
+  // Delete the usage record for the given key_set_id.
+  // Usage info storage is origin-specific, and the origin is determined by the
+  // CDM's current IStorage object.
+  virtual Status deleteUsageRecord(const std::string& key_set_id) = 0;
+
+  // Delete all usage records for the current origin.
+  // Usage info storage is origin-specific, and the origin is determined by the
+  // CDM's current IStorage object.
+  virtual Status deleteAllUsageRecords() = 0;
+
+  // Creates a new session.
+  // Do not use this to load an existing persistent session (use load()).
+  // If successful, the session_id is returned via |sessionId|.
+  virtual Status createSession(SessionType session_type,
+                               std::string* session_id) = 0;
+
+  // Generates a request based on the initData.
+  // The request will be provided via a synchronous call to
+  // IEventListener::onMessage().
+  // This is done so that license requests and renewals follow the same flow.
+  virtual Status generateRequest(const std::string& session_id,
+                                 InitDataType init_data_type,
+                                 const std::string& init_data) = 0;
+
+  // Loads an existing persisted session from storage.
+  virtual Status load(const std::string& session_id) = 0;
+
+  // Loads a new sublicense as specified in init_data.
+  virtual Status load(const std::string& session_id,
+                      InitDataType init_data_type,
+                      const std::string& init_data) = 0;
+
+  // Provides messages, including licenses, to the CDM.
+  // If the message is a successful response to a release message, stored
+  // session data will be removed for the session.
+  virtual Status update(const std::string& session_id,
+                        const std::string& response) = 0;
+
+  // The time, in milliseconds since 1970 UTC, after which the key(s) in the
+  // session will no longer be usable to decrypt media data, or -1 if no such
+  // time exists.
+  virtual Status getExpiration(const std::string& session_id,
+                               int64_t* expiration) = 0;
+
+  // A map of known key IDs to the current status of the associated key.
+  virtual Status getKeyStatuses(const std::string& session_id,
+                                KeyStatusMap* key_statuses) = 0;
+
+  // Gets the permitted usage for a specific key by ID.
+  virtual Status getKeyAllowedUsages(const std::string& session_id,
+                                     const std::string& key_id,
+                                     KeyAllowedUsageFlags* usage_flags) = 0;
+
+  // Gets the permitted usage for a specific key by ID.
+  // Search for key across all known sessions.  If there are keys in separate
+  // sessions that match the given key_id, return kTypeError unless all such
+  // keys have identical Allowed Usage settings.
+  virtual Status getKeyAllowedUsages(const std::string& key_id,
+                                     KeyAllowedUsageFlags* usage_flags) = 0;
+
+  // Indicates that the application no longer needs the session and the CDM
+  // should release any resources associated with it and close it.
+  // Does not generate release messages for persistent sessions.
+  // Does not remove stored session data for persistent sessions.
+  virtual Status close(const std::string& session_id) = 0;
+
+  // Removes stored session data associated with the session.
+  // The session must be loaded before it can be removed.
+  // Generates release messages, which must be delivered to the license server.
+  // A reply from the license server must be provided via update() before the
+  // session is fully removed.
+  virtual Status remove(const std::string& session_id) = 0;
+
+  // Describes a repeating pattern as defined by the CENC 3.0 standard. A
+  // CENC 3.0 pattern consists of a number of encrypted blocks followed by a
+  // number of clear blocks, after which it repeats.
+  struct Pattern {
+   public:
+    Pattern()
+      : encrypted_blocks(0),
+        clear_blocks(0) {}
+
+    Pattern(uint32_t encrypt, uint32_t clear)
+      : encrypted_blocks(encrypt),
+        clear_blocks(clear) {}
+
+    // The number of crypto blocks that are encrypted and therefore need to be
+    // decrypted.
+    uint32_t encrypted_blocks;
+
+    // The number of crypto blocks that are not encrypted and therefore should
+    // be skipped when doing decryption.
+    uint32_t clear_blocks;
+  };
+
+  struct InputBuffer {
+   public:
+    InputBuffer()
+      : key_id(NULL),
+        key_id_length(0),
+        iv(NULL),
+        iv_length(0),
+        pattern(),
+        data(NULL),
+        data_length(0),
+        block_offset(0),
+        encryption_scheme(kAesCtr),
+        is_video(true),
+        first_subsample(true),
+        last_subsample(true) {}
+
+    const uint8_t* key_id;
+    uint32_t key_id_length;
+
+    // The IV is expected to be 16 bytes.
+    const uint8_t* iv;
+    uint32_t iv_length;
+
+    // Describes the repeating pattern with which the content was encrypted.  If
+    // left at its default value of (0,0), patterns will be disabled.  Should
+    // only be changed for content that uses patterns, such as for CENC 3.0
+    // "cens" and "cbcs" content or for HLS content.
+    Pattern pattern;
+
+    // This pointer and length describe the data to be decrypted.  This data
+    // should be ready to be decrypted with no further processing.  If the data
+    // is coming from a format that requires processing before decryption, that
+    // processing needs to happen before the data is passed in here.  For
+    // example, content coming from HLS will need to have its extra start code
+    // emulation prevention removed before it is passed to Widevine.
+    const uint8_t* data;
+    uint32_t data_length;
+
+    // |data|'s offset within its 16-byte AES block.  Only used for encrypted
+    // subsamples from content using CENC standards before 3.0 or the
+    // equivalent mode in CENC 3.0, "cenc" mode.  Should always be 0 in CENC 3.0
+    // modes "cens," "cbc1," and "cbcs," as well as for HLS content.  When used,
+    // it should start at 0 for each sample, then go up by |data_length| (mod
+    // 16) after the |is_encrypted| part of each subsample.
+    uint32_t block_offset;
+
+    // Specifies the encryption scheme, if any, to be used to decrypt the data.
+    // When set to kClear, decryption will copy the input data directly to the
+    // output buffer.  This is necessary for secure output types, where the
+    // output buffer cannot be directly accessed above the CDM.
+    EncryptionScheme encryption_scheme;
+
+    // Used by secure output type kDirectRender, where the secure hardware must
+    // decode and render the decrypted content:
+    bool is_video;
+    bool first_subsample;
+    bool last_subsample;
+  };
+
+  struct OutputBuffer {
+    OutputBuffer()
+      : data(NULL),
+        data_length(0),
+        data_offset(0),
+        is_secure(false) {}
+
+    // If |is_secure| is false or the secure output type is kNoSecureOutput,
+    // this is a memory address in main memory.
+    // If |is_secure| is true and the secure output type is kOpaqueHandle,
+    // this is an opaque handle.
+    // If |is_secure| is true and the secure output type is kDirectRender,
+    // this is ignored.
+    // See also SecureOutputType argument to initialize().
+    uint8_t* data;
+
+    // The maximum amount of data that can be decrypted to the buffer in this
+    // call, starting from |data|.
+    // Must be at least as large as the input buffer's |data_length|.
+    // This size accounts for the bytes that will be skipped by |data_offset|.
+    uint32_t data_length;
+
+    // An offset applied to the output address.
+    // Useful when |data| is an opaque handle rather than an address.
+    uint32_t data_offset;
+
+    // False for clear buffers, true otherwise.
+    // Must be false if the secure output type is kNoSecureOutput.
+    // See also SecureOutputType argument to initialize().
+    bool is_secure;
+  };
+
+  // Decrypt the input as described by |input| and pass the output as described
+  // in |output|.
+  virtual Status decrypt(const InputBuffer& input,
+                         const OutputBuffer& output) = 0;
+
+  // Sets a value in the custom app settings.  These are settings
+  // that are sent with any message to the license server.  These methods
+  // should only be used by advanced users maintaining existing systems.
+  // The |key| cannot be empty.
+  virtual Status setAppParameter(const std::string& key,
+                                 const std::string& value) = 0;
+
+  // Gets the current value in the custom app settings.  If the key is
+  // not present, then kTypeError is returned.  The |key| cannot be
+  // empty.  |result| cannot be null.  See setAppParameter().
+  virtual Status getAppParameter(const std::string& key,
+                                 std::string* result) = 0;
+
+  // Removes the value in the custom app settings.  If the key is not
+  // present, then kTypeError is returned.  The |key| cannot be empty.
+  // See setAppParameter().
+  virtual Status removeAppParameter(const std::string& key) = 0;
+
+  // Clears all the values in the custom app settings.  See setAppParameter().
+  virtual Status clearAppParameters() = 0;
+
+  // Generic crypto - functions for applying crypto operations to
+  // app-level data (outside the content stream).
+
+  typedef enum {
+    kEncryptionAlgorithmUnknown,
+    kEncryptionAlgorithmAesCbc128,
+  } GenericEncryptionAlgorithmType;
+
+  typedef enum {
+    kSigningAlgorithmUnknown,
+    kSigningAlgorithmHmacSha256
+  } GenericSigningAlgorithmType;
+
+  // Encrypts a buffer of app-level data.
+  virtual Status genericEncrypt(
+      const std::string& session_id, const std::string& in_buffer,
+      const std::string& key_id, const std::string& iv,
+      GenericEncryptionAlgorithmType algorithm, std::string* out_buffer) = 0;
+
+  // Decrypts a buffer of app-level data.
+  virtual Status genericDecrypt(
+      const std::string& session_id, const std::string& in_buffer,
+      const std::string& key_id, const std::string& iv,
+      GenericEncryptionAlgorithmType algorithm, std::string* out_buffer) = 0;
+
+  // Signs a buffer of app-level data.
+  virtual Status genericSign(
+      const std::string& session_id, const std::string& message,
+      const std::string& key_id, GenericSigningAlgorithmType algorithm,
+      std::string* signature) = 0;
+
+  // Verifies the signature on a buffer of app-level data.
+  // Returns kSuccess if signature is verified, otherwise returns kDecryptError.
+  virtual Status genericVerify(
+      const std::string& session_id, const std::string& message,
+      const std::string& key_id, GenericSigningAlgorithmType algorithm,
+      const std::string& signature) = 0;
+
+  // Enable enforcement of Video Resolution Constraints.
+  // This function should be called during session startup and any time
+  // the video resolution changes.
+  // Video resolution in license policy is a 32-bit value representing pixels.
+  // If the product of width and height is greater than or equal to 1^32,
+  // return kRangeError.
+  virtual Status setVideoResolution(const std::string& session_id,
+                                    uint32_t width, uint32_t height) = 0;
+
+ protected:
+  Cdm() {}
+};
+
+}  // namespace widevine
+
+#endif  // WVCDM_CDM_CDM_H_
diff --git a/widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/cdm/include/cdm_version.h b/widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/cdm/include/cdm_version.h
new file mode 100644
index 0000000..c5bbe8f
--- /dev/null
+++ b/widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/cdm/include/cdm_version.h
@@ -0,0 +1,2 @@
+// Widevine CE CDM Version
+#define CDM_VERSION "v3.5.0-0-gc0ea5d51-ce"
diff --git a/widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/cdm/include/properties_ce.h b/widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/cdm/include/properties_ce.h
new file mode 100644
index 0000000..05ddd9f
--- /dev/null
+++ b/widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/cdm/include/properties_ce.h
@@ -0,0 +1,31 @@
+// Copyright 2015 Google Inc. All Rights Reserved.
+#ifndef WVCDM_CDM_PROPERTIES_CE_H_
+#define WVCDM_CDM_PROPERTIES_CE_H_
+
+#include "cdm.h"
+
+#if defined(UNIT_TEST)
+# include <gtest/gtest.h>
+#endif
+
+namespace widevine {
+
+class PropertiesCE {
+ public:
+  static Cdm::ClientInfo GetClientInfo();
+  static Cdm::SecureOutputType GetSecureOutputType();
+  static void SetProvisioningMessagesAreBinary(bool bin_prov);
+
+ private:
+  static void SetSecureOutputType(Cdm::SecureOutputType secure_output_type);
+  static void SetClientInfo(const Cdm::ClientInfo& client_info);
+
+  friend class Cdm;
+#if defined(UNIT_TEST)
+  FRIEND_TEST(CdmTest, DeviceCertificateRequest);
+#endif
+};
+
+}  // namespace widevine
+
+#endif  // WVCDM_CDM_PROPERTIES_CE_H_
diff --git a/widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/core/include/buffer_reader.h b/widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/core/include/buffer_reader.h
new file mode 100644
index 0000000..f08ddda
--- /dev/null
+++ b/widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/core/include/buffer_reader.h
@@ -0,0 +1,70 @@
+// Copyright 2012 Google Inc. All Rights Reserved.
+
+#ifndef WVCDM_CORE_BUFFER_READER_H_
+#define WVCDM_CORE_BUFFER_READER_H_
+
+#include <stdint.h>
+#include <string>
+#include <vector>
+
+#include "wv_cdm_types.h"
+
+namespace wvcdm {
+
+// Annotate a function indicating the caller must examine the return value.
+// Use like:
+//   int foo() WARN_UNUSED_RESULT;
+// To explicitly ignore a result, see |ignore_result()| in <base/basictypes.h>.
+#if defined(COMPILER_GCC)
+#define WARN_UNUSED_RESULT __attribute__((warn_unused_result))
+#else
+#define WARN_UNUSED_RESULT
+#endif
+
+class BufferReader {
+ public:
+  BufferReader(const uint8_t* buf, size_t size)
+      : buf_(buf), size_(buf != NULL ? size : 0), pos_(0) {}
+
+  bool HasBytes(size_t count) const { return pos_ + count <= size_; }
+  bool IsEOF() const { return pos_ >= size_; }
+
+  // Read a value from the stream, performing endian correction,
+  // and advance the stream pointer.
+  bool Read1(uint8_t* v) WARN_UNUSED_RESULT;
+  bool Read2(uint16_t* v) WARN_UNUSED_RESULT;
+  bool Read2s(int16_t* v) WARN_UNUSED_RESULT;
+  bool Read4(uint32_t* v) WARN_UNUSED_RESULT;
+  bool Read4s(int32_t* v) WARN_UNUSED_RESULT;
+  bool Read8(uint64_t* v) WARN_UNUSED_RESULT;
+  bool Read8s(int64_t* v) WARN_UNUSED_RESULT;
+
+  bool ReadString(std::string* str, size_t count) WARN_UNUSED_RESULT;
+  bool ReadVec(std::vector<uint8_t>* t, size_t count) WARN_UNUSED_RESULT;
+
+  // These variants read a 4-byte integer of the corresponding signedness and
+  // store it in the 8-byte return type.
+  bool Read4Into8(uint64_t* v) WARN_UNUSED_RESULT;
+  bool Read4sInto8s(int64_t* v) WARN_UNUSED_RESULT;
+
+  // Advance the stream by this many bytes.
+  bool SkipBytes(size_t nbytes) WARN_UNUSED_RESULT;
+
+  const uint8_t* data() const { return buf_; }
+  size_t size() const { return size_; }
+  size_t pos() const { return pos_; }
+
+ protected:
+  const uint8_t* buf_;
+  size_t size_;
+  size_t pos_;
+
+  template <typename T>
+  bool Read(T* t) WARN_UNUSED_RESULT;
+
+  CORE_DISALLOW_COPY_AND_ASSIGN(BufferReader);
+};
+
+}  // namespace wvcdm
+
+#endif  // WVCDM_CORE_BUFFER_READER_H_
diff --git a/widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/core/include/cdm_client_property_set.h b/widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/core/include/cdm_client_property_set.h
new file mode 100644
index 0000000..589a60c
--- /dev/null
+++ b/widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/core/include/cdm_client_property_set.h
@@ -0,0 +1,28 @@
+// Copyright 2013 Google Inc. All Rights Reserved.
+
+#ifndef WVCDM_CORE_CDM_CLIENT_PROPERTY_SET_H_
+#define WVCDM_CORE_CDM_CLIENT_PROPERTY_SET_H_
+
+#include <stdint.h>
+#include <string>
+#include <vector>
+
+namespace wvcdm {
+
+class CdmClientPropertySet {
+ public:
+  virtual ~CdmClientPropertySet() {}
+
+  virtual const std::string& security_level() const = 0;
+  virtual bool use_privacy_mode() const = 0;
+  virtual const std::string& service_certificate() const = 0;
+  virtual void set_service_certificate(const std::string& cert) = 0;
+  virtual bool is_session_sharing_enabled() const = 0;
+  virtual uint32_t session_sharing_id() const = 0;
+  virtual void set_session_sharing_id(uint32_t id) = 0;
+  virtual const std::string& app_id() const = 0;
+};
+
+}  // namespace wvcdm
+
+#endif  // WVCDM_CORE_CDM_CLIENT_PROPERTY_SET_H_
diff --git a/widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/core/include/cdm_engine.h b/widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/core/include/cdm_engine.h
new file mode 100644
index 0000000..9780c3e
--- /dev/null
+++ b/widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/core/include/cdm_engine.h
@@ -0,0 +1,345 @@
+// Copyright 2013 Google Inc. All Rights Reserved.
+
+#ifndef WVCDM_CORE_CDM_ENGINE_H_
+#define WVCDM_CORE_CDM_ENGINE_H_
+
+#include <memory>
+#include <string>
+#include <vector>
+
+#include "cdm_session_map.h"
+#include "certificate_provisioning.h"
+#include "clock.h"
+#include "crypto_session.h"
+#include "file_store.h"
+#include "initialization_data.h"
+#include "lock.h"
+#include "metrics_collections.h"
+#include "oemcrypto_adapter.h"
+#include "scoped_ptr.h"
+#include "service_certificate.h"
+#include "timer_metric.h"
+#include "wv_cdm_constants.h"
+#include "wv_cdm_types.h"
+
+namespace wvcdm {
+
+class CdmClientPropertySet;
+class CdmSession;
+class CryptoEngine;
+class UsagePropertySet;
+class WvCdmEventListener;
+
+// Keep expiration time for each key set
+typedef std::map<CdmKeySetId,
+                 std::pair<CdmSessionId, int64_t> > CdmReleaseKeySetMap;
+
+class CdmEngine {
+ public:
+  CdmEngine(FileSystem* file_system, const std::string& spoid = EMPTY_SPOID);
+  virtual ~CdmEngine();
+
+  // Set service certificate for all sessions under this CDM/CdmEngine.
+  // Setting to the empty string is OK. If the License Service certificate is
+  // empty and privacy mode is true, the certificate will be fetched from
+  // the server before the first license request.
+  virtual CdmResponseType SetServiceCertificate(
+      const std::string& certificate);
+
+  // Report whether the service certificate has been set.
+  virtual bool HasServiceCertificate();
+
+  // Session related methods
+  virtual CdmResponseType OpenSession(
+      const CdmKeySystem& key_system, CdmClientPropertySet* property_set,
+      const CdmSessionId& forced_session_id,
+      WvCdmEventListener* event_listener);
+
+  virtual CdmResponseType OpenSession(
+      const CdmKeySystem& key_system, CdmClientPropertySet* property_set,
+      WvCdmEventListener* event_listener, CdmSessionId* session_id);
+
+  virtual CdmResponseType CloseSession(const CdmSessionId& session_id);
+
+  virtual bool IsOpenSession(const CdmSessionId& session_id);
+
+  virtual CdmResponseType OpenKeySetSession(
+      const CdmKeySetId& key_set_id, CdmClientPropertySet* property_set,
+      WvCdmEventListener* event_listener);
+
+  virtual CdmResponseType CloseKeySetSession(const CdmKeySetId& key_set_id);
+
+  // License related methods
+
+  // Construct a valid license request. The arguments are used as follows:
+  // session_id: The Session ID of the session the request is being generated
+  //             for. This is ignored for license release requests.
+  // key_set_id: The Key Set ID of the key set the request is being generated
+  //             for. This is ignored except for license release requests.
+  // init_data: The initialization data from the media file, which is used to
+  //            build the key request. This is ignored for release and renewal
+  //            requests.
+  // license_type: The type of license being requested. Never ignored.
+  // app_parameters: Additional, application-specific parameters that factor
+  //                 into the request generation. This is ignored for release
+  //                 and renewal requests.
+  // key_request: This must be non-null and point to a CdmKeyRequest. The
+  //              message field will be filled with the key request, the
+  //              type field will be filled with the key request type,
+  //              whether it is an initial request, renewal request,
+  //              release request, etc. The url field will be filled with
+  //              the default URL (if one is known) to send this key
+  //              request to.
+  virtual CdmResponseType GenerateKeyRequest(
+      const CdmSessionId& session_id, const CdmKeySetId& key_set_id,
+      const InitializationData& init_data, const CdmLicenseType license_type,
+      CdmAppParameterMap& app_parameters, CdmKeyRequest* key_request);
+  // This API may
+  // (a) accept license response, extract key info and load keys.
+  // (b) accept a renewal response and update license policy information.
+  // (c) accept a release response and release an offline license or secure
+  //     stop.
+  // (d) accept a service certificate and cache that information for the
+  //     the lifetime of the session.
+  //
+  // |session_id| identifies the session that generated the request and can
+  //              process the response. Should be empty if a release response.
+  // |key_data| is the license, renewal, release response or service
+  //            certificate response.
+  // |key_set_id| should be non-null and specified if license release.
+  //              If offline license or streaming license associated with
+  //              a secure stop, |key_set_id| should be non-null and will
+  //              be filled in on return. Use the |key_set_id| with
+  //              RestoreKeys (to reload offline session) or
+  //              GenerateKeyRequest (to release offline session/secure stop).
+  //              |key_set_id| will be cleared if release or streaming
+  //              (not associated with a secure stop).
+  virtual CdmResponseType AddKey(const CdmSessionId& session_id,
+                                 const CdmKeyResponse& key_data,
+                                 CdmKeySetId* key_set_id);
+
+  virtual CdmResponseType RestoreKey(const CdmSessionId& session_id,
+                                     const CdmKeySetId& key_set_id);
+
+  virtual CdmResponseType RemoveKeys(const CdmSessionId& session_id);
+
+  // Construct valid renewal request for the current session keys.
+  virtual CdmResponseType GenerateRenewalRequest(
+      const CdmSessionId& session_id, CdmKeyRequest* key_request);
+
+  // Accept renewal response and update key info.
+  virtual CdmResponseType RenewKey(const CdmSessionId& session_id,
+                                   const CdmKeyResponse& key_data);
+
+  // Query system information
+  virtual CdmResponseType QueryStatus(SecurityLevel security_level,
+                                      const std::string& query_token,
+                                      std::string* query_response);
+
+  // Query session information
+  virtual CdmResponseType QuerySessionStatus(const CdmSessionId& session_id,
+                                             CdmQueryMap* query_response);
+  virtual bool IsReleaseSession(const CdmSessionId& session_id);
+  virtual bool IsOfflineSession(const CdmSessionId& session_id);
+
+  // Query license information
+  virtual CdmResponseType QueryKeyStatus(const CdmSessionId& session_id,
+                                         CdmQueryMap* query_response);
+
+  // Query the types of usage permitted for the specified key.
+  virtual CdmResponseType QueryKeyAllowedUsage(const CdmSessionId& session_id,
+                                               const std::string& key_id,
+                                               CdmKeyAllowedUsage* key_usage);
+
+  // Query the types of usage permitted for the specified key.
+  // Apply the query across all sessions.  If the key is found in more than
+  // one session, return the allowed usage settings only if the usage settings
+  // are identical for each instance of the key.  Otherwise, clear the settings
+  // and return KEY_CONFLICT_1.
+  virtual CdmResponseType QueryKeyAllowedUsage(const std::string& key_id,
+                                               CdmKeyAllowedUsage* key_usage);
+
+  // Query OEMCrypto session ID
+  virtual CdmResponseType QueryOemCryptoSessionId(
+      const CdmSessionId& session_id, CdmQueryMap* query_response);
+
+  // Generate and return a valid provisioning request.
+  virtual CdmResponseType GetProvisioningRequest(
+      CdmCertificateType cert_type, const std::string& cert_authority,
+      CdmProvisioningRequest* request, std::string* default_url);
+
+  // Verify and process a provisioning response.
+  virtual CdmResponseType HandleProvisioningResponse(
+      const CdmProvisioningResponse& response, std::string* cert,
+      std::string* wrapped_key);
+
+  // Return true if there is a device certificate on the current
+  // (origin-specific) file system.
+  virtual bool IsProvisioned(CdmSecurityLevel security_level);
+
+  // Remove device DRM certificate from the current (origin-specific) file
+  // system. This will force the device to reprovision itself.
+  virtual CdmResponseType Unprovision(CdmSecurityLevel security_level);
+
+  // Delete OEMCrypto usage tables. Used by Unprovision().
+  virtual CdmResponseType DeleteUsageTable(CdmSecurityLevel security_level);
+
+  // Return the list of key_set_ids stored on the current (origin-specific)
+  // file system.
+  virtual CdmResponseType ListStoredLicenses(
+      CdmSecurityLevel security_level, std::vector<std::string>* key_set_ids);
+
+  // Return the list of key_set_ids stored as usage records on the
+  // current (origin-specific) file system.
+  virtual CdmResponseType ListUsageRecords(
+      const std::string& app_id, CdmSecurityLevel security_level,
+      std::vector<std::string>* ksids);
+
+  // Delete the usage record for the given key_set_id. This removes the
+  // usage record in the file system and the OEMCrypto usage record.
+  virtual CdmResponseType DeleteUsageRecord(const std::string& app_id,
+                                            CdmSecurityLevel security_level,
+                                            const std::string& key_set_id);
+
+  // Usage related methods for streaming licenses
+  // Retrieve a random usage info from the list of all usage infos for this app
+  // id.
+  virtual CdmResponseType GetUsageInfo(const std::string& app_id,
+                                       CdmUsageInfo* usage_info);
+
+  // Retrieve the usage info for the specified pst.
+  // Returns UNKNOWN_ERROR if no usage info was found.
+  virtual CdmResponseType GetUsageInfo(const std::string& app_id,
+                                       const CdmSecureStopId& ssid,
+                                       CdmUsageInfo* usage_info);
+
+  // Release all usage records for the current origin.
+  virtual CdmResponseType ReleaseAllUsageInfo(const std::string& app_id,
+                                              CdmSecurityLevel security_level);
+
+  // Release all usage records for the current origin. Span all
+  // security levels.
+  virtual CdmResponseType ReleaseAllUsageInfo(const std::string& app_id);
+
+  virtual CdmResponseType ReleaseUsageInfo(
+      const CdmUsageInfoReleaseMessage& message);
+  virtual CdmResponseType LoadUsageSession(const CdmKeySetId& key_set_id,
+                                           CdmKeyMessage* release_message);
+
+  // Decryption and key related methods
+  // Accept encrypted buffer and return decrypted data.
+  virtual CdmResponseType Decrypt(const CdmSessionId& session_id,
+                                  const CdmDecryptionParameters& parameters);
+
+  // Generic crypto operations - provides basic crypto operations that an
+  // application can use outside of content stream processing
+
+  // Encrypts a buffer of app-level data.
+  virtual CdmResponseType GenericEncrypt(
+      const std::string& session_id, const std::string& in_buffer,
+      const std::string& key_id, const std::string& iv,
+      CdmEncryptionAlgorithm algorithm, std::string* out_buffer);
+
+  // Decrypts a buffer of app-level data.
+  virtual CdmResponseType GenericDecrypt(
+      const std::string& session_id, const std::string& in_buffer,
+      const std::string& key_id, const std::string& iv,
+      CdmEncryptionAlgorithm algorithm, std::string* out_buffer);
+
+  // Computes the signature for a message.
+  virtual CdmResponseType GenericSign(const std::string& session_id,
+                                      const std::string& message,
+                                      const std::string& key_id,
+                                      CdmSigningAlgorithm algorithm,
+                                      std::string* signature);
+
+  // Verifies the signature on a buffer of app-level data.
+  virtual CdmResponseType GenericVerify(const std::string& session_id,
+                                        const std::string& message,
+                                        const std::string& key_id,
+                                        CdmSigningAlgorithm algorithm,
+                                        const std::string& signature);
+
+  virtual size_t SessionSize() const { return session_map_.Size(); }
+
+  // Is the key known to any session?
+  virtual bool IsKeyLoaded(const KeyId& key_id);
+  virtual bool FindSessionForKey(const KeyId& key_id, CdmSessionId* sessionId);
+
+  // Used for notifying the Max-Res Engine of resolution changes.
+  // Return false if no match is found for session_id.
+  virtual bool NotifyResolution(const CdmSessionId& session_id, uint32_t width,
+                                uint32_t height);
+
+  // Timer expiration method. This method is not re-entrant -- there can be
+  // only one timer.
+  // This method triggers appropriate event callbacks from |event_listener_|,
+  // which is assumed to be asynchronous -- i.e. an event should be dispatched
+  // to another thread which does the actual work. In particular, if a
+  // synchronous listener calls OpenSession or CloseSession, the thread will
+  // dead lock.
+  virtual void OnTimerEvent();
+
+  virtual metrics::EngineMetrics* GetMetrics() { return &metrics_; }
+
+ private:
+  // private methods
+  CdmResponseType OpenSession(
+      const CdmKeySystem& key_system, CdmClientPropertySet* property_set,
+      WvCdmEventListener* event_listener, const CdmSessionId* forced_session_id,
+      CdmSessionId* session_id);
+
+  void DeleteAllUsageReportsUponFactoryReset();
+  bool ValidateKeySystem(const CdmKeySystem& key_system);
+  CdmResponseType GetUsageInfo(const std::string& app_id,
+                               SecurityLevel requested_security_level,
+                               CdmUsageInfo* usage_info);
+
+  void OnKeyReleaseEvent(const CdmKeySetId& key_set_id);
+
+  std::string MapHdcpVersion(CryptoSession::HdcpCapability version);
+
+  void CloseExpiredReleaseSessions();
+
+  // instance variables
+
+  /*
+   * The metrics group must be the first variable declared to ensure
+   * that it is the last member destroyed so that no child members
+   * try to use a reference to it after it is destroyed. This will
+   * ensure that all data has been properly recorded in the group before
+   * it is published.
+   */
+  metrics::EngineMetrics metrics_;
+  metrics::TimerMetric life_span_;
+
+  CdmSessionMap session_map_;
+  CdmReleaseKeySetMap release_key_sets_;
+  scoped_ptr<CertificateProvisioning> cert_provisioning_;
+  SecurityLevel cert_provisioning_requested_security_level_;
+  FileSystem* file_system_;
+  Clock clock_;
+  std::string spoid_;
+
+  static bool seeded_;
+
+  // Service certificate for license server and provisioning server.
+  // It is initially empty.  If left empty, the operations that
+  // require them (getting provider_id, encrypting ClientIdentification)
+  // are not performed.
+  ServiceCertificate service_certificate_;
+
+  // usage related variables
+  scoped_ptr<CdmSession> usage_session_;
+  scoped_ptr<UsagePropertySet> usage_property_set_;
+  int64_t last_usage_information_update_time_;
+
+  // Protect release_key_sets_ from non-thread-safe operations.
+  Lock release_key_sets_lock_;
+
+  CORE_DISALLOW_COPY_AND_ASSIGN(CdmEngine);
+};
+
+}  // namespace wvcdm
+
+#endif  // WVCDM_CORE_CDM_ENGINE_H_
diff --git a/widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/core/include/cdm_session.h b/widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/core/include/cdm_session.h
new file mode 100644
index 0000000..e14cc79
--- /dev/null
+++ b/widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/core/include/cdm_session.h
@@ -0,0 +1,263 @@
+// Copyright 2012 Google Inc. All Rights Reserved.
+
+#ifndef WVCDM_CORE_CDM_SESSION_H_
+#define WVCDM_CORE_CDM_SESSION_H_
+
+#include <set>
+#include <string>
+#include <vector>
+
+#include "crypto_session.h"
+#include "device_files.h"
+#include "file_store.h"
+#include "initialization_data.h"
+#include "license.h"
+#include "metrics_collections.h"
+#include "oemcrypto_adapter.h"
+#include "policy_engine.h"
+#include "scoped_ptr.h"
+#include "timer_metric.h"
+#include "wv_cdm_types.h"
+
+namespace wvcdm {
+
+class CdmClientPropertySet;
+class ServiceCertificate;
+class WvCdmEventListener;
+class UsageTableHeader;
+
+class CdmSession {
+ public:
+  // Creates a new instance of the CdmSession with the given |file_system|
+  // and |metrics| parameters. Both parameters are owned by the caller and
+  // must remain in scope througout the scope of the new instance. |metrics|
+  // must not be null.
+  CdmSession(FileSystem* file_system, metrics::SessionMetrics* metrics);
+  virtual ~CdmSession();
+
+  void Close() { closed_ = true; }
+  bool IsClosed() { return closed_; }
+
+  // Initializes this instance of CdmSession with the given property set.
+  // |cdm_client_property_set| MAY be null, is owned by the caller,
+  // and must remain in scope throughout the scope of this session.
+  virtual CdmResponseType Init(CdmClientPropertySet* cdm_client_property_set);
+
+  // Initializes this instance of CdmSession with the given parmeters.
+  // All parameters are owned by the caller.
+  // |service_certificate| is caller owned, cannot be null, and must be in
+  //     scope as long as the session is in scope.
+  // |cdm_client_property_set| is caller owned, may be null, but must be
+  //     in scope as long as the session is in scope.
+  // |forced_session_id| is caller owned and may be null.
+  // |event_listener| is caller owned, may be null, but must be in scope
+  //     as long as the session is in scope.
+  virtual CdmResponseType Init(CdmClientPropertySet* cdm_client_property_set,
+                               const CdmSessionId* forced_session_id,
+                               WvCdmEventListener* event_listener);
+
+  virtual CdmResponseType RestoreOfflineSession(
+      const CdmKeySetId& key_set_id, const CdmLicenseType license_type);
+  virtual CdmResponseType RestoreUsageSession(
+      const DeviceFiles::CdmUsageData& usage_data);
+
+  virtual const CdmSessionId& session_id() { return session_id_; }
+  virtual const CdmKeySetId& key_set_id() { return key_set_id_; }
+
+  virtual CdmResponseType GenerateKeyRequest(
+      const InitializationData& init_data, CdmLicenseType license_type,
+      const CdmAppParameterMap& app_parameters, CdmKeyRequest* key_request);
+
+  // AddKey() - Accept license response and extract key info.
+  virtual CdmResponseType AddKey(const CdmKeyResponse& key_response);
+
+  // Query session status
+  virtual CdmResponseType QueryStatus(CdmQueryMap* query_response);
+
+  // Query license information
+  virtual CdmResponseType QueryKeyStatus(CdmQueryMap* query_response);
+
+  // Query allowed usages for key
+  virtual CdmResponseType QueryKeyAllowedUsage(const std::string& key_id,
+                                               CdmKeyAllowedUsage* key_usage);
+
+  // Query OEMCrypto session ID
+  virtual CdmResponseType QueryOemCryptoSessionId(CdmQueryMap* query_response);
+
+  // Decrypt() - Accept encrypted buffer and return decrypted data.
+  virtual CdmResponseType Decrypt(const CdmDecryptionParameters& parameters);
+
+  // License renewal
+  // GenerateRenewalRequest() - Construct valid renewal request for the current
+  // session keys.
+  virtual CdmResponseType GenerateRenewalRequest(CdmKeyRequest* key_request);
+
+  // RenewKey() - Accept renewal response and update key info.
+  virtual CdmResponseType RenewKey(const CdmKeyResponse& key_response);
+
+  // License release
+  // GenerateReleaseRequest() - Construct valid release request for the current
+  // session keys.
+  virtual CdmResponseType GenerateReleaseRequest(CdmKeyRequest* key_request);
+
+  // ReleaseKey() - Accept response and release key.
+  virtual CdmResponseType ReleaseKey(const CdmKeyResponse& key_response);
+
+  virtual CdmResponseType DeleteUsageEntry(uint32_t usage_entry_number);
+
+  virtual bool IsKeyLoaded(const KeyId& key_id);
+  virtual int64_t GetDurationRemaining();
+
+  // Used for notifying the Policy Engine of resolution changes
+  virtual void NotifyResolution(uint32_t width, uint32_t height);
+
+  virtual void OnTimerEvent(bool update_usage);
+  virtual void OnKeyReleaseEvent(const CdmKeySetId& key_set_id);
+
+  virtual void GetApplicationId(std::string* app_id);
+  virtual SecurityLevel GetRequestedSecurityLevel() {
+    return requested_security_level_;
+  }
+  virtual CdmSecurityLevel GetSecurityLevel() { return security_level_; }
+
+  // Delete usage information for the list of tokens, |provider_session_tokens|.
+  virtual CdmResponseType DeleteMultipleUsageInformation(
+      const std::vector<std::string>& provider_session_tokens);
+  virtual CdmResponseType UpdateUsageTableInformation();
+  virtual CdmResponseType UpdateUsageEntryInformation();
+
+  virtual bool is_initial_usage_update() { return is_initial_usage_update_; }
+  virtual bool is_usage_update_needed() { return is_usage_update_needed_; }
+  virtual void reset_usage_flags() {
+    is_initial_usage_update_ = false;
+    is_usage_update_needed_ = false;
+  }
+
+  virtual bool is_release() { return is_release_; }
+  virtual bool is_offline() { return is_offline_; }
+  virtual bool is_temporary() { return is_temporary_; }
+  virtual bool license_received() { return license_received_; }
+  virtual bool has_provider_session_token() {
+    return (license_parser_.get() != NULL &&
+        license_parser_->provider_session_token().size() > 0);
+  }
+
+  virtual CdmUsageSupportType get_usage_support_type()
+      { return usage_support_type_; }
+
+  // ReleaseCrypto() - Closes the underlying crypto session but leaves this
+  // object alive. It is invalid to call any method that requires a crypto
+  // session after calling this. Since calling this renders this object mostly
+  // useless, it is preferable to simply delete this object (which will also
+  // release the underlying crypto session) rather than call this method.
+  virtual CdmResponseType ReleaseCrypto();
+
+  // Delete current license and matching usage record
+  bool DeleteLicense();
+
+  // Generate unique ID for each new session.
+  CdmSessionId GenerateSessionId();
+
+  // Generic crypto operations - provides basic crypto operations that an
+  // application can use outside of content stream processing
+
+  // Encrypts a buffer of app-level data.
+  virtual CdmResponseType GenericEncrypt(const std::string& in_buffer,
+                                         const std::string& key_id,
+                                         const std::string& iv,
+                                         CdmEncryptionAlgorithm algorithm,
+                                         std::string* out_buffer);
+
+  // Decrypts a buffer of app-level data.
+  virtual CdmResponseType GenericDecrypt(const std::string& in_buffer,
+                                         const std::string& key_id,
+                                         const std::string& iv,
+                                         CdmEncryptionAlgorithm algorithm,
+                                         std::string* out_buffer);
+
+  // Computes the signature for a message.
+  virtual CdmResponseType GenericSign(const std::string& message,
+                                      const std::string& key_id,
+                                      CdmSigningAlgorithm algorithm,
+                                      std::string* signature);
+
+  // Verifies the signature on a buffer of app-level data.
+  virtual CdmResponseType GenericVerify(const std::string& message,
+                                        const std::string& key_id,
+                                        CdmSigningAlgorithm algorithm,
+                                        const std::string& signature);
+
+  virtual metrics::SessionMetrics* GetMetrics() { return metrics_; }
+
+ private:
+  friend class CdmSessionTest;
+
+  bool GenerateKeySetId(CdmKeySetId* key_set_id);
+
+  CdmResponseType StoreLicense();
+  bool StoreLicense(DeviceFiles::LicenseState state);
+
+  bool UpdateUsageInfo();
+
+  // These setters are for testing only. Takes ownership of the pointers.
+  void set_license_parser(CdmLicense* license_parser);
+  void set_crypto_session(CryptoSession* crypto_session);
+  void set_policy_engine(PolicyEngine* policy_engine);
+  void set_file_handle(DeviceFiles* file_handle);
+
+  // instance variables
+  metrics::SessionMetrics* metrics_;
+  metrics::CryptoMetrics* crypto_metrics_;
+  metrics::TimerMetric life_span_;
+
+  bool initialized_;
+  bool closed_;  // Session closed, but final shared_ptr has not been released.
+  CdmSessionId session_id_;
+  FileSystem* file_system_;
+  scoped_ptr<CdmLicense> license_parser_;
+  scoped_ptr<CryptoSession> crypto_session_;
+  scoped_ptr<PolicyEngine> policy_engine_;
+  scoped_ptr<DeviceFiles> file_handle_;
+  bool license_received_;
+  bool is_offline_;
+  bool is_release_;
+  bool is_temporary_;
+  CdmSecurityLevel security_level_;
+  SecurityLevel requested_security_level_;
+  CdmAppParameterMap app_parameters_;
+
+  // decryption flags
+  bool is_initial_decryption_;
+  bool has_decrypted_since_last_report_;  // ... last report to policy engine.
+
+  // Usage related flags and data
+  bool is_initial_usage_update_;
+  bool is_usage_update_needed_;
+  CdmUsageSupportType usage_support_type_;
+  UsageTableHeader* usage_table_header_;
+  uint32_t usage_entry_number_;
+  CdmUsageEntry usage_entry_;
+  std::string usage_provider_session_token_;
+
+  // information useful for offline and usage scenarios
+  CdmKeyMessage key_request_;
+  CdmKeyResponse key_response_;
+
+  // license type offline related information
+  CdmInitData offline_init_data_;
+  CdmKeyMessage offline_key_renewal_request_;
+  CdmKeyResponse offline_key_renewal_response_;
+  std::string offline_release_server_url_;
+
+  // license type release and offline related information
+  CdmKeySetId key_set_id_;
+
+  bool mock_license_parser_in_use_;
+  bool mock_policy_engine_in_use_;
+
+  CORE_DISALLOW_COPY_AND_ASSIGN(CdmSession);
+};
+
+}  // namespace wvcdm
+
+#endif  // WVCDM_CORE_CDM_SESSION_H_
diff --git a/widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/core/include/cdm_session_map.h b/widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/core/include/cdm_session_map.h
new file mode 100644
index 0000000..0d7f147
--- /dev/null
+++ b/widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/core/include/cdm_session_map.h
@@ -0,0 +1,52 @@
+// Copyright 2017 Google Inc. All Rights Reserved.
+
+#ifndef WVCDM_CORE_CDM_SESSION_MAP_H_
+#define WVCDM_CORE_CDM_SESSION_MAP_H_
+
+#include <list>
+#include <memory>
+#include <string>
+
+#include "cdm_session.h"
+#include "lock.h"
+#include "shared_ptr.h"
+#include "wv_cdm_types.h"
+
+namespace wvcdm {
+
+typedef std::list<shared_ptr<CdmSession> > CdmSessionList;
+
+class CdmSessionMap {
+ public:
+  CdmSessionMap() {}
+  virtual ~CdmSessionMap();
+
+  void Add(const std::string& id, CdmSession* session);
+
+  bool CloseSession(const std::string& id);
+
+  bool Exists(const std::string& id);
+
+  size_t Size() const { return sessions_.size(); }
+
+  bool FindSession(const CdmSessionId& id,
+                   shared_ptr<CdmSession>* session);
+
+  void GetSessionList(CdmSessionList& sessions);
+
+ private:
+  typedef std::map<CdmSessionId, shared_ptr<CdmSession> >
+      CdmIdToSessionMap;
+
+  bool FindSessionNoLock(const CdmSessionId& session_id,
+                         shared_ptr<CdmSession>* session);
+
+  Lock lock_;
+  CdmIdToSessionMap sessions_;
+
+  CORE_DISALLOW_COPY_AND_ASSIGN(CdmSessionMap);
+};
+
+}  // namespace wvcdm
+
+#endif  // WVCDM_CORE_CDM_SESSION_MAP_H_
diff --git a/widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/core/include/certificate_provisioning.h b/widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/core/include/certificate_provisioning.h
new file mode 100644
index 0000000..784f892
--- /dev/null
+++ b/widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/core/include/certificate_provisioning.h
@@ -0,0 +1,64 @@
+// Copyright 2013 Google Inc. All Rights Reserved.
+
+#ifndef WVCDM_CORE_CERTIFICATE_PROVISIONING_H_
+#define WVCDM_CORE_CERTIFICATE_PROVISIONING_H_
+
+#include <string>
+
+#include "crypto_session.h"
+#include "license_protocol.pb.h"
+#include "metrics_collections.h"
+#include "oemcrypto_adapter.h"
+#include "scoped_ptr.h"
+#include "wv_cdm_types.h"
+
+namespace wvcdm {
+
+class CdmClientPropertySet;
+class CdmSession;
+class FileSystem;
+class ServiceCertificate;
+
+class CertificateProvisioning {
+ public:
+  CertificateProvisioning(metrics::CryptoMetrics* metrics,
+                          ServiceCertificate* service_certificate) :
+      crypto_session_(metrics),
+      cert_type_(kCertificateWidevine),
+      service_certificate_(service_certificate) {}
+
+  ~CertificateProvisioning() {};
+
+  // Construct a valid provisioning request.
+  // The request will be sent to the provisioning server.
+  CdmResponseType GetProvisioningRequest(
+      SecurityLevel requested_security_level, CdmCertificateType cert_type,
+      const std::string& cert_authority, const std::string& origin,
+      const std::string& spoid, CdmProvisioningRequest* request,
+      std::string* default_url);
+
+  // Process the provisioning response.
+  CdmResponseType HandleProvisioningResponse(
+      FileSystem* file_system, const CdmProvisioningResponse& response,
+      std::string* cert, std::string* wrapped_key);
+
+ private:
+  bool GetProvisioningTokenType(
+      video_widevine::ClientIdentification::TokenType* token_type);
+
+  bool SetSpoidParameter(const std::string& origin, const std::string& spoid,
+                         video_widevine::ProvisioningRequest* request);
+
+  video_widevine::SignedProvisioningMessage::ProtocolVersion
+      GetProtocolVersion();
+
+  CryptoSession crypto_session_;
+  CdmCertificateType cert_type_;
+  ServiceCertificate* service_certificate_;
+
+  CORE_DISALLOW_COPY_AND_ASSIGN(CertificateProvisioning);
+};
+
+}  // namespace wvcdm
+
+#endif  // WVCDM_CORE_CERTIFICATE_PROVISIONING_H_
diff --git a/widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/core/include/clock.h b/widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/core/include/clock.h
new file mode 100644
index 0000000..10dc6b4
--- /dev/null
+++ b/widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/core/include/clock.h
@@ -0,0 +1,24 @@
+// Copyright 2013 Google Inc. All Rights Reserved.
+//
+// Clock - Platform independent interface for a time library
+//
+#ifndef WVCDM_CORE_CLOCK_H_
+#define WVCDM_CORE_CLOCK_H_
+
+#include <stdint.h>
+
+namespace wvcdm {
+
+// Provides time related information. The implementation is platform dependent.
+class Clock {
+ public:
+  Clock() {}
+  virtual ~Clock() {}
+
+  // Provides the number of seconds since an epoch - 01/01/1970 00:00 UTC
+  virtual int64_t GetCurrentTime();
+};
+
+}  // namespace wvcdm
+
+#endif  // WVCDM_CORE_CLOCK_H_
diff --git a/widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/core/include/crypto_key.h b/widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/core/include/crypto_key.h
new file mode 100644
index 0000000..0da57d5
--- /dev/null
+++ b/widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/core/include/crypto_key.h
@@ -0,0 +1,60 @@
+// Copyright 2012 Google Inc. All Rights Reserved.
+
+#ifndef WVCDM_CORE_CRYPTO_KEY_H_
+#define WVCDM_CORE_CRYPTO_KEY_H_
+
+#include "wv_cdm_types.h"
+
+namespace wvcdm {
+
+class CryptoKey {
+ public:
+  CryptoKey() {};
+  ~CryptoKey() {};
+
+  const std::string& key_id() const { return key_id_; }
+  const std::string& key_data() const { return key_data_; }
+  const std::string& key_data_iv() const { return key_data_iv_; }
+  const std::string& key_control() const { return key_control_; }
+  const std::string& key_control_iv() const { return key_control_iv_; }
+  const std::string& sub_session_key_id() const {return sub_session_key_id_;}
+  const std::string& sub_session_key() const {return sub_session_key_;}
+  const std::string& track_label() const { return track_label_; }
+  CdmCipherMode cipher_mode() const { return cipher_mode_; }
+  void set_key_id(const std::string& key_id) { key_id_ = key_id; }
+  void set_key_data(const std::string& key_data) { key_data_ = key_data; }
+  void set_key_data_iv(const std::string& iv) { key_data_iv_ = iv; }
+  void set_key_control(const std::string& ctl) { key_control_ = ctl; }
+  void set_key_control_iv(const std::string& ctl_iv) {
+    key_control_iv_ = ctl_iv;
+  }
+  void set_cipher_mode(CdmCipherMode cipher_mode) {
+    cipher_mode_ = cipher_mode;
+  }
+  void set_sub_session_key_id(const std::string& sub_session_key_id) {
+    sub_session_key_id_ = sub_session_key_id;
+  }
+  void set_sub_session_key(const std::string& sub_session_key) {
+      sub_session_key_ = sub_session_key;
+    }
+  void set_track_label(const std::string& track_label) {
+    track_label_ = track_label;
+  }
+
+  bool HasKeyControl() const { return key_control_.size() >= 16; }
+
+ private:
+  std::string key_id_;
+  std::string key_data_iv_;
+  std::string key_data_;
+  std::string key_control_;
+  std::string key_control_iv_;
+  std::string sub_session_key_id_;
+  std::string track_label_;
+  std::string sub_session_key_;
+  CdmCipherMode cipher_mode_;
+};
+
+}  // namespace wvcdm
+
+#endif  // WVCDM_CORE_CRYPTO_KEY_H_
diff --git a/widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/core/include/crypto_session.h b/widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/core/include/crypto_session.h
new file mode 100644
index 0000000..ae84948
--- /dev/null
+++ b/widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/core/include/crypto_session.h
@@ -0,0 +1,303 @@
+// Copyright 2012 Google Inc. All Rights Reserved.
+
+#ifndef WVCDM_CORE_CRYPTO_SESSSION_H_
+#define WVCDM_CORE_CRYPTO_SESSSION_H_
+
+#include <map>
+#include <string>
+#include <vector>
+
+#include "OEMCryptoCENC.h"
+#include "lock.h"
+#include "metrics_collections.h"
+#include "oemcrypto_adapter.h"
+#include "OEMCryptoCENC.h"
+#include "scoped_ptr.h"
+#include "timer_metric.h"
+#include "wv_cdm_types.h"
+
+namespace wvcdm {
+
+class CryptoKey;
+class UsageTableHeader;
+
+typedef std::map<std::string, CryptoKey*> CryptoKeyMap;
+typedef std::map<std::string, CryptoSessionId> SubLicenseSessionMap;
+
+class KeySession {
+ protected:
+  KeySession(metrics::CryptoMetrics* metrics) : metrics_(metrics) {}
+
+ public:
+  typedef enum { kDefault, kSubLicense } KeySessionType;
+  virtual ~KeySession() {}
+  virtual KeySessionType Type() = 0;
+  virtual bool GenerateDerivedKeys(const std::string& message) = 0;
+  virtual bool GenerateDerivedKeys(const std::string& message,
+                                   const std::string& session_key) = 0;
+  virtual OEMCryptoResult LoadKeys(const std::string& message,
+                                   const std::string& signature,
+                                   const std::string& mac_key_iv,
+                                   const std::string& mac_key,
+                                   const std::vector<CryptoKey>& keys,
+                                   const std::string& provider_session_token,
+                                   CdmCipherMode* cipher_mode,
+                                   const std::string& srm_requirement) = 0;
+  virtual OEMCryptoResult SelectKey(const std::string& key_id) = 0;
+  virtual OEMCryptoResult Decrypt(
+      const CdmDecryptionParameters& params,
+      OEMCrypto_DestBufferDesc& buffer_descriptor,
+      OEMCrypto_CENCEncryptPatternDesc& pattern_descriptor) = 0;
+
+ protected:
+  metrics::CryptoMetrics* metrics_;
+};
+
+class CryptoSession {
+ public:
+  typedef OEMCrypto_HDCP_Capability HdcpCapability;
+  typedef enum {
+    kUsageDurationsInvalid = 0,
+    kUsageDurationPlaybackNotBegun = 1,
+    kUsageDurationsValid = 2,
+  } UsageDurationStatus;
+
+  struct SupportedCertificateTypes {
+    bool rsa_2048_bit;
+    bool rsa_3072_bit;
+    bool rsa_cast;
+  };
+
+  // Creates an instance of CryptoSession with the given |crypto_metrics|.
+  // |crypto_metrics| is owned by the caller, must NOT be null, and must
+  // exist as long as the new CryptoSession exists.
+  explicit CryptoSession(metrics::CryptoMetrics* crypto_metrics);
+  virtual ~CryptoSession();
+
+  virtual bool GetClientToken(std::string* client_token);
+  virtual bool GetProvisioningToken(std::string* client_token);
+  virtual CdmClientTokenType GetPreProvisionTokenType() {
+    return pre_provision_token_type_;
+  }
+  virtual CdmSecurityLevel GetSecurityLevel();
+  virtual bool GetInternalDeviceUniqueId(std::string* device_id);
+  virtual bool GetExternalDeviceUniqueId(std::string* device_id);
+  virtual bool GetApiVersion(uint32_t* version);
+  virtual bool GetSystemId(uint32_t* system_id);
+  virtual bool GetProvisioningId(std::string* provisioning_id);
+  virtual uint8_t GetSecurityPatchLevel();
+
+  virtual CdmResponseType Open() { return Open(kLevelDefault); }
+  virtual CdmResponseType Open(SecurityLevel requested_security_level);
+  virtual void Close();
+
+  virtual bool IsOpen() { return open_; }
+  virtual CryptoSessionId oec_session_id() { return oec_session_id_; }
+
+  // Key request/response
+  virtual bool GenerateRequestId(std::string* req_id_str);
+  virtual bool PrepareRequest(const std::string& key_deriv_message,
+                              bool is_provisioning, std::string* signature);
+  virtual bool PrepareRenewalRequest(const std::string& message,
+                                     std::string* signature);
+  virtual CdmResponseType LoadKeys(const std::string& message,
+                                   const std::string& signature,
+                                   const std::string& mac_key_iv,
+                                   const std::string& mac_key,
+                                   const std::vector<CryptoKey>& key_array,
+                                   const std::string& provider_session_token,
+                                   const std::string& srm_requirement);
+  virtual bool LoadCertificatePrivateKey(std::string& wrapped_key);
+  virtual bool RefreshKeys(const std::string& message,
+                           const std::string& signature, int num_keys,
+                           const CryptoKey* key_array);
+  virtual bool GenerateNonce(uint32_t* nonce);
+  virtual bool GenerateDerivedKeys(const std::string& message);
+  virtual bool GenerateDerivedKeys(const std::string& message,
+                                   const std::string& session_key);
+  virtual bool RewrapCertificate(const std::string& signed_message,
+                                 const std::string& signature,
+                                 const std::string& nonce,
+                                 const std::string& private_key,
+                                 const std::string& iv,
+                                 const std::string& wrapping_key,
+                                 std::string* wrapped_private_key);
+
+  // Media data path
+  virtual CdmResponseType Decrypt(const CdmDecryptionParameters& params);
+
+  // Usage related methods
+  virtual bool UsageInformationSupport(bool* has_support);
+  virtual CdmResponseType UpdateUsageInformation();  // only for OEMCrypto v9-12
+  virtual CdmResponseType DeactivateUsageInformation(
+      const std::string& provider_session_token);
+  virtual CdmResponseType GenerateUsageReport(
+      const std::string& provider_session_token, std::string* usage_report,
+      UsageDurationStatus* usage_duration_status,
+      int64_t* seconds_since_started, int64_t* seconds_since_last_played);
+  virtual CdmResponseType ReleaseUsageInformation(
+      const std::string& message, const std::string& signature,
+      const std::string& provider_session_token);
+  // Delete a usage information for a single token.  This does not require
+  // a signed message from the server.
+  virtual CdmResponseType DeleteUsageInformation(
+      const std::string& provider_session_token);
+  // Delete usage information for a list of tokens.  This does not require
+  // a signed message from the server.
+  virtual CdmResponseType DeleteMultipleUsageInformation(
+      const std::vector<std::string>& provider_session_tokens);
+  virtual CdmResponseType DeleteAllUsageReports();
+  virtual bool IsAntiRollbackHwPresent();
+
+  virtual bool GetHdcpCapabilities(HdcpCapability* current,
+                                   HdcpCapability* max);
+  virtual bool GetSupportedCertificateTypes(SupportedCertificateTypes* support);
+  virtual bool GetRandom(size_t data_length, uint8_t* random_data);
+  virtual bool GetNumberOfOpenSessions(size_t* count);
+  virtual bool GetMaxNumberOfSessions(size_t* max);
+
+  virtual bool GetSrmVersion(uint16_t* srm_version);
+  virtual bool IsSrmUpdateSupported();
+  virtual bool LoadSrm(const std::string& srm);
+
+  virtual CdmResponseType GenericEncrypt(const std::string& in_buffer,
+                                         const std::string& key_id,
+                                         const std::string& iv,
+                                         CdmEncryptionAlgorithm algorithm,
+                                         std::string* out_buffer);
+  virtual CdmResponseType GenericDecrypt(const std::string& in_buffer,
+                                         const std::string& key_id,
+                                         const std::string& iv,
+                                         CdmEncryptionAlgorithm algorithm,
+                                         std::string* out_buffer);
+  virtual CdmResponseType GenericSign(const std::string& message,
+                                      const std::string& key_id,
+                                      CdmSigningAlgorithm algorithm,
+                                      std::string* signature);
+  virtual CdmResponseType GenericVerify(const std::string& message,
+                                        const std::string& key_id,
+                                        CdmSigningAlgorithm algorithm,
+                                        const std::string& signature);
+
+  // Usage table header and usage entry related methods
+  virtual UsageTableHeader* GetUsageTableHeader() {
+    return usage_table_header_;
+  }
+  virtual CdmResponseType GetUsageSupportType(CdmUsageSupportType* type);
+  virtual CdmResponseType CreateUsageTableHeader(
+      CdmUsageTableHeader* usage_table_header);
+  virtual CdmResponseType LoadUsageTableHeader(
+      const CdmUsageTableHeader& usage_table_header);
+  virtual CdmResponseType CreateUsageEntry(uint32_t* entry_number);
+  virtual CdmResponseType LoadUsageEntry(uint32_t entry_number,
+                                         const CdmUsageEntry& usage_entry);
+  virtual CdmResponseType UpdateUsageEntry(
+      CdmUsageTableHeader* usage_table_header,
+      CdmUsageEntry* usage_entry);
+  virtual CdmResponseType ShrinkUsageTableHeader(
+      uint32_t new_entry_count, CdmUsageTableHeader* usage_table_header);
+  virtual CdmResponseType MoveUsageEntry(uint32_t new_entry_number);
+  virtual bool CreateOldUsageEntry(
+      uint64_t time_since_license_received,
+      uint64_t time_since_first_decrypt,
+      uint64_t time_since_last_decrypt,
+      UsageDurationStatus status,
+      const std::string& server_mac_key,
+      const std::string& client_mac_key,
+      const std::string& provider_session_token);
+  virtual CdmResponseType CopyOldUsageEntry(
+      const std::string& provider_session_token);
+  virtual metrics::CryptoMetrics* GetCryptoMetrics() { return metrics_; }
+
+  virtual CdmResponseType AddSubSession(const std::string& sub_session_key_id,
+                                        const std::string& group_master_key_id);
+  // TODO(jfore): exists is set based on whether a sub session exists. For now,
+  // that is not assumed to be an error.
+  virtual bool GenerateSubSessionNonce(const std::string& sub_session_key_id,
+                                       bool* exists, uint32_t* nonce);
+
+ private:
+  bool GetProvisioningMethod(CdmClientTokenType* token_type);
+  void Init();
+  void Terminate();
+  bool GetTokenFromKeybox(std::string* token);
+  bool GetTokenFromOemCert(std::string* token);
+  bool GenerateSignature(const std::string& message, std::string* signature);
+  bool GenerateRsaSignature(const std::string& message, std::string* signature);
+
+  bool SetDestinationBufferType();
+
+  bool RewrapDeviceRSAKey(
+      const std::string& message, const std::string& signature,
+      const std::string& nonce, const std::string& enc_rsa_key,
+      const std::string& rsa_key_iv, std::string* wrapped_rsa_key);
+
+  bool RewrapDeviceRSAKey30(
+      const std::string& message, const std::string& nonce,
+      const std::string& private_key, const std::string& iv,
+      const std::string& wrapping_key, std::string* wrapped_private_key);
+
+  CdmResponseType SelectKey(const std::string& key_id);
+
+  static const OEMCrypto_Algorithm kInvalidAlgorithm =
+      static_cast<OEMCrypto_Algorithm>(-1);
+
+  OEMCrypto_Algorithm GenericSigningAlgorithm(CdmSigningAlgorithm algorithm);
+  OEMCrypto_Algorithm GenericEncryptionAlgorithm(
+      CdmEncryptionAlgorithm algorithm);
+  size_t GenericEncryptionBlockSize(CdmEncryptionAlgorithm algorithm);
+
+  // These methods are used when a subsample exceeds the maximum buffer size
+  // that the device can handle.
+  OEMCryptoResult CopyBufferInChunks(
+      const CdmDecryptionParameters& params,
+      OEMCrypto_DestBufferDesc buffer_descriptor);
+  OEMCryptoResult DecryptInChunks(
+      const CdmDecryptionParameters& params,
+      const OEMCrypto_DestBufferDesc& full_buffer_descriptor,
+      const OEMCrypto_CENCEncryptPatternDesc& pattern_descriptor,
+      size_t max_chunk_size);
+  static void IncrementIV(uint64_t increase_by, std::vector<uint8_t>* iv_out);
+
+  static const size_t kAes128BlockSize = 16;  // Block size for AES_CBC_128
+  static const size_t kSignatureSize = 32;    // size for HMAC-SHA256 signature
+  static Lock crypto_lock_;
+  static bool initialized_;
+  static int session_count_;
+
+  metrics::CryptoMetrics* metrics_;
+  metrics::TimerMetric life_span_;
+
+  bool open_;
+  CdmClientTokenType pre_provision_token_type_;
+  std::string oem_token_;  // Cached OEMCrypto Public Key
+  bool update_usage_table_after_close_session_;
+  CryptoSessionId oec_session_id_;
+  SubLicenseSessionMap sub_license_oec_sessions_;
+  // Used for sub license sessions.
+  std::string wrapped_key_;
+  scoped_ptr<KeySession> key_session_;
+
+  OEMCryptoBufferType destination_buffer_type_;
+  bool is_destination_buffer_type_valid_;
+  SecurityLevel requested_security_level_;
+
+  KeyId cached_key_id_;
+
+  bool is_usage_support_type_valid_;
+  CdmUsageSupportType usage_support_type_;
+  UsageTableHeader* usage_table_header_;
+  static UsageTableHeader* usage_table_header_l1_;
+  static UsageTableHeader* usage_table_header_l3_;
+
+  uint64_t request_id_base_;
+  static uint64_t request_id_index_;
+
+  CdmCipherMode cipher_mode_;
+
+  CORE_DISALLOW_COPY_AND_ASSIGN(CryptoSession);
+};
+
+}  // namespace wvcdm
+
+#endif  // WVCDM_CORE_CRYPTO_SESSSION_H_
diff --git a/widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/core/include/device_files.h b/widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/core/include/device_files.h
new file mode 100644
index 0000000..13aad01
--- /dev/null
+++ b/widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/core/include/device_files.h
@@ -0,0 +1,249 @@
+// Copyright 2013 Google Inc. All Rights Reserved.
+//
+#ifndef WVCDM_CORE_DEVICE_FILES_H_
+#define WVCDM_CORE_DEVICE_FILES_H_
+
+#include <unistd.h>
+
+#include <set>
+#include <string>
+#include <vector>
+
+#include "device_files.pb.h"
+#include "scoped_ptr.h"
+#include "wv_cdm_types.h"
+
+#if defined(UNIT_TEST)
+#include <gtest/gtest_prod.h>
+#endif
+
+namespace wvcdm {
+
+class FileSystem;
+
+class DeviceFiles {
+ public:
+  typedef enum {
+    kLicenseStateActive,
+    kLicenseStateReleasing,
+    kLicenseStateUnknown,
+  } LicenseState;
+
+  struct CdmUsageData {
+    std::string provider_session_token;
+    CdmKeyMessage license_request;
+    CdmKeyResponse license;
+    std::string key_set_id;
+    CdmUsageEntry usage_entry;
+    uint32_t usage_entry_number;
+  };
+
+  DeviceFiles(FileSystem*);
+  virtual ~DeviceFiles();
+
+  virtual bool Init(CdmSecurityLevel security_level);
+  virtual bool Reset(CdmSecurityLevel security_level) {
+    return Init(security_level);
+  }
+
+  virtual bool StoreCertificate(const std::string& certificate,
+                                const std::string& wrapped_private_key);
+  virtual bool RetrieveCertificate(std::string* certificate,
+                                   std::string* wrapped_private_key,
+                                   std::string* serial_number,
+                                   uint32_t* system_id);
+  virtual bool HasCertificate();
+  virtual bool RemoveCertificate();
+
+  virtual bool StoreLicense(const std::string& key_set_id,
+                            const LicenseState state,
+                            const CdmInitData& pssh_data,
+                            const CdmKeyMessage& key_request,
+                            const CdmKeyResponse& key_response,
+                            const CdmKeyMessage& key_renewal_request,
+                            const CdmKeyResponse& key_renewal_response,
+                            const std::string& release_server_url,
+                            int64_t playback_start_time,
+                            int64_t last_playback_time,
+                            int64_t grace_period_end_time,
+                            const CdmAppParameterMap& app_parameters,
+                            const CdmUsageEntry& usage_entry,
+                            uint32_t usage_entry_number);
+  virtual bool RetrieveLicense(
+      const std::string& key_set_id, LicenseState* state,
+      CdmInitData* pssh_data, CdmKeyMessage* key_request,
+      CdmKeyResponse* key_response, CdmKeyMessage* key_renewal_request,
+      CdmKeyResponse* key_renewal_response, std::string* release_server_url,
+      int64_t* playback_start_time, int64_t* last_playback_time,
+      int64_t* grace_period_end_time, CdmAppParameterMap* app_parameters,
+      CdmUsageEntry* usage_entry, uint32_t* usage_entry_number);
+  virtual bool DeleteLicense(const std::string& key_set_id);
+  virtual bool ListLicenses(std::vector<std::string>* key_set_ids);
+  virtual bool DeleteAllFiles();
+  virtual bool DeleteAllLicenses();
+  virtual bool LicenseExists(const std::string& key_set_id);
+  virtual bool ReserveLicenseId(const std::string& key_set_id);
+  virtual bool UnreserveLicenseId(const std::string& key_set_id);
+
+  // Use this method to create a |usage_info_file_name| from an |app_id|
+  static std::string GetUsageInfoFileName(const std::string& app_id);
+
+  // The UsageInfo methods have been revised to use |usage_info_file_name|
+  // rather than |app_id| as a parameter. Use the helper method above to
+  // translate.
+  // OEMCrypto API 13 introduced big usage tables which required
+  // migration from usage tables stored by the TEE to usage table
+  // header+usage entries stored in unsecured persistent storage. The upgrade
+  // required creation of reverse lookup tables (CdmUsageEntryInfo).
+  // |app_id| however was hashed and unextractable, and necessitated the
+  // switch to |usage_info_file_name|
+  virtual bool StoreUsageInfo(const std::string& provider_session_token,
+                              const CdmKeyMessage& key_request,
+                              const CdmKeyResponse& key_response,
+                              const std::string& usage_info_file_name,
+                              const std::string& key_set_id,
+                              const CdmUsageEntry& usage_entry,
+                              uint32_t usage_entry_number);
+
+  // Extract KSIDs from usage information on the file system.
+  virtual bool ListUsageRecords(const std::string& app_id,
+                                std::vector<std::string>* ksids);
+
+  // Get the provider session token for the given key_set_id.
+  virtual bool GetProviderSessionToken(const std::string& app_id,
+                                       const std::string& key_set_id,
+                                       std::string* provider_session_token);
+
+  virtual bool DeleteUsageInfo(const std::string& usage_info_file_name,
+                               const std::string& provider_session_token);
+
+  // Delete usage information from the file system.  Puts a list of all the
+  // psts that were deleted from the file into |provider_session_tokens|.
+  virtual bool DeleteAllUsageInfoForApp(
+      const std::string& usage_info_file_name,
+      std::vector<std::string>* provider_session_tokens);
+
+  // Retrieve one usage info from the file.  Subsequent calls will retrieve
+  // subsequent entries in the table for this app_id.
+  virtual bool RetrieveUsageInfo(
+      const std::string& usage_info_file_name,
+      std::vector<std::pair<CdmKeyMessage, CdmKeyResponse> >* usage_info);
+
+  // Retrieve the usage info entry specified by |provider_session_token|.
+  // Returns false if the entry could not be found.
+  virtual bool RetrieveUsageInfo(const std::string& usage_info_file_name,
+                                 const std::string& provider_session_token,
+                                 CdmKeyMessage* license_request,
+                                 CdmKeyResponse* license_response,
+                                 CdmUsageEntry* usage_entry,
+                                 uint32_t* usage_entry_number);
+  // Retrieve the usage info entry specified by |key_set_id|.
+  // Returns false if the entry could not be found.
+  virtual bool RetrieveUsageInfoByKeySetId(
+      const std::string& usage_info_file_name,
+      const std::string& key_set_id,
+      std::string* provider_session_token,
+      CdmKeyMessage* license_request,
+      CdmKeyResponse* license_response,
+      CdmUsageEntry* usage_entry,
+      uint32_t* usage_entry_number);
+
+  // These APIs support upgrading from usage tables to usage tabler header +
+  // entries introduced in OEMCrypto V13.
+
+  virtual bool ListUsageInfoFiles(std::vector<std::string>* usage_file_names);
+  virtual bool RetrieveUsageInfo(const std::string& usage_info_file_name,
+                                 std::vector<CdmUsageData>* usage_data);
+  virtual bool RetrieveUsageInfo(const std::string& usage_info_file_name,
+                                 const std::string& provider_session_token,
+                                 CdmUsageData* usage_data);
+  // This method overwrites rather than appends data to the usage file
+  virtual bool StoreUsageInfo(const std::string& usage_info_file_name,
+                              const std::vector<CdmUsageData>& usage_data);
+  virtual bool UpdateUsageInfo(const std::string& usage_info_file_name,
+                               const std::string& provider_session_token,
+                               const CdmUsageData& usage_data);
+
+  virtual bool StoreHlsAttributes(const std::string& key_set_id,
+                                  const CdmHlsMethod method,
+                                  const std::vector<uint8_t>& media_segment_iv);
+  virtual bool RetrieveHlsAttributes(const std::string& key_set_id,
+                                     CdmHlsMethod* method,
+                                     std::vector<uint8_t>* media_segment_iv);
+  virtual bool DeleteHlsAttributes(const std::string& key_set_id);
+
+  virtual bool StoreUsageTableInfo(
+      const CdmUsageTableHeader& usage_table_header,
+      const std::vector<CdmUsageEntryInfo>& usage_entry_info);
+
+  virtual bool RetrieveUsageTableInfo(
+      CdmUsageTableHeader* usage_table_header,
+      std::vector<CdmUsageEntryInfo>* usage_entry_info);
+
+ private:
+  // Extract serial number and system ID from DRM Device certificate
+  bool ExtractDeviceInfo(const std::string& device_certificate,
+                         std::string* serial_number,
+                         uint32_t* system_id);
+
+  // Helpers that wrap the File interface and automatically handle hashing, as
+  // well as adding the device files base path to to the file name.
+  bool StoreFileWithHash(const std::string& name,
+                         const std::string& serialized_file);
+  bool StoreFileRaw(const std::string& name,
+                    const std::string& serialized_file);
+  bool RetrieveHashedFile(const std::string& name,
+                          video_widevine_client::sdk::File* file);
+  bool FileExists(const std::string& name);
+  bool ListFiles(std::vector<std::string>* names);
+  bool RemoveFile(const std::string& name);
+  ssize_t GetFileSize(const std::string& name);
+
+  static std::string GetCertificateFileName();
+  static std::string GetHlsAttributesFileNameExtension();
+  static std::string GetLicenseFileNameExtension();
+  static std::string GetUsageTableFileName();
+  static std::string GetFileNameSafeHash(const std::string& input);
+
+#if defined(UNIT_TEST)
+  FRIEND_TEST(DeviceFilesSecurityLevelTest, SecurityLevel);
+  FRIEND_TEST(DeviceCertificateStoreTest, StoreCertificate);
+  FRIEND_TEST(DeviceCertificateTest, DISABLED_ReadCertificate);
+  FRIEND_TEST(DeviceCertificateTest, HasCertificate);
+  FRIEND_TEST(DeviceFilesStoreTest, StoreLicense);
+  FRIEND_TEST(DeviceFilesHlsAttributesTest, Delete);
+  FRIEND_TEST(DeviceFilesHlsAttributesTest, Read);
+  FRIEND_TEST(DeviceFilesHlsAttributesTest, Store);
+  FRIEND_TEST(DeviceFilesTest, DeleteLicense);
+  FRIEND_TEST(DeviceFilesTest, ReserveLicenseIdsDoesNotUseFileSystem);
+  FRIEND_TEST(DeviceFilesTest, RetrieveLicenses);
+  FRIEND_TEST(DeviceFilesTest, AppParametersBackwardCompatibility);
+  FRIEND_TEST(DeviceFilesTest, StoreLicenses);
+  FRIEND_TEST(DeviceFilesTest, UpdateLicenseState);
+  FRIEND_TEST(DeviceFilesUsageInfoTest, Delete);
+  FRIEND_TEST(DeviceFilesUsageInfoTest, DeleteAll);
+  FRIEND_TEST(DeviceFilesUsageInfoTest, Read);
+  FRIEND_TEST(DeviceFilesUsageInfoTest, Store);
+  FRIEND_TEST(DeviceFilesUsageTableTest, Read);
+  FRIEND_TEST(DeviceFilesUsageTableTest, Store);
+  FRIEND_TEST(WvCdmRequestLicenseTest, UnprovisionTest);
+  FRIEND_TEST(WvCdmRequestLicenseTest, ForceL3Test);
+  FRIEND_TEST(WvCdmRequestLicenseTest, UsageInfoRetryTest);
+  FRIEND_TEST(WvCdmRequestLicenseTest, UsageReleaseAllTest);
+  FRIEND_TEST(WvCdmUsageInfoTest, UsageInfo);
+  FRIEND_TEST(WvCdmUsageTest, WithClientId);
+  FRIEND_TEST(WvCdmExtendedDurationTest, UsageOverflowTest);
+#endif
+
+  static std::set<std::string> reserved_license_ids_;
+
+  FileSystem* file_system_;
+  CdmSecurityLevel security_level_;
+  bool initialized_;
+
+  CORE_DISALLOW_COPY_AND_ASSIGN(DeviceFiles);
+};
+
+}  // namespace wvcdm
+
+#endif  // WVCDM_CORE_DEVICE_FILES_H_
diff --git a/widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/core/include/file_store.h b/widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/core/include/file_store.h
new file mode 100644
index 0000000..fd27e78
--- /dev/null
+++ b/widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/core/include/file_store.h
@@ -0,0 +1,80 @@
+// Copyright 2013 Google Inc. All Rights Reserved.
+//
+// File - Platform independent interface for a File class
+//
+#ifndef WVCDM_CORE_FILE_STORE_H_
+#define WVCDM_CORE_FILE_STORE_H_
+
+#include <unistd.h>
+#include <string>
+#include <vector>
+
+#include "wv_cdm_types.h"
+
+namespace wvcdm {
+
+// File class. The implementation is platform dependent.
+class File {
+ public:
+  virtual ssize_t Read(char* buffer, size_t bytes);
+  virtual ssize_t Write(const char* buffer, size_t bytes);
+  virtual void Close();
+
+ protected:
+  class Impl;
+
+  File(Impl*);
+  virtual ~File();
+
+ private:
+  Impl* impl_;
+
+  friend class FileSystem;
+  CORE_DISALLOW_COPY_AND_ASSIGN(File);
+};
+
+class FileSystem {
+ public:
+  class Impl;
+
+  // defines as bit flag
+  enum OpenFlags {
+    kNoFlags = 0,
+    kCreate = 1,
+    kReadOnly = 2,  // defaults to read and write access
+    kTruncate = 4
+  };
+
+  FileSystem();
+  FileSystem(const std::string& origin, void* extra_data);
+  virtual ~FileSystem();
+
+  virtual File* Open(const std::string& file_path, int flags);
+
+  virtual bool Exists(const std::string& file_path);
+  virtual bool Remove(const std::string& file_path);
+  virtual ssize_t FileSize(const std::string& file_path);
+
+  // Return the filenames stored at dir_path.
+  // dir_path will be stripped from the returned names.
+  virtual bool List(const std::string& dir_path,
+                    std::vector<std::string>* names);
+
+  const std::string& origin() const { return origin_; }
+  void SetOrigin(const std::string& origin);
+
+  const std::string& identifier() const { return identifier_; }
+  void SetIdentifier(const std::string& identifier);
+  bool IsGlobal() const { return identifier_.empty(); }
+
+ private:
+  Impl* impl_;
+  std::string origin_;
+  std::string identifier_;
+
+  CORE_DISALLOW_COPY_AND_ASSIGN(FileSystem);
+};
+
+}  // namespace wvcdm
+
+#endif  // WVCDM_CORE_FILE_STORE_H_
diff --git a/widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/core/include/initialization_data.h b/widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/core/include/initialization_data.h
new file mode 100644
index 0000000..53e8402
--- /dev/null
+++ b/widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/core/include/initialization_data.h
@@ -0,0 +1,82 @@
+// Copyright 2014 Google Inc. All Rights Reserved.
+
+#ifndef CORE_INCLUDE_INITIALIZATION_DATA_H_
+#define CORE_INCLUDE_INITIALIZATION_DATA_H_
+
+#include <string>
+
+#include "license_protocol.pb.h"
+#include "wv_cdm_types.h"
+
+namespace wvcdm {
+
+class WvCdmEngineTest;
+
+class InitializationData {
+ public:
+  InitializationData(const std::string& type = std::string(),
+                     const CdmInitData& data = CdmInitData());
+
+  bool is_supported() const { return is_cenc_ || is_webm_ || is_hls_; }
+  bool is_cenc() const { return is_cenc_; }
+  bool is_hls() const { return is_hls_; }
+  bool is_webm() const { return is_webm_; }
+
+  bool IsEmpty() const { return data_.empty(); }
+
+  const std::string& type() const { return type_; }
+  const CdmInitData& data() const { return data_; }
+  std::vector<uint8_t> hls_iv() const { return hls_iv_; }
+  CdmHlsMethod hls_method() const { return hls_method_; }
+  std::vector<video_widevine::SubLicense> ExtractEmbeddedKeys() const;
+  const std::string ExtractGroupMasterKeyId() const;
+
+ private:
+  // Parse a blob of multiple concatenated PSSH atoms to extract the first
+  // Widevine PSSH.
+  bool ExtractWidevinePssh(const CdmInitData& init_data, CdmInitData* output);
+
+  bool ExtractHlsAttributes(const std::string& attribute_list,
+                            CdmHlsMethod* method, std::vector<uint8_t>* iv,
+                            std::string* uri);
+  static bool ConstructWidevineInitData(CdmHlsMethod method,
+                                        const std::string& uri,
+                                        CdmInitData* output);
+  static bool ExtractQuotedAttribute(const std::string& attribute_list,
+                                     const std::string& key,
+                                     std::string* value);
+  static bool ExtractHexAttribute(const std::string& attribute_list,
+                                  const std::string& key,
+                                  std::vector<uint8_t>* value);
+  static bool ExtractAttribute(const std::string& attribute_list,
+                               const std::string& key, std::string* value);
+
+  static std::vector<std::string> ExtractKeyFormatVersions(
+      const std::string& key_format_versions);
+
+// For testing only:
+#if defined(UNIT_TEST)
+  FRIEND_TEST(HlsAttributeExtractionTest, ExtractAttribute);
+  FRIEND_TEST(HlsConstructionTest, InitData);
+  FRIEND_TEST(HlsInitDataConstructionTest, InvalidUriDataFormat);
+  FRIEND_TEST(HlsInitDataConstructionTest, InvalidUriBase64Encode);
+  FRIEND_TEST(HlsHexAttributeExtractionTest, ExtractHexAttribute);
+  FRIEND_TEST(HlsKeyFormatVersionsExtractionTest, ExtractKeyFormatVersions);
+  FRIEND_TEST(HlsParseTest, Parse);
+  FRIEND_TEST(HlsQuotedAttributeExtractionTest, ExtractQuotedAttribute);
+  FRIEND_TEST(HlsTest, ExtractHlsAttributes);
+#endif
+
+  std::string type_;
+  CdmInitData data_;
+  bool is_cenc_;
+  bool is_hls_;
+  bool is_webm_;
+
+  std::vector<uint8_t> hls_iv_;
+  CdmHlsMethod hls_method_;
+};
+
+}  // namespace wvcdm
+
+#endif  // CORE_INCLUDE_INITIALIZATION_DATA_H_
diff --git a/widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/core/include/license.h b/widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/core/include/license.h
new file mode 100644
index 0000000..805c233
--- /dev/null
+++ b/widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/core/include/license.h
@@ -0,0 +1,136 @@
+// Copyright 2012 Google Inc. All Rights Reserved.
+
+#ifndef WVCDM_CORE_LICENSE_H_
+#define WVCDM_CORE_LICENSE_H_
+
+#include <set>
+
+#include "initialization_data.h"
+#include "license_protocol.pb.h"
+#include "scoped_ptr.h"
+#include "service_certificate.h"
+#include "wv_cdm_types.h"
+
+namespace video_widevine {
+class SignedMessage;
+class LicenseRequest;
+}  // namespace video_widevine
+
+namespace wvcdm {
+
+class Clock;
+class CryptoSession;
+class PolicyEngine;
+class CdmSession;
+class CryptoKey;
+
+class CdmLicense {
+ public:
+  CdmLicense(const CdmSessionId& session_id);
+  virtual ~CdmLicense();
+
+  virtual bool Init(
+      const std::string& client_token, CdmClientTokenType client_token_type,
+      const std::string& device_id, bool use_privacy_mode,
+      const std::string& signed_service_certificate, CryptoSession* session,
+      PolicyEngine* policy_engine);
+
+  virtual CdmResponseType PrepareKeyRequest(
+      const InitializationData& init_data, CdmLicenseType license_type,
+      const CdmAppParameterMap& app_parameters, CdmKeyMessage* signed_request,
+      std::string* server_url);
+  virtual CdmResponseType PrepareKeyUpdateRequest(
+      bool is_renewal, const CdmAppParameterMap& app_parameters,
+      CdmSession* cdm_session, CdmKeyMessage* signed_request,
+      std::string* server_url);
+  virtual CdmResponseType HandleKeyResponse(
+      const CdmKeyResponse& license_response);
+  virtual CdmResponseType HandleKeyUpdateResponse(
+      bool is_renewal, const CdmKeyResponse& license_response);
+  virtual CdmResponseType HandleSubLicense(const InitializationData& init_data);
+
+  virtual bool RestoreOfflineLicense(
+      const CdmKeyMessage& license_request,
+      const CdmKeyResponse& license_response,
+      const CdmKeyResponse& license_renewal_response,
+      int64_t playback_start_time, int64_t last_playback_time,
+      int64_t grace_period_end_time, CdmSession* cdm_session);
+  virtual bool RestoreLicenseForRelease(const CdmKeyMessage& license_request,
+                                        const CdmKeyResponse& license_response);
+  virtual bool HasInitData() { return stored_init_data_.get(); }
+  virtual bool IsKeyLoaded(const KeyId& key_id);
+
+  virtual std::string provider_session_token() {
+    return provider_session_token_;
+  }
+
+  virtual bool is_offline() {
+    return is_offline_;
+  }
+
+  static bool ExtractProviderSessionToken(
+      const CdmKeyResponse& license_response,
+      std::string* provider_session_token);
+
+ private:
+
+  CdmResponseType HandleKeyErrorResponse(
+      const video_widevine::SignedMessage& signed_message);
+
+  bool GetClientTokenType(
+      video_widevine::ClientIdentification::TokenType* token_type);
+
+  CdmResponseType PrepareClientId(
+      const CdmAppParameterMap& app_parameters,
+      video_widevine::LicenseRequest* license_request);
+
+  CdmResponseType PrepareContentId(
+      const InitializationData& init_data, CdmLicenseType license_type,
+      const std::string& request_id,
+      video_widevine::LicenseRequest* license_request);
+
+  template <typename T>
+  bool SetTypeAndId(CdmLicenseType license_type,
+                    const std::string& request_id, T* content_id);
+
+  CryptoSession* crypto_session_;
+  PolicyEngine* policy_engine_;
+  std::string server_url_;
+  std::string client_token_;
+  CdmClientTokenType client_token_type_;
+  std::string device_id_;
+  const CdmSessionId session_id_;
+  scoped_ptr<InitializationData> stored_init_data_;
+  bool initialized_;
+  std::set<KeyId> loaded_keys_;
+  std::string provider_session_token_;
+  bool renew_with_client_id_;
+  bool is_offline_;
+
+  // Associated with ClientIdentification encryption
+  bool use_privacy_mode_;
+  ServiceCertificate service_certificate_;
+
+  // Used for certificate based licensing
+  CdmKeyMessage key_request_;
+
+  scoped_ptr<Clock> clock_;
+
+  // For testing
+  // CdmLicense takes ownership of the clock.
+  CdmLicense(const CdmSessionId& session_id, Clock* clock);
+
+  // For sublicense key embedding. This key array will be initilized with any
+  // sub session keys we may have received in a license response. These keys
+  // may be used to support key rotation.
+  std::vector<CryptoKey> sub_session_key_array_;
+#if defined(UNIT_TEST)
+  friend class CdmLicenseTest;
+#endif
+
+  CORE_DISALLOW_COPY_AND_ASSIGN(CdmLicense);
+};
+
+}  // namespace wvcdm
+
+#endif  // WVCDM_CORE_LICENSE_H_
diff --git a/widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/core/include/license_key_status.h b/widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/core/include/license_key_status.h
new file mode 100644
index 0000000..e562873
--- /dev/null
+++ b/widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/core/include/license_key_status.h
@@ -0,0 +1,143 @@
+// Copyright 2016 Google Inc. All Rights Reserved.
+
+#ifndef WVCDM_CORE_LICENSE_KEY_STATUS_H_
+#define WVCDM_CORE_LICENSE_KEY_STATUS_H_
+
+#include <map>
+
+#include "crypto_session.h"
+#include "license_protocol.pb.h"
+#include "wv_cdm_types.h"
+
+namespace wvcdm {
+
+class LicenseKeyStatus;
+
+// Holds all content and operator session keys for a session.
+class LicenseKeys {
+ public:
+  LicenseKeys() {}
+  virtual ~LicenseKeys() { Clear(); }
+
+  virtual bool Empty() { return keys_.empty(); }
+
+  // Returns true if the key is a content key (not an operator session key)
+  virtual bool IsContentKey(const KeyId& key_id);
+
+  // Returns true if the key is currently usable for content decryption.
+  virtual bool CanDecryptContent(const KeyId& key_id);
+
+  // Returns the allowed usages for a key.
+  virtual bool GetAllowedUsage(const KeyId& key_id,
+                               CdmKeyAllowedUsage* allowed_usage);
+
+  // Applies a new status to each content key.
+  // Returns true if any statuses changed, and sets new_usable_keys to
+  // true if the status changes resulted in keys becoming usable.
+  virtual bool ApplyStatusChange(CdmKeyStatus new_status,
+                                 bool* new_usable_keys);
+
+  // Returns current CdmKeyStatus for the given key.
+  // Returns kKeyStatusKeyUnknown if key_id not found.
+  virtual CdmKeyStatus GetKeyStatus(const KeyId& key_id);
+
+  // Populates a CdmKeyStatusMap with the current content keys.
+  virtual void ExtractKeyStatuses(CdmKeyStatusMap* content_keys);
+
+  // Determines whether the specified key can be used under the current
+  // resolution and/or hdcp constraints.  If no constraints have been applied
+  // to the key, returns true.
+  virtual bool MeetsConstraints(const KeyId& key_id);
+
+  // Applies a resolution and/or hdcp change to each key, updating their
+  // useability under their constraints.
+  virtual void ApplyConstraints(uint32_t new_resolution,
+                                CryptoSession::HdcpCapability new_hdcp_level);
+
+  // Extracts the keys from a license and makes them available for
+  // querying usage and constraint settings.
+  virtual void SetFromLicense(
+      const video_widevine::License& license);
+
+ private:
+  typedef ::video_widevine::License::KeyContainer KeyContainer;
+  typedef std::map<wvcdm::KeyId, LicenseKeyStatus*>::const_iterator
+      LicenseKeyStatusIterator;
+
+  void Clear();
+
+  bool is_initialized_;
+  std::map<KeyId, LicenseKeyStatus*> keys_;
+
+  CORE_DISALLOW_COPY_AND_ASSIGN(LicenseKeys);
+};
+
+// Holds the current license status of a key.
+class LicenseKeyStatus {
+  friend class LicenseKeys;
+
+ public:
+  // Returns true if the key is a content key (not an operator session key)
+  virtual bool IsContentKey() { return is_content_key_; }
+
+  // Returns true if the key is currently usable for content decryption
+  virtual bool CanDecryptContent();
+
+  // Returns the usages allowed for this key.
+  virtual bool GetAllowedUsage(CdmKeyAllowedUsage* allowed_usage);
+
+  // Returns the current status of the key.
+  virtual CdmKeyStatus GetKeyStatus() const { return key_status_; }
+
+  // Applies a new status to this key.
+  // Returns true if the status changed, and sets new_usable_keys to
+  // true if the status changes resulted in the key becoming usable.
+  virtual bool ApplyStatusChange(CdmKeyStatus new_status,
+                                 bool* new_usable_keys);
+
+  // Returns the current constraint status of this key.  The result
+  // may change due to calls to ApplyConstraints().
+  // Note: this will return true until the first call to ApplyConstraints().
+  virtual bool MeetsConstraints() const { return meets_constraints_; }
+
+  // Applies the given changes in resolution or HDCP settings.
+  virtual void ApplyConstraints(
+      uint32_t new_resolution, CryptoSession::HdcpCapability new_hdcp_level);
+
+ protected:
+  typedef ::video_widevine::License::KeyContainer KeyContainer;
+  typedef KeyContainer::OperatorSessionKeyPermissions
+      OperatorSessionKeyPermissions;
+  typedef KeyContainer::OutputProtection OutputProtection;
+  typedef KeyContainer::VideoResolutionConstraint VideoResolutionConstraint;
+  typedef ::google::protobuf::RepeatedPtrField<VideoResolutionConstraint>
+      ConstraintList;
+
+  LicenseKeyStatus(const KeyContainer& key);
+
+  virtual ~LicenseKeyStatus() {}
+
+ private:
+
+  void ParseContentKey(const KeyContainer& key);
+  void ParseOperatorSessionKey(const KeyContainer& key);
+
+  bool HasConstraints() {
+    return is_content_key_ && constraints_.size() != 0;
+  }
+
+  void SetConstraints(const ConstraintList& constraints);
+
+  bool is_content_key_;
+  CdmKeyStatus key_status_;
+  bool meets_constraints_;
+  CdmKeyAllowedUsage allowed_usage_;
+  CryptoSession::HdcpCapability default_hdcp_level_;
+  ConstraintList constraints_;
+
+  CORE_DISALLOW_COPY_AND_ASSIGN(LicenseKeyStatus);
+};
+
+}  // namespace wvcdm
+
+#endif  // WVCDM_CORE_LICENSE_KEY_STATUS_H_
diff --git a/widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/core/include/lock.h b/widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/core/include/lock.h
new file mode 100644
index 0000000..decb1ca
--- /dev/null
+++ b/widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/core/include/lock.h
@@ -0,0 +1,51 @@
+// Copyright 2013 Google Inc. All Rights Reserved.
+//
+// Lock - Platform independent interface for a Mutex class
+//
+#ifndef WVCDM_CORE_LOCK_H_
+#define WVCDM_CORE_LOCK_H_
+
+#include "wv_cdm_types.h"
+
+namespace wvcdm {
+
+// Simple lock class. The implementation is platform dependent.
+//
+// The lock must be unlocked by the thread that locked it.
+// The lock is also not recursive (ie. cannot be taken multiple times).
+class Lock {
+ public:
+  Lock();
+  ~Lock();
+
+  void Acquire();
+  void Release();
+
+  friend class AutoLock;
+
+ private:
+  class Impl;
+  Impl* impl_;
+
+  CORE_DISALLOW_COPY_AND_ASSIGN(Lock);
+};
+
+// Manages the lock automatically. It will be locked when AutoLock
+// is constructed and release when AutoLock goes out of scope.
+class AutoLock {
+ public:
+  explicit AutoLock(Lock& lock) : lock_(&lock) { lock_->Acquire(); }
+
+  explicit AutoLock(Lock* lock) : lock_(lock) { lock_->Acquire(); }
+
+  ~AutoLock() { lock_->Release(); }
+
+ private:
+  Lock* lock_;
+
+  CORE_DISALLOW_COPY_AND_ASSIGN(AutoLock);
+};
+
+}  // namespace wvcdm
+
+#endif  // WVCDM_CORE_LOCK_H_
diff --git a/widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/core/include/log.h b/widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/core/include/log.h
new file mode 100644
index 0000000..3ef1522
--- /dev/null
+++ b/widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/core/include/log.h
@@ -0,0 +1,44 @@
+// Copyright 2013 Google Inc. All Rights Reserved.
+//
+// Log - Platform independent interface for a Logging class
+//
+#ifndef WVCDM_CORE_LOG_H_
+#define WVCDM_CORE_LOG_H_
+
+namespace wvcdm {
+
+// Simple logging class. The implementation is platform dependent.
+
+typedef enum {
+  LOG_ERROR,
+  LOG_WARN,
+  LOG_INFO,
+  LOG_DEBUG,
+  LOG_VERBOSE
+} LogPriority;
+
+extern LogPriority g_cutoff;
+
+// Enable/disable verbose logging (LOGV).
+// This function is supplied for cases where the system layer does not
+// initialize logging.  This is also needed to initialize logging in
+// unit tests.
+void InitLogging();
+
+void Log(const char* file, const char* function, int line, LogPriority level,
+         const char* fmt, ...);
+
+// Log APIs
+#define LOGE(...) Log(__FILE__, __func__, __LINE__, \
+                      wvcdm::LOG_ERROR, __VA_ARGS__)
+#define LOGW(...) Log(__FILE__, __func__, __LINE__, \
+                      wvcdm::LOG_WARN, __VA_ARGS__)
+#define LOGI(...) Log(__FILE__, __func__, __LINE__, \
+                      wvcdm::LOG_INFO, __VA_ARGS__)
+#define LOGD(...) Log(__FILE__, __func__, __LINE__, \
+                      wvcdm::LOG_DEBUG, __VA_ARGS__)
+#define LOGV(...) Log(__FILE__, __func__, __LINE__, \
+                      wvcdm::LOG_VERBOSE, __VA_ARGS__)
+}  // namespace wvcdm
+
+#endif  // WVCDM_CORE_LOG_H_
diff --git a/widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/core/include/oemcrypto_adapter.h b/widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/core/include/oemcrypto_adapter.h
new file mode 100644
index 0000000..19d7854
--- /dev/null
+++ b/widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/core/include/oemcrypto_adapter.h
@@ -0,0 +1,85 @@
+// Copyright 2013 Google Inc. All Rights Reserved.
+//
+#ifndef WVCDM_CORE_OEMCRYPTO_ADAPTER_H_
+#define WVCDM_CORE_OEMCRYPTO_ADAPTER_H_
+
+#include "OEMCryptoCENC.h"
+#include "wv_cdm_types.h"
+
+namespace wvcdm {
+
+// This attempts to open a session at the desired security level.
+// If one level is not available, the other will be used instead.
+OEMCryptoResult OEMCrypto_OpenSession(OEMCrypto_SESSION* session,
+                                      SecurityLevel level);
+OEMCryptoResult OEMCrypto_CopyBuffer(
+    SecurityLevel level, const uint8_t* data_addr, size_t data_length,
+    OEMCrypto_DestBufferDesc* out_buffer, uint8_t subsample_flags);
+OEMCryptoResult OEMCrypto_InstallKeybox(const uint8_t* keybox,
+                                        size_t keyBoxLength,
+                                        SecurityLevel level);
+OEMCryptoResult OEMCrypto_IsKeyboxValid(SecurityLevel level);
+OEMCryptoResult OEMCrypto_GetDeviceID(uint8_t* deviceID, size_t* idLength,
+                                      SecurityLevel level);
+OEMCryptoResult OEMCrypto_GetKeyData(uint8_t* keyData, size_t* keyDataLength,
+                                     SecurityLevel level);
+uint32_t OEMCrypto_APIVersion(SecurityLevel level);
+const char* OEMCrypto_SecurityLevel(SecurityLevel level);
+OEMCryptoResult OEMCrypto_GetHDCPCapability(SecurityLevel level,
+                                            OEMCrypto_HDCP_Capability* current,
+                                            OEMCrypto_HDCP_Capability* maximum);
+bool OEMCrypto_SupportsUsageTable(SecurityLevel level);
+bool OEMCrypto_IsAntiRollbackHwPresent(SecurityLevel level);
+OEMCryptoResult OEMCrypto_GetNumberOfOpenSessions(SecurityLevel level,
+                                                  size_t* count);
+OEMCryptoResult OEMCrypto_GetMaxNumberOfSessions(SecurityLevel level,
+                                                 size_t* maximum);
+uint8_t OEMCrypto_Security_Patch_Level(SecurityLevel level);
+OEMCrypto_ProvisioningMethod OEMCrypto_GetProvisioningMethod(
+    SecurityLevel level);
+uint32_t OEMCrypto_SupportedCertificates(SecurityLevel level);
+OEMCryptoResult OEMCrypto_CreateUsageTableHeader(SecurityLevel level,
+                                                 uint8_t* header_buffer,
+                                                 size_t* header_buffer_length);
+OEMCryptoResult OEMCrypto_LoadUsageTableHeader(SecurityLevel level,
+                                               const uint8_t* buffer,
+                                               size_t buffer_length);
+OEMCryptoResult OEMCrypto_ShrinkUsageTableHeader(SecurityLevel level,
+                                                 uint32_t new_table_size,
+                                                 uint8_t* header_buffer,
+                                                 size_t* header_buffer_length);
+OEMCryptoResult OEMCrypto_CreateOldUsageEntry(SecurityLevel level,
+    uint64_t time_since_license_received, uint64_t time_since_first_decrypt,
+    uint64_t time_since_last_decrypt, OEMCrypto_Usage_Entry_Status status,
+    uint8_t* server_mac_key, uint8_t* client_mac_key, const uint8_t* pst,
+    size_t pst_length);
+
+}  // namespace wvcdm
+
+/* The following functions are deprecated in OEMCrypto v13.  They are defined
+ * here so that core cdm code may be backwards compatible with an OEMCrypto
+ * v12.
+ */
+extern "C" {
+
+OEMCryptoResult OEMCrypto_LoadKeys_V11_or_V12(
+    OEMCrypto_SESSION session, const uint8_t* message, size_t message_length,
+    const uint8_t* signature, size_t signature_length,
+    const uint8_t* enc_mac_keys_iv, const uint8_t* enc_mac_keys,
+    size_t num_keys, const OEMCrypto_KeyObject* key_array, const uint8_t* pst,
+    size_t pst_length);
+
+OEMCryptoResult OEMCrypto_UpdateUsageTable();
+
+OEMCryptoResult OEMCrypto_DeactivateUsageEntry_V12(const uint8_t* pst,
+                                                  size_t pst_length);
+OEMCryptoResult OEMCrypto_DeleteUsageEntry(
+    OEMCrypto_SESSION session, const uint8_t* pst, size_t pst_length,
+    const uint8_t* message, size_t message_length, const uint8_t* signature,
+    size_t signature_length);
+
+OEMCryptoResult OEMCrypto_ForceDeleteUsageEntry(const uint8_t* pst,
+                                                size_t pst_length);
+}  // extern "C"
+
+#endif  // WVCDM_CORE_OEMCRYPTO_ADAPTER_H_
diff --git a/widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/core/include/override.h b/widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/core/include/override.h
new file mode 100644
index 0000000..a206d16
--- /dev/null
+++ b/widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/core/include/override.h
@@ -0,0 +1,18 @@
+// Copyright 2015 Google Inc. All Rights Reserved.
+// TODO: Import to core/, use everywhere.
+#ifndef WVCDM_CDM_OVERRIDE_H_
+#define WVCDM_CDM_OVERRIDE_H_
+
+#define GCC_HAS_OVERRIDE ( \
+  (__GNUC__ > 4) || \
+  (__GNUC__ == 4 && __GNUC_MINOR__ >= 7) \
+)
+
+#if !defined(DISABLE_OVERRIDE_KEYWORD) && \
+    (defined(COMPILER_MSVC) || defined(__clang__) || GCC_HAS_OVERRIDE)
+#define OVERRIDE override
+#else
+#define OVERRIDE
+#endif
+
+#endif  // WVCDM_CDM_OVERRIDE_H_
diff --git a/widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/core/include/policy_engine.h b/widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/core/include/policy_engine.h
new file mode 100644
index 0000000..113253a
--- /dev/null
+++ b/widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/core/include/policy_engine.h
@@ -0,0 +1,216 @@
+// Copyright 2013 Google Inc. All Rights Reserved.
+
+#ifndef WVCDM_CORE_POLICY_ENGINE_H_
+#define WVCDM_CORE_POLICY_ENGINE_H_
+
+#include <map>
+#include <string>
+
+#include "license_key_status.h"
+#include "license_protocol.pb.h"
+#include "scoped_ptr.h"
+#include "wv_cdm_types.h"
+
+namespace wvcdm {
+
+using video_widevine::LicenseIdentification;
+
+class Clock;
+class CryptoSession;
+class WvCdmEventListener;
+
+// This acts as an oracle that basically says "Yes(true) you may still decrypt
+// or no(false) you may not decrypt this data anymore."
+class PolicyEngine {
+ public:
+  PolicyEngine(CdmSessionId session_id, WvCdmEventListener* event_listener,
+               CryptoSession* crypto_session);
+  virtual ~PolicyEngine();
+
+  // The value returned should be taken as a hint rather than an absolute
+  // status. It is computed during the last call to either SetLicense/
+  // UpdateLicense/OnTimerEvent/BeginDecryption and may be out of sync
+  // depending on the amount of time elapsed. The current decryption
+  // status is not calculated to avoid overhead in the decryption path.
+  virtual bool CanDecryptContent(const KeyId& key_id);
+
+  // Returns the current CdmKeyStatus for the given key, or
+  // kKeyStatusKeyUnknown if the key is not found. This is useful for finding
+  // out why a key is not usable.
+  virtual CdmKeyStatus GetKeyStatus(const KeyId& key_id);
+
+  // OnTimerEvent is called when a timer fires. It notifies the Policy Engine
+  // that the timer has fired and dispatches the relevant events through
+  // |event_listener_|.
+  virtual void OnTimerEvent();
+
+  // SetLicense is used in handling the initial license response. It stores
+  // an exact copy of the policy information stored in the license.
+  // The license state transitions to kLicenseStateCanPlay if the license
+  // permits playback.
+  virtual void SetLicense(const video_widevine::License& license);
+
+  virtual void UpdateLicenseKeys(const video_widevine::License& license);
+
+  // SetLicenseForRelease is used when releasing a license. The keys in this
+  // license will be ignored, and any old keys will be expired.
+  virtual void SetLicenseForRelease(
+      const video_widevine::License& license);
+
+  // Call this on first decrypt to set the start of playback.
+  virtual void BeginDecryption(void);
+  virtual void DecryptionEvent(void);
+
+  // UpdateLicense is used in handling a license response for a renewal request.
+  // The response may only contain any policy fields that have changed. In this
+  // case an exact copy is not what we want to happen. We also will receive an
+  // updated license_start_time from the server. The license will transition to
+  // kLicenseStateCanPlay if the license permits playback.
+  virtual void UpdateLicense(
+      const video_widevine::License& license);
+
+  // Used for notifying the Policy Engine of resolution changes
+  virtual void NotifyResolution(uint32_t width, uint32_t height);
+
+  virtual void NotifySessionExpiration();
+
+  virtual CdmResponseType Query(CdmQueryMap* query_response);
+
+  virtual CdmResponseType QueryKeyAllowedUsage(const KeyId& key_id,
+                                               CdmKeyAllowedUsage* key_usage);
+
+  virtual const LicenseIdentification& license_id() { return license_id_; }
+
+  bool GetSecondsSinceStarted(int64_t* seconds_since_started);
+  bool GetSecondsSinceLastPlayed(int64_t* seconds_since_started);
+
+  // for offline save and restore
+  int64_t GetPlaybackStartTime() { return playback_start_time_; }
+  int64_t GetLastPlaybackTime() { return last_playback_time_; }
+  int64_t GetGracePeriodEndTime() { return grace_period_end_time_; }
+  void RestorePlaybackTimes(int64_t playback_start_time,
+                            int64_t last_playback_time,
+                            int64_t grace_period_end_time);
+
+  bool IsLicenseForFuture() { return license_state_ == kLicenseStatePending; }
+  bool HasPlaybackStarted(int64_t current_time) {
+    if (playback_start_time_ == 0)
+      return false;
+
+    const int64_t playback_time = current_time - playback_start_time_;
+    return playback_time >= policy_.play_start_grace_period_seconds();
+  }
+
+  bool HasLicenseOrPlaybackDurationExpired(int64_t current_time);
+  int64_t GetLicenseOrPlaybackDurationRemaining();
+
+  bool CanRenew() { return policy_.can_renew(); }
+
+  bool IsSufficientOutputProtection(const KeyId& key_id) {
+    return license_keys_->MeetsConstraints(key_id);
+  }
+
+ private:
+  friend class PolicyEngineTest;
+  friend class PolicyEngineConstraintsTest;
+
+  void InitDevice(CryptoSession* crypto_session);
+  void SetDeviceResolution(uint32_t width, uint32_t height);
+  void CheckDeviceHdcpStatusOnTimer(int64_t current_time);
+  void CheckDeviceHdcpStatus();
+
+  typedef enum {
+    kLicenseStateInitial,
+    kLicenseStatePending,  // if license is issued for sometime in the future
+    kLicenseStateCanPlay,
+    kLicenseStateNeedRenewal,
+    kLicenseStateWaitingLicenseUpdate,
+    kLicenseStateExpired
+  } LicenseState;
+
+  // Gets the clock time that the license expires.  This is the hard limit that
+  // all license types must obey at all times.
+  int64_t GetHardLicenseExpiryTime();
+  // Gets the clock time that the rental duration will expire, using the license
+  // duration if one is not present.
+  int64_t GetRentalExpiryTime();
+  // Gets the clock time that the license expires based on whether we have
+  // started playing.  This takes into account GetHardLicenseExpiryTime.
+  int64_t GetExpiryTime(int64_t current_time,
+                        bool ignore_soft_enforce_playback_duration);
+
+  int64_t GetLicenseOrRentalDurationRemaining(int64_t current_time);
+  int64_t GetPlaybackDurationRemaining(int64_t current_time);
+
+  bool HasRenewalDelayExpired(int64_t current_time);
+  bool HasRenewalRecoveryDurationExpired(int64_t current_time);
+  bool HasRenewalRetryIntervalExpired(int64_t current_time);
+
+  void UpdateRenewalRequest(int64_t current_time);
+
+  // Notifies updates in keys information and fire OnKeysChange event if
+  // key changes.
+  void NotifyKeysChange(CdmKeyStatus new_status);
+
+  // Notifies updates in expiry time and fire OnExpirationUpdate event if
+  // expiry time changes.
+  void NotifyExpirationUpdate(int64_t current_time);
+
+  // Guard against clock rollbacks
+  int64_t GetCurrentTime();
+
+  // set_clock() is for testing only. It alters ownership of the
+  // passed-in pointer.
+  void set_clock(Clock* clock);
+
+  LicenseState license_state_;
+
+  // This is the current policy information for this license. This gets updated
+  // as license renewals occur.
+  video_widevine::License::Policy policy_;
+
+  // This is the license id field from server response. This data gets passed
+  // back to the server in each renewal request. When we get a renewal response
+  // from the license server we will get an updated id field.
+  video_widevine::LicenseIdentification license_id_;
+
+  // The server returns the license start time in the license/license renewal
+  // response based off the request time sent by the client in the
+  // license request/renewal
+  int64_t license_start_time_;
+  int64_t playback_start_time_;
+  int64_t last_playback_time_;
+  int64_t last_expiry_time_;
+  int64_t grace_period_end_time_;
+  bool last_expiry_time_set_;
+  bool was_expired_on_load_;
+
+  // This is used as a reference point for policy management. This value
+  // represents an offset from license_start_time_. This is used to
+  // calculate the time where renewal retries should occur.
+  int64_t next_renewal_time_;
+
+  // to assist in clock rollback checks
+  int64_t last_recorded_current_time_;
+
+  // Used to dispatch CDM events.
+  CdmSessionId session_id_;
+  WvCdmEventListener* event_listener_;
+
+  // Keys associated with license - holds allowed usage, usage constraints,
+  // and current status (CdmKeyStatus)
+  scoped_ptr<LicenseKeys> license_keys_;
+
+  // Device checks
+  int64_t next_device_check_;
+  uint32_t current_resolution_;
+  CryptoSession* crypto_session_;
+
+  scoped_ptr<Clock> clock_;
+
+  CORE_DISALLOW_COPY_AND_ASSIGN(PolicyEngine);
+};
+
+}  // wvcdm
+
+#endif  // WVCDM_CORE_POLICY_ENGINE_H_
diff --git a/widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/core/include/privacy_crypto.h b/widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/core/include/privacy_crypto.h
new file mode 100644
index 0000000..68511e1
--- /dev/null
+++ b/widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/core/include/privacy_crypto.h
@@ -0,0 +1,70 @@
+// Copyright 2013 Google Inc. All Rights Reserved.
+//
+// Description:
+//   Declaration of classes representing AES and RSA public keys used
+//   for signature verification and encryption.
+//
+// AES encryption details:
+//   Algorithm: AES-CBC
+//
+// RSA signature details:
+//   Algorithm: RSASSA-PSS
+//   Hash algorithm: SHA1
+//   Mask generation function: mgf1SHA1
+//   Salt length: 20 bytes
+//   Trailer field: 0xbc
+//
+// RSA encryption details:
+//   Algorithm: RSA-OAEP
+//   Mask generation function: mgf1SHA1
+//   Label (encoding paramter): empty string
+//
+#ifndef WVCDM_CORE_PRIVACY_CRYPTO_H_
+#define WVCDM_CORE_PRIVACY_CRYPTO_H_
+
+#include <string>
+
+#include "wv_cdm_types.h"
+
+namespace wvcdm {
+
+class AesCbcKey {
+ public:
+  AesCbcKey();
+  ~AesCbcKey();
+
+  bool Init(const std::string& key);
+  bool Encrypt(const std::string& in, std::string* out, std::string* iv);
+
+ private:
+  std::string key_;
+
+  CORE_DISALLOW_COPY_AND_ASSIGN(AesCbcKey);
+};
+
+class RsaPublicKey {
+ public:
+  RsaPublicKey();
+  ~RsaPublicKey();
+
+  // Initializes an RsaPublicKey object using a DER encoded PKCS#1 RSAPublicKey
+  bool Init(const std::string& serialized_key);
+
+  // Encrypt a message using RSA-OAEP. Caller retains ownership of all
+  // parameters. Returns true if successful, false otherwise.
+  bool Encrypt(const std::string& plaintext, std::string* ciphertext);
+
+  // Verify RSASSA-PSS signature. Caller retains ownership of all parameters.
+  // Returns true if validation succeeds, false otherwise.
+  bool VerifySignature(const std::string& message,
+                       const std::string& signature);
+
+ private:
+  std::string serialized_key_;
+
+  CORE_DISALLOW_COPY_AND_ASSIGN(RsaPublicKey);
+};
+
+}  // namespace wvcdm
+
+#endif  // WVCDM_CORE_PRIVACY_CRYPTO_H_
diff --git a/widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/core/include/properties.h b/widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/core/include/properties.h
new file mode 100644
index 0000000..214d9e1
--- /dev/null
+++ b/widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/core/include/properties.h
@@ -0,0 +1,130 @@
+// Copyright 2013 Google Inc. All Rights Reserved.
+
+#ifndef WVCDM_CORE_PROPERTIES_H_
+#define WVCDM_CORE_PROPERTIES_H_
+
+#include <map>
+#include <string>
+
+#include "cdm_client_property_set.h"
+#include "lock.h"
+#include "scoped_ptr.h"
+#include "wv_cdm_types.h"
+
+#if defined(UNIT_TEST)
+#include <gtest/gtest_prod.h>
+#endif
+
+namespace wvcdm {
+
+typedef std::map<CdmSessionId, CdmClientPropertySet*>
+    CdmClientPropertySetMap;
+
+// This class saves information about features and properties enabled
+// for a given platform. At initialization it initializes properties from
+// property_configuration.h. That file specifies features selected for each
+// platform. Core CDM can then query enabled features though specific getter
+// methods.
+// Setter methods are provided but their only planned use is for testing.
+class Properties {
+ public:
+  static void Init();
+
+  static inline bool oem_crypto_use_secure_buffers() {
+    return oem_crypto_use_secure_buffers_;
+  }
+  static inline bool oem_crypto_use_fifo() { return oem_crypto_use_fifo_; }
+  static inline bool oem_crypto_use_userspace_buffers() {
+    return oem_crypto_use_userspace_buffers_;
+  }
+  static inline bool provisioning_messages_are_binary() {
+    return provisioning_messages_are_binary_;
+  }
+  static inline bool allow_service_certificate_requests() {
+    return allow_service_certificate_requests_;
+  }
+  static void set_provisioning_messages_are_binary(bool flag) {
+    provisioning_messages_are_binary_ = flag;
+  }
+  static inline bool security_level_path_backward_compatibility_support() {
+    return security_level_path_backward_compatibility_support_;
+  }
+  static bool GetCompanyName(std::string* company_name);
+  static bool GetModelName(std::string* model_name);
+  static bool GetArchitectureName(std::string* arch_name);
+  static bool GetDeviceName(std::string* device_name);
+  static bool GetProductName(std::string* product_name);
+  static bool GetBuildInfo(std::string* build_info);
+  static bool GetWVCdmVersion(std::string* version);
+  static bool GetDeviceFilesBasePath(CdmSecurityLevel security_level,
+                                     std::string* base_path);
+  static bool GetFactoryKeyboxPath(std::string* keybox);
+  static bool GetOEMCryptoPath(std::string* library_name);
+  static bool AlwaysUseKeySetIds();
+  static bool UseProviderIdInProvisioningRequest();
+
+  static bool GetSecurityLevelDirectories(std::vector<std::string>* dirs);
+  static bool GetApplicationId(const CdmSessionId& session_id,
+                               std::string* app_id);
+  static bool GetServiceCertificate(const CdmSessionId& session_id,
+                                    std::string* service_certificate);
+  static bool SetServiceCertificate(const CdmSessionId& session_id,
+                                    const std::string& service_certificate);
+  static bool GetDeviceProvisioningServiceCertificate(
+      const CdmSessionId& session_id, std::string* service_certificate);
+  static bool SetDeviceProvisioningServiceCertificate(
+      const CdmSessionId& session_id, const std::string& service_certificate);
+  static bool UsePrivacyMode(const CdmSessionId& session_id);
+  static uint32_t GetSessionSharingId(const CdmSessionId& session_id);
+
+  static bool AddSessionPropertySet(const CdmSessionId& session_id,
+                                    CdmClientPropertySet* property_set);
+  static bool RemoveSessionPropertySet(const CdmSessionId& session_id);
+
+ private:
+  static CdmClientPropertySet* GetCdmClientPropertySet(
+      const CdmSessionId& session_id);
+  static void set_oem_crypto_use_secure_buffers(bool flag) {
+    oem_crypto_use_secure_buffers_ = flag;
+  }
+  static void set_oem_crypto_use_fifo(bool flag) {
+    oem_crypto_use_fifo_ = flag;
+  }
+  static void set_oem_crypto_use_userspace_buffers(bool flag) {
+    oem_crypto_use_userspace_buffers_ = flag;
+  }
+  static void set_use_certificates_as_identification(bool flag) {
+    use_certificates_as_identification_ = flag;
+  }
+  static void set_security_level_path_backward_compatibility_support(
+      bool flag) {
+    security_level_path_backward_compatibility_support_ = flag;
+  }
+
+#if defined(UNIT_TEST)
+  FRIEND_TEST(CdmSessionTest, InitWithBuiltInCertificate);
+  FRIEND_TEST(CdmSessionTest, InitWithCertificate);
+  FRIEND_TEST(CdmSessionTest, InitWithKeybox);
+  FRIEND_TEST(CdmSessionTest, ReInitFail);
+  FRIEND_TEST(CdmSessionTest, InitFailCryptoError);
+  FRIEND_TEST(CdmSessionTest, InitNeedsProvisioning);
+  FRIEND_TEST(CdmLicenseTest, PrepareKeyRequestValidation);
+  FRIEND_TEST(SubLicenseTest, VerifySubSessionData);
+#endif
+
+ private:
+  static bool oem_crypto_use_secure_buffers_;
+  static bool oem_crypto_use_fifo_;
+  static bool oem_crypto_use_userspace_buffers_;
+  static bool use_certificates_as_identification_;
+  static bool security_level_path_backward_compatibility_support_;
+  static bool provisioning_messages_are_binary_;
+  static bool allow_service_certificate_requests_;
+  static scoped_ptr<CdmClientPropertySetMap> session_property_set_;
+
+  CORE_DISALLOW_COPY_AND_ASSIGN(Properties);
+};
+
+}  // namespace wvcdm
+
+#endif  // WVCDM_CORE_PROPERTIES_H_
diff --git a/widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/core/include/scoped_ptr.h b/widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/core/include/scoped_ptr.h
new file mode 100644
index 0000000..edaaacd
--- /dev/null
+++ b/widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/core/include/scoped_ptr.h
@@ -0,0 +1,65 @@
+// Copyright 2013 Google Inc. All Rights Reserved.
+//
+// A simple and partial implementation of scoped_ptr class.
+// The implementation is copied from gtest/include/gtest/internal/gtest-port.h.
+//
+#ifndef WVCDM_CORE_SCOPED_PTR_H_
+#define WVCDM_CORE_SCOPED_PTR_H_
+
+#include "wv_cdm_types.h"
+
+namespace wvcdm {
+
+// A scoped_ptr<T> is like a T*, except that the destructor of scoped_ptr<T>
+// automatically deletes the pointer it holds (if any).
+// That is, scoped_ptr<T> owns the T object that it points to.
+// Like a T*, a scoped_ptr<T> may hold either NULL or a pointer to a T object.
+// Also like T*, scoped_ptr<T> is thread-compatible, and once you
+// dereference it, you get the thread safety guarantees of T.
+//
+// The size of scoped_ptr is small. On most compilers, sizeof(scoped_ptr<T>)
+// == sizeof(T*).
+//
+// Current implementation targets having a strict subset of  C++11's
+// unique_ptr<> features. Known deficiencies include not supporting move-only
+// deleteres, function pointers as deleters, and deleters with reference
+// types.
+
+// This implementation of scoped_ptr is PARTIAL, e.g. it does not support move,
+// custom deleter etc.
+template <typename T>
+class scoped_ptr {
+ public:
+  typedef T element_type;
+
+  explicit scoped_ptr(T* p = NULL) : ptr_(p) {}
+  ~scoped_ptr() { reset(); }
+
+  T& operator*() const { return *ptr_; }
+  T* operator->() const { return ptr_; }
+  T* get() const { return ptr_; }
+
+  T* release() {
+    T* const ptr = ptr_;
+    ptr_ = NULL;
+    return ptr;
+  }
+
+  void reset(T* p = NULL) {
+    if (p != ptr_) {
+      if (sizeof(T) > 0) {  // Makes sure T is a complete type.
+        delete ptr_;
+      }
+      ptr_ = p;
+    }
+  }
+
+ private:
+  T* ptr_;
+
+  CORE_DISALLOW_COPY_AND_ASSIGN(scoped_ptr);
+};
+
+}  // namespace wvcdm
+
+#endif  // WVCDM_CORE_SCOPED_PTR_H_
diff --git a/widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/core/include/service_certificate.h b/widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/core/include/service_certificate.h
new file mode 100644
index 0000000..d672c3a
--- /dev/null
+++ b/widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/core/include/service_certificate.h
@@ -0,0 +1,85 @@
+// Copyright 2017 Google Inc. All Rights Reserved.
+//
+#ifndef WVCDM_CORE_SERVICE_CERTIFICATE_H_
+#define WVCDM_CORE_SERVICE_CERTIFICATE_H_
+
+// Service Certificates are used to encrypt the ClientIdentification message
+// that is part of Device Provisioning, License, Renewal, and Release requests.
+// It also supplies a provider_id setting used in device provisioning.
+// Service Certificates are typically supplied by the application. If one
+// is not supplied and privacy mode is enabled, the CDM will send a Service
+// Certificate Request to the target server to get one. Once the Service
+// Certificate is established for the session, it should not change.
+
+#include <memory>
+
+#include "license_protocol.pb.h"
+#include "privacy_crypto.h"
+#include "wv_cdm_types.h"
+
+namespace wvcdm {
+
+class CryptoSession;
+
+class ServiceCertificate {
+ public:
+  ServiceCertificate() : has_certificate_(false) {}
+  virtual ~ServiceCertificate() {}
+
+  // Set up a new service certificate.
+  // Accept a serialized video_widevine::SignedDrmDeviceCertificate message.
+  virtual CdmResponseType Init(const std::string& signed_certificate);
+
+  bool has_certificate() const { return has_certificate_; }
+  const std::string certificate() const { return certificate_; }
+  const std::string& provider_id() const { return provider_id_; }
+
+  // Verify the signature for a message.
+  virtual CdmResponseType VerifySignedMessage(const std::string& message,
+                                              const std::string& signature);
+
+  // Encrypt the ClientIdentification message for a provisioning or
+  // licensing request.  Encryption is performed using the current
+  // service certificate.  Return a failure if the service certificate is
+  // not present, not valid, or if some other error occurs.
+  // The routine should not be called if privacy mode is off or if the
+  // certificate is empty.
+  virtual CdmResponseType EncryptClientId(
+      CryptoSession* crypto_session,
+      const video_widevine::ClientIdentification* clear_client_id,
+      video_widevine::EncryptedClientIdentification* encrypted_client_id);
+
+  // Helper methods
+  static bool GetRequest(CdmKeyMessage* request);
+  static CdmResponseType ParseResponse(const std::string& response,
+                                       std::string* signed_certificate);
+ private:
+
+  // Encrypt data using RSA with OAEP padding.
+  // |plaintext| is the data to be encrypted. |ciphertext| is a pointer to a
+  // string to contain the decrypted data on return, and may not be null.
+  // returns NO_ERROR if successful or an appropriate error code otherwise.
+  virtual CdmResponseType EncryptRsaOaep(const std::string& plaintext,
+                                         std::string* ciphertext);
+
+  // Track whether object holds valid certificate
+  bool has_certificate_;
+
+  // Certificate, verified and extracted from signed message.
+  std::string certificate_;
+
+  // Certificate serial number.
+  std::string serial_number_;
+
+  // Provider ID, extracted from certificate message.
+  std::string provider_id_;
+
+  // Public key.
+  std::auto_ptr<RsaPublicKey> public_key_;
+
+  CORE_DISALLOW_COPY_AND_ASSIGN(ServiceCertificate);
+};
+
+}  // namespace wvcdm
+
+#endif  // WVCDM_CORE_SERVICE_CERTIFICATE_H_
diff --git a/widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/core/include/shared_ptr.h b/widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/core/include/shared_ptr.h
new file mode 100644
index 0000000..1d9b8f9
--- /dev/null
+++ b/widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/core/include/shared_ptr.h
@@ -0,0 +1,222 @@
+// Copyright 2017 Google Inc.  All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+// from google3/util/gtl/shared_ptr.h
+// from protobuf/src/google/protobuf/stubs/shared_ptr.h
+
+#ifndef WVCDM_CORE_SHARED_PTR_H__
+#define WVCDM_CORE_SHARED_PTR_H__
+
+#include <algorithm>  // for swap
+#include <stddef.h>
+#include <memory>
+
+#include "wv_cdm_types.h"
+
+namespace {
+bool Barrier_AtomicIncrement(volatile uint32_t* ptr, uint32_t value) {
+  *ptr += value;
+  return *ptr;
+}
+bool NoBarrier_AtomicIncrement(volatile uint32_t* ptr, uint32_t value) {
+  *ptr += value;
+  return *ptr;
+}
+
+inline bool RefCountDec(volatile uint32_t *ptr) {
+  return Barrier_AtomicIncrement(ptr, -1) != 0;
+}
+
+inline void RefCountInc(volatile uint32_t *ptr) {
+  NoBarrier_AtomicIncrement(ptr, 1);
+}
+
+}  // namespace
+
+namespace wvcdm {
+
+template <typename T> class shared_ptr;
+
+// This class is an internal implementation detail for shared_ptr. If two
+// shared_ptrs point to the same object, they also share a control block.
+// An "empty" shared_pointer refers to NULL and also has a NULL control block.
+// It contains all of the state that's needed for reference counting or any
+// other kind of resource management. In this implementation the control block
+// consists of a single reference count (the number of shared_ptrs that
+// share ownership of the object).
+class SharedPtrControlBlock {
+  template <typename T> friend class shared_ptr;
+ private:
+  SharedPtrControlBlock() : refcount_(1) {}
+  uint32_t refcount_;
+};
+
+// Forward declaration. The class is defined below.
+template <typename T> class enable_shared_from_this;
+
+template <typename T>
+class shared_ptr {
+ public:
+  typedef T element_type;
+
+  shared_ptr() : ptr_(NULL), control_block_(NULL) {}
+
+  explicit shared_ptr(T* ptr)
+      : ptr_(ptr),
+        control_block_(ptr != NULL ? new SharedPtrControlBlock : NULL) {
+  }
+
+  // Copy constructor: makes this object a copy of ptr, and increments
+  // the reference count.
+  template <typename U>
+  shared_ptr(const shared_ptr<U>& ptr)
+      : ptr_(NULL),
+        control_block_(NULL) {
+    Initialize(ptr);
+  }
+  // Need non-templated version to prevent the compiler-generated default
+  shared_ptr(const shared_ptr<T>& ptr)
+      : ptr_(NULL),
+        control_block_(NULL) {
+    Initialize(ptr);
+  }
+
+  // Assignment operator. Replaces the existing shared_ptr with ptr.
+  // Increment ptr's reference count and decrement the one being replaced.
+  template <typename U>
+  shared_ptr<T>& operator=(const shared_ptr<U>& ptr) {
+    if (ptr_ != ptr.ptr_) {
+      shared_ptr<T> me(ptr);   // will hold our previous state to be destroyed.
+      swap(me);
+    }
+    return *this;
+  }
+
+  // Need non-templated version to prevent the compiler-generated default
+  shared_ptr<T>& operator=(const shared_ptr<T>& ptr) {
+    if (ptr_ != ptr.ptr_) {
+      shared_ptr<T> me(ptr);   // will hold our previous state to be destroyed.
+      swap(me);
+    }
+    return *this;
+  }
+
+  ~shared_ptr() {
+    if (ptr_ != NULL) {
+      if (!RefCountDec(&control_block_->refcount_)) {
+        delete ptr_;
+      }
+    }
+  }
+
+  // Replaces underlying raw pointer with the one passed in.  The reference
+  // count is set to one (or zero if the pointer is NULL) for the pointer
+  // being passed in and decremented for the one being replaced.
+  //
+  // If you have a compilation error with this code, make sure you aren't
+  // passing NULL, nullptr, or 0 to this function.  Call reset without an
+  // argument to reset to a null ptr.
+  template <typename Y>
+  void reset(Y* p) {
+    if (p != ptr_) {
+      shared_ptr<T> tmp(p);
+      tmp.swap(*this);
+    }
+  }
+
+  void reset() {
+    reset(static_cast<T*>(NULL));
+  }
+
+  // Exchanges the contents of this with the contents of r.  This function
+  // supports more efficient swapping since it eliminates the need for a
+  // temporary shared_ptr object.
+  void swap(shared_ptr<T>& r) {
+    using std::swap;  // http://go/using-std-swap
+    swap(ptr_, r.ptr_);
+    swap(control_block_, r.control_block_);
+  }
+
+  // The following function is useful for gaining access to the underlying
+  // pointer when a shared_ptr remains in scope so the reference-count is
+  // known to be > 0 (e.g. for parameter passing).
+  T* get() const {
+    return ptr_;
+  }
+
+  T& operator*() const {
+    return *ptr_;
+  }
+
+  T* operator->() const {
+    return ptr_;
+  }
+
+  long use_count() const {
+    return control_block_ ? control_block_->refcount_ : 1;
+  }
+
+  bool unique() const {
+    return use_count() == 1;
+  }
+
+ private:
+  // If r is non-empty, initialize *this to share ownership with r,
+  // increasing the underlying reference count.
+  // If r is empty, *this remains empty.
+  // Requires: this is empty, namely this->ptr_ == NULL.
+  template <typename U>
+  void Initialize(const shared_ptr<U>& r) {
+    // This performs a static_cast on r.ptr_ to U*, which is a no-op since it
+    // is already a U*. So initialization here requires that r.ptr_ is
+    // implicitly convertible to T*.
+    InitializeWithStaticCast<U>(r);
+  }
+
+  // Initializes *this as described in Initialize, but additionally performs a
+  // static_cast from r.ptr_ (V*) to U*.
+  // NOTE(gfc): We'd need a more general form to support const_pointer_cast and
+  // dynamic_pointer_cast, but those operations are sufficiently discouraged
+  // that supporting static_pointer_cast is sufficient.
+  template <typename U, typename V>
+  void InitializeWithStaticCast(const shared_ptr<V>& r) {
+    if (r.control_block_ != NULL) {
+      RefCountInc(&r.control_block_->refcount_);
+
+      ptr_ = static_cast<U*>(r.ptr_);
+      control_block_ = r.control_block_;
+    }
+  }
+
+  T* ptr_;
+  SharedPtrControlBlock* control_block_;
+};
+
+}  // namespace wvcdm
+
+#endif  // WVCDM_CORE_SHARED_PTR_H__
diff --git a/widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/core/include/string_conversions.h b/widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/core/include/string_conversions.h
new file mode 100644
index 0000000..d261c80
--- /dev/null
+++ b/widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/core/include/string_conversions.h
@@ -0,0 +1,30 @@
+// Copyright 2013 Google Inc. All Rights Reserved.
+
+#ifndef WVCDM_CORE_STRING_CONVERSIONS_H_
+#define WVCDM_CORE_STRING_CONVERSIONS_H_
+
+#include <stddef.h>
+#include <stdint.h>
+#include <string>
+#include <vector>
+
+namespace wvcdm {
+
+std::vector<uint8_t> a2b_hex(const std::string& b);
+std::vector<uint8_t> a2b_hex(const std::string& label, const std::string& b);
+std::string a2bs_hex(const std::string& b);
+std::string b2a_hex(const std::vector<uint8_t>& b);
+std::string b2a_hex(const std::string& b);
+std::string Base64Encode(const std::vector<uint8_t>& bin_input);
+std::vector<uint8_t> Base64Decode(const std::string& bin_input);
+std::string Base64SafeEncode(const std::vector<uint8_t>& bin_input);
+std::string Base64SafeEncodeNoPad(const std::vector<uint8_t>& bin_input);
+std::vector<uint8_t> Base64SafeDecode(const std::string& bin_input);
+std::string HexEncode(const uint8_t* bytes, unsigned size);
+std::string IntToString(int value);
+int64_t htonll64(int64_t x);
+inline int64_t ntohll64(int64_t x) { return htonll64(x); }
+
+}  // namespace wvcdm
+
+#endif  // WVCDM_CORE_STRING_CONVERSIONS_H_
diff --git a/widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/core/include/usage_table_header.h b/widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/core/include/usage_table_header.h
new file mode 100644
index 0000000..78f3b9e
--- /dev/null
+++ b/widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/core/include/usage_table_header.h
@@ -0,0 +1,136 @@
+// Copyright 2017 Google Inc. All Rights Reserved.
+
+#ifndef WVCDM_CORE_USAGE_TABLE_HEADER_H_
+#define WVCDM_CORE_USAGE_TABLE_HEADER_H_
+
+#include <string>
+#include <vector>
+
+#include "device_files.h"
+#include "file_store.h"
+#include "lock.h"
+#include "metrics_collections.h"
+#include "scoped_ptr.h"
+#include "wv_cdm_types.h"
+
+namespace wvcdm {
+
+class CryptoSession;
+
+// Offline licenses/secure stops may be securely tracked using usage
+// tables (OEMCrypto v9-12) or usage table headers+usage entries
+// (OEMCrypto v13+). This class assists with the latter, synchronizing
+// access to usage table header and associated data-structures and controlling
+// when they are read in or written out to non-secure persistent storage.
+//
+// Each OEMCrypto (for each security level) will maintain its own usage table
+// header. Each license will have an associated usage entry that is also
+// stored in persistent memory and is noted in the usage table header.
+// Usage entry information will be verified when licenses are loaded.
+//
+// OEMCrypto for each security level have their own usage table
+// headers. They are loaded on initialization and written out periodically.
+// The lifecycle of this class is tied to when OEMCrypto is
+// initialized/terminated.
+//
+// Sessions and licenses are however handled by CdmSession and so most
+// calls to maniplate the usage table header related to usage entries
+// are by CdmSession.
+//
+// Upgrades from a fixed size usage table (supported by previous
+// versions of the OEMCrypto API v9-12) are handled by this class.
+// |usage_entry| and |usage_entry_number|s need to be saved in the license
+// and usage info records by the caller.
+class UsageTableHeader {
+ public:
+  UsageTableHeader();
+  virtual ~UsageTableHeader() {}
+
+  // |crypto_session| is used to create or load a usage master table and
+  // not cached beyound this call.
+  bool Init(CdmSecurityLevel security_level, CryptoSession* crypto_session);
+
+  // |persistent_license| false indicates usage info record
+  CdmResponseType AddEntry(CryptoSession* crypto_session,
+                           bool persistent_license,
+                           const CdmKeySetId& key_set_id,
+                           const std::string& usage_info_filename,
+                           uint32_t* usage_entry_number);
+  CdmResponseType LoadEntry(CryptoSession* crypto_session,
+                            const CdmUsageEntry& usage_entry,
+                            uint32_t usage_entry_number);
+  CdmResponseType UpdateEntry(CryptoSession* crypto_session,
+                              CdmUsageEntry* usage_entry);
+
+  // The licenses or usage info records specified by |usage_entry_number|
+  // should not be in use by any open CryptoSession objects when calls
+  // to DeleteEntry and MoveEntry are made.
+  CdmResponseType DeleteEntry(uint32_t usage_entry_number, DeviceFiles* handle,
+                              metrics::CryptoMetrics* metrics);
+
+ private:
+  CdmResponseType MoveEntry(uint32_t from /* usage entry number */,
+                            const CdmUsageEntry& from_usage_entry,
+                            uint32_t to /* usage entry number */,
+                            DeviceFiles* handle,
+                            metrics::CryptoMetrics* metrics);
+
+  CdmResponseType GetEntry(uint32_t usage_entry_number, DeviceFiles* handle,
+                           CdmUsageEntry* usage_entry);
+  CdmResponseType StoreEntry(uint32_t usage_entry_number, DeviceFiles* handle,
+                             const CdmUsageEntry& usage_entry);
+
+  CdmResponseType Shrink(metrics::CryptoMetrics* metrics,
+                         uint32_t number_of_usage_entries_to_delete);
+
+  CdmResponseType UpgradeFromUsageTable(DeviceFiles* handle,
+                                        metrics::CryptoMetrics* metrics);
+  bool UpgradeLicensesFromUsageTable(DeviceFiles* handle,
+                                     metrics::CryptoMetrics* metrics);
+  bool UpgradeUsageInfoFromUsageTable(DeviceFiles* handle,
+                                      metrics::CryptoMetrics* metrics);
+
+  virtual bool is_inited() { return is_inited_; }
+
+  virtual bool CreateDummyOldUsageEntry(CryptoSession* crypto_session);
+
+  // This handle and file system is only to be used when accessing
+  // usage_table_header. Usage entries should use the file system provided
+  // by CdmSession.
+  scoped_ptr<DeviceFiles> file_handle_;
+  scoped_ptr<FileSystem> file_system_;
+  CdmSecurityLevel security_level_;
+  SecurityLevel requested_security_level_;
+
+  CdmUsageTableHeader usage_table_header_;
+  std::vector<CdmUsageEntryInfo> usage_entry_info_;
+
+  // Lock to ensure that a single object is created for each security level
+  // and data member to represent whether an object has been correctly
+  // initialized.
+  bool is_inited_;
+
+  // Synchonizes access to the Usage Table Header and bookkeeping
+  // data-structures
+  Lock usage_table_header_lock_;
+
+  // Test related declarations
+  friend class UsageTableHeaderTest;
+
+  // These setters are for testing only. Takes ownership of the pointers.
+  void SetDeviceFiles(DeviceFiles* device_files) {
+    file_handle_.reset(device_files);
+  }
+  void SetCryptoSession(CryptoSession* crypto_session) {
+    test_crypto_session_.reset(crypto_session);
+  }
+
+  // Test related data members
+  scoped_ptr<CryptoSession> test_crypto_session_;
+
+  CORE_DISALLOW_COPY_AND_ASSIGN(UsageTableHeader);
+};
+
+}  // namespace wvcdm
+
+#endif  // WVCDM_CORE_USAGE_TABLE_HEADER_H_
diff --git a/widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/core/include/wv_cdm_constants.h b/widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/core/include/wv_cdm_constants.h
new file mode 100644
index 0000000..ae3bd2d
--- /dev/null
+++ b/widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/core/include/wv_cdm_constants.h
@@ -0,0 +1,115 @@
+// Copyright 2012 Google Inc. All Rights Reserved.
+
+#ifndef WVCDM_CORE_WV_CDM_CONSTANTS_H_
+#define WVCDM_CORE_WV_CDM_CONSTANTS_H_
+
+#include <string>
+
+namespace wvcdm {
+static const size_t KEY_CONTROL_SIZE = 16;
+static const size_t KEY_ID_SIZE = 16;
+static const size_t KEY_IV_SIZE = 16;
+static const size_t KEY_PAD_SIZE = 16;
+static const size_t KEY_SIZE = 16;
+static const size_t MAC_KEY_SIZE = 32;
+static const size_t KEYBOX_KEY_DATA_SIZE = 72;
+static const size_t SRM_REQUIREMENT_SIZE = 12;
+
+// Initial estimate of certificate size.  Code that
+// uses this estimate should be able to adapt to a larger or smaller size.
+static const size_t CERTIFICATE_DATA_SIZE = 4 * 1024;
+
+// Use 0 to represent never expired license as specified in EME spec
+// (NaN in JS translates to 0 in unix timestamp).
+static const int64_t NEVER_EXPIRES = 0;
+
+static const char SESSION_ID_PREFIX[] = "sid";
+static const char KEY_SET_ID_PREFIX[] = "ksid";
+static const char KEY_SYSTEM[] = "com.widevine";
+
+// define query keys, values here
+static const std::string QUERY_KEY_LICENSE_TYPE = "LicenseType";
+                                                    // "Streaming", "Offline"
+static const std::string QUERY_KEY_PLAY_ALLOWED = "PlayAllowed";
+                                                    // "True", "False"
+static const std::string QUERY_KEY_PERSIST_ALLOWED = "PersistAllowed";
+                                                    // "True", "False"
+static const std::string QUERY_KEY_RENEW_ALLOWED = "RenewAllowed";
+                                                    // "True", "False"
+static const std::string QUERY_KEY_LICENSE_DURATION_REMAINING =
+    "LicenseDurationRemaining";        // non-negative integer denoting seconds
+static const std::string QUERY_KEY_PLAYBACK_DURATION_REMAINING =
+    "PlaybackDurationRemaining";      // non-negative integer denoting seconds
+static const std::string QUERY_KEY_RENEWAL_SERVER_URL = "RenewalServerUrl";
+                                                    // url
+static const std::string QUERY_KEY_OEMCRYPTO_SESSION_ID = "OemCryptoSessionId";
+                                                    // session id
+static const std::string QUERY_KEY_SECURITY_LEVEL = "SecurityLevel";
+                                                    // "L1", "L3"
+static const std::string QUERY_KEY_DEVICE_ID = "DeviceID";
+                                               // device unique id
+static const std::string QUERY_KEY_SYSTEM_ID = "SystemID";
+                                               // system id
+static const std::string QUERY_KEY_PROVISIONING_ID = "ProvisioningID";
+                                               // provisioning unique id
+static const std::string QUERY_KEY_CURRENT_HDCP_LEVEL = "HdcpLevel";
+                                                        // current HDCP level
+static const std::string QUERY_KEY_MAX_HDCP_LEVEL = "MaxHdcpLevel";
+                                                // maximum supported HDCP level
+static const std::string QUERY_KEY_USAGE_SUPPORT = "UsageSupport";
+                                        // whether usage reporting is supported
+static const std::string QUERY_KEY_NUMBER_OF_OPEN_SESSIONS =
+    "NumberOfOpenSessions";
+static const std::string QUERY_KEY_MAX_NUMBER_OF_SESSIONS =
+    "MaxNumberOfSessions";
+static const std::string QUERY_KEY_OEMCRYPTO_API_VERSION =
+    "OemCryptoApiVersion";
+static const std::string QUERY_KEY_CURRENT_SRM_VERSION = "CurrentSRMVersion";
+static const std::string QUERY_KEY_SRM_UPDATE_SUPPORT = "SRMUpdateSupport";
+                                        // whether OEM supports SRM update
+static const std::string QUERY_KEY_WVCDM_VERSION = "WidevineCdmVersion";
+
+static const std::string QUERY_VALUE_TRUE = "True";
+static const std::string QUERY_VALUE_FALSE = "False";
+static const std::string QUERY_VALUE_STREAMING = "Streaming";
+static const std::string QUERY_VALUE_OFFLINE = "Offline";
+static const std::string QUERY_VALUE_SECURITY_LEVEL_L1 = "L1";
+static const std::string QUERY_VALUE_SECURITY_LEVEL_L2 = "L2";
+static const std::string QUERY_VALUE_SECURITY_LEVEL_L3 = "L3";
+static const std::string QUERY_VALUE_SECURITY_LEVEL_UNKNOWN = "Unknown";
+static const std::string QUERY_VALUE_SECURITY_LEVEL_DEFAULT = "Default";
+static const std::string QUERY_VALUE_DISCONNECTED = "Disconnected";
+static const std::string QUERY_VALUE_UNPROTECTED = "Unprotected";
+static const std::string QUERY_VALUE_HDCP_V1 = "HDCP-1.x";
+static const std::string QUERY_VALUE_HDCP_V2_0 = "HDCP-2.0";
+static const std::string QUERY_VALUE_HDCP_V2_1 = "HDCP-2.1";
+static const std::string QUERY_VALUE_HDCP_V2_2 = "HDCP-2.2";
+
+static const std::string ISO_BMFF_VIDEO_MIME_TYPE = "video/mp4";
+static const std::string ISO_BMFF_AUDIO_MIME_TYPE = "audio/mp4";
+static const std::string WEBM_VIDEO_MIME_TYPE = "video/webm";
+static const std::string WEBM_AUDIO_MIME_TYPE = "audio/webm";
+static const std::string CENC_INIT_DATA_FORMAT = "cenc";
+static const std::string HLS_INIT_DATA_FORMAT = "hls";
+static const std::string WEBM_INIT_DATA_FORMAT = "webm";
+
+static const std::string HLS_KEYFORMAT_ATTRIBUTE = "KEYFORMAT";
+static const std::string HLS_KEYFORMAT_VERSIONS_ATTRIBUTE = "KEYFORMATVERSIONS";
+static const std::string HLS_KEYFORMAT_VERSION_VALUE_1 = "1";
+static const std::string HLS_METHOD_ATTRIBUTE = "METHOD";
+static const std::string HLS_METHOD_AES_128 = "AES-128";
+static const std::string HLS_METHOD_NONE = "NONE";
+static const std::string HLS_METHOD_SAMPLE_AES = "SAMPLE-AES";
+static const std::string HLS_IV_ATTRIBUTE = "IV";
+static const std::string HLS_URI_ATTRIBUTE = "URI";
+
+static const char EMPTY_ORIGIN[] = "";
+static const char EMPTY_SPOID[] = "";
+
+//Policy engine HDCP enforcement
+static const uint32_t HDCP_UNSPECIFIED_VIDEO_RESOLUTION = 0;
+static const int64_t HDCP_DEVICE_CHECK_INTERVAL = 10;
+static const char EMPTY_APP_PACKAGE_NAME[] = "";
+}  // namespace wvcdm
+
+#endif  // WVCDM_CORE_WV_CDM_CONSTANTS_H_
diff --git a/widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/core/include/wv_cdm_event_listener.h b/widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/core/include/wv_cdm_event_listener.h
new file mode 100644
index 0000000..87fae5d
--- /dev/null
+++ b/widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/core/include/wv_cdm_event_listener.h
@@ -0,0 +1,31 @@
+// Copyright 2012 Google Inc. All Rights Reserved.
+
+#ifndef WVCDM_CORE_WV_CDM_EVENT_LISTENER_H_
+#define WVCDM_CORE_WV_CDM_EVENT_LISTENER_H_
+
+#include "wv_cdm_types.h"
+
+namespace wvcdm {
+
+// Listener for events from the Content Decryption Module.
+class WvCdmEventListener {
+ public:
+  WvCdmEventListener() {}
+  virtual ~WvCdmEventListener() {}
+
+  virtual void OnSessionRenewalNeeded(const CdmSessionId& session_id) = 0;
+  virtual void OnSessionKeysChange(const CdmSessionId& session_id,
+                                   const CdmKeyStatusMap& keys_status,
+                                   bool has_new_usable_key) = 0;
+  // Note that a |new_expiry_time_seconds| of 0 represents never expired
+  // license.
+  virtual void OnExpirationUpdate(const CdmSessionId& session_id,
+                                  int64_t new_expiry_time_seconds) = 0;
+
+ private:
+  CORE_DISALLOW_COPY_AND_ASSIGN(WvCdmEventListener);
+};
+
+}  // namespace wvcdm
+
+#endif  // WVCDM_CORE_WV_CDM_EVENT_LISTENER_H_
diff --git a/widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/core/include/wv_cdm_types.h b/widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/core/include/wv_cdm_types.h
new file mode 100644
index 0000000..4ae91b9
--- /dev/null
+++ b/widevine-bin/prebuilt-v14/arm.aapcs-linux.hard/include/core/include/wv_cdm_types.h
@@ -0,0 +1,542 @@
+// Copyright 2013 Google Inc. All Rights Reserved.
+
+#ifndef WVCDM_CORE_WV_CDM_TYPES_H_
+#define WVCDM_CORE_WV_CDM_TYPES_H_
+
+#include <stdint.h>
+#include <map>
+#include <string>
+#include <vector>
+
+namespace wvcdm {
+
+typedef std::string CdmKeySystem;
+typedef std::string CdmInitData;
+typedef std::string CdmKeyMessage;
+typedef std::string CdmKeyResponse;
+typedef std::string KeyId;
+typedef std::string CdmSecureStopId;
+typedef std::string CdmSessionId;
+typedef std::string CdmKeySetId;
+typedef std::string RequestId;
+typedef uint32_t CryptoResult;
+typedef uint32_t CryptoSessionId;
+typedef std::map<std::string, std::string> CdmAppParameterMap;
+typedef std::map<std::string, std::string> CdmQueryMap;
+typedef std::vector<std::string> CdmUsageInfo;
+typedef std::string CdmUsageInfoReleaseMessage;
+typedef std::string CdmProvisioningRequest;
+typedef std::string CdmProvisioningResponse;
+typedef std::string CdmUsageTableHeader;
+typedef std::string CdmUsageEntry;
+
+enum CdmKeyRequestType {
+  kKeyRequestTypeUnknown,
+  kKeyRequestTypeInitial,
+  kKeyRequestTypeRenewal,
+  kKeyRequestTypeRelease,
+};
+
+enum CdmResponseType {
+  NO_ERROR, /* 0 */
+  UNKNOWN_ERROR,
+  KEY_ADDED,
+  KEY_ERROR,
+  KEY_MESSAGE,
+  NEED_KEY, /* 5 */
+  KEY_CANCELED,
+  NEED_PROVISIONING,
+  DEVICE_REVOKED,
+  INSUFFICIENT_CRYPTO_RESOURCES,
+  ADD_KEY_ERROR, /* 10 */
+  CERT_PROVISIONING_GET_KEYBOX_ERROR_1,
+  CERT_PROVISIONING_GET_KEYBOX_ERROR_2,
+  CERT_PROVISIONING_INVALID_CERT_TYPE,
+  CERT_PROVISIONING_REQUEST_ERROR_1,
+  CERT_PROVISIONING_NONCE_GENERATION_ERROR, /* 15 */
+  CERT_PROVISIONING_REQUEST_ERROR_3,
+  CERT_PROVISIONING_REQUEST_ERROR_4,
+  CERT_PROVISIONING_RESPONSE_ERROR_1,
+  CERT_PROVISIONING_RESPONSE_ERROR_2,
+  CERT_PROVISIONING_RESPONSE_ERROR_3, /* 20 */
+  CERT_PROVISIONING_RESPONSE_ERROR_4,
+  CERT_PROVISIONING_RESPONSE_ERROR_5,
+  CERT_PROVISIONING_RESPONSE_ERROR_6,
+  CERT_PROVISIONING_RESPONSE_ERROR_7,
+  CERT_PROVISIONING_RESPONSE_ERROR_8, /* 25 */
+  CRYPTO_SESSION_OPEN_ERROR_1,
+  CRYPTO_SESSION_OPEN_ERROR_2,
+  CRYPTO_SESSION_OPEN_ERROR_3,
+  CRYPTO_SESSION_OPEN_ERROR_4,
+  CRYPTO_SESSION_OPEN_ERROR_5, /* 30 */
+  DECRYPT_NOT_READY,
+  DEVICE_CERTIFICATE_ERROR_1,
+  DEVICE_CERTIFICATE_ERROR_2,
+  DEVICE_CERTIFICATE_ERROR_3,
+  DEVICE_CERTIFICATE_ERROR_4, /* 35 */
+  EMPTY_KEY_DATA_1,
+  EMPTY_KEY_DATA_2,
+  EMPTY_KEYSET_ID,
+  EMPTY_KEYSET_ID_ENG_1,
+  EMPTY_KEYSET_ID_ENG_2, /* 40 */
+  EMPTY_KEYSET_ID_ENG_3,
+  EMPTY_KEYSET_ID_ENG_4,
+  EMPTY_LICENSE_RENEWAL,
+  EMPTY_LICENSE_RESPONSE_1,
+  EMPTY_LICENSE_RESPONSE_2, /* 45 */
+  EMPTY_PROVISIONING_CERTIFICATE_1,
+  EMPTY_PROVISIONING_RESPONSE,
+  EMPTY_SESSION_ID,
+  GENERATE_DERIVED_KEYS_ERROR,
+  LICENSE_RENEWAL_NONCE_GENERATION_ERROR, /* 50 */
+  GENERATE_USAGE_REPORT_ERROR,
+  GET_LICENSE_ERROR,
+  GET_RELEASED_LICENSE_ERROR,
+  GET_USAGE_INFO_ERROR_1,
+  GET_USAGE_INFO_ERROR_2, /* 55 */
+  GET_USAGE_INFO_ERROR_3,
+  GET_USAGE_INFO_ERROR_4,
+  INIT_DATA_NOT_FOUND,
+  INVALID_CRYPTO_SESSION_1,
+  INVALID_CRYPTO_SESSION_2, /* 60 */
+  INVALID_CRYPTO_SESSION_3,
+  INVALID_CRYPTO_SESSION_4,
+  INVALID_CRYPTO_SESSION_5,
+  INVALID_DECRYPT_PARAMETERS_ENG_1,
+  INVALID_DECRYPT_PARAMETERS_ENG_2, /* 65 */
+  INVALID_DECRYPT_PARAMETERS_ENG_3,
+  INVALID_DECRYPT_PARAMETERS_ENG_4,
+  INVALID_DEVICE_CERTIFICATE_TYPE,
+  INVALID_KEY_SYSTEM,
+  INVALID_LICENSE_RESPONSE, /* 70 */
+  INVALID_LICENSE_TYPE,
+  INVALID_PARAMETERS_ENG_1,
+  INVALID_PARAMETERS_ENG_2,
+  INVALID_PARAMETERS_ENG_3,
+  INVALID_PARAMETERS_ENG_4, /* 75 */
+  INVALID_PARAMETERS_LIC_1,
+  INVALID_PARAMETERS_LIC_2,
+  INVALID_PROVISIONING_PARAMETERS_1,
+  INVALID_PROVISIONING_PARAMETERS_2,
+  INVALID_PROVISIONING_REQUEST_PARAM_1, /* 80 */
+  INVALID_PROVISIONING_REQUEST_PARAM_2,
+  INVALID_QUERY_KEY,
+  INVALID_SESSION_ID,
+  KEY_REQUEST_ERROR_1,
+  UNUSED_1,  /* previously KEY_REQUEST_ERROR_2 */ /* 85 */
+  KEY_SIZE_ERROR,
+  KEYSET_ID_NOT_FOUND_1,
+  KEYSET_ID_NOT_FOUND_2,
+  KEYSET_ID_NOT_FOUND_3,
+  LICENSE_ID_NOT_FOUND, /* 90 */
+  LICENSE_PARSER_INIT_ERROR,
+  LICENSE_PARSER_NOT_INITIALIZED_1,
+  LICENSE_PARSER_NOT_INITIALIZED_2,
+  LICENSE_PARSER_NOT_INITIALIZED_3,
+  LICENSE_RESPONSE_NOT_SIGNED, /* 95 */
+  LICENSE_RESPONSE_PARSE_ERROR_1,
+  LICENSE_RESPONSE_PARSE_ERROR_2,
+  LICENSE_RESPONSE_PARSE_ERROR_3,
+  LOAD_KEY_ERROR,
+  NO_CONTENT_KEY, /* 100 */
+  REFRESH_KEYS_ERROR,
+  RELEASE_ALL_USAGE_INFO_ERROR_1,
+  RELEASE_ALL_USAGE_INFO_ERROR_2,
+  RELEASE_KEY_ERROR,
+  RELEASE_KEY_REQUEST_ERROR, /* 105 */
+  RELEASE_LICENSE_ERROR_1,
+  RELEASE_LICENSE_ERROR_2,
+  RELEASE_USAGE_INFO_ERROR,
+  RENEW_KEY_ERROR_1,
+  RENEW_KEY_ERROR_2, /* 110 */
+  LICENSE_RENEWAL_SIGNING_ERROR,
+  UNUSED_4,  /* previously RESTORE_OFFLINE_LICENSE_ERROR_1 */
+  RESTORE_OFFLINE_LICENSE_ERROR_2,
+  SESSION_INIT_ERROR_1,
+  SESSION_INIT_ERROR_2, /* 115 */
+  UNUSED_5,  /* previously SESSION_INIT_GET_KEYBOX_ERROR */
+  SESSION_NOT_FOUND_1,
+  SESSION_NOT_FOUND_2,
+  SESSION_NOT_FOUND_3,
+  SESSION_NOT_FOUND_4, /* 120 */
+  SESSION_NOT_FOUND_5,
+  SESSION_NOT_FOUND_6,
+  SESSION_NOT_FOUND_7,
+  SESSION_NOT_FOUND_8,
+  SESSION_NOT_FOUND_9, /* 125 */
+  SESSION_NOT_FOUND_10,
+  SESSION_NOT_FOUND_FOR_DECRYPT,
+  SESSION_KEYS_NOT_FOUND,
+  SIGNATURE_NOT_FOUND,
+  STORE_LICENSE_ERROR_1, /* 130 */
+  STORE_LICENSE_ERROR_2,
+  UNUSED_6,  /* previously STORE_LICENSE_ERROR_3 */
+  STORE_USAGE_INFO_ERROR,
+  UNPROVISION_ERROR_1,
+  UNPROVISION_ERROR_2, /* 135 */
+  UNPROVISION_ERROR_3,
+  UNPROVISION_ERROR_4,
+  UNSUPPORTED_INIT_DATA,
+  USAGE_INFO_NOT_FOUND,
+  UNUSED_8, /* 140 */
+  /* UNUSED_8 previously LICENSE_RENEWAL_SERVICE_CERTIFICATE_GENERATION_ERROR */
+  PARSE_SERVICE_CERTIFICATE_ERROR,
+  UNUSED_10, /* previously SERVICE_CERTIFICATE_TYPE_ERROR */
+  CLIENT_ID_GENERATE_RANDOM_ERROR,
+  CLIENT_ID_AES_INIT_ERROR,
+  CLIENT_ID_AES_ENCRYPT_ERROR, /* 145 */
+  CLIENT_ID_RSA_INIT_ERROR,
+  CLIENT_ID_RSA_ENCRYPT_ERROR,
+  INVALID_QUERY_STATUS,
+  UNUSED_3,  /* previously EMPTY_PROVISIONING_CERTIFICATE_2 on mnc-dev, */
+             /* DUPLICATE_SESSION_ID_SPECIFIED on master */
+  LICENSE_PARSER_NOT_INITIALIZED_4, /* 150 */
+  INVALID_PARAMETERS_LIC_3,
+  INVALID_PARAMETERS_LIC_4,
+  UNUSED_2,  /* previously INVALID_PARAMETERS_LIC_5 */
+  INVALID_PARAMETERS_LIC_6,
+  INVALID_PARAMETERS_LIC_7, /* 155 */
+  LICENSE_REQUEST_SERVICE_CERTIFICATE_GENERATION_ERROR,
+  CENC_INIT_DATA_UNAVAILABLE,
+  PREPARE_CENC_CONTENT_ID_FAILED,
+  WEBM_INIT_DATA_UNAVAILABLE,
+  PREPARE_WEBM_CONTENT_ID_FAILED, /* 160 */
+  UNSUPPORTED_INIT_DATA_FORMAT,
+  LICENSE_REQUEST_NONCE_GENERATION_ERROR,
+  LICENSE_REQUEST_SIGNING_ERROR,
+  EMPTY_LICENSE_REQUEST,
+  SECURE_BUFFER_REQUIRED, /* 165 */
+  DUPLICATE_SESSION_ID_SPECIFIED,
+  LICENSE_RENEWAL_PROHIBITED,
+  EMPTY_PROVISIONING_CERTIFICATE_2,
+  OFFLINE_LICENSE_PROHIBITED,
+  STORAGE_PROHIBITED, /* 170 */
+  EMPTY_KEYSET_ID_ENG_5,
+  SESSION_NOT_FOUND_11,
+  LOAD_USAGE_INFO_FILE_ERROR,
+  LOAD_USAGE_INFO_MISSING,
+  SESSION_FILE_HANDLE_INIT_ERROR, /* 175 */
+  INCORRECT_CRYPTO_MODE,
+  INVALID_PARAMETERS_ENG_5,
+  DECRYPT_ERROR,
+  INSUFFICIENT_OUTPUT_PROTECTION,
+  SESSION_NOT_FOUND_12, /* 180 */
+  KEY_NOT_FOUND_1,
+  KEY_NOT_FOUND_2,
+  KEY_CONFLICT_1,
+  INVALID_PARAMETERS_ENG_6,
+  INVALID_PARAMETERS_ENG_7, /* 185 */
+  INVALID_PARAMETERS_ENG_8,
+  INVALID_PARAMETERS_ENG_9,
+  INVALID_PARAMETERS_ENG_10,
+  INVALID_PARAMETERS_ENG_11,
+  INVALID_PARAMETERS_ENG_12, /* 190 */
+  SESSION_NOT_FOUND_13,
+  SESSION_NOT_FOUND_14,
+  SESSION_NOT_FOUND_15,
+  SESSION_NOT_FOUND_16,
+  KEY_NOT_FOUND_3, /* 195 */
+  KEY_NOT_FOUND_4,
+  KEY_NOT_FOUND_5,
+  KEY_NOT_FOUND_6,
+  INVALID_SESSION_1,
+  NO_DEVICE_KEY_1, /* 200 */
+  NO_CONTENT_KEY_2,
+  INSUFFICIENT_CRYPTO_RESOURCES_2,
+  INVALID_PARAMETERS_ENG_13,
+  INVALID_PARAMETERS_ENG_14,
+  INVALID_PARAMETERS_ENG_15, /* 205 */
+  INVALID_PARAMETERS_ENG_16,
+  UNUSED_7, /* previously DEVICE_CERTIFICATE_ERROR_5 */
+  CERT_PROVISIONING_CLIENT_TOKEN_ERROR_1,
+  CERT_PROVISIONING_CLIENT_TOKEN_ERROR_2,
+  LICENSING_CLIENT_TOKEN_ERROR_1, /* 210 */
+  ANALOG_OUTPUT_ERROR,
+  UNKNOWN_SELECT_KEY_ERROR_1,
+  UNKNOWN_SELECT_KEY_ERROR_2,
+  CREATE_USAGE_TABLE_ERROR,
+  LOAD_USAGE_HEADER_GENERATION_SKEW, /* 215 */
+  LOAD_USAGE_HEADER_SIGNATURE_FAILURE,
+  LOAD_USAGE_HEADER_BAD_MAGIC,
+  LOAD_USAGE_HEADER_UNKNOWN_ERROR,
+  INVALID_PARAMETERS_ENG_17,
+  INVALID_PARAMETERS_ENG_18, /* 220 */
+  INSUFFICIENT_CRYPTO_RESOURCES_3,
+  CREATE_USAGE_ENTRY_UNKNOWN_ERROR,
+  LOAD_USAGE_ENTRY_GENERATION_SKEW,
+  LOAD_USAGE_ENTRY_SIGNATURE_FAILURE,
+  LOAD_USAGE_ENTRY_UNKNOWN_ERROR, /* 225 */
+  INVALID_PARAMETERS_ENG_19,
+  INVALID_PARAMETERS_ENG_20,
+  UPDATE_USAGE_ENTRY_UNKNOWN_ERROR,
+  INVALID_PARAMETERS_ENG_21,
+  SHRINK_USAGE_TABLER_HEADER_UNKNOWN_ERROR, /* 230 */
+  MOVE_USAGE_ENTRY_UNKNOWN_ERROR,
+  COPY_OLD_USAGE_ENTRY_UNKNOWN_ERROR,
+  INVALID_PARAMETERS_ENG_22,
+  LIST_LICENSE_ERROR_1,
+  LIST_LICENSE_ERROR_2, /* 235 */
+  INVALID_PARAMETERS_ENG_23,
+  USAGE_INFORMATION_SUPPORT_FAILED,
+  USAGE_SUPPORT_GET_API_FAILED,
+  UNEXPECTED_EMPTY_USAGE_ENTRY,
+  INVALID_USAGE_ENTRY_NUMBER_MODIFICATION, /* 240 */
+  USAGE_INVALID_NEW_ENTRY,
+  USAGE_INVALID_PARAMETERS_1,
+  USAGE_GET_ENTRY_RETRIEVE_LICENSE_FAILED,
+  USAGE_GET_ENTRY_RETRIEVE_USAGE_INFO_FAILED,
+  USAGE_GET_ENTRY_RETRIEVE_INVALID_STORAGE_TYPE, /* 245 */
+  USAGE_ENTRY_NUMBER_MISMATCH,
+  USAGE_STORE_LICENSE_FAILED,
+  USAGE_STORE_USAGE_INFO_FAILED,
+  USAGE_INVALID_LOAD_ENTRY,
+  RELEASE_ALL_USAGE_INFO_ERROR_4, /* 250 */
+  RELEASE_ALL_USAGE_INFO_ERROR_5,
+  RELEASE_USAGE_INFO_FAILED,
+  INCORRECT_USAGE_SUPPORT_TYPE_1,
+  INCORRECT_USAGE_SUPPORT_TYPE_2,
+  KEY_PROHIBITED_FOR_SECURITY_LEVEL, /* 255 */
+  KEY_NOT_FOUND_IN_SESSION,
+  NO_USAGE_ENTRIES,
+  LIST_USAGE_ERROR_1,
+  LIST_USAGE_ERROR_2,
+  DELETE_USAGE_ERROR_1, /* 260 */
+  DELETE_USAGE_ERROR_2,
+  DELETE_USAGE_ERROR_3,
+  PRIVACY_MODE_ERROR_1,
+  PRIVACY_MODE_ERROR_2,
+  PRIVACY_MODE_ERROR_3, /* 265 */
+  EMPTY_RESPONSE_ERROR_1,
+  INVALID_PARAMETERS_ENG_24,
+  PARSE_RESPONSE_ERROR_1,
+  PARSE_RESPONSE_ERROR_2,
+  PARSE_RESPONSE_ERROR_3, /* 270 */
+  PARSE_RESPONSE_ERROR_4,
+  USAGE_STORE_ENTRY_RETRIEVE_LICENSE_FAILED,
+  USAGE_STORE_ENTRY_RETRIEVE_USAGE_INFO_FAILED,
+  USAGE_STORE_ENTRY_RETRIEVE_INVALID_STORAGE_TYPE,
+  RELEASE_ALL_USAGE_INFO_ERROR_6, /* 275 */
+  RELEASE_ALL_USAGE_INFO_ERROR_7,
+  LICENSE_REQUEST_INVALID_SUBLICENSE,
+};
+
+enum CdmKeyStatus {
+  kKeyStatusKeyUnknown,
+  kKeyStatusUsable,
+  kKeyStatusExpired,
+  kKeyStatusOutputNotAllowed,
+  kKeyStatusPending,
+  kKeyStatusInternalError,
+};
+typedef std::map<KeyId, CdmKeyStatus> CdmKeyStatusMap;
+
+#define CORE_DISALLOW_COPY_AND_ASSIGN(TypeName) \
+  TypeName(const TypeName&);                    \
+  void operator=(const TypeName&)
+
+enum CdmLicenseType {
+  kLicenseTypeOffline,
+  kLicenseTypeStreaming,
+  kLicenseTypeRelease,
+  // Like Streaming, but stricter.  Does not permit storage of any kind.
+  // Named after the 'temporary' session type in EME, which has this behavior.
+  kLicenseTypeTemporary,
+  kLicenseTypeSubSession
+};
+
+enum SecurityLevel {
+  kLevelDefault,
+  kLevel3
+};
+
+enum CdmSecurityLevel {
+  kSecurityLevelUninitialized,
+  kSecurityLevelL1,
+  kSecurityLevelL2,
+  kSecurityLevelL3,
+  kSecurityLevelUnknown
+};
+
+enum CdmCertificateType {
+  kCertificateWidevine,
+  kCertificateX509,
+};
+
+enum CdmHlsMethod {
+  kHlsMethodNone,
+  kHlsMethodAes128,
+  kHlsMethodSampleAes,
+};
+
+enum CdmCipherMode {
+  kCipherModeCtr,
+  kCipherModeCbc,
+};
+
+enum CdmEncryptionAlgorithm {
+  kEncryptionAlgorithmUnknown,
+  kEncryptionAlgorithmAesCbc128
+};
+
+enum CdmSigningAlgorithm {
+  kSigningAlgorithmUnknown,
+  kSigningAlgorithmHmacSha256
+};
+
+enum CdmClientTokenType {
+  kClientTokenKeybox,
+  kClientTokenDrmCert,
+  kClientTokenOemCert
+};
+
+// kNonSecureUsageSupport - TEE does not provide any support for usage
+//     information.
+// kUsageTableSupport - TEE persists usage information securely in a fixed
+//     size table, commonly 50 entries. (OEMCrypto v9+)
+// kUsageEntrySupport - usage information (table headers and entries) are
+//     persisted in non-secure storage but are loaded and unloaded from
+//     the TEE during use (OEMCrypto v13+)
+// kUnknownUsageSupport - usage support type is uninitialized or unavailable
+enum CdmUsageSupportType {
+  kNonSecureUsageSupport,
+  kUsageTableSupport,
+  kUsageEntrySupport,
+  kUnknownUsageSupport,
+};
+
+enum CdmUsageEntryStorageType {
+  kStorageLicense,
+  kStorageUsageInfo,
+  kStorageTypeUnknown,
+};
+
+struct CdmUsageEntryInfo {
+  CdmUsageEntryStorageType storage_type;
+  CdmKeySetId key_set_id;
+  std::string usage_info_file_name;
+  bool operator==(const CdmUsageEntryInfo& other) const {
+      return storage_type == other.storage_type &&
+          key_set_id == other.key_set_id &&
+          (storage_type != kStorageUsageInfo ||
+           usage_info_file_name == other.usage_info_file_name);
+  }
+};
+
+class CdmKeyAllowedUsage {
+ public:
+  CdmKeyAllowedUsage() {
+    Clear();
+  }
+
+  bool Valid() const { return valid_; }
+  void SetValid() { valid_ = true; }
+
+  void Clear() {
+    decrypt_to_clear_buffer = false;
+    decrypt_to_secure_buffer = false;
+    generic_encrypt = false;
+    generic_decrypt = false;
+    generic_sign = false;
+    generic_verify = false;
+    valid_ = false;
+  }
+
+  bool Equals(const CdmKeyAllowedUsage& other) {
+    if (!valid_ || !other.Valid() ||
+        decrypt_to_clear_buffer != other.decrypt_to_clear_buffer ||
+        decrypt_to_secure_buffer != other.decrypt_to_secure_buffer ||
+        generic_encrypt != other.generic_encrypt ||
+        generic_decrypt != other.generic_decrypt ||
+        generic_sign != other.generic_sign ||
+        generic_verify != other.generic_verify) {
+      return false;
+    }
+    return true;
+  }
+
+  bool decrypt_to_clear_buffer;
+  bool decrypt_to_secure_buffer;
+  bool generic_encrypt;
+  bool generic_decrypt;
+  bool generic_sign;
+  bool generic_verify;
+
+ private:
+  bool valid_;
+};
+
+// For schemes that do not use pattern encryption (cenc and cbc1), encrypt
+// and skip should be set to 0. For those that do (cens and cbcs), it is
+// recommended that encrypt+skip bytes sum to 10 and for cbcs that a 1:9
+// encrypt:skip ratio be used. See ISO/IEC DIS 23001-7, section 10.4.2 for
+// more information.
+struct CdmCencPatternEncryptionDescriptor {
+  size_t encrypt_blocks;  // number of 16 byte blocks to decrypt
+  size_t skip_blocks;     // number of 16 byte blocks to leave in clear
+  CdmCencPatternEncryptionDescriptor()
+      : encrypt_blocks(0),
+        skip_blocks(0) {}
+};
+
+struct CdmDecryptionParameters {
+  bool is_encrypted;
+  bool is_secure;
+  CdmCipherMode cipher_mode;
+  const KeyId* key_id;
+  const uint8_t* encrypt_buffer;
+  size_t encrypt_length;
+  const std::vector<uint8_t>* iv;
+  size_t block_offset;
+  void* decrypt_buffer;
+  size_t decrypt_buffer_length;
+  size_t decrypt_buffer_offset;
+  uint8_t subsample_flags;
+  bool is_video;
+  CdmCencPatternEncryptionDescriptor pattern_descriptor;
+  CdmDecryptionParameters()
+      : is_encrypted(true),
+        is_secure(true),
+        cipher_mode(kCipherModeCtr),
+        key_id(NULL),
+        encrypt_buffer(NULL),
+        encrypt_length(0),
+        iv(NULL),
+        block_offset(0),
+        decrypt_buffer(NULL),
+        decrypt_buffer_length(0),
+        decrypt_buffer_offset(0),
+        subsample_flags(0),
+        is_video(true) {}
+  CdmDecryptionParameters(const KeyId* key, const uint8_t* encrypted_buffer,
+                          size_t encrypted_length,
+                          const std::vector<uint8_t>* initialization_vector,
+                          size_t offset, void* decrypted_buffer)
+      : is_encrypted(true),
+        is_secure(true),
+        cipher_mode(kCipherModeCtr),
+        key_id(key),
+        encrypt_buffer(encrypted_buffer),
+        encrypt_length(encrypted_length),
+        iv(initialization_vector),
+        block_offset(offset),
+        decrypt_buffer(decrypted_buffer),
+        decrypt_buffer_length(encrypted_length),
+        decrypt_buffer_offset(0),
+        subsample_flags(0),
+        is_video(true) {}
+};
+
+struct CdmKeyRequest {
+  CdmKeyMessage message;
+  CdmKeyRequestType type;
+  std::string url;
+};
+
+// forward class references
+class KeyMessage;
+class Request;
+class Key;
+
+}  // namespace wvcdm
+
+#endif  // WVCDM_CORE_WV_CDM_TYPES_H_
-- 
2.24.1

