From 2029ceb15dffad44d61bb6b2a8ae823d16cec752 Mon Sep 17 00:00:00 2001
From: Tao Guo <tao.guo@amlogic.com>
Date: Tue, 20 Apr 2021 18:27:27 +0800
Subject: [PATCH 2/2] playready: add headers for build [1/1]

PD#SWPL-46651

Change-Id: Ia302a7396bd17e51331b0ddf781da28aee393144
Signed-off-by: Tao Guo <tao.guo@amlogic.com>
---
 prebuilt-v4.4/noarch/include/drmactivation.h  |   24 +
 .../noarch/include/drmactivationconstants.h   |   44 +
 .../noarch/include/drmactivationimp.h         |  240 +
 prebuilt-v4.4/noarch/include/drmallstrings.h  |   39 +
 .../noarch/include/drmantirollbackclock.h     |   76 +
 .../include/drmantirollbackclockconstants.h   |   21 +
 prebuilt-v4.4/noarch/include/drmbase64.h      |   83 +
 .../noarch/include/drmbcertcachetypes.h       |   51 +
 .../noarch/include/drmbcertconstants.h        |  324 +
 .../noarch/include/drmbcertformat_generated.h |  314 +
 .../noarch/include/drmbcertformatbuilder.h    |  298 +
 .../noarch/include/drmbcertformatparser.h     |  256 +
 .../include/drmbcertformatparsercache.h       |   33 +
 prebuilt-v4.4/noarch/include/drmbcrl.h        |   69 +
 prebuilt-v4.4/noarch/include/drmbcrltypes.h   |   53 +
 .../noarch/include/drmblackboxtypes.h         |   84 +
 prebuilt-v4.4/noarch/include/drmblobcache.h   |   40 +
 prebuilt-v4.4/noarch/include/drmbuild_linux.h |  118 +
 prebuilt-v4.4/noarch/include/drmbuild_oem.h   |  118 +
 .../noarch/include/drmbuild_oemplayonly.h     |  125 +
 .../noarch/include/drmbuild_oemtee.h          |  118 +
 .../noarch/include/drmbuild_oemteeplayonly.h  |  118 +
 prebuilt-v4.4/noarch/include/drmbytemanip.h   |   33 +
 prebuilt-v4.4/noarch/include/drmcallbacks.h   |   57 +
 .../noarch/include/drmcallbacktypes.h         |  128 +
 prebuilt-v4.4/noarch/include/drmcdmi.h        |  159 +
 prebuilt-v4.4/noarch/include/drmcdmiimpl.h    |   47 +
 prebuilt-v4.4/noarch/include/drmcdmishared.h  |   63 +
 prebuilt-v4.4/noarch/include/drmcdmitypes.h   |  193 +
 prebuilt-v4.4/noarch/include/drmchain.h       |   54 +
 prebuilt-v4.4/noarch/include/drmchaintypes.h  |   94 +
 prebuilt-v4.4/noarch/include/drmcleanstore.h  |   33 +
 prebuilt-v4.4/noarch/include/drmcmdlnpars.h   |   49 +
 prebuilt-v4.4/noarch/include/drmcompiler.h    |  864 +++
 prebuilt-v4.4/noarch/include/drmconstants.h   |  263 +
 .../noarch/include/drmcontextsizes.h          |  174 +
 prebuilt-v4.4/noarch/include/drmcontract.h    |  110 +
 prebuilt-v4.4/noarch/include/drmcrt.h         |  180 +
 prebuilt-v4.4/noarch/include/drmdatastore.h   |  206 +
 .../noarch/include/drmdatastorecommon.h       |   65 +
 .../noarch/include/drmdatastoretypes.h        |  285 +
 prebuilt-v4.4/noarch/include/drmdebug.h       |  109 +
 prebuilt-v4.4/noarch/include/drmdebug.inc     |   57 +
 prebuilt-v4.4/noarch/include/drmderivedkey.h  |  125 +
 .../noarch/include/drmdomainconstants.h       |  142 +
 prebuilt-v4.4/noarch/include/drmdomainimp.h   |  169 +
 .../noarch/include/drmdomainkeyxmrparser.h    |   43 +
 .../include/drmdomainkeyxmrparsertypes.h      |   85 +
 prebuilt-v4.4/noarch/include/drmdomainstore.h |  108 +
 .../noarch/include/drmdomainstoretypes.h      |   70 +
 .../noarch/include/drmembeddedstore_impl.h    |   94 +
 prebuilt-v4.4/noarch/include/drmembedding.h   |   34 +
 prebuilt-v4.4/noarch/include/drmenvelope.h    |   54 +
 prebuilt-v4.4/noarch/include/drmerr.h         |  234 +
 prebuilt-v4.4/noarch/include/drmerror.h       |   45 +
 prebuilt-v4.4/noarch/include/drmest.h         |  195 +
 prebuilt-v4.4/noarch/include/drmfeatures.h    |  325 +
 prebuilt-v4.4/noarch/include/drmh264.h        |  105 +
 prebuilt-v4.4/noarch/include/drmhashcache.h   |   60 +
 .../noarch/include/drmhdrbuilderconstants.h   |   22 +
 prebuilt-v4.4/noarch/include/drmhds.h         |  327 +
 prebuilt-v4.4/noarch/include/drmhds_impl.h    |  412 ++
 .../noarch/include/drmhdsblockheadercache.h   |   37 +
 .../noarch/include/drmheaderparser.h          |   75 +
 .../noarch/include/drmheaderparserconstants.h |   21 +
 prebuilt-v4.4/noarch/include/drmint64.h       |  223 +
 .../noarch/include/drmkeyfilecerttypes.h      |   27 +
 .../noarch/include/drmkeygenerator.h          |   69 +
 prebuilt-v4.4/noarch/include/drmlastinclude.h |   19 +
 .../include/drmlegacyxmlcertrevocation.h      |   64 +
 .../noarch/include/drmlegacyxmlcertrsakeys.h  |   56 +
 prebuilt-v4.4/noarch/include/drmlicacqv3.h    |  350 +
 .../noarch/include/drmlicacqv3constants.h     |  212 +
 prebuilt-v4.4/noarch/include/drmlicense.h     |   41 +
 prebuilt-v4.4/noarch/include/drmliceval.h     |   62 +
 .../noarch/include/drmlicevaltypes.h          |  150 +
 prebuilt-v4.4/noarch/include/drmlicgen.h      |   49 +
 prebuilt-v4.4/noarch/include/drmlicgentypes.h |  131 +
 prebuilt-v4.4/noarch/include/drmlicreason.h   |   45 +
 prebuilt-v4.4/noarch/include/drmlicstore.h    |  281 +
 prebuilt-v4.4/noarch/include/drmmanager.h     |  643 ++
 prebuilt-v4.4/noarch/include/drmmanagerimpl.h |   32 +
 .../noarch/include/drmmanagertypes.h          |  252 +
 prebuilt-v4.4/noarch/include/drmmathsafe.h    |  471 ++
 .../noarch/include/drmmathsafe_impl.h         | 1049 +++
 prebuilt-v4.4/noarch/include/drmmeterapi.h    |   23 +
 .../noarch/include/drmmetercertstore.h        |  228 +
 .../noarch/include/drmmeterconstants.h        |  144 +
 prebuilt-v4.4/noarch/include/drmmeterimp.h    |  217 +
 .../noarch/include/drmmodelrevocation.h       |   25 +
 .../noarch/include/drmmodulesupport.h         |  223 +
 prebuilt-v4.4/noarch/include/drmnamespace.h   |   73 +
 prebuilt-v4.4/noarch/include/drmnoncestore.h  |  128 +
 prebuilt-v4.4/noarch/include/drmnonceverify.h |   23 +
 .../noarch/include/drmoutputleveltypes.h      |  263 +
 prebuilt-v4.4/noarch/include/drmperformance.h |   58 +
 .../noarch/include/drmplayreadyobj.h          |  154 +
 .../noarch/include/drmplayreadyobjconstants.h |   31 +
 prebuilt-v4.4/noarch/include/drmpragmas.h     |  117 +
 prebuilt-v4.4/noarch/include/drmprofile.h     |  218 +
 .../noarch/include/drmprofileconstants.h      |  602 ++
 .../noarch/include/drmprofiletypes.h          |  202 +
 .../include/drmprovisioningformat_generated.h |  146 +
 .../noarch/include/drmremovaldatestore.h      |   67 +
 .../include/drmremovaldatestorecontext.h      |   58 +
 prebuilt-v4.4/noarch/include/drmresults.h     | 5837 +++++++++++++++++
 prebuilt-v4.4/noarch/include/drmrevocation.h  |  110 +
 .../noarch/include/drmrevocationconstants.h   |   26 +
 .../noarch/include/drmrevocationenum.h        |   27 +
 .../noarch/include/drmrevocationstore.h       |  114 +
 .../noarch/include/drmrevocationtypes.h       |  106 +
 .../noarch/include/drmrivcrlparser.h          |  100 +
 prebuilt-v4.4/noarch/include/drmsal.h         |  879 +++
 prebuilt-v4.4/noarch/include/drmsecurecore.h  |  121 +
 .../noarch/include/drmsecurecore_int.h        |   59 +
 .../noarch/include/drmsecurecore_notee.h      |   58 +
 .../noarch/include/drmsecurecore_tee.h        |   94 +
 .../noarch/include/drmsecurecore_template.h   |  517 ++
 .../noarch/include/drmsecurecoreconstants.h   |   24 +
 .../noarch/include/drmsecurecorefuncptrdefs.h |  147 +
 .../noarch/include/drmsecurecoretypes.h       |  106 +
 .../noarch/include/drmsecuredelete.h          |   68 +
 .../noarch/include/drmsecuredeleteconstants.h |   55 +
 prebuilt-v4.4/noarch/include/drmsecurestop.h  |  271 +
 .../noarch/include/drmsecurestopconstants.h   |   67 +
 .../noarch/include/drmsecurestopinternal.h    |   69 +
 .../noarch/include/drmsecurestoptypes.h       |   89 +
 prebuilt-v4.4/noarch/include/drmsecurestore.h |  177 +
 .../noarch/include/drmsecurestoretypes.h      |  140 +
 prebuilt-v4.4/noarch/include/drmsecuretime.h  |   42 +
 .../noarch/include/drmsecuretimeconstants.h   |   30 +
 .../noarch/include/drmsecuretimetypes.h       |   23 +
 .../noarch/include/drmsoapxmlconstants.h      |   71 +
 .../noarch/include/drmsoapxmlutility.h        |  158 +
 .../noarch/include/drmsstconstants.h          |   23 +
 prebuilt-v4.4/noarch/include/drmstkalloc.h    |   93 +
 .../noarch/include/drmstkalloctypes.h         |   30 +
 prebuilt-v4.4/noarch/include/drmstrsafe.h     |  106 +
 prebuilt-v4.4/noarch/include/drmtee.h         |  266 +
 prebuilt-v4.4/noarch/include/drmteebase.h     |  245 +
 prebuilt-v4.4/noarch/include/drmteeproxy.h    |  286 +
 .../include/drmteeproxyformat_generated.h     |  204 +
 .../noarch/include/drmteeproxystructured.h    |   50 +
 .../include/drmteeproxystructuredcommon.h     |  181 +
 .../include/drmteeproxystructureddefines.h    |  137 +
 .../noarch/include/drmteeproxystubcommon.h    |  198 +
 prebuilt-v4.4/noarch/include/drmteestub.h     |   38 +
 prebuilt-v4.4/noarch/include/drmteetypes.h    |  634 ++
 .../noarch/include/drmtesturlhelper.h         |  252 +
 prebuilt-v4.4/noarch/include/drmtoken.h       |  139 +
 .../noarch/include/drmtoolsconstants.h        |  303 +
 prebuilt-v4.4/noarch/include/drmtrace.h       |  248 +
 prebuilt-v4.4/noarch/include/drmtypes.h       |  558 ++
 prebuilt-v4.4/noarch/include/drmutf.h         |  113 +
 prebuilt-v4.4/noarch/include/drmutftypes.h    |  323 +
 .../include/drmutilitiesgeneralconstants.h    |   38 +
 .../noarch/include/drmutilitieslite.h         |  218 +
 .../noarch/include/drmversionconstants.h      |   22 +
 prebuilt-v4.4/noarch/include/drmwindowsenv.h  |   51 +
 prebuilt-v4.4/noarch/include/drmxb.h          |  398 ++
 prebuilt-v4.4/noarch/include/drmxbbuilder.h   |  117 +
 prebuilt-v4.4/noarch/include/drmxbparser.h    |   52 +
 prebuilt-v4.4/noarch/include/drmxmlbuilder.h  |  254 +
 prebuilt-v4.4/noarch/include/drmxmlbuildera.h |  162 +
 .../noarch/include/drmxmlbuilderconstants.h   |   32 +
 prebuilt-v4.4/noarch/include/drmxmlhash.h     |   55 +
 prebuilt-v4.4/noarch/include/drmxmlparser.h   |  179 +
 .../noarch/include/drmxmlparserconstants.h    |   24 +
 prebuilt-v4.4/noarch/include/drmxmlsig.h      |  235 +
 .../noarch/include/drmxmlsigconstants.h       |  168 +
 .../noarch/include/drmxmrconstants.h          |  214 +
 .../noarch/include/drmxmrformat_generated.h   |  447 ++
 .../noarch/include/drmxmrformatbuilder.h      |  260 +
 .../noarch/include/drmxmrformatparser.h       |   32 +
 .../noarch/include/drmxmrformattypes.h        |  265 +
 .../include/etc/playready/bgroupcert.dat      |    0
 .../etc/playready/zgpriv_protected.dat        |    0
 .../noarch/include/oem/ansi/inc/oem.h         |   16 +
 .../noarch/include/oem/ansi/inc/oemplatform.h |   71 +
 .../noarch/include/oem/common/inc/bigdecls.h  |   59 +
 .../noarch/include/oem/common/inc/bigdefs.h   |  341 +
 .../noarch/include/oem/common/inc/bignum.h    |  684 ++
 .../noarch/include/oem/common/inc/bigpriv.h   |   72 +
 .../noarch/include/oem/common/inc/dblint.h    |  184 +
 .../noarch/include/oem/common/inc/ecurve.h    |  196 +
 .../noarch/include/oem/common/inc/field.h     |  293 +
 .../noarch/include/oem/common/inc/fieldpriv.h |   29 +
 .../noarch/include/oem/common/inc/mprand.h    |   61 +
 .../noarch/include/oem/common/inc/oemaes.h    |   43 +
 .../include/oem/common/inc/oemaescommon.h     |   67 +
 .../include/oem/common/inc/oemaesimpl.h       |   51 +
 .../noarch/include/oem/common/inc/oemaeskey.h |   39 +
 .../include/oem/common/inc/oemaeskeywrap.h    |   54 +
 .../oem/common/inc/oemaeskeywraptypes.h       |   75 +
 .../include/oem/common/inc/oemaesmulti.h      |   70 +
 .../noarch/include/oem/common/inc/oembroker.h |   88 +
 .../include/oem/common/inc/oembyteorder.h     |  371 ++
 .../include/oem/common/inc/oemcbctypes.h      |   31 +
 .../include/oem/common/inc/oemciphertypes.h   |   85 +
 .../include/oem/common/inc/oemcocktail.h      |   52 +
 .../include/oem/common/inc/oemcocktailtypes.h |   60 +
 .../noarch/include/oem/common/inc/oemcommon.h |  733 +++
 .../include/oem/common/inc/oemcommonmem.h     |  253 +
 .../include/oem/common/inc/oemcryptoctx.h     |   62 +
 .../noarch/include/oem/common/inc/oemdebug.h  |   58 +
 .../noarch/include/oem/common/inc/oemdes.h    |   87 +
 .../include/oem/common/inc/oemeccp256.h       |  264 +
 .../include/oem/common/inc/oemeccp256impl.h   |  151 +
 .../noarch/include/oem/common/inc/oemmd5.h    |   31 +
 .../include/oem/common/inc/oemmd5types.h      |   35 +
 .../include/oem/common/inc/oemprofile.h       |   24 +
 .../noarch/include/oem/common/inc/oemrc4.h    |   98 +
 .../include/oem/common/inc/oemrc4types.h      |   28 +
 .../noarch/include/oem/common/inc/oemrsa.h    |  247 +
 .../include/oem/common/inc/oemrsacommon.h     |   95 +
 .../include/oem/common/inc/oemrsaimpl.h       |  101 +
 .../include/oem/common/inc/oemrsaoaeppss.h    |  147 +
 .../oem/common/inc/oemrsaoaeppssimpl.h        |   79 +
 .../noarch/include/oem/common/inc/oemsha1.h   |  159 +
 .../noarch/include/oem/common/inc/oemsha256.h |   37 +
 .../include/oem/common/inc/oemsha256types.h   |   58 +
 .../noarch/include/oem/common/inc/oemtee.h    |  706 ++
 .../include/oem/common/inc/oemteeproxy.h      |   75 +
 .../include/oem/common/inc/oemteetypes.h      |  221 +
 .../noarch/include/oem/common/inc/oemtrace.h  |   69 +
 .../include/oem/common/inc/oemxmlhash.h       |  145 +
 prebuilt-v4.4/noarch/include/oemcompiler.h    |  238 +
 prebuilt-v4.4/noarch/include/oemresults.h     |   50 +
 prebuilt-v4.4/noarch/pkgconfig/playready.pc   |   10 +
 229 files changed, 40465 insertions(+)
 create mode 100644 prebuilt-v4.4/noarch/include/drmactivation.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmactivationconstants.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmactivationimp.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmallstrings.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmantirollbackclock.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmantirollbackclockconstants.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmbase64.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmbcertcachetypes.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmbcertconstants.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmbcertformat_generated.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmbcertformatbuilder.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmbcertformatparser.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmbcertformatparsercache.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmbcrl.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmbcrltypes.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmblackboxtypes.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmblobcache.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmbuild_linux.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmbuild_oem.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmbuild_oemplayonly.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmbuild_oemtee.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmbuild_oemteeplayonly.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmbytemanip.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmcallbacks.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmcallbacktypes.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmcdmi.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmcdmiimpl.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmcdmishared.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmcdmitypes.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmchain.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmchaintypes.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmcleanstore.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmcmdlnpars.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmcompiler.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmconstants.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmcontextsizes.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmcontract.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmcrt.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmdatastore.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmdatastorecommon.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmdatastoretypes.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmdebug.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmdebug.inc
 create mode 100644 prebuilt-v4.4/noarch/include/drmderivedkey.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmdomainconstants.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmdomainimp.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmdomainkeyxmrparser.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmdomainkeyxmrparsertypes.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmdomainstore.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmdomainstoretypes.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmembeddedstore_impl.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmembedding.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmenvelope.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmerr.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmerror.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmest.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmfeatures.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmh264.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmhashcache.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmhdrbuilderconstants.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmhds.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmhds_impl.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmhdsblockheadercache.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmheaderparser.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmheaderparserconstants.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmint64.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmkeyfilecerttypes.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmkeygenerator.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmlastinclude.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmlegacyxmlcertrevocation.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmlegacyxmlcertrsakeys.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmlicacqv3.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmlicacqv3constants.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmlicense.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmliceval.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmlicevaltypes.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmlicgen.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmlicgentypes.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmlicreason.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmlicstore.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmmanager.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmmanagerimpl.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmmanagertypes.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmmathsafe.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmmathsafe_impl.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmmeterapi.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmmetercertstore.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmmeterconstants.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmmeterimp.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmmodelrevocation.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmmodulesupport.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmnamespace.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmnoncestore.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmnonceverify.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmoutputleveltypes.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmperformance.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmplayreadyobj.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmplayreadyobjconstants.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmpragmas.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmprofile.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmprofileconstants.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmprofiletypes.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmprovisioningformat_generated.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmremovaldatestore.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmremovaldatestorecontext.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmresults.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmrevocation.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmrevocationconstants.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmrevocationenum.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmrevocationstore.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmrevocationtypes.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmrivcrlparser.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmsal.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmsecurecore.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmsecurecore_int.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmsecurecore_notee.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmsecurecore_tee.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmsecurecore_template.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmsecurecoreconstants.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmsecurecorefuncptrdefs.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmsecurecoretypes.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmsecuredelete.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmsecuredeleteconstants.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmsecurestop.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmsecurestopconstants.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmsecurestopinternal.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmsecurestoptypes.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmsecurestore.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmsecurestoretypes.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmsecuretime.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmsecuretimeconstants.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmsecuretimetypes.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmsoapxmlconstants.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmsoapxmlutility.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmsstconstants.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmstkalloc.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmstkalloctypes.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmstrsafe.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmtee.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmteebase.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmteeproxy.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmteeproxyformat_generated.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmteeproxystructured.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmteeproxystructuredcommon.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmteeproxystructureddefines.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmteeproxystubcommon.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmteestub.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmteetypes.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmtesturlhelper.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmtoken.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmtoolsconstants.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmtrace.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmtypes.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmutf.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmutftypes.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmutilitiesgeneralconstants.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmutilitieslite.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmversionconstants.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmwindowsenv.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmxb.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmxbbuilder.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmxbparser.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmxmlbuilder.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmxmlbuildera.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmxmlbuilderconstants.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmxmlhash.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmxmlparser.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmxmlparserconstants.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmxmlsig.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmxmlsigconstants.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmxmrconstants.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmxmrformat_generated.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmxmrformatbuilder.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmxmrformatparser.h
 create mode 100644 prebuilt-v4.4/noarch/include/drmxmrformattypes.h
 create mode 100644 prebuilt-v4.4/noarch/include/etc/playready/bgroupcert.dat
 create mode 100644 prebuilt-v4.4/noarch/include/etc/playready/zgpriv_protected.dat
 create mode 100644 prebuilt-v4.4/noarch/include/oem/ansi/inc/oem.h
 create mode 100644 prebuilt-v4.4/noarch/include/oem/ansi/inc/oemplatform.h
 create mode 100644 prebuilt-v4.4/noarch/include/oem/common/inc/bigdecls.h
 create mode 100644 prebuilt-v4.4/noarch/include/oem/common/inc/bigdefs.h
 create mode 100644 prebuilt-v4.4/noarch/include/oem/common/inc/bignum.h
 create mode 100644 prebuilt-v4.4/noarch/include/oem/common/inc/bigpriv.h
 create mode 100644 prebuilt-v4.4/noarch/include/oem/common/inc/dblint.h
 create mode 100644 prebuilt-v4.4/noarch/include/oem/common/inc/ecurve.h
 create mode 100644 prebuilt-v4.4/noarch/include/oem/common/inc/field.h
 create mode 100644 prebuilt-v4.4/noarch/include/oem/common/inc/fieldpriv.h
 create mode 100644 prebuilt-v4.4/noarch/include/oem/common/inc/mprand.h
 create mode 100644 prebuilt-v4.4/noarch/include/oem/common/inc/oemaes.h
 create mode 100644 prebuilt-v4.4/noarch/include/oem/common/inc/oemaescommon.h
 create mode 100644 prebuilt-v4.4/noarch/include/oem/common/inc/oemaesimpl.h
 create mode 100644 prebuilt-v4.4/noarch/include/oem/common/inc/oemaeskey.h
 create mode 100644 prebuilt-v4.4/noarch/include/oem/common/inc/oemaeskeywrap.h
 create mode 100644 prebuilt-v4.4/noarch/include/oem/common/inc/oemaeskeywraptypes.h
 create mode 100644 prebuilt-v4.4/noarch/include/oem/common/inc/oemaesmulti.h
 create mode 100644 prebuilt-v4.4/noarch/include/oem/common/inc/oembroker.h
 create mode 100644 prebuilt-v4.4/noarch/include/oem/common/inc/oembyteorder.h
 create mode 100644 prebuilt-v4.4/noarch/include/oem/common/inc/oemcbctypes.h
 create mode 100644 prebuilt-v4.4/noarch/include/oem/common/inc/oemciphertypes.h
 create mode 100644 prebuilt-v4.4/noarch/include/oem/common/inc/oemcocktail.h
 create mode 100644 prebuilt-v4.4/noarch/include/oem/common/inc/oemcocktailtypes.h
 create mode 100644 prebuilt-v4.4/noarch/include/oem/common/inc/oemcommon.h
 create mode 100644 prebuilt-v4.4/noarch/include/oem/common/inc/oemcommonmem.h
 create mode 100644 prebuilt-v4.4/noarch/include/oem/common/inc/oemcryptoctx.h
 create mode 100644 prebuilt-v4.4/noarch/include/oem/common/inc/oemdebug.h
 create mode 100644 prebuilt-v4.4/noarch/include/oem/common/inc/oemdes.h
 create mode 100644 prebuilt-v4.4/noarch/include/oem/common/inc/oemeccp256.h
 create mode 100644 prebuilt-v4.4/noarch/include/oem/common/inc/oemeccp256impl.h
 create mode 100644 prebuilt-v4.4/noarch/include/oem/common/inc/oemmd5.h
 create mode 100644 prebuilt-v4.4/noarch/include/oem/common/inc/oemmd5types.h
 create mode 100644 prebuilt-v4.4/noarch/include/oem/common/inc/oemprofile.h
 create mode 100644 prebuilt-v4.4/noarch/include/oem/common/inc/oemrc4.h
 create mode 100644 prebuilt-v4.4/noarch/include/oem/common/inc/oemrc4types.h
 create mode 100644 prebuilt-v4.4/noarch/include/oem/common/inc/oemrsa.h
 create mode 100644 prebuilt-v4.4/noarch/include/oem/common/inc/oemrsacommon.h
 create mode 100644 prebuilt-v4.4/noarch/include/oem/common/inc/oemrsaimpl.h
 create mode 100644 prebuilt-v4.4/noarch/include/oem/common/inc/oemrsaoaeppss.h
 create mode 100644 prebuilt-v4.4/noarch/include/oem/common/inc/oemrsaoaeppssimpl.h
 create mode 100644 prebuilt-v4.4/noarch/include/oem/common/inc/oemsha1.h
 create mode 100644 prebuilt-v4.4/noarch/include/oem/common/inc/oemsha256.h
 create mode 100644 prebuilt-v4.4/noarch/include/oem/common/inc/oemsha256types.h
 create mode 100644 prebuilt-v4.4/noarch/include/oem/common/inc/oemtee.h
 create mode 100644 prebuilt-v4.4/noarch/include/oem/common/inc/oemteeproxy.h
 create mode 100644 prebuilt-v4.4/noarch/include/oem/common/inc/oemteetypes.h
 create mode 100644 prebuilt-v4.4/noarch/include/oem/common/inc/oemtrace.h
 create mode 100644 prebuilt-v4.4/noarch/include/oem/common/inc/oemxmlhash.h
 create mode 100644 prebuilt-v4.4/noarch/include/oemcompiler.h
 create mode 100644 prebuilt-v4.4/noarch/include/oemresults.h
 create mode 100644 prebuilt-v4.4/noarch/pkgconfig/playready.pc

diff --git a/prebuilt-v4.4/noarch/include/drmactivation.h b/prebuilt-v4.4/noarch/include/drmactivation.h
new file mode 100644
index 0000000..9ad1ddd
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmactivation.h
@@ -0,0 +1,24 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __DRM_ACTIVATION__
+#define __DRM_ACTIVATION__
+
+#include <drmtypes.h>
+
+ENTER_PK_NAMESPACE;
+
+DRM_API DRM_BOOL DRM_CALL DRM_ACTIVATION_IsActivationSupported( DRM_VOID );
+DRM_API DRM_BOOL DRM_CALL DRM_ACTIVATION_IsActivationUnsupported( DRM_VOID );
+DRM_NO_INLINE DRM_API const DRM_ANSI_CONST_STRING *DRM_CALL DRM_ACTIVATION_GetReeFeatureXml( DRM_VOID ) DRM_NO_INLINE_ATTRIBUTE;
+
+
+EXIT_PK_NAMESPACE;
+
+#endif /* __DRM_ACTIVATION__ */
+
diff --git a/prebuilt-v4.4/noarch/include/drmactivationconstants.h b/prebuilt-v4.4/noarch/include/drmactivationconstants.h
new file mode 100644
index 0000000..973d388
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmactivationconstants.h
@@ -0,0 +1,44 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __DRM_ACTIVATION_CONSTANTS_H__
+#define __DRM_ACTIVATION_CONSTANTS_H__
+
+ENTER_PK_NAMESPACE;
+
+/*
+** ---------------------------------------------------------------
+** XML strings used in the construction of an activation challenge
+** ---------------------------------------------------------------
+*/
+
+extern DRM_GLOBAL_CONST  DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrActivationResponsePrimaryPayloadPath;
+extern DRM_GLOBAL_CONST  DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrActivationResponseAuxPayloadUrlPath;
+extern DRM_GLOBAL_CONST  DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrActivationResponseTag;
+extern DRM_GLOBAL_CONST  DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrActivationResultTag;
+extern DRM_GLOBAL_CONST  DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrauxilaryPayloadUrlTag;
+extern DRM_GLOBAL_CONST  DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrActivationRequestTag;
+extern DRM_GLOBAL_CONST  DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrActivationServiceNamespaceV1AttribValue;
+extern DRM_GLOBAL_CONST  DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrclientSdkVersionTag;
+extern DRM_GLOBAL_CONST  DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrclientSdkTypeTag;
+extern DRM_GLOBAL_CONST  DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrplatformTag;
+extern DRM_GLOBAL_CONST  DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrtidTag;
+extern DRM_GLOBAL_CONST  DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrpayloadTag;
+extern DRM_GLOBAL_CONST  DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrprimaryPayloadTag;
+extern DRM_GLOBAL_CONST  DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrauxilaryPayloadTag;
+extern DRM_GLOBAL_CONST  DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrwsdlServiceTag;
+extern DRM_GLOBAL_CONST  DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrnameAttribute;
+extern DRM_GLOBAL_CONST  DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrwsdlServiceNameAttributeValue;
+extern DRM_GLOBAL_CONST  DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrwsdlPortTag;
+extern DRM_GLOBAL_CONST  DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrwsdlPortNameAttributeValue;
+extern DRM_GLOBAL_CONST  DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrhttpAddressTag;
+extern DRM_GLOBAL_CONST  DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrlocationAttributeName;
+
+EXIT_PK_NAMESPACE;
+
+#endif /* __DRM_ACTIVATION_CONSTANTS_H__ */
diff --git a/prebuilt-v4.4/noarch/include/drmactivationimp.h b/prebuilt-v4.4/noarch/include/drmactivationimp.h
new file mode 100644
index 0000000..12779cf
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmactivationimp.h
@@ -0,0 +1,240 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __DRMACTIVATIONIMP_H__
+#define __DRMACTIVATIONIMP_H__
+
+#include <drmtypes.h>
+#include <drmcontextsizes.h>
+
+ENTER_PK_NAMESPACE;
+
+/**********************************************************************
+**  Activation platform values: These values should be kept in sync with
+**                              drmbcertconstants.h. Only values above 0x100
+**                              should be used to define any platforms that
+**                              will not be added to drmbcertconstants.h
+**  Undefined    0x0 : This should never be set for an activation enabled
+**                     platform
+**  WINDOWSONX86 0x100
+**  WINDOWSONX64 DRM_BCERT_SECURITY_VERSION_PLATFORM_WINDOWS
+**  OSX          DRM_BCERT_SECURITY_VERSION_PLATFORM_OSX
+**  WINDOWSONARM DRM_BCERT_SECURITY_VERSION_PLATFORM_WINDOWS_ARM
+**  IOSONARM     DRM_BCERT_SECURITY_VERSION_PLATFORM_IOS_ARM
+**  XBOXONPPC    DRM_BCERT_SECURITY_VERSION_PLATFORM_XBOX_PPC
+**  WP8ONARM     DRM_BCERT_SECURITY_VERSION_PLATFORM_WP8_ARM
+**  WP8ONX86     DRM_BCERT_SECURITY_VERSION_PLATFORM_WP8_X86
+**  ANDROIDARM   DRM_BCERT_SECURITY_VERSION_PLATFORM_ANDROID_ARM
+**********************************************************************/
+#define DRM_ACTIVATION_PROTOCOL_PLATFORM_MAXVALUE     0x100
+
+#define DRM_ACTIVATION_PROTOCOL_SDKTYPE_PLAYREADY_SDK  0x0
+#define DRM_ACTIVATION_PROTOCOL_SDKTYPE_SL_LOADER      0x1
+#define DRM_ACTIVATION_PROTOCOL_SDKTYPE_ACTIVATION_LIB 0x2
+#define DRM_ACTIVATION_PROTOCOL_SDKTYPE_MAXVALUE       0x2
+
+/**********************************************************************
+**
+** Function:    DRM_ACT_GenerateChallengeInternal
+**
+** Synopsis:    This method generates an XML activation challenge
+**              with the given challenge parameters.
+**
+** Arguments:
+**              f_dwClientSdkVersion  : Client SDK version in the
+**                                      form A.B.C.D. For a PK client, the
+**                                      SDK version will be the build version.
+**              f_dwClientSdkType     : Client SDK type. Supported
+**                                      values are currently 0 = PlayReady SDK,
+**                                      1 = Silverlight Loader, 2 = Activation
+**                                      library.
+**              f_dwPlatform          : Client platform. Supported
+**                                      values are currently 256 = WindowsOnX86,
+**                                      0 = WindowsOnX64, 2 = WindowsOnARM,
+**                                      1 = OSX,7 = XBOXOnPPC, 6 = iOSOnARM
+**                                      8 = WP8OnARM, 9 = WP8OnX86
+**              f_dwTransformVersion  : Transform version DWORD specifying the
+**                                      underlying protocol and transforms executed
+**                                      on the activation blob.
+**              f_pbPrimaryPayload: buffer containing the activation blob in
+**                                  the client lib.
+**              f_cbPrimaryPayload: Length of the activation blob in bytes.
+**              f_pbAuxPayload    : Optional buffer containing the current
+**                                  keyfile for re-activation.
+**              f_cbAuxPayload    : Length of the keyfile blob in bytes.
+**              f_pbChallenge         : Buffer that contains the returned XML
+**                                      challenge. The caller is responsible
+**                                      for allocating this buffer. This can be
+**                                      set to NULL when querying for buffer size.
+**              f_pcbChallenge        : Size of the returned challenge in bytes.
+**
+** Returns:     DRM_E_BUFFERTOOSMALL  : The passed in buffer was too small for
+**                                      generating the challenge. f_pcbChallenge
+**                                      contains the required buffer size.
+**              DRM_SUCCESS           : The challenge was generated successfully.
+**              DRM_E_INVALIDARG      : If the argument is invalid or
+**              any return code as defined in drmresults.h.
+**
+** Notes:       Does not use a caller passed in stack for allocating scratch space
+**              but instead accounts for scratch buffer space in the requested
+**              challenge buffer size so caller can predictably allocate required
+**              space.
+**
+**********************************************************************/
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_ACT_GenerateChallengeInternal(
+    __in                                      DRM_DWORD   f_dwClientSdkVersion,
+    __in                                      DRM_DWORD   f_dwClientSdkType,
+    __in                                      DRM_DWORD   f_dwPlatform,
+    __in                                      DRM_DWORD   f_dwTransformVersion,
+    __in_bcount( f_cbPrimaryPayload )   const DRM_BYTE   *f_pbPrimaryPayload,
+    __in                                      DRM_DWORD   f_cbPrimaryPayload,
+    __in_ecount_opt( f_cbAuxPayload )   const DRM_BYTE   *f_pbAuxPayload,
+    __in                                      DRM_DWORD   f_cbAuxPayload,
+    __inout_bcount_opt( *f_pcbChallenge )     DRM_BYTE   *f_pbChallenge,
+    __inout                                   DRM_DWORD  *f_pcbChallenge ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_ACT_VerifyAppData(
+    __in_ecount(f_cbAppId) const DRM_BYTE  *f_pbAppId,
+    __in                         DRM_DWORD  f_cbAppId,
+    __in                         DRM_DWORD  f_dwAppVersion ) DRM_NO_INLINE_ATTRIBUTE;
+
+/**********************************************************************
+**
+** Function:    DRM_ACT_ProcessResponseGenerateChallenge
+**
+** Synopsis:    This method processes an XML activation response
+**              and returns the next challenge to be used by the application OR
+**              processes the activation response if this is the final
+**              protocol response to be processed.
+**
+** Arguments:
+**              f_pbActivationCtx     : Activation protocol state buffer.
+**              f_pbResponse          : Buffer that contains the XML
+**                                      response to be processed.
+**              f_cbResponse          : Size of the response in bytes.
+**              f_pbChallenge         : Buffer that contains the next returned XML
+**                                      challenge if any.
+**              f_pcbChallenge        : Size of the next returned challenge in bytes.
+**              f_pszUrl              : The next Url to be used by the application.
+**              f_pcchUrl             : Size of the next Url in bytes.
+**              f_pResult             : Optional pointer to a variable that receives the
+**                                      status code.
+**
+** Returns:     DRM_E_BUFFERTOOSMALL  : The passed in challenge buffer was too small
+**                                      to generate the next challenge. The required size
+**                                      is returned in f_pcbChallenge.
+**              DRM_SUCCESS           : The response was processed successfully.
+**              DRM_E_INVALIDARG      : If the argument is invalid.
+**              or any return code as defined in drmresults.h.
+**
+** Notes:
+**
+**********************************************************************/
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_ACT_ProcessResponseGenerateChallenge(
+    __in_opt                                   DRM_VOID        *f_pOEMContext,
+    __inout_bcount( ACTIVATION_CONTEXT_SIZE )  DRM_BYTE         f_pbActivationCtx[ACTIVATION_CONTEXT_SIZE],
+    __in_bcount_opt( f_cbResponse )      const DRM_BYTE        *f_pbResponse,
+    __in_opt                                   DRM_DWORD        f_cbResponse,
+    __out_bcount_opt( *f_pcbChallenge )        DRM_BYTE        *f_pbChallenge,
+    __inout                                    DRM_DWORD       *f_pcbChallenge,
+    __out_ecount_opt( *f_pcchUrl )             DRM_CHAR        *f_pszUrl,
+    __inout                                    DRM_DWORD       *f_pcchUrl,
+    __out                                      DRM_RESULT      *f_pResult ) DRM_NO_INLINE_ATTRIBUTE;
+
+/**********************************************************************
+**
+** Function:    DRM_ACT_ProcessResponseInternal
+**
+** Synopsis:    This method processes an XML activation response
+**              and returns the primary and optionally the auxillary
+**              payload Url.
+**
+** Arguments:   f_pdastrResponse  : buffer containing the response XML.
+**              f_pbPrimaryPayload: Buffer containing the activation keyfile response.
+**              f_cbPrimaryPayload: Length of the activation keyfile response in bytes.
+**              f_pdastrAuxPayloadUrl: returned string containing the optional auxillary
+**                                     payload Url. An DRM_EMPTY_DRM_STRING is returned if no
+**                                     auxillary response Url is present. The caller should
+**                                     pass in an DRM_EMPTY_DRM_STRING for this parameter.
+**
+** Returns:     DRM_E_BUFFERTOOSMALL  : The passed in buffer was too small for
+**                                      returning the primary payload. f_pcbPrimaryPayload
+**                                      contains the required buffer size.
+**              DRM_SUCCESS           : The challenge was generated successfully.
+**              DRM_E_INVALIDARG      : If the argument is invalid.
+**              DRM_E_PROTOCOL_VERSION_NOT_SUPPORTED : The response namespace version is
+**                                                     not supported.
+**              or any return code as defined in drmresults.h.
+**
+** Notes:       Space needed for the auxillary payload Url is accounted for
+**              in the requested primary payload buffer size.
+**
+**********************************************************************/
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_ACT_ProcessResponseInternal(
+    __in                                         DRM_ANSI_CONST_STRING *f_pdastrResponse,
+    __inout_bcount_opt( *f_pcbPrimaryPayload )   DRM_BYTE              *f_pbPrimaryPayload,
+    __inout                                      DRM_DWORD             *f_pcbPrimaryPayload,
+    __out                                        DRM_ANSI_STRING       *f_pdastrAuxPayloadUrl ) DRM_NO_INLINE_ATTRIBUTE;
+
+/**********************************************************************
+**
+** Function:    DRM_ACT_ProcessWSDLResponseInternal
+**
+** Synopsis:    This method processes an XML activation petition response
+**              (the activation service WSDL)
+**
+** Arguments:   f_pdastrResponse      : buffer containing the response XML.
+**              f_pdastrActivationUrl : returned string containing the activation Url.
+**
+** Returns:     DRM_E_BUFFERTOOSMALL : The passed in DRM_ANSI_STRING was too small for
+**                                      returning the Url. cchString
+**                                      contains the required buffer size.
+**              DRM_SUCCESS          : The response was processed successfully.
+**              DRM_E_INVALIDARG     : If the argument is invalid.
+**              or any return code as defined in drmresults.h.
+**
+** Notes:
+**
+**********************************************************************/
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_ACT_ProcessWSDLResponseInternal(
+    __in                                    DRM_ANSI_CONST_STRING  *f_pdastrResponse,
+    __out                                   DRM_ANSI_STRING        *f_pdastrActivationUrl ) DRM_NO_INLINE_ATTRIBUTE;
+
+
+/*****************************************************************************
+**
+** Function:    DRM_ACT_LoadAndVerifyKeyfile
+**
+** Synopsis:    Opens a keyfile and verifies it is corresponding the activation
+**              version of the current binary
+**
+** Arguments:   [f_pOpaqueKeyFileContext] : inout keyfile context
+**
+** Returns:     DRM_SUCCESS      - on success
+**              DRM_E_INVALIDARG - if f_pKeyFileContext is NULL
+**              DRM_E_ACTIVATION_REQUIRED - if keyfile cannot be validated
+**
+******************************************************************************/
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_ACT_LoadAndVerifyKeyfile(
+        __inout_ecount(1) DRM_VOID * f_pOpaqueKeyFileContext ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_REACT_InitializeProtectedKeyfile(
+    __in_opt                                 DRM_VOID     *f_pOEMContext,
+    __deref_out_ecount( *f_cbKeyfileBlob )   DRM_BYTE    **f_ppbKeyfileBlob,
+    __out_ecount( 1 )                        DRM_DWORD    *f_cbKeyfileBlob,
+    __in_ecount( DRM_AES_KEYSIZE_128 ) const DRM_BYTE     *f_pbNonce ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_REACT_MapPreReactivateErrorCode(
+    __in             DRM_RESULT         f_dr,
+    __in_opt   const DRM_CONST_STRING  *f_pdstrDeviceStoreName,
+    __out            DRM_BOOL          *f_pfDeleteKeyFile ) DRM_NO_INLINE_ATTRIBUTE;
+
+EXIT_PK_NAMESPACE;
+
+#endif /* __DRMACTIVATIONIMP_H__ */
+
diff --git a/prebuilt-v4.4/noarch/include/drmallstrings.h b/prebuilt-v4.4/noarch/include/drmallstrings.h
new file mode 100644
index 0000000..33e3554
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmallstrings.h
@@ -0,0 +1,39 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __DRMALLSTRINGS_H__
+#define __DRMALLSTRINGS_H__
+
+#include <drmtypes.h>
+
+ENTER_PK_NAMESPACE;
+
+DRM_API_VOID DRM_VOID DRM_CALL DRM_InitAllStrings( DRM_VOID );
+
+/*
+** Every time a string is protected, it has to be added to one of these
+** corresponding arrays. The size of these arrays must be updated here
+** to enable compile time tests.
+*/
+
+#define CHAR_STRING_COUNT  491
+extern DRM_STR_CONST DRM_CHAR * g_rpcAllCharStrings[CHAR_STRING_COUNT];
+
+#define WCHAR_STRING_COUNT 116
+extern DRM_STR_CONST DRM_WCHAR * g_rpwcAllWCharStrings[WCHAR_STRING_COUNT];
+EXIT_PK_NAMESPACE;
+
+/*
+** This is used in testing to verify that the correct strings are encoded and decoded.
+** It cannot be replaced by mathematical expressions from constants above because
+** it is used to create variable names consisting of these numbers.
+*/
+#define STRING_TOTAL_COUNT 607
+
+#endif /* __DRMALLSTRINGS_H__ */
+
diff --git a/prebuilt-v4.4/noarch/include/drmantirollbackclock.h b/prebuilt-v4.4/noarch/include/drmantirollbackclock.h
new file mode 100644
index 0000000..2b776c9
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmantirollbackclock.h
@@ -0,0 +1,76 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __DRMANTIROLLBACKCLOCK_H__
+#define __DRMANTIROLLBACKCLOCK_H__
+
+#include <drmliceval.h>
+#include <drmlicstore.h>
+
+ENTER_PK_NAMESPACE;
+
+#define DRM_ANTIROLLBACK_CLOCK_CHECK_GRACE_IN_SECONDS 30
+#define DRM_ANTIROLLBACK_CLOCK_CHECK_GRACE_IN_100_NS_INTERVALS  DRM_UI64( DRM_ANTIROLLBACK_CLOCK_CHECK_GRACE_IN_SECONDS * DRM_C_TICS_PER_SECOND )
+
+#define DRM_ANTIROLLBACK_CLOCK_CHECK( ui64saved, ui64current ) \
+       ( DRM_UI64Gre( ( ui64saved ), ( ui64current ) ) && DRM_UI64Gre( DRM_UI64Sub( ( ui64saved ), ( ui64current ) ), DRM_ANTIROLLBACK_CLOCK_CHECK_GRACE_IN_100_NS_INTERVALS ) )
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_ARCLK_LEVL_OverrideMachineDateTimeWithSavedValue(
+    __inout       DRM_LICEVAL_CONTEXT *f_pContextLicEval,
+    __inout       DRM_UINT64          *f_pui64MachineDateTime ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_ARCLK_LEVL_GetMachineDatetime(
+    __inout       DRM_LICEVAL_CONTEXT *f_pContextLicEval,
+    __inout       DRM_UINT64          *f_pui64MachineDateTime ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_ARCLK_LEVL_DisableOnRollback(
+    __inout       DRM_LICEVAL_CONTEXT *f_pContextLicEval,
+    __in    const DRM_XMRFORMAT       *f_pXMR,
+    __out         DRM_BOOL            *f_pfDisabled ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_ARCLK_LEVL_SaveLicenseStoreTime(
+    __inout       DRM_LICEVAL_CONTEXT *f_pContextLicEval,
+    __in    const DRM_XMRFORMAT       *f_pXMR ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_ARCLK_LEVL_ReportClockRollback(
+    __inout       DRM_LICEVAL_CONTEXT *f_pContextLicEval,
+    __in    const DRM_XMRFORMAT       *f_pXMR ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_ARCLK_DOMST_GetDomainSavedDateTime(
+    __in_bcount( OEM_SHA1_DIGEST_LEN ) const DRM_BYTE                 f_rgbPasswordSST[ OEM_SHA1_DIGEST_LEN ],
+    __inout_opt                              DRM_VOID                *f_pOEMContext,
+    __in                                     DRM_DOMAINSTORE_CONTEXT *f_poDomainStoreContext,
+    __in                               const DRM_GUID                *f_poAccountID,
+    __out_opt                                DRM_UINT64              *f_puiDomainSavedDateTime ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_ARCLK_DOMST_ClockRollbackDetected(
+    __in    DRM_DOMAINSTORE_CONTEXT *f_poDomainStoreContext,
+    __inout DRM_SECURECORE_CONTEXT  *f_pSecureCoreCtx,
+    __in    DRM_UINT64               f_ui64GlobalSavedTime ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_ARCLK_DOMST_CreateDomainStorePassword(
+    __in                                const DRM_GUID                *f_poAccountID,
+    __inout                                   DRM_SECURECORE_CONTEXT  *f_pSecureCoreCtx,
+    __out_bcount( OEM_SHA1_DIGEST_LEN )       DRM_BYTE                 f_rgbPasswordSST[ OEM_SHA1_DIGEST_LEN ] ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_API DRM_RESULT DRM_CALL DRM_ARCLK_LIC_CheckClockRollback(
+    __inout                 DRM_LICEVAL_CONTEXT         *f_pLicEval,
+    __in                    DRM_LICSTORE_CONTEXT        *f_pLicStoreXMR,
+    __in                    DRM_LICSTOREENUM_CONTEXT    *f_pLicEnum,
+    __in_ecount(f_cbBuffer) DRM_BYTE                    *f_pbBuffer,
+    __in                    DRM_DWORD                    f_cbBuffer,
+    __in                    DRM_DST                     *f_pDatastore,
+    __in                    DRM_STACK_ALLOCATOR_CONTEXT *f_poStack );
+
+DRM_API DRM_RESULT DRM_CALL DRM_ARCLK_LIC_ResetClockRollback(
+    __in DRM_LICEVAL_CONTEXT       *f_pLicEval );
+
+EXIT_PK_NAMESPACE;
+
+#endif /*__DRMANTIROLLBACKCLOCK_H__ */
+
diff --git a/prebuilt-v4.4/noarch/include/drmantirollbackclockconstants.h b/prebuilt-v4.4/noarch/include/drmantirollbackclockconstants.h
new file mode 100644
index 0000000..db9a666
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmantirollbackclockconstants.h
@@ -0,0 +1,21 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __DRMANTIROLLBACKCLOCKCONSTANTS_H__
+#define __DRMANTIROLLBACKCLOCKCONSTANTS_H__
+
+#include <drmtypes.h>
+
+ENTER_PK_NAMESPACE;
+
+    extern DRM_GLOBAL_CONST  DRM_CONST_STRING       g_dstrDRM_LS_OLDSAVETIME_ATTR;
+
+EXIT_PK_NAMESPACE;
+
+#endif /* __DRMANTIROLLBACKCLOCKCONSTANTS_H__ */
+
diff --git a/prebuilt-v4.4/noarch/include/drmbase64.h b/prebuilt-v4.4/noarch/include/drmbase64.h
new file mode 100644
index 0000000..5f515c5
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmbase64.h
@@ -0,0 +1,83 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __DRMBASE64_H__
+#define __DRMBASE64_H__
+
+#include <drmmathsafe.h>
+
+ENTER_PK_NAMESPACE;
+
+/*
+   Using decode in place will cause the decoder to place the decoded output in the
+   last *pcbDestination bytes of pwszSource->pwszString
+*/
+#define DRM_BASE64_DECODE_NO_FLAGS 0
+#define DRM_BASE64_DECODE_IN_PLACE 1
+
+/* No encoding flags are currently supported */
+#define DRM_BASE64_ENCODE_NO_FLAGS 0
+
+/* characters required for a binary of size cb expressed as base64*/
+#define CCH_BASE64_EQUIV(cb)          ((((cb)/3)+(((cb)%3)?1:0))*4)
+/* SAL does not accept modulo% operand, introducing another macro for SAL */
+#define CCH_BASE64_EQUIV_SAL(cb)      ((((cb)/3)+(((cb)-((cb)/3)*3)?1:0))*4)
+#define CB_BASE64_DECODE(cch)         (((cch)*3)/4)
+
+#define CCH_BASE64_EQUIV_SAFE(__cb,__cch) DRM_DO {                  \
+    __cch = ( ( ( __cb ) / 3 ) + ( ( ( __cb ) % 3 ) ? 1 : 0 ) );    \
+    ChkDR( DRM_DWordMult( ( __cch ), 4, &( __cch ) ) );             \
+} DRM_WHILE_FALSE
+
+#define CB_BASE64_DECODE_SAFE(__cch,__cb) DRM_DO {      \
+    ChkDR( DRM_DWordMult( ( __cch ), 3, &( __cb ) ) );  \
+    ( __cb ) /= 4;                                      \
+} DRM_WHILE_FALSE
+
+PREFAST_PUSH_DISABLE_EXPLAINED(__WARNING_COUNT_REQUIRED_FOR_WRITABLE_BUFFER, "f_pbDestination length defined by f_pcbDestination and f_pdasstrSource" )
+PREFAST_PUSH_DISABLE_EXPLAINED(__WARNING_COUNT_REQUIRED_FOR_WRITABLE_BUFFER_25057, "f_pbDestination length defined by f_pcbDestination and f_pdasstrSource" )
+DRM_API DRM_RESULT DRM_CALL DRM_B64_DecodeA(
+    __in_ecount( f_pdasstrSource->m_ich + f_pdasstrSource->m_cch ) const DRM_CHAR *f_pszBase,
+    __in                          const DRM_SUBSTRING  *f_pdasstrSource,
+    __inout                             DRM_DWORD      *pcbDestination,
+    __out_bcount_opt( ( dwFlags & DRM_BASE64_DECODE_IN_PLACE ) == 0 ? *pcbDestination : f_pdasstrSource->m_ich + *pcbDestination ) DRM_BYTE *pbDestination,
+    __in                                DRM_DWORD       dwFlags);
+PREFAST_POP
+PREFAST_POP
+
+DRM_API DRM_RESULT DRM_CALL DRM_B64_DecodeW(
+    __in                          const DRM_CONST_STRING *pdstrSource,
+    __inout                             DRM_DWORD        *pcbDestination,
+    __out_bcount_opt( *pcbDestination ) DRM_BYTE         *pbDestination,
+    __in                                DRM_DWORD         dwFlags);
+
+DRM_API DRM_RESULT DRM_CALL DRM_B64_EncodeA(
+    __in_bcount( cbBuffer )    const DRM_BYTE  *pvBuffer,    /* input buffer */
+    __in                             DRM_DWORD  cbBuffer,    /* input len */
+    __out_ecount_opt( *pcchEncoded ) DRM_CHAR  *pszEncoded,  /* output char */
+    __inout                          DRM_DWORD *pcchEncoded, /* output ch len */
+    __in                             DRM_DWORD  dwFlags );
+
+DRM_API DRM_RESULT DRM_CALL DRM_B64_EncodeW(
+    __in_bcount( f_cbSource )    const DRM_BYTE  *f_pbSource,    /* input buffer */
+    __in                               DRM_DWORD  f_cbSource,    /* input len */
+    __out_ecount_opt( *f_pcchEncoded ) DRM_WCHAR *f_pwszEncoded, /* output WCHAR */
+    __inout                            DRM_DWORD *f_pcchEncoded, /* output ch len */
+    __in                               DRM_DWORD  f_dwFlags );
+
+#define DRM_B64_DECODEA_SIMPLE( __cchB64, __pszB64, __cb, __pb, __cbL ) DRM_DO {        \
+    DRM_SUBSTRING __drmsubstr = DRM_EMPTY_DRM_SUBSTRING;                                \
+    __cbL = __cb;                                                                       \
+    __drmsubstr.m_cch = (DRM_DWORD)__cchB64;                                            \
+    ChkDR( DRM_B64_DecodeA( __pszB64, &__drmsubstr, &__cbL, __pb, 0 ) );                \
+} DRM_WHILE_FALSE
+
+EXIT_PK_NAMESPACE;
+
+#endif /* __DRMBASE64_H__ */
+
diff --git a/prebuilt-v4.4/noarch/include/drmbcertcachetypes.h b/prebuilt-v4.4/noarch/include/drmbcertcachetypes.h
new file mode 100644
index 0000000..84bd23d
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmbcertcachetypes.h
@@ -0,0 +1,51 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __DRMBCERTCACHETYPES_H__
+#define __DRMBCERTCACHETYPES_H__
+
+#include <drmtypes.h>
+#include <oemcommon.h>
+#include <oemeccp256.h>
+
+ENTER_PK_NAMESPACE;
+
+typedef enum
+{
+    DRM_BINARY_DEVICE_CERT_KEY_SIGN         = 0,
+    DRM_BINARY_DEVICE_CERT_KEY_ENCRYPT      = 1,
+} eDRM_BINARY_DEVICE_CERT_KEYUSAGE;
+
+typedef struct
+{
+    PUBKEY_P256       PublicKey;
+DRM_OBFUS_PTR_TOP
+    OEM_CRYPTO_HANDLE hPublicKey;
+DRM_OBFUS_PTR_BTM
+} DRM_PUBLIC_KEY_CONTEXT;
+
+typedef struct
+{
+    DRM_PUBLIC_KEY_CONTEXT PublicKeyContext;
+} DRM_BINARY_DEVICE_CERT_KEYPAIR;
+
+typedef struct
+{
+    DRM_ID                          DeviceSerialNumber;
+    DRM_DWORD                       dwGroupSecurityLevel;
+    DRM_DWORD                       dwFeatureFlags;
+    DRM_BINARY_DEVICE_CERT_KEYPAIR  DeviceKeySign;
+    DRM_BINARY_DEVICE_CERT_KEYPAIR  DeviceKeyEncrypt;
+} DRM_BINARY_DEVICE_CERT_CACHED_VALUES;
+
+#define DRM_BINARY_DEVICE_CERT_CACHED_VALUES_EMPTY { DRM_ID_EMPTY, 0, 0, {0}, {0} }
+
+EXIT_PK_NAMESPACE;
+
+#endif /* __DRMBCERTCACHETYES_H__ */
+
diff --git a/prebuilt-v4.4/noarch/include/drmbcertconstants.h b/prebuilt-v4.4/noarch/include/drmbcertconstants.h
new file mode 100644
index 0000000..102c6df
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmbcertconstants.h
@@ -0,0 +1,324 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __DRMBCERTCONTSTANTS_H__
+#define __DRMBCERTCONTSTANTS_H__
+
+#include <drmtypes.h>
+#include <oemsha256.h>
+#include <oemeccp256.h>
+
+ENTER_PK_NAMESPACE;
+
+#define DRM_BCERT_MAX_URL_LENGTH                  4096              /* bytes */
+#define DRM_BCERT_MAX_EXTDATA_RECORDS             1
+#define DRM_BINARY_DEVICE_CERT_MAX_KEYUSAGES      3
+#define DRM_BINARY_DEVICE_CERT_STANDARD_KEYUSAGES ((DRM_DWORD)2)    /* signing key, encryption key */
+#define DRM_BCERT_MAX_MANUFACTURER_STRING_LENGTH  128               /* bytes */
+#define DRM_BCERT_CHAIN_HEADER_TAG                0x43484149        /* "CHAI" */
+
+#define DRM_BCERT_CLIENT_ID_LENGTH   16  /* 128 bits */
+#define DRM_BCERT_CERT_ID_LENGTH     16  /* 128 bits */
+#define DRM_BCERT_ACCOUNT_ID_LENGTH  16  /* 128 bits */
+#define DRM_BCERT_METERING_ID_LENGTH 16  /* 128 bits */
+#define DRM_BCERT_SERVICE_ID_LENGTH  16  /* 128 bits */
+
+/*
+** Minimal length of a certificate chain in bytes - 20
+*/
+#define DRM_MIN_CERT_CHAIN_LEN \
+    ( sizeof( DRM_DWORD )           /* Header Constant */ \
+    + sizeof( DRM_DWORD )           /* Version         */ \
+    + sizeof( DRM_DWORD )           /* Length          */ \
+    + sizeof( DRM_DWORD )           /* Flags           */ \
+    + sizeof( DRM_DWORD ) )         /* No of certificate entries: zero for minimal cert chain */
+
+#define DRM_BCERT_HEADER_DATA_SIZE_OFFSET  \
+    ( sizeof( DRM_DWORD )           /* Header tag          */ \
+    + sizeof( DRM_DWORD ) )         /* Version             */
+
+#define DRM_BCERT_HEADER_SIGNED_DATA_SIZE_OFFSET  \
+    ( sizeof( DRM_DWORD )           /* Header tag          */ \
+    + sizeof( DRM_DWORD )           /* Version             */ \
+    + sizeof( DRM_DWORD ) )         /* Certificate size    */
+
+/*
+** Defines for verification of object lengths in object headers
+*/
+#define DRM_BCERT_HEADER_LEN \
+    ( sizeof( DRM_DWORD )           /* Header tag          */ \
+    + sizeof( DRM_DWORD )           /* Version             */ \
+    + sizeof( DRM_DWORD )           /* Certificate size    */ \
+    + sizeof( DRM_DWORD ) )         /* Size of signed data */
+
+#define DRM_BCERT_OBJECT_HEADER_LEN \
+    ( sizeof( DRM_WORD )            /* Flags  */ \
+    + sizeof( DRM_WORD )            /* Type   */ \
+    + sizeof( DRM_DWORD ) )         /* Length */
+
+
+#define DRM_BCERT_SIGNATURE_OBJECT_LEN \
+    ( DRM_BCERT_OBJECT_HEADER_LEN   /* Object header             */ \
+    + sizeof( DRM_DWORD )           /* Signature type and length */ \
+    + sizeof( SIGNATURE_P256 )      /* Signature data            */ \
+    + sizeof( DRM_DWORD )           /* Issuer key length         */ \
+    + sizeof( PUBKEY_P256 ) )       /* Issuer key data           */
+
+#define DRM_BCERT_BASIC_INFO_OBJECT_LEN \
+    ( DRM_BCERT_OBJECT_HEADER_LEN   /* Object header     */ \
+    + sizeof( DRM_ID )              /* Certificate ID    */ \
+    + sizeof( DRM_DWORD )           /* Security level    */ \
+    + sizeof( DRM_DWORD )           /* Certificate Flags */ \
+    + sizeof( DRM_DWORD )           /* Type              */ \
+    + OEM_SHA256_DIGEST_SIZE_IN_BYTES   /* Digest Value      */ \
+    + sizeof( DRM_DWORD )           /* Expiration Date   */ \
+    + sizeof( DRM_ID ) )            /* Client ID         */
+
+#define DRM_BCERT_DEVICE_INFO_OBJECT_LEN \
+    ( DRM_BCERT_OBJECT_HEADER_LEN   /* Object header           */ \
+    + sizeof( DRM_DWORD )           /* Max License Size        */ \
+    + sizeof( DRM_DWORD )           /* Max Header Size         */ \
+    + sizeof( DRM_DWORD ) )         /* Max License Chain Depth */
+
+#define DRM_BCERT_FEATURES_OBJECT_MIN_LEN \
+    ( DRM_BCERT_OBJECT_HEADER_LEN   /* Object header                                     */ \
+    + sizeof( DRM_DWORD ) )         /* Number of features: zero for minimal feature info */
+
+#define DRM_BCERT_KEY_OBJECT_MIN_LEN \
+    ( DRM_BCERT_OBJECT_HEADER_LEN   /* Object header     */ \
+    + sizeof( DRM_WORD )            /* Type              */ \
+    + sizeof( DRM_WORD )            /* Length            */ \
+    + sizeof( DRM_DWORD )           /* Flags             */ \
+    + ECC_P256_POINT_SIZE_IN_BYTES  /* Value             */ \
+    + sizeof( DRM_DWORD )           /* Number of Entries */ \
+    + sizeof( DRM_DWORD ) )         /* One entry         */
+
+
+#define DRM_BCERT_EXTDATA_SIG_LEN \
+    ( DRM_BCERT_OBJECT_HEADER_LEN   /* Object header     */ \
+    + sizeof( DRM_WORD )            /* Signature type    */ \
+    + sizeof( SIGNATURE_P256 ) )    /* Signatrue length  */
+
+
+/*
+** Minimal length of a certificate:
+** Cert header, Basic Info, Feature Info with zero features,
+** Key Info and Signature Info.
+*/
+#define DRM_MIN_CERTIFICATE_LEN \
+    ( DRM_BCERT_HEADER_LEN               \
+    + DRM_BCERT_BASIC_INFO_OBJECT_LEN    \
+    + DRM_BCERT_FEATURES_OBJECT_MIN_LEN  \
+    + DRM_BCERT_KEY_OBJECT_MIN_LEN       \
+    + DRM_BCERT_SIGNATURE_OBJECT_LEN )
+
+#define DRM_BCERT_MAX_CERTS_PER_CHAIN   6
+
+#define DRM_BCERT_OBJFLAG_EMPTY             0x0000
+#define DRM_BCERT_OBJFLAG_MUST_UNDERSTAND   0x0001
+#define DRM_BCERT_OBJFLAG_CONTAINER_OBJ     0x0002
+
+
+/* ------------------------------------------------------------------------- */
+/*  BASIC INFO  */
+
+#define DRM_BCERT_SECURITYLEVEL_150         150  /* for testing */
+#define DRM_BCERT_SECURITYLEVEL_2000        2000
+#define DRM_BCERT_SECURITYLEVEL_3000        3000 /* Refer to PlayReady compliance rules (CRs) */
+
+#define DRM_BCERT_FLAGS_EMPTY               0x00000000 /* default */
+#define DRM_BCERT_FLAGS_EXTDATA_PRESENT     0x00000001 /* presence of extended data */
+
+#define DRM_BCERT_CERTTYPE_UNKNOWN          0x00000000
+#define DRM_BCERT_CERTTYPE_PC               0x00000001
+#define DRM_BCERT_CERTTYPE_DEVICE           0x00000002
+#define DRM_BCERT_CERTTYPE_DOMAIN           0x00000003
+#define DRM_BCERT_CERTTYPE_ISSUER           0x00000004
+#define DRM_BCERT_CERTTYPE_CRL_SIGNER       0x00000005
+#define DRM_BCERT_CERTTYPE_SERVICE          0x00000006
+#define DRM_BCERT_CERTTYPE_SILVERLIGHT      0x00000007
+#define DRM_BCERT_CERTTYPE_APPLICATION      0x00000008
+#define DRM_BCERT_CERTTYPE_METERING         0x00000009
+#define DRM_BCERT_CERTTYPE_KEYFILESIGNER    0x0000000a
+#define DRM_BCERT_CERTTYPE_SERVER           0x0000000b
+#define DRM_BCERT_CERTTYPE_LICENSESIGNER    0x0000000c
+#define DRM_BCERT_CERTTYPE_SECURETIMESERVER 0x0000000d
+#define DRM_BCERT_CERTTYPE_RPROVMODELAUTH   0x0000000e
+
+#define DRM_BCERT_CERTTYPE_MAX_VALUE        0x0000000e
+
+#define DRM_BCERT_DEFAULT_EXPIRATION_DATE   0xFFFFFFFF
+
+/* ------------------------------------------------------------------------- */
+/*  SILVERLIGHT INFO  */
+
+
+/*  Platform Identifiers for the SilverLight INFO structure, v2/v3 (not v4) */
+#define DRM_BCERT_SILVERLIGHT_PLATFORM_WINDOWS_X86  0
+#define DRM_BCERT_SILVERLIGHT_PLATFORM_WINDOWS_X64  1
+#define DRM_BCERT_SILVERLIGHT_PLATFORM_OSX_PPC      2
+#define DRM_BCERT_SILVERLIGHT_PLATFORM_OSX_X86      3
+#define DRM_BCERT_SILVERLIGHT_PLATFORM_OSX_X64      4
+#define DRM_BCERT_SILVERLIGHT_PLATFORM_MAX          4
+
+/* ------------------------------------------------------------------------- */
+/*  DEVICE INFO  */
+
+
+#define DRM_BCERT_MAX_LICENSE_SIZE         10240  /* 10K */
+#define DRM_BCERT_MAX_HEADER_SIZE          15360  /* 15K */
+#define DRM_BCERT_MAX_LICENSE_CHAIN_DEPTH      2
+
+/* ------------------------------------------------------------------------- */
+/*  SECURITY VERSION */
+
+#define DRM_BCERT_SECURITY_VERSION_UNSPECIFIED           (DRM_MAX_UNSIGNED_TYPE(DRM_DWORD))
+#define DRM_BCERT_SECURITY_VERSION_PLATFORM_UNSPECIFIED  (DRM_MAX_UNSIGNED_TYPE(DRM_DWORD))
+#define DRM_BCERT_SECURITY_VERSION_PLATFORM_OEM          DRM_BCERT_SECURITY_VERSION_PLATFORM_UNSPECIFIED
+
+#define DRM_BCERT_SECURITY_VERSION_PLATFORM_WINDOWS      0x0
+#define DRM_BCERT_SECURITY_VERSION_PLATFORM_OSX          0x1
+#define DRM_BCERT_SECURITY_VERSION_PLATFORM_WINDOWS_ARM  0x2
+
+#define DRM_BCERT_SECURITY_VERSION_PLATFORM_WM_7         0x5
+
+#define DRM_BCERT_SECURITY_VERSION_PLATFORM_IOS_ARM      0x6
+#define DRM_BCERT_SECURITY_VERSION_PLATFORM_XBOX_PPC     0x7
+#define DRM_BCERT_SECURITY_VERSION_PLATFORM_WP8_ARM      0x8
+#define DRM_BCERT_SECURITY_VERSION_PLATFORM_WP8_X86      0x9
+#define DRM_BCERT_SECURITY_VERSION_PLATFORM_XBOX_ONE     0xa
+#define DRM_BCERT_SECURITY_VERSION_PLATFORM_ANDROID_ARM  0xb
+#define DRM_BCERT_SECURITY_VERSION_PLATFORM_WP8_1_ARM    0xc
+#define DRM_BCERT_SECURITY_VERSION_PLATFORM_WP8_1_X86    0xd
+
+#define DRM_BCERT_SECURITY_VERSION_PLATFORM_WINDOWS_INTEL_HWDRM     100
+#define DRM_BCERT_SECURITY_VERSION_PLATFORM_WINDOWS_QUALCOMM_HWDRM  101
+#define DRM_BCERT_SECURITY_VERSION_PLATFORM_WINDOWS_SL150_HWDRM     102
+
+
+/* ------------------------------------------------------------------------- */
+/*  FEATURE INFO  */
+
+#define DRM_BCERT_MAX_FEATURES 32    /* array size with room to grow */
+
+#define DRM_BCERT_FEATURE_TRANSMITTER             0x00000001
+#define DRM_BCERT_FEATURE_RECEIVER                0x00000002
+#define DRM_BCERT_FEATURE_SHARED_CERTIFICATE      0x00000003
+#define DRM_BCERT_FEATURE_SECURE_CLOCK            0x00000004
+#define DRM_BCERT_FEATURE_ANTIROLLBACK_CLOCK      0x00000005
+/*
+** The next three feature flags should not be explicitly set in the certs
+** because for any cert their values are already known
+** (i.e. every device must support metering, license sync and symmetric optimization)
+** These features will stay deprecated as long as they are not optional.
+*/
+#define DRM_BCERT_FEATURE_RESERVED_METERING       0x00000006
+#define DRM_BCERT_FEATURE_RESERVED_LICSYNC        0x00000007
+#define DRM_BCERT_FEATURE_RESERVED_SYMOPT         0x00000008
+#define DRM_BCERT_FEATURE_SUPPORTS_CRLS           0x00000009
+
+/*
+** Server features
+*/
+#define DRM_BCERT_FEATURE_SERVER_BASIC_EDITION    0x0000000A
+#define DRM_BCERT_FEATURE_SERVER_STANDARD_EDITION 0x0000000B
+#define DRM_BCERT_FEATURE_SERVER_PREMIUM_EDITION  0x0000000C
+
+/* Client supports different keys for different streams in the content even without key rotation, e.g. for Audio and Video */
+#define DRM_BCERT_FEATURE_SUPPORTS_PR3_FEATURES   0x0000000D
+
+#define DRM_BCERT_FEATURE_DEPRECATED_SECURE_STOP  0x0000000E
+
+#define DRM_BCERT_FEATURE_MAX_VALUE               0x0000000E
+
+
+#define BCERT_FEATURE_BIT(dwFeature)     ( ( 0 != ( dwFeature ) ) ? ( 1 << ( ( dwFeature ) - 1 ) ) : 0 )
+#define DRM_BCERT_IS_FEATURE_SUPPORTED(dwSupportedFeatures, dwFeature)    ( 0 != ( BCERT_FEATURE_BIT( dwFeature ) & (dwSupportedFeatures) ) )
+
+/* ------------------------------------------------------------------------- */
+/*  KEY INFO  */
+
+
+/* List of supported key types. (currently just one) */
+#define DRM_BCERT_KEYTYPE_ECC256   0x0001
+
+#define DRM_BCERT_KEYUSAGE_UNKNOWN                                0x00000000
+#define DRM_BCERT_KEYUSAGE_SIGN                                   0x00000001
+#define DRM_BCERT_KEYUSAGE_ENCRYPT_KEY                            0x00000002
+#define DRM_BCERT_KEYUSAGE_SIGN_CRL                               0x00000003
+#define DRM_BCERT_KEYUSAGE_ISSUER_ALL                             0x00000004
+#define DRM_BCERT_KEYUSAGE_ISSUER_INDIV                           0x00000005
+#define DRM_BCERT_KEYUSAGE_ISSUER_DEVICE                          0x00000006
+#define DRM_BCERT_KEYUSAGE_ISSUER_LINK                            0x00000007
+#define DRM_BCERT_KEYUSAGE_ISSUER_DOMAIN                          0x00000008
+#define DRM_BCERT_KEYUSAGE_ISSUER_SILVERLIGHT                     0x00000009
+#define DRM_BCERT_KEYUSAGE_ISSUER_APPLICATION                     0x0000000a
+#define DRM_BCERT_KEYUSAGE_ISSUER_CRL                             0x0000000b
+#define DRM_BCERT_KEYUSAGE_ISSUER_METERING                        0x0000000c
+#define DRM_BCERT_KEYUSAGE_ISSUER_SIGN_KEYFILE                    0x0000000d
+#define DRM_BCERT_KEYUSAGE_SIGN_KEYFILE                           0x0000000e
+#define DRM_BCERT_KEYUSAGE_ISSUER_SERVER                          0x0000000f
+#define DRM_BCERT_KEYUSAGE_ENCRYPTKEY_SAMPLE_PROTECTION_RC4       0x00000010
+#define DRM_BCERT_KEYUSAGE_RESERVED2                              0x00000011
+#define DRM_BCERT_KEYUSAGE_ISSUER_SIGN_LICENSE                    0x00000012
+#define DRM_BCERT_KEYUSAGE_SIGN_LICENSE                           0x00000013
+#define DRM_BCERT_KEYUSAGE_SIGN_RESPONSE                          0x00000014
+#define DRM_BCERT_KEYUSAGE_PRND_ENCRYPT_KEY_DEPRECATED            0x00000015
+#define DRM_BCERT_KEYUSAGE_ENCRYPTKEY_SAMPLE_PROTECTION_AES128CTR 0x00000016
+#define DRM_BCERT_KEYUSAGE_ISSUER_SECURETIMESERVER                0x00000017
+#define DRM_BCERT_KEYUSAGE_ISSUER_RPROVMODELAUTH                  0x00000018
+
+#define DRM_BCERT_KEYUSAGE_MAX_VALUE                              0x00000018
+
+/*
+** DRM_BCERT_MAX_KEY_USAGES has to be larger than DRM_BCERT_KEYUSAGE_MAX_VALUE.
+** DRM_BCERT_MAX_KEY_USAGES should not exceed 32 since a bitmap based on DRM_DWORD
+** is currently used to represent key usage set.
+*/
+#define DRM_BCERT_MAX_KEY_USAGES                25
+
+#define BCERT_KEYUSAGE_BIT(dwKeyUsage)          (1 << ((dwKeyUsage)-1))
+#define DRM_BCERT_IS_KEYUSAGE_SUPPORTED(dwSupportedKeyUsages, dwUsage) ( 0 != ( BCERT_KEYUSAGE_BIT( dwUsage ) & (dwSupportedKeyUsages) ) )
+
+#define BCERT_KEYUSAGE_PARENT_ISSUERS_MASK                              \
+    ( BCERT_KEYUSAGE_BIT( DRM_BCERT_KEYUSAGE_ISSUER_INDIV )             \
+    | BCERT_KEYUSAGE_BIT( DRM_BCERT_KEYUSAGE_ISSUER_DEVICE )            \
+    | BCERT_KEYUSAGE_BIT( DRM_BCERT_KEYUSAGE_ISSUER_LINK )              \
+    | BCERT_KEYUSAGE_BIT( DRM_BCERT_KEYUSAGE_ISSUER_DOMAIN )            \
+    | BCERT_KEYUSAGE_BIT( DRM_BCERT_KEYUSAGE_ISSUER_SILVERLIGHT )       \
+    | BCERT_KEYUSAGE_BIT( DRM_BCERT_KEYUSAGE_ISSUER_APPLICATION )       \
+    | BCERT_KEYUSAGE_BIT( DRM_BCERT_KEYUSAGE_ISSUER_CRL )               \
+    | BCERT_KEYUSAGE_BIT( DRM_BCERT_KEYUSAGE_ISSUER_SIGN_KEYFILE )      \
+    | BCERT_KEYUSAGE_BIT( DRM_BCERT_KEYUSAGE_ISSUER_METERING )          \
+    | BCERT_KEYUSAGE_BIT( DRM_BCERT_KEYUSAGE_ISSUER_SIGN_LICENSE )      \
+    | BCERT_KEYUSAGE_BIT( DRM_BCERT_KEYUSAGE_ISSUER_SECURETIMESERVER )  \
+    | BCERT_KEYUSAGE_BIT( DRM_BCERT_KEYUSAGE_ISSUER_RPROVMODELAUTH ) )
+
+
+/*
+** The following byte value should be equal to the largest public key length supported
+*/
+#define DRM_BCERT_MAX_PUBKEY_VALUE_LENGTH     sizeof( PUBKEY_P256 )
+
+typedef PUBKEY_P256 DRM_BCERT_PUBKEY;
+
+
+/* ------------------------------------------------------------------------- */
+/*  SIGNATURE INFO  */
+
+
+#define DRM_BCERT_SIGNATURE_TYPE_P256         0x0001    /* ECDSA-P-256-SHA-256 */
+
+/*
+** The following byte value should be equal to the largest signature length supported
+*/
+#define DRM_BCERT_MAX_SIGNATURE_DATA_LENGTH   sizeof( SIGNATURE_P256 )
+
+EXIT_PK_NAMESPACE;
+
+#endif /* __DRMBCERTCONSTANTS_H__ */
diff --git a/prebuilt-v4.4/noarch/include/drmbcertformat_generated.h b/prebuilt-v4.4/noarch/include/drmbcertformat_generated.h
new file mode 100644
index 0000000..99d6ef6
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmbcertformat_generated.h
@@ -0,0 +1,314 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+/* This source was autogenerated by xbgen.
+** DO NOT EDIT THIS SOURCE MANUALLY.
+** If changes need to be applied update the XML and regenerate this source.
+*/
+/*
+** This file defines the following generated formats
+** DRM_BCERTFORMAT_CERT
+** DRM_BCERTFORMAT_CERT_HEADER
+** DRM_BCERTFORMAT_CHAIN
+*/
+#ifndef __BINCERT_H__
+#define __BINCERT_H__ 1
+
+ENTER_PK_NAMESPACE;
+
+PREFAST_PUSH_DISABLE_EXPLAINED( __WARNING_POOR_DATA_ALIGNMENT_25021, "Ignore poor alignment of XBinary data structures" );
+
+#define DRM_BCERTFORMAT_CURRENT_VERSION 1
+#define DRM_BCERTFORMAT_PARSER_STACK_SIZE_MIN 1024
+#define DRM_BCERTFORMAT_BUILDER_STACK_SIZE_MIN 1300
+#define DRM_BCERTFORMAT_STACK_SIZE 4096
+#define DRM_BCERTFORMAT_PARSER_STACK_SIZE_MAX (DRM_BCERTFORMAT_PARSER_STACK_SIZE_MIN * 8)
+#define DRM_BCERTFORMAT_BUILDER_STACK_SIZE_MAX (DRM_BCERTFORMAT_BUILDER_STACK_SIZE_MIN * 8)
+#define DRM_BCERTFORMAT_OBJTYPE_BASIC 0x0001
+#define DRM_BCERTFORMAT_OBJTYPE_DOMAIN 0x0002
+#define DRM_BCERTFORMAT_OBJTYPE_PC 0x0003
+#define DRM_BCERTFORMAT_OBJTYPE_DEVICE 0x0004
+#define DRM_BCERTFORMAT_OBJTYPE_FEATURE 0x0005
+#define DRM_BCERTFORMAT_OBJTYPE_KEY 0x0006
+#define DRM_BCERTFORMAT_OBJTYPE_MANUFACTURER 0x0007
+#define DRM_BCERTFORMAT_OBJTYPE_SIGNATURE 0x0008
+#define DRM_BCERTFORMAT_OBJTYPE_SILVERLIGHT 0x0009
+#define DRM_BCERTFORMAT_OBJTYPE_METERING 0x000A
+#define DRM_BCERTFORMAT_OBJTYPE_EXTDATASIGNKEY 0x000B
+#define DRM_BCERTFORMAT_OBJTYPE_EXTDATACONTAINER 0x000C
+#define DRM_BCERTFORMAT_OBJTYPE_EXTDATASIGNATURE 0x000D
+#define DRM_BCERTFORMAT_OBJTYPE_EXTDATA_HWID 0x000E
+#define DRM_BCERTFORMAT_OBJTYPE_SERVER 0x000F
+#define DRM_BCERTFORMAT_OBJTYPE_SECURITY_VERSION 0x0010
+#define DRM_BCERTFORMAT_OBJTYPE_SECURITY_VERSION_2 0x0011
+#define DRM_BCERTFORMAT_UNKNOWN_OBJECT_ID 0xFFFD
+
+typedef struct __tagDRM_BCERTFORMAT_KEY_TYPE
+{
+    DRM_BOOL             fValid;
+    DRM_WORD             wType;
+    DRM_WORD             wKeyLength;
+    DRM_DWORD            dwFlags;
+    DRM_XB_BYTEARRAY     xbbaKeyValue;
+    DRM_XB_DWORDLIST     dwlKeyUsages;
+    DRM_DWORD            dwUsageSet;
+} DRM_BCERTFORMAT_KEY_TYPE;
+
+typedef struct __tagDRM_BCERTFORMAT_EXTENDED_HEADER
+{
+    DRM_BOOL      fValid;
+    DRM_DWORD     dwVersion;
+    DRM_DWORD     dwLength;
+    DRM_DWORD     dwSignedLength;
+} DRM_BCERTFORMAT_EXTENDED_HEADER;
+
+typedef struct __tagDRM_BCERTFORMAT_CHAIN_EXTENDED_HEADER
+{
+    DRM_BOOL      fValid;
+    DRM_DWORD     dwVersion;
+    DRM_DWORD     cbChain;
+    DRM_DWORD     dwFlags;
+    DRM_DWORD     cCerts;
+} DRM_BCERTFORMAT_CHAIN_EXTENDED_HEADER;
+
+typedef enum __tagDRM_BCERTFORMAT_CERT_TYPES 
+{
+    DRM_BCERTFORMAT_BASIC_INFO_ENTRY_TYPE               = 0x1,
+    DRM_BCERTFORMAT_DOMAIN_INFO_ENTRY_TYPE              = 0x2,
+    DRM_BCERTFORMAT_PC_INFO_ENTRY_TYPE                  = 0x3,
+    DRM_BCERTFORMAT_DEVICE_INFO_ENTRY_TYPE              = 0x4,
+    DRM_BCERTFORMAT_FEATURE_INFO_ENTRY_TYPE             = 0x5,
+    DRM_BCERTFORMAT_KEY_INFO_ENTRY_TYPE                 = 0x6,
+    DRM_BCERTFORMAT_MANUFACTURER_INFO_ENTRY_TYPE        = 0x7,
+    DRM_BCERTFORMAT_SIGNATURE_INFO_ENTRY_TYPE           = 0x8,
+    DRM_BCERTFORMAT_SILVERLIGHT_INFO_ENTRY_TYPE         = 0x9,
+    DRM_BCERTFORMAT_METERING_INFO_ENTRY_TYPE            = 0xA,
+    DRM_BCERTFORMAT_EX_DATA_SIGKEY_INFO_ENTRY_TYPE      = 0xB,
+    DRM_BCERTFORMAT_EXTENDED_DATA_CONTAINER_ENTRY_TYPE  = 0xC,
+    DRM_BCERTFORMAT_EXT_DATA_SIG_INFO_ENTRY_TYPE        = 0xD,
+    DRM_BCERTFORMAT_HWID_ENTRY_TYPE                     = 0xE,
+    DRM_BCERTFORMAT_SERVER_TYPE_INFO_ENTRY_TYPE         = 0xF,
+    DRM_BCERTFORMAT_SECURITY_VERSION_ENTRY_TYPE         = 0x10,
+    DRM_BCERTFORMAT_SECURITY_VERSION2_ENTRY_TYPE        = 0x11,
+    DRM_BCERTFORMAT_EXT_DATA_OBJECT_ENTRY_TYPE          = 0xFFFD,
+} DRM_BCERTFORMAT_CERT_TYPES;
+/* Count Includes XB_OBJECT_GLOBAL_HEADER */
+#define DRM_BCERTFORMAT_CERT_TYPE_COUNT       19
+#define DRM_BCERTFORMAT_CERT_FORMAT_ID        XB_DEFINE_DWORD_FORMAT_ID( 'C', 'E', 'R', 'T' )
+
+typedef struct __tagDRM_BCERTFORMAT_BASIC_INFO
+{
+    DRM_BOOL             fValid;
+    DRM_ID               certID;
+    DRM_DWORD            dwSecurityLevel;
+    DRM_DWORD            dwFlags;
+    DRM_DWORD            dwType;
+    DRM_XB_BYTEARRAY     xbbaDigestValue;
+    DRM_DWORD            dwExpirationDate;
+    DRM_ID               ClientID;
+} DRM_BCERTFORMAT_BASIC_INFO;
+
+typedef struct __tagDRM_BCERTFORMAT_DOMAIN_INFO
+{
+    DRM_BOOL             fValid;
+    DRM_ID               ServiceID;
+    DRM_ID               AccountID;
+    DRM_DWORD            dwRevision;
+    DRM_XB_BYTEARRAY     xbbaDomainUrl;
+} DRM_BCERTFORMAT_DOMAIN_INFO;
+
+typedef struct __tagDRM_BCERTFORMAT_PC_INFO
+{
+    DRM_BOOL      fValid;
+    DRM_DWORD     dwSecurityVersion;
+} DRM_BCERTFORMAT_PC_INFO;
+
+typedef struct __tagDRM_BCERTFORMAT_DEVICE_INFO
+{
+    DRM_BOOL      fValid;
+    DRM_DWORD     dwMaxLicenseSize;
+    DRM_DWORD     dwMaxHeaderSize;
+    DRM_DWORD     dwMaxLicenseChainDepth;
+} DRM_BCERTFORMAT_DEVICE_INFO;
+
+typedef struct __tagDRM_BCERTFORMAT_SILVERLIGHT_INFO
+{
+    DRM_BOOL      fValid;
+    DRM_DWORD     dwSecurityVersion;
+    DRM_DWORD     dwPlatformID;
+} DRM_BCERTFORMAT_SILVERLIGHT_INFO;
+
+typedef struct __tagDRM_BCERTFORMAT_SERVER_TYPE_INFO
+{
+    DRM_BOOL      fValid;
+    DRM_DWORD     dwWarningStartDate;
+} DRM_BCERTFORMAT_SERVER_TYPE_INFO;
+
+typedef struct __tagDRM_BCERTFORMAT_METERING_INFO
+{
+    DRM_BOOL             fValid;
+    DRM_ID               MeteringID;
+    DRM_XB_BYTEARRAY     xbbaMeteringUrl;
+} DRM_BCERTFORMAT_METERING_INFO;
+
+typedef struct __tagDRM_BCERTFORMAT_SECURITY_VERSION
+{
+    DRM_BOOL      fValid;
+    DRM_DWORD     dwSecurityVersion;
+    DRM_DWORD     dwPlatformID;
+} DRM_BCERTFORMAT_SECURITY_VERSION;
+
+typedef struct __tagDRM_BCERTFORMAT_SECURITY_VERSION2
+{
+    DRM_BOOL      fValid;
+    DRM_DWORD     dwSecurityVersion;
+    DRM_DWORD     dwPlatformID;
+} DRM_BCERTFORMAT_SECURITY_VERSION2;
+
+typedef struct __tagDRM_BCERTFORMAT_FEATURE_INFO
+{
+    DRM_BOOL             fValid;
+    DRM_XB_DWORDLIST     dwlFeatures;
+    DRM_DWORD            dwFeatureSet;
+} DRM_BCERTFORMAT_FEATURE_INFO;
+
+typedef struct __tagDRM_BCERTFORMAT_KEY_INFO
+{
+    DRM_BOOL                      fValid;
+    DRM_DWORD                     cEntries;
+    DRM_BCERTFORMAT_KEY_TYPE*     pHead;
+} DRM_BCERTFORMAT_KEY_INFO;
+
+typedef struct __tagDRM_BCERTFORMAT_MANUFACTURER_INFO
+{
+    DRM_BOOL             fValid;
+    DRM_DWORD            dwFlags;
+    DRM_XB_BYTEARRAY     xbbaManufacturerName;
+    DRM_XB_BYTEARRAY     xbbaModelName;
+    DRM_XB_BYTEARRAY     xbbaModelNumber;
+} DRM_BCERTFORMAT_MANUFACTURER_INFO;
+
+typedef struct __tagDRM_BCERTFORMAT_EX_DATA_SIGKEY_INFO
+{
+    DRM_BOOL             fValid;
+    DRM_WORD             wType;
+    DRM_WORD             wKeyLen;
+    DRM_DWORD            dwFlags;
+    DRM_XB_BYTEARRAY     xbbKeyValue;
+} DRM_BCERTFORMAT_EX_DATA_SIGKEY_INFO;
+
+typedef struct __tagDRM_BCERTFORMAT_SIGNATURE_INFO
+{
+    DRM_BOOL             fValid;
+    DRM_WORD             wSignatureType;
+    DRM_XB_BYTEARRAY     xbbaSignature;
+    DRM_XB_BYTEARRAY     xbbaIssuerKey;
+} DRM_BCERTFORMAT_SIGNATURE_INFO;
+
+typedef struct __tagDRM_BCERTFORMAT_HWID
+{
+    DRM_BOOL             fValid;
+    DRM_XB_BYTEARRAY     xbbaData;
+} DRM_BCERTFORMAT_HWID;
+
+typedef struct __tagDRM_BCERTFORMAT_EXT_DATA_SIG_INFO
+{
+    DRM_BOOL             fValid;
+    DRM_WORD             wSignatureType;
+    DRM_XB_BYTEARRAY     xbbaSignature;
+} DRM_BCERTFORMAT_EXT_DATA_SIG_INFO;
+
+typedef struct __tagDRM_BCERTFORMAT_EXTENDED_DATA_CONTAINER
+{
+    DRM_BOOL                              fValid;
+    DRM_BCERTFORMAT_HWID                  HwidRecord;
+    DRM_BCERTFORMAT_EXT_DATA_SIG_INFO     ExDataSignatureInformation;
+    DRM_XB_UNKNOWN_OBJECT                *pExtendedData;
+    DRM_XB_BYTEARRAY                      xbbaRawData;
+} DRM_BCERTFORMAT_EXTENDED_DATA_CONTAINER;
+
+typedef struct __tagDRM_BCERTFORMAT_CERT
+{
+    DRM_BOOL                                    fValid;
+    DRM_BCERTFORMAT_EXTENDED_HEADER             HeaderData;
+    DRM_BCERTFORMAT_BASIC_INFO                  BasicInformation;
+    DRM_BCERTFORMAT_DOMAIN_INFO                 DomainInformation;
+    DRM_BCERTFORMAT_PC_INFO                     PCInfo;
+    DRM_BCERTFORMAT_DEVICE_INFO                 DeviceInformation;
+    DRM_BCERTFORMAT_SILVERLIGHT_INFO            SilverlightInformation;
+    DRM_BCERTFORMAT_SERVER_TYPE_INFO            ServerTypeInformation;
+    DRM_BCERTFORMAT_METERING_INFO               MeteringInformation;
+    DRM_BCERTFORMAT_SECURITY_VERSION            SecurityVersion;
+    DRM_BCERTFORMAT_SECURITY_VERSION2           SecurityVersion2;
+    DRM_BCERTFORMAT_FEATURE_INFO                FeatureInformation;
+    DRM_BCERTFORMAT_KEY_INFO                    KeyInformation;
+    DRM_BCERTFORMAT_MANUFACTURER_INFO           ManufacturerInformation;
+    DRM_BCERTFORMAT_EX_DATA_SIGKEY_INFO         ExDataSigKeyInfo;
+    DRM_BCERTFORMAT_SIGNATURE_INFO              SignatureInformation;
+    DRM_BCERTFORMAT_EXTENDED_DATA_CONTAINER     ExDataContainer;
+    DRM_XB_BYTEARRAY                            xbbaRawData;
+} DRM_BCERTFORMAT_CERT;
+
+DRM_EXPORT_VAR extern DRM_GLOBAL_CONST DRM_XB_FORMAT_DESCRIPTION s_DRM_BCERTFORMAT_CERT_FormatDescription[1];
+
+typedef enum __tagDRM_BCERTFORMAT_CERT_HEADER_TYPES 
+{
+    DRM_BCERTFORMAT_CHAIN_OFFSET_ENTRY_TYPE  = 0x2,
+    DRM_BCERTFORMAT_CHAIN_INDEX_ENTRY_TYPE   = 0x3,
+} DRM_BCERTFORMAT_CERT_HEADER_TYPES;
+/* Count Includes XB_OBJECT_GLOBAL_HEADER */
+#define DRM_BCERTFORMAT_CERT_HEADER_TYPE_COUNT       3
+#define DRM_BCERTFORMAT_CERT_HEADER_FORMAT_ID        XB_DEFINE_DWORD_FORMAT_ID( 'C', 'E', 'R', 'T' )
+
+typedef struct __tagDRM_BCERTFORMAT_CERT_HEADER
+{
+    DRM_BOOL                            fValid;
+    DRM_BCERTFORMAT_EXTENDED_HEADER     HeaderData;
+    DRM_DWORD                           dwOffset;
+    DRM_DWORD                           dwIndex;
+    DRM_XB_BYTEARRAY                    xbbaRawData;
+} DRM_BCERTFORMAT_CERT_HEADER;
+
+DRM_EXPORT_VAR extern DRM_GLOBAL_CONST DRM_XB_FORMAT_DESCRIPTION s_DRM_BCERTFORMAT_CERT_HEADER_FormatDescription[1];
+
+typedef enum __tagDRM_BCERTFORMAT_CHAIN_TYPES 
+{
+    DRM_BCERTFORMAT_CHAIN_CERT_HEADER_ENTRY_TYPE       = 0x2,
+    DRM_BCERTFORMAT_CHIAN_SECURITY_VERSION_ENTRY_TYPE  = 0x3,
+    DRM_BCERTFORMAT_CHIAN_PLATFORM_ID_ENTRY_TYPE       = 0x4,
+    DRM_BCERTFORMAT_CHAIN_EXPIRATION_ENTRY_TYPE        = 0x5,
+} DRM_BCERTFORMAT_CHAIN_TYPES;
+/* Count Includes XB_OBJECT_GLOBAL_HEADER */
+#define DRM_BCERTFORMAT_CHAIN_TYPE_COUNT       5
+#define DRM_BCERTFORMAT_CHAIN_FORMAT_ID        XB_DEFINE_DWORD_FORMAT_ID( 'C', 'H', 'A', 'I' )
+
+typedef struct __tagDRM_BCERTFORMAT_CHAIN_CERT_HEADER
+{
+    DRM_BOOL                         fValid;
+    DRM_DWORD                        cEntries;
+    DRM_BCERTFORMAT_CERT_HEADER*     pCertHeaders;
+} DRM_BCERTFORMAT_CHAIN_CERT_HEADER;
+
+typedef struct __tagDRM_BCERTFORMAT_CHAIN
+{
+    DRM_BOOL                                  fValid;
+    DRM_BCERTFORMAT_CHAIN_EXTENDED_HEADER     Header;
+    DRM_BCERTFORMAT_CHAIN_CERT_HEADER         Certificates;
+    DRM_DWORD                                 dwSecurityVersion;
+    DRM_DWORD                                 dwPlatformID;
+    DRM_DWORD                                 dwExpiration;
+    DRM_XB_BYTEARRAY                          xbbaRawData;
+} DRM_BCERTFORMAT_CHAIN;
+
+DRM_EXPORT_VAR extern DRM_GLOBAL_CONST DRM_XB_FORMAT_DESCRIPTION s_DRM_BCERTFORMAT_CHAIN_FormatDescription[1];
+
+PREFAST_POP;
+
+EXIT_PK_NAMESPACE;
+
+#endif /* __BINCERT_H__ */
diff --git a/prebuilt-v4.4/noarch/include/drmbcertformatbuilder.h b/prebuilt-v4.4/noarch/include/drmbcertformatbuilder.h
new file mode 100644
index 0000000..2e5707a
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmbcertformatbuilder.h
@@ -0,0 +1,298 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __DRMBCERTFORMATBUILDER_H__
+#define __DRMBCERTFORMATBUILDER_H__
+
+#include <drmxbbuilder.h>
+#include <drmbcertconstants.h>
+#include <drmbcertformat_generated.h>
+#include <drmbcertformatparser.h>
+#include <oemtee.h>
+
+ENTER_PK_NAMESPACE;
+
+#define DRM_BCERTFORMAT_PAD_AMOUNT(x) ( ( (x) > 0 ) ? ( ( sizeof(DRM_DWORD) - ( (x) % sizeof(DRM_DWORD) ) ) % sizeof(DRM_DWORD) ) : 0 )
+
+#define DRM_BCERTFORMAT_BUILDER_CALCULATE_SIGNATUREINFO_SIZE(cbSignatureLength, cbIssuerKeyLength) \
+            ( XB_BASE_OBJECT_LENGTH                                                                \
+            + sizeof( DRM_WORD )                                /* signature type    */            \
+            + sizeof( DRM_WORD )                                /* signature length  */            \
+            + ( cbSignatureLength )                             /* signature data    */            \
+            + DRM_BCERTFORMAT_PAD_AMOUNT( cbSignatureLength )   /* padding           */            \
+            + sizeof( DRM_DWORD )                               /* issuer key length */            \
+            + ( cbIssuerKeyLength )                             /* issuer key value  */            \
+            + DRM_BCERTFORMAT_PAD_AMOUNT( cbIssuerKeyLength ) ) /* padding           */
+
+#define DRM_BCERTFORMAT_BUILDER_CALCULATE_SIGNATUREINFO_SIZE_SAFE(__cbSignature, __cbIssuerKey, __cbSigInfo) DRM_DO {   \
+    ( __cbSigInfo ) = XB_BASE_OBJECT_LENGTH + 2 * sizeof( DRM_WORD ) + sizeof( DRM_DWORD );                             \
+    ChkDR( DRM_DWordAddSame( &( __cbSigInfo ), ( __cbSignature ) ) );                                                   \
+    ChkDR( DRM_DWordAddSame( &( __cbSigInfo ), DRM_BCERTFORMAT_PAD_AMOUNT( __cbSignature ) ) );                         \
+    ChkDR( DRM_DWordAddSame( &( __cbSigInfo ), ( __cbIssuerKey ) ) );                                                   \
+    ChkDR( DRM_DWordAddSame( &( __cbSigInfo ), DRM_BCERTFORMAT_PAD_AMOUNT( __cbIssuerKey ) ) );                         \
+} DRM_WHILE_FALSE
+
+#define DRM_BCERTFORMAT_BUILDER_CALCULATE_EXTDATA_RECORD_SIZE(cbBlobLength)                        \
+            ( XB_BASE_OBJECT_LENGTH                             /* extended data record header */  \
+            + sizeof( DRM_DWORD )                               /* data length                 */  \
+            + cbBlobLength                                      /* data blob                   */  \
+            + DRM_BCERTFORMAT_PAD_AMOUNT( cbBlobLength ) )      /* padding                     */
+
+#define DRM_BCERTFORMAT_BUILDER_CALCULATE_EXTDATA_RECORD_SIZE_SAFE(__cbBlob, __cbRecord) DRM_DO {   \
+    ( __cbRecord ) = XB_BASE_OBJECT_LENGTH + sizeof( DRM_DWORD );                                   \
+    ChkDR( DRM_DWordAddSame( &( __cbRecord ), ( __cbBlob ) ) );                                     \
+    ChkDR( DRM_DWordAddSame( &( __cbRecord ), DRM_BCERTFORMAT_PAD_AMOUNT( __cbBlob ) ) );           \
+} DRM_WHILE_FALSE
+
+#define DRM_BCERTFORMAT_BUILDER_CALCULATE_EXTDATA_SIGNATURE_SIZE(cbSignatureLength)                \
+            ( XB_BASE_OBJECT_LENGTH                             /* signature obj header        */  \
+            + sizeof( DRM_WORD )                                /* signature type              */  \
+            + sizeof( DRM_WORD )                                /* signature length            */  \
+            + cbSignatureLength                                 /* signature data              */  \
+            + DRM_BCERTFORMAT_PAD_AMOUNT( cbSignatureLength ) ) /* padding                     */
+
+#define DRM_BCERTFORMAT_BUILDER_CALCULATE_EXTDATA_SIGNATURE_SIZE_SAFE(__cbSignature,__cbExtDataSignature) DRM_DO {  \
+    ( __cbExtDataSignature ) = XB_BASE_OBJECT_LENGTH + 2 * sizeof( DRM_WORD );                                      \
+    ChkDR( DRM_DWordAddSame( &( __cbExtDataSignature ), ( __cbSignature ) ) );                                      \
+    ChkDR( DRM_DWordAddSame( &( __cbExtDataSignature ), DRM_BCERTFORMAT_PAD_AMOUNT( __cbSignature ) ) );            \
+} DRM_WHILE_FALSE
+
+#define DRM_BCERTFORMAT_BUILDER_CALCULATE_EXTDATA_CONTAINER_SIZE(cbBlobLength, cbSignatureLength)  \
+            ( XB_BASE_OBJECT_LENGTH                             /* container obj header        */  \
+            + DRM_BCERTFORMAT_BUILDER_CALCULATE_EXTDATA_RECORD_SIZE(cbBlobLength)                  \
+            + DRM_BCERTFORMAT_BUILDER_CALCULATE_EXTDATA_SIGNATURE_SIZE(cbSignatureLength) )
+
+#define DRM_BCERTFORMAT_BUILDER_CALCULATE_EXTDATA_CONTAINER_SIZE_SAFE(__cbBlob, __cbSignature, __cbContainer) DRM_DO {  \
+    DRM_DWORD __cbData;                                                                                                 \
+    ( __cbContainer ) = XB_BASE_OBJECT_LENGTH;                                                                          \
+    DRM_BCERTFORMAT_BUILDER_CALCULATE_EXTDATA_RECORD_SIZE_SAFE( __cbBlob, __cbData );                                   \
+    ChkDR( DRM_DWordAddSame( &( __cbContainer ), ( __cbData ) ) );                                                      \
+    DRM_BCERTFORMAT_BUILDER_CALCULATE_EXTDATA_SIGNATURE_SIZE_SAFE( __cbSignature, __cbData );                           \
+    ChkDR( DRM_DWordAddSame( &( __cbContainer ), ( __cbData ) ) );                                                      \
+} DRM_WHILE_FALSE
+
+#define ChkDRAllowXBObjectExists(expr) DRM_DO {     \
+    dr = (expr);                                    \
+    if( dr == DRM_E_XB_OBJECT_ALREADY_EXISTS )      \
+    {                                               \
+        dr = DRM_SUCCESS;                           \
+    }                                               \
+    else if( DRM_FAILED( dr ) )                     \
+    {                                               \
+        goto ErrorExit;                             \
+    }                                               \
+} DRM_WHILE_FALSE
+
+#define DRM_BCERTFORMAT_MAX_MANUFACTURER_STRING_LENGTH  128   /* bytes */
+typedef struct _tagDrmBCertFormatManufacturerString
+{
+    DRM_DWORD   cb;
+    DRM_BYTE    rgb[ DRM_BCERT_MAX_MANUFACTURER_STRING_LENGTH ];
+} DRM_BCERTFORMAT_MANUFACTURER_STRING;
+
+typedef struct _tagDrmBCertFormatManufacturerStrings
+{
+    DRM_BCERTFORMAT_MANUFACTURER_STRING  ManufacturerName;
+    DRM_BCERTFORMAT_MANUFACTURER_STRING  ModelName;
+    DRM_BCERTFORMAT_MANUFACTURER_STRING  ModelNumber;
+} DRM_BCERTFORMAT_MANUFACTURER_STRINGS;
+
+typedef struct __tagDRM_BCERTFORMAT_BUILDER_KEYDATA
+{
+    DRM_WORD      wKeyType;
+    DRM_WORD      cbKey;
+    DRM_DWORD     cKeyUsages;
+    DRM_BYTE      rgbKey[DRM_BCERT_MAX_PUBKEY_VALUE_LENGTH];
+    DRM_DWORD     rgdwKeyUsages[DRM_BCERT_MAX_KEY_USAGES];
+} DRM_BCERTFORMAT_BUILDER_KEYDATA;
+
+typedef struct __tagDRM_BCERTFORMAT_BUILDER_CONTEXT_INTERNAL
+{
+    DRM_BCERTFORMAT_CHAIN                oCertChain;
+    DRM_BCERTFORMAT_CERT                 oNewCert;
+    DRM_XB_BUILDER_CONTEXT               oBuilderCtx;
+    DRM_BCERTFORMAT_MANUFACTURER_STRINGS oManufactureStrings;
+    DRM_BCERTFORMAT_BUILDER_KEYDATA     *pKeyData;
+    DRM_DWORD                            cbExtPrivKey;
+    const DRM_BYTE                      *pbExtPrivKey;
+} DRM_BCERTFORMAT_BUILDER_CONTEXT_INTERNAL;
+
+#define DRM_BCERTFORMAT_BUILDER_CONTEXT_BUFFER_SIZE sizeof( DRM_BCERTFORMAT_BUILDER_CONTEXT_INTERNAL )
+
+typedef struct __tagDRM_BCERTFORMAT_BUILDER_CONTEXT
+{
+    /*
+    ** This data is Opaque.  Do not set any value in it.
+    */
+    DRM_BYTE rgbOpaqueBuffer[ DRM_BCERTFORMAT_BUILDER_CONTEXT_BUFFER_SIZE ];
+} DRM_BCERTFORMAT_BUILDER_CONTEXT;
+
+typedef union __tagDRM_BCERTFORMAT_CERT_TYPE_DATA
+{
+    struct _tagDrmBCertDomainData
+    {
+        DRM_ID     ServiceID;
+        DRM_ID     AccountID;
+        DRM_DWORD  dwRevision;   /* a timestamp */
+        DRM_DWORD  cbDomainURL;
+        DRM_BYTE   rgbDomainURL[DRM_BCERT_MAX_URL_LENGTH];
+    } Domain;
+
+    struct _tagDrmBCertPCData
+    {
+        DRM_DWORD  dwSecurityVersion;  /* A.B.C.D */
+    } PC;
+
+    struct _tagDrmSilverlightData
+    {
+        DRM_DWORD  dwSecurityVersion;  /* A.B.C.D */
+        DRM_DWORD  dwPlatformIdentifier;
+    } Silverlight;
+
+    struct _tagDrmBCertDeviceData
+    {
+        DRM_DWORD  cbMaxLicense;
+        DRM_DWORD  cbMaxHeader;
+        DRM_DWORD  dwMaxChainDepth;
+    } Device;
+
+    struct _tagDrmBCertMeteringData
+    {
+        DRM_ID     MeteringID;
+        DRM_DWORD  cbMeteringURL;
+        DRM_BYTE   rgbMeteringURL[DRM_BCERT_MAX_URL_LENGTH];
+    } Metering;
+
+    struct _tagDrmBCertServerData
+    {
+        DRM_DWORD  dwWarningDays;
+    } Server;
+} DRM_BCERTFORMAT_CERT_TYPE_DATA;
+
+typedef struct __tagDRM_BCERTFORMAT_CERT_DEVICE_DATA
+{
+    DRM_DWORD       cbMaxLicense;
+    DRM_DWORD       cbMaxHeader;
+    DRM_DWORD       dwMaxChainDepth;
+} DRM_BCERTFORMAT_CERT_DEVICE_DATA;
+
+typedef struct __tagDrmBCertFormatCertSignatureInfo
+{
+    DRM_DWORD        cbCertificate;
+    DRM_DWORD        cbSignature;
+    const DRM_BYTE  *pbCertficate;
+    DRM_BYTE        *pbSignature;
+} DRM_BCERTFORMAT_CERT_SIGNATURE_INFO;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_BCERTFORMAT_SetKeyInfo(
+    __inout_ecount( 1 )                             DRM_BCERTFORMAT_BUILDER_CONTEXT     *f_pBuilderCtx,
+    __in                                            DRM_DWORD                            f_cKeys,
+    __in_ecount( f_cKeys )                          DRM_BCERTFORMAT_BUILDER_KEYDATA     *f_pKeys ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_BCERTFORMAT_SetManufacturerName(
+    __inout_ecount( 1 )                             DRM_BCERTFORMAT_BUILDER_CONTEXT     *f_pBuilderCtx,
+    __in                                            DRM_DWORD                            f_cbManufacturerName,
+    __in_bcount( f_cbManufacturerName )       const DRM_BYTE                            *f_pbManufacturerName ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_BCERTFORMAT_SetModelName(
+    __inout_ecount( 1 )                             DRM_BCERTFORMAT_BUILDER_CONTEXT     *f_pBuilderCtx,
+    __in                                            DRM_DWORD                            f_cbModelName,
+    __in_bcount( f_cbModelName )              const DRM_BYTE                            *f_pbModelName ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_BCERTFORMAT_SetModelNumber(
+    __inout_ecount( 1 )                             DRM_BCERTFORMAT_BUILDER_CONTEXT     *f_pBuilderCtx,
+    __in                                            DRM_DWORD                            f_cbModelNumber,
+    __in_bcount( f_cbModelNumber )            const DRM_BYTE                            *f_pbModelNumber ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_BCERTFORMAT_SetFeatures(
+    __inout_ecount( 1 )                             DRM_BCERTFORMAT_BUILDER_CONTEXT     *f_pBuilderCtx,
+    __in                                            DRM_DWORD                            f_cFeatures,
+    __in_ecount( f_cFeatures )                const DRM_DWORD                           *f_pdwFeatures ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_BCERTFORMAT_SetSecurityLevel(
+    __inout_ecount( 1 )                             DRM_BCERTFORMAT_BUILDER_CONTEXT     *f_pBuilderCtx,
+    __in                                            DRM_DWORD                            f_dwSecurityLevel ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_BCERTFORMAT_SetBuilderFlags(
+    __inout_ecount( 1 )                             DRM_BCERTFORMAT_BUILDER_CONTEXT     *f_pBuilderCtx,
+    __in                                            DRM_DWORD                            f_dwChainHeaderFlags,
+    __in                                            DRM_DWORD                            f_dwBasicInfoFlags,
+    __in                                            DRM_DWORD                            f_dwManufacturerFlags ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_BCERTFORMAT_SetSecurityVersion(
+     __inout_ecount( 1 )                            DRM_BCERTFORMAT_BUILDER_CONTEXT     *f_pBuilderCtx,
+     __in                                           DRM_DWORD                            f_dwPlatformID,
+     __in                                           DRM_DWORD                            f_dwSecurityVersion ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_BCERTFORMAT_SetExpirationDate(
+    __inout_ecount( 1 )                             DRM_BCERTFORMAT_BUILDER_CONTEXT     *f_pBuilderCtx,
+    __in                                            DRM_DWORD                            f_dwExpirationDate ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_BCERTFORMAT_SetExtData(
+    __inout_ecount( 1 )                             DRM_BCERTFORMAT_BUILDER_CONTEXT     *f_pBuilderCtx,
+    __in                                            DRM_DWORD                            f_cbExtData,
+    __in_bcount( f_cbExtData )                const DRM_BYTE                            *f_pbExtData ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_BCERTFORMAT_SetExtDataKeyInfo(
+    __inout_ecount( 1 )                             DRM_BCERTFORMAT_BUILDER_CONTEXT     *f_pBuilderCtx,
+    __in                                            DRM_WORD                             f_wKeyType,
+    __in                                            DRM_WORD                             f_wKeyLen,
+    __in                                            DRM_DWORD                            f_dwFlags,
+    __in                                            DRM_DWORD                            f_cbPrivateSigningKey,
+    __in_bcount( f_cbPrivateSigningKey )      const DRM_BYTE                            *f_pbPrivateSigningKey,
+    __in                                            DRM_DWORD                            f_cbPublicSigningKey,
+    __in_bcount( f_cbPublicSigningKey )       const DRM_BYTE                            *f_pbPublicSigningKey ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_BCERTFORMAT_LoadCertificateChain(
+    __inout_opt                                     OEM_TEE_CONTEXT                     *f_pOemTeeContext,
+    __inout                                         DRM_STACK_ALLOCATOR_CONTEXT         *f_pStack,
+    __in                                            DRM_DWORD                            f_cbCertChain,
+    __in_bcount( f_cbCertChain )              const DRM_BYTE                            *f_pbCertChain,
+    __out_ecount( 1 )                               DRM_BCERTFORMAT_CERT               **f_ppCertWeakRef,
+    __out_ecount( 1 )                               DRM_BCERTFORMAT_BUILDER_CONTEXT     *f_pBuilderCtx,
+    __out_ecount( 1 )                               DRM_BCERTFORMAT_PARSER_CONTEXT      *f_pParserCtx ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_BCERTFORMAT_SaveCertificateChain(
+    __inout                                         DRM_BCERTFORMAT_BUILDER_CONTEXT     *f_pBuilderCtx,
+    __inout_opt                                     OEM_TEE_CONTEXT                     *f_pOemTeeContext,
+    __in                                      const PRIVKEY_P256                        *f_pIssuerPrivateKey,
+    __in                                      const PUBKEY_P256                         *f_pIssuerPublicKey,
+    __out                                           DRM_DWORD                           *f_pcbCertChain,
+    __out_bcount_opt( *f_pcbCertChain )             DRM_BYTE                            *f_pbCertChain ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_BCERTFORMAT_StartCertificateChain(
+    __inout                                         DRM_STACK_ALLOCATOR_CONTEXT         *f_pStack,
+    __in                                            DRM_DWORD                            f_cbParentChain,
+    __in_bcount_opt( f_cbParentChain )        const DRM_BYTE                            *f_pbParentChain,
+    __in                                            DRM_DWORD                            f_dwCertType,
+    __in                                      const DRM_BCERTFORMAT_CERT_TYPE_DATA      *f_pCertData,
+    __in                                      const DRM_ID                              *f_pCertificateID,
+    __in_opt                                  const DRM_ID                              *f_pClientID,
+    __out_ecount( 1 )                               DRM_BCERTFORMAT_BUILDER_CONTEXT     *f_pBuilderCtx ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_BCERTFORMAT_StartDeviceCertificateChain(
+    __inout                                         DRM_STACK_ALLOCATOR_CONTEXT         *f_pStack,
+    __in                                            DRM_DWORD                            f_cbParentChain,
+    __in_bcount_opt( f_cbParentChain )        const DRM_BYTE                            *f_pbParentChain,
+    __in                                      const DRM_BCERTFORMAT_CERT_DEVICE_DATA    *f_pCertData,
+    __in                                      const DRM_ID                              *f_pCertificateID,
+    __in_opt                                  const DRM_ID                              *f_pClientID,
+    __out_ecount( 1 )                               DRM_BCERTFORMAT_BUILDER_CONTEXT     *f_pBuilderCtx ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_BCERTFORMAT_FinishCertificateChain(
+    __inout_ecount( 1 )                             DRM_BCERTFORMAT_BUILDER_CONTEXT     *f_pBuilderCtx,
+    __inout_opt                                     OEM_TEE_CONTEXT                     *f_pOemTeeContext,
+    __in_opt                                  const PRIVKEY_P256                        *f_pIssuerPrivateKey,
+    __in                                      const PUBKEY_P256                         *f_pIssuerPublicKey,
+    __inout_ecount( 1 )                             DRM_DWORD                           *f_pcbCertificateChain,
+    __inout_bcount_opt( *f_pcbCertificateChain )    DRM_BYTE                            *f_pbCertificateChain,
+    __inout_opt                                     DRM_BCERTFORMAT_CERT_SIGNATURE_INFO *f_pSignatureInfo ) DRM_NO_INLINE_ATTRIBUTE;
+
+EXIT_PK_NAMESPACE;
+
+#endif /* __DRMBCERTFORMATBUILDER_H__ */
diff --git a/prebuilt-v4.4/noarch/include/drmbcertformatparser.h b/prebuilt-v4.4/noarch/include/drmbcertformatparser.h
new file mode 100644
index 0000000..fe0510b
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmbcertformatparser.h
@@ -0,0 +1,256 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __DRMBCERTFORMATPARSER_H__
+#define __DRMBCERTFORMATPARSER_H__
+
+#include <drmxbparser.h>
+#include <drmbcertconstants.h>
+#include <drmbcertformat_generated.h>
+#include <oemtee.h>
+#include <drmrevocationtypes.h>
+
+ENTER_PK_NAMESPACE;
+
+PREFAST_PUSH_DISABLE_EXPLAINED(__WARNING_POOR_DATA_ALIGNMENT_25021,"Ignore poor data alignment" );
+
+typedef struct __tagDRM_BCERTFORMAT_VERIFICATIONRESULT {
+    /*
+    ** Number of the cert in the chain, zero-based with leaf cert as 0
+    */
+    DRM_DWORD   cCertNumber;
+    /*
+    ** Error code
+    */
+    DRM_RESULT  drResult;
+} DRM_BCERTFORMAT_VERIFICATIONRESULT;
+
+typedef enum __tagDRM_BCERTFORMAT_PARSER_CONTEXT_TYPE
+{
+    DRM_BCERTFORMAT_CONTEXT_TYPE_INVALID = 0,
+    DRM_BCERTFORMAT_CONTEXT_TYPE_FULL    = 1,
+    DRM_BCERTFORMAT_CONTEXT_TYPE_BASE    = 2,
+} DRM_BCERTFORMAT_PARSER_CONTEXT_TYPE;
+
+typedef struct __tagDRM_BCERTFORMAT_PARSER_CONTEXT_BASE
+{
+    DRM_BCERTFORMAT_PARSER_CONTEXT_TYPE eContextType;
+    DRM_BOOL                            fInitialized;
+    DRMFILETIME                         ftCurrentTime;
+    DRM_DWORD                           dwExpectedLeafCertType;
+    DRM_STACK_ALLOCATOR_CONTEXT        *pStack;
+    OEM_TEE_CONTEXT                    *pOemTeeCtx;
+} DRM_BCERTFORMAT_PARSER_CONTEXT_BASE;
+
+#define DRM_BCERTFORMAT_PARSER_CONTEXT_BASE_EMPTY { DRM_BCERTFORMAT_CONTEXT_TYPE_INVALID, 0, { 0, 0 }, 0, NULL, NULL }
+
+typedef struct __tagDRM_BCERTFORMAT_PARSER_CONTEXT_FULL
+{
+    DRM_BCERTFORMAT_PARSER_CONTEXT_BASE oBaseCtx;
+    DRM_BOOL                            fCheckSignature;
+    DRM_DWORD                           iCurrentCert;
+    DRM_BOOL                            fRootPubKeySet;
+    PUBKEY_P256                         oRootPubKey;
+    DRM_BOOL                            fDontFailOnMissingExtData;
+    DRM_DWORD                           dwRequiredKeyUsageMask;
+    DRM_DWORD                           iResult;
+    DRM_DWORD                           cResults;
+    DRM_BCERTFORMAT_CERT                rgoCertCache[DRM_BCERT_MAX_CERTS_PER_CHAIN];
+    DRM_BCERTFORMAT_VERIFICATIONRESULT *pResults;
+} DRM_BCERTFORMAT_PARSER_CONTEXT_FULL;
+
+#define DRM_BCERTFORMAT_PARSER_CONTEXT_BUFFER_SIZE sizeof( DRM_BCERTFORMAT_PARSER_CONTEXT_FULL )
+
+typedef struct __tagDRM_BCERTFORMAT_PARSER_CONTEXT
+{
+    /*
+    ** This data is Opaque.  Do not set any value in it.
+    */
+    DRM_BYTE rgbOpaqueBuffer[ DRM_BCERTFORMAT_PARSER_CONTEXT_BUFFER_SIZE ];
+} DRM_BCERTFORMAT_PARSER_CONTEXT;
+
+#define DRM_BCERTFORMAT_PARSER_CONTEXT_INTERNAL DRM_VOID
+
+#define DRM_BCERTFORMAT_PARSER_CTX_IS_BASE( pCtx )          ((pCtx)->eContextType == DRM_BCERTFORMAT_CONTEXT_TYPE_BASE)
+#define DRM_BCERTFORMAT_PARSER_CTX_IS_FULL( pCtx )          ((pCtx)->eContextType == DRM_BCERTFORMAT_CONTEXT_TYPE_FULL)
+#define DRM_BCERTFORMAT_PARSER_CTX_TO_FULL( pCtx )          DRM_REINTERPRET_CAST( DRM_BCERTFORMAT_PARSER_CONTEXT_FULL, (pCtx) )
+#define DRM_BCERTFORMAT_PARSER_CTX_TO_CONST_FULL( pCtx )    DRM_REINTERPRET_CONST_CAST( const DRM_BCERTFORMAT_PARSER_CONTEXT_FULL, (pCtx) )
+#define DRM_BCERTFORMAT_PARSER_CTX_SIZE( pCtx )             (DRM_BCERTFORMAT_PARSER_CTX_IS_FULL( pCtx ) ? sizeof(DRM_BCERTFORMAT_PARSER_CONTEXT_FULL) : sizeof(DRM_BCERTFORMAT_PARSER_CONTEXT_BASE))
+
+
+PREFAST_POP; /* __WARNING_POOR_DATA_ALIGNMENT_25021 */
+
+
+typedef struct __tagDRM_BCERTFORMAT_MFG_STRING
+{
+    DRM_DWORD cbString;
+    DRM_BYTE *pbString;
+} DRM_BCERTFORMAT_MFG_STRING;
+
+typedef enum __tagDRM_TEE_BCERTFORMAT_CHAIN_DATA_KEY
+{
+    DRM_BCERTFORMAT_CHAIN_DATA_KEY__SIGN                    = 0,
+    DRM_BCERTFORMAT_CHAIN_DATA_KEY__ENCRYPT                 = 1,
+    DRM_BCERTFORMAT_CHAIN_DATA_KEY__PRND_ENCRYPT_DEPRECATED = 2,
+    DRM_BCERTFORMAT_CHAIN_DATA_KEY__SAMPLEPROT              = 3,
+    DRM_BCERTFORMAT_CHAIN_DATA_KEY__SIGN_CRL                = 4,
+
+    /* This must be the last item */
+    DRM_BCERTFORMAT_CHAIN_DATA_KEY__COUNT                   = 5,
+} DRM_TEE_BCERTFORMAT_CHAIN_DATA_KEY;
+
+typedef struct __tagDRM_BCERTFORMAT_PARSER_CHAIN_DATA
+{
+    DRM_DWORD                  dwLeafSecurityLevel;
+    DRM_DWORD                  dwLeafFeatureSet;
+    DRM_DWORD                  dwSecurityVersion;
+    DRM_DWORD                  dwPlatformID;
+    DRM_DWORD                  cDigests;
+    DRM_DWORD                  dwValidKeyMask;
+    OEM_SHA256_DIGEST          rgoDigests[DRM_BCERT_MAX_CERTS_PER_CHAIN];
+    PUBKEY_P256                rgoLeafPubKeys[DRM_BCERTFORMAT_CHAIN_DATA_KEY__COUNT];
+    DRM_BCERTFORMAT_MFG_STRING oManufacturingName;
+    DRM_BCERTFORMAT_MFG_STRING oManufacturingModel;
+    DRM_BCERTFORMAT_MFG_STRING oManufacturingNumber;
+} DRM_BCERTFORMAT_PARSER_CHAIN_DATA;
+
+#define DRM_BCERTFORMAT_PARSER_CHAIN_DATA_KEY_BIT(dwKey)                 (1u << (dwKey))
+#define DRM_BCERTFORMAT_PARSER_CHAIN_DATA_IS_KEY_VALID(dwKeyMask, dwKey) ( DRM_BCERTFORMAT_PARSER_CHAIN_DATA_KEY_BIT( dwKey ) & (dwKeyMask) )
+
+
+#define DRM_BCERTFORMAT_CHKVERIFICATIONERR( pVerificationCtx, fCondition, dwErr ) DRM_DO {          \
+    if( !(fCondition) )                                                                             \
+    {                                                                                               \
+        DRM_BCERTFORMAT_PARSER_CONTEXT_BASE *_pVCtx = (pVerificationCtx);                           \
+        DRM_RESULT _drErr = (dwErr);                                                                \
+        if( !DRM_BCERTFORMAT_PARSER_CTX_IS_FULL(_pVCtx ) )                                          \
+        {                                                                                           \
+            ChkDR( _drErr );                                                                        \
+        }                                                                                           \
+        else                                                                                        \
+        {                                                                                           \
+            DRM_BCERTFORMAT_PARSER_CONTEXT_FULL *_pVCtx2 =                                          \
+                DRM_BCERTFORMAT_PARSER_CTX_TO_FULL(_pVCtx);                                         \
+            ChkBOOL( _pVCtx2->iResult < _pVCtx2->cResults, _drErr );                                \
+            _pVCtx2->pResults[_pVCtx2->iResult].cCertNumber = _pVCtx2->iCurrentCert;                \
+            _pVCtx2->pResults[_pVCtx2->iResult].drResult    = _drErr;                               \
+            _pVCtx2->iResult = _pVCtx2->iResult + 1; /* Can't overflow: limited number of calls */  \
+        }                                                                                           \
+    }                                                                                               \
+} DRM_WHILE_FALSE
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_BCERTFORMAT_OverrideRootPublicKey(
+    __inout_ecount( 1 )                     DRM_BCERTFORMAT_PARSER_CONTEXT        *f_pParserCtx,
+    __in_ecount_opt( 1 )              const PUBKEY_P256                           *f_pRootPubKey ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_BCERTFORMAT_InitializeParserContext(
+    __in                                    DRM_BOOL                               f_fCheckSignature,
+    __in                                    DRM_BOOL                               f_fDontFailOnMissingExtData,
+    __in                                    DRM_DWORD                              f_cRequiredKeyUsages,
+    __in_ecount_opt( f_cRequiredKeyUsages )
+                                      const DRM_DWORD                             *f_pdwRequiredKeyUsages,
+    __in                                    DRM_DWORD                              f_cResults,
+    __in_ecount_opt( f_cResults )           DRM_BCERTFORMAT_VERIFICATIONRESULT    *f_pResults,
+    __inout_ecount( 1 )                     DRM_BCERTFORMAT_PARSER_CONTEXT        *f_pParserCtx ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_BCERTFORMAT_GetCertificate(
+    __inout_ecount( 1 )                     DRM_BCERTFORMAT_PARSER_CONTEXT        *f_pParserCtx,
+    __in                              const DRM_BCERTFORMAT_CERT_HEADER           *f_pCertificateHeader,
+    __out_ecount_opt( 1 )                   DRM_DWORD                             *f_pcbParsed,
+    __out_ecount_opt( 1 )                   DRM_BCERTFORMAT_CERT                  *f_pCert ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_BCERTFORMAT_ParseCertificateChain(
+    __inout_ecount( 1 )                     DRM_BCERTFORMAT_PARSER_CONTEXT        *f_pParserCtx,
+    __inout_opt                             OEM_TEE_CONTEXT                       *f_pOemTeeContext,
+    __in_ecount_opt( 1 )              const DRMFILETIME                           *f_pftCurrentTime,
+    __in                                    DRM_DWORD                              f_dwExpectedLeafCertType,
+    __inout                                 DRM_STACK_ALLOCATOR_CONTEXT           *f_pStack,
+    __in                                    DRM_DWORD                              f_cbCertData,
+    __in_bcount( f_cbCertData )       const DRM_BYTE                              *f_pbCertData,
+    __inout_ecount_opt( 1 )                 DRM_DWORD                             *f_cbParsed,
+    __out_ecount( 1 )                       DRM_BCERTFORMAT_CHAIN                 *f_pChain,
+    __out_ecount_opt( 1 )                   DRM_BCERTFORMAT_CERT                  *f_pLeafMostCert ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_BCERTFORMAT_VerifyCertificateChain(
+    __inout_opt                             OEM_TEE_CONTEXT                       *f_pOemTeeContext,
+    __inout_opt                             DRM_BCERTFORMAT_PARSER_CONTEXT        *f_pParserCtx,
+    __in_ecount_opt( 1 )              const DRMFILETIME                           *f_pftCurrentTime,
+    __in                                    DRM_DWORD                              f_dwCertType,
+    __in                                    DRM_DWORD                              f_dwMinSecurityLevel,
+    __in                                    DRM_DWORD                              f_cbCertData,
+    __in_bcount( f_cbCertData )       const DRM_BYTE                              *f_pbCertData ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_BCERTFORMAT_GetPublicKeyByUsageFromChain(
+    __inout_ecount( 1 )                     DRM_BCERTFORMAT_PARSER_CONTEXT        *f_pParserCtx,
+    __in                              const DRM_BCERTFORMAT_CHAIN                 *f_pChain,
+    __in                                    DRM_DWORD                              f_dwKeyUsage,
+    __inout_ecount( 1 )                     PUBKEY_P256                           *f_pPubkey,
+    __out_ecount_opt( 1 )                   DRM_DWORD                             *f_pdwKeyUsageSet,
+    __inout_ecount_opt( 1 )                 DRM_BCERTFORMAT_CERT                  *f_pCert,
+    __out_ecount_opt( 1 )                   DRM_DWORD                             *f_pdwCertKeyIndex ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_BCERTFORMAT_GetPublicKeyFromCert(
+    __in_ecount( 1 )                  const DRM_BCERTFORMAT_CERT                  *f_pCert,
+    __inout_ecount( 1 )                     PUBKEY_P256                           *f_pPubkey ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_BCERTFORMAT_GetPublicKeyByUsage(
+    __inout_opt                             DRM_BCERTFORMAT_PARSER_CONTEXT        *f_pParserCtx,
+    __inout_opt                             OEM_TEE_CONTEXT                       *f_pOemTeeContext,
+    __in                              const DRM_DWORD                              f_cbCertData,
+    __in_bcount(f_cbCertData)         const DRM_BYTE                              *f_pbCertData,
+    __in                              const DRM_DWORD                              f_dwCertIndex,
+    __in                              const DRM_DWORD                              f_dwKeyUsage,
+    __out_ecount(1)                         PUBKEY_P256                           *f_pPubkey,
+    __out_opt                               DRM_DWORD                             *f_pdwKeyUsageSet,
+    __out_ecount_opt(1)                     DRM_DWORD                             *f_pdwCertKeyIndex ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_BCERTFORMAT_GetPublicKey(
+    __inout_opt                             DRM_BCERTFORMAT_PARSER_CONTEXT        *f_pParserCtx,
+    __inout_opt                             OEM_TEE_CONTEXT                       *f_pOemTeeContext,
+    __in                              const DRM_DWORD                              f_cbCertData,
+    __in_bcount(f_cbCertData)         const DRM_BYTE                              *f_pbCertData,
+    __out_ecount(1)                         PUBKEY_P256                           *f_pPubkey ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_BCERTFORMAT_GetPublicKeyAndDomainRevision(
+    _Inout_opt_                             DRM_BCERTFORMAT_PARSER_CONTEXT        *f_pParserCtx,
+    _Inout_opt_                             OEM_TEE_CONTEXT                       *f_pOemTeeContext,
+    _In_                              const DRM_DWORD                              f_cbCertData,
+    _In_reads_( f_cbCertData )        const DRM_BYTE                              *f_pbCertData,
+    _Out_writes_( 1 )                       PUBKEY_P256                           *f_pPubkey,
+    _Out_writes_opt_( 1 )                   DRM_DWORD                             *f_pdwRevision ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_BCERTFORMAT_GetSecurityLevel(
+    __inout_opt                             DRM_BCERTFORMAT_PARSER_CONTEXT        *f_pParserCtx,
+    __inout_opt                             OEM_TEE_CONTEXT                       *f_pOemTeeContext,
+    __in                              const DRM_DWORD                              f_cbCertData,
+    __in_bcount( f_cbCertData )       const DRM_BYTE                              *f_pbCertData,
+    __out_ecount( 1 )                       DRM_DWORD                             *f_pdwSecurityLevel ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_BCERTFORMAT_VerifyChildUsage(
+    __in                              const DRM_DWORD                              f_dwChildKeyUsageMask,
+    __in                              const DRM_DWORD                              f_dwParentKeyUsageMask ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_BCERTFORMAT_ParseCertificateChainData(
+    __inout_opt                             OEM_TEE_CONTEXT                       *f_pOemTeeContext,
+    __in_opt                          const DRMFILETIME                           *f_pftCurrentTime,
+    __in                                    DRM_DWORD                              f_dwExpectedLeafCertType,
+    __inout                                 DRM_STACK_ALLOCATOR_CONTEXT           *f_pStack,
+    __in                                    DRM_DWORD                              f_cbCertData,
+    __in_bcount( f_cbCertData )       const DRM_BYTE                              *f_pbCertData,
+    __out                                   DRM_BCERTFORMAT_PARSER_CHAIN_DATA     *f_poChainData,
+    __in                                    DRM_BOOL                               f_fForceSkipSignatureCheck ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_BCERTFORMAT_VerifySignature(
+    __in                              const DRM_BCERTFORMAT_CERT                  *f_pCertificate,
+    __inout_opt                             OEM_TEE_CONTEXT                       *f_pOemTeeContext ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API_VOID DRM_DWORD DRM_BCERTFORMAT_GetResultCount( __in DRM_BCERTFORMAT_PARSER_CONTEXT *f_pCertParserCtx ) DRM_NO_INLINE_ATTRIBUTE;
+
+EXIT_PK_NAMESPACE;
+
+#endif /* __DRMBCERTFORMATPARSER_H__ */
diff --git a/prebuilt-v4.4/noarch/include/drmbcertformatparsercache.h b/prebuilt-v4.4/noarch/include/drmbcertformatparsercache.h
new file mode 100644
index 0000000..86c2a9b
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmbcertformatparsercache.h
@@ -0,0 +1,33 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __DRMBCERTFORMATPARSERCACHE_H__
+#define __DRMBCERTFORMATPARSERCACHE_H__
+
+#include <drmtypes.h>
+#include <drmbcertcachetypes.h>
+#include <drmsecurecoretypes.h>
+
+ENTER_PK_NAMESPACE;
+
+PREFAST_PUSH_DISABLE_EXPLAINED(__WARNING_NONCONST_PARAM_25004,"Ignore non const parameter for DRM_SECURECORE_CONTEXT." )
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_BCERTFORMAT_LoadPropertiesCache(
+    __inout                         DRM_SECURECORE_CONTEXT               *f_pSecureCoreCtx,
+    __in_bcount(f_cbCertData) const DRM_BYTE                             *f_pbCertData,
+    __in                      const DRM_DWORD                             f_cbCertData,
+    __inout                         DRM_BINARY_DEVICE_CERT_CACHED_VALUES *f_pCachedValues ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API_VOID DRM_VOID DRM_CALL DRM_BCERTFORMAT_CleanupPropertiesCache(
+    __inout                         DRM_SECURECORE_CONTEXT               *f_pSecureCoreCtx,
+    __inout                         DRM_BINARY_DEVICE_CERT_CACHED_VALUES *f_pCachedValues ) DRM_NO_INLINE_ATTRIBUTE;
+PREFAST_POP /* __WARNING_NONCONST_PARAM_25004 */
+
+EXIT_PK_NAMESPACE;
+
+#endif /* __DRMBCERTFORMATPARSERCACHE_H__ */
+
diff --git a/prebuilt-v4.4/noarch/include/drmbcrl.h b/prebuilt-v4.4/noarch/include/drmbcrl.h
new file mode 100644
index 0000000..aea4df8
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmbcrl.h
@@ -0,0 +1,69 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __DRMBCRL_H__
+#define __DRMBCRL_H__
+
+#include <drmbcrltypes.h>
+#include <oemcryptoctx.h>
+#include <oemeccp256.h>
+#include <drmbcertformatparser.h>
+#include <drmrevocationtypes.h>
+#include <drmsecurecoretypes.h>
+
+ENTER_PK_NAMESPACE;
+
+/*********************************************************************
+**
+**  Parses Playready/Silverlight CRL from binary to data structure.
+**  Verifies signature and certificate chain.
+**
+**  NOTE: The parser does not make copies of the DRM_RevocationEntry
+**        data, it just points to them in the f_pbCrlData buffer so
+**        you cannot free the f_pbCrlData and still have a valid f_poCrl
+**        data structure.
+**
+*********************************************************************/
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_BCrl_ParseCrl(
+    __in_bcount(f_cbCrlData)          const DRM_BYTE                        *f_pbCrlData,
+    __in                              const DRM_DWORD                        f_cbCrlData,
+    __out                                   DRM_BCRL_Signed                 *f_poCrl,
+    __in_ecount(1)                    const PUBKEY_P256                     *f_pRootPubkey,
+    __inout_opt                             DRM_CRYPTO_CONTEXT              *f_pCryptoCtx,
+    __inout_opt                             DRM_SECURECORE_CONTEXT          *f_pSecureCoreCtx,
+    __in_opt                                DRM_SECSTORE_CONTEXT            *f_pcontextSST,
+    __in_opt                                DRM_DST                         *f_pDatastore ) DRM_NO_INLINE_ATTRIBUTE;
+
+/*********************************************************************
+**
+**  Checks to see if the given certificate is in the given CRL file.
+**  Internally the API uses the DRM_BCrl_ParseCrl method to parse
+**  and verify the CRL.  Then it walks through the entries in the CRL
+**  to see if the given certificate is revoked.  The API returns
+**  DRM_E_CERTIFICATE_REVOKED if any certificate in the chain is revoked.
+**
+*********************************************************************/
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_BCrl_CheckIfPlayReadyCertRevoked(
+    __inout                                 DRM_BCERTFORMAT_PARSER_CONTEXT  *f_pCertParserCtx,
+    __in                              const DRM_BCERTFORMAT_CHAIN           *f_pPlayReadyCertChain,
+    __in_bcount(f_cbPlayReadyCRL)     const DRM_BYTE                        *f_pbPlayReadyCRL,
+    __in                                    DRM_DWORD                        f_cbPlayReadyCRL,
+    __out_opt                               OEM_SHA256_DIGEST               *f_pRevokedCertDigest,
+    __out_opt                               DRM_DWORD                       *f_pdwPlayReadyCRLVer,
+    __inout_opt                             DRM_CRYPTO_CONTEXT              *f_pCryptoCtx,
+    __inout_opt                             DRM_SECURECORE_CONTEXT          *f_pSecureCoreCtx,
+    __in_opt                                DRM_SECSTORE_CONTEXT            *f_pcontextSST,
+    __in_opt                                DRM_DST                         *f_pDatastore ) DRM_NO_INLINE_ATTRIBUTE;
+
+EXIT_PK_NAMESPACE;
+
+#endif /* __DRMBCRL_H__ */
+
+
diff --git a/prebuilt-v4.4/noarch/include/drmbcrltypes.h b/prebuilt-v4.4/noarch/include/drmbcrltypes.h
new file mode 100644
index 0000000..007a040
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmbcrltypes.h
@@ -0,0 +1,53 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __DRMBCRLTYPES_H__
+#define __DRMBCRLTYPES_H__
+
+#include <drmrevocationtypes.h>
+#include <oemeccp256.h>
+
+ENTER_PK_NAMESPACE;
+
+#define PLAYREADY_DRM_BCRL_SIGNATURE_TYPE 1
+
+typedef DRM_BYTE DRM_CrlIdentifier[16];
+
+typedef struct __tagDRM_BCRL
+{
+    DRM_CrlIdentifier    Identifier;
+    DRM_DWORD            dwVersion;
+    DRM_DWORD            cRevocationEntries;
+    DRM_RevocationEntry *Entries;
+} DRM_BCRL;
+
+/*
+** The following byte value should be equal to the largest signature length supported
+*/
+#define DRM_BCRL_MAX_SIGNATURE_DATA_LENGTH   sizeof( SIGNATURE_P256 )
+
+typedef struct _tagDrmBCrlSignatureData
+{
+    DRM_BYTE    bType;
+    DRM_WORD    cb;
+    DRM_BYTE    rgb[ DRM_BCRL_MAX_SIGNATURE_DATA_LENGTH ];
+} DRM_BCRL_SIGNATURE_DATA;
+
+typedef struct __tagDRM_BCRL_Signed
+{
+    DRM_BCRL                 Crl;
+    DRM_BCRL_SIGNATURE_DATA  Signature;
+    DRM_BYTE                *pbCertificateChain;
+    DRM_DWORD                cbCertificateChain;
+} DRM_BCRL_Signed;
+
+EXIT_PK_NAMESPACE;
+
+#endif /* __DRMBCRLTYPES_H__ */
+
+
diff --git a/prebuilt-v4.4/noarch/include/drmblackboxtypes.h b/prebuilt-v4.4/noarch/include/drmblackboxtypes.h
new file mode 100644
index 0000000..35a1452
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmblackboxtypes.h
@@ -0,0 +1,84 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __DRMBLACKBOXTYPES_H__
+#define __DRMBLACKBOXTYPES_H__
+
+#include <drmlicense.h>
+#include <drmdomainstoretypes.h>
+#include <drmbcertcachetypes.h>
+#include <drmxmrformattypes.h>
+
+#include <oemcommon.h>
+#include <oemeccp256.h>
+#include <oemcryptoctx.h>
+#include <oemcocktailtypes.h>
+
+ENTER_PK_NAMESPACE;
+
+typedef DRM_OBFUS_FIXED_ALIGN struct __tagDRM_CLIENT_INFO
+{
+    DRM_ANSI_STRING m_dastrClientVersion;
+} DRM_CLIENT_INFO;
+
+#define DRM_HDS_DOMAIN_KEY_RECORD_MAX_SIZE  ( sizeof(DRM_DWORD) + ECC_P256_CIPHERTEXT_SIZE_IN_BYTES + ( 2 * ( sizeof(PUBKEY_P256) + sizeof(PRIVKEY_P256) ) ) )
+
+/*
+** Contains checksum data
+*/
+typedef DRM_OBFUS_FIXED_ALIGN struct __tagDRM_BB_CHECKSUM_CONTEXT
+{
+    DRM_BOOL   m_fIgnoreChecksum;
+    DRM_BYTE   m_rgbChecksumData[DRM_MAX_CHECKSUM];
+    DRM_DWORD  m_cbChecksum;  /* Should be 20 bytes for normal checksum, 24 bytes for V1 header checksum */
+    DRM_KID    m_KID;
+DRM_OBFUS_PTR_TOP
+    DRM_BYTE  *m_pbV1KID;     /* If not NULL then use the old V1 checksum algorithm */
+DRM_OBFUS_PTR_BTM
+} DRM_BB_CHECKSUM_CONTEXT;
+
+typedef DRM_OBFUS_FIXED_ALIGN struct __tagDRM_XMR_BINDING_INFO
+{
+DRM_OBFUS_PTR_TOP
+    DRM_XMRFORMAT_CONTENT_KEY      *m_pxmrContentKey;
+DRM_OBFUS_PTR_BTM
+DRM_OBFUS_PTR_TOP
+    DRM_XMRFORMAT_DEVICE_KEY       *m_pxmrDeviceEccKey;
+DRM_OBFUS_PTR_BTM
+DRM_OBFUS_PTR_TOP
+    DRM_XMRFORMAT_SIGNATURE        *m_pxmrSignature;
+DRM_OBFUS_PTR_BTM
+DRM_OBFUS_PTR_TOP
+    DRM_XMRFORMAT_DOMAIN_ID        *m_pxmrDomainID;
+DRM_OBFUS_PTR_BTM
+DRM_OBFUS_PTR_TOP
+    DRM_XMRFORMAT                  *m_pxmrLicense;    /* An HMAC signature of this license will be calculated and compared to m_pbSignature */
+DRM_OBFUS_PTR_BTM
+
+
+DRM_OBFUS_PTR_TOP
+    DRM_DOMAINSTORE_CONTEXT        *m_pDomainStoreContext;
+DRM_OBFUS_PTR_BTM
+    DRM_DWORD                       m_cbDomainKeyRecord;
+    DRM_BYTE                        m_rgbDomainKeyRecord[DRM_HDS_DOMAIN_KEY_RECORD_MAX_SIZE];
+} DRM_XMR_BINDING_INFO;
+
+typedef DRM_OBFUS_FIXED_ALIGN struct __tagDRM_BINDING_INFO
+{
+    DRM_BB_CHECKSUM_CONTEXT m_oChecksum;   /* Contains Checksum data */
+
+    union
+    {
+        DRM_XMR_BINDING_INFO m_XMR;
+    } m_BindingInfo;
+} DRM_BINDING_INFO;
+
+EXIT_PK_NAMESPACE;
+
+#endif /* __DRMBLACKBOXTYPES_H__ */
+
diff --git a/prebuilt-v4.4/noarch/include/drmblobcache.h b/prebuilt-v4.4/noarch/include/drmblobcache.h
new file mode 100644
index 0000000..bb46002
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmblobcache.h
@@ -0,0 +1,40 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __DRMBLOBCACHE_H__
+#define __DRMBLOBCACHE_H__
+
+#include <drmsecurecoretypes.h>
+#include <drmsecurestoretypes.h>
+#include <drmdatastoretypes.h>
+
+ENTER_PK_NAMESPACE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_BLOBCACHE_Verify(
+    __inout_opt                         DRM_SECURECORE_CONTEXT  *f_pSecureCoreCtx,
+    __in_opt                            DRM_SECSTORE_CONTEXT    *f_poSecStoreContext,
+    __in_opt                            DRM_DST                 *f_poDatastoreHDS,
+    __in_ecount( f_cbBlob1 )      const DRM_BYTE                *f_pbBlob1,
+    __in                                DRM_DWORD                f_cbBlob1,
+    __in_ecount_opt( f_cbBlob2 )  const DRM_BYTE                *f_pbBlob2,
+    __in                                DRM_DWORD                f_cbBlob2,
+    __out                               DRM_BOOL                *f_pfResult ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_BLOBCACHE_Update(
+    __inout                             DRM_SECURECORE_CONTEXT  *f_pSecureCoreCtx,
+    __in                                DRM_SECSTORE_CONTEXT    *f_poSecStoreContext,
+    __in                                DRM_DST                 *f_poDatastoreHDS,
+    __in_ecount( f_cbBlob1 )      const DRM_BYTE                *f_pbBlob1,
+    __in                                DRM_DWORD                f_cbBlob1,
+    __in_ecount_opt( f_cbBlob2 )  const DRM_BYTE                *f_pbBlob2,
+    __in                                DRM_DWORD                f_cbBlob2 ) DRM_NO_INLINE_ATTRIBUTE;
+
+EXIT_PK_NAMESPACE;
+
+#endif /* __DRMBLOBCACHE_H__ */
+
diff --git a/prebuilt-v4.4/noarch/include/drmbuild_linux.h b/prebuilt-v4.4/noarch/include/drmbuild_linux.h
new file mode 100644
index 0000000..15cf81c
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmbuild_linux.h
@@ -0,0 +1,118 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+/*
+** This file includes the #defines normally set by a profile.
+** It should be #included at the top of drmfeatures.h if you
+** are not using the provided .mk files.
+*/
+
+#ifndef __DRMPROFILEOEMTEEMK_H__
+#define __DRMPROFILEOEMTEEMK_H__
+
+#ifndef DRM_BUILD_PROFILE
+#define DRM_BUILD_PROFILE 13
+#endif /* DRM_BUILD_PROFILE */
+
+#ifndef DRM_ACTIVATION_PLATFORM
+#define DRM_ACTIVATION_PLATFORM 0
+#endif /* DRM_ACTIVATION_PLATFORM */
+
+#ifndef DRM_SUPPORT_FILE_LOCKING
+#define DRM_SUPPORT_FILE_LOCKING 0
+#endif /* DRM_SUPPORT_FILE_LOCKING */
+
+#ifndef DRM_SUPPORT_MULTI_THREADING
+#define DRM_SUPPORT_MULTI_THREADING 0
+#endif /* DRM_SUPPORT_MULTI_THREADING */
+
+#ifndef DRM_SUPPORT_ECCPROFILING
+#define DRM_SUPPORT_ECCPROFILING 1
+#endif /* DRM_SUPPORT_ECCPROFILING */
+
+#ifndef DRM_SUPPORT_INLINEDWORDCPY
+#define DRM_SUPPORT_INLINEDWORDCPY 0
+#endif /* DRM_SUPPORT_INLINEDWORDCPY */
+
+#ifndef DRM_SUPPORT_DATASTORE_PREALLOC
+#define DRM_SUPPORT_DATASTORE_PREALLOC 1
+#endif /* DRM_SUPPORT_DATASTORE_PREALLOC */
+
+#ifndef DRM_SUPPORT_NATIVE_64BIT_TYPES
+#define DRM_SUPPORT_NATIVE_64BIT_TYPES 1
+#endif /* DRM_SUPPORT_NATIVE_64BIT_TYPES */
+
+#ifndef DRM_SUPPORT_FORCE_ALIGN
+#define DRM_SUPPORT_FORCE_ALIGN 0
+#endif /* DRM_SUPPORT_FORCE_ALIGN */
+
+#ifndef DRM_SUPPORT_ASSEMBLY
+#define DRM_SUPPORT_ASSEMBLY 1
+#endif /* DRM_SUPPORT_ASSEMBLY */
+
+#ifndef DRM_SUPPORT_PRECOMPUTE_GTABLE
+#define DRM_SUPPORT_PRECOMPUTE_GTABLE 0
+#endif /* DRM_SUPPORT_PRECOMPUTE_GTABLE */
+
+/********************************************************************************
+**
+** Refer to comments in DrmOverrideFeatureDefaults.mk for details on
+** each DRM_SUPPORT_TEE option and what it means.
+**
+********************************************************************************/
+#ifndef DRM_SUPPORT_TEE
+#define DRM_SUPPORT_TEE 3
+#endif /* DRM_SUPPORT_TEE */
+
+#ifndef DRM_SUPPORT_TRACING
+#define DRM_SUPPORT_TRACING 0
+#endif /* DRM_SUPPORT_TRACING */
+
+#ifndef _DATASTORE_WRITE_THRU
+#define _DATASTORE_WRITE_THRU 1
+#endif /* _DATASTORE_WRITE_THRU */
+
+#ifndef _ADDLICENSE_WRITE_THRU
+#define _ADDLICENSE_WRITE_THRU 0
+#endif /* _ADDLICENSE_WRITE_THRU */
+
+#ifndef DRM_HDS_COPY_BUFFER_SIZE
+#define DRM_HDS_COPY_BUFFER_SIZE 32768
+#endif /* DRM_HDS_COPY_BUFFER_SIZE */
+
+#ifndef DRM_SUPPORT_TOOLS_NET_IO
+#define DRM_SUPPORT_TOOLS_NET_IO 0
+#endif /* DRM_SUPPORT_TOOLS_NET_IO */
+
+#ifndef DRM_TEST_SUPPORT_ACTIVATION
+#define DRM_TEST_SUPPORT_ACTIVATION 0
+#endif /* DRM_TEST_SUPPORT_ACTIVATION */
+
+#ifndef USE_PK_NAMESPACES
+#define USE_PK_NAMESPACES 0
+#endif /* USE_PK_NAMESPACES */
+
+#ifndef DRM_INCLUDE_PK_NAMESPACE_USING_STATEMENT
+#define DRM_INCLUDE_PK_NAMESPACE_USING_STATEMENT 0
+#endif /* DRM_INCLUDE_PK_NAMESPACE_USING_STATEMENT */
+
+#ifndef DRM_COMPILE_FOR_NORMAL_WORLD
+#define DRM_COMPILE_FOR_NORMAL_WORLD 1
+#endif /* DRM_COMPILE_FOR_NORMAL_WORLD */
+
+#ifndef DRM_COMPILE_FOR_SECURE_WORLD
+#define DRM_COMPILE_FOR_SECURE_WORLD 0
+#endif /* DRM_COMPILE_FOR_SECURE_WORLD */
+
+#ifndef DRM_NO_OPT
+#define DRM_NO_OPT 0
+#endif /* DRM_NO_OPT */
+
+
+#endif /* __DRMPROFILEOEMTEEMK_H__ */
+
diff --git a/prebuilt-v4.4/noarch/include/drmbuild_oem.h b/prebuilt-v4.4/noarch/include/drmbuild_oem.h
new file mode 100644
index 0000000..6f31a68
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmbuild_oem.h
@@ -0,0 +1,118 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+/*
+** This file includes the #defines normally set by a profile.
+** It should be #included at the top of drmfeatures.h if you
+** are not using the provided .mk files.
+*/
+
+#ifndef __DRMPROFILEOEMMK_H__
+#define __DRMPROFILEOEMMK_H__
+
+#ifndef DRM_BUILD_PROFILE
+#define DRM_BUILD_PROFILE 10
+#endif /* DRM_BUILD_PROFILE */
+
+#ifndef DRM_ACTIVATION_PLATFORM
+#define DRM_ACTIVATION_PLATFORM 0
+#endif /* DRM_ACTIVATION_PLATFORM */
+
+#ifndef DRM_SUPPORT_FILE_LOCKING
+#define DRM_SUPPORT_FILE_LOCKING 0
+#endif /* DRM_SUPPORT_FILE_LOCKING */
+
+#ifndef DRM_SUPPORT_MULTI_THREADING
+#define DRM_SUPPORT_MULTI_THREADING 0
+#endif /* DRM_SUPPORT_MULTI_THREADING */
+
+#ifndef DRM_SUPPORT_ECCPROFILING
+#define DRM_SUPPORT_ECCPROFILING 1
+#endif /* DRM_SUPPORT_ECCPROFILING */
+
+#ifndef DRM_SUPPORT_INLINEDWORDCPY
+#define DRM_SUPPORT_INLINEDWORDCPY 0
+#endif /* DRM_SUPPORT_INLINEDWORDCPY */
+
+#ifndef DRM_SUPPORT_DATASTORE_PREALLOC
+#define DRM_SUPPORT_DATASTORE_PREALLOC 1
+#endif /* DRM_SUPPORT_DATASTORE_PREALLOC */
+
+#ifndef DRM_SUPPORT_NATIVE_64BIT_TYPES
+#define DRM_SUPPORT_NATIVE_64BIT_TYPES 1
+#endif /* DRM_SUPPORT_NATIVE_64BIT_TYPES */
+
+#ifndef DRM_SUPPORT_FORCE_ALIGN
+#define DRM_SUPPORT_FORCE_ALIGN 0
+#endif /* DRM_SUPPORT_FORCE_ALIGN */
+
+#ifndef DRM_SUPPORT_ASSEMBLY
+#define DRM_SUPPORT_ASSEMBLY 1
+#endif /* DRM_SUPPORT_ASSEMBLY */
+
+#ifndef DRM_SUPPORT_PRECOMPUTE_GTABLE
+#define DRM_SUPPORT_PRECOMPUTE_GTABLE 0
+#endif /* DRM_SUPPORT_PRECOMPUTE_GTABLE */
+
+/********************************************************************************
+**
+** Refer to comments in DrmOverrideFeatureDefaults.mk for details on
+** each DRM_SUPPORT_TEE option and what it means.
+**
+********************************************************************************/
+#ifndef DRM_SUPPORT_TEE
+#define DRM_SUPPORT_TEE 2
+#endif /* DRM_SUPPORT_TEE */
+
+#ifndef DRM_SUPPORT_TRACING
+#define DRM_SUPPORT_TRACING 0
+#endif /* DRM_SUPPORT_TRACING */
+
+#ifndef _DATASTORE_WRITE_THRU
+#define _DATASTORE_WRITE_THRU 1
+#endif /* _DATASTORE_WRITE_THRU */
+
+#ifndef _ADDLICENSE_WRITE_THRU
+#define _ADDLICENSE_WRITE_THRU 0
+#endif /* _ADDLICENSE_WRITE_THRU */
+
+#ifndef DRM_HDS_COPY_BUFFER_SIZE
+#define DRM_HDS_COPY_BUFFER_SIZE 32768
+#endif /* DRM_HDS_COPY_BUFFER_SIZE */
+
+#ifndef DRM_SUPPORT_TOOLS_NET_IO
+#define DRM_SUPPORT_TOOLS_NET_IO 0
+#endif /* DRM_SUPPORT_TOOLS_NET_IO */
+
+#ifndef DRM_TEST_SUPPORT_ACTIVATION
+#define DRM_TEST_SUPPORT_ACTIVATION 0
+#endif /* DRM_TEST_SUPPORT_ACTIVATION */
+
+#ifndef USE_PK_NAMESPACES
+#define USE_PK_NAMESPACES 0
+#endif /* USE_PK_NAMESPACES */
+
+#ifndef DRM_INCLUDE_PK_NAMESPACE_USING_STATEMENT
+#define DRM_INCLUDE_PK_NAMESPACE_USING_STATEMENT 0
+#endif /* DRM_INCLUDE_PK_NAMESPACE_USING_STATEMENT */
+
+#ifndef DRM_COMPILE_FOR_NORMAL_WORLD
+#define DRM_COMPILE_FOR_NORMAL_WORLD 1
+#endif /* DRM_COMPILE_FOR_NORMAL_WORLD */
+
+#ifndef DRM_COMPILE_FOR_SECURE_WORLD
+#define DRM_COMPILE_FOR_SECURE_WORLD 0
+#endif /* DRM_COMPILE_FOR_SECURE_WORLD */
+
+#ifndef DRM_NO_OPT
+#define DRM_NO_OPT 0
+#endif /* DRM_NO_OPT */
+
+
+#endif /* __DRMPROFILEOEMMK_H__ */
+
diff --git a/prebuilt-v4.4/noarch/include/drmbuild_oemplayonly.h b/prebuilt-v4.4/noarch/include/drmbuild_oemplayonly.h
new file mode 100644
index 0000000..7d95138
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmbuild_oemplayonly.h
@@ -0,0 +1,125 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+/*
+** This file includes the #defines normally set by a profile.
+** It should be #included at the top of drmfeatures.h if you
+** are not using the provided .mk files.
+*/
+
+#ifndef __DRMPROFILEOEMPLAYONLYMK_H__
+#define __DRMPROFILEOEMPLAYONLYMK_H__
+
+/********************************************************************************
+**
+** MICROSOFT INTERNAL PROFILE
+** This profile, in spite of its name, is included as part of the PK MSI
+** for Microsoft-internal reasons.  You should NOT use this profile.
+**
+********************************************************************************/
+#ifndef DRM_BUILD_PROFILE
+#define DRM_BUILD_PROFILE 11
+#endif /* DRM_BUILD_PROFILE */
+
+#ifndef DRM_ACTIVATION_PLATFORM
+#define DRM_ACTIVATION_PLATFORM 0
+#endif /* DRM_ACTIVATION_PLATFORM */
+
+#ifndef DRM_SUPPORT_FILE_LOCKING
+#define DRM_SUPPORT_FILE_LOCKING 0
+#endif /* DRM_SUPPORT_FILE_LOCKING */
+
+#ifndef DRM_SUPPORT_MULTI_THREADING
+#define DRM_SUPPORT_MULTI_THREADING 0
+#endif /* DRM_SUPPORT_MULTI_THREADING */
+
+#ifndef DRM_SUPPORT_ECCPROFILING
+#define DRM_SUPPORT_ECCPROFILING 1
+#endif /* DRM_SUPPORT_ECCPROFILING */
+
+#ifndef DRM_SUPPORT_INLINEDWORDCPY
+#define DRM_SUPPORT_INLINEDWORDCPY 0
+#endif /* DRM_SUPPORT_INLINEDWORDCPY */
+
+#ifndef DRM_SUPPORT_DATASTORE_PREALLOC
+#define DRM_SUPPORT_DATASTORE_PREALLOC 1
+#endif /* DRM_SUPPORT_DATASTORE_PREALLOC */
+
+#ifndef DRM_SUPPORT_NATIVE_64BIT_TYPES
+#define DRM_SUPPORT_NATIVE_64BIT_TYPES 1
+#endif /* DRM_SUPPORT_NATIVE_64BIT_TYPES */
+
+#ifndef DRM_SUPPORT_FORCE_ALIGN
+#define DRM_SUPPORT_FORCE_ALIGN 0
+#endif /* DRM_SUPPORT_FORCE_ALIGN */
+
+#ifndef DRM_SUPPORT_ASSEMBLY
+#define DRM_SUPPORT_ASSEMBLY 1
+#endif /* DRM_SUPPORT_ASSEMBLY */
+
+#ifndef DRM_SUPPORT_PRECOMPUTE_GTABLE
+#define DRM_SUPPORT_PRECOMPUTE_GTABLE 0
+#endif /* DRM_SUPPORT_PRECOMPUTE_GTABLE */
+
+/********************************************************************************
+**
+** Refer to comments in DrmOverrideFeatureDefaults.mk for details on
+** each DRM_SUPPORT_TEE option and what it means.
+**
+********************************************************************************/
+#ifndef DRM_SUPPORT_TEE
+#define DRM_SUPPORT_TEE 2
+#endif /* DRM_SUPPORT_TEE */
+
+#ifndef DRM_SUPPORT_TRACING
+#define DRM_SUPPORT_TRACING 0
+#endif /* DRM_SUPPORT_TRACING */
+
+#ifndef _DATASTORE_WRITE_THRU
+#define _DATASTORE_WRITE_THRU 1
+#endif /* _DATASTORE_WRITE_THRU */
+
+#ifndef _ADDLICENSE_WRITE_THRU
+#define _ADDLICENSE_WRITE_THRU 0
+#endif /* _ADDLICENSE_WRITE_THRU */
+
+#ifndef DRM_HDS_COPY_BUFFER_SIZE
+#define DRM_HDS_COPY_BUFFER_SIZE 32768
+#endif /* DRM_HDS_COPY_BUFFER_SIZE */
+
+#ifndef DRM_SUPPORT_TOOLS_NET_IO
+#define DRM_SUPPORT_TOOLS_NET_IO 0
+#endif /* DRM_SUPPORT_TOOLS_NET_IO */
+
+#ifndef DRM_TEST_SUPPORT_ACTIVATION
+#define DRM_TEST_SUPPORT_ACTIVATION 0
+#endif /* DRM_TEST_SUPPORT_ACTIVATION */
+
+#ifndef USE_PK_NAMESPACES
+#define USE_PK_NAMESPACES 0
+#endif /* USE_PK_NAMESPACES */
+
+#ifndef DRM_INCLUDE_PK_NAMESPACE_USING_STATEMENT
+#define DRM_INCLUDE_PK_NAMESPACE_USING_STATEMENT 0
+#endif /* DRM_INCLUDE_PK_NAMESPACE_USING_STATEMENT */
+
+#ifndef DRM_COMPILE_FOR_NORMAL_WORLD
+#define DRM_COMPILE_FOR_NORMAL_WORLD 1
+#endif /* DRM_COMPILE_FOR_NORMAL_WORLD */
+
+#ifndef DRM_COMPILE_FOR_SECURE_WORLD
+#define DRM_COMPILE_FOR_SECURE_WORLD 0
+#endif /* DRM_COMPILE_FOR_SECURE_WORLD */
+
+#ifndef DRM_NO_OPT
+#define DRM_NO_OPT 0
+#endif /* DRM_NO_OPT */
+
+
+#endif /* __DRMPROFILEOEMPLAYONLYMK_H__ */
+
diff --git a/prebuilt-v4.4/noarch/include/drmbuild_oemtee.h b/prebuilt-v4.4/noarch/include/drmbuild_oemtee.h
new file mode 100644
index 0000000..11a421a
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmbuild_oemtee.h
@@ -0,0 +1,118 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+/*
+** This file includes the #defines normally set by a profile.
+** It should be #included at the top of drmfeatures.h if you
+** are not using the provided .mk files.
+*/
+
+#ifndef __DRMPROFILEOEMTEEMK_H__
+#define __DRMPROFILEOEMTEEMK_H__
+
+#ifndef DRM_BUILD_PROFILE
+#define DRM_BUILD_PROFILE 13
+#endif /* DRM_BUILD_PROFILE */
+
+#ifndef DRM_ACTIVATION_PLATFORM
+#define DRM_ACTIVATION_PLATFORM 0
+#endif /* DRM_ACTIVATION_PLATFORM */
+
+#ifndef DRM_SUPPORT_FILE_LOCKING
+#define DRM_SUPPORT_FILE_LOCKING 0
+#endif /* DRM_SUPPORT_FILE_LOCKING */
+
+#ifndef DRM_SUPPORT_MULTI_THREADING
+#define DRM_SUPPORT_MULTI_THREADING 0
+#endif /* DRM_SUPPORT_MULTI_THREADING */
+
+#ifndef DRM_SUPPORT_ECCPROFILING
+#define DRM_SUPPORT_ECCPROFILING 1
+#endif /* DRM_SUPPORT_ECCPROFILING */
+
+#ifndef DRM_SUPPORT_INLINEDWORDCPY
+#define DRM_SUPPORT_INLINEDWORDCPY 0
+#endif /* DRM_SUPPORT_INLINEDWORDCPY */
+
+#ifndef DRM_SUPPORT_DATASTORE_PREALLOC
+#define DRM_SUPPORT_DATASTORE_PREALLOC 1
+#endif /* DRM_SUPPORT_DATASTORE_PREALLOC */
+
+#ifndef DRM_SUPPORT_NATIVE_64BIT_TYPES
+#define DRM_SUPPORT_NATIVE_64BIT_TYPES 1
+#endif /* DRM_SUPPORT_NATIVE_64BIT_TYPES */
+
+#ifndef DRM_SUPPORT_FORCE_ALIGN
+#define DRM_SUPPORT_FORCE_ALIGN 0
+#endif /* DRM_SUPPORT_FORCE_ALIGN */
+
+#ifndef DRM_SUPPORT_ASSEMBLY
+#define DRM_SUPPORT_ASSEMBLY 1
+#endif /* DRM_SUPPORT_ASSEMBLY */
+
+#ifndef DRM_SUPPORT_PRECOMPUTE_GTABLE
+#define DRM_SUPPORT_PRECOMPUTE_GTABLE 0
+#endif /* DRM_SUPPORT_PRECOMPUTE_GTABLE */
+
+/********************************************************************************
+**
+** Refer to comments in DrmOverrideFeatureDefaults.mk for details on
+** each DRM_SUPPORT_TEE option and what it means.
+**
+********************************************************************************/
+#ifndef DRM_SUPPORT_TEE
+#define DRM_SUPPORT_TEE 3
+#endif /* DRM_SUPPORT_TEE */
+
+#ifndef DRM_SUPPORT_TRACING
+#define DRM_SUPPORT_TRACING 0
+#endif /* DRM_SUPPORT_TRACING */
+
+#ifndef _DATASTORE_WRITE_THRU
+#define _DATASTORE_WRITE_THRU 1
+#endif /* _DATASTORE_WRITE_THRU */
+
+#ifndef _ADDLICENSE_WRITE_THRU
+#define _ADDLICENSE_WRITE_THRU 0
+#endif /* _ADDLICENSE_WRITE_THRU */
+
+#ifndef DRM_HDS_COPY_BUFFER_SIZE
+#define DRM_HDS_COPY_BUFFER_SIZE 32768
+#endif /* DRM_HDS_COPY_BUFFER_SIZE */
+
+#ifndef DRM_SUPPORT_TOOLS_NET_IO
+#define DRM_SUPPORT_TOOLS_NET_IO 0
+#endif /* DRM_SUPPORT_TOOLS_NET_IO */
+
+#ifndef DRM_TEST_SUPPORT_ACTIVATION
+#define DRM_TEST_SUPPORT_ACTIVATION 0
+#endif /* DRM_TEST_SUPPORT_ACTIVATION */
+
+#ifndef USE_PK_NAMESPACES
+#define USE_PK_NAMESPACES 0
+#endif /* USE_PK_NAMESPACES */
+
+#ifndef DRM_INCLUDE_PK_NAMESPACE_USING_STATEMENT
+#define DRM_INCLUDE_PK_NAMESPACE_USING_STATEMENT 0
+#endif /* DRM_INCLUDE_PK_NAMESPACE_USING_STATEMENT */
+
+#ifndef DRM_COMPILE_FOR_NORMAL_WORLD
+#define DRM_COMPILE_FOR_NORMAL_WORLD 1
+#endif /* DRM_COMPILE_FOR_NORMAL_WORLD */
+
+#ifndef DRM_COMPILE_FOR_SECURE_WORLD
+#define DRM_COMPILE_FOR_SECURE_WORLD 0
+#endif /* DRM_COMPILE_FOR_SECURE_WORLD */
+
+#ifndef DRM_NO_OPT
+#define DRM_NO_OPT 0
+#endif /* DRM_NO_OPT */
+
+
+#endif /* __DRMPROFILEOEMTEEMK_H__ */
+
diff --git a/prebuilt-v4.4/noarch/include/drmbuild_oemteeplayonly.h b/prebuilt-v4.4/noarch/include/drmbuild_oemteeplayonly.h
new file mode 100644
index 0000000..af4b024
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmbuild_oemteeplayonly.h
@@ -0,0 +1,118 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+/*
+** This file includes the #defines normally set by a profile.
+** It should be #included at the top of drmfeatures.h if you
+** are not using the provided .mk files.
+*/
+
+#ifndef __DRMPROFILEOEMTEEPLAYONLYMK_H__
+#define __DRMPROFILEOEMTEEPLAYONLYMK_H__
+
+#ifndef DRM_BUILD_PROFILE
+#define DRM_BUILD_PROFILE 14
+#endif /* DRM_BUILD_PROFILE */
+
+#ifndef DRM_ACTIVATION_PLATFORM
+#define DRM_ACTIVATION_PLATFORM 0
+#endif /* DRM_ACTIVATION_PLATFORM */
+
+#ifndef DRM_SUPPORT_FILE_LOCKING
+#define DRM_SUPPORT_FILE_LOCKING 0
+#endif /* DRM_SUPPORT_FILE_LOCKING */
+
+#ifndef DRM_SUPPORT_MULTI_THREADING
+#define DRM_SUPPORT_MULTI_THREADING 0
+#endif /* DRM_SUPPORT_MULTI_THREADING */
+
+#ifndef DRM_SUPPORT_ECCPROFILING
+#define DRM_SUPPORT_ECCPROFILING 1
+#endif /* DRM_SUPPORT_ECCPROFILING */
+
+#ifndef DRM_SUPPORT_INLINEDWORDCPY
+#define DRM_SUPPORT_INLINEDWORDCPY 0
+#endif /* DRM_SUPPORT_INLINEDWORDCPY */
+
+#ifndef DRM_SUPPORT_DATASTORE_PREALLOC
+#define DRM_SUPPORT_DATASTORE_PREALLOC 1
+#endif /* DRM_SUPPORT_DATASTORE_PREALLOC */
+
+#ifndef DRM_SUPPORT_NATIVE_64BIT_TYPES
+#define DRM_SUPPORT_NATIVE_64BIT_TYPES 1
+#endif /* DRM_SUPPORT_NATIVE_64BIT_TYPES */
+
+#ifndef DRM_SUPPORT_FORCE_ALIGN
+#define DRM_SUPPORT_FORCE_ALIGN 0
+#endif /* DRM_SUPPORT_FORCE_ALIGN */
+
+#ifndef DRM_SUPPORT_ASSEMBLY
+#define DRM_SUPPORT_ASSEMBLY 1
+#endif /* DRM_SUPPORT_ASSEMBLY */
+
+#ifndef DRM_SUPPORT_PRECOMPUTE_GTABLE
+#define DRM_SUPPORT_PRECOMPUTE_GTABLE 0
+#endif /* DRM_SUPPORT_PRECOMPUTE_GTABLE */
+
+/********************************************************************************
+**
+** Refer to comments in DrmOverrideFeatureDefaults.mk for details on
+** each DRM_SUPPORT_TEE option and what it means.
+**
+********************************************************************************/
+#ifndef DRM_SUPPORT_TEE
+#define DRM_SUPPORT_TEE 3
+#endif /* DRM_SUPPORT_TEE */
+
+#ifndef DRM_SUPPORT_TRACING
+#define DRM_SUPPORT_TRACING 0
+#endif /* DRM_SUPPORT_TRACING */
+
+#ifndef _DATASTORE_WRITE_THRU
+#define _DATASTORE_WRITE_THRU 1
+#endif /* _DATASTORE_WRITE_THRU */
+
+#ifndef _ADDLICENSE_WRITE_THRU
+#define _ADDLICENSE_WRITE_THRU 0
+#endif /* _ADDLICENSE_WRITE_THRU */
+
+#ifndef DRM_HDS_COPY_BUFFER_SIZE
+#define DRM_HDS_COPY_BUFFER_SIZE 32768
+#endif /* DRM_HDS_COPY_BUFFER_SIZE */
+
+#ifndef DRM_SUPPORT_TOOLS_NET_IO
+#define DRM_SUPPORT_TOOLS_NET_IO 0
+#endif /* DRM_SUPPORT_TOOLS_NET_IO */
+
+#ifndef DRM_TEST_SUPPORT_ACTIVATION
+#define DRM_TEST_SUPPORT_ACTIVATION 0
+#endif /* DRM_TEST_SUPPORT_ACTIVATION */
+
+#ifndef USE_PK_NAMESPACES
+#define USE_PK_NAMESPACES 0
+#endif /* USE_PK_NAMESPACES */
+
+#ifndef DRM_INCLUDE_PK_NAMESPACE_USING_STATEMENT
+#define DRM_INCLUDE_PK_NAMESPACE_USING_STATEMENT 0
+#endif /* DRM_INCLUDE_PK_NAMESPACE_USING_STATEMENT */
+
+#ifndef DRM_COMPILE_FOR_NORMAL_WORLD
+#define DRM_COMPILE_FOR_NORMAL_WORLD 1
+#endif /* DRM_COMPILE_FOR_NORMAL_WORLD */
+
+#ifndef DRM_COMPILE_FOR_SECURE_WORLD
+#define DRM_COMPILE_FOR_SECURE_WORLD 0
+#endif /* DRM_COMPILE_FOR_SECURE_WORLD */
+
+#ifndef DRM_NO_OPT
+#define DRM_NO_OPT 0
+#endif /* DRM_NO_OPT */
+
+
+#endif /* __DRMPROFILEOEMTEEPLAYONLYMK_H__ */
+
diff --git a/prebuilt-v4.4/noarch/include/drmbytemanip.h b/prebuilt-v4.4/noarch/include/drmbytemanip.h
new file mode 100644
index 0000000..717fba8
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmbytemanip.h
@@ -0,0 +1,33 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __DRM_BYTEMANIP_H__
+#define __DRM_BYTEMANIP_H__
+
+#include <drmcrt.h>
+#include <oembyteorder.h>
+
+ENTER_PK_NAMESPACE;
+
+#define DRM_BYT_CopyBytes(to,tooffset,from,fromoffset,count) DRMCRT_memcpy(&((to)[(tooffset)]),&((from)[(fromoffset)]),(count))
+#define DRM_BYT_MoveBytes(to,tooffset,from,fromoffset,count) DRMCRT_memmove(&((to)[(tooffset)]),&((from)[(fromoffset)]),(count))
+#define DRM_BYT_SetBytes(pb,ib,cb,b) DRMCRT_memset(&((pb)[(ib)]),b,cb)
+#define DRM_BYT_CompareBytes(pbA,ibA,pbB,ibB,cb) DRMCRT_memcmp(&((pbA)[(ibA)]),&((pbB)[(ibB)]),(cb))
+
+#define MEMSET(pb,ch,cb) DRM_BYT_SetBytes(((DRM_BYTE*)(pb)),0,(cb),(ch))
+#define ZEROMEM(pb,cb)   DRM_DO { DRM_BYT_SetBytes(((DRM_BYTE*)(pb)),0,(cb),0); __analysis_assume(((DRM_BYTE*)(pb))[0]==0); } DRM_WHILE_FALSE
+#define MEMCPY(pbTo,pbFrom,cb)  DRM_BYT_CopyBytes(   ((DRM_BYTE*)(pbTo)),0,((DRM_BYTE*)(pbFrom)),0,(cb))
+#define MEMMOVE(pbTo,pbFrom,cb) DRM_BYT_MoveBytes(   ((DRM_BYTE*)(pbTo)),0,((DRM_BYTE*)(pbFrom)),0,(cb))
+#define MEMCMP(pbA,pbB,cb)      DRMCRT_memcmp((pbA) ,(pbB), (cb))
+
+#define DRM_ID_ARE_EQUAL(idA,idB) (0==DRMCRT_memcmp(&(idA),&(idB),sizeof(idA)))
+
+EXIT_PK_NAMESPACE;
+
+#endif /* __DRM_BYTEMANIP_H__ */
+
diff --git a/prebuilt-v4.4/noarch/include/drmcallbacks.h b/prebuilt-v4.4/noarch/include/drmcallbacks.h
new file mode 100644
index 0000000..65879a6
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmcallbacks.h
@@ -0,0 +1,57 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __DRM_CALLBACKS_H__
+#define __DRM_CALLBACKS_H__
+
+#include <drmnamespace.h>   /* defining proper namespace (if used) */
+#include <drmcallbacktypes.h>
+#include <drmtoken.h>
+
+ENTER_PK_NAMESPACE;
+
+typedef enum __tag_DRM_STORE_LICENSE_CALLBACK_ENUM
+{
+    DRM_STORE_LICENSE_NOTIFY_KID            = 1, /* Callbacks with this reason will have pvData as a DRM_CONST_STRING */
+    DRM_STORE_LICENSE_NOTIFY_RESERVED_2     = 2, /* Reserved - Not Supported. */
+    DRM_STORE_LICENSE_NOTIFY_RESERVED_3     = 3, /* Reserved - Not Supported. */
+    DRM_STORE_LICENSE_NOTIFY_RESERVED_4     = 4  /* Reserved - Not Supported. */
+
+} DRM_STORE_LICENSE_CALLBACK_ENUM;
+
+typedef DRM_RESULT (DRM_CALL *pfnLicenseResponseCallback)(
+    __in DRM_VOID                        *pvData,
+    __in DRM_STORE_LICENSE_CALLBACK_ENUM  eReason,
+    __in DRM_VOID                        *pvContext );
+
+typedef struct
+{
+    DRM_CONST_STRING *pdstrAttributeName;
+
+    /* On input contains the token data that now exists on disk, on output the
+    ** callback function should update it to the value that should be stored */
+    TOKEN            *pOnDisk;
+
+    /* Contains the data that was originally intended to be stored during Bind */
+    TOKEN            *pOriginallyIntendedValue;
+
+    /* If TRUE, indicates that during Bind the token didn't exist on disk
+    ** so another instance must have created this attribute as well */
+    DRM_BOOL          fNewAttribute;
+
+    /*
+    ** Right ID and restriction ID the secure store entry is associated with
+    */
+    DRM_WORD          wRightID;
+    DRM_WORD          wRestrictionID;
+
+} DRM_SECURE_STATE_TOKEN_RESOLVE_DATA;
+
+EXIT_PK_NAMESPACE;
+
+#endif
diff --git a/prebuilt-v4.4/noarch/include/drmcallbacktypes.h b/prebuilt-v4.4/noarch/include/drmcallbacktypes.h
new file mode 100644
index 0000000..f698205
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmcallbacktypes.h
@@ -0,0 +1,128 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __DRM_CALLBACKTYPES_H__
+#define __DRM_CALLBACKTYPES_H__
+
+#include <drmerr.h>
+#include <drmoutputleveltypes.h>
+#include <drmxmrformattypes.h>
+
+ENTER_PK_NAMESPACE;
+
+typedef enum __tag_DRM_POLICY_CALLBACK_TYPE
+{
+    DRM_PLAY_OPL_CALLBACK                       = 0x1,  /* DRM_PLAY_OPL_3_0                                 */
+    DRM_POLICY_CALLBACK_RESERVED_2              = 0x2,  /* Never called, enum value maintained for compat   */
+    DRM_POLICY_CALLBACK_RESERVED_3              = 0x3,  /* Never called, enum value maintained for compat   */
+    DRM_EXTENDED_RESTRICTION_CONDITION_CALLBACK = 0x4,  /* DRM_EXTENDED_RESTRICTION_CALLBACK_STRUCT         */
+    DRM_EXTENDED_RESTRICTION_ACTION_CALLBACK    = 0x5,  /* DRM_EXTENDED_RESTRICTION_CALLBACK_STRUCT         */
+    DRM_EXTENDED_RESTRICTION_QUERY_CALLBACK     = 0x6,  /* DRM_EXTENDED_RESTRICTION_CALLBACK_STRUCT         */
+    DRM_SECURE_STATE_TOKEN_RESOLVE_CALLBACK     = 0x7,  /* DRM_SECURE_STATE_TOKEN_RESOLVE_DATA              */
+    DRM_RESTRICTED_SOURCEID_CALLBACK            = 0x8,  /* DRM_RESTRICTED_SOURCEID_CALLBACK_STRUCT          */
+    DRM_OEM_KEY_INFO_CALLBACK                   = 0x9,  /* DRM_OEM_KEY_INFO_CALLBACK_STRUCT                 */
+    DRM_ENABLE_LICENSE_REJECTION_CALLBACK       = 0xA,  /* DRM_ENABLE_LICENSE_REJECTION_CALLBACK_STRUCT     */
+} DRM_POLICY_CALLBACK_TYPE;
+
+typedef DRM_RESULT (DRM_CALL* DRMPFNPOLICYCALLBACK)(
+    __in     const DRM_VOID                 *f_pvCallbackData,
+    __in           DRM_POLICY_CALLBACK_TYPE  f_dwCallbackType,
+    __in_opt const DRM_KID                  *f_pKID,            /* KID that is being enumerated, i.e. the KID of the leaf-most license in a chain.  Will be NULL for callbacks not dealing with a license. */
+    __in_opt const DRM_LID                  *f_pLID,            /* LID of the actual license being called upon, i.e. may be leaf or root license in a chain.  Will be NULL for callbacks not dealing with a license. */
+    __in_opt const DRM_VOID                 *f_pv );            /* Void pointer to opaque data passed in alongside the DRMPFNPOLICYCALLBACK parameter which is then passed to the callback, e.g. in Drm_Reader_Bind */
+
+typedef struct
+{
+    DRM_WORD                             wRightID;
+    DRM_XB_UNKNOWN_OBJECT               *pRestriction;
+    DRM_XMRFORMAT                       *pXMRLicense;
+    DRM_VOID                            *pContextSST;   /* DRM_SECSTORE_CONTEXT */
+} DRM_EXTENDED_RESTRICTION_CALLBACK_STRUCT;
+
+typedef struct
+{
+    DRM_DWORD dwSourceID; /* global requirement, no need to pass right ID */
+} DRM_RESTRICTED_SOURCEID_CALLBACK_STRUCT;
+
+typedef struct
+{
+          DRM_DWORD  cb;
+    const DRM_BYTE  *pb;
+} DRM_OEM_KEY_INFO_CALLBACK_STRUCT;
+
+/*
+** Each time a candidate simple license or license chain is located during Drm_Reader_Bind,
+** the policy callback is called for that candidate with f_dwCallbackType equal to
+** DRM_ENABLE_LICENSE_REJECTION_CALLBACK and f_pvCallbackData set to the following structure.
+**
+** The idSession member will match the m_idSession member of the DRM_LICENSE_RESPONSE structure.
+** Cannot-persist licenses will always populate this value.
+** Persistent licenses stored via DRM_CDMI_Update function will always populate this value.
+** Persistent licenses stored via Drm_LicenseAcq_ProcessResponse will only populate this value
+** if the source code from path source\modules\hdssession\real is linked into the PK;
+** persistent session information is otherwise not stored on disk and is unavailable during Bind.
+** When dealing with a license chain, idSession always represents the leaf license's session.
+**
+** Because multiple licenses may be passed into this function (in the case of license chains),
+** both the f_pKID and f_pLID params will be NULL, but you can obtain the KID(s) using the
+** following sample code.  The if block in this sample code will be entered iff the candidate
+** is a license chain (in which case oKID will be set to the leaf KID).
+**
+** BEGIN_SAMPLE_CODE
+**
+** DRM_ENABLE_LICENSE_REJECTION_CALLBACK_STRUCT *pIn = ( (DRM_ENABLE_LICENSE_REJECTION_CALLBACK_STRUCT*)f_pvCallbackData );
+** DRM_KID oKID = DRM_ID_EMPTY;
+** DRMCRT_memcpy( oKID.rgb, pIn->rgXMRLicenses[ 0 ].OuterContainer.KeyMaterialContainer.ContentKey.guidKeyID.rgb, sizeof( oKID.rgb ) );
+** 
+** if( pIn->cXMRLicenses > 1 )
+** {
+**     DRM_KID oKIDRoot = DRM_ID_EMPTY;
+**     DRMCRT_memcpy( oKIDRoot.rgb, pIn->rgXMRLicenses[ 1 ].OuterContainer.KeyMaterialContainer.ContentKey.guidKeyID.rgb, sizeof( oKIDRoot.rgb ) );
+** }
+**
+** END_SAMPLE_CODE
+**
+** If you return an error from a call to this callback, the candidate will be rejected
+** and the search for a viable candidate will continue as if that candidate was unusable
+** for any other reason.
+**
+** You have total control over the conditions under which you reject a candidate.
+**
+** For example, if you have a license with an expiration date in the near future
+** (especially if it has real-time expiration set), but you also know that you've acquired
+** a license with a longer expiration (or no expiration at all), you may wish to reject
+** the shorter duration license if you see it via this callback by returning an error.
+**
+** This callback is called *before* setting up a decryptor in order to avoid that
+** (potentially expensive) operation for any license(s) which you are rejecting.
+**
+** Once you return success from this function for a given candidate, you will
+** not receive callbacks for any remaining candidates unless there is an error setting
+** up the decryptor (in which case the search for a viable candidate will continue).
+**
+** Since the sequence of licenses found during license enumeration is non-deterministic,
+** you are only guaranteed to get a callback for every available candidate if you return
+** an error every time this function is called on a given Drm_Reader_Bind call.
+**
+** If there are multiple leaf and/or root licenses for any given KID, it is possible
+** that any given license will be passed via this callback multiple times.
+** This is because the callback is called for the entire candidate as a unit rather
+** than being called for each license individually so that you can evaluate the
+** unit as a whole rather than having to keep track of the leaf/root separately.
+*/
+typedef struct
+{
+          DRM_DWORD      cXMRLicenses;
+    const DRM_XMRFORMAT *rgXMRLicenses;
+          DRM_ID         idSession;
+} DRM_ENABLE_LICENSE_REJECTION_CALLBACK_STRUCT;
+
+EXIT_PK_NAMESPACE;
+
+#endif /* __DRMCALLBACKTYPES_H__ */
+
diff --git a/prebuilt-v4.4/noarch/include/drmcdmi.h b/prebuilt-v4.4/noarch/include/drmcdmi.h
new file mode 100644
index 0000000..a14b0e2
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmcdmi.h
@@ -0,0 +1,159 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __DRMCDMI_H__
+#define __DRMCDMI_H__
+
+#include <drmcdmitypes.h>
+#include <drmmodulesupport.h>
+
+ENTER_PK_NAMESPACE;
+
+extern DRM_GLOBAL_CONST DRM_CHAR g_rgchPlayReadyCDMSystemID[];
+
+/*
+** Helper methods
+*/
+DRM_NO_INLINE DRM_API_VOID DRM_CDMI_EXCEPTION DRM_CALL DRM_CDMI_MapErrorCodeToExceptionType(
+    __in                                                  DRM_RESULT                              f_dr );
+
+/*
+** MediaKeySystemAccess methods
+*/
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_CDMI_CreateMediaKeySystemAccess(
+    __in_z                                                                         const DRM_CHAR                               *f_pszKeySystem,
+    __inout                                                                              DRM_DWORD                              *f_pcInitDataTypes,
+    _At_buffer_( f_rgpszInitDataTypes, _Iter_, *f_pcInitDataTypes, _Inout_opt_z_ )       DRM_CHAR                              **f_rgpszInitDataTypes,
+    __in_z_opt                                                                     const DRM_CHAR                               *f_pszDistinctiveIdentifierRequested,
+    __out_z_opt                                                                          DRM_CHAR                              **f_ppszDistinctiveIdentifierUsed,
+    __in_z_opt                                                                     const DRM_CHAR                               *f_pszPersistentStateRequested,
+    __out_z_opt                                                                          DRM_CHAR                              **f_ppszPersistentStateUsed,
+    __in                                                                                 DRM_DWORD                               f_cSessionTypes,
+    _At_buffer_( f_rgpszSessionTypes, _Iter_, f_cSessionTypes, _In_opt_z_ )        const DRM_CHAR                              **f_rgpszSessionTypes,
+    __out_ecount( 1 )                                                                    DRM_CDMI_MEDIA_KEY_SYSTEM_ACCESS       *f_pMediaKeySystemAccess );
+
+DRM_NO_INLINE DRM_API_VOID DRM_VOID DRM_CALL DRM_CDMI_DestroyMediaKeySystemAccess(
+    __inout_ecount( 1 )                                           DRM_CDMI_MEDIA_KEY_SYSTEM_ACCESS       *f_pMediaKeySystemAccess );
+
+DRM_NO_INLINE DRM_API_VOID const DRM_CHAR* DRM_CALL DRM_CDMI_GetKeySystem(
+    __in_ecount( 1 )                                        const DRM_CDMI_MEDIA_KEY_SYSTEM_ACCESS       *f_pMediaKeySystemAccess );
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_CDMI_GetConfiguration(
+    __inout_ecount( 1 )                                           DRM_CDMI_MEDIA_KEY_SYSTEM_ACCESS       *f_pMediaKeySystemAccess,
+    __out                                                         DRM_DWORD                              *f_pcInitDataTypes,
+    __deref_out_ecount( *f_pcInitDataTypes )                      DRM_CHAR                             ***f_prgpszInitDataTypes,
+    __out                                                         DRM_CHAR                              **f_ppszDistinctiveIdentifier,
+    __out                                                         DRM_CHAR                              **f_ppszPersistedState,
+    __out                                                         DRM_DWORD                              *f_pcSessionTypes,
+    __deref_out_ecount( *f_pcSessionTypes )                       DRM_CHAR                             ***f_prgpszSessionTypes );
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_CDMI_CreateMediaKeys(
+    __in_ecount( 1 )                                        const DRM_CDMI_MEDIA_KEY_SYSTEM_ACCESS       *f_pMediaKeySystemAccess,
+    __out_ecount( 1 )                                             DRM_CDMI_MEDIA_KEYS                    *f_pMediaKeys );
+
+/*
+** MediaKeys methods
+*/
+DRM_NO_INLINE DRM_API_VOID DRM_VOID DRM_CALL DRM_CDMI_DestroyMediaKeys(
+    __inout_ecount( 1 )                                           DRM_CDMI_MEDIA_KEYS                    *f_pMediaKeys );
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_CDMI_SetServerCertificate(
+    __inout_ecount( 1 )                                           DRM_CDMI_MEDIA_KEYS                    *f_pMediaKeys,
+    __in                                                          DRM_DWORD                               f_cbServerCertificate,
+    __in_ecount( f_cbServerCertificate )                    const DRM_BYTE                               *f_pbServerCertificate );
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_CDMI_CreateMediaKeySession(
+    __in_ecount( 1 )                                        const DRM_CDMI_MEDIA_KEYS                    *f_pMediaKeys,
+    __in_z_opt                                              const DRM_CHAR                               *f_pszSessionType,
+    __in_opt                                                      DRM_VOID                               *f_pOEMContext,
+    __in_z                                                  const DRM_CHAR                               *f_pszDeviceStoreName,
+    __out_ecount( 1 )                                             DRM_CDMI_MEDIA_KEY_SESSION             *f_pMediaKeySession );
+
+/*
+** MediaKeySession methods
+*/
+DRM_NO_INLINE DRM_API_VOID DRM_VOID DRM_CALL DRM_CDMI_DestroyMediaKeySession(
+    __inout_ecount( 1 )                                           DRM_CDMI_MEDIA_KEY_SESSION             *f_pMediaKeySession );
+
+DRM_NO_INLINE DRM_API_VOID const DRM_CHAR* DRM_CALL DRM_CDMI_GetSessionId(
+    __in_ecount( 1 )                                        const DRM_CDMI_MEDIA_KEY_SESSION             *f_pMediaKeySession );
+
+DRM_NO_INLINE DRM_API_VOID DRM_VOID DRM_CALL DRM_CDMI_SetSessionCallbacks(
+    __inout_ecount( 1 )                                           DRM_CDMI_MEDIA_KEY_SESSION             *f_pMediaKeySession,
+    __in_opt                                                      DRM_VOID                               *f_pvCallbackContext,
+    __in_ecount_opt( 1 )                                          PFN_DRM_CDMI_OnCloseCallback            f_pfnOnClose,
+    __in_ecount_opt( 1 )                                          PFN_DRM_CDMI_OnKeyStatusChangeCallback  f_pfnOnKeyStatusChange,
+    __in_ecount_opt( 1 )                                          PFN_DRM_CDMI_OnKeyMessageCallback       f_pfnOnKeyMessage );
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_CDMI_GetExpiration(
+    __in_ecount( 1 )                                              DRM_CDMI_MEDIA_KEY_SESSION             *f_pMediaKeySession,
+    __out                                                         DRM_UINT64                             *f_pui64Expiration );
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_CDMI_GetMediaKeyCount(
+    __in_ecount( 1 )                                        const DRM_CDMI_MEDIA_KEY_SESSION             *f_pMediaKeySession,
+    __out                                                         DRM_DWORD                              *f_pcMediaKeys );
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_CDMI_GetMediaKeyStatus(
+    __in_ecount( 1 )                                              DRM_CDMI_MEDIA_KEY_SESSION             *f_pMediaKeySession,
+    __inout_opt                                                   DRM_DWORD                              *f_piMediaKey,
+    __inout_opt                                                   DRM_ID                                 *f_pKeyId,
+    __out_opt                                                     DRM_BOOL                               *f_pfHasKey,
+    __out_opt                                                     DRM_CDMI_KEY_STATUS                    *f_peKeyStatus );
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_CDMI_GenerateRequest(
+    __inout_ecount( 1 )                                           DRM_CDMI_MEDIA_KEY_SESSION             *f_pMediaKeySession,
+    __in_z                                                  const DRM_CHAR                               *f_pszInitDataType,
+    __in                                                          DRM_DWORD                               f_cbInitData,
+    __in_ecount( f_cbInitData )                             const DRM_BYTE                               *f_pbInitData );
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_CDMI_Load(
+    __inout_ecount( 1 )                                           DRM_CDMI_MEDIA_KEY_SESSION             *f_pMediaKeySession,
+    __in_z                                                  const DRM_CHAR                               *f_pszSessionId,
+    __in_opt                                                      DRMPFNPOLICYCALLBACK                    f_pfnPolicyCallback,
+    __in_opt                                                const DRM_VOID                               *f_pvPolicyCallbackContext );
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_CDMI_Update(
+    __inout_ecount( 1 )                                           DRM_CDMI_MEDIA_KEY_SESSION             *f_pMediaKeySession,
+    __in_opt                                                      DRMPFNPOLICYCALLBACK                    f_pfnPolicyCallback,
+    __in_opt                                                const DRM_VOID                               *f_pvPolicyCallbackContext,
+    __in                                                          DRM_DWORD                               f_cbResponse,
+    __in_ecount( f_cbResponse )                             const DRM_BYTE                               *f_pbResponse );
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_CDMI_Close(
+    __inout_ecount( 1 )                                           DRM_CDMI_MEDIA_KEY_SESSION             *f_pMediaKeySession );
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_CDMI_Remove(
+    __inout_ecount( 1 )                                           DRM_CDMI_MEDIA_KEY_SESSION             *f_pMediaKeySession );
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_CDMI_DecryptOpaque(
+    __inout_ecount( 1 )                                           DRM_CDMI_MEDIA_KEY_SESSION             *f_pMediaKeySession,
+    __in                                                    const DRM_ID                                 *f_pKeyId,
+    __in                                                          DRM_UINT64                              f_ui64InitializationVectorHigh,
+    __in                                                          DRM_UINT64                              f_ui64InitializationVectorLow,
+    __in                                                          DRM_DWORD                               f_cEncryptedRegionMappings,
+    __in_ecount( f_cEncryptedRegionMappings )               const DRM_DWORD                              *f_pEncryptedRegionMappings,
+    __in                                                          DRM_DWORD                               f_cEncryptedRegionSkip,
+    __in_ecount_opt( f_cEncryptedRegionSkip )               const DRM_DWORD                              *f_pEncryptedRegionSkip,
+    __in                                                          DRM_DWORD                               f_cbEncryptedContent,
+    __in_bcount( f_cbEncryptedContent )                     const DRM_BYTE                               *f_pbEncryptedContent,
+    __out                                                         DRM_DWORD                              *f_pcbOpaqueClearContent,
+    __deref_out_bcount( *f_pcbOpaqueClearContent )                DRM_BYTE                              **f_ppbOpaqueClearContent );
+
+DRM_NO_INLINE DRM_API_VOID DRM_VOID DRM_CALL DRM_CDMI_FreeOpaqueDecryptedContent(
+    __inout_ecount( 1 )                                           DRM_CDMI_MEDIA_KEY_SESSION             *f_pMediaKeySession,
+    __in                                                    const DRM_ID                                 *f_pKeyId,
+    __in                                                          DRM_DWORD                               f_cbOpaqueClearContent,
+    __inout_bcount( f_cbOpaqueClearContent )                      DRM_BYTE                               *f_pbOpaqueClearContent );
+
+DRM_NO_INLINE DRM_API_VOID DRM_APP_CONTEXT* DRM_CALL DRM_CDMI_GetSessionAppContext(
+    __inout_ecount( 1 )                                           DRM_CDMI_MEDIA_KEY_SESSION             *f_pMediaKeySession );
+
+EXIT_PK_NAMESPACE;
+
+#endif /*__DRMCDMI_H__ */
+
diff --git a/prebuilt-v4.4/noarch/include/drmcdmiimpl.h b/prebuilt-v4.4/noarch/include/drmcdmiimpl.h
new file mode 100644
index 0000000..7ad1e40
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmcdmiimpl.h
@@ -0,0 +1,47 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __DRMCDMIIMPL_H__
+#define __DRMCDMIIMPL_H__
+
+#include <drmcdmitypes.h>
+#include <drmmodulesupport.h>
+
+ENTER_PK_NAMESPACE;
+
+typedef DRM_VOID( DRM_CALL* DRM_CDMIIMPL_PfnTrace )(
+    __in_opt const DRM_DWORD        *f_pdwPROCount,
+    __in_opt const DRM_CONST_STRING *f_dstrdrmidKidAdded );
+
+/*
+** Helper methods
+*/
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_CDMIIMPL_ParseInitDataKeyIdsJson(
+    __in                                          DRM_DWORD       f_cbInitData,
+    __in_ecount( f_cbInitData )             const DRM_BYTE       *f_pbInitData,
+    __out                                         DRM_DWORD      *f_pcbPRO,
+    __deref_out_ecount( *f_pcbPRO )               DRM_BYTE      **f_ppbPRO );
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_CDMIIMPL_GetPROFromCencInitData(
+    __in                                          DRM_DWORD       f_cbInitData,
+    __in_bcount( f_cbInitData )             const DRM_BYTE       *f_pbInitData,
+    __out                                         DRM_DWORD      *f_pibPRO,
+    __out                                         DRM_DWORD      *f_pcbPRO );
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_CDMIIMPL_MergePROsFromInitData(
+    __in                                          DRM_BOOL                f_fPermissive,
+    __in                                          DRM_CDMIIMPL_PfnTrace   f_pfnTrace,
+    __in                                          DRM_DWORD               f_cbContentInitData,
+    __in_bcount( f_cbContentInitData )      const DRM_BYTE               *f_pbContentInitData,
+    __out                                         DRM_DWORD              *f_pcbMergedPRO,
+    __deref_out_bcount( *f_pcbMergedPRO )         DRM_BYTE              **f_ppbMergedPRO );
+
+EXIT_PK_NAMESPACE;
+
+#endif /*__DRMCDMIIMPL_H__ */
+
diff --git a/prebuilt-v4.4/noarch/include/drmcdmishared.h b/prebuilt-v4.4/noarch/include/drmcdmishared.h
new file mode 100644
index 0000000..c65a2af
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmcdmishared.h
@@ -0,0 +1,63 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __DRMCDMISHARED_H__
+#define __DRMCDMISHARED_H__
+
+#include <drmcdmiimpl.h>
+#include <drmlicacqv3.h>
+
+ENTER_PK_NAMESPACE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_CDMI_HDS_WriteSession(
+    __inout                                           DRM_DST                    *f_pDST,
+    __in                                        const DRM_ID                     *f_pidSession,
+    __in                                              DRM_CDMI_SESSION_TYPE       f_eSessionType,
+    __in                                              DRM_DWORD                   f_cbPRO,
+    __in_ecount_opt( f_cbPRO )                  const DRM_BYTE                   *f_pbPRO,
+    __in                                              DRM_DWORD                   f_cLicenseAcks,
+    __in_ecount( f_cLicenseAcks )               const DRM_LICENSE_ACK            *f_pLicenseAcks );
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_CDMI_HDS_ReadSession(
+    __inout                                           DRM_DST                    *f_pDST,
+    __inout_opt                                       DRM_SECURECORE_CONTEXT     *f_pSecureCore,
+    __inout_opt                                       DRM_SECURESTOP_CONTEXT     *f_pSecureStop,
+    __in                                        const DRM_ID                     *f_pidSession,
+    __in                                              DRM_CDMI_SESSION_TYPE       f_eSessionType,
+    __in                                              DRM_DWORD                   f_cbServerCertificate,
+    __in_ecount_opt( f_cbServerCertificate )    const DRM_BYTE                   *f_pbServerCertificate,
+    __out_opt                                         DRM_BOOL                   *f_pfHasPersistentLicenses,
+    __out_opt                                         DRM_BOOL                   *f_pfHasSecureStopLicenses,
+    __out                                             DRM_DWORD                  *f_pcLicenseAcks,
+    __deref_out_ecount( *f_pcLicenseAcks )            DRM_LICENSE_ACK           **f_ppLicenseAcks,
+    __out_opt                                         DRM_DWORD                  *f_pcbPRO,
+    __deref_opt_out_bcount_opt( *f_pcbPRO )           DRM_BYTE                  **f_ppbPRO,
+    __out                                             DRM_BOOL                   *f_pfRemoveCalled );
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_CDMI_HDS_SetRemoveCalledOnSession(
+    __inout                                           DRM_DST                    *f_pDST,
+    __in                                        const DRM_ID                     *f_pidSession,
+    __in                                              DRM_CDMI_SESSION_TYPE       f_eSessionType );
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_CDMI_HDS_DeleteSession(
+    __inout                                           DRM_DST                    *f_pDST,
+    __in                                        const DRM_ID                     *f_pidSession,
+    __in                                              DRM_CDMI_SESSION_TYPE       f_eSessionType );
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_CDMI_HDS_CleanupSessionRecords(
+     __inout                                           DRM_DST                    *f_pDST );
+
+DRM_API DRM_RESULT DRM_CALL DRM_CDMI_HDS_GetSessionForLicense(
+    _In_                                               DRM_DST                    *f_pDST,
+    _In_                                         const DRM_LID                    *f_pLID,
+    _Out_                                              DRM_ID                     *f_pidSession );
+
+EXIT_PK_NAMESPACE;
+
+#endif /*__DRMCDMISHARED_H__ */
+
diff --git a/prebuilt-v4.4/noarch/include/drmcdmitypes.h b/prebuilt-v4.4/noarch/include/drmcdmitypes.h
new file mode 100644
index 0000000..1648c02
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmcdmitypes.h
@@ -0,0 +1,193 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __DRMCDMITYPES_H__
+#define __DRMCDMITYPES_H__
+
+#include <drmmanagertypes.h>
+#include <drmlicacqv3.h>
+#include <drmbcertformatparser.h>
+
+ENTER_PK_NAMESPACE;
+
+#define DRM_CDMI_MAX_SUPPORTED_INIT_DATA_TYPES  2
+#define DRM_CDMI_MAX_SUPPORTED_SESSION_TYPES    3
+#define DRM_CDMI_CHARS_IN_B64_DRM_ID            ( CCH_BASE64_EQUIV( sizeof( DRM_ID ) ) )
+
+struct __tag_DRM_CDMI_MEDIA_KEY_SESSION;
+typedef struct __tag_DRM_CDMI_MEDIA_KEY_SESSION DRM_CDMI_MEDIA_KEY_SESSION;
+
+typedef DRM_API_VOID DRM_VOID( DRM_CALL *PFN_DRM_CDMI_OnCloseCallback )(
+    __in                                      DRM_CDMI_MEDIA_KEY_SESSION    *f_pMediaKeySession,
+    __in_opt                                  DRM_VOID                      *f_pvCallbackContext );
+typedef DRM_API_VOID DRM_VOID( DRM_CALL *PFN_DRM_CDMI_OnKeyStatusChangeCallback )(
+    __in                                      DRM_CDMI_MEDIA_KEY_SESSION    *f_pMediaKeySession,
+    __in_opt                                  DRM_VOID                      *f_pvCallbackContext );
+typedef DRM_API_VOID DRM_VOID( DRM_CALL *PFN_DRM_CDMI_OnKeyMessageCallback )(
+    __in                                      DRM_CDMI_MEDIA_KEY_SESSION    *f_pMediaKeySession,
+    __in_opt                                  DRM_VOID                      *f_pvCallbackContext,
+    __in_z                              const DRM_CHAR                      *f_pszMediaKeyMessageType,
+    __in                                      DRM_DWORD                      f_cbMediaKeyMessage,
+    __in_ecount( f_cbMediaKeyMessage )        DRM_BYTE                      *f_pbMediaKeyMessage );
+
+/*
+** Note: PlayReady never returns an error which should map to QuotaExceededError.
+** Refer to DRM_CDMI_Load documentation for more information.
+*/
+typedef enum __tag_DRM_CDMI_EXCEPTION
+{
+    DRM_CDMI_EXCEPTION_NOT_SUPPORTED_ERROR,
+    DRM_CDMI_EXCEPTION_INVALID_STATE_ERROR,
+    DRM_CDMI_EXCEPTION_TYPE_ERROR
+} DRM_CDMI_EXCEPTION;
+
+/* Note: used as a bitmask. */
+typedef enum __tag_DRM_CDMI_SESSION_TYPE
+{
+    DRM_CDMI_SESSION_TYPE_TEMPORARY                 = 0x1,
+    DRM_CDMI_SESSION_TYPE_PERSISTENT_USAGE_RECORD   = 0x2,
+    DRM_CDMI_SESSION_TYPE_PERSISTENT_LICENSE        = 0x4,
+} DRM_CDMI_SESSION_TYPE;
+
+#define DRM_CDMI_SESSION_TYPE_COUNT 3
+#define DRM_CDMI_SESSION_TYPE_MASK_TEMPORARY                                    ( DRM_CDMI_SESSION_TYPE_TEMPORARY )
+#define DRM_CDMI_SESSION_TYPE_MASK_TEMPORARY_AND_USAGE_RECORD                   ( DRM_CDMI_SESSION_TYPE_TEMPORARY | DRM_CDMI_SESSION_TYPE_PERSISTENT_USAGE_RECORD )
+#define DRM_CDMI_SESSION_TYPE_MASK_TEMPORARY_AND_USAGE_RECORD_AND_PERSISTENT    ( DRM_CDMI_SESSION_TYPE_TEMPORARY | DRM_CDMI_SESSION_TYPE_PERSISTENT_USAGE_RECORD | DRM_CDMI_SESSION_TYPE_PERSISTENT_LICENSE )
+
+/* Note: These macros work on either an enum or a bitmask */
+#define DRM_CDMI_SESSION_TYPE_ALLOW_TEMPORARY_LICENSES( __eSessionType ) ( ( ( __eSessionType ) & DRM_CDMI_SESSION_TYPE_TEMPORARY ) != 0 )
+#define DRM_CDMI_SESSION_TYPE_ALLOW_SECURESTOP_LICENSES( __eSessionType ) ( ( ( __eSessionType ) & DRM_CDMI_SESSION_TYPE_PERSISTENT_USAGE_RECORD ) != 0 )
+#define DRM_CDMI_SESSION_TYPE_ALLOW_PERSISTENT_LICENSES( __eSessionType ) ( ( ( __eSessionType ) & DRM_CDMI_SESSION_TYPE_PERSISTENT_LICENSE ) != 0 )
+#define DRM_CDMI_SESSION_TYPE_HAS_PERSISTENT_STATE( __eSessionType ) \
+    ( DRM_CDMI_SESSION_TYPE_ALLOW_SECURESTOP_LICENSES( __eSessionType ) || DRM_CDMI_SESSION_TYPE_ALLOW_PERSISTENT_LICENSES( __eSessionType ) )
+
+/*
+** Note: PlayReady never returns emun values which are equivalent
+** to the following strings.
+**
+** "output-restricted"
+** "output-downscaled"
+** "status-pending"
+**
+** However, when PlayReady returns DRM_CDMI_KEY_STATUS_USABLE,
+** the caller should factor in the output protection information
+** sent via the DRMPFNPOLICYCALLBACK parameter passed to other
+** CDMI functions.
+** For example, if PlayReady returns DRM_CDMI_KEY_STATUS_USABLE
+** but the output protection information requires the caller
+** to downscale content based on the caller's knowledge of
+** the state of output protection enforcement in the media
+** pipeline, then instead of sending "usable" to the application,
+** the caller should instead send "output-restricted".
+**
+** Refer to the PlayReady Compliance and Robustness Rules
+** and the EME specification for more information.
+*/
+typedef enum __tag_DRM_CDMI_KEY_STATUS
+{
+    DRM_CDMI_KEY_STATUS_UNDEFINED           = 0,    /*
+                                                    ** An invalid argument, e.g. an unknown KID, was passed to DRM_CDMI_GetMediaKeyStatus.
+                                                    ** Do not include this KID's information in the MediaKeyStatusMap.
+                                                    */
+    DRM_CDMI_KEY_STATUS_PENDING             = 1,    /* Maps to "status-pending" */
+    DRM_CDMI_KEY_STATUS_USABLE              = 2,    /* Maps to "usable" */
+    DRM_CDMI_KEY_STATUS_EXPIRED             = 3,    /* Maps to "expired" */
+    DRM_CDMI_KEY_STATUS_RELEASED            = 4,    /* Maps to "released" */
+    DRM_CDMI_KEY_STATUS_INTERNAL_ERROR      = 5,    /* Maps to "internal-error" */
+} DRM_CDMI_KEY_STATUS;
+
+typedef struct __tag_DRM_CDMI_KEY_STATUS_WITH_ERROR
+{
+    DRM_CDMI_KEY_STATUS eStatus;
+    DRM_RESULT          drStatus;
+} DRM_CDMI_KEY_STATUS_WITH_ERROR;
+
+typedef struct __tag_DRM_CDMI_MEDIA_KEY_SYSTEM_ACCESS
+{
+    DRM_DWORD    dwSessionTypesAllowedMask;
+    DRM_DWORD    cSupportedInitDataTypes;
+    DRM_CHAR    *rgszSupportedInitDataTypes[ DRM_CDMI_MAX_SUPPORTED_INIT_DATA_TYPES ];
+    DRM_DWORD    cSupportedSessionTypes;
+    DRM_CHAR    *rgszSupportedSessionTypes[ DRM_CDMI_MAX_SUPPORTED_SESSION_TYPES ];
+} DRM_CDMI_MEDIA_KEY_SYSTEM_ACCESS;
+
+typedef struct __tag_DRM_CDMI_CERT_DATA
+{
+    DRM_DWORD                        cbServerCertificate;
+    DRM_BYTE                        *pbServerCertificate;
+} DRM_CDMI_CERT_DATA;
+
+typedef struct __tag_DRM_CDMI_MEDIA_KEYS
+{
+    DRM_DWORD           dwSessionTypesAllowedMask;
+    DRM_CDMI_CERT_DATA  oCertData;
+} DRM_CDMI_MEDIA_KEYS;
+
+typedef struct __tag_DRM_CDMI_MEDIA_KEY_SESSION_CALLBACKS
+{
+    DRM_VOID                               *pvCallbackContext;
+    PFN_DRM_CDMI_OnCloseCallback            pfnOnClose;
+    PFN_DRM_CDMI_OnKeyStatusChangeCallback  pfnKeyStatusChange;
+    PFN_DRM_CDMI_OnKeyMessageCallback       pfnOnKeyMessage;
+} DRM_CDMI_MEDIA_KEY_SESSION_CALLBACKS;
+
+typedef struct __tag_DRM_CDMI_APP_CONTEXT_STATE
+{
+    DRM_APP_CONTEXT         oAppContext;
+    DRM_VOID               *pOEMContext;
+    DRM_BYTE                rgbAppContextOpaqueBuffer[ MINIMUM_APPCONTEXT_OPAQUE_BUFFER_SIZE ];
+    DRM_BYTE                rgbAppContextRevocationBuffer[ REVOCATION_BUFFER_SIZE ];
+} DRM_CDMI_APP_CONTEXT_STATE;
+
+typedef struct __tag_DRM_CDMI_DECRYPTOR
+{
+    DRM_DECRYPT_CONTEXT     oDecryptContext;
+    DRM_BOOL                fCommitted;
+} DRM_CDMI_DECRYPTOR;
+
+typedef struct __tag_DRM_CDMI_LICENSE_STATE
+{
+    DRM_LICENSE_RESPONSE                 oLicenseResponse;          /* oLicenseResponse.m_pAcks member may be allocated, if so will be freed when session is destroyed */
+    DRM_LICENSE_ACK                     *pAcks;                     /* Will equal oLicenseResponse.m_rgoAcks or oLicenseResponse.m_pAcks, should not be freed */
+    DRM_DWORD                            cLicenses;                 /* Will equal oLicenseResponse.m_cAcks */
+    DRM_BOOL                             fBound;                    /* TRUE if currently bound to a license, FALSE otherwise */
+    DRM_DWORD                            iBound;                    /* if( fBound), index of license currently bound */
+    DRM_CDMI_DECRYPTOR                  *pDecryptors;               /* Size will equal cLicenses, will be freed when session is destroyed */
+    DRMPFNPOLICYCALLBACK                 pfnPolicyCallback;
+    const DRM_VOID                      *pvPolicyCallbackContext;
+    DRM_UINT64                           ui64Expiration;
+    DRM_CDMI_KEY_STATUS_WITH_ERROR      *pKeyStatusesWithErrors;    /* Size will equal cLicenses, will be freed when session is destroyed */
+    DRM_BOOL                             fRemoveCalled;
+} DRM_CDMI_LICENSE_STATE;
+
+typedef struct __tag_DRM_CDMI_MEDIA_KEY_SESSION_STATE
+{
+    DRM_BOOL                    fInitialized;
+    DRM_BOOL                    fCloseExecuted;
+    DRM_BOOL                    fRemoveExecuted;
+    DRM_BOOL                    fCallable;
+    DRM_BOOL                    fAllSessionsForSecureStop;
+    DRM_CDMI_APP_CONTEXT_STATE  oAppContextState;
+    DRM_CDMI_LICENSE_STATE      oLicenseState;
+    DRM_CDMI_CERT_DATA          oCertData;
+} DRM_CDMI_MEDIA_KEY_SESSION_STATE;
+
+typedef struct __tag_DRM_CDMI_MEDIA_KEY_SESSION
+{
+    DRM_ID                                  idSession;
+    DRM_CHAR                                rgchSessionId[ DRM_CDMI_CHARS_IN_B64_DRM_ID + 1 ];     /* +1 for null terminator */
+    DRM_CDMI_SESSION_TYPE                   eSessionType;
+
+    DRM_CDMI_MEDIA_KEY_SESSION_CALLBACKS    oCallbacks;
+    DRM_CDMI_MEDIA_KEY_SESSION_STATE        oSessionState;
+} DRM_CDMI_MEDIA_KEY_SESSION;
+
+EXIT_PK_NAMESPACE;
+
+#endif /*__DRMCDMITYPES_H__ */
+
diff --git a/prebuilt-v4.4/noarch/include/drmchain.h b/prebuilt-v4.4/noarch/include/drmchain.h
new file mode 100644
index 0000000..3d00eb8
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmchain.h
@@ -0,0 +1,54 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __DRM_CHAIN_H__
+#define __DRM_CHAIN_H__
+
+#include <drmchaintypes.h>
+#include <drmcallbacks.h>
+#include <drmliceval.h>
+
+ENTER_PK_NAMESPACE;
+
+DRM_API DRM_RESULT DRM_CALL DRM_LIC_CompleteLicenseChain(
+    __out_opt                    DRM_CIPHER_CONTEXT          *f_pCipherContext,
+    __inout                      DRM_FFLICENSE               *f_pFFLicense,
+    __in_ecount(f_cRights) const DRM_CONST_STRING            *f_rgpdstrRights[],
+    __in                         DRM_DWORD                    f_cRights,
+    __out                        DRM_DWORD                   *f_pdwChainDepth,
+    __in                         DRM_DST                     *f_pDatastore,
+    __in                         DRMPFNPOLICYCALLBACK         f_pfnPolicyCallback,
+    __in                   const DRM_VOID                    *f_pv );
+
+DRM_API DRM_RESULT DRM_CALL DRM_LIC_ReportActions(
+    __inout                        DRM_FFLICENSE                *f_pFFLicense,
+    __in_ecount( f_cRights ) const DRM_CONST_STRING             *f_rgpdstrRights[],
+    __in                           DRM_DWORD                     f_cRights,
+    __in                           DRM_DWORD                     f_dwChainDepth,
+    __in                     const DRM_DST                      *f_pDatastore,
+    __in                           DRMPFNPOLICYCALLBACK          f_pfnPolicyCallback,
+    __in                     const DRM_VOID                     *f_pv );
+
+DRM_API DRM_RESULT DRM_CALL DRM_LIC_CheckClockRollback(
+    __in                           DRM_LICEVAL_CONTEXT      *f_pLicEval,
+    __in                           DRM_LICSTORE_CONTEXT     *f_pLicStoreXMR,
+    __in                           DRM_LICSTOREENUM_CONTEXT *f_pLicEnum,
+    __in_bcount( f_cbBuffer )      DRM_BYTE                 *f_pbBuffer,
+    __in                           DRM_DWORD                 f_cbBuffer,
+    __in                           DRM_DST                  *f_pDatastore,
+    __in_bcount( f_cbStackBuffer ) DRM_BYTE                 *f_pbStackBuffer,
+    __in                           DRM_DWORD                 f_cbStackBuffer );
+
+DRM_API DRM_RESULT DRM_CALL DRM_LICOPL_ProcessPlayOutputLevelDataXMR(
+    __in    const DRM_XMRFORMAT_PLAYBACK_POLICY_CONTAINER   *f_pxmrPlaybackRights,
+    __inout       DRM_PLAY_OPL_LATEST                       *f_pPlayOPL,
+    __in          DRM_STACK_ALLOCATOR_CONTEXT               *f_pstack );
+
+EXIT_PK_NAMESPACE;
+
+#endif  /* __DRM_CHAIN_H__ */
diff --git a/prebuilt-v4.4/noarch/include/drmchaintypes.h b/prebuilt-v4.4/noarch/include/drmchaintypes.h
new file mode 100644
index 0000000..1b7209b
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmchaintypes.h
@@ -0,0 +1,94 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __DRM_CHAINTYPES_H__
+#define __DRM_CHAINTYPES_H__
+
+#include <drmtypes.h>
+#include <drmlicevaltypes.h>
+#include <drmlicstore.h>
+#include <drmcallbacktypes.h>
+#include <drmnoncestore.h>
+
+ENTER_PK_NAMESPACE;
+
+#define DRM_MAX_PLAY_OPL_DATA_SIZE (1024)
+
+typedef DRM_RESULT (DRM_CALL *pfnCheckDeviceRevocation)(DRM_LICEVAL_CONTEXT* pLicEvalContext, DRM_VOID *pv );
+
+typedef struct __tagPLAY_OPL_CHAIN
+{
+    DRM_BYTE            rgbPlayOPLBuffer[ DRM_MAX_PLAY_OPL_DATA_SIZE ];
+    DRM_PLAY_OPL_LATEST oplPlay;
+} PLAY_OPL_CHAIN;
+
+PREFAST_PUSH_DISABLE_EXPLAINED( __WARNING_POOR_DATA_ALIGNMENT_25021, "Ignore poor data alignment that occurs due to making structures human-readable" )
+
+typedef struct _FFLICENSE
+{
+    /* __in    */ DRM_LICSTORE_CONTEXT              *rgpLicStoreCurrent[DRM_MAX_LICENSE_CHAIN_DEPTH]; /* Context to an Open license store for each license in the chain */
+    /* __in    */ DRM_LICSTORE_CONTEXT              *rgpLicStores[DRM_LICSTORE_MAX_STORES]; /* Array of contexts to Open license stores (for enumeration) */
+    /* __in    */ DRM_LICSTORE_CONTEXT              *pLicStoreNST;  /* Non-NULL if NST store is included in Open license stores */
+    /* __in    */ DRM_LICSTORE_CONTEXT              *pLicStoreEST;  /* Non-NULL if EST store is included in Open license stores */
+    /* _In_    */ DRM_NONCESTORE_CONTEXT            *pNonceStoreContext;
+    /* __in    */ DRM_DWORD                          cLicStores; /* Count of elements in pLicStores */
+    /* __inout */ DRM_LICSTOREENUM_MULTIPLE_CONTEXT *pLicStoreEnum; /* Enumerators for all depths, [0] should be initialized */
+    /* __inout */ DRM_SECSTORE_CONTEXT              *pSecStoreLicense;
+    /* __in    */ DRM_LICEVAL_CONTEXT               *pLicEval;
+    /* __in    */ DRM_V1Header                      *pV1Header;
+    /* __out   */ DRM_BINDING_INFO                  *pBindingInfo;     /* This should point to an array of DRM_MAX_LICENSE_CHAIN_DEPTH binding infos. */
+    /* __out   */ DRM_XMRFORMAT                     *pLicenseXMR;
+    /* __in    */ DRM_STACK_ALLOCATOR_CONTEXT       *pstack;
+    /* __in    */ DRM_BYTE                          *pbBuffer;     /* Working buffer */
+    /* __in    */ DRM_DWORD                          cbBuffer;
+    /* __in    */ DRM_DWORD                          dwChainDepth; /* The current depth of the chain.  If we are looking for the first license this is 0 */
+    /* __in    */ DRM_DWORD                          dwPolicyFlags; /* bitmask of policy flags */
+    /* __in    */ DRM_BYTE                           rgbRevocationPassword [ OEM_SHA1_DIGEST_LEN ];
+    /*         */ DRM_BYTE                           rgbLicensePassword    [ OEM_SHA1_DIGEST_LEN ];
+    /* __out   */ DRM_BOOL                           fSecStoreOpen         [DRM_MAX_LICENSE_CHAIN_DEPTH]; /* On function exit the caller should close the stores if they are open */
+    /* __out   */ DRM_BOOL                           rgfLicenseFromEST     [DRM_MAX_LICENSE_CHAIN_DEPTH];
+    /* __out   */ DRM_KID                            rgkid                 [DRM_MAX_LICENSE_CHAIN_DEPTH];
+    /* __out   */ DRM_LID                            rglid                 [DRM_MAX_LICENSE_CHAIN_DEPTH];
+    /* __out   */ DRM_DST_SLOT_HINT                  rgslotHint            [DRM_MAX_LICENSE_CHAIN_DEPTH];
+    /* __out   */ DRM_MID                            rgmid                 [DRM_MAX_LICENSE_CHAIN_DEPTH];
+    /* __out   */ DRM_BOOL                           rgfHasMetering        [DRM_MAX_LICENSE_CHAIN_DEPTH]; /* On function exit the caller should close the stores if they are open */
+
+    /* __out   */ PLAY_OPL_CHAIN                     rgPlayOpl             [DRM_MAX_LICENSE_CHAIN_DEPTH];
+    /* __out   */ DRM_BOOL                           rgfPlayOplValid       [DRM_MAX_LICENSE_CHAIN_DEPTH];
+
+    /* __out   */ DRM_DWORD                          dwMinimumRequiredAppSec;
+    /* __in    */ DRM_BOOL                           fCanBind;
+    /* __out   */ DRM_DWORD                          dwSourceid;
+    /* __out   */ DRM_DWORD                          dwLicRevInfoVer;
+
+    /*
+    ** We use this boolean to cache whether the root license MUST
+    **  be domain bound due to a leaf license requiring it.
+    ** See comments regarding the equivalent flag in drmliceval.h
+    **  for more information.
+    */
+    /* __out   */ DRM_BOOL                          fDomainBoundRootRequired;
+
+    /* __out   */ DRM_UINT64                        ui64RealTimeExpiration;
+    /* __out   */ DRM_UINT64                        ui64RealTimeExpirationTicsAfterFirstPlay;
+
+    /*
+    ** On input, the decryption mode requested by the application.
+    ** On output, the decryption mode used by the TEE.
+    ** Valid values are in oemteetypes.h (OEM_TEE_DECRYPTION_MODE).
+    */
+    /* __inout */ DRM_DWORD                         dwDecryptionOutputMode;
+
+} DRM_FFLICENSE;
+
+PREFAST_POP /* __WARNING_POOR_DATA_ALIGNMENT_25021 */
+
+EXIT_PK_NAMESPACE;
+
+#endif  /* __DRM_CHAINTYPES_H__ */
+
diff --git a/prebuilt-v4.4/noarch/include/drmcleanstore.h b/prebuilt-v4.4/noarch/include/drmcleanstore.h
new file mode 100644
index 0000000..e09501b
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmcleanstore.h
@@ -0,0 +1,33 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __DRM_CLEANSTORE__
+#define __DRM_CLEANSTORE__
+
+#include <drmtypes.h>
+#include <drmlicstore.h>
+#include <drmlicevaltypes.h>
+
+ENTER_PK_NAMESPACE;
+
+DRM_API DRM_RESULT DRM_CALL DRM_CLEANSTORE_RemoveUnusableLicenses(
+    __in                                                DRM_LICEVAL_CONTEXT         *f_pContextLEVL,
+    __in_opt                                            DRM_LICSTORE_CONTEXT        *f_pContextLSTXMR,
+    __in                                                DRM_LICSTOREENUM_CONTEXT    *f_pLicStoreEnumContext,
+    __in                                                DRM_DWORD                    f_dwFlags,
+    __in_bcount(f_cbBuffer )                            DRM_BYTE                    *f_pbBuffer,
+    __in                                                DRM_DWORD                    f_cbBuffer,
+    __in_opt                                      const DRM_VOID                    *f_pvCallerData,
+    __in                                                DRM_DWORD                    f_dwCallbackInterval,
+    __in_opt                                            pfnStoreCleanupProgress      f_pfnCallback,
+    __inout_ecount( 1 )                                 DRM_DST                     *f_pDatastore ) DRM_NO_INLINE_ATTRIBUTE;
+
+EXIT_PK_NAMESPACE;
+
+#endif /* __DRM_CLEANSTORE__ */
+
diff --git a/prebuilt-v4.4/noarch/include/drmcmdlnpars.h b/prebuilt-v4.4/noarch/include/drmcmdlnpars.h
new file mode 100644
index 0000000..6c27edb
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmcmdlnpars.h
@@ -0,0 +1,49 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __CMDLNPARS_H__
+#define __CMDLNPARS_H__
+
+#include <drmtypes.h>
+
+#define DRM_CMD_MAX_ARGUMENTS 15
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+DRM_LONG DRM_CALL DRM_Main( _In_ DRM_LONG argc, _At_buffer_( argv, _Iter_, argc, _In_opt_z_ ) DRM_WCHAR **argv );
+
+#ifdef __cplusplus
+}
+#endif
+
+ENTER_PK_NAMESPACE;
+
+DRM_LONG DRM_CALL DRM_CMD_ConvertToArgvArgc(
+    __in __nullterminated                                     const DRM_WCHAR *lpCmdLine,
+    _Out_opt_cap_( DRM_CMD_MAX_ARGUMENTS ) _Deref_post_opt_z_       DRM_WCHAR *argv[ DRM_CMD_MAX_ARGUMENTS ] );
+
+DRM_BOOL DRM_CALL DRM_CMD_ParseCmdLine(
+    __in_z_opt                                                                                                                                                          const DRM_WCHAR        *pwszArgument,
+    __inout_ecount_opt( 1 )                                                                                                                                                   DRM_WCHAR        *pwchOptionChar,
+    __out_opt _Post_satisfies_( f_pdstrParam == NULL || f_pdstrParam->pwszString == NULL || _String_length_( f_pdstrParam->pwszString ) == f_pdstrParam->cchString )          DRM_CONST_STRING *f_pdstrParam,
+    __out_opt _Post_satisfies_( f_pdstrExtra == NULL || f_pdstrExtra->pwszString == NULL || _String_length_( f_pdstrExtra->pwszString ) == f_pdstrExtra->cchString )          DRM_CONST_STRING *f_pdstrExtra );
+
+DRM_BOOL DRM_CALL DRM_CMD_ParseCmdLineMultiChar(
+    __in_z    const DRM_WCHAR        *pwszArgument,
+    __inout         DRM_CONST_STRING *pwszOptionStr,
+    __out_opt       DRM_CONST_STRING *f_pdstrParam,
+    __out_opt       DRM_CONST_STRING *f_pdstrExtra );
+
+DRM_RESULT DRM_CALL DRM_CMD_TryProcessDefaultOption(
+    __in_z const DRM_WCHAR  *f_wszArgument );
+
+EXIT_PK_NAMESPACE;
+
+#endif /* __CMDLNPARS_H__ */
diff --git a/prebuilt-v4.4/noarch/include/drmcompiler.h b/prebuilt-v4.4/noarch/include/drmcompiler.h
new file mode 100644
index 0000000..258de0d
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmcompiler.h
@@ -0,0 +1,864 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __DRMCOMPILER_H__
+#define __DRMCOMPILER_H__
+
+#include <drmfeatures.h>
+#include <oemcompiler.h>
+
+#if !defined(DRM_DBG)
+#if DBG
+#define DRM_DBG 1
+#endif /* DBG */
+#endif /* DRM_DBG */
+
+#if defined( __powerpc__   ) || defined( __ppc__   ) || defined( __PPC__  ) || \
+    defined( __powerpc64__ ) || defined( __ppc64__ ) || defined( __PPC64__)
+#define DRM_ARCH_POWERPC 1
+#endif
+
+/*
+** +---------------------+
+** | DRM_VOID definition |
+** +---------------------+
+*/
+#if !DRM_VOID_DEFINED
+#undef DRM_VOID_DEFINED
+#define DRM_VOID_DEFINED 1
+#if DRM_BUILD_PROFILE == DRM_BUILD_PROFILE_IOS || DRM_BUILD_PROFILE == DRM_BUILD_PROFILE_LINUX || DRM_BUILD_PROFILE == DRM_BUILD_PROFILE_ANDROID || DRM_BUILD_PROFILE == DRM_BUILD_PROFILE_MAC
+#define DRM_VOID    void
+#else
+typedef void      DRM_VOID;
+#endif /* DRM_BUILD_PROFILE == DRM_BUILD_PROFILE_IOS || DRM_BUILD_PROFILE == DRM_BUILD_PROFILE_LINUX || DRM_BUILD_PROFILE == DRM_BUILD_PROFILE_ANDROID || DRM_BUILD_PROFILE == DRM_BUILD_PROFILE_MAC */
+#endif /* !DRM_VOID_DEFINED */
+
+/*
+** +------------------+
+** | Compiler Version |
+** +------------------+
+*/
+
+/*
+** Set DRM_GNUC_MAJOR and DRM_GNUC_MINOR if not already set.
+*/
+#if defined(__GNUC__) && !defined(DRM_GNUC_MAJOR)
+#define DRM_GNUC_MAJOR __GNUC__
+#endif /* defined(__GNUC__) && !defined(DRM_GNUC_MAJOR) */
+#if defined(__GNUC_MINOR__) && !defined(DRM_GNUC_MINOR)
+#define DRM_GNUC_MINOR __GNUC_MINOR__
+#endif /* defined(__GNUC_MINOR__) && !defined(DRM_GNUC_MINOR) */
+
+#if defined(DRM_GNUC_MAJOR) && !defined(DRM_GNUC_MINOR)
+#error You or your compiler is setting DRM_GNUC_MAJOR (possibly by setting __GNUC__) but not DRM_GNUC_MINOR (possibly by not setting __GNUC_MINOR__).  You must ensure that both are set or neither are set.
+#elif !defined(DRM_GNUC_MAJOR) && defined(DRM_GNUC_MINOR)
+#error You or your compiler is setting DRM_GNUC_MINOR (possibly by setting __GNUC_MINOR__) but not DRM_GNUC_MAJOR (possibly by not setting __GNUC__).  You must ensure that both are set or neither are set.
+#endif /* defined(DRM_GNUC_MAJOR) && !defined(DRM_GNUC_MINOR) */
+
+/*
+** Set DRM_MSC_VER if not already set.
+**
+** Some customers have codebases that set _MSC_VER to values less than 1300
+** when using 3rd party compilers in order to leverage Microsoft headers.
+** So, only define DRM_MSC_VER to _MSC_VER if it is at least 1300.
+*/
+#if !defined(DRM_MSC_VER) && defined(_MSC_VER) && ( _MSC_VER >= 1300 )
+#define DRM_MSC_VER _MSC_VER
+#endif /* !defined(DRM_MSC_VER) && defined(_MSC_VER) && ( _MSC_VER >= 1300 ) */
+
+/*
+** +--------------------------+
+** | PREFAST WARNING HANDLERS |
+** +--------------------------+
+*/
+#if defined(_PREFAST_)
+#define PREFAST_PUSH_DISABLE_EXPLAINED(warning, explanation) \
+    __pragma(prefast(push))\
+    __pragma(prefast(disable:warning,explanation))
+#define PREFAST_POP __pragma(prefast(pop))
+
+#define PREFAST_PUSH_IGNORE_NONCONST_PARAMS( __reason )                               \
+    PREFAST_PUSH_DISABLE_EXPLAINED( __WARNING_NONCONST_PARAM_25004, __reason )        \
+    PREFAST_PUSH_DISABLE_EXPLAINED( __WARNING_NONCONST_BUFFER_PARAM_25033, __reason )
+#define PREFAST_POP_IGNORE_NONCONST_PARAMS                      \
+    PREFAST_POP  /* __WARNING_NONCONST_BUFFER_PARAM_25033 */    \
+    PREFAST_POP  /* __WARNING_NONCONST_PARAM_25004 */
+
+#define PREFAST_PUSH_IGNORE_NONCONST_PARAMS_FOR_STUB_IMPL PREFAST_PUSH_IGNORE_NONCONST_PARAMS( "Changing parameters to const to satisfy warning would make them not match the real interface." )
+#define PREFAST_POP_IGNORE_NONCONST_PARAMS_FOR_STUB_IMPL  PREFAST_POP_IGNORE_NONCONST_PARAMS
+
+#define PREFAST_PUSH_IGNORE_ARGUMENT_CHECKS_FOR_TESTING                                                                                                                                     \
+    PREFAST_PUSH_DISABLE_EXPLAINED( __WARNING_DEREFERENCING_NULL_POINTER_6011, "Test code intentionally passes invalid parameters to test argument checking in dev code." )                 \
+    PREFAST_PUSH_DISABLE_EXPLAINED( __WARNING_INVALID_PARAMETER_6387, "Test code intentionally passes invalid parameters to test argument checking in dev code." )                          \
+    PREFAST_PUSH_DISABLE_EXPLAINED( __WARNING_PRECONDITION_NULLTERMINATION_VIOLATION_26035, "Test code intentionally passes invalid parameters to test argument checking in dev code." )    \
+    PREFAST_PUSH_DISABLE_EXPLAINED( __WARNING_POTENTIAL_RANGE_PRECONDITION_VIOLATION_26070, "Test code intentionally passes invalid parameters to test argument checking in dev code." )    \
+    PREFAST_PUSH_DISABLE_EXPLAINED( __WARNING_POINTER_COPY_COULD_BE_NULL_28183, "Test code intentionally passes invalid parameters to test argument checking in dev code." )                \
+
+#define PREFAST_POP_IGNORE_ARGUMENT_CHECKS_FOR_TESTING                                                                                                                          \
+    PREFAST_POP  /* __WARNING_POINTER_COPY_COULD_BE_NULL_28183 */                                                                                                               \
+    PREFAST_POP  /* __WARNING_POTENTIAL_RANGE_PRECONDITION_VIOLATION_26070 */                                                                                                   \
+    PREFAST_POP  /* __WARNING_PRECONDITION_NULLTERMINATION_VIOLATION_26035 */                                                                                                   \
+    PREFAST_POP  /* __WARNING_INVALID_PARAMETER_6387 */                                                                                                                         \
+    PREFAST_POP  /* __WARNING_DEREFERENCING_NULL_POINTER_6011 */                                                                                                                \
+
+#else /* defined(_PREFAST_) */
+#define PREFAST_PUSH_DISABLE_EXPLAINED(warning, explanation)
+#define PREFAST_POP
+#define PREFAST_PUSH_IGNORE_NONCONST_PARAMS( __reason )
+#define PREFAST_POP_IGNORE_NONCONST_PARAMS
+#define PREFAST_PUSH_IGNORE_NONCONST_PARAMS_FOR_STUB_IMPL
+#define PREFAST_POP_IGNORE_NONCONST_PARAMS_FOR_STUB_IMPL
+#define PREFAST_PUSH_IGNORE_ARGUMENT_CHECKS_FOR_TESTING
+#define PREFAST_POP_IGNORE_ARGUMENT_CHECKS_FOR_TESTING
+#endif /* defined(_PREFAST_) */
+
+/*
+** +-----------------------+
+** | PRAGMA WARNING MACROS |
+** +-----------------------+
+*/
+#if !DRM_PRAGMA_WARNING_MACROS_DEFINED
+
+#if defined(PRAGMA_INTRINSIC) || defined(PRAGMA_WARNING_DEFAULT) || defined(PRAGMA_WARNING_DISABLE)  \
+ || defined(PRAGMA_WARNING_PUSH) || defined(PRAGMA_WARNING_POP) || defined(PRAGMA_WARNING_PUSH_WARN) \
+ || defined(PRAGMA_PACK_PUSH_VALUE) || defined(PRAGMA_PACK_POP) || defined(PRAGMA_DIAG_OFF)          \
+ || defined(PRAGMA_DIAG_ON)
+#error You did not set DRM_PRAGMA_WARNING_MACROS_DEFINED to 1 but at least one of its macros is already defined - please refer to oemcompiler.h near DRM_PRAGMA_WARNING_MACROS_DEFINED
+#endif /* At least one PRAGMA_WARNING macro is already defined */
+
+#undef DRM_PRAGMA_WARNING_MACROS_DEFINED
+#define DRM_PRAGMA_WARNING_MACROS_DEFINED 1
+
+#ifdef DRM_GNUC_MAJOR
+
+#define PRAGMA_INTRINSIC(func)
+#define PRAGMA_WARNING_DEFAULT(warningnum)
+#define PRAGMA_WARNING_DISABLE(warningnum)
+#define PRAGMA_WARNING_PUSH
+#define PRAGMA_WARNING_POP
+#define PRAGMA_WARNING_PUSH_WARN(warningnum)
+#define PRAGMA_PACK_PUSH_VALUE(packval)
+#define PRAGMA_PACK_POP
+
+#define DRM_STRINGIFY_TEMP(s) #s
+#define PRAGMA_DIAG_WITH_TEMP(s) _Pragma( DRM_STRINGIFY_TEMP( GCC diagnostic s ) )
+
+#if ((DRM_GNUC_MAJOR >= 4) && (DRM_GNUC_MINOR >= 6))
+#define PRAGMA_DIAG_OFF(x, reason) PRAGMA_DIAG_WITH_TEMP( push )  \
+                PRAGMA_DIAG_WITH_TEMP( ignored DRM_STRINGIFY_TEMP(-W ## x) )
+#define PRAGMA_DIAG_ON(x) PRAGMA_DIAG_WITH_TEMP( pop )
+#elif ((DRM_GNUC_MAJOR >= 4) && (DRM_GNUC_MINOR >= 2))
+#define PRAGMA_DIAG_OFF(x, reason) PRAGMA_DIAG_WITH_TEMP( ignored DRM_STRINGIFY_TEMP(-W ## x) )
+#define PRAGMA_DIAG_ON(x) PRAGMA_DIAG_WITH_TEMP( warning DRM_STRINGIFY_TEMP(-W ## x) )
+#else /* DRM_GNUC_MAJOR < 4 || DRM_GNUC_MINOR < 2 */
+#define PRAGMA_DIAG_OFF(x, reason)
+#define PRAGMA_DIAG_ON(x)
+#endif /* various DRM_GNUC_MAJOR versions */
+
+#else /* DRM_GNUC_MAJOR */
+
+#define PRAGMA_INTRINSIC(func) __pragma(intrinsic(func))
+#define PRAGMA_WARNING_DEFAULT(warningnum) __pragma(warning(default:warningnum))
+#define PRAGMA_WARNING_DISABLE(warningnum) __pragma(warning(disable:warningnum))
+#define PRAGMA_WARNING_PUSH __pragma(warning(push))
+#define PRAGMA_WARNING_POP __pragma(warning(pop))
+#define PRAGMA_WARNING_PUSH_WARN(warningnum)    \
+    __pragma(warning(push))                     \
+    __pragma(warning(disable:warningnum))
+#define PRAGMA_PACK_PUSH_VALUE(packval)         \
+    __pragma(pack(push))                        \
+    __pragma(pack(packval))
+#define PRAGMA_PACK_POP __pragma(pack(pop))
+
+#define PRAGMA_DIAG_OFF(x, reason)
+#define PRAGMA_DIAG_ON(x)
+
+#endif /* DRM_GNUC_MAJOR */
+
+#endif /* DRM_PRAGMA_WARNING_MACROS_DEFINED */
+
+#if !defined(PRAGMA_INTRINSIC) || !defined(PRAGMA_WARNING_DEFAULT) || !defined(PRAGMA_WARNING_DISABLE)  \
+ || !defined(PRAGMA_WARNING_PUSH) || !defined(PRAGMA_WARNING_POP) || !defined(PRAGMA_WARNING_PUSH_WARN) \
+ || !defined(PRAGMA_PACK_PUSH_VALUE) || !defined(PRAGMA_PACK_POP) || !defined(PRAGMA_DIAG_OFF)          \
+ || !defined(PRAGMA_DIAG_ON)
+#error You set DRM_PRAGMA_WARNING_MACROS_DEFINED to 1 but at least one of its macros is not defined - please refer to oemcompiler.h near DRM_PRAGMA_WARNING_MACROS_DEFINED
+#endif /* At least one PRAGMA_WARNING macro is not defined */
+
+/*
+** +----------------------------------------+
+** | 64-BIT TARGET ARCHITECTURE DEFINITIONS |
+** +----------------------------------------+
+*/
+#if !DRM_64BIT_TARGET_DEFINED
+
+#if defined(DRM_64BIT_TARGET)
+#error You did not set DRM_64BIT_TARGET_DEFINED to 1 but DRM_64BIT_TARGET is already defined - please refer to oemcompiler.h near DRM_64BIT_TARGET_DEFINED
+#endif  /* DRM_64BIT_TARGET is already defined */
+
+#undef DRM_64BIT_TARGET_DEFINED
+#define DRM_64BIT_TARGET_DEFINED 1
+
+#if defined(_WIN64)
+#define DRM_64BIT_TARGET         1
+#elif DRM_BUILD_PROFILE == DRM_BUILD_PROFILE_MAC
+#define DRM_64BIT_TARGET         1
+#elif defined( __powerpc64__ ) || defined( __ppc64__ ) || defined( __PPC64__)
+#define DRM_64BIT_TARGET         1
+#elif defined( ARM64 )
+#define DRM_64BIT_TARGET         1
+#else /* Unknown architecture */
+/*
+** Assume the target is a 32-bit architecture.
+** If the target is 64-bit, DRM_64BIT_TARGET should be set to 1.
+*/
+#define DRM_64BIT_TARGET         0
+#endif /* Known architectures check */
+#endif /* DRM_64BIT_TARGET_DEFINED */
+
+#if !defined(DRM_64BIT_TARGET)
+#error You set DRM_64BIT_TARGET_DEFINED to 1 but did not define DRM_64BIT_TARGET - please refer to oemcompiler.h near DRM_64BIT_TARGET_DEFINED
+#endif /* DRM_64BIT_TARGET is not defined */
+
+/*
+** +----------------------------------------+
+** | GS STRICT AND DBG OPTIMIZATION PRAGMAS |
+** +----------------------------------------+
+*/
+#if !DRM_STRICT_AND_OPTIMIZATION_PRAGMAS_DEFINED
+
+#if defined(PRAGMA_STRICT_GS_PUSH_ON) || defined(PRAGMA_STRICT_GS_POP) || defined(PRAGMA_DBG_OPTIMIZATION_OFF)         \
+ || defined(PRAGMA_DBG_OPTIMIZATION_ON) || defined(PRAGMA_ARM_OPTIMIZATION_OFF) || defined(PRAGMA_ARM_OPTIMIZATION_ON) \
+ || defined(PRAGMA_GCC_OPTIMIZATION_OFF) || defined(PRAGMA_GCC_OPTIMIZATION_ON)
+#error You did not set DRM_STRICT_AND_OPTIMIZATION_PRAGMAS_DEFINED to 1 but at least one of its macros is already defined - please refer to oemcompiler.h near DRM_STRICT_AND_OPTIMIZATION_PRAGMAS_DEFINED
+#endif /* At least one STRICT_AND_OPTIMIZATION_PRAGMA macro is already defined */
+
+#undef DRM_STRICT_AND_OPTIMIZATION_PRAGMAS_DEFINED
+#define DRM_STRICT_AND_OPTIMIZATION_PRAGMAS_DEFINED 1
+
+#if defined(DRM_MSC_VER) && !defined(DRM_GNUC_MAJOR)
+#define PRAGMA_STRICT_GS_PUSH_ON    __pragma(strict_gs_check(push, on))
+#define PRAGMA_STRICT_GS_POP        __pragma(strict_gs_check(pop))
+#if DRM_EXPORT_APIS_TO_DLL
+#define PRAGMA_COV_OPTIMIZATION_OFF  __pragma(optimize("",off))
+#endif  /* DRM_EXPORT_APIS_TO_DLL */
+#if DRM_DBG
+#define PRAGMA_DBG_OPTIMIZATION_OFF __pragma(optimize("",off))
+#define PRAGMA_DBG_OPTIMIZATION_ON  __pragma(optimize("",on))
+#else   /* DRM_DBG */
+#define PRAGMA_DBG_OPTIMIZATION_OFF
+#define PRAGMA_DBG_OPTIMIZATION_ON
+#endif  /* DRM_DBG */
+#if defined( ARM )
+#define PRAGMA_ARM_OPTIMIZATION_OFF __pragma(optimize("",off))
+#define PRAGMA_ARM_OPTIMIZATION_ON  __pragma(optimize("",on))
+#else /* defined( ARM ) */
+#define PRAGMA_ARM_OPTIMIZATION_OFF
+#define PRAGMA_ARM_OPTIMIZATION_ON
+#endif /* defined( ARM ) */
+#define PRAGMA_GCC_OPTIMIZATION_OFF
+#define PRAGMA_GCC_OPTIMIZATION_ON
+#else /* defined(DRM_MSC_VER) && !defined(DRM_GNUC_MAJOR) */
+#if defined(DRM_GNUC_MAJOR)
+#define PRAGMA_STRICT_GS_PUSH_ON
+#define PRAGMA_STRICT_GS_POP
+
+#if ((DRM_GNUC_MAJOR >= 4) && (DRM_GNUC_MINOR >= 4)) && ( defined(__i386__) || defined(__amd64__) || defined(DRM_ARCH_POWERPC) )
+#define PRAGMA_GCC_OPTIMIZATION_OFF _Pragma( "GCC push_options" )      \
+                                    _Pragma( "GCC optimize(\"-O0\")" )
+#define PRAGMA_GCC_OPTIMIZATION_ON  _Pragma( "GCC pop_options" )
+#else /* ((DRM_GNUC_MAJOR >= 4) && (DRM_GNUC_MINOR >= 4)) && ( defined(__i386__) || defined(__amd64__) || defined(DRM_ARCH_POWERPC) ) */
+#define PRAGMA_GCC_OPTIMIZATION_OFF
+#define PRAGMA_GCC_OPTIMIZATION_ON
+#endif /* ((DRM_GNUC_MAJOR >= 4) && (DRM_GNUC_MINOR >= 4)) && ( defined(__i386__) || defined(__amd64__) || defined(DRM_ARCH_POWERPC) ) */
+#if DRM_DBG
+#define PRAGMA_DBG_OPTIMIZATION_OFF PRAGMA_GCC_OPTIMIZATION_OFF
+#define PRAGMA_DBG_OPTIMIZATION_ON  PRAGMA_GCC_OPTIMIZATION_ON
+#else /* DRM_DBG */
+#define PRAGMA_DBG_OPTIMIZATION_OFF
+#define PRAGMA_DBG_OPTIMIZATION_ON
+#endif /* DRM_DBG */
+#define PRAGMA_ARM_OPTIMIZATION_OFF
+#define PRAGMA_ARM_OPTIMIZATION_ON
+#else /* defined(DRM_GNUC_MAJOR) */
+#define PRAGMA_STRICT_GS_PUSH_ON
+#define PRAGMA_STRICT_GS_POP
+#define PRAGMA_DBG_OPTIMIZATION_OFF
+#define PRAGMA_DBG_OPTIMIZATION_ON
+#define PRAGMA_ARM_OPTIMIZATION_OFF
+#define PRAGMA_ARM_OPTIMIZATION_ON
+#define PRAGMA_GCC_OPTIMIZATION_OFF
+#define PRAGMA_GCC_OPTIMIZATION_ON
+#endif /* defined(DRM_GNUC_MAJOR) */
+#endif /* defined(DRM_MSC_VER) && !defined(DRM_GNUC_MAJOR) */
+#endif /* !DRM_STRICT_AND_OPTIMIZATION_PRAGMAS_DEFINED */
+
+#if !defined(PRAGMA_STRICT_GS_PUSH_ON) || !defined(PRAGMA_STRICT_GS_POP) || !defined(PRAGMA_DBG_OPTIMIZATION_OFF)         \
+ || !defined(PRAGMA_DBG_OPTIMIZATION_ON) || !defined(PRAGMA_ARM_OPTIMIZATION_OFF) || !defined(PRAGMA_ARM_OPTIMIZATION_ON) \
+ || !defined(PRAGMA_GCC_OPTIMIZATION_OFF) || !defined(PRAGMA_GCC_OPTIMIZATION_ON)
+#error You set DRM_STRICT_AND_OPTIMIZATION_PRAGMAS_DEFINED to 1 but at least one of its macros is not defined - please refer to oemcompiler.h near DRM_STRICT_AND_OPTIMIZATION_PRAGMAS_DEFINED
+#endif /* At least one STRICT_AND_OPTIMIZATION_PRAGMA macro is not defined */
+
+/*
+** +--------------------------------------+
+** | DISABLE OPTIMIZATIONS WHEN REQUESTED |
+** +--------------------------------------+
+*/
+#if DRM_NO_OPT
+PRAGMA_DBG_OPTIMIZATION_OFF
+#endif /* DRM_NO_OPT */
+#undef PRAGMA_DBG_OPTIMIZATION_OFF
+
+#if !defined(PRAGMA_COV_OPTIMIZATION_OFF)
+#define PRAGMA_COV_OPTIMIZATION_OFF
+#endif  /* PRAGMA_COV_OPTIMIZATION_OFF */
+
+PRAGMA_COV_OPTIMIZATION_OFF
+#undef PRAGMA_DBG_OPTIMIZATION_OFF
+
+/*
+** +-----------------------------------+
+** | COMPILATION QUALIFIER DEFINITIONS |
+** +-----------------------------------+
+*/
+
+#if !DRM_COMPILATION_QUALIFIERS_DEFINED
+
+#if defined(DRM_CCALL) || defined(DRM_DLLEXPORT) || defined(DRM_DLLIMPORT) || defined(DRM_ALIGN_4) \
+ || defined(DRM_ALIGN_8) || defined(DRM_PACKED) || defined(DRM_DISCARDABLE)
+#error You did not set DRM_COMPILATION_QUALIFIERS_DEFINED to 1 but at least one of its macros is already defined - please refer to oemcompiler.h near DRM_COMPILATION_QUALIFIERS_DEFINED
+#endif /* At least one COMPILATION_QUALIFIERS macro is already defined */
+
+#undef DRM_COMPILATION_QUALIFIERS_DEFINED
+#define DRM_COMPILATION_QUALIFIERS_DEFINED 1
+
+/* ====================== Microsoft specific qualifiers ======================= */
+/* ============================================================================ */
+#if defined(DRM_MSC_VER)
+
+#define DRM_CCALL      __cdecl
+#define DRM_DLLEXPORT  __declspec(dllexport)
+#define DRM_DLLIMPORT  __declspec(dllimport)
+#if DRM_SUPPORT_FORCE_ALIGN
+#define DRM_ALIGN_4    __declspec(align(4))
+#define DRM_ALIGN_8    __declspec(align(8))
+#endif /* DRM_SUPPORT_FORCE_ALIGN */
+#define DRM_PACKED
+
+/*
+** Microsoft linkers require that extern const data be marked with __declspec(selectany) for it to be discarded
+** when not used.  If this tag is not present the data will be linked into final binaries regardless of it being necessary
+** or not.
+*/
+#define DRM_DISCARDABLE __declspec(selectany)
+
+/* ========================= GNU specific qualifiers ========================== */
+/* ============================================================================ */
+#elif defined(DRM_GNUC_MAJOR)
+
+#define DRM_CCALL      __attribute__((cdecl))
+#define DRM_DLLEXPORT  __attribute__((dllexport))
+#define DRM_DLLIMPORT  __attribute__((dllimport))
+#if DRM_SUPPORT_FORCE_ALIGN
+#define DRM_ALIGN_4    __attribute__((aligned(4)))
+#define DRM_ALIGN_8    __attribute__((aligned(8)))
+#endif /* DRM_SUPPORT_FORCE_ALIGN */
+#define DRM_PACKED     __attribute__((__packed__))
+
+/*
+**  Set to nothing as there is no comparable setting
+*/
+#define DRM_DISCARDABLE
+
+/* ======================== Default (empty) qualifiers ======================== */
+/* ============================================================================ */
+#else /* neither DRM_MSC_VER nor DRM_GNUC_MAJOR */
+
+#define DRM_CCALL
+#define DRM_DLLEXPORT
+#define DRM_DLLIMPORT
+#define DRM_ALIGN_4
+#define DRM_ALIGN_8
+#define DRM_PACKED
+#define DRM_DISCARDABLE
+
+#endif /* DRM_MSC_VER or DRM_GNUC_MAJOR */
+
+#endif /* !DRM_COMPILATION_QUALIFIERS_DEFINED */
+
+#if !DRM_SUPPORT_FORCE_ALIGN
+#undef DRM_ALIGN_4
+#define DRM_ALIGN_4
+#undef DRM_ALIGN_8
+#define DRM_ALIGN_8
+#endif /* !DRM_SUPPORT_FORCE_ALIGN */
+
+#if !defined(DRM_CCALL) || !defined(DRM_DLLEXPORT) || !defined(DRM_DLLIMPORT) || !defined(DRM_ALIGN_4) \
+ || !defined(DRM_ALIGN_8) || !defined(DRM_PACKED) || !defined(DRM_DISCARDABLE)
+#error You set DRM_COMPILATION_QUALIFIERS_DEFINED to 1 but at least one of its macros is not defined - please refer to oemcompiler.h near DRM_COMPILATION_QUALIFIERS_DEFINED
+#endif /* At least one COMPILATION_QUALIFIERS macro is not defined */
+
+/*
+** +-------------------------------+
+** | COMPILATION BEHAVIOR SETTINGS |
+** +-------------------------------+
+*/
+#if !DRM_COMPILATION_BEHAVIOR_DEFINED
+
+#if defined(DRM_NO_INLINE_ATTRIBUTE) || defined(DRM_ALWAYS_INLINE_ATTRIBUTE) || defined(DRM_CALL) \
+ || defined(DRM_ALWAYS_INLINE) || defined(DRM_EXTERN_INLINE) || defined(DRM_EXPORTED_INLINE)      \
+ || defined(DRM_INLINING_SUPPORTED) || defined(DRM_DWORD_ALIGN) || defined(DRM_NO_INLINE)
+#error You did not set DRM_COMPILATION_BEHAVIOR_DEFINED to 1 but at least one of its macros is already defined - please refer to oemcompiler.h near DRM_COMPILATION_BEHAVIOR_DEFINED
+#endif /* At least one COMPILATION_BEHAVIOR macro is already defined */
+
+#undef DRM_COMPILATION_BEHAVIOR_DEFINED
+#define DRM_COMPILATION_BEHAVIOR_DEFINED 1
+
+/* ============================ Microsoft Compiler ============================ */
+/* ============================================================================ */
+#if defined(DRM_MSC_VER)
+
+#define DRM_NO_INLINE_ATTRIBUTE
+#define DRM_ALWAYS_INLINE_ATTRIBUTE
+
+/* ------------------------------ MS ANSI build ------------------------------- */
+/* ---------------------------------------------------------------------------- */
+/* when compiling as ANSI, parameter-passing specifications aren't allowed      */
+#if defined(__STDC__)
+
+#define DRM_CALL
+#define DRM_ALWAYS_INLINE
+#define DRM_EXTERN_INLINE
+#define DRM_EXPORTED_INLINE
+#define DRM_INLINING_SUPPORTED 0
+#define DRM_DWORD_ALIGN
+#define DRM_NO_INLINE
+
+/* ---------------------------- MS non-ANSI build ----------------------------- */
+/* ---------------------------------------------------------------------------- */
+#else /* __STDC__ */
+
+/* ----------------- Building the PK DLL ----------------- */
+/* Set the macros to export the APIs and global variables  */
+#if DRM_EXPORT_APIS_TO_DLL
+#define DRM_API         DRM_DLLEXPORT
+#define DRM_API_VOID    DRM_DLLEXPORT
+#define DRM_EXPORT_VAR  DRM_DLLEXPORT
+#endif  /* DRM_EXPORT_APIS_TO_DLL */
+
+/* ------------ Building the Test Executables ------------ */
+/* Set the macro to import the global variables            */
+#if DRM_TEST_LINK_TO_DRMAPI_DLL
+#define DRM_EXPORT_VAR  DRM_DLLIMPORT
+#endif /* DRM_TEST_LINK_TO_DRMAPI_DLL */
+
+#define DRM_CALL                DRM_CCALL
+#define DRM_ALWAYS_INLINE       __forceinline
+#define DRM_EXTERN_INLINE       extern _inline
+#define DRM_EXPORTED_INLINE     _inline
+#define DRM_INLINING_SUPPORTED  1
+#define DRM_DWORD_ALIGN         DRM_ALIGN_4
+#define DRM_NO_INLINE           __declspec(noinline)
+
+#endif /* __STDC__ */
+
+/* =============================== GNU Compiler =============================== */
+/* ============================================================================ */
+#elif defined(DRM_GNUC_MAJOR)
+
+#define DRM_NO_INLINE_ATTRIBUTE __attribute__((noinline))
+#define DRM_ALWAYS_INLINE_ATTRIBUTE __attribute__((always_inline))
+#define DRM_CALL
+
+#if DRM_BUILD_PROFILE == DRM_BUILD_PROFILE_IOS || DRM_BUILD_PROFILE == DRM_BUILD_PROFILE_ANDROID
+#define DRM_ALWAYS_INLINE       inline DRM_ALWAYS_INLINE_ATTRIBUTE
+#else
+#define DRM_ALWAYS_INLINE       __inline__ DRM_ALWAYS_INLINE_ATTRIBUTE
+#endif /* DRM_BUILD_PROFILE == DRM_BUILD_PROFILE_IOS || DRM_BUILD_PROFILE == DRM_BUILD_PROFILE_ANDROID */
+
+#define DRM_EXTERN_INLINE       extern
+#define DRM_EXPORTED_INLINE
+
+#define DRM_INLINING_SUPPORTED  1
+#define DRM_DWORD_ALIGN         DRM_ALIGN_4
+#define DRM_NO_INLINE
+
+/* ============================= Unknown Compiler ============================= */
+/* ============================================================================ */
+#else /* Neither DRM_MSC_VER nor DRM_GNUC_MAJOR is defined */
+#error Unknown compiler - please refer to oemcompiler.h near DRM_COMPILATION_BEHAVIOR_DEFINED
+#endif
+
+#endif /* !DRM_COMPILATION_BEHAVIOR_DEFINED */
+
+#if !defined(DRM_NO_INLINE_ATTRIBUTE) || !defined(DRM_ALWAYS_INLINE_ATTRIBUTE) || !defined(DRM_CALL) \
+ || !defined(DRM_ALWAYS_INLINE) || !defined(DRM_EXTERN_INLINE) || !defined(DRM_EXPORTED_INLINE)      \
+ || !defined(DRM_INLINING_SUPPORTED) || !defined(DRM_DWORD_ALIGN) || !defined(DRM_NO_INLINE)
+#error You set DRM_COMPILATION_BEHAVIOR_DEFINED to 1 but at least one of its macros is not defined - please refer to oemcompiler.h near DRM_COMPILATION_BEHAVIOR_DEFINED
+#endif /* At least one COMPILATION_BEHAVIOR macro is not defined */
+
+/*
+** Currently, creating a DLL is only supported on Microsoft compiler non-ANSI builds,
+** so ensure that the following DLL specific macros are empty if not set above.
+*/
+#if !defined(DRM_API)
+#define DRM_API_DEFAULT 1
+#define DRM_API
+#define DRM_API_VOID
+#endif  /* DRM_API */
+
+#if !defined(DRM_EXPORT_VAR)
+#define DRM_EXPORT_VAR
+#endif  /* DRM_EXPORT_VAR */
+
+/*
+** PlayReady PK function declaration should match the following pattern.
+**   [static] [DRM_*_INLINE] [DRM_API[_VOID]] <return_type> [DRM_CALL] func(...)
+**
+**   The following additional restrictions apply.
+**   +) DRM_API must not appear without DRM_CALL.
+**   +) DRM_API must not appear if <return_type> is either void or DRM_VOID.  (DRM_API_VOID is allowed.)
+**   +) DRM_API must not appear with static.
+**
+**   The following additional preferences apply.
+**   +) DRM_API should not appear where static can be used instead.  (i.e. Prefer static.)
+**   +) DRM_API or static should appear for all PK-DEV functions.  ("PK-DEV functions" are in files under msi\source)
+**   +) DRM_CALL should appear for all PK functions.  ("PK functions" are in files under msi)
+**
+** Any function failing to meet the above characteristics should be considered a bug to be fixed in a future release.
+**
+** Rationale behind the pattern:
+**   +) Although a number of the pattern's items can appear in a variety of sequence-orderings,
+**      using a consistent ordering improves overall codebase readibility.
+**   +) Using static first calls out that that the function cannot be called outside this file.
+**   +) Including <return_type> immediately before the function name keeps all types used by
+**      the function co-located and thus easy to find.
+**   +) DRM_API and DRM_API_VOID are typically used internally by Microsoft by code-coverage
+**      and static analysis tools.  Inlining macros are used both internally and externally
+**      for performance.  Therefore, the inlining macros are placed earlier to make them more obvious.
+**
+** Rationale behind the additional restrictions:
+**   +) All of these restrictions are required for Microsoft's internal code-coverage
+**      and static analysis tools to function properly / give accurate data.
+**
+** Rationale behind additional prefernces:
+**   +) Using "static" on a function enables better optimization on some compilers.
+**   +) Using DRM_API for non-static functions enables Microsoft's internal code-coverage
+**      tools to gather better data.
+**   +) Using a consistent calling convention enables better optimization on some compilers.
+*/
+
+/*
+** +-------------------------------------------------+
+** | TARGET ENDIANNESS AND UNALIGNED POINTER SUPPORT |
+** +-------------------------------------------------+
+*/
+#if !defined(TARGET_LITTLE_ENDIAN) || !defined(TARGET_SUPPORTS_UNALIGNED_DWORD_POINTERS)
+#if defined(_M_IX86)       /* Microsoft X86 compiler detected   */
+#ifndef TARGET_LITTLE_ENDIAN
+#define TARGET_LITTLE_ENDIAN                        1
+#endif  /* TARGET_LITTLE_ENDIAN */
+#ifndef TARGET_SUPPORTS_UNALIGNED_DWORD_POINTERS
+#define TARGET_SUPPORTS_UNALIGNED_DWORD_POINTERS    1
+#endif  /* TARGET_SUPPORTS_UNALIGNED_DWORD_POINTERS */
+#elif defined( _M_AMD64 )  /* Microsoft AMD64 compiler detected */
+#ifndef TARGET_LITTLE_ENDIAN
+#define TARGET_LITTLE_ENDIAN                        1
+#endif  /* TARGET_LITTLE_ENDIAN */
+#ifndef TARGET_SUPPORTS_UNALIGNED_DWORD_POINTERS
+#define TARGET_SUPPORTS_UNALIGNED_DWORD_POINTERS    1
+#endif  /* TARGET_SUPPORTS_UNALIGNED_DWORD_POINTERS */
+#elif defined( _M_IA64 )   /* Microsoft IA64 compiler detected  */
+#ifndef TARGET_LITTLE_ENDIAN
+#define TARGET_LITTLE_ENDIAN                        1
+#endif  /* TARGET_LITTLE_ENDIAN */
+#ifndef TARGET_SUPPORTS_UNALIGNED_DWORD_POINTERS
+#define TARGET_SUPPORTS_UNALIGNED_DWORD_POINTERS    1
+#endif  /* TARGET_SUPPORTS_UNALIGNED_DWORD_POINTERS */
+#elif defined( _XBOX )     /* Microsoft XBOX compiler detected  */
+#ifndef TARGET_LITTLE_ENDIAN
+#define TARGET_LITTLE_ENDIAN                        0
+#endif  /* TARGET_LITTLE_ENDIAN */
+#ifndef TARGET_SUPPORTS_UNALIGNED_DWORD_POINTERS
+#define TARGET_SUPPORTS_UNALIGNED_DWORD_POINTERS    1
+#endif  /* TARGET_SUPPORTS_UNALIGNED_DWORD_POINTERS */
+#elif defined( _M_PPC )     /* Microsoft XBOX/PPC compiler detected  */
+#ifndef TARGET_LITTLE_ENDIAN
+#define TARGET_LITTLE_ENDIAN                        0
+#endif  /* TARGET_LITTLE_ENDIAN */
+#ifndef TARGET_SUPPORTS_UNALIGNED_DWORD_POINTERS
+#define TARGET_SUPPORTS_UNALIGNED_DWORD_POINTERS    1
+#endif  /* TARGET_SUPPORTS_UNALIGNED_DWORD_POINTERS */
+#elif defined( ARM )
+#ifndef TARGET_LITTLE_ENDIAN
+#define TARGET_LITTLE_ENDIAN                        1
+#endif  /* TARGET_LITTLE_ENDIAN */
+#ifndef TARGET_SUPPORTS_UNALIGNED_DWORD_POINTERS
+#define TARGET_SUPPORTS_UNALIGNED_DWORD_POINTERS    0
+#endif  /* TARGET_SUPPORTS_UNALIGNED_DWORD_POINTERS */
+#elif defined( ARM64 )
+#ifndef TARGET_LITTLE_ENDIAN
+#define TARGET_LITTLE_ENDIAN                        1
+#endif  /* TARGET_LITTLE_ENDIAN */
+#ifndef TARGET_SUPPORTS_UNALIGNED_DWORD_POINTERS
+#define TARGET_SUPPORTS_UNALIGNED_DWORD_POINTERS    0
+#endif  /* TARGET_SUPPORTS_UNALIGNED_DWORD_POINTERS */
+#elif defined( DRM_ARCH_POWERPC )
+#ifndef TARGET_LITTLE_ENDIAN
+#define TARGET_LITTLE_ENDIAN                        0
+#endif  /* TARGET_LITTLE_ENDIAN */
+#ifndef TARGET_SUPPORTS_UNALIGNED_DWORD_POINTERS
+#define TARGET_SUPPORTS_UNALIGNED_DWORD_POINTERS    1
+#endif  /* TARGET_SUPPORTS_UNALIGNED_DWORD_POINTERS */
+/*
+** Default to little endian for GCC if TARGET_LITTLE_ENDIAN was not set
+*/
+#elif defined( DRM_GNUC_MAJOR )
+#ifndef TARGET_LITTLE_ENDIAN
+#define TARGET_LITTLE_ENDIAN                        1
+#endif  /* TARGET_LITTLE_ENDIAN */
+#ifndef TARGET_SUPPORTS_UNALIGNED_DWORD_POINTERS
+#define TARGET_SUPPORTS_UNALIGNED_DWORD_POINTERS    0
+#endif  /* TARGET_SUPPORTS_UNALIGNED_DWORD_POINTERS */
+#else  /* unknown target */
+#error Unknown target - please refer to oemcompiler.h near TARGET_LITTLE_ENDIAN
+#endif /* determining target */
+#endif  /* !defined(TARGET_LITTLE_ENDIAN) || !defined(TARGET_SUPPORTS_UNALIGNED_DWORD_POINTERS) */
+
+/*
+** +-----------------------------+
+** | BASIC TYPE/SIZE DEFINITIONS |
+** +-----------------------------+
+*/
+
+#if !DRM_BASIC_TYPE_SIZES_DEFINED
+#undef DRM_BASIC_TYPE_SIZES_DEFINED
+#define DRM_BASIC_TYPE_SIZES_DEFINED 1
+
+/*
+** In General,
+** DRM_CHAR* is used for null terminated ANSI strings
+** DRM_BYTE* is used for just plain byte buffer, w/o any termination
+*/
+
+/*
+** Wide character is special type in C++ - wchar_t,
+** while for "C" compilation it is just unsigned short.
+** So 2 different types for C and C++.
+*/
+
+/* ======================== Microsoft compiler sizes ========================== */
+/* ============================================================================ */
+#if defined(DRM_MSC_VER)
+                                                        /* Size */
+typedef unsigned __int8         DRM_BYTE;               /* 1 byte  */
+typedef __int8                  DRM_CHAR;               /* 1 byte  */
+typedef unsigned __int16        DRM_WORD;               /* 2 bytes */
+typedef unsigned __int16        DRM_WCHAR;              /* 2 bytes */
+typedef __int32                 DRM_BOOL;               /* 4 bytes */
+typedef unsigned long           DRM_DWORD;              /* 4 bytes */
+typedef unsigned __int32        DRM_WCHAR32;            /* 4 bytes */
+typedef long                    DRM_LONG;               /* 4 bytes */
+typedef unsigned __int16        DRM_WCHAR_NATIVE;       /* 2 bytes */
+
+/* =========================== GNU compiler sizes ============================= */
+/* ============================================================================ */
+#elif defined(DRM_GNUC_MAJOR)
+
+#include <stdint.h>
+#include <wchar.h>
+                                                    /* Size */
+typedef uint8_t             DRM_BYTE;               /* 1 byte  */
+typedef char                DRM_CHAR;               /* 1 byte  */
+typedef uint16_t            DRM_WORD;               /* 2 bytes */
+
+/*
+** DRM_WCHAR needs to be a 2 bytes in size.  Opt for wchar_t if it is the right size,
+** otherwise use uint16_t
+*/
+#if __WCHAR_MAX__ == 0xFFFF
+typedef wchar_t             DRM_WCHAR;              /* 2 bytes */
+#else  /* __WCHAR_MAX__ == 0xFFFF */
+typedef uint16_t            DRM_WCHAR;              /* 2 bytes */
+#endif /* __WCHAR_MAX__ == 0xFFFF */
+
+typedef int32_t             DRM_BOOL;               /* 4 bytes */
+typedef uint32_t            DRM_DWORD;              /* 4 bytes */
+typedef uint32_t            DRM_WCHAR32;            /* 4 bytes */
+
+#if DRM_64BIT_TARGET
+typedef int32_t             DRM_LONG;               /* 4 bytes */
+#else  /* DRM_64BIT_TARGET */
+typedef long                DRM_LONG;               /* 4 bytes */
+#endif /* DRM_64BIT_TARGET */
+
+#ifdef __cplusplus
+typedef wchar_t             DRM_WCHAR_NATIVE;       /* 2 bytes  */
+#else  /* __cplusplus */
+typedef uint16_t            DRM_WCHAR_NATIVE;       /* 2 bytes  */
+#endif /* __cplusplus */
+
+#define  vsprintf_s    vsnprintf
+
+/* ============================== Default sizes =============================== */
+/* ============================================================================ */
+#else /* Neither DRM_MSC_VER nor DRM_GNUC_MAJOR is defined */
+                                                        /* Size */
+typedef unsigned char           DRM_BYTE;               /* 1 byte  */
+typedef char                    DRM_CHAR;               /* 1 byte  */
+typedef unsigned short          DRM_WORD;               /* 2 bytes */
+typedef unsigned short          DRM_WCHAR;              /* 2 bytes */
+typedef int                     DRM_BOOL;               /* 4 bytes */
+typedef unsigned long           DRM_DWORD;              /* 4 bytes */
+typedef unsigned int            DRM_WCHAR32;            /* 4 bytes */
+typedef long                    DRM_LONG;               /* 4 bytes */
+
+#ifdef __cplusplus
+typedef wchar_t                 DRM_WCHAR_NATIVE;       /* 2 bytes */
+#else  /* __cplusplus */
+typedef unsigned short          DRM_WCHAR_NATIVE;       /* 2 bytes */
+#endif /* __cplusplus */
+
+#endif /* DRM_MSC_VER, DRM_GNUC_MAJOR, or neither is defined */
+
+#endif /* !DRM_BASIC_TYPE_SIZES_DEFINED */
+
+/*
+** +-----------------------------------+
+** | MACRO DEFINITIONS                 |
+** +-----------------------------------+
+*/
+
+#define DRM_OFFSET_OF(struc,member)   (DRM_SIZE_T)&(((struc *)0)->member)
+
+/*
+** DRM_SIZEOF_MEMBER uses the DRM_OFFSET_OF trick to reference a member of a struct for use in sizeof because sizeof(struct foo.bar) doesn't "just work"
+** without an explicit instance of foo
+*/
+#define DRM_SIZEOF_MEMBER(struc,member) sizeof((((struc *)0)->member))
+#define DRM_SIZEOF_MEMBER_DEREF(struc,member) sizeof(*((((struc *)0)->member)))
+
+
+/* ====================== Microsoft specific qualifiers ======================= */
+/* ============================================================================ */
+#if defined(DRM_MSC_VER)
+
+/*
+** Compile-time asserts cause PREfast warnings regarding the comparison of two constants.
+** So, enable this macro only when the PREfast tool is not analyzing the code.
+*/
+#if !defined(_PREFAST_)
+
+    /* Definition of the compile time assert. */
+    #define DRMCASSERT( x ) switch(0){case 0:case (x):;}
+
+    /* Assertion of the alignment of a member field within a structure. */
+    #define DRMALIGNASSERT( struc, member ) DRMCASSERT( ( DRM_OFFSET_OF( struc, member ) ) % sizeof( DRM_WCHAR ) == 0 )
+
+    /* Assertion of adjacency of two member fields within the same structure. */
+    #define DRMADJASSERT( struc, member1, member2 ) DRMCASSERT( ENSURE_MEMBERS_ADJACENT( struc, member1, member2 ) )
+
+#else  /* _PREFAST_ */
+    /* Definition of the compile time assert. */
+    #define DRMCASSERT( x )
+
+    /* Assertion of the alignment of a member field within a structure. */
+    #define DRMALIGNASSERT( struc, member ) DRMASSERT( ( DRM_OFFSET_OF( struc, member ) ) % sizeof( DRM_WCHAR ) == 0 )
+
+    /* Assertion of adjacency of two member fields within the same structure. */
+    #define DRMADJASSERT( struc, member1, member2 ) DRMASSERT( ENSURE_MEMBERS_ADJACENT( struc, member1, member2 ) )
+
+#endif /* _PREFAST_ */
+
+#else  /* DRM_MSC_VER */
+
+/* Definition of the compile time assert. */
+#define DRMCASSERT( x ) switch(0){case 0:case (x):;}
+
+/* Assertion of the alignment of a member field within a structure. */
+#define DRMALIGNASSERT( struc, member ) DRMASSERT( ( DRM_OFFSET_OF( struc, member ) ) % sizeof( DRM_WCHAR ) == 0 )
+
+/* Assertion of adjacency of two member fields within the same structure. */
+#define DRMADJASSERT( struc, member1, member2 ) DRMASSERT( ENSURE_MEMBERS_ADJACENT( struc, member1, member2 ) )
+
+#endif /* DRM_MSC_VER */
+
+/*
+** This option enables specific struct alignment on some Microsoft internal builds.
+** Should not be used.
+*/
+#define DRM_OBFUS_FIXED_ALIGN
+#if !defined(DRM_USE_OBFUS_STRUCT_ALIGN)
+
+#define DRM_OBFUS_FILL_BYTES(x)
+#define DRM_OBFUS_PTR_TOP
+#define DRM_OBFUS_PTR_BTM
+#define DRM_OBFUS_FIXED_ALIGN
+#define DRM_OBFUS_INIT_PTR_TOP
+#define DRM_OBFUS_INIT_PTR_BTM
+#define DRM_OBFUS_INIT_FILL
+#define DRM_OBFUS_PTR_WRAP_SIZE 0
+
+#endif /* DRM_USE_OBFUS_STRUCT_ALIGN */
+
+#if DRM_DBG
+#define DRM_FRE_INLINE              DRM_NO_INLINE
+#define DRM_FRE_INLINE_ATTRIBUTE    DRM_NO_INLINE_ATTRIBUTE
+#else  /* DRM_DBG */
+#define DRM_FRE_INLINE              DRM_ALWAYS_INLINE
+#define DRM_FRE_INLINE_ATTRIBUTE    DRM_ALWAYS_INLINE_ATTRIBUTE
+#endif /* DRM_DBG */
+
+#if DRM_INLINING_SUPPORTED
+#define DRM_INLINING_MATHSAFE_SUPPORTED 1
+#endif /* DRM_INLINING_SUPPORTED */
+
+#define DRM_GLOBAL_CONST const
+
+#if !defined(DRM_COMPILE_FOR_NORMAL_WORLD) && !defined(DRM_COMPILE_FOR_SECURE_WORLD)
+#error Both DRM_COMPILE_FOR_NORMAL_WORLD and DRM_COMPILE_FOR_SECURE_WORLD are defined.
+#elif DRM_COMPILE_FOR_NORMAL_WORLD && DRM_COMPILE_FOR_SECURE_WORLD
+#error Neither DRM_COMPILE_FOR_NORMAL_WORLD nor DRM_COMPILE_FOR_SECURE_WORLD are non-zero.
+#endif
+
+#if defined(DRM_GNUC_MAJOR)
+
+/* If using the GNU compiler use __builtin_expect to improve branch predictions */
+#define DRM_LIKELY( expr ) __builtin_expect(!!(expr),1)
+#define DRM_UNLIKELY( expr ) __builtin_expect(!!(expr),0)
+
+#else  /* DRM_GNUC_MAJOR */
+
+#define DRM_LIKELY( expr )    (expr)
+#define DRM_UNLIKELY( expr )  (expr)
+
+#endif  /* DRM_GNUC_MAJOR */
+
+/*
+** +-------------------------+
+** | 64-BIT TYPE DEFINITIONS |
+** +-------------------------+
+*/
+#if DRM_SUPPORT_NATIVE_64BIT_TYPES && !DRM_NATIVE_64BIT_TYPES_DEFINED
+#undef DRM_NATIVE_64BIT_TYPES_DEFINED
+#define DRM_NATIVE_64BIT_TYPES_DEFINED 1
+#if defined(DRM_MSC_VER)
+typedef          __int64 DRM_INT64;
+typedef unsigned __int64 DRM_UINT64;
+#elif DRM_BUILD_PROFILE == DRM_BUILD_PROFILE_MAC
+typedef          int64_t       DRM_INT64;
+typedef          uint64_t      DRM_UINT64;
+#elif defined(DRM_GNUC_MAJOR)
+typedef          int64_t       DRM_INT64;
+typedef          uint64_t      DRM_UINT64;
+#else
+#error Unknown compiler - you must typedef DRM_INT64 and DRM_UINT64 appropriately OR set DRM_SUPPORT_NATIVE_64BIT_TYPES=0
+#endif /* defined(DRM_MSC_VER) */
+#endif /* DRM_SUPPORT_NATIVE_64BIT_TYPES && !defined(DRM_NATIVE_64BIT_TYPES_DEFINED) */
+
+#endif   /* __DRMCOMPILER_H__ */
+
diff --git a/prebuilt-v4.4/noarch/include/drmconstants.h b/prebuilt-v4.4/noarch/include/drmconstants.h
new file mode 100644
index 0000000..fb28e3c
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmconstants.h
@@ -0,0 +1,263 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __DRMSTRINGS_H__
+#define __DRMSTRINGS_H__
+
+#include <drmtypes.h>
+#include <oemcryptoctx.h>
+#include <oemeccp256.h>
+
+ENTER_PK_NAMESPACE;
+
+    /* License constants */
+    extern DRM_GLOBAL_CONST  DRM_LID g_rgbSecStoreGlobalName;
+
+    /* Character constants */
+    extern DRM_GLOBAL_CONST  DRM_WCHAR              g_wchNull;
+    extern DRM_GLOBAL_CONST  DRM_WCHAR              g_wchMinus;
+    extern DRM_GLOBAL_CONST  DRM_WCHAR              g_wchPlus;
+    extern DRM_GLOBAL_CONST  DRM_WCHAR              g_wchForwardSlash;
+    extern DRM_GLOBAL_CONST  DRM_WCHAR              g_wchColon;
+    extern DRM_GLOBAL_CONST  DRM_WCHAR              g_wchComma;
+    extern DRM_GLOBAL_CONST  DRM_WCHAR              g_wchQuote;
+    extern DRM_GLOBAL_CONST  DRM_WCHAR              g_wchSingleQuote;
+    extern DRM_GLOBAL_CONST  DRM_WCHAR              g_wchNewLine;
+    extern DRM_GLOBAL_CONST  DRM_WCHAR              g_wchBackSlash;
+    extern DRM_GLOBAL_CONST  DRM_WCHAR              g_wch0;
+    extern DRM_GLOBAL_CONST  DRM_WCHAR              g_wch1;
+    extern DRM_GLOBAL_CONST  DRM_WCHAR              g_wch2;
+    extern DRM_GLOBAL_CONST  DRM_WCHAR              g_wch9;
+    extern DRM_GLOBAL_CONST  DRM_WCHAR              g_wcha;
+    extern DRM_GLOBAL_CONST  DRM_WCHAR              g_wchd;
+    extern DRM_GLOBAL_CONST  DRM_WCHAR              g_wchf;
+    extern DRM_GLOBAL_CONST  DRM_WCHAR              g_wchh;
+    extern DRM_GLOBAL_CONST  DRM_WCHAR              g_wchm;
+    extern DRM_GLOBAL_CONST  DRM_WCHAR              g_wchn;
+    extern DRM_GLOBAL_CONST  DRM_WCHAR              g_wchs;
+    extern DRM_GLOBAL_CONST  DRM_WCHAR              g_wchx;
+    extern DRM_GLOBAL_CONST  DRM_WCHAR              g_wchy;
+    extern DRM_GLOBAL_CONST  DRM_WCHAR              g_wchz;
+    extern DRM_GLOBAL_CONST  DRM_WCHAR              g_wchA;
+    extern DRM_GLOBAL_CONST  DRM_WCHAR              g_wchF;
+    extern DRM_GLOBAL_CONST  DRM_WCHAR              g_wchG;
+    extern DRM_GLOBAL_CONST  DRM_WCHAR              g_wchM;
+    extern DRM_GLOBAL_CONST  DRM_WCHAR              g_wchT;
+    extern DRM_GLOBAL_CONST  DRM_WCHAR              g_wchX;
+    extern DRM_GLOBAL_CONST  DRM_WCHAR              g_wchZ;
+    extern DRM_GLOBAL_CONST  DRM_WCHAR              g_wchUnderscore;
+    extern DRM_GLOBAL_CONST  DRM_WCHAR              g_wchPeriod;
+    extern DRM_GLOBAL_CONST  DRM_WCHAR              g_wchQuestionMark;
+    extern DRM_GLOBAL_CONST  DRM_WCHAR              g_wchExclamationMark;
+    extern DRM_GLOBAL_CONST  DRM_WCHAR              g_wchOpenParen;
+    extern DRM_GLOBAL_CONST  DRM_WCHAR              g_wchCloseParen;
+    extern DRM_GLOBAL_CONST  DRM_WCHAR              g_wchPound;
+    extern DRM_GLOBAL_CONST  DRM_WCHAR              g_wchSpace;
+    extern DRM_GLOBAL_CONST  DRM_WCHAR              g_wchTab;
+    extern DRM_GLOBAL_CONST  DRM_WCHAR              g_wchLineFeed;
+    extern DRM_GLOBAL_CONST  DRM_WCHAR              g_wchVerticalTab;
+    extern DRM_GLOBAL_CONST  DRM_WCHAR              g_wchFormFeed;
+    extern DRM_GLOBAL_CONST  DRM_WCHAR              g_wchCarriageReturn;
+    extern DRM_GLOBAL_CONST  DRM_WCHAR              g_wchEqual;
+    extern DRM_GLOBAL_CONST  DRM_WCHAR              g_wchOpenCurly;
+    extern DRM_GLOBAL_CONST  DRM_WCHAR              g_wchCloseCurly;
+    extern DRM_GLOBAL_CONST  DRM_WCHAR              g_wchLessThan;
+    extern DRM_GLOBAL_CONST  DRM_WCHAR              g_wchGreaterThan;
+    extern DRM_GLOBAL_CONST  DRM_WCHAR              g_wchLeftBracket;
+    extern DRM_GLOBAL_CONST  DRM_WCHAR              g_wchRightBracket;
+    extern DRM_GLOBAL_CONST  DRM_WCHAR              g_wchAsterisk;
+    extern DRM_GLOBAL_CONST  DRM_WCHAR              g_wchPercent;
+    extern DRM_GLOBAL_CONST  DRM_WCHAR              g_wchSemiColon;
+    extern DRM_GLOBAL_CONST  DRM_WCHAR              g_wchAmpersand;
+    extern DRM_GLOBAL_CONST  DRM_WCHAR              g_wchPipe;
+
+    /* Character constants - ANSI */
+    extern DRM_GLOBAL_CONST  DRM_CHAR               g_chForwardSlash;
+    extern DRM_GLOBAL_CONST  DRM_CHAR               g_chPeriod;
+    extern DRM_GLOBAL_CONST  DRM_CHAR               g_chNull;
+    extern DRM_GLOBAL_CONST  DRM_CHAR               g_chMinus;
+    extern DRM_GLOBAL_CONST  DRM_CHAR               g_chPlus;
+    extern DRM_GLOBAL_CONST  DRM_CHAR               g_ch0;
+    extern DRM_GLOBAL_CONST  DRM_CHAR               g_ch9;
+    extern DRM_GLOBAL_CONST  DRM_CHAR               g_cha;
+    extern DRM_GLOBAL_CONST  DRM_CHAR               g_chA;
+
+    /* Misc strings shared across disparate functional areas */
+    extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING  g_adstrLicenseRespTag;
+    extern DRM_GLOBAL_CONST  DRM_CONST_STRING       g_dstrGUID;
+    extern DRM_GLOBAL_CONST  DRM_CONST_STRING       g_dstrFlag;
+    extern DRM_GLOBAL_CONST  DRM_CONST_STRING       g_dstrSecureClockNotSet;
+    extern DRM_GLOBAL_CONST  DRM_CONST_STRING       g_dstrSecureClockSet;
+    extern DRM_GLOBAL_CONST  DRM_CONST_STRING       g_dstrSecureClockNeedsRefresh;
+    extern DRM_GLOBAL_CONST  DRM_CONST_STRING       g_dstrExprVarSavedDateTime;
+    extern DRM_GLOBAL_CONST  DRM_CONST_STRING       g_dstrTagMetering;
+
+    /* Rights */
+    extern DRM_GLOBAL_CONST  DRM_CONST_STRING       g_dstrDRM_RIGHT_NONE;
+    extern DRM_GLOBAL_CONST  DRM_CONST_STRING       g_dstrDRM_RIGHT_PLAYBACK;
+    extern DRM_GLOBAL_CONST  DRM_CONST_STRING       g_dstrDRM_RIGHT_COLLABORATIVE_PLAY;
+    extern DRM_GLOBAL_CONST  DRM_CONST_STRING       g_dstrDRM_RIGHT_COPY;
+    extern DRM_GLOBAL_CONST  DRM_CONST_STRING       g_dstrDRM_RIGHT_CREATE_THUMBNAIL_IMAGE;
+    extern DRM_GLOBAL_CONST  DRM_CONST_STRING       g_dstrDRM_RIGHT_COPY_TO_CD;
+
+    /* Script varibles used for license properties. */
+    extern DRM_GLOBAL_CONST  DRM_CONST_STRING       g_dstrDRM_LS_COUNT_ATTR;
+    extern DRM_GLOBAL_CONST  DRM_CONST_STRING       g_dstrDRM_LS_FIRSTUSE_ATTR;
+    extern DRM_GLOBAL_CONST  DRM_CONST_STRING       g_dstrDRM_LS_FIRSTSTORE_ATTR;
+    extern DRM_GLOBAL_CONST  DRM_CONST_STRING       g_dstrDRM_LS_PLAYCOUNT_ATTR;
+    extern DRM_GLOBAL_CONST  DRM_CONST_STRING       g_dstrDRM_LS_COPYCOUNT_ATTR;
+    extern DRM_GLOBAL_CONST  DRM_CONST_STRING       g_dstrDRM_LS_DELETED_ATTR;
+
+    /* Shared XML tags */
+    extern DRM_GLOBAL_CONST  DRM_CONST_STRING       g_dstrAttributeVersion;
+    extern DRM_GLOBAL_CONST  DRM_CONST_STRING       g_dstrTagData;
+    extern DRM_GLOBAL_CONST  DRM_CONST_STRING       g_dstrTagIndex;
+    extern DRM_GLOBAL_CONST  DRM_CONST_STRING       g_dstrTagPubkey;
+    extern DRM_GLOBAL_CONST  DRM_CONST_STRING       g_dstrTagValue;
+    extern DRM_GLOBAL_CONST  DRM_CONST_STRING       g_dstrTagSignature;
+    extern DRM_GLOBAL_CONST  DRM_CONST_STRING       g_dstrTagHashAlg;
+    extern DRM_GLOBAL_CONST  DRM_CONST_STRING       g_dstrTagSignAlg;
+    extern DRM_GLOBAL_CONST  DRM_CONST_STRING       g_dstrSHA;
+    extern DRM_GLOBAL_CONST  DRM_CONST_STRING       g_dstrMSDRM;
+    extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING  g_dastrAttributeType;
+    extern DRM_GLOBAL_CONST  DRM_CONST_STRING       g_dstrAttributeType;
+    extern DRM_GLOBAL_CONST  DRM_CONST_STRING       g_dstrTagCertificate;
+    extern DRM_GLOBAL_CONST  DRM_CONST_STRING       g_dstrTagWrmHeader;
+    extern DRM_GLOBAL_CONST  DRM_CONST_STRING       g_dstrAttributeVersion2Value;
+    extern DRM_GLOBAL_CONST  DRM_CONST_STRING       g_dstrAttributeVersion4Value;
+    extern DRM_GLOBAL_CONST  DRM_CONST_STRING       g_dstrAttributeVersion4_1Value;
+    extern DRM_GLOBAL_CONST  DRM_CONST_STRING       g_dstrAttributeVersion4_2Value;
+    extern DRM_GLOBAL_CONST  DRM_CONST_STRING       g_dstrAttributeVersion4_3Value;
+    extern DRM_GLOBAL_CONST  DRM_CONST_STRING       g_dstrTagLAINFO;
+    extern DRM_GLOBAL_CONST  DRM_CONST_STRING       g_dstrTagV4DATA;
+    extern DRM_GLOBAL_CONST  DRM_CONST_STRING       g_dstrTagLAURL;
+    extern DRM_GLOBAL_CONST  DRM_CONST_STRING       g_dstrTagLUIURL;
+    extern DRM_GLOBAL_CONST  DRM_CONST_STRING       g_dstrTagDSID;
+    extern DRM_GLOBAL_CONST  DRM_CONST_STRING       g_dstrTagKID;
+    extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING  g_dastrTagKID;
+    extern DRM_GLOBAL_CONST  DRM_CONST_STRING       g_dstrTagKIDS;
+    extern DRM_GLOBAL_CONST  DRM_CONST_STRING       g_dstrTagChecksum;
+    extern DRM_GLOBAL_CONST  DRM_CONST_STRING       g_dstrTagAlgID;
+    extern DRM_GLOBAL_CONST  DRM_CONST_STRING       g_dstrTagUplink;
+    extern DRM_GLOBAL_CONST  DRM_CONST_STRING       g_dstrTagDecryptorSetup;
+    extern DRM_GLOBAL_CONST  DRM_CONST_STRING       g_dstrTagProtectInfo;
+    extern DRM_GLOBAL_CONST  DRM_CONST_STRING       g_dstrTagKeyLen;
+    extern DRM_GLOBAL_CONST  DRM_CONST_STRING       g_dstrKeyLenNodeDataCocktail;
+    extern DRM_GLOBAL_CONST  DRM_CONST_STRING       g_dstrKeyLenNodeDataAESCTR;
+    extern DRM_GLOBAL_CONST  DRM_CONST_STRING       g_dstrKeyLenNodeDataAESCBC;
+    extern DRM_GLOBAL_CONST  DRM_CONST_STRING       g_dstrTagCOCKTAIL;
+    extern DRM_GLOBAL_CONST  DRM_CONST_STRING       g_dstrTagAESCTR;
+    extern DRM_GLOBAL_CONST  DRM_CONST_STRING       g_dstrTagAESCBC;
+    extern DRM_GLOBAL_CONST  DRM_CONST_STRING       g_dstrTagCustomAttributes;
+    extern DRM_GLOBAL_CONST  DRM_CONST_STRING       g_dstrTagONDEMAND;
+    extern DRM_GLOBAL_CONST  DRM_CONST_STRING       g_dstrEmptyWRMHeaderV4_1;
+    extern DRM_GLOBAL_CONST  DRM_CONST_STRING       g_dstrEmptyWRMHeaderV4_2;
+    extern DRM_GLOBAL_CONST  DRM_CONST_STRING       g_dstrEmptyWRMHeaderV4_3;
+    extern DRM_GLOBAL_CONST  DRM_CONST_STRING       g_dstrTagAction;
+    extern DRM_GLOBAL_CONST  DRM_CONST_STRING       g_dstrTagSecurityVersion;
+    extern DRM_GLOBAL_CONST  DRM_CONST_STRING       g_dstrTagMID;
+    extern DRM_GLOBAL_CONST  DRM_CONST_STRING       g_dstrTagTID;
+    extern DRM_GLOBAL_CONST  DRM_CONST_STRING       g_dstrTagURL;
+    extern DRM_GLOBAL_CONST  DRM_CONST_STRING       g_dstrLabelValue;
+    extern DRM_GLOBAL_CONST  DRM_CONST_STRING       g_dstrChallenge;
+    extern DRM_GLOBAL_CONST  DRM_CONST_STRING       g_dstrTagCertificateChain;
+    extern DRM_GLOBAL_CONST  DRM_CONST_STRING       g_dstrTagPrivateKey;
+    extern DRM_GLOBAL_CONST  DRM_CONST_STRING       g_dstrTagDataPubKey;
+    extern DRM_GLOBAL_CONST  DRM_CONST_STRING       g_dstrTemplate;
+    extern DRM_GLOBAL_CONST  DRM_CONST_STRING       g_dstrTagDataSecVerPlatform;
+    extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING  g_dastrLicAcqReeTag;
+
+    /* Shared Certificate tags */
+    extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING  g_dastrAttributeAlgorithm;
+    extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING  g_dastrKeyUsageSignCert;
+    extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING  g_dastrKeyUsageEncryptKey;
+    extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING  g_dastrOne;
+    extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING  g_dastrPrefixManufacturer;
+    extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING  g_dastrTagCanonicalization;
+    extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING  g_dastrTagCertificateCollection;
+    extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING  g_dastrTagDigestMethod;
+    extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING  g_dastrURIDSigSHA1;
+    extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING  g_dastrTagDigestValue;
+    extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING  g_dastrTagSignatureValue;
+    extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING  g_dastrTagKeyInfo;
+    extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING  g_dastrTagPublicKey;
+    extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING  g_dastrTagPrivateKey;
+    extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING  g_dastrTagKeyValue;
+    extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING  g_dastrTagRSAKeyValue;
+    extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING  g_dastrTagModulus;
+    extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING  g_dastrTagExponent;
+    extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING  g_dastrTagManufacturerName;
+    extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING  g_dastrTagManufacturerData;
+    extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING  g_dastrURIRSASHA1;
+    extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING  g_dastrURIRSASHA1_Old;
+    extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING  g_dastrTagReference;
+    extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING  g_dastrTagTransforms;
+    extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING  g_dastrTagTransform;
+    extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING  g_dastrURITransformMSCert;
+    extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING  g_dastrURITransformMSCertColl;
+    extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING  g_dastrURITransformMSCert_Old;
+    extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING  g_dastrURITransformC14N;
+    extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING  g_dastrTagSignature;
+    extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING  g_dastrTagSignatureMethod;
+    extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING  g_dastrTagSignedInfo;
+    extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING  g_dastrURIC14N;
+    extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING  g_dastrPrefixMicrosoftCert;
+    extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING  g_dastrMSNDRootPubKeyB64;
+
+    /* Well-known public Keys */
+    extern DRM_GLOBAL_CONST  PUBKEY_P256            g_ECC256MSPlayReadyRootIssuerPubKey;
+
+    /* Revocation GUIDs */
+    DRM_DECLARE_GUID( g_guidRevocationTypeRevInfo );
+    DRM_DECLARE_GUID( g_guidRevocationTypeRevInfo2 );
+    DRM_DECLARE_GUID( g_guidRevocationTypeLegacyXMLCert );
+    DRM_DECLARE_GUID( g_guidRevocationTypePlayReadySilverLightRuntime );
+    DRM_DECLARE_GUID( g_guidRevocationTypePlayReadySilverLightApplication );
+    DRM_DECLARE_GUID( g_guidRevocationTypeGRL );
+
+    /* Actions GUIDs. Used with DRM_LEVL_PerformOperationsXMR() API */
+    DRM_DECLARE_GUID( DRM_ACTION_PLAY );
+    DRM_DECLARE_GUID( DRM_ACTION_COPY );
+    DRM_DECLARE_GUID( DRM_ACTION_CREATE_THUMBNAIL );
+    DRM_DECLARE_GUID( DRM_ACTION_COLLABORATIVE_PLAY );
+    DRM_DECLARE_GUID( DRM_ACTION_COPY_TO_CD );
+    DRM_DECLARE_GUID( DRM_ACTION_COPY_TO_PC );
+    DRM_DECLARE_GUID( DRM_ACTION_COPY_TO_DEVICE );
+
+    DRM_DECLARE_GUID( DRM_PR_PROTECTION_SYSTEM_ID );
+
+    DRM_DECLARE_GUID( g_guidNull );
+
+    /* PlayEnabler GUIDS */
+    DRM_DECLARE_GUID( DRM_PLAYENABLER_UNKNOWN_OUTPUT );
+    DRM_DECLARE_GUID( DRM_PLAYENABLER_CONSTRAINED_RESOLUTION_UNKNOWN_OUTPUT );
+    DRM_DECLARE_GUID( DRM_PLAYENABLER_MIRACAST );
+
+    /* Digital Video Output Protection GUIDs */
+    DRM_DECLARE_GUID( g_guidHDCPTypeRestriction ); /* HDCP Type Restriction            */
+    DRM_DECLARE_GUID( g_guidMaxResDecode );        /* MaxRes Decode                    */
+
+    /* Digital Audio Output Protection GUIDs */
+    DRM_DECLARE_GUID( g_guidSCMS );                /* SCMS control bits                */
+
+    /* Analog Video Output Protection GUIDs */
+    DRM_DECLARE_GUID( g_guidBestEffortCGMSA );     /* Best Effort CGMS-A               */
+    DRM_DECLARE_GUID( g_guidCGMSA );               /* CGMS-A                           */
+    DRM_DECLARE_GUID( g_guidDigitalOnlyToken );    /* DigitalToken                     */
+    DRM_DECLARE_GUID( g_guidAGC );                 /* AGCColorStrip                    */
+    DRM_DECLARE_GUID( g_guidVGA_MaxRes );          /* MAX_VGA_RESOLUTION:downres       */
+    DRM_DECLARE_GUID( g_guidComponent_MaxRes );    /* MAX_COMPONENT_RESOLUTION:downres */
+
+    DRM_DECLARE_GUID( g_guidPsshBox );
+
+    extern DRM_GLOBAL_CONST DRM_ID g_idNull;
+
+EXIT_PK_NAMESPACE;
+
+#endif /* __DRMSTRINGS_H__ */
+
diff --git a/prebuilt-v4.4/noarch/include/drmcontextsizes.h b/prebuilt-v4.4/noarch/include/drmcontextsizes.h
new file mode 100644
index 0000000..1ee8ca8
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmcontextsizes.h
@@ -0,0 +1,174 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __DRMCONTEXTSIZES_H__
+#define __DRMCONTEXTSIZES_H__
+
+#include <drmtypes.h>
+#include <oemcryptoctx.h>
+#include <drmstkalloctypes.h>
+#include <drmdatastoretypes.h>
+#include <drmhds.h>
+#include <drmsecurestore.h>
+#include <drmliceval.h>
+#include <drmutilitieslite.h>
+#include <drmmetercertstore.h>
+#include <drmblackboxtypes.h>
+#include <drmlicstore.h>
+#include <drmoutputleveltypes.h>
+#include <drmchaintypes.h>
+#include <drmplayreadyobj.h>
+#include <drmdomainstoretypes.h>
+#include <drmnoncestore.h>
+#include <drmlicgentypes.h>
+#include <drmsecurecoretypes.h>
+#include <drmsecurestoptypes.h>
+
+ENTER_PK_NAMESPACE;
+
+/* Recommended activation context size. */
+#define ACTIVATION_CONTEXT_SIZE                  1024
+
+/* The buffer should be big enough to store a single XMR license. */
+#define DRM_DEFAULT_IN_MEMORY_LICENSE_SIZE       1024
+
+/* The maximum buffer should be big enough to store 200 XMR licenses. */
+#define DRM_MAX_IN_MEMORY_LICENSE_STORE_SIZE     204800
+
+/* The maximum buffer size of an In memory SecureStore. */
+#define DRM_MAX_IN_MEMORY_SECURE_STORE_SIZE      204800
+
+typedef enum _DRM_CONTENT_SET_PROPERTY
+{
+    DRM_CSP_HEADER_NOT_SET          = 0,
+    DRM_CSP_V1_HEADER               = 1,
+    DRM_CSP_V2_HEADER               = 2,
+    DRM_CSP_KID                     = 3,
+    DRM_CSP_V2_4_HEADER             = 5,
+    DRM_CSP_V4_HEADER               = 6,
+    DRM_CSP_AUTODETECT_HEADER       = 7,
+    DRM_CSP_PLAYREADY_OBJ           = 8,
+    DRM_CSP_V4_1_HEADER             = 9,
+    DRM_CSP_PLAYREADY_OBJ_WITH_KID  = 10,
+    DRM_CSP_HEADER_COMPONENTS       = 11,
+    DRM_CSP_V4_2_HEADER             = 12,
+    DRM_CSP_DECRYPTION_OUTPUT_MODE  = 13,
+    DRM_CSP_SELECT_KID              = 14,
+    DRM_CSP_V4_3_HEADER             = 15,
+} DRM_CONTENT_SET_PROPERTY;
+
+typedef enum _DRM_CONTENT_GET_PROPERTY
+{
+    DRM_CGP_HEADER_KID              = 0,
+    DRM_CGP_HEADER_TYPE             = 1,
+    DRM_CGP_HEADER                  = 2,
+    DRM_CGP_PLAYREADY_OBJ           = 3,
+    DRM_CGP_CIPHER_TYPE             = 4,
+    DRM_CGP_DECRYPTORSETUP          = 5,
+    DRM_CGP_HEADER_KIDS             = 6,
+    DRM_CGP_DECRYPTION_OUTPUT_MODE  = 7,
+} DRM_CONTENT_GET_PROPERTY;
+
+PREFAST_PUSH_DISABLE_EXPLAINED( __WARNING_POOR_DATA_ALIGNMENT_25021, "Ignore poor data alignment that occurs due to making structures human-readable" )
+
+typedef struct __tagDRM_APP_CONTEXT_INTERNAL
+{
+    DRM_BOOL                    fLicStoreOpenXMR;
+    DRM_BOOL                    fSecStoreGlobalContextOpen;
+    DRM_CONTENT_SET_PROPERTY    eHeaderInContext;
+    DRM_BOOL                    fCanBind;
+
+    DRM_BOOL                    fResponseSignatureChecked;
+    DRM_DWORD                   dwLastResponseProtocol;
+
+    DRM_VOID                   *pOEMContext;
+
+    DRM_KID                     KID;
+
+    DRM_BINDING_INFO            oBindInfo[DRM_MAX_LICENSE_CHAIN_DEPTH];
+    DRM_XMRFORMAT               licenseXMR[DRM_MAX_LICENSE_CHAIN_DEPTH];
+
+    DRM_LICSTORE_CONTEXT        oLicStoreContextXMR;
+    DRM_LICSTORE_CONTEXT        oLicStoreContextEmbedded;
+    DRM_LICSTOREENUM_CONTEXT    oLicEnum[DRM_MAX_LICENSE_CHAIN_DEPTH];
+    DRM_LICSTOREENUM_MULTIPLE_CONTEXT oLicEnumMultiple[DRM_MAX_LICENSE_CHAIN_DEPTH];
+
+    DRM_LICEVAL_CONTEXT         oLicEvalContext;
+    DRM_SECSTORE_CONTEXT        oSecStoreGlobalContext;
+
+    DRM_DWORD                   dwChainDepth;
+    DRM_SECSTORE_CONTEXT        rgcontextSST[DRM_MAX_LICENSE_CHAIN_DEPTH];
+
+    DRM_SECSTORE_CONTEXT        contextSSTCertCache;
+
+    DRM_REVLIST_ID_VALUES        idCRLsCurrent;
+    DRM_REVOCATIONSTORE_CONTEXT  oRevContext;
+
+    DRM_BYTE                    *pbRevocationBuffer;
+    DRM_DWORD                    cbRevocationBuffer;
+
+    DRM_FFLICENSE                oFFLicense;
+    DRM_METERCERT_CONTEXT        oMeterCertContext;
+    DRM_DST                      oDatastoreHDS;
+    DRM_HDS_CONTEXT              oContextHDS;
+    DRM_DST                      oDatastoreEST;
+    DRM_EST_CONTEXT              oContextEST;
+    DRM_BOOL                     fStoreOpened;
+
+    DRM_BYTE                    *pbOpaqueBuffer;
+    DRM_DWORD                    cbOpaqueBuffer;
+    DRM_BYTE                    *pbDRMHeaderData;  /* Should always point to the start of pbOpaqueBuffer */
+    DRM_DWORD                    cbDRMHeaderData;  /* Should always be cbOpaqueBuffer - DRM_DWORD_ALIGNED_SIZE( DRM_MAX_LICENSESIZE ) */
+    DRM_BYTE                    *pbDRMLicense;    /* Should always point to the last DRM_DWORD_ALIGNED_SIZE( DRM_MAX_LICENSESIZE ) bytes of pbOpaqueBuffer */
+    DRM_DWORD                    cbDRMLicense;    /* Should always be DRM_DWORD_ALIGNED_SIZE( DRM_MAX_LICENSESIZE ) */
+
+    DRM_WCHAR                   *pwszHeaderData;  /* Used with pbDRMHeaderData: Points into the PRO at the V4 header */
+    DRM_DWORD                    cbHeaderData;
+    DRM_BYTE                    *pbEmbeddedStore; /* Used with pbDRMHeaderData: Points into the PRO at the embedded store */
+    DRM_DWORD                    cbEmbeddedStore;
+    DRM_DWORD                    cbPROData;       /* Used with pbDRMHeaderData: Specifies the length of the entire PRO if it is set  */
+    DRM_DWORD                    cbTotalHeaderData; /* Used with pbDRMHeaderData: Specifies the total length of the buffer filled with header data or PRO data */
+
+    DRM_BOOL                     fClockSet;
+    DRM_BOOL                     fBindThenCommit;
+    DRM_DWORD                    dwSourceid;
+
+    DRM_DWORD                    dwLicRevInfoVer;
+
+    DRM_DOMAINSTORE_CONTEXT      oDomainStoreContext;
+    DRM_LICSTORE_CONTEXT         oLicStoreContextNST;
+    DRM_NONCESTORE_CONTEXT       oNonceStoreContext;
+
+    DRM_DWORD                    cbNSTBuffer;
+    DRM_BYTE                    *pbNSTBuffer;
+
+    DRM_CHAR                     szClientVersion[DRM_VER_STRING_MAX_LEN];
+    DRM_BYTE                    *pbActivationCtx;
+
+    DRM_DST                          oDSTContextMemSST;
+    DRM_EST_CONTEXT                  oESTContextMemSST;
+    DRM_BYTE                        *pbMemSSTStore;
+    DRM_DWORD                        cbMemSSTStore;
+
+    DRM_LOCAL_LICENSE_CONTEXT       *poLocalLicenseContext;
+
+    DRM_SECURECORE_CONTEXT           oSecureCoreCtx;
+    DRM_DWORD                        dwDecryptionOutputMode;   /* Refer to the member with the same name in DRM_FFLICENSE */
+
+    DRM_SECURESTOP_CONTEXT           oSecureStopCtx;
+
+} DRM_APP_CONTEXT_INTERNAL;
+
+PREFAST_POP /* __WARNING_POOR_DATA_ALIGNMENT_25021 */
+
+#define DRM_APP_CONTEXT_BUFFER_SIZE        sizeof( DRM_APP_CONTEXT_INTERNAL )
+
+EXIT_PK_NAMESPACE;
+
+#endif /* __DRMCONTEXTSIZES_H__ */
+
diff --git a/prebuilt-v4.4/noarch/include/drmcontract.h b/prebuilt-v4.4/noarch/include/drmcontract.h
new file mode 100644
index 0000000..eb0788f
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmcontract.h
@@ -0,0 +1,110 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+/*
+** Header file for the Error contract mechanism.
+*/
+
+#ifndef __DRMCONTRACT_H__
+#define __DRMCONTRACT_H__
+
+#include <drmtypes.h>
+
+ENTER_PK_NAMESPACE;
+
+/*
+** The following are the API IDs for each top-level API with an Error Code Contract (ECC).
+** The order here is alphabetical by name to match the ordering in the .chm help file:
+**     PlayReady.chm --> Programming Reference --> DRM Functions
+**
+** IF YOU ADD/DELETE ANY APIs HERE, YOU MUST ALSO:
+** 1) ENSURE THAT THE CHM FILE IS UP-TO-DATE
+** 2) UPDATE THE g_prgdrErrorCodelist ARRAY IN 'drmcontract.c' TO MATCH THIS ORDERING
+** 3) POSSIBLY UPDATE THE TEST FILE ...\Test\Utils\ErrorContractTest.pc.pk.ce.txt (HAS HARDCODED API IDs)
+*/
+enum ECC_DRM_API_List
+{
+    ECC_DRM_GENERIC_ERROR_LIST = 0,
+
+    ECC_Drm_Content_UpdateEmbeddedStore,
+    ECC_Drm_Content_SetProperty,
+    ECC_Drm_Device_GetProperty,
+    ECC_Drm_DomainCert_EnumNext,
+    ECC_Drm_DomainCert_Find,
+    ECC_Drm_DomainCert_InitEnum,
+    ECC_Drm_Envelope_Close,
+    ECC_Drm_Envelope_DuplicateFileContext,
+    ECC_Drm_Envelope_GetSize,
+    ECC_Drm_Envelope_GetOriginalFileName,
+    ECC_Drm_Envelope_InitializeRead,
+    ECC_Drm_Envelope_Open,
+    ECC_Drm_Envelope_Read,
+    ECC_Drm_Envelope_Seek,
+    ECC_Drm_GetAdditionalResponseData,
+    ECC_Drm_Initialize,
+    ECC_Drm_JoinDomain_GenerateChallenge,
+    ECC_Drm_JoinDomain_ProcessResponse,
+    ECC_Drm_LeaveDomain_GenerateChallenge,
+    ECC_Drm_LeaveDomain_ProcessResponse,
+    ECC_Drm_License_GetProperty,
+    ECC_Drm_LicenseAcq_GenerateChallenge,
+    ECC_Drm_LicenseAcq_GenerateAck,
+    ECC_Drm_LicenseAcq_GetContentHeader,
+    ECC_Drm_LicenseAcq_ProcessAckResponse,
+    ECC_Drm_LicenseAcq_ProcessResponse,
+    ECC_Drm_LicenseQuery_GetState,
+    ECC_Drm_LicenseQuery_IsAllowed,
+    ECC_Drm_MeterCert_Delete,
+    ECC_Drm_MeterCert_EnumNext,
+    ECC_Drm_MeterCert_GenerateChallenge,
+    ECC_Drm_MeterCert_InitEnum,
+    ECC_Drm_MeterCert_Invalidate,
+    ECC_Drm_MeterCert_ProcessResponse,
+    ECC_Drm_MeterCert_Update,
+    ECC_Drm_Metering_GenerateChallenge,
+    ECC_Drm_Metering_ProcessResponse,
+    ECC_Drm_ProcessCommand,
+    ECC_Drm_ProcessRequest,
+    ECC_Drm_Reader_Bind,
+    ECC_Drm_Reader_Commit,
+    ECC_Drm_Reader_Decrypt,
+    ECC_Drm_Reinitialize,
+    ECC_Drm_SecureTime_GenerateChallenge,
+    ECC_Drm_SecureTime_GetValue,
+    ECC_Drm_SecureTime_ProcessResponse,
+    ECC_Drm_StoreMgmt_CleanupStore,
+    ECC_Drm_StoreMgmt_DeleteLicenses,
+    ECC_Drm_Uninitialize,
+    ECC_Drm_Content_GetProperty,
+    ECC_Drm_Envelope_WritePlayReadyObject,
+    ECC_Drm_Content_UpdateEmbeddedStore_Commit,
+    ECC_Drm_PlayReadyObject_ConvertFromWmdrmHeader,
+};
+
+/*
+** Macro to interface with the DRM API.
+** The argument 'apivalue' should be one of the values defined above
+*/
+#define ChkECC( apivalue, dr ) DRM_DO {                                                                 \
+    if( DRM_CONTRACT_IsContractSupported()                                                              \
+     && DRM_FAILED( dr )                                                                                \
+     && !OEM_ECC_ExpectedErrorCode( apivalue, dr ) )                                                    \
+    {                                                                                                   \
+        DRM_DBG_TRACE( ( "Error code 0x%X doesn't match expected error codes for "#apivalue, dr ) );    \
+        DRMASSERT( FALSE ) ;                                                                            \
+    }                                                                                                   \
+} DRM_WHILE_FALSE
+
+DRM_API DRM_BOOL DRM_CALL OEM_ECC_ExpectedErrorCode(
+    __in const DRM_DWORD  f_uiAPIid,
+    __in const DRM_RESULT f_dr );
+
+EXIT_PK_NAMESPACE;
+
+#endif   /* __DRMCONTRACT_H__ */
+
diff --git a/prebuilt-v4.4/noarch/include/drmcrt.h b/prebuilt-v4.4/noarch/include/drmcrt.h
new file mode 100644
index 0000000..f43a493
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmcrt.h
@@ -0,0 +1,180 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __DRMCRT_H__
+#define __DRMCRT_H__
+
+#include <drmstrsafe.h>
+
+#if DRM_BUILD_PROFILE == DRM_BUILD_PROFILE_WP8_1 || DRM_BUILD_PROFILE == DRM_BUILD_PROFILE_IOS || DRM_BUILD_PROFILE == DRM_BUILD_PROFILE_MAC
+#ifndef DRM_BUILDING_CRTIMPLREAL_C
+#include <oemcommonmem.h>
+#endif  /* DRM_BUILDING_CRTIMPLREAL_C */
+#endif  /* DRM_BUILD_PROFILE == DRM_BUILD_PROFILE_WP8_1 || DRM_BUILD_PROFILE == DRM_BUILD_PROFILE_IOS || DRM_BUILD_PROFILE == DRM_BUILD_PROFILE_MAC */
+
+ENTER_PK_NAMESPACE;
+
+/* String CRT functions */
+
+DRM_API DRM_BOOL  DRM_CALL DRMCRT_iswspace  (DRM_WCHAR wch);
+DRM_API DRM_BOOL  DRM_CALL DRMCRT_iswxdigit (DRM_WCHAR wch);
+DRM_API DRM_BOOL  DRM_CALL DRMCRT_iswdigit  (DRM_WCHAR wch);
+DRM_API DRM_BOOL  DRM_CALL DRMCRT_iswalpha  (DRM_WCHAR wch);
+DRM_API DRM_WCHAR DRM_CALL DRMCRT_towlower  (DRM_WCHAR wch);
+
+DRM_API DRM_BOOL  DRM_CALL DRMCRT_isdigit   (DRM_CHAR ch);
+
+#if DRM_BUILD_PROFILE == DRM_BUILD_PROFILE_WP8_1 || DRM_BUILD_PROFILE == DRM_BUILD_PROFILE_IOS || DRM_BUILD_PROFILE == DRM_BUILD_PROFILE_ANDROID || DRM_BUILD_PROFILE == DRM_BUILD_PROFILE_MAC
+
+#ifndef DRM_BUILDING_CRTIMPLREAL_C
+#ifdef DRMCRT_memcpy
+#undef DRMCRT_memcpy
+#endif
+#ifdef DRMCRT_memset
+#undef DRMCRT_memset
+#endif
+#ifdef DRMCRT_memcmp
+#undef DRMCRT_memcmp
+#endif
+
+#if defined(DRM_MSC_VER) || defined(DRM_GNUC_MAJOR)
+DRM_ALWAYS_INLINE int DRM_CALL DRMCRT_LocalMemcmp(
+    __in_bcount( f_cbCount ) const  DRM_VOID  *f_pLHS,
+    __in_bcount( f_cbCount ) const  DRM_VOID  *f_pRHS,
+    __in                            DRM_DWORD  f_cbCount ) DRM_ALWAYS_INLINE_ATTRIBUTE;
+
+DRM_ALWAYS_INLINE int DRM_CALL DRMCRT_LocalMemcmp(
+    __in_bcount( f_cbCount ) const  DRM_VOID  *f_pLHS,
+    __in_bcount( f_cbCount ) const  DRM_VOID  *f_pRHS,
+    __in                            DRM_DWORD  f_cbCount )
+{
+    /* Without volatile, some compilers can figure out this is an implementation of a memcmp */
+    volatile const char * pRHS = (const char *) f_pRHS;
+    const char * pLHS = (const char *) f_pLHS;
+    while (f_cbCount--)
+    {
+        if(*pLHS < *pRHS)
+        {
+            return -1;
+        }
+        else if(*pLHS > *pRHS)
+        {
+            return 1;
+        }
+        pLHS++;
+        pRHS++;
+    }
+    return 0;
+}
+
+#else   /* defined(DRM_MSC_VER) || defined(DRM_GNUC_MAJOR) */
+#error "Unexpected Error: In the profile currently being compiled, either DRM_MSC_VER or DRM_GNUC_MAJOR *should* be defined."
+#endif  /* defined(DRM_MSC_VER) || defined(DRM_GNUC_MAJOR) */
+
+#define DRMCRT_memcpy OEM_SECURE_MEMCPY
+#define DRMCRT_memset OEM_SECURE_MEMSET
+#define DRMCRT_memcmp DRMCRT_LocalMemcmp
+
+#endif  /* DRM_BUILDING_CRTIMPLREAL_C */
+
+#else /* DRM_BUILD_PROFILE == DRM_BUILD_PROFILE_WP8_1 || DRM_BUILD_PROFILE == DRM_BUILD_PROFILE_IOS || DRM_BUILD_PROFILE == DRM_BUILD_PROFILE_ANDROID || DRM_BUILD_PROFILE == DRM_BUILD_PROFILE_MAC */
+
+DRM_API DRM_LONG DRM_CALL DRMCRT_memcmp(
+    __in_bcount( count ) const DRM_VOID   *src1,
+    __in_bcount( count ) const DRM_VOID   *src2,
+    __in                       DRM_SIZE_T  count );
+
+DRM_API_VOID DRM_VOID DRM_CALL DRMCRT_memset(
+    __out_bcount( count ) DRM_VOID   *dst,
+    __in                  DRM_DWORD   b,
+    __in                  DRM_SIZE_T  count );
+
+DRM_API_VOID DRM_VOID DRM_CALL DRMCRT_memcpy(
+    __out_bcount( count )       DRM_VOID   *dst,
+    __in_bcount( count )  const DRM_VOID   *src,
+    __in                        DRM_SIZE_T  count );
+
+#endif /* DRM_BUILD_PROFILE == DRM_BUILD_PROFILE_WP8_1 || DRM_BUILD_PROFILE == DRM_BUILD_PROFILE_IOS*/
+
+DRM_API_VOID DRM_VOID * DRM_CALL DRMCRT_memmove(
+    __out_bcount( count )       DRM_VOID  *dst,
+    __in_bcount( count )  const DRM_VOID  *src,
+    __in                        DRM_SIZE_T count );
+
+DRM_API DRM_LONG DRM_CALL DRMCRT_wcsncmp(
+    __in_ecount( count ) const DRM_WCHAR  *first,
+    __in_ecount( count ) const DRM_WCHAR  *last,
+    __in                       DRM_SIZE_T  count );
+
+DRM_API DRM_LONG DRM_CALL DRMCRT_wcsnicmp(
+    __in_ecount( count ) const DRM_WCHAR    *first,
+    __in_ecount( count ) const DRM_WCHAR    *last,
+    __in                       DRM_SIZE_T    count );
+
+DRM_API DRM_LONG DRM_CALL DRMCRT_wcsicmp(
+    __in_z const DRM_WCHAR *first,
+    __in_z const DRM_WCHAR *last );
+
+DRM_API _Post_equal_to_( _String_length_( wsz ) ) DRM_SIZE_T DRM_CALL DRMCRT_wcslen(
+    __in_z const DRM_WCHAR *wsz );
+
+DRM_API _Post_equal_to_( _String_length_( sz ) ) DRM_SIZE_T DRM_CALL DRMCRT_strlen(
+    __in_z const DRM_CHAR *sz );
+
+DRM_API DRM_LONG DRM_CALL DRMCRT_strncmp(
+    _In_reads_or_z_( count ) const DRM_CHAR   *first,
+    _In_reads_or_z_( count ) const DRM_CHAR   *last,
+    __in                           DRM_SIZE_T  count );
+
+DRM_API DRM_LONG DRM_CALL DRMCRT_abs( DRM_LONG number );
+
+/**********************************************************************
+**
+** Set of DRM specific functions that complement C run time.
+*
+***********************************************************************/
+
+DRM_API DRM_RESULT DRM_CALL DRMCRT_AtoDWORD(
+    __in_ecount( f_cchStringInput ) const DRM_CHAR  *f_pszStringInput,
+    __in                                  DRM_DWORD  f_cchStringInput,
+    __in                                  DRM_DWORD  f_base,
+    __out                                 DRM_DWORD *f_pdwValue );
+
+DRM_API DRM_RESULT DRM_CALL DRMCRT_WtoDWORD(
+    __in_ecount( f_cchStringInput ) const DRM_WCHAR *pwszStringInput,
+    __in                                  DRM_DWORD  f_cchStringInput,
+    __in                                  DRM_DWORD  f_base,
+    __out                                 DRM_DWORD *f_pdwValue,
+    __out_opt                             DRM_DWORD *f_pcchValue );
+
+DRM_API DRM_RESULT DRM_CALL DRMCRT_strntol(
+    __in_ecount( cchStringInput ) const DRM_CHAR *pszStringInput,
+    __in                                DRM_DWORD  cchStringInput,
+    __out                               DRM_LONG  *plValue );
+
+DRM_API DRM_RESULT DRM_CALL DRMCRT_wcsntol(
+    __in_ecount( cchStringInput ) const DRM_WCHAR *pwszStringInput,
+    __in                                DRM_DWORD  cchStringInput,
+    __out                               DRM_LONG  *plValue );
+
+DRM_API _Post_maybenull_ _When_( _String_length_( pszStr ) <= cchMaxStr, _Null_terminated_ ) DRM_CHAR* DRM_CALL DRMCRT_strnstr(
+    _In_reads_or_z_( cchMaxStr )       const DRM_CHAR  *pszStr,
+   __in                                      DRM_DWORD  cchMaxStr,
+    _In_reads_or_z_( cchMaxStrSearch ) const DRM_CHAR  *pszStrSearch,
+   __in                                      DRM_DWORD  cchMaxStrSearch );
+
+DRM_API _Post_maybenull_ _When_( _String_length_( pwszStr ) <= cchMaxStr, _Null_terminated_ ) DRM_WCHAR* DRM_CALL DRMCRT_wcsnstr(
+    _In_reads_or_z_( cchMaxStr )       const DRM_WCHAR *pwszStr,
+   __in                                      DRM_DWORD  cchMaxStr,
+    _In_reads_or_z_( cchMaxStrSearch ) const DRM_WCHAR *pwszStrSearch,
+   __in                                      DRM_DWORD  cchMaxStrSearch );
+
+EXIT_PK_NAMESPACE;
+
+#endif /* __DRMCRT_H__ */
+
diff --git a/prebuilt-v4.4/noarch/include/drmdatastore.h b/prebuilt-v4.4/noarch/include/drmdatastore.h
new file mode 100644
index 0000000..52b6d92
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmdatastore.h
@@ -0,0 +1,206 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+
+#ifndef __DRM_DATASTORE_H__
+#define __DRM_DATASTORE_H__
+
+#include <drmdatastoretypes.h>
+#include <drmdatastorecommon.h>
+#include <drmembeddedstore_impl.h>
+#include <drmhds_impl.h>
+#include <drmpragmas.h>
+
+ENTER_PK_NAMESPACE;
+
+/*
+** ----------------------------------------------------------------------------
+** API function definitions to be used for data store interface calls
+** ----------------------------------------------------------------------------
+*/
+
+/*
+** ----------------------------------------------------------------------------
+** Methods applied to whole data store
+** ----------------------------------------------------------------------------
+*/
+
+DRM_API DRM_RESULT DRM_CALL DRM_DST_Init(
+    __in                          DRM_DST_IMPLEMENTATION_TYPE       f_eImplementationType,
+    __in_bcount( f_cbDSTContext ) DRM_DST_CONTEXT                  *f_pDSTContext,
+    __in                          DRM_DWORD                         f_cbDSTContext,
+    __out                         DRM_DST                          *f_pDST );
+
+DRM_API DRM_RESULT DRM_CALL DRM_DST_Uninit( __inout DRM_DST *f_pDST );
+
+DRM_API DRM_RESULT DRM_CALL DRM_DST_CreateStore(
+    __in_opt                           DRM_VOID          *f_pbOEMContext,
+    __in_bcount( f_cbStoreData ) const DRM_BYTE          *f_pbStoreData,
+    __in                               DRM_DWORD          f_cbStoreData,
+    __in                         const DRM_DWORD          f_dwBlockSize,
+    __in                               DRM_DST_BLKNUMTYPE f_eBlNumType,
+    __in                               DRM_BOOL           f_fTruncateExist,
+    __in                         const DRM_DWORD          f_dwInitSizeInKB,
+    __inout                            DRM_DST            *f_pDST );
+
+DRM_API DRM_RESULT DRM_CALL DRM_DST_OpenStore(
+    __in_opt                     DRM_VOID   *f_pOEMContext,
+    __in_bcount( f_cbStoreData ) DRM_BYTE   *f_pbStoreData,
+    __in                         DRM_DWORD   f_cbStoreData,
+    __in                         DRM_DWORD   f_dwGrowBySizeinKB,
+    __inout                      DRM_DST    *f_pDST );
+
+DRM_API DRM_RESULT DRM_CALL DRM_DST_CloseStore( __inout DRM_DST *f_pDST );
+
+DRM_API DRM_RESULT DRM_CALL DRM_DST_CommitStore( __inout DRM_DST *f_pDST );
+
+DRM_API DRM_RESULT DRM_CALL DRM_DST_CleanupStore(
+    __inout DRM_DST   *f_pDST,
+    __in    DRM_BOOL   f_fWait );
+
+
+/*
+** ----------------------------------------------------------------------------
+** Methods applied to namespaces within the data store.
+** ----------------------------------------------------------------------------
+*/
+
+DRM_API DRM_RESULT DRM_CALL DRM_DST_OpenNamespace(
+    __inout        DRM_DST                   *f_pDST,
+    __in    const  DRM_DST_NAMESPACE         *f_pNamespace,
+    __in           DRM_DST_OPENMODE           f_eOpenMode,
+    __in           DRM_WORD                   f_wMaxNumChildren,
+    __in           DRM_DWORD                  f_dwExpectedSlotSize,
+    __out          DRM_DST_NAMESPACE_CONTEXT *f_pContextNS );
+
+DRM_API DRM_RESULT DRM_CALL DRM_DST_DeleteNamespace(
+    __inout    DRM_DST           *f_pDST,
+    __inout    DRM_DST_NAMESPACE *f_pNS,
+    __in       DRM_BOOL           f_fWait );
+
+DRM_API DRM_RESULT DRM_CALL DRM_DST_CloseNamespace(
+    __inout const DRM_DST                    *f_pDST,
+    __inout       DRM_DST_NAMESPACE_CONTEXT  *f_pContextNS ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_API DRM_RESULT DRM_CALL DRM_DST_CommitNamespace(
+    __inout const DRM_DST                    *f_pDST,
+    __inout       DRM_DST_NAMESPACE_CONTEXT  *f_pContextNS );
+
+
+/*
+** ----------------------------------------------------------------------------
+** Methods to navigate, create, delete, open and close DST dataslots
+** ----------------------------------------------------------------------------
+*/
+
+DRM_API DRM_RESULT DRM_CALL DRM_DST_MakeSlotHint(
+    __inout const DRM_DST               *f_pDST,
+    __in          DRM_DST_SLOT_CONTEXT  *f_pContextSlot,
+    __out         DRM_DST_SLOT_HINT     *f_pSlotHint ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_API DRM_RESULT DRM_CALL DRM_DST_OpenSlot(
+    __inout  const DRM_DST                   *f_pDST,
+    __in           DRM_DST_NAMESPACE_CONTEXT *f_pContextNS,
+    __in           DRM_DWORD                  f_dwMode,
+    __in     const DRM_DST_KEY               *f_pKey1,
+    __in     const DRM_DST_KEY               *f_pKey2,
+    __in_opt       DRM_DST_SLOT_HINT         *f_pSlotHint,
+    __inout        DRM_DWORD                 *f_pcbSlotSize,
+    __out          DRM_DST_SLOT_CONTEXT      *f_pContextSlot ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_API DRM_RESULT DRM_CALL DRM_DST_CloseSlot(
+    __inout const DRM_DST               *f_pDST,
+    __inout       DRM_DST_SLOT_CONTEXT  *f_pContextSlot ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_API DRM_RESULT DRM_CALL DRM_DST_DeleteSlot(
+    __inout  const DRM_DST                   *f_pDST,
+    __in           DRM_DST_NAMESPACE_CONTEXT *f_pContextNS,
+    __in     const DRM_DST_KEY               *f_pKey1,
+    __in     const DRM_DST_KEY               *f_pKey2,
+    __in_opt       DRM_DST_SLOT_HINT         *f_pSlotHint,
+    __in           DRM_BOOL                   f_fWait ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_API DRM_RESULT DRM_CALL DRM_DST_InitSlotEnum(
+    __inout  const DRM_DST                   *f_pDST,
+    __in           DRM_DST_NAMESPACE_CONTEXT *f_pContextNS,
+    __in_opt const DRM_DST_KEY               *f_pKey1,
+    __in           DRM_DST_LOCKMODE           f_eLockMode,
+    __out          DRM_DST_ENUM_CONTEXT      *f_pContextEnum ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_API DRM_RESULT DRM_CALL DRM_DST_SlotEnumNext(
+    __inout   const DRM_DST               *f_pDST,
+    __inout         DRM_DST_ENUM_CONTEXT  *f_pContextEnum,
+    __out           DRM_DST_SLOT_CONTEXT  *f_pContextSlot,
+    __out_opt       DRM_DST_KEY           *f_pKey1,
+    __out_opt       DRM_DST_KEY           *f_pKey2,
+    __out_opt       DRM_DWORD             *f_pcbSize ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_API DRM_RESULT DRM_CALL DRM_DST_SlotEnumReloadCurrent(
+    __inout   const DRM_DST               *f_pDST,
+    __inout         DRM_DST_ENUM_CONTEXT  *f_pContextEnum,
+    __out           DRM_DST_SLOT_CONTEXT  *f_pContextSlot,
+    __out_opt       DRM_DST_KEY           *f_pKey1,
+    __out_opt       DRM_DST_KEY           *f_pKey2,
+    __out_opt       DRM_DWORD             *f_pcbSize ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_API DRM_RESULT DRM_CALL DRM_DST_SlotEnumDeleteCurrent(
+    __inout const DRM_DST               *f_pDST,
+    __inout       DRM_DST_ENUM_CONTEXT  *f_pContextEnum,
+    __inout       DRM_DST_SLOT_CONTEXT  *f_pContextSlot ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_API DRM_RESULT DRM_CALL DRM_DST_BlockScanDelete(
+    __inout                const DRM_DST                    *f_pDST,
+    __inout                      DRM_DST_NAMESPACE_CONTEXT  *f_pContextNS,
+    __in_ecount( f_cKey1 )       DRM_DST_KEY                *f_rgKey1,
+    __in                         DRM_DWORD                   f_cKey1,
+    __in                         DRM_DST_KEY                *f_pKey2,
+    __in                         DRM_BOOL                    f_fWait ) DRM_NO_INLINE_ATTRIBUTE;
+
+
+/*
+** ----------------------------------------------------------------------------
+** Methods to read, write and seek within a dataslot
+** ----------------------------------------------------------------------------
+*/
+
+DRM_API DRM_RESULT DRM_CALL DRM_DST_SlotResize(
+    __inout const DRM_DST               *f_pDST,
+    __inout       DRM_DST_SLOT_CONTEXT  *f_pContextSlot,
+    __in          DRM_DWORD              f_cbSize ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_API DRM_RESULT DRM_CALL DRM_DST_SlotSeek(
+    __inout   const DRM_DST               *f_pDST,
+    __inout         DRM_DST_SLOT_CONTEXT  *f_pContextSlot,
+    __in            DRM_LONG               f_lOffset,
+    __in            DRM_DST_SEEKMODE       f_eSeekMode,
+    __out_opt       DRM_DWORD             *f_pdwSeekPointer ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_API DRM_RESULT DRM_CALL DRM_DST_SlotRead(
+    __inout                  const DRM_DST               *f_pDST,
+    __inout                        DRM_DST_SLOT_CONTEXT  *f_pContextSlot,
+    __in                           DRM_DWORD              f_cbData,
+    __out_bcount( f_cbData )       DRM_BYTE              *f_pbData,
+    __out_opt                      DRM_DWORD             *f_pcbRead ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_API DRM_RESULT DRM_CALL DRM_DST_SlotWrite(
+    __inout                 const DRM_DST               *f_pDST,
+    __inout                       DRM_DST_SLOT_CONTEXT  *f_pContextSlot,
+    __in                          DRM_DWORD              f_cbData,
+    __in_bcount( f_cbData ) const DRM_BYTE              *f_pbData,
+    __out_opt                     DRM_DWORD             *f_pcbWritten ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_API DRM_RESULT DRM_CALL DRM_DST_SlotReadPtr(
+    __inout                     const DRM_DST               *f_pDST,
+    __inout                           DRM_DST_SLOT_CONTEXT  *f_pContextSlot,
+    __deref_out_bcount( *f_pcbData )  DRM_BYTE             **f_ppbData,
+    __out                             DRM_DWORD             *f_pcbData );
+
+EXIT_PK_NAMESPACE;
+
+#endif  /* __DRM_DATASTORE_H__ */
+
diff --git a/prebuilt-v4.4/noarch/include/drmdatastorecommon.h b/prebuilt-v4.4/noarch/include/drmdatastorecommon.h
new file mode 100644
index 0000000..42ae157
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmdatastorecommon.h
@@ -0,0 +1,65 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+
+#ifndef __DRM_DATASTORECOMMON_H__
+#define __DRM_DATASTORECOMMON_H__
+
+#include <drmtypes.h>
+#include <drmpragmas.h>
+
+ENTER_PK_NAMESPACE;
+
+/*
+** DRM_DST_BLKNUMTYPE specifies the block-numbering type for a given store.
+*/
+typedef enum
+{
+    eDRM_DSTBLKNUM_WORD  = 2,  /* Number blocks by WORD */
+    eDRM_DSTBLKNUM_DWORD = 4   /* Number blocks by DWORD */
+} DRM_DST_BLKNUMTYPE;
+
+/*
+** DRM_DST_OPENMODE specifies the open mode for a store or namespace.
+*/
+typedef enum
+{
+    eDRM_DST_CREATE_NEW    = 0x1000,      /* Create only, fail if it already exists. */
+    eDRM_DST_OPEN_EXISTING = 0x2000,      /* Open if exists, fail if not. */
+    eDRM_DST_OPEN_ALWAYS   = 0x4000       /* Open if exists, create if not. */
+} DRM_DST_OPENMODE;
+
+/*
+** DRM_DST_LOCKMODE specifies the locking mode for a store, namespace, or slot.
+*/
+typedef enum
+{
+    eDRM_DST_LOCKSHARED    = 0x0, /* Opened for shared access. */
+    eDRM_DST_LOCKEXCLUSIVE = 0x1, /* Opened for exclusive access. */
+    eDRM_DST_LOCKWAIT      = 0x2, /* Wait for existing lock before access. */
+    eDRM_DST_LOCKMODE_MASK = 0x3  /* Bitmask defining the bits used for the lock mode */
+} DRM_DST_LOCKMODE;
+
+/*
+** DRM_DST_SEEKMODE specifies the seek mode for seeking within a slot.
+*/
+typedef enum
+{
+    eDRM_DST_SEEKCUR = 1, /* Seek from the current position */
+    eDRM_DST_SEEKEND = 2, /* Seek from the end of the slot */
+    eDRM_DST_SEEKSET = 3  /* Seek from the beginning of the slot */
+} DRM_DST_SEEKMODE;
+
+/*
+** Both keys used in the data store are of type DRM_ID.
+*/
+typedef DRM_ID DRM_DST_KEY;
+
+EXIT_PK_NAMESPACE;
+
+#endif  /* __DRM_DATASTORECOMMON_H__ */
diff --git a/prebuilt-v4.4/noarch/include/drmdatastoretypes.h b/prebuilt-v4.4/noarch/include/drmdatastoretypes.h
new file mode 100644
index 0000000..ef81204
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmdatastoretypes.h
@@ -0,0 +1,285 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+
+#ifndef __DRM_DATASTORETYPES_H__
+#define __DRM_DATASTORETYPES_H__
+
+#include <drmembeddedstore_impl.h>
+#include <drmhds_impl.h>
+
+ENTER_PK_NAMESPACE;
+
+/*
+** Enumeration of the currently supported DST implementations
+*/
+typedef enum
+{
+    eDRM_DST_NONE,
+    eDRM_DST_HDS,
+    eDRM_DST_EMBEDDED
+} DRM_DST_IMPLEMENTATION_TYPE;
+
+/*
+** Context sizes which depend on the supported, underlying implementations:
+*/
+#define DRM_DST_CONTEXT_LEN            DRM_MAX( DRM_HDS_CONTEXT_LEN,           DRM_EST_CONTEXT_LEN )
+#define DRM_DST_NAMESPACE_CONTEXT_LEN  DRM_MAX( DRM_HDS_NAMESPACE_CONTEXT_LEN, DRM_EST_NAMESPACE_CONTEXT_LEN )
+#define DRM_DST_NAMESPACE_LEN          DRM_MAX( DRM_HDS_NSNAME_SIZE,           DRM_EST_NAMESPACE_LEN )
+#define DRM_DST_SLOT_CONTEXT_LEN       DRM_MAX( DRM_HDS_SLOT_CONTEXT_LEN,      DRM_EST_SLOT_CONTEXT_LEN )
+#define DRM_DST_ENUM_CONTEXT_LEN       DRM_MAX( DRM_HDS_ENUM_CONTEXT_LEN,      DRM_EST_ENUM_CONTEXT_LEN )
+#define DRM_DST_SLOT_HINT_LEN          DRM_MAX( DRM_HDS_SLOT_HINT_LEN,         DRM_EST_SLOT_HINT_LEN )
+
+/*
+** Context containing information about a data store.
+** This is a maximum size across all implementations.
+*/
+typedef struct __tagDRM_DST_CONTEXT
+{
+    DRM_BYTE rgbOpaqueData[DRM_DST_CONTEXT_LEN]; /* Opaque, implementation-specific data */
+} DRM_DST_CONTEXT;
+
+/*
+** Namespace identification data.
+*/
+typedef struct __tagDRM_DST_NAMESPACE
+{
+    DRM_BYTE rgbOpaqueData[DRM_DST_NAMESPACE_LEN];/* Opaque, implementation-specific data */
+} DRM_DST_NAMESPACE;
+
+/*
+** Context containing information about a namespace within a data store.
+*/
+typedef struct __tagDRM_DST_NAMESPACE_CONTEXT
+{
+    DRM_BYTE rgbOpaqueData[DRM_DST_NAMESPACE_CONTEXT_LEN]; /* Opaque, implementation-specific data */
+} DRM_DST_NAMESPACE_CONTEXT;
+
+/*
+** Context containing information about a data slot within a namespace.
+*/
+typedef struct __tagDRM_DST_SLOT_CONTEXT
+{
+    DRM_BYTE rgbOpaqueData[DRM_DST_SLOT_CONTEXT_LEN]; /* Opaque, implementation-specific data */
+} DRM_DST_SLOT_CONTEXT;
+
+/*
+** Context containing information about a slot enumeration context.
+*/
+typedef struct __tagDRM_DST_ENUM_CONTEXT
+{
+    DRM_BYTE rgbOpaqueData[DRM_DST_ENUM_CONTEXT_LEN]; /* Opaque, implementation-specific data */
+} DRM_DST_ENUM_CONTEXT;
+
+/*
+** Context containing data used to find a slot quickly.
+*/
+typedef struct __tagDRM_DST_SLOT_HINT
+{
+    DRM_BYTE rgbOpaqueData[DRM_DST_SLOT_HINT_LEN]; /* Opaque, implementation-specific data */
+} DRM_DST_SLOT_HINT;
+
+
+/*
+** ----------------------------------------------------------------------------
+** Function typedefs
+** ----------------------------------------------------------------------------
+*/
+
+typedef DRM_API DRM_RESULT ( DRM_CALL *DRM_DST_INIT ) ( __inout DRM_DST_CONTEXT *f_pContextDST );
+
+typedef DRM_API DRM_RESULT ( DRM_CALL *DRM_DST_UNINIT ) ( __inout DRM_DST_CONTEXT *f_pContextDST );
+
+typedef DRM_API DRM_RESULT ( DRM_CALL *DRM_DST_CREATESTORE ) (
+    __in_opt                           DRM_VOID          *f_pbOEMContext,
+    __in_bcount( f_cbStoreData ) const DRM_BYTE          *f_pbStoreData,
+    __in                               DRM_DWORD          f_cbStoreData,
+    __in                         const DRM_DWORD          f_dwBlockSize,
+    __in                               DRM_DST_BLKNUMTYPE f_eBlNumType,
+    __in                               DRM_BOOL           f_fTruncateExist,
+    __in                         const DRM_DWORD          f_dwInitSizeInKB,
+    __inout                            DRM_DST_CONTEXT   *f_pContextDST );
+
+typedef DRM_API DRM_RESULT ( DRM_CALL *DRM_DST_OPENSTORE ) (
+    __in_opt                     DRM_VOID        *f_pOEMContext,
+    __in_bcount( f_cbStoreData ) DRM_BYTE        *f_pbStoreData,
+    __in                         DRM_DWORD        f_cbStoreData,
+    __in                         DRM_DWORD        f_dwGrowBySizeinKB,
+    __inout                      DRM_DST_CONTEXT *f_pContextDST );
+
+typedef DRM_API DRM_RESULT ( DRM_CALL *DRM_DST_CLOSESTORE )( __inout DRM_DST_CONTEXT *f_pContextDST );
+
+typedef DRM_API DRM_RESULT ( DRM_CALL *DRM_DST_COMMITSTORE )( __inout DRM_DST_CONTEXT *f_pContextDST );
+
+typedef DRM_API DRM_RESULT ( DRM_CALL *DRM_DST_CLEANUPSTORE )(
+    __inout DRM_DST_CONTEXT *f_pContextDST,
+    __in    DRM_BOOL         f_fWait );
+
+typedef DRM_API DRM_RESULT ( DRM_CALL *DRM_DST_OPENNAMESPACE )(
+    __inout        DRM_DST_CONTEXT           *f_pContextDST,
+    __in    const  DRM_DST_NAMESPACE         *f_pNamespace,
+    __in           DRM_DST_OPENMODE           f_eOpenMode,
+    __in           DRM_WORD                   f_wMaxNumChildren,
+    __in           DRM_DWORD                  f_dwExpectedSlotSize,
+    __out          DRM_DST_NAMESPACE_CONTEXT *f_pContextNS );
+
+typedef DRM_API DRM_RESULT ( DRM_CALL *DRM_DST_DELETENAMESPACE )(
+    __inout    DRM_DST_CONTEXT   *f_pContextDST,
+    __inout    DRM_DST_NAMESPACE *f_pNS,
+    __in       DRM_BOOL           f_fWait );
+
+typedef DRM_API DRM_RESULT ( DRM_CALL *DRM_DST_CLOSENAMESPACE )(
+    __inout    DRM_DST_NAMESPACE_CONTEXT  *f_pContextNS );
+
+typedef DRM_API DRM_RESULT ( DRM_CALL *DRM_DST_COMMITNAMESPACE )(
+    __inout    DRM_DST_NAMESPACE_CONTEXT  *f_pContextNS );
+
+typedef DRM_API DRM_RESULT ( DRM_CALL *DRM_DST_MAKESLOTHINT )(
+    __in    DRM_DST_SLOT_CONTEXT  *f_pContextSlot,
+    __out   DRM_DST_SLOT_HINT     *f_pSlotHint );
+
+typedef DRM_API DRM_RESULT ( DRM_CALL *DRM_DST_OPENSLOT )(
+    __in       DRM_DST_NAMESPACE_CONTEXT *f_pContextNS,
+    __in       DRM_DWORD                  f_dwMode,
+    __in const DRM_DST_KEY               *f_pKey1,
+    __in const DRM_DST_KEY               *f_pKey2,
+    __in_opt   DRM_DST_SLOT_HINT         *f_pSlotHint,
+    __inout    DRM_DWORD                 *f_pcbSlotSize,
+    __out      DRM_DST_SLOT_CONTEXT      *f_pContextSlot );
+
+typedef DRM_API DRM_RESULT ( DRM_CALL *DRM_DST_CLOSESLOT )(
+    __inout  DRM_DST_SLOT_CONTEXT  *f_pContextSlot );
+
+typedef DRM_API DRM_RESULT ( DRM_CALL *DRM_DST_DELETESLOT )(
+    __in       DRM_DST_NAMESPACE_CONTEXT *f_pContextNS,
+    __in const DRM_DST_KEY               *f_pKey1,
+    __in const DRM_DST_KEY               *f_pKey2,
+    __in_opt   DRM_DST_SLOT_HINT         *f_pSlotHint,
+    __in       DRM_BOOL                   f_fWait );
+
+typedef DRM_API DRM_RESULT ( DRM_CALL *DRM_DST_INITSLOTENUM )(
+    __in           DRM_DST_NAMESPACE_CONTEXT *f_pContextNS,
+    __in_opt const DRM_DST_KEY               *f_pKey1,
+    __in           DRM_DST_LOCKMODE           f_eLockMode,
+    __out          DRM_DST_ENUM_CONTEXT      *f_pContextEnum );
+
+typedef DRM_API DRM_RESULT ( DRM_CALL *DRM_DST_SLOTENUMNEXT )(
+    __inout    DRM_DST_ENUM_CONTEXT  *f_pContextEnum,
+    __out      DRM_DST_SLOT_CONTEXT  *f_pContextSlot,
+    __out_opt  DRM_DST_KEY           *f_pKey1,
+    __out_opt  DRM_DST_KEY           *f_pKey2,
+    __out_opt  DRM_DWORD             *f_pcbSize );
+
+typedef DRM_API DRM_RESULT ( DRM_CALL *DRM_DST_SLOTENUMRELOADCURRENT )(
+    __inout    DRM_DST_ENUM_CONTEXT  *f_pContextEnum,
+    __out      DRM_DST_SLOT_CONTEXT  *f_pContextSlot,
+    __out_opt  DRM_DST_KEY           *f_pKey1,
+    __out_opt  DRM_DST_KEY           *f_pKey2,
+    __out_opt  DRM_DWORD             *f_pcbSize );
+
+typedef DRM_API DRM_RESULT ( DRM_CALL *DRM_DST_SLOTENUMDELETECURRENT )(
+    __inout   DRM_DST_ENUM_CONTEXT  *f_pContextEnum,
+    __inout   DRM_DST_SLOT_CONTEXT  *f_pContextSlot );
+
+typedef DRM_API DRM_RESULT ( DRM_CALL *DRM_DST_BLOCKSCANDELETE )(
+    __inout                DRM_DST_NAMESPACE_CONTEXT  *f_pContextNS,
+    __in_ecount( f_cKey1 ) DRM_DST_KEY                *f_rgKey1,
+    __in                   DRM_DWORD                   f_cKey1,
+    __in                   DRM_DST_KEY                *f_pKey2,
+    __in                   DRM_BOOL                    f_fWait );
+
+typedef DRM_API DRM_RESULT ( DRM_CALL *DRM_DST_SLOTRESIZE )(
+    __inout  DRM_DST_SLOT_CONTEXT  *f_pContextSlot,
+    __in     DRM_DWORD              f_cbSize );
+
+typedef DRM_API DRM_RESULT ( DRM_CALL *DRM_DST_SLOTSEEK )(
+    __inout   DRM_DST_SLOT_CONTEXT  *f_pContextSlot,
+    __in      DRM_LONG               f_lOffset,
+    __in      DRM_DST_SEEKMODE       f_eSeekMode,
+    __out_opt DRM_DWORD             *f_pdwSeekPointer );
+
+typedef DRM_API DRM_RESULT ( DRM_CALL *DRM_DST_SLOTREAD )(
+    __inout                  DRM_DST_SLOT_CONTEXT  *f_pContextSlot,
+    __in                     DRM_DWORD              f_cbData,
+    __out_bcount( f_cbData ) DRM_BYTE              *f_pbData,
+    __out_opt                DRM_DWORD             *f_pcbRead );
+
+typedef DRM_API DRM_RESULT ( DRM_CALL *DRM_DST_SLOTWRITE )(
+    __inout                       DRM_DST_SLOT_CONTEXT  *f_pContextSlot,
+    __in                          DRM_DWORD              f_cbData,
+    __in_bcount( f_cbData ) const DRM_BYTE              *f_pbData,
+    __out_opt                     DRM_DWORD             *f_pcbWritten );
+
+typedef DRM_API DRM_RESULT ( DRM_CALL *DRM_DST_SLOTREADPTR )(
+    __inout                           DRM_DST_SLOT_CONTEXT  *f_pContextSlot,
+    __deref_out_bcount( *f_pcbData )  DRM_BYTE             **f_ppbData,
+    __out                             DRM_DWORD             *f_pcbData );
+
+
+/*
+** Meta-structure which contains the function pointers used to access
+** data store implementations
+*/
+typedef struct __tag_DRM_DST_INTERFACE
+{
+    /*
+    ** Methods applied to whole data store
+    */
+    DRM_DST_INIT         pfnInit;        /* Pointer to a data store init function */
+    DRM_DST_UNINIT       pfnUninit;      /* Pointer to a data store uninit function */
+    DRM_DST_CREATESTORE  pfnCreateStore; /* Pointer to a data store creation function */
+    DRM_DST_OPENSTORE    pfnOpenStore;   /* Pointer to a data store opem function */
+    DRM_DST_CLOSESTORE   pfnCloseStore;  /* Pointer to a data store close function */
+    DRM_DST_COMMITSTORE  pfnCommitStore; /* Pointer to a data store commit function */
+    DRM_DST_CLEANUPSTORE pfnCleanupStore;/* Pointer to a data store cleanup function */
+
+    /*
+    ** Methods used to open and manage namespaces within a data store.
+    */
+    DRM_DST_OPENNAMESPACE   pfnOpenNamespace;   /* Pointer to a namespace open function */
+    DRM_DST_DELETENAMESPACE pfnDeleteNamespace; /* Pointer to a namespace deletion function */
+    DRM_DST_CLOSENAMESPACE  pfnCloseNamespace;  /* Pointer to a namespace close function */
+    DRM_DST_COMMITNAMESPACE pfnCommitNamespace; /* Pointer to a namespace commit function */
+
+    /*
+    ** Methods to navigate, create, delete, open and close DST dataslots
+    */
+    DRM_DST_MAKESLOTHINT          pfnMakeSlotHint;          /* Pointer to a slot hint function */
+    DRM_DST_OPENSLOT              pfnOpenSlot;              /* Pointer to an open slot function */
+    DRM_DST_CLOSESLOT             pfnCloseSlot;             /* Pointer to a close slot function */
+    DRM_DST_DELETESLOT            pfnDeleteSlot;            /* Pointer to a slot deletion function */
+    DRM_DST_INITSLOTENUM          pfnInitSlotEnum;          /* Pointer to an init slot enum function */
+    DRM_DST_SLOTENUMNEXT          pfnSlotEnumNext;          /* Pointer to a slot enum next function */
+    DRM_DST_SLOTENUMRELOADCURRENT pfnSlotEnumReloadCurrent; /* Pointer to a slot enum reload current function */
+    DRM_DST_SLOTENUMDELETECURRENT pfnSlotEnumDeleteCurrent; /* Pointer to a slot enum delete current function */
+    DRM_DST_BLOCKSCANDELETE       pfnBlockScanDelete;       /* Pointer to a block scan delete function */
+
+    /*
+    ** Functions to read, write and seek within a dataslot
+    */
+    DRM_DST_SLOTRESIZE  pfnSlotResize;  /* Pointer to a slot resize function. */
+    DRM_DST_SLOTSEEK    pfnSlotSeek;    /* Pointer to a slot seek function. */
+    DRM_DST_SLOTREAD    pfnSlotRead;    /* Pointer to a slot read function. */
+    DRM_DST_SLOTWRITE   pfnSlotWrite;   /* Pointer to a slot write function. */
+    DRM_DST_SLOTREADPTR pfnSlotReadPtr; /* Pointer to a slod read pointer function. Valid only for memory-backed stores. */
+} DRM_DST_INTERFACE;
+
+/*
+** Context containing information about a data store.
+*/
+typedef struct __tagDRM_DST
+{
+    DRM_DST_IMPLEMENTATION_TYPE       eImplementationType;  /* Specifies the implementation type */
+    DRM_DST_INTERFACE                 oDataStoreInterface;  /* Contains the function table for an implementation */
+    DRM_DST_CONTEXT                  *poContextDST;         /* Contains the internal data store context */
+} DRM_DST;
+
+EXIT_PK_NAMESPACE;
+
+#endif  /* __DRM_DATASTORETYPES_H__ */
+
diff --git a/prebuilt-v4.4/noarch/include/drmdebug.h b/prebuilt-v4.4/noarch/include/drmdebug.h
new file mode 100644
index 0000000..ca5a0b7
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmdebug.h
@@ -0,0 +1,109 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+
+#ifndef __DRMDEBUG_H__
+#define __DRMDEBUG_H__
+
+#include <oemdebug.h>
+
+ENTER_PK_NAMESPACE;
+
+/*************************************************************************
+*
+*   debug printf macro
+*   Sample calling seq:
+*
+*   DRM_DBG_TRACE(("My name is %s", "DRM"));
+*
+*   Note the double parenthesis.
+*************************************************************************/
+#if DRM_DBG
+
+    #undef DRM_DBG_TRACE
+
+    #ifdef __cplusplus_cli
+        /* If building under a C++/CLI flag ignore all DRM_DBG_TRACE statements */
+        #define DRM_DBG_TRACE(x)
+    #else
+        #define DRM_DBG_TRACE(x) DRM_DO { Oem_Debug_Trace("DRM_DBG_TRACE at %s(%d): ", __FILE__, __LINE__); Oem_Debug_Trace x; Oem_Debug_Trace("\r\n"); } DRM_WHILE_FALSE
+    #endif
+
+    #undef TRACE_IF_FAILED
+    #define TRACE_IF_FAILED(x) DRM_DO { if ( DRM_FAILED( dr ) ){ DRM_DBG_TRACE(x); } } DRM_WHILE_FALSE
+
+    /*
+    ** Set to 1 to enable maximum TEE heap usage logging for PC builds using the simulated TEE HWDRM.
+    ** The log file (defined by DRM_TEE_HEAP_USAGE_LOG_FILE in oemdiagheaplogger.cpp) will be located
+    ** next to the HDS file.
+    */
+    #define DRM_PC_USE_TEE_HEAP_USAGE_DIAGNOSITCS 0
+
+    #if DRM_BUILD_PROFILE == DRM_BUILD_PROFILE_PC && DRM_PC_USE_TEE_HEAP_USAGE_DIAGNOSITCS == 1
+        #define DRM_PC_TEST_CAPTURE_TEE_HEAP_USAGE 1
+        #define DRM_PC_TEST_CAPTURE_TEE_HEAP_MOCK ENTER_PK_NAMESPACE; DRM_DWORD g_dwCurrentTeeFunctionID = 0; EXIT_PK_NAMESPACE;
+    #else
+        #define DRM_PC_TEST_CAPTURE_TEE_HEAP_USAGE 0
+        #define DRM_PC_TEST_CAPTURE_TEE_HEAP_MOCK
+    #endif
+
+#else  /* DRM_DBG */
+
+    #define DRM_PC_TEST_CAPTURE_TEE_HEAP_USAGE 0
+    #define DRM_PC_TEST_CAPTURE_TEE_HEAP_MOCK
+
+    #ifndef DRM_DBG_TRACE
+    #define DRM_DBG_TRACE(x)
+    #endif
+
+    #ifndef TRACE_IF_FAILED
+    #define TRACE_IF_FAILED(x)
+    #endif
+
+#endif  /* DRM_DBG */
+
+
+/*
+** Compile-time asserts cause PREfast warnings regarding the comparison of two constants.
+** So, enable this macro only when the PREfast tool is not analyzing the code.
+*/
+#ifndef _PREFAST_
+    #define DRMSIZEASSERT(x,y)  \
+        {switch(0){case ((x)==(y)?0:(y)):case (y):;}} \
+        {switch(0){case ((y)==(x)?0:(x)):case (x):;}}
+#else
+    #define DRMSIZEASSERT(x,y)
+#endif
+
+
+#define ENSURE_MEMBERS_ADJACENT(struc,member1,member2)  ((DRM_OFFSET_OF(struc,member1)+(DRM_DWORD)(sizeof(((struc *)0)->member1))) == DRM_OFFSET_OF(struc,member2))
+
+#if DRM_DBG
+    #undef DRMASSERT
+    /* Call the global assert handler function. */
+
+    #ifdef __cplusplus_cli
+        /* Don't include strings in C++/CLI code */
+        #define DRMASSERT(x) Oem_Debug_Assert((x), NULL, NULL, __LINE__)
+    #else
+        #define DRMASSERT(x) Oem_Debug_Assert((x), #x, __FILE__, __LINE__)
+    #endif
+
+#else /* DRM_DBG */
+    #ifndef DRMASSERT
+        #define DRMASSERT( x )
+    #endif
+    #ifndef DRMCASSERT
+        #define DRMCASSERT( x )
+    #endif
+#endif /* DRM_DBG */
+
+EXIT_PK_NAMESPACE;
+
+#endif  /* __DRMDEBUG_H__ */
+
diff --git a/prebuilt-v4.4/noarch/include/drmdebug.inc b/prebuilt-v4.4/noarch/include/drmdebug.inc
new file mode 100644
index 0000000..506247d
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmdebug.inc
@@ -0,0 +1,57 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#define DRM_BUILDING_DRMDEBUG_C
+#include <drmdebug.h>
+#include <drmlicense.h>
+#include <drmlastinclude.h>
+#include <drmh264.h>
+#include <drmrevocationtypes.h>
+#include <oemteetypes.h>
+
+ENTER_PK_NAMESPACE_CODE;
+
+DRM_VOID DRM_TYPE_ASSERTS(void)
+{
+    /*
+    ** If you get a compile-time assert in this code file,
+    ** refer to comments in oemcompiler.h near
+    ** DRM_BASIC_TYPE_SIZES_DEFINED
+    */
+    DRMSIZEASSERT(sizeof(DRM_BYTE),         1);
+    DRMSIZEASSERT(sizeof(DRM_CHAR),         1);
+    DRMSIZEASSERT(sizeof(DRM_WCHAR),        2);
+    DRMSIZEASSERT(sizeof(DRM_WCHAR_NATIVE), 2);
+    DRMSIZEASSERT(sizeof(DRM_WORD),         2);
+    DRMSIZEASSERT(sizeof(DRM_LONG),         4);
+    DRMSIZEASSERT(sizeof(DRM_DWORD),        4);
+    DRMSIZEASSERT(sizeof(DRM_WCHAR32),      4);
+    DRMSIZEASSERT(sizeof(DRM_BOOL),         4);
+    DRMSIZEASSERT(sizeof(DRM_INT64),        8);
+    DRMSIZEASSERT(sizeof(DRM_UINT64),       8);
+
+    /*
+    ** Device cert and licenses will be staged to share the same buffer
+    */
+    DRMSIZEASSERT(MAX_DEVICE_CERT_SIZE, DRM_MAX_LICENSESIZE);
+
+    #if DRM_SUPPORT_NATIVE_64BIT_TYPES
+    /*
+    ** The following constants were pre-evaluated for performance
+    ** reasons. Their correctness is checked by the following asserts.
+    */
+    DRMCASSERT( DRM_C_SECONDS_FROM_1601_TO_1970             == DRM_UI64Mul( DRM_UI64( 1164447360 ), DRM_UI64( 10 ) ) );
+    DRMCASSERT( DRM_H264_ERROR_WINDOW_IN_TICS               == DRM_UI64Mul( DRM_H264_ERROR_WINDOW_IN_SECONDS, DRM_C_TICS_PER_SECOND ) );
+    DRMCASSERT( MAX_REVOCATION_EXPIRE_TICS                  == DRM_UI64Mul( MAX_REVOCATION_EXPIRE_TIME, DRM_C_TICS_PER_SECOND ) );
+    DRMCASSERT( MAX_ALLOWED_TIME_BEFORE_CLOCK_RESYNC        == DRM_UI64Mul( DRM_UI64( 3456000 ), DRM_UI64( DRM_C_TICS_PER_SECOND ) ) );
+    DRMCASSERT( DRM_SECURETIME_MAX_REQUEST_WAIT_IN_FILETIME == DRM_UI64Mul( DRM_SECURETIME_MAX_RESPONSE_WAIT_IN_MINUTES, ONE_MIN_IN_FILETIME ) );
+    #endif
+}
+
+EXIT_PK_NAMESPACE_CODE;
+
diff --git a/prebuilt-v4.4/noarch/include/drmderivedkey.h b/prebuilt-v4.4/noarch/include/drmderivedkey.h
new file mode 100644
index 0000000..d53da9c
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmderivedkey.h
@@ -0,0 +1,125 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __DRMDERIVEDKEY_H__
+#define __DRMDERIVEDKEY_H__
+
+ENTER_PK_NAMESPACE;
+
+/*
+** Macro that defines the location prefix:
+** Each bit of '1' represents a path leg from the root to the
+** key tree node that is represented by the location. All
+** other bits are 0. In other words, the prefix is a bit mask
+** with all bits before the stop bit be 1 and all bits from the
+** stop bit be 0.
+*/
+#define LP( x )     ( ~( ( x ) ^ ( ( x ) -1 ) ) )
+
+/*
+** Macro that defines the stop bit mask which is a bit mask with
+** all bits except the stop bit be 0.
+*/
+#define SBM( x )    ( ( ( ~LP( x ) ) >> 1 ) + 1 )
+
+/*
+** Macro to check whether a key tree node with location x is the
+** ancestor of another key tree node with location y. x is an ancestor
+** of y means x and y are at the same branch from the root and x is
+** located closer to the root than y does.
+*/
+#define IsAncestor( x, y )  ( SBM( x ) >= SBM( y ) && ( y  & LP( x ) ) == ( x & LP( x ) ) )
+
+/*
+** The maximum depth of the stack that is used to store the intermediate keys
+** during derivation. It should be the maximum depth of any subtree in the
+** whole key tree.
+*/
+#define MAX_KEY_STACK   20
+
+/*
+** Implementation of function which determines whether the given location
+** exists in an aux key entry array.
+** If so, it sets the out parameter to the index and returns DRM_SUCCESS.
+** If not, it returns the DRM_RESULT specified in the macro as __drToReturn.
+**
+** The macro assumes that it is being used in the following way:
+**
+** DRM_RESULT _MyFunc(
+**     __in                                DRM_DWORD                      f_dwLocation,
+**     __in                          const DRM_DWORD                      f_cAuxKeys,
+**     __in_ecount_opt( f_cAuxKeys ) const DRM_XMRFORMAT_AUX_KEY_ENTRY   *f_prgAuxKeys,
+**     __inout                             DRM_DWORD                     *f_pdwAuxKeyIndex )
+** {
+**     FIND_AUX_KEY_ENTRY_IMPL( ... );
+** }
+**
+** The __drToReturn will typically be DRM_S_FALSE or DRM_E_UNABLE_TO_RESOLVE_LOCATION_TREE
+*/
+#define FIND_AUX_KEY_ENTRY_IMPL( __drToReturn )                                                                         \
+    DRM_RESULT dr    = DRM_SUCCESS;                                                                                     \
+                                                                                                                        \
+    DRMASSERT( f_pdwAuxKeyIndex != NULL );                                                                              \
+                                                                                                                        \
+    if( f_cAuxKeys        == 0                                                                                          \
+     || f_prgAuxKeys      == NULL                                                                                       \
+     || *f_pdwAuxKeyIndex >= f_cAuxKeys )                                                                               \
+    {                                                                                                                   \
+        dr = __drToReturn;                                                                                              \
+    }                                                                                                                   \
+    else                                                                                                                \
+    {                                                                                                                   \
+        DRM_BOOL   fDone = FALSE;                                                                                       \
+        DRM_LONG   nLeft;               /* Initialized before usage below */                                            \
+        DRM_LONG   nRight;              /* Initialized before usage below */                                            \
+        DRM_LONG   nMiddle;             /* Initialized before usage below */                                            \
+        DRM_LONG   nStart;              /* Initialized before usage below */                                            \
+        DRM_DWORD  dwLocationToTry;     /* Initialized before usage below */                                            \
+                                                                                                                        \
+        nStart = nLeft = (DRM_LONG)*f_pdwAuxKeyIndex;                                                                   \
+                                                                                                                        \
+        nRight = (DRM_LONG)( f_cAuxKeys - 1 ); /* Can't underflow: We only get here if f_cAuxKeys > 0 */                \
+                                                                                                                        \
+        while( !fDone )                                                                                                 \
+        {                                                                                                               \
+            nMiddle = ( nLeft + nRight ) / 2;                                                                           \
+                                                                                                                        \
+            NETWORKBYTES_TO_DWORD( dwLocationToTry, &f_prgAuxKeys[ nMiddle ].dwLocation, 0 );                           \
+            if( IsAncestor( dwLocationToTry, f_dwLocation ) )                                                           \
+            {                                                                                                           \
+                *f_pdwAuxKeyIndex = (DRM_DWORD)nMiddle;                                                                 \
+                fDone = TRUE;   /* Found the index */                                                                   \
+            }                                                                                                           \
+            else                                                                                                        \
+            {                                                                                                           \
+                if( dwLocationToTry > f_dwLocation )                                                                    \
+                {                                                                                                       \
+                    nRight = nMiddle - 1;   /* Can't underflow: both types are SIGNED and never go much below zero */   \
+                }                                                                                                       \
+                else                                                                                                    \
+                {                                                                                                       \
+                    nLeft = nMiddle + 1;    /* Can't underflow: both types are SIGNED and never go much below zero */   \
+                }                                                                                                       \
+                                                                                                                        \
+                if( nLeft  >= (DRM_LONG)f_cAuxKeys                                                                      \
+                 || nRight <  nStart                                                                                    \
+                 || nLeft  >  nRight )                                                                                  \
+                {                                                                                                       \
+                    dr = __drToReturn;                                                                                  \
+                    fDone = TRUE;   /* Index not found */                                                               \
+                }                                                                                                       \
+            }                                                                                                           \
+        }                                                                                                               \
+    }                                                                                                                   \
+                                                                                                                        \
+    return dr;
+
+EXIT_PK_NAMESPACE;
+
+#endif /* __DRMDERIVEDKEY_H__ */
+
diff --git a/prebuilt-v4.4/noarch/include/drmdomainconstants.h b/prebuilt-v4.4/noarch/include/drmdomainconstants.h
new file mode 100644
index 0000000..958550c
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmdomainconstants.h
@@ -0,0 +1,142 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __DRM_DOMAIN_CONSTANTS_H
+#define __DRM_DOMAIN_CONSTANTS_H
+
+ENTER_PK_NAMESPACE;
+
+/*
+** ---------------------------------------------------------------------
+** XML strings used in the construction of domain join challenge
+** ---------------------------------------------------------------------
+*/
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrDomJoinRootTag;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrDomJoinVersionTag;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrDomJoinChallenge1Tag;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrDomJoinChallenge2Tag;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrDomJoinDomainTag;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrDomJoinDataTag;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrDomJoinServiceIDTag;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrDomJoinAccountIDTag;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrDomJoinRevisionTag;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrDomJoinFriendlyNameTag;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrDomJoinCustomDataTag;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrDomJoinCertificateChainTag;
+
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrDomJoinRootAttribName;
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrDomJoinRootAttribValue;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrDomJoinChallenge2AttribName;
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrDomJoinChallenge2AttribValue;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrDomJoinDomainAttrib1Name;
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrDomJoinDomainAttrib1Value;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrDomJoinDomainAttrib2Name;
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrDomJoinDomainAttrib2Value;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrDomJoinCertificateChainAttribName;
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrDomJoinCertificateChainAttribValue;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrDomainJoinVersion;
+
+
+
+/*
+** -----------------------------------------------------------------------
+** XML strings used in the construction of domain leave challenge
+** -----------------------------------------------------------------------
+*/
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrDomLeaveRootTag;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrDomLeaveVersionTag;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrDomLeaveChallenge1Tag;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrDomLeaveChallenge2Tag;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrDomLeaveDomainTag;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrDomLeaveDataTag;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrDomLeaveAccountIDTag;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrDomLeaveCustomDataTag;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrDomLeaveCertificateChainTag;
+
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrDomLeaveRootAttribName;
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrDomLeaveRootAttribValue;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrDomLeaveChallenge2AttribName;
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrDomLeaveChallenge2AttribValue;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrDomLeaveDomainAttrib1Name;
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrDomLeaveDomainAttrib1Value;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrDomLeaveDomainAttrib2Name;
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrDomLeaveDomainAttrib2Value;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrDomLeaveCertificateChainAttribName;
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrDomLeaveCertificateChainAttribValue;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrDomainLeaveVersion;
+
+
+
+/*
+** ---------------------------------------------------------------
+** XML strings used in the parsing of domain join response
+** ---------------------------------------------------------------
+*/
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrDomJoinResponsePath;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrDomJoinDataPath;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrDomJoinDataPath;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrDomJoinVersionPath;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrDomJoinServiceIDPath;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrDomJoinAccountIDPath;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrDomJoinRevisionPath;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrDomJoinCertificateChainPath;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrDomJoinDomainKeysPath;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrDomJoinSigningCertPath;
+
+/*
+** -----------------------------------------------------------------
+** XML strings used in the parsing of domain leave response
+** -----------------------------------------------------------------
+*/
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrDomLeaveAccountIDPath;
+
+
+EXIT_PK_NAMESPACE;
+
+#endif /* __DRM_DOMAIN_CONSTANTS_H */
+
diff --git a/prebuilt-v4.4/noarch/include/drmdomainimp.h b/prebuilt-v4.4/noarch/include/drmdomainimp.h
new file mode 100644
index 0000000..2360beb
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmdomainimp.h
@@ -0,0 +1,169 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __DRM_DOMAIN_IMP_H
+#define __DRM_DOMAIN_IMP_H
+
+#include <drmlicevaltypes.h>
+#include <drmxmlbuildera.h>
+#include <drmdomainstoretypes.h>
+#include <drmdomainkeyxmrparser.h>
+#include <drmmodulesupport.h>
+
+ENTER_PK_NAMESPACE;
+
+/*
+** The following constants define the types of custom data that is sent to
+** both the domain join and domain leave challenge.
+** Any custom data should belong to one and only one of the following types.
+**
+** NULL custom data.
+*/
+#define DRM_REGISTER_NULL_DATA            0
+
+/*
+** XML segment that contains only the data.
+*/
+#define DRM_REGISTER_CUSTOM_DATA          1
+
+/*
+** XML segment that contains both the DID and the data.
+*/
+#define DRM_REGISTER_INDIRECT_QUERY_DATA  2
+
+typedef DRM_DOMAINSTORE_ENUM_CONTEXT DRM_DOMAIN_CERT_ENUM_CONTEXT;
+
+/*
+** List of license response processing flags
+*/
+typedef enum _DRM_PROCESS_DJ_RESPONSE_FLAG
+{
+    DRM_PROCESS_DJ_RESPONSE_NO_FLAGS                  = 0x00000000L,      /* Opt-in signature verification (default). */
+    DRM_PROCESS_DJ_RESPONSE_SIGNATURE_NOT_REQUIRED    = 0x00000001L,      /* Signature is not required, i.e. Opt-out signature verification. */
+} DRM_PROCESS_DJ_RESPONSE_FLAG;
+
+/*
+** ---------------------------------------
+** Domain implementation API functions
+** ---------------------------------------
+*/
+DRM_API DRM_RESULT DRM_CALL DRM_DOM_GenerateJoinChallenge(
+    __inout                                    DRM_SECURECORE_CONTEXT   *f_pSecureCoreCtx,
+    __in                                       DRM_DOMAINSTORE_CONTEXT  *f_poDomainStoreContext,
+    __in                                       DRM_DWORD                 f_dwFlags,
+    __in_opt                                   DRM_DOMAIN_ID            *f_poDomainID,
+    __in_ecount_opt( f_cchFriendlyName ) const DRM_CHAR                 *f_pchFriendlyName,
+    __in                                       DRM_DWORD                 f_cchFriendlyName,
+    __in_bcount_opt( f_cbDeviceCert )    const DRM_BYTE                 *f_pbDeviceCert,
+    __in                                       DRM_DWORD                 f_cbDeviceCert,
+    __in_ecount_opt( f_cchData)          const DRM_CHAR                 *f_pchData,
+    __in                                       DRM_DWORD                 f_cchData,
+    __out_bcount_opt( *f_pcbChallenge )        DRM_BYTE                 *f_pbChallenge,
+    __inout                                    DRM_DWORD                *f_pcbChallenge,
+    __in_ecount( 1 )                     const PUBKEY_P256              *f_poECC256SignPubKey );
+
+DRM_API DRM_RESULT DRM_CALL DRM_DOM_ProcessJoinResponse(
+    __inout                        DRM_SECURECORE_CONTEXT  *f_pSecureCoreCtx,
+    __in                           DRM_DOMAINSTORE_CONTEXT *f_poDomainStoreContext,
+    __inout_bcount( f_cbResponse ) DRM_BYTE                *f_pbResponse,
+    __in                           DRM_DWORD                f_cbResponse,
+    __out                          DRM_RESULT              *f_pResult,
+    __out_opt                      DRM_DOMAIN_ID           *f_poDomainID );
+
+DRM_API DRM_RESULT DRM_CALL DRM_DOM_GenerateLeaveChallenge(
+    __inout                                   DRM_SECURECORE_CONTEXT    *f_pSecureCoreCtx,
+    __in                                      DRM_DOMAINSTORE_CONTEXT   *f_poDomainStoreContext,
+    __in                                      DRM_DWORD                  f_dwFlags,
+    __in_opt                                  DRM_DOMAIN_ID             *f_poDomainID,
+    __in_bcount_opt( f_cbDeviceCert )   const DRM_BYTE                  *f_pbDeviceCert,
+    __in                                      DRM_DWORD                  f_cbDeviceCert,
+    __in_ecount_opt( f_cchData)         const DRM_CHAR                  *f_pchData,
+    __in                                      DRM_DWORD                  f_cchData,
+    __out_bcount_opt( *f_pcbChallenge )       DRM_BYTE                  *f_pbChallenge,
+    __inout                                   DRM_DWORD                 *f_pcbChallenge,
+    __in_ecount( 1 )                    const PUBKEY_P256               *f_poECC256SignPubKey );
+
+DRM_API DRM_RESULT DRM_CALL DRM_DOM_ProcessLeaveResponse(
+    __in_bcount( f_cbResponse ) const DRM_BYTE                  *f_pbResponse,
+    __in                              DRM_DWORD                  f_cbResponse,
+    __out_ecount(1)                   DRM_RESULT                *f_pResult );
+
+DRM_API DRM_RESULT DRM_CALL DRM_DOM_FindCert(
+    __in                                       DRM_DOMAINSTORE_CONTEXT *f_poDomainStoreContext,
+    __in                                 const DRM_DOMAIN_ID           *f_poDomainID,
+    __out_bcount_opt( *f_pcbDomainCert )       DRM_BYTE                *f_pbDomainCert,
+    __inout                                    DRM_DWORD               *f_pcbDomainCert );
+
+DRM_API DRM_RESULT DRM_CALL DRM_DOM_InitCertEnum(
+    __in  DRM_DOMAINSTORE_CONTEXT      *f_poDomainStoreContext,
+    __out DRM_DOMAIN_CERT_ENUM_CONTEXT *f_poDomainCertEnumContext );
+
+DRM_API DRM_RESULT DRM_CALL DRM_DOM_EnumNextCert(
+    __in  DRM_DOMAIN_CERT_ENUM_CONTEXT  *f_poDomainCertEnumContext,
+    __out DRM_DWORD                     *f_pcchDomainCert,
+    __out DRM_DOMAINCERT_INFO           *f_poDomainCertInfo );
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_DOM_IsLicenseValidForELS(
+    __in          DRM_DOMAINSTORE_CONTEXT     *f_pDomainStore,
+    __inout const DRM_XMRFORMAT               *f_pXMRLicense,
+    __inout       DRM_BOOL                    *f_pfValidForELS ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_DOM_ParseDomainResponseKeys(
+    __in                                        DRM_DWORD                          f_cbDomainKeysData,
+    __in_bcount( f_cbDomainKeysData )     const DRM_BYTE                          *f_pbDomainKeysData,
+    __in                                        DRM_DWORD                          f_cbDomainCert,
+    __in_bcount( f_cbDomainCert )         const DRM_BYTE                          *f_pbDomainCert,
+    __in                                        DRM_DWORD                          f_cbMachineCertificate,
+    __in_bcount( f_cbMachineCertificate ) const DRM_BYTE                          *f_pbMachineCertificate,
+    __out                                       DRM_DOMKEYXMR_HEADER              *f_pHeader,
+    __out                                       DRM_DOMKEYXMR_SESSIONKEY          *f_pSessionKey,
+    __out                                       DRM_DOMKEYXMR_PRIVKEYCONTAINER    *f_pPrivKeyContainer,
+    __out                                       DRM_DWORD                         *f_pibDomainKeysDataPrivkeys,
+    __out                                       DRM_DWORD                         *f_pcDomainKeys ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_DOM_LA_CalcDomainCertsCharCount(
+    __in        DRM_DOMAINSTORE_CONTEXT *f_poDomainStoreContext,
+    __in  const DRM_GUID                *f_poServiceID,
+    __out       DRM_DWORD               *f_pcchDomainCerts ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_DOM_LA_BuildDomainCertsXML(
+    __in          DRM_DOMAINSTORE_CONTEXT *f_poDomainStoreContext,
+    __in    const DRM_GUID                *f_poServiceID,
+    __inout       _XMBContextA            *f_poXMLContext ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_DOM_ARCLK_ClockRollbackDetected(
+    __in    DRM_DOMAINSTORE_CONTEXT *f_poDomainStoreContext,
+    __inout DRM_SECURECORE_CONTEXT  *f_pSecureCoreCtx,
+    __in    DRM_UINT64               f_ui64GlobalSavedTime ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_DOM_ARCLK_LEVL_DisableOnRollback(
+    __inout       DRM_LICEVAL_CONTEXT *f_pContextLicEval,
+    __in    const DRM_XMRFORMAT       *f_pXMR,
+    __in          DRM_UINT64           f_u64MachineDateTime,
+    __out         DRM_BOOL            *f_pfDisabled ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_DOM_ARCLK_CreateDomainStorePassword(
+    __in                          const DRM_GUID                *f_poAccountID,
+    __inout                             DRM_SECURECORE_CONTEXT  *f_pSecureCoreCtx,
+    __out_bcount( OEM_SHA1_DIGEST_LEN ) DRM_BYTE                 f_rgbPasswordSST[ OEM_SHA1_DIGEST_LEN ] ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_DOM_ARCLK_GetDomainSavedDateTime(
+    __in_bcount( OEM_SHA1_DIGEST_LEN ) const DRM_BYTE                 f_rgbPasswordSST[ OEM_SHA1_DIGEST_LEN ],
+    __inout_opt                              DRM_VOID                *f_pOEMContext,
+    __in                                     DRM_DOMAINSTORE_CONTEXT *f_poDomainStoreContext,
+    __in                               const DRM_GUID                *f_poAccountID,
+    __out_opt                                DRM_UINT64              *f_puiDomainSavedDateTime ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_API DRM_RESULT DRM_CALL DRM_DOM_InitDomainInfoForXMRBind(
+    __in    DRM_DOMAINSTORE_CONTEXT *f_pDomainStoreContext,
+    __inout DRM_XMR_BINDING_INFO    *f_pXmrInfo );
+
+EXIT_PK_NAMESPACE;
+
+#endif /* __DRM_DOMAIN_IMP_H */
+
diff --git a/prebuilt-v4.4/noarch/include/drmdomainkeyxmrparser.h b/prebuilt-v4.4/noarch/include/drmdomainkeyxmrparser.h
new file mode 100644
index 0000000..afc6fc8
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmdomainkeyxmrparser.h
@@ -0,0 +1,43 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __DRMDOMAINKEYXMRPARSER_H__
+#define __DRMDOMAINKEYXMRPARSER_H__
+
+#include <drmdomainkeyxmrparsertypes.h>
+
+ENTER_PK_NAMESPACE;
+
+DRM_API DRM_RESULT DRM_CALL DRM_DOMKEYXMR_GetHeader(
+    __in_bcount( f_cbData ) const DRM_BYTE              *f_pbData,
+    __in                          DRM_DWORD              f_cbData,
+    __inout_ecount( 1 )           DRM_DWORD             *f_pcbDataOffset,
+    __inout_ecount( 1 )           DRM_DOMKEYXMR_HEADER  *f_poHeader );
+
+DRM_API DRM_RESULT DRM_CALL DRM_DOMKEYXMR_GetSessionKey(
+    __in_bcount( f_cbData ) DRM_BYTE                 *f_pbData,
+    __in                    DRM_DWORD                 f_cbData,
+    __inout_ecount( 1 )     DRM_DWORD                *f_pcbDataOffset,
+    __inout_ecount( 1 )     DRM_DOMKEYXMR_SESSIONKEY *f_poKeyObj );
+
+DRM_API DRM_RESULT DRM_CALL DRM_DOMKEYXMR_GetPrivKeyContainer(
+    __in_bcount( f_cbData ) const DRM_BYTE                        *f_pbData,
+    __in                          DRM_DWORD                        f_cbData,
+    __inout_ecount( 1 )           DRM_DWORD                       *f_pcbDataOffset,
+    __inout_ecount( 1 )           DRM_DOMKEYXMR_PRIVKEYCONTAINER  *f_poKeyContainer );
+
+DRM_API DRM_RESULT DRM_CALL DRM_DOMKEYXMR_GetPrivkey(
+    __in_bcount( f_cbData ) DRM_BYTE                *f_pbData,
+    __in                    DRM_DWORD                f_cbData,
+    __inout_ecount( 1 )     DRM_DWORD               *f_pcbDataOffset,
+    __inout_ecount( 1 )     DRM_DOMKEYXMR_PRIVKEY   *f_poKeyObj );
+
+EXIT_PK_NAMESPACE;
+
+#endif /* __DRMDOMAINKEYXMRPARSER_H__ */
+
diff --git a/prebuilt-v4.4/noarch/include/drmdomainkeyxmrparsertypes.h b/prebuilt-v4.4/noarch/include/drmdomainkeyxmrparsertypes.h
new file mode 100644
index 0000000..c309243
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmdomainkeyxmrparsertypes.h
@@ -0,0 +1,85 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+
+#ifndef __DRMDOMAINKEYXMRPARSERTYPES_H__
+#define __DRMDOMAINKEYXMRPARSERTYPES_H__
+
+#include <drmtypes.h>
+
+ENTER_PK_NAMESPACE;
+
+#define DRM_DOMKEYXMR_HEADER_CONSTANT 0x444b4559 /* DKEY */
+#define DRM_DOMKEYXMR_HEADER_VERSION  1
+
+#define DRM_DOMKEYXMR_SESSIONKEY_ENCTYPE_ECCP256 1
+
+#define DRM_DOMKEYXMR_OBJTYPE_PRIVKEYCONTAINER  0x500
+#define DRM_DOMKEYXMR_OBJTYPE_ACCOUNTID         0x501
+#define DRM_DOMKEYXMR_OBJTYPE_NONCE             0x502
+#define DRM_DOMKEYXMR_OBJTYPE_SESSIOINKEY       0x503
+#define DRM_DOMKEYXMR_OBJTYPE_PRIVKEY           0x504
+
+#define DRM_DOMKEYXMR_PRIVKEYOBJ_MIN_LENGTH 20
+
+#define DRM_DOMKEYXMR_PRIVKEY_TYPE_ECCP256         2
+#define DRM_DOMKEYXMR_PRIVKEY_ENCTYPE_MIXED_AESECB 3
+
+/* Matches value in drmdomainconstants.h */
+#define DRM_DOMAIN_JOIN_PROTOCOL_VERSION 2
+
+/*
+** XMR strucutre for DomainKeys data
+*/
+typedef struct _tagDRM_DOMKEYXMR_HEADER
+{
+    DRM_DWORD  dwConstant;
+    DRM_DWORD  dwVersion;
+    DRM_DWORD  dwLength;
+    DRM_DWORD  dwSignedLength;
+} DRM_DOMKEYXMR_HEADER;
+
+typedef DRM_OBFUS_FIXED_ALIGN struct _tagDRM_DOMKEYXMR_SESSIONKEY
+{
+    DRM_WORD   wFlags;
+    DRM_WORD   wType;
+    DRM_DWORD  dwLength;
+    DRM_WORD   wKeyType;
+    DRM_WORD   wEncryptionType;
+    DRM_DWORD  dwKeyLength;
+DRM_OBFUS_PTR_TOP
+    DRM_BYTE  *pbData;
+DRM_OBFUS_PTR_BTM
+} DRM_DOMKEYXMR_SESSIONKEY;
+
+typedef struct _tagDRM_DOMKEYXMR_PRIVKEYCONTAINER
+{
+    DRM_WORD  wFlags;
+    DRM_WORD  wType;
+    DRM_DWORD dwLength;
+} DRM_DOMKEYXMR_PRIVKEYCONTAINER;
+
+typedef DRM_OBFUS_FIXED_ALIGN struct _tagDRM_DOMKEYXMR_PRIVKEY
+{
+    DRM_WORD  wFlags;
+    DRM_WORD  wType;
+    DRM_DWORD dwLength;
+    DRM_DWORD dwRevision;
+    DRM_WORD  wKeyType;
+    DRM_WORD  wEncryptionType;
+    DRM_DWORD dwKeyLength;
+DRM_OBFUS_FILL_BYTES(4)
+DRM_OBFUS_PTR_TOP
+    DRM_BYTE *pbData;
+DRM_OBFUS_PTR_BTM
+} DRM_DOMKEYXMR_PRIVKEY;
+
+EXIT_PK_NAMESPACE;
+
+#endif /* __DRMDOMAINKEYXMRPARSERTYPES_H__ */
+
diff --git a/prebuilt-v4.4/noarch/include/drmdomainstore.h b/prebuilt-v4.4/noarch/include/drmdomainstore.h
new file mode 100644
index 0000000..7066b01
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmdomainstore.h
@@ -0,0 +1,108 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __DRM_DOMAIN_STORE_H
+#define __DRM_DOMAIN_STORE_H
+
+#include <drmdomainstoretypes.h>
+#include <drmsecurecoretypes.h>
+
+ENTER_PK_NAMESPACE;
+
+DRM_API DRM_RESULT DRM_CALL DRM_DOMST_OpenStore(
+    __in  DRM_DST                 *f_pDatastore,
+    __out DRM_DOMAINSTORE_CONTEXT *f_poDomainStoreContext );
+
+
+DRM_API DRM_RESULT DRM_CALL DRM_DOMST_CloseStore(
+    __in DRM_DOMAINSTORE_CONTEXT *f_poDomainStoreContext );
+
+
+DRM_API DRM_RESULT DRM_CALL DRM_DOMST_AddCert(
+    __in_bcount( OEM_SHA1_DIGEST_LEN ) const DRM_BYTE                 f_rgbPasswordSST[ OEM_SHA1_DIGEST_LEN ],
+    __inout_opt                              DRM_VOID                *f_pOEMContext,
+    __in                                     DRM_DOMAINSTORE_CONTEXT *f_poDomainStoreContext,
+    __in                               const DRM_GUID                *f_poAccountID,
+    __in                               const DRM_GUID                *f_poServiceID,
+    __in_bcount( f_cbCert )            const DRM_BYTE                *f_pbCert,
+    __in                                     DRM_DWORD                f_cbCert );
+
+
+DRM_API DRM_RESULT DRM_CALL DRM_DOMST_GetCert(
+    __in                                 DRM_DOMAINSTORE_CONTEXT *f_poDomainStoreContext,
+    __in                           const DRM_GUID                *f_poAccountID,
+    __in                                 DRM_GUID                *f_poServiceID,
+    __out_bcount_opt( *f_pcbCert )       DRM_BYTE                *f_pbCert,
+    __inout                              DRM_DWORD                *f_pcbCert );
+
+
+DRM_API DRM_RESULT DRM_CALL DRM_DOMST_DeleteCert(
+    __in       DRM_DOMAINSTORE_CONTEXT *f_poDomainStoreContext,
+    __in const DRM_GUID                *f_poAccountID );
+
+
+DRM_API DRM_RESULT DRM_CALL DRM_DOMST_InitEnumCert(
+    __in  DRM_DOMAINSTORE_CONTEXT      *f_poDomainStoreContext,
+    __out DRM_DOMAINSTORE_ENUM_CONTEXT *f_poDomainStoreEnumContext );
+
+
+DRM_API DRM_RESULT DRM_CALL DRM_DOMST_EnumNextCert(
+    __in      DRM_DOMAINSTORE_ENUM_CONTEXT *f_poDomainStoreEnumContext,
+    __out     DRM_GUID                     *f_poAccountID,
+    __out_opt DRM_GUID                     *f_poServiceID,
+    __out_opt DRM_DST_SLOT_HINT            *f_poSlotHint,
+    __out_opt DRM_DWORD                    *f_pcbData );
+
+
+DRM_API DRM_RESULT DRM_CALL DRM_DOMST_AddKey(
+    __in                         DRM_DOMAINSTORE_CONTEXT *f_poDomainStoreContext,
+    __in                   const DRM_GUID                *f_poAccountID,
+    __in                         DRM_DWORD                f_dwRevision,
+    __in_bcount( f_cbKey ) const DRM_BYTE                *f_pbKey,
+    __in                         DRM_DWORD                f_cbKey );
+
+
+DRM_API DRM_RESULT DRM_CALL DRM_DOMST_GetKey(
+    __in                                DRM_DOMAINSTORE_CONTEXT *f_poDomainStoreContext,
+    __in                          const DRM_GUID                *f_poAccountID,
+    __in                                DRM_DWORD                f_dwRevision,
+    __out_bcount_opt( *f_pcbKey )       DRM_BYTE                *f_pbKey,
+    __inout                             DRM_DWORD               *f_pcbKey );
+
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_DOMST_DeleteKey(
+    __in       DRM_DOMAINSTORE_CONTEXT *f_poDomainStoreContext,
+    __in const DRM_GUID                *f_poAccountID,
+    __in       DRM_DWORD                f_dwRevision );
+
+
+DRM_API DRM_RESULT DRM_CALL DRM_DOMST_DeleteKeys(
+    __in       DRM_DOMAINSTORE_CONTEXT *f_poDomainStoreContext,
+    __in const DRM_GUID                *f_poAccountID );
+
+
+DRM_API DRM_RESULT DRM_CALL DRM_DOMST_InitEnumKey(
+    __in  DRM_DOMAINSTORE_CONTEXT      *f_poDomainStoreContext,
+    __out DRM_DOMAINSTORE_ENUM_CONTEXT *f_poDomainStoreEnumContext );
+
+
+DRM_API DRM_RESULT DRM_CALL DRM_DOMST_EnumNextKey(
+    __in                DRM_DOMAINSTORE_ENUM_CONTEXT *f_poDomainStoreEnumContext,
+    __out               DRM_GUID                     *f_poAccountID,
+    __out_ecount_opt(1) DRM_DWORD                    *f_pdwRevision,
+    __out_opt           DRM_DST_SLOT_HINT            *f_poSlotHint,
+    __out_opt           DRM_DWORD                    *f_pcbData );
+
+DRM_API DRM_RESULT DRM_CALL DRM_DOMST_CreateDomainStorePassword(
+    __in                                const DRM_GUID                *f_poAccountID,
+    __inout                                   DRM_SECURECORE_CONTEXT  *f_pSecureCoreCtx,
+    __out_bcount( OEM_SHA1_DIGEST_LEN )       DRM_BYTE                 f_rgbPasswordSST[ OEM_SHA1_DIGEST_LEN ] );
+
+EXIT_PK_NAMESPACE;
+
+#endif /* __DRM_DOMAIN_STORE_H */
diff --git a/prebuilt-v4.4/noarch/include/drmdomainstoretypes.h b/prebuilt-v4.4/noarch/include/drmdomainstoretypes.h
new file mode 100644
index 0000000..2b273a4
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmdomainstoretypes.h
@@ -0,0 +1,70 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __DRM_DOMAIN_STORE_TYPES_H
+#define __DRM_DOMAIN_STORE_TYPES_H
+
+#include <drmsecurestoretypes.h>
+
+ENTER_PK_NAMESPACE;
+
+/* The context of the domain store. */
+typedef struct _tagDomainStoreContextPrivate
+{
+    /* Pointer to the underlying DST. */
+    DRM_DST *m_poDST;
+
+    /* The underlying DST namespace context. */
+    DRM_DST_NAMESPACE_CONTEXT m_oDSTNameSpaceContext;
+
+    /* The underlying DST slot context. */
+    DRM_DST_SLOT_CONTEXT m_oDSTSlotContext;
+
+    /* The SST context. */
+    DRM_SECSTORE_CONTEXT m_oSSTContext;
+
+    /* Flag indicating whether the context has been initialized. */
+    DRM_BOOL m_fInited;
+
+#if DRM_OBFUS_NEED_PADDING
+    DRM_VOID *m_rgpvWM7Padding[107];
+#endif /* DRM_OBFUS_NEED_PADDING */
+} DRM_DOMAINSTORE_CONTEXT_PRIVATE;
+
+/* The context of the domain store in the form of a BLOB. */
+typedef struct __tagDRM_DOMAINSTORE_CONTEXT
+{
+    DRM_BYTE rgbOpaqueData [ sizeof( DRM_DOMAINSTORE_CONTEXT_PRIVATE ) ];
+} DRM_DOMAINSTORE_CONTEXT;
+
+/* The enumeration context of the domain store. */
+typedef struct __tagDRM_DOMAINSTORE_ENUM_CONTEXT
+{
+    /* The underlying domain store. */
+    DRM_DST *m_poDomainStore;
+
+    /* The underlying DST enumeration context. */
+    DRM_DST_ENUM_CONTEXT m_oDSTEnumContext;
+
+    /* The underlying DST slot context. */
+    DRM_DST_SLOT_CONTEXT m_oDSTSlotContext;
+
+    /*
+    ** Flag indicating whether domain certificates
+    ** or domain private keys to be enumerated.
+    */
+    DRM_BOOL m_fCert;
+
+    /* Flag indicating whether the context has been initialized. */
+    DRM_BOOL m_fInited;
+} DRM_DOMAINSTORE_ENUM_CONTEXT;
+
+EXIT_PK_NAMESPACE;
+
+#endif /* __DRM_DOMAIN_STORE_TYPES_H */
+
diff --git a/prebuilt-v4.4/noarch/include/drmembeddedstore_impl.h b/prebuilt-v4.4/noarch/include/drmembeddedstore_impl.h
new file mode 100644
index 0000000..798340d
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmembeddedstore_impl.h
@@ -0,0 +1,94 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+
+#ifndef __DRM_EMBEDDEDSTORE_IMPL_H__
+#define __DRM_EMBEDDEDSTORE_IMPL_H__
+
+#include <drmdatastorecommon.h>
+
+ENTER_PK_NAMESPACE;
+
+#define MAX_EMBEDDED_STORE_LEN 10240
+
+#define BYTES_PER_DWORD      sizeof( DRM_DWORD )
+
+/*
+** Context containing information about the embedded store.
+*/
+typedef struct __tagDRM_EST_CONTEXT
+{
+    DRM_BOOL   m_fInited;         /* Denotes whether the context has been initialized. */
+    DRM_BOOL   m_fStoreOpen;      /* Denotes whether the context contains data for an open store */
+    DRM_BOOL   m_fIsDirty;        /* Denotes whether the store has changed since opening */
+    DRM_BYTE  *m_pbEmbeddedStore; /* Pointer to the actual store data. */
+    DRM_DWORD  m_cbEmbeddedStore; /* Length of m_pbEmbeddedStore that is used in bytes. */
+    DRM_DWORD  m_ibUnused;        /* Starting index of the unused buffer within the buffer pointed by m_pbEmbeddedStore. */
+    DRM_DWORD  m_cbUnused;        /* Size of the unused buffer within the buffer pointed by m_pbEmbeddedStore. */
+    DRM_DWORD  m_dwDeleteCount;   /* Starts at 0, incremented each time a slot is deleted. Used to detect when enumerations should be restarted due to slot deletions */
+} DRM_EST_CONTEXT;
+
+/*
+** Context containing information about a namespace within an embedded store.
+*/
+typedef struct __tagDRM_EST_NAMESPACE_CONTEXT
+{
+    DRM_BOOL          m_fNamespaceOpen; /* Denotes whether the namespace is open */
+    DRM_EST_CONTEXT  *m_poESTContext;   /* A pointer to context for the EST used to open the namespace. */
+} DRM_EST_NAMESPACE_CONTEXT;
+
+/*
+** Context containing information used to find a particular slot.
+*/
+typedef struct __tagDRM_EST_SLOT_HINT
+{
+    DRM_DWORD         m_ibOffset;  /* The byte offset of the slot within the current namespace */
+    DRM_DWORD         m_cbSlotLen; /* The length of the slot in bytes, without padding */
+} DRM_EST_SLOT_HINT;
+
+/*
+** Context containing information about a slot.
+*/
+typedef struct __tagDRM_EST_SLOT_CONTEXT
+{
+    DRM_BOOL                   m_fSlotOpen;     /* Denotes whether a slot has been opened with this context. */
+    DRM_EST_NAMESPACE_CONTEXT *m_poESTNSContext;/* A pointer to context for the namespace  */
+    DRM_DST_KEY                m_oKey1;         /* Specifies the first key of the slot */
+    DRM_DST_KEY                m_oKey2;         /* Specifies the second key of the slot */
+    DRM_DST_LOCKMODE           m_eLockmode;     /* Specifies the lock mode used to open the slot. */
+    DRM_DWORD                  m_ibSeekPtr;     /* Maintains the current seek pointer within the slot */
+    DRM_EST_SLOT_HINT          m_oSlotLocation; /* Contains the location of the opened slot  */
+} DRM_EST_SLOT_CONTEXT;
+
+/*
+** Context containing information used to enumerate slots.
+*/
+typedef struct __tagDRM_EST_ENUM_CONTEXT
+{
+    DRM_BOOL                    m_fInited;        /* Denotes whether the enum context has been initialized. */
+    DRM_EST_NAMESPACE_CONTEXT  *m_poESTNSContext; /* A pointer to context for the namespace. */
+    DRM_DWORD                   m_cSlots;         /* Contains the number of slots in the current enumeration */
+    DRM_DWORD                   m_iSlot;          /* Contains the index of the current slot in the enumeration. */
+    DRM_EST_SLOT_HINT           m_oSlotHint;      /* Slot hint contains the location of current slot */
+    DRM_DST_KEY                 m_oKey1;          /* Primary key that is used to find matching slots. */
+    DRM_DST_LOCKMODE            m_eLockMode;      /* Locking mode of the enumeration. */
+    DRM_BOOL                    m_fSlotValid;     /* Flag indicating whether there is a current slot being enumerated. */
+    DRM_DWORD                   m_dwCurrentDeleteCount; /* Delete count when enumeration was started, used to detect if deletions have occurred since starting/restarting */
+} DRM_EST_ENUM_CONTEXT;
+
+#define DRM_EST_CONTEXT_LEN             sizeof( DRM_EST_CONTEXT )
+#define DRM_EST_NAMESPACE_CONTEXT_LEN   sizeof( DRM_EST_NAMESPACE_CONTEXT )
+#define DRM_EST_SLOT_CONTEXT_LEN        sizeof( DRM_EST_SLOT_CONTEXT )
+#define DRM_EST_SLOT_HINT_LEN           sizeof( DRM_EST_SLOT_HINT )
+#define DRM_EST_NAMESPACE_LEN           16
+#define DRM_EST_ENUM_CONTEXT_LEN        sizeof( DRM_EST_ENUM_CONTEXT )
+
+EXIT_PK_NAMESPACE;
+
+#endif  /* __DRM_EMBEDDEDSTORE_IMPL_H__ */
+
diff --git a/prebuilt-v4.4/noarch/include/drmembedding.h b/prebuilt-v4.4/noarch/include/drmembedding.h
new file mode 100644
index 0000000..0ebef99
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmembedding.h
@@ -0,0 +1,34 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __DRMEMBEDDING_H__
+#define __DRMEMBEDDING_H__
+
+#include <drmtypes.h>
+#include <drmlicstore.h>
+#include <drmliceval.h>
+
+ENTER_PK_NAMESPACE;
+
+DRM_API DRM_RESULT DRM_CALL DRM_EMB_UpdateEmbeddedStore(
+    __in                                          DRM_LICSTORE_CONTEXT               *f_pEmbeddedStore,
+    __in                                          DRM_LICSTORE_CONTEXT               *f_pLicStore,
+    __in                                          DRM_DOMAINSTORE_CONTEXT            *f_poDomainStoreContext,
+    __in                                    const DRM_LICEVAL_CONTEXT                *f_pLicEvalBackup,
+    __inout                                       DRM_LICEVAL_CONTEXT                *f_rgbLicEvalBuffer,
+    __in_bcount_opt( *f_pcbScratchBuffer )        DRM_BYTE                           *f_pbScratchBuffer,
+    __inout                                       DRM_DWORD                          *f_pcbScratchBuffer,
+    __in                                    const DRM_KID                            *f_poKID,
+    __out                                         DRM_LICSTOREENUM_MULTIPLE_CONTEXT  *f_pLicEnumMultiple,
+    __out                                         DRM_XMRFORMAT                      *f_poLicense,
+    __inout                                       DRM_BOOL                           *f_pfModifiedEST );
+
+
+EXIT_PK_NAMESPACE;
+
+#endif /* __DRMEMBEDDING_H__ */
diff --git a/prebuilt-v4.4/noarch/include/drmenvelope.h b/prebuilt-v4.4/noarch/include/drmenvelope.h
new file mode 100644
index 0000000..4191094
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmenvelope.h
@@ -0,0 +1,54 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __DRMENVELOPE_H__
+#define __DRMENVELOPE_H__
+
+#include <oemcommon.h>
+#include <oemciphertypes.h>
+
+ENTER_PK_NAMESPACE;
+
+#define DRM_ENVELOPE_FILE_SIGNATURE 0x07455250
+
+#define DRM_ENVELOPE_CURRENT_FORMAT_VERSION 1
+
+/* This is the size in bytes of a v1 envelope header */
+#define DRM_ENVELOPE_MINIMUM_HEADER_SIZE 50
+
+#define DRM_ENVELOPE_CIPHER_DATA_SIZE 24
+
+typedef struct __tagDRM_ENVELOPE_HEADER
+{
+    DRM_DWORD dwFileSignature;
+    DRM_DWORD cbHeaderSize;
+    DRM_DWORD dwFileDataOffset;
+    DRM_WORD  wFormatVersion;
+    DRM_WORD  wCompatibleVersion;
+    DRM_DWORD dwCipherType;
+    DRM_BYTE  rgbCipherData[DRM_ENVELOPE_CIPHER_DATA_SIZE];
+    DRM_WORD  cbOriginalFilename;
+    DRM_DWORD cbDrmHeaderLen;
+} DRM_ENVELOPE_HEADER;
+
+typedef struct __tagDRM_ENVELOPED_FILE_CONTEXT
+{
+    OEM_FILEHDL pEnvFileHandle;
+
+    DRM_DWORD dwFileDataStart;
+
+    DRM_CIPHER_CONTEXT oDecrypt;
+    DRM_UINT64 qwInitialCipherCounter;
+    DRM_ENVELOPE_HEADER oEnvHeader;
+
+} DRM_ENVELOPED_FILE_CONTEXT;
+
+EXIT_PK_NAMESPACE;
+
+#endif /* __DRMENVELOPE_H__ */
+
diff --git a/prebuilt-v4.4/noarch/include/drmerr.h b/prebuilt-v4.4/noarch/include/drmerr.h
new file mode 100644
index 0000000..cb3555b
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmerr.h
@@ -0,0 +1,234 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __DRMERR_H__
+#define __DRMERR_H__
+
+#include <drmtypes.h>
+#include <drmdebug.h>
+#include <drmresults.h>
+#include <drmpragmas.h> /* Required to ChkDR( constant ); */
+
+#if DRM_DBG
+
+ENTER_PK_NAMESPACE;
+    extern void (*g_pfDebugAnalyzeDR)(unsigned long, const char*, unsigned long, const char*);
+EXIT_PK_NAMESPACE;
+
+#define SetDbgAnalyzeFunction(pfn) g_pfDebugAnalyzeDR = pfn;
+#define GetDbgAnalyzeFunction() g_pfDebugAnalyzeDR
+
+#define ExamineDRValue(_drval_,_file_,_line_,_expr_) DRM_DO {                                           \
+    if( g_pfDebugAnalyzeDR != NULL )                                                                    \
+    {                                                                                                   \
+        (*g_pfDebugAnalyzeDR)((unsigned long)(_drval_), (_file_), (unsigned long)(_line_), (_expr_));   \
+    }                                                                                                   \
+} DRM_WHILE_FALSE
+
+#else  /* DRM_DBG */
+
+#define SetDbgAnalyzeFunction(pfn)
+#define ExamineDRValue(_drval_,_file_,_line_,_expr_)
+#define GetDbgAnalyzeFunction()
+
+#endif  /* DRM_DBG */
+
+#define ChkDRAllowENOTIMPL(expr) DRM_DO {               \
+    dr = (expr);                                        \
+    if( dr == DRM_E_NOTIMPL )                           \
+    {                                                   \
+        dr = DRM_SUCCESS;                               \
+    }                                                   \
+    else                                                \
+    {                                                   \
+        ExamineDRValue(dr, __FILE__, __LINE__, #expr);  \
+        if( DRM_FAILED( dr ) )                          \
+        {                                               \
+            goto ErrorExit;                             \
+        }                                               \
+    }                                                   \
+} DRM_WHILE_FALSE
+
+#define ChkDRNoGOTO(expr) DRM_DO {                      \
+    dr = (expr);                                        \
+    ExamineDRValue(dr, __FILE__, __LINE__, #expr);      \
+} DRM_WHILE_FALSE
+
+#define ChkDR(expr) DRM_DO {                            \
+    ChkDRNoGOTO( expr );                                \
+    if( DRM_FAILED( dr ) )                              \
+    {                                                   \
+        goto ErrorExit;                                 \
+    }                                                   \
+} DRM_WHILE_FALSE
+
+#define ChkMem(expr) DRM_DO {                                                                   \
+    if( DRM_UNLIKELY( NULL == (expr) ) )                                                        \
+    {                                                                                           \
+        DRM_DBG_TRACE( ("Allocation failure at %s : %d.\n%s\n", __FILE__, __LINE__, #expr) );   \
+        dr = DRM_E_OUTOFMEMORY;                                                                 \
+        ExamineDRValue(dr, __FILE__, __LINE__, #expr);                                          \
+        goto ErrorExit;                                                                         \
+    }                                                                                           \
+} DRM_WHILE_FALSE
+
+#define ChkArgError() DRM_DO {                                                                  \
+    DRM_DBG_TRACE( ("Invalid argument at %s : %d.\nFALSE\n", __FILE__, __LINE__) );             \
+    dr = DRM_E_INVALIDARG;                                                                      \
+    ExamineDRValue(dr, __FILE__, __LINE__, "FALSE");                                            \
+    goto ErrorExit;                                                                             \
+} DRM_WHILE_FALSE
+
+#define ChkArg(expr) DRM_DO {                                                                   \
+    if( DRM_UNLIKELY( !(expr) ) )                                                               \
+    {                                                                                           \
+        DRM_DBG_TRACE( ("Invalid argument at %s : %d.\n%s\n", __FILE__, __LINE__, #expr) );     \
+        dr = DRM_E_INVALIDARG;                                                                  \
+        ExamineDRValue(dr, __FILE__, __LINE__, #expr);                                          \
+        goto ErrorExit;                                                                         \
+    }                                                                                           \
+} DRM_WHILE_FALSE
+
+#define ChkPtr(expr) DRM_DO {                                                                   \
+    if( DRM_UNLIKELY( NULL == (expr) ) )                                                        \
+    {                                                                                           \
+        DRM_DBG_TRACE( ("NULL pointer at %s : %d.\n%s\n", __FILE__, __LINE__, #expr) );         \
+        dr = DRM_E_POINTER;                                                                     \
+        ExamineDRValue(dr, __FILE__, __LINE__, #expr);                                          \
+        goto ErrorExit;                                                                         \
+    }                                                                                           \
+} DRM_WHILE_FALSE
+
+#define ChkDRMString(s) DRM_DO {                                                                \
+    if( !(s) || (s)->pwszString == NULL || (s)->cchString == 0 )                                \
+    {                                                                                           \
+        DRM_DBG_TRACE( ("Invalid argument at %s : %d.\n%s\n", __FILE__, __LINE__, #s) );        \
+        dr = DRM_E_INVALIDARG;                                                                  \
+        ExamineDRValue(dr, __FILE__, __LINE__, #s);                                             \
+        goto ErrorExit;                                                                         \
+    }                                                                                           \
+} DRM_WHILE_FALSE
+
+#define ChkDRMANSIString(s) DRM_DO {                                                            \
+    if( !(s) || (s)->pszString == NULL || (s)->cchString == 0 )                                 \
+    {                                                                                           \
+        DRM_DBG_TRACE( ("Invalid argument at %s : %d.\n%s\n", __FILE__, __LINE__, #s) );        \
+        dr = DRM_E_INVALIDARG;                                                                  \
+        ExamineDRValue(dr, __FILE__, __LINE__, #s);                                             \
+        goto ErrorExit;                                                                         \
+    }                                                                                           \
+} DRM_WHILE_FALSE
+
+#define ChkBOOL(fExpr,err) DRM_DO {                             \
+    if( !(fExpr) )                                              \
+    {                                                           \
+        dr = (err);                                             \
+        ExamineDRValue(dr, __FILE__, __LINE__, #fExpr);         \
+        goto ErrorExit;                                         \
+    }                                                           \
+} DRM_WHILE_FALSE
+
+#define ChkVOID(fExpr) DRM_DO { \
+    fExpr;                      \
+} DRM_WHILE_FALSE
+
+#define ChkDRContinue(expr) DRM_DO {                \
+    dr=(expr);                                      \
+    ExamineDRValue(dr, __FILE__, __LINE__, #expr);  \
+    if( DRM_FAILED( dr ) )                          \
+    {                                               \
+        continue;                                   \
+    }                                               \
+} DRM_WHILE_FALSE
+
+#define ChkDRMap( expr, drOriginal, drMapped ) DRM_DO { \
+    dr = ( expr );                                      \
+    ExamineDRValue(dr, __FILE__, __LINE__, #expr);      \
+    if( dr == ( drOriginal ) )                          \
+    {                                                   \
+        dr = ( drMapped );                              \
+        ExamineDRValue(dr, __FILE__, __LINE__, #expr);  \
+    }                                                   \
+    if( DRM_FAILED( dr ) )                              \
+    {                                                   \
+        goto ErrorExit;                                 \
+    }                                                   \
+} DRM_WHILE_FALSE
+
+#define MapDR( drOriginal, drMapped ) DRM_DO {                                                                      \
+    DRM_DBG_TRACE( ("Error code 0x%X mapped at %s : %d. to 0x%X \n", drOriginal,  __FILE__, __LINE__, drMapped) );  \
+    drOriginal = ( drMapped );                                                                                      \
+} DRM_WHILE_FALSE
+
+#define AssertLogicError() DRM_DO {     \
+    DRMASSERT( FALSE );                 \
+    dr = DRM_E_LOGICERR;                \
+    goto ErrorExit;                     \
+} DRM_WHILE_FALSE
+
+#define AssertChkBOOL(expr) DRM_DO {    \
+    DRM_BOOL _f = (expr);               \
+    DRMASSERT( _f );                    \
+    if( DRM_UNLIKELY( !_f ) )           \
+    {                                   \
+        dr = DRM_E_LOGICERR;            \
+        goto ErrorExit;                 \
+    }                                   \
+    __analysis_assume( expr );          \
+} DRM_WHILE_FALSE
+
+#define AssertChkArg(expr) AssertChkBOOL(expr)
+
+#define AssertChkFeature(expr) DRM_DO {                                                                         \
+    DRM_BOOL _f = (expr);                                                                                       \
+    if( DRM_UNLIKELY( !_f ) )                                                                                   \
+    {                                                                                                           \
+        DRM_DBG_TRACE( ( "Incompatible Feature Set Detected at %s : %d.\n%s\n", __FILE__, __LINE__, #expr ) );  \
+        DRMASSERT( FALSE );                                                                                     \
+        ChkDR( DRM_E_BCERT_INVALID_FEATURE );                                                                   \
+    }                                                                                                           \
+} DRM_WHILE_FALSE
+
+#define DRM_REQUIRE_BUFFER_TOO_SMALL( expr ) DRM_DO {   \
+    DRM_RESULT __drTemp = (expr);                       \
+    if( __drTemp != DRM_E_BUFFERTOOSMALL )              \
+    {                                                   \
+        ChkDR( __drTemp );                              \
+        DRMASSERT( FALSE );                             \
+        ChkDR( DRM_E_LOGICERR );                        \
+    }                                                   \
+} DRM_WHILE_FALSE
+
+#define InitOutputPtr( lhs, rhs ) DRM_DO {  \
+    if( (lhs) != NULL )                     \
+    {                                       \
+        *(lhs) = (rhs);                     \
+    }                                       \
+} DRM_WHILE_FALSE
+
+#define ChkAndInitOutputPtr( lhs, rhs ) DRM_DO {    \
+    ChkArg( (lhs) != NULL );                        \
+    *(lhs) = (rhs);                                 \
+} DRM_WHILE_FALSE
+
+/*
+** To ensure that safe math isn't required for numerous calculations across various protocols,
+** limit the size of things like custom data to no more than ~16 MB.
+*/
+#define ChkMaxProtocolData( __cb )  ChkArg( ( __cb ) <= ( (DRM_DWORD)0xFFFFFFUL ) )
+
+#define ChkMaxVersionLen( __pSecureCoreCtx ) DRM_DO {                                               \
+    ChkArg( ( __pSecureCoreCtx ) != NULL );                                                         \
+    if( ( __pSecureCoreCtx )->pClientInfo != NULL )                                                 \
+    {                                                                                               \
+        ChkMaxProtocolData( ( __pSecureCoreCtx )->pClientInfo->m_dastrClientVersion.cchString );    \
+    }                                                                                               \
+} DRM_WHILE_FALSE
+
+#endif /* __DRMERR_H__ */
+
diff --git a/prebuilt-v4.4/noarch/include/drmerror.h b/prebuilt-v4.4/noarch/include/drmerror.h
new file mode 100644
index 0000000..6bf9250
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmerror.h
@@ -0,0 +1,45 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+/*
+**  drmerrsay.h
+**
+**  Defines functions used for looking up DRM error values.
+**
+*/
+
+#ifndef __DRMERRSAY_H__
+#define __DRMERRSAY_H__
+
+#include <drmtypes.h>
+
+ENTER_PK_NAMESPACE;
+
+typedef struct _tagDRM_ERROR_MESSAGE
+{
+    DRM_RESULT      m_drValue;
+    DRM_ANSI_CONST_STRING m_dastrName;
+    DRM_ANSI_CONST_STRING m_dastrDescription;
+} DRM_ERROR_MESSAGE;
+
+extern const DRM_ERROR_MESSAGE g_rgoPKErrorMap[];
+
+DRM_API DRM_BOOL   DRM_CALL DRM_ERR_IsErrorCodeKnown( DRM_RESULT f_drErrorCode );
+
+DRM_API const DRM_CHAR*  DRM_CALL DRM_ERR_GetErrorNameFromCode(
+    __in                      DRM_RESULT      f_drErrorCode,
+    __deref_opt_out_opt const DRM_CHAR      **f_ppszDescription );
+
+DRM_API DRM_RESULT DRM_CALL DRM_ERR_GetErrorCodeFromStringA(
+    __in_ecount( f_cchString )  const DRM_CHAR   *f_pszString,
+    __in                              DRM_DWORD   f_cchString,
+    __out                             DRM_RESULT *f_pdrErrorCode );
+
+EXIT_PK_NAMESPACE;
+
+#endif /* __DRMERRSAY_H__ */
diff --git a/prebuilt-v4.4/noarch/include/drmest.h b/prebuilt-v4.4/noarch/include/drmest.h
new file mode 100644
index 0000000..3e60970
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmest.h
@@ -0,0 +1,195 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+
+#ifndef __DRM_EMBEDDEDSTORE_H__
+#define __DRM_EMBEDDEDSTORE_H__
+
+#include <drmdatastore.h>
+#include <drmmodulesupport.h>
+
+ENTER_PK_NAMESPACE;
+
+PREFAST_PUSH_DISABLE_EXPLAINED(__WARNING_NONCONST_PARAM, "Parameters must match generic drmdatastore.h interface")
+
+/*
+** Embedded store header constants
+*/
+#define DRM_EST_HEADER_CONST     "EST" /* Constant which must begin the EST buffer. */
+#define DRM_EST_HEADER_CONST_LEN 4     /* Length of DRM_EST_HEADER_CONST in bytes. */
+#define DRM_EST_MINIMUM_VERSION  1     /* Lowest valid version for the embedded store format */
+#define DRM_EST_CURRENT_VERSION  1     /* Current version of the embedded store format. */
+
+/*
+** EmbeddedLicenseStore Header Format
+**
+** Field                         | Type
+** --------------------------------------
+** Header Constants              | DWORD
+** Store Version                 | WORD
+** Minimum Compatibility Version | WORD
+** Store Size                    | DWORD
+** License Slots                 | Data
+*/
+#define DRM_EST_HEADER_LEN       ( DRM_EST_HEADER_CONST_LEN + 2 * sizeof( DRM_WORD ) + sizeof( DRM_DWORD ) )
+
+/*
+** Embedded store slot constants
+*/
+
+/*
+** EmbeddedLicenseSlot Header Format
+**
+** Field                         | Type
+** --------------------------------------
+** Slot Size                     | DWORD
+** Key ID                        | DRM_GUID
+** License ID                    | DRM_GUID
+** License Priority              | DWORD                Priority is the first DWORD of the license data
+** License Data                  | Byte array
+*/
+#define DRM_EST_SLOTHEADER_LEN  ( sizeof( DRM_DWORD ) + 2 * sizeof( DRM_DST_KEY ) )
+
+DRM_API DRM_RESULT DRM_CALL DRM_EST_InitializeDST( __out DRM_DST *f_pDst );
+
+DRM_API DRM_RESULT DRM_CALL DRM_EST_Init( __inout DRM_DST_CONTEXT *f_pContextDST );
+
+DRM_API DRM_RESULT DRM_CALL DRM_EST_Uninit( __inout DRM_DST_CONTEXT *f_pContextDST );
+
+DRM_API DRM_RESULT DRM_CALL DRM_EST_CreateStore(
+    __in_opt                           DRM_VOID          *f_pbOEMContext,
+    __in_bcount( f_cbStoreData ) const DRM_BYTE          *f_pbStoreData,
+    __in                               DRM_DWORD          f_cbStoreData,
+    __in                         const DRM_DWORD          f_dwBlockSize,
+    __in                               DRM_DST_BLKNUMTYPE f_eBlNumType,
+    __in                               DRM_BOOL           f_fTruncateExist,
+    __in                         const DRM_DWORD          f_dwInitSizeInKB,
+    __inout                            DRM_DST_CONTEXT   *f_pContextDST );
+
+PREFAST_PUSH_DISABLE_EXPLAINED( __WARNING_NONCONST_PARAM_25004, "Function much match DRM_DST interface" )
+DRM_API DRM_RESULT DRM_CALL DRM_EST_OpenStore(
+    __in_opt                     DRM_VOID        *f_pOEMContext,
+    __in_bcount( f_cbStoreData ) DRM_BYTE        *f_pbStoreData,
+    __in                         DRM_DWORD        f_cbStoreData,
+    __in                         DRM_DWORD        f_dwGrowBySizeinKB,
+    __inout                      DRM_DST_CONTEXT *f_pContextDST );
+PREFAST_POP     /* __WARNING_NONCONST_PARAM_25004 */
+
+DRM_API DRM_RESULT DRM_CALL DRM_EST_CloseStore( __inout DRM_DST_CONTEXT *f_pContextDST );
+
+DRM_API DRM_RESULT DRM_CALL DRM_EST_CommitStore( __inout DRM_DST_CONTEXT *f_pContextDST );
+
+DRM_API DRM_RESULT DRM_CALL DRM_EST_CleanupStore(
+    __inout       DRM_DST_CONTEXT *f_pContextDST,
+    __in          DRM_BOOL         f_fWait );
+
+DRM_API DRM_RESULT DRM_CALL DRM_EST_OpenNamespace(
+    __inout        DRM_DST_CONTEXT           *f_pContextDST,
+    __in    const  DRM_DST_NAMESPACE         *f_pNamespace,
+    __in           DRM_DST_OPENMODE           f_eOpenMode,
+    __in           DRM_WORD                   f_wMaxNumChildren,
+    __in           DRM_DWORD                  f_dwExpectedSlotSize,
+    __out          DRM_DST_NAMESPACE_CONTEXT *f_pContextNS );
+
+DRM_API DRM_RESULT DRM_CALL DRM_EST_DeleteNamespace(
+    __inout    DRM_DST_CONTEXT   *f_pContextDST,
+    __inout    DRM_DST_NAMESPACE *f_pNS,
+    __in       DRM_BOOL           f_fWait );
+
+DRM_API DRM_RESULT DRM_CALL DRM_EST_CloseNamespace(
+    __inout    DRM_DST_NAMESPACE_CONTEXT  *f_pContextNS );
+
+DRM_API DRM_RESULT DRM_CALL DRM_EST_CommitNamespace(
+    __inout    DRM_DST_NAMESPACE_CONTEXT  *f_pContextNS );
+
+DRM_API DRM_RESULT DRM_CALL DRM_EST_MakeSlotHint(
+    __in    DRM_DST_SLOT_CONTEXT  *f_pContextSlot,
+    __out   DRM_DST_SLOT_HINT     *f_pSlotHint );
+
+DRM_API DRM_RESULT DRM_CALL DRM_EST_OpenSlot(
+    __in       DRM_DST_NAMESPACE_CONTEXT *f_pContextNS,
+    __in       DRM_DWORD                  f_dwMode,
+    __in const DRM_DST_KEY               *f_pKey1,
+    __in const DRM_DST_KEY               *f_pKey2,
+    __in_opt   DRM_DST_SLOT_HINT         *f_pSlotHint,
+    __inout    DRM_DWORD                 *f_pcbSlotSize,
+    __out      DRM_DST_SLOT_CONTEXT      *f_pContextSlot );
+
+DRM_API DRM_RESULT DRM_CALL DRM_EST_CloseSlot(
+    __inout  DRM_DST_SLOT_CONTEXT  *f_pContextSlot );
+
+DRM_API DRM_RESULT DRM_CALL DRM_EST_DeleteSlot(
+    __in       DRM_DST_NAMESPACE_CONTEXT *f_pContextNS,
+    __in const DRM_DST_KEY               *f_pKey1,
+    __in const DRM_DST_KEY               *f_pKey2,
+    __in_opt   DRM_DST_SLOT_HINT         *f_pSlotHint,
+    __in       DRM_BOOL                   f_fWait );
+
+DRM_API DRM_RESULT DRM_CALL DRM_EST_InitSlotEnum(
+    __in           DRM_DST_NAMESPACE_CONTEXT *f_pContextNS,
+    __in_opt const DRM_DST_KEY               *f_pKey1,
+    __in           DRM_DST_LOCKMODE           f_eLockMode,
+    __out          DRM_DST_ENUM_CONTEXT      *f_pContextEnum );
+
+DRM_API DRM_RESULT DRM_CALL DRM_EST_SlotEnumNext(
+    __inout    DRM_DST_ENUM_CONTEXT  *f_pContextEnum,
+    __out      DRM_DST_SLOT_CONTEXT  *f_pContextSlot,
+    __out_opt  DRM_DST_KEY           *f_pKey1,
+    __out_opt  DRM_DST_KEY           *f_pKey2,
+    __out_opt  DRM_DWORD             *f_pcbSize );
+
+DRM_API DRM_RESULT DRM_CALL DRM_EST_SlotEnumReloadCurrent(
+    __inout    DRM_DST_ENUM_CONTEXT  *f_pContextEnum,
+    __out      DRM_DST_SLOT_CONTEXT  *f_pContextSlot,
+    __out_opt  DRM_DST_KEY           *f_pKey1,
+    __out_opt  DRM_DST_KEY           *f_pKey2,
+    __out_opt  DRM_DWORD             *f_pcbSize );
+
+DRM_API DRM_RESULT DRM_CALL DRM_EST_SlotEnumDeleteCurrent(
+    __inout   DRM_DST_ENUM_CONTEXT  *f_pContextEnum,
+    __inout   DRM_DST_SLOT_CONTEXT  *f_pContextSlot );
+
+DRM_API DRM_RESULT DRM_CALL DRM_EST_BlockScanDelete(
+    __inout                DRM_DST_NAMESPACE_CONTEXT  *f_pContextNS,
+    __in_ecount( f_cKey1 ) DRM_DST_KEY                *f_rgKey1,
+    __in                   DRM_DWORD                   f_cKey1,
+    __in                   DRM_DST_KEY                *f_pKey2,
+    __in                   DRM_BOOL                    f_fWait );
+
+DRM_API DRM_RESULT DRM_CALL DRM_EST_SlotResize(
+    __inout  DRM_DST_SLOT_CONTEXT  *f_pContextSlot,
+    __in     DRM_DWORD              f_cbSize );
+
+DRM_API DRM_RESULT DRM_CALL DRM_EST_SlotSeek(
+    __inout   DRM_DST_SLOT_CONTEXT  *f_pContextSlot,
+    __in      DRM_LONG               f_lOffset,
+    __in      DRM_DST_SEEKMODE       f_eSeekMode,
+    __out_opt DRM_DWORD             *f_pdwSeekPointer );
+
+DRM_API DRM_RESULT DRM_CALL DRM_EST_SlotRead(
+    __inout                  DRM_DST_SLOT_CONTEXT  *f_pContextSlot,
+    __in                     DRM_DWORD              f_cbData,
+    __out_bcount( f_cbData ) DRM_BYTE              *f_pbData,
+    __out_opt                DRM_DWORD             *f_pcbRead );
+
+DRM_API DRM_RESULT DRM_CALL DRM_EST_SlotWrite(
+    __inout                       DRM_DST_SLOT_CONTEXT  *f_pContextSlot,
+    __in                          DRM_DWORD              f_cbData,
+    __in_bcount( f_cbData ) const DRM_BYTE              *f_pbData,
+    __out_opt                     DRM_DWORD             *f_pcbWritten );
+
+DRM_API DRM_RESULT DRM_CALL DRM_EST_SlotReadPtr(
+    __inout                           DRM_DST_SLOT_CONTEXT  *f_pContextSlot,
+    __deref_out_bcount( *f_pcbData )  DRM_BYTE             **f_ppbData,
+    __out                             DRM_DWORD             *f_pcbData );
+
+PREFAST_POP /* Parameters must match generic drmdatastore.h interface */
+
+EXIT_PK_NAMESPACE;
+
+#endif  /* __DRM_EMBEDDEDSTORE_H__ */
diff --git a/prebuilt-v4.4/noarch/include/drmfeatures.h b/prebuilt-v4.4/noarch/include/drmfeatures.h
new file mode 100644
index 0000000..ac519cc
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmfeatures.h
@@ -0,0 +1,325 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __DRMSETFEATURES_H__
+#define __DRMSETFEATURES_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+** Sample OEM profiles - OEMs can make variants of these profiles and give them names here.
+*/
+#define DRM_BUILD_PROFILE_OEM                  10
+#define DRM_BUILD_PROFILE_OEMPLAYONLY          11
+#define DRM_BUILD_PROFILE_OEMGATES             12
+#define DRM_BUILD_PROFILE_OEMTEE               13
+#define DRM_BUILD_PROFILE_OEMTEEPLAYONLY       14
+#define DRM_BUILD_PROFILE_LINUX                900
+
+/*
+** MS internal only (No value in OEM modification): Other profiles
+** -----------------------------------------------
+** MIN and MAX TEST profiles - This range of values is used internally for testing
+*/
+#define DRM_BUILD_PROFILE_PK                           1
+#define DRM_BUILD_PROFILE_PC                          21
+#define DRM_BUILD_PROFILE_RESERVED                    22
+#define DRM_BUILD_PROFILE_WP8_1                       23
+#define DRM_BUILD_PROFILE_PK_TEST_MIN                100
+#define DRM_BUILD_PROFILE_PK_TEST_OEM_PSEUDO_TEE     133
+#define DRM_BUILD_PROFILE_PK_TEST_MAX                199
+#define DRM_BUILD_PROFILE_XBOX                       600
+#define DRM_BUILD_PROFILE_IOS                        700
+#define DRM_BUILD_PROFILE_RMSDK                      800
+#define DRM_BUILD_PROFILE_MPR                       1000
+#define DRM_BUILD_PROFILE_ANDROID                   1100
+#define DRM_BUILD_PROFILE_MAC                       1200
+
+/*
+** Ensure the build profile is properly set.
+*/
+#ifndef DRM_BUILD_PROFILE
+    #ifndef __BUILDMACHINE__
+        #error "DRM_BUILD_PROFILE must be set to one of the above values either by the build environment or here."
+        /* Example: #define DRM_BUILD_PROFILE DRM_BUILD_PROFILE_PK */
+    #else
+        /* MS internal only (No value in OEM modification): MS builds (detected via __BUILDMACHINE__) default to PC profile */
+        #define DRM_BUILD_PROFILE DRM_BUILD_PROFILE_PC
+    #endif
+#endif
+
+/*
+** Pick correct compilation options based on a build profile.
+*/
+#if DRM_BUILD_PROFILE == DRM_BUILD_PROFILE_OEM
+
+/*
+** If building inside the provided nmake build system:
+** Do nothing.
+** If building outside the provided nmake build system:
+** Uncommment the #include below.
+** Modify the corresponding header for your specific OEM implementation.
+*/
+
+/* #include <drmbuild_oem.h> */
+
+#elif DRM_BUILD_PROFILE == DRM_BUILD_PROFILE_OEMPLAYONLY
+
+/*
+** If building inside the provided nmake build system:
+** Do nothing.
+** If building outside the provided nmake build system:
+** Uncommment the #include below.
+** Modify the corresponding header for your specific OEM implementation.
+*/
+
+/* #include <drmbuild_oemplayonly.h> */
+
+#elif DRM_BUILD_PROFILE == DRM_BUILD_PROFILE_OEMTEE
+
+/*
+** If building inside the provided nmake build system:
+** Do nothing.
+** If building outside the provided nmake build system:
+** Uncommment the #include below.
+** Modify the corresponding header for your specific OEM implementation.
+*/
+
+/* #include <drmbuild_oemtee.h> */
+
+#elif DRM_BUILD_PROFILE == DRM_BUILD_PROFILE_OEMTEEPLAYONLY
+
+/*
+** If building inside the provided nmake build system:
+** Do nothing.
+** If building outside the provided nmake build system:
+** Uncommment the #include below.
+** Modify the corresponding header for your specific OEM implementation.
+*/
+
+/* #include <drmbuild_oemteeplayonly.h> */
+
+/*
+** MS internal only (No value in OEM modification): #elif sections below
+*/
+#elif DRM_BUILD_PROFILE == DRM_BUILD_PROFILE_IOS
+#include <drmbuild_ios.h>
+#include <drmobfusdefs.h>
+#elif DRM_BUILD_PROFILE == DRM_BUILD_PROFILE_PK
+/* Do nothing */
+#elif DRM_BUILD_PROFILE == DRM_BUILD_PROFILE_RMSDK
+/* Do nothing */
+#elif DRM_BUILD_PROFILE == DRM_BUILD_PROFILE_PC
+/* Do nothing */
+#elif DRM_BUILD_PROFILE == DRM_BUILD_PROFILE_WP8_1
+/* Do nothing */
+#elif DRM_BUILD_PROFILE >= DRM_BUILD_PROFILE_PK_TEST_MIN && DRM_BUILD_PROFILE <= DRM_BUILD_PROFILE_PK_TEST_MAX
+/* Do nothing */
+#elif DRM_BUILD_PROFILE == DRM_BUILD_PROFILE_MPR
+#include <drmobfusdefs.h>
+#elif DRM_BUILD_PROFILE == DRM_BUILD_PROFILE_LINUX
+#include <drmbuild_linux.h>
+#elif DRM_BUILD_PROFILE == DRM_BUILD_PROFILE_ANDROID
+#include <drmbuild_android.h>
+#include <drmobfusdefs.h>
+#elif DRM_BUILD_PROFILE == DRM_BUILD_PROFILE_MAC
+#include <drmbuild_mac.h>
+#elif DRM_BUILD_PROFILE == DRM_BUILD_PROFILE_OEMGATES
+/* Do nothing */
+#else
+#error "Invalid value of DRM_BUILD_PROFILE in drmfeatures.h"
+#endif
+
+#if ( ( DRM_BUILD_PROFILE >= DRM_BUILD_PROFILE_PK_TEST_MIN && DRM_BUILD_PROFILE <= DRM_BUILD_PROFILE_PK_TEST_MAX ) || ( DRM_BUILD_PROFILE == DRM_BUILD_PROFILE_PK ) || ( DRM_BUILD_PROFILE == DRM_BUILD_PROFILE_PC ) )
+#define DRM_BUILD_PROFILE_IS_MICROSOFT_INTERNAL 1
+#endif  /* ( ( DRM_BUILD_PROFILE >= DRM_BUILD_PROFILE_PK_TEST_MIN && DRM_BUILD_PROFILE <= DRM_BUILD_PROFILE_PK_TEST_MAX ) || ( DRM_BUILD_PROFILE == DRM_BUILD_PROFILE_PK ) ) */
+
+/*
+#------------------------------------------------------------------------------
+# DRM_SUPPORT_PROFILING
+# Set this flag to '1' to enable profiling functionality
+# Profiling macros compile to gather performance data and write to a binary
+# file named perf.dat or perfagg.dat. The file can be used by external tools
+# for further analysis.
+# Profiling must be activated by a runtime call of DRM_Start_Profiling(),
+# and it can also be turned off at runtime by calling DRM_Stop_Profiling().
+# To minimize overhead introduced by the profiling, samples collected during
+# profiling are buffered first and flushed to a file when the buffer becomes full.
+# The file drmprofile.h defines several contstants to modify the behavior of
+# the profiling.
+#
+# If this flag is '0', the profiling macros compile to nothing.
+#
+# An application must still link to drmprofilingreal.lib in order for
+# profiling functions to be enabled.  Otherwise, the profiling macros
+# compile to function calls that themselves do nothing.
+#
+# There are no top level APIs directly affected by this flag.
+#
+#------------------------------------------------------------------------------
+*/
+#ifndef DRM_SUPPORT_PROFILING
+#define DRM_SUPPORT_PROFILING           0
+#endif
+
+/*
+#------------------------------------------------------------------------------
+# DRM_EXPORT_APIS_TO_DLL
+# MS internal only (No value in OEM modification):
+# Set this flag to '1' to mark DRM_API functions to be exported from a DLL.
+#------------------------------------------------------------------------------
+*/
+#ifndef DRM_EXPORT_APIS_TO_DLL
+#define DRM_EXPORT_APIS_TO_DLL          0
+#endif
+/*
+#------------------------------------------------------------------------------
+# DRM_TEST_LINK_TO_DRMAPI_DLL
+# MS internal only (No value in OEM modification):
+# Set this flag to '1' to allow test code executables to link with a DLL.
+#------------------------------------------------------------------------------
+*/
+#ifndef DRM_TEST_LINK_TO_DRMAPI_DLL
+#define DRM_TEST_LINK_TO_DRMAPI_DLL     0
+#endif
+
+/*
+#------------------------------------------------------------------------------
+# DRM_MAX_LICENSE_CHAIN_DEPTH
+# MS internal only (No value in OEM modification):
+# Total number of licenses in a chain support by this DRM implementation
+# Must be set to 2.
+#------------------------------------------------------------------------------
+*/
+#ifndef DRM_MAX_LICENSE_CHAIN_DEPTH
+#define DRM_MAX_LICENSE_CHAIN_DEPTH   2
+#endif
+
+/*
+#------------------------------------------------------------------------------
+# DRM_NO_OBFUS
+# MS internal only (No value in OEM modification):
+# Set this flag to '1' to disable using obfuscated group private key BLOB.
+#------------------------------------------------------------------------------
+*/
+#ifndef DRM_NO_OBFUS
+#define DRM_NO_OBFUS 1
+#endif
+
+/*
+#------------------------------------------------------------------------------
+# MS internal only (No value in OEM modification):
+# These flags must be defined by a profile.
+# If building inside the provided nmake build system,
+# they will be set by the included .mk files.
+# If building outside the provided nmake build system,
+# they should be set inside the following #if block above:
+# #if DRM_BUILD_PROFILE == DRM_BUILD_PROFILE_OEM
+# Refer to comments in that #if block (above).
+#------------------------------------------------------------------------------
+*/
+#ifndef DRM_SUPPORT_ASSEMBLY
+#error DRM_SUPPORT_ASSEMBLY must be defined by your profile
+#endif
+
+#ifndef DRM_SUPPORT_DATASTORE_PREALLOC
+#error DRM_SUPPORT_DATASTORE_PREALLOC must be defined by your profile
+#endif
+
+#ifndef DRM_SUPPORT_ECCPROFILING
+#error DRM_SUPPORT_ECCPROFILING must be defined by your profile
+#endif
+
+#ifndef DRM_SUPPORT_FORCE_ALIGN
+#error DRM_SUPPORT_FORCE_ALIGN must be defined by your profile
+#endif
+
+#ifndef DRM_SUPPORT_INLINEDWORDCPY
+#error DRM_SUPPORT_INLINEDWORDCPY must be defined by your profile
+#endif
+
+#ifndef DRM_SUPPORT_FILE_LOCKING
+#error DRM_SUPPORT_FILE_LOCKING must be defined by your profile
+#endif
+
+#ifndef DRM_SUPPORT_MULTI_THREADING
+#error DRM_SUPPORT_MULTI_THREADING must be defined by your profile
+#endif
+
+#ifndef DRM_SUPPORT_NATIVE_64BIT_TYPES
+#error DRM_SUPPORT_NATIVE_64BIT_TYPES must be defined by your profile
+#endif
+
+#ifndef DRM_SUPPORT_PRECOMPUTE_GTABLE
+#error DRM_SUPPORT_PRECOMPUTE_GTABLE must be defined by your profile
+#endif
+
+#ifndef DRM_SUPPORT_TRACING
+#error DRM_SUPPORT_TRACING must be defined by your profile
+#endif
+
+#ifndef _DATASTORE_WRITE_THRU
+#error _DATASTORE_WRITE_THRU must be defined by your profile
+#endif
+
+#ifndef _ADDLICENSE_WRITE_THRU
+#error _ADDLICENSE_WRITE_THRU must be defined by your profile
+#endif
+
+#ifndef DRM_HDS_COPY_BUFFER_SIZE
+#error DRM_HDS_COPY_BUFFER_SIZE must be defined by your profile
+#endif
+
+#ifndef DRM_SUPPORT_TOOLS_NET_IO
+#error DRM_SUPPORT_TOOLS_NET_IO must be defined by your profile
+#endif
+
+#ifndef DRM_TEST_SUPPORT_ACTIVATION
+#error DRM_TEST_SUPPORT_ACTIVATION must be defined by your profile
+#endif
+
+#ifndef USE_PK_NAMESPACES
+#error USE_PK_NAMESPACES must be defined by your profile
+#endif
+
+#ifndef DRM_INCLUDE_PK_NAMESPACE_USING_STATEMENT
+#error DRM_INCLUDE_PK_NAMESPACE_USING_STATEMENT must be defined by your profile
+#endif
+
+#if !defined(DRM_COMPILE_FOR_NORMAL_WORLD) && !defined(DRM_COMPILE_FOR_SECURE_WORLD)
+#error Neither DRM_COMPILE_FOR_NORMAL_WORLD nor DRM_COMPILE_FOR_SECURE_WORLD are defined.  One must be defined to 1 by your profile.  The other must be defined to 0 by your profile.
+#elif defined(DRM_COMPILE_FOR_NORMAL_WORLD) && DRM_COMPILE_FOR_NORMAL_WORLD != 1 && DRM_COMPILE_FOR_NORMAL_WORLD != 0
+#error DRM_COMPILE_FOR_NORMAL_WORLD is defined to neither 0 nor 1.
+#elif defined(DRM_COMPILE_FOR_SECURE_WORLD) && DRM_COMPILE_FOR_SECURE_WORLD != 1 && DRM_COMPILE_FOR_SECURE_WORLD != 0
+#error DRM_COMPILE_FOR_SECURE_WORLD is defined to neither 0 nor 1.
+#elif DRM_COMPILE_FOR_NORMAL_WORLD == DRM_COMPILE_FOR_SECURE_WORLD
+#error Both DRM_COMPILE_FOR_NORMAL_WORLD and DRM_COMPILE_FOR_SECURE_WORLD are defined to the same value.  One must be defined to 1 by your profile.  The other must be defined to 0 by your profile.
+#endif
+
+/*
+** MS internal only (No value in OEM modification):
+**
+** To enforce feature value for ALL profiles add the following pragma and then define a feature:
+**
+** #pragma warning(disable:4005)
+** #define DRM_SUPPORT_SOMEFEATURE 1
+*/
+
+/* This is the only supported keyfile version at this time. */
+#define DRM_KEYFILE_VERSION 3
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif  /* __DRMSETFEATURES_H__ */
+
+
+
diff --git a/prebuilt-v4.4/noarch/include/drmh264.h b/prebuilt-v4.4/noarch/include/drmh264.h
new file mode 100644
index 0000000..f7a4e8e
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmh264.h
@@ -0,0 +1,105 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __DRMH264_H__
+#define __DRMH264_H__
+
+#include <drmteetypes.h>
+
+ENTER_PK_NAMESPACE;
+
+#define DRM_MAP_H264_ERROR( drOrig ) DRM_DO {   \
+    DRM_RESULT _drTemp = (drOrig);              \
+    if( _drTemp >= DRM_E_H264_MINIMUM           \
+     && _drTemp <= DRM_E_H264_MAXIMUM )         \
+    {                                           \
+        dr = DRM_E_H264_PARSING_FAILED;         \
+    }                                           \
+    else                                        \
+    {                                           \
+        dr = _drTemp;                           \
+    }                                           \
+} DRM_WHILE_FALSE
+
+/*
+** Note: The functions declared in this file do NOT support execution on a Big-Endian CPU.
+*/
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_H264_FindSliceHeaderData(
+    __in                                                DRM_DWORD         f_cbEncrypted,
+    __in_bcount( f_cbEncrypted )                  const DRM_BYTE         *f_pbEncrypted,
+    __in                                                DRM_DWORD         f_cEncryptedRegionMapping,
+    __in_ecount( f_cEncryptedRegionMapping )      const DRM_DWORD        *f_pdwEncryptedRegionMapping,
+    __out                                               DRM_DWORD        *f_pcbNaluLengthInfo,
+    __deref_out_bcount( *f_pcbNaluLengthInfo )          DRM_BYTE        **f_ppbNaluLengthInfo,
+    __out                                               DRM_DWORD        *f_pibToRemove,
+    __out                                               DRM_DWORD        *f_pcbNaluTypes,
+    __deref_out_bcount( *f_pcbNaluTypes )               DRM_BYTE        **f_ppbNaluTypes,
+    __out                                               DRM_DWORD        *f_pcbSPSPPSData,
+    __deref_out_bcount( *f_pcbSPSPPSData )              DRM_BYTE        **f_ppbSPSPPSData,
+    __out                                               DRM_DWORD        *f_pcbUsedPortion,
+    __deref_out_bcount( *f_pcbUsedPortion )             DRM_BYTE        **f_ppbUsedPortion,
+    __out                                               DRM_DWORD        *f_pcdwOffsetData,
+    __deref_out_ecount( *f_pcdwOffsetData )             DRM_DWORD       **f_ppdwOffsetData,
+    __out                                               DRM_DWORD        *f_pcbSEIData,
+    __deref_out_bcount( *f_pcbSEIData )                 DRM_BYTE        **f_ppbSEIData ) DRM_NO_INLINE_ATTRIBUTE;
+
+typedef DRM_API DRM_RESULT( DRM_CALL *LPFN_H264_MEM_ALLOCATE )(
+    __inout_opt                                     DRM_VOID                   *f_pCallbackContextAllowNULL,
+    __in                                            DRM_DWORD                   f_cbSize,
+    __deref_out_bcount( f_cbSize )                  DRM_VOID                  **f_ppv );
+
+typedef DRM_API_VOID DRM_VOID( DRM_CALL *LPFN_H264_MEM_FREE )(
+    __inout_opt                                     DRM_VOID                   *f_pCallbackContextAllowNULL,
+    __inout                                         DRM_VOID                  **f_ppv );
+
+typedef DRM_API DRM_RESULT( DRM_CALL *LPFN_H264_MEM_GET_TIME )(
+    __inout_opt                                     DRM_VOID                   *f_pCallbackContextAllowNULL,
+    __out                                           DRMFILETIME                *f_pftSystemTime );
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_H264_LocateAndVerifySliceHeaders(
+    __in                                                      LPFN_H264_MEM_ALLOCATE  f_pfnMemAllocate,
+    __in                                                      LPFN_H264_MEM_FREE      f_pfnMemFree,
+    __in_opt                                                  LPFN_H264_MEM_GET_TIME  f_pfnGetTime,
+    __inout_opt                                               DRM_VOID               *f_pCallbackContextAllowNULL,
+    __in                                                      DRM_DWORD               f_cbFrame,
+    __in_bcount( f_cbFrame )                            const DRM_BYTE               *f_pbFrame,
+    __in                                                      DRM_DWORD               f_cbSPSPPSDictionary,
+    __in_bcount_opt( f_cbSPSPPSDictionary )             const DRM_BYTE               *f_pbSPSPPSDictionary,
+    __out                                                     DRM_DWORD              *f_pcbSPSPPSDictionaryUpdated,
+    __deref_out_bcount_opt( *f_pcbSPSPPSDictionaryUpdated )   DRM_BYTE              **f_ppbSPSPPSDictionaryUpdated,
+    __out                                                     DRM_DWORD              *f_pcbSliceHeaders,
+    __deref_out_bcount_opt( *f_pcbSliceHeaders )              DRM_BYTE              **f_ppbSliceHeaders ) DRM_NO_INLINE_ATTRIBUTE;
+
+#define DRM_H264_CheckErrorWindow_IMPLEMENTED 1
+
+#if DRM_H264_CheckErrorWindow_IMPLEMENTED
+DRM_NO_INLINE DRM_API DRM_BOOL DRM_CALL DRM_H264_CheckErrorWindow(
+    __in    const DRMFILETIME  *f_pftCurrentTime,
+    __in          DRM_BOOL      f_fOutsideTEE ) DRM_NO_INLINE_ATTRIBUTE;
+
+#define DRM_H264_ERROR_WINDOW_IN_SECONDS    60
+
+/*
+** For Perf, DRM_H264_ERROR_WINDOW_IN_TICS was pre-calculated.
+** If either value is changed, make sure this expression is also updated.
+**
+** DRM_H264_ERROR_WINDOW_IN_TICS =
+**              DRM_H264_ERROR_WINDOW_IN_SECONDS * C_TICS_PER_SECOND
+*/
+#define DRM_H264_ERROR_WINDOW_IN_TICS       600000000
+
+#define DRM_H264_MAX_ERRORS_IN_WINDOW       600
+#define DRM_H264_ERROR_USERMODE_FACTOR      0.85
+#else   /* DRM_H264_CheckErrorWindow_IMPLEMENTED */
+#define DRM_H264_CheckErrorWindow(x,y) DRM_SUCCESS
+#endif  /* DRM_H264_CheckErrorWindow_IMPLEMENTED */
+
+EXIT_PK_NAMESPACE;
+
+#endif /* __DRMH264_H__ */
+
diff --git a/prebuilt-v4.4/noarch/include/drmhashcache.h b/prebuilt-v4.4/noarch/include/drmhashcache.h
new file mode 100644
index 0000000..1f0c4d2
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmhashcache.h
@@ -0,0 +1,60 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __DRMHASHCACHE_H__
+#define __DRMHASHCACHE_H__ 1
+
+#include <drmtypes.h>
+#include <oemsha256types.h>
+#include <oemeccp256.h>
+
+ENTER_PK_NAMESPACE;
+
+typedef struct __tagDRM_CACHED_VERIFIED_HASH
+{
+    DRM_BOOL            fValid;
+    OEM_SHA256_DIGEST   oHash;
+} DRM_CACHED_VERIFIED_HASH;
+
+typedef struct __tagDRM_HASHCACHE_CONTEXT_INTERNAL
+{
+    DRM_BOOL                  fValid;
+    DRM_DWORD                 idxNextFree;
+    DRM_DWORD                 cPreVerifiedHashes;
+    DRM_DWORD                 cVerifiedHashes;
+    DRM_CACHED_VERIFIED_HASH *pVerifiedHashes;
+} DRM_HASHCACHE_CONTEXT_INTERNAL;
+
+
+typedef struct __tagDRM_HASHCACHE_CONTEXT
+{
+    DRM_BYTE rgbContext[sizeof(DRM_HASHCACHE_CONTEXT_INTERNAL)];
+} DRM_HASHCACHE_CONTEXT;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_HASHCACHE_Initialize(
+    __in                                    DRM_DWORD                    f_cPreVerifiedHashes,
+    __in_ecount(f_cPreVerifiedHashes) const OEM_SHA256_DIGEST           *f_pPreVerifiedHashes,
+    __in                                    DRM_DWORD                    f_cCacheBuffer,
+    __out_ecount(f_cCacheBuffer)            DRM_CACHED_VERIFIED_HASH    *f_pCacheBuffer,
+    __out                                   DRM_HASHCACHE_CONTEXT       *f_pCacheCtx ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_BOOL DRM_CALL DRM_HASHCACHE_CheckHash(
+    __in                              const DRM_HASHCACHE_CONTEXT       *f_pCacheCtx,
+    __in                              const OEM_SHA256_DIGEST           *f_pHash ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API_VOID DRM_VOID DRM_CALL DRM_HASHCACHE_AddHash(
+    __inout                                 DRM_HASHCACHE_CONTEXT       *f_pCacheCtx,
+    __in                              const OEM_SHA256_DIGEST           *f_pHash ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API_VOID DRM_VOID DRM_CALL DRM_HASHCACHE_Clear(
+    __inout                                 DRM_HASHCACHE_CONTEXT       *f_pCacheCtx ) DRM_NO_INLINE_ATTRIBUTE;
+
+EXIT_PK_NAMESPACE;
+
+#endif /* __DRMHASHCACHE_H__ */
+
diff --git a/prebuilt-v4.4/noarch/include/drmhdrbuilderconstants.h b/prebuilt-v4.4/noarch/include/drmhdrbuilderconstants.h
new file mode 100644
index 0000000..8197657
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmhdrbuilderconstants.h
@@ -0,0 +1,22 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __DRMHDRBUILDERCONSTANTS_H__
+#define __DRMHDRBUILDERCONSTANTS_H__
+
+#include <drmtypes.h>
+
+ENTER_PK_NAMESPACE;
+
+    extern DRM_GLOBAL_CONST  DRM_CONST_STRING       g_dstrAttributeHeaderXmlnsName;
+    extern DRM_GLOBAL_CONST  DRM_CONST_STRING       g_dstrAttributeHeaderXmlnsValue;
+
+EXIT_PK_NAMESPACE;
+
+#endif /* __DRMHDRBUILDERCONSTANTS_H__ */
+
diff --git a/prebuilt-v4.4/noarch/include/drmhds.h b/prebuilt-v4.4/noarch/include/drmhds.h
new file mode 100644
index 0000000..1880b90
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmhds.h
@@ -0,0 +1,327 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+
+#ifndef __DRM_HDS_H__
+#define __DRM_HDS_H__
+
+#include <drmdatastorecommon.h>
+#include <drmdatastore.h>
+#include <drmmodulesupport.h>
+
+PREFAST_PUSH_DISABLE_EXPLAINED(__WARNING_NONCONST_PARAM_25004, "Parameters must match generic drmdatastore.h interface")
+
+ENTER_PK_NAMESPACE;
+
+typedef struct __tagDRM_HDS_CONTEXT
+{
+    DRM_BYTE rgbOpaqueData[ DRM_HDS_CONTEXT_LEN ];
+} DRM_HDS_CONTEXT;
+
+/*
+** API Functions
+*/
+
+/*
+** ----------------------------------------------------------------------------
+** Methods applied to whole hashed file store
+** ----------------------------------------------------------------------------
+*/
+
+/**********************************************************************
+** Function:    DRM_HDS_Init
+** Synopsis:    Init HDS Context
+** Arguments:   [f_pContextDST] --
+** Returns:     DRM_SUCCESS on success
+** Notes:       The function MUST be called in the main thread BEFORE
+**              any of the child thread(s) starting sharing the same
+**              context. If this function is called after the child
+**              thread(s) started, the result is undefined.
+***********************************************************************/
+DRM_API DRM_RESULT DRM_CALL DRM_HDS_Init( __inout DRM_DST_CONTEXT *f_pContextDST );
+
+
+/**********************************************************************
+** Function:    DRM_HDS_Uninit
+** Synopsis:    Uninit HDS Context
+** Arguments:   [f_pContextDST] --
+** Returns:     DRM_SUCCESS on success
+** Notes:       This function MUST be called in the main thread AFTER
+**              any of the child thread(s) sharing the same context
+**              stopped. If this function is called before the child
+**              thread(s) stopped, the result is undefined.
+***********************************************************************/
+DRM_API DRM_RESULT DRM_CALL DRM_HDS_Uninit( __inout DRM_DST_CONTEXT *f_pContextDST );
+
+
+/**********************************************************************
+** Function:    DRM_HDS_CreateStore
+** Synopsis:    Create DRM data store file
+** Arguments:   [] --
+** Returns:     DRM_SUCCESS on success
+** Notes:
+***********************************************************************/
+DRM_API DRM_RESULT DRM_CALL DRM_HDS_CreateStore(
+    __in_opt                           DRM_VOID          *f_pvOEMContext,
+    __in_bcount( f_cbStoreData ) const DRM_BYTE          *f_pbStoreData,
+    __in                               DRM_DWORD          f_cbStoreData,
+    __in                         const DRM_DWORD          f_dwBlockSize,
+    __in                               DRM_DST_BLKNUMTYPE f_eBlNumType,
+    __in                               DRM_BOOL           f_fTruncateExist,
+    __in                         const DRM_DWORD          f_dwInitSizeInKB,
+    __out                              DRM_DST_CONTEXT   *f_pContextDST );
+
+
+/**********************************************************************
+** Function:    DRM_HDS_OpenStore
+** Synopsis:    Initialize the data store
+** Arguments:   [] --
+** Returns:     DRM_SUCCESS on success
+** Notes:
+***********************************************************************/
+PREFAST_PUSH_DISABLE_EXPLAINED(__WARNING_NONCONST_BUFFER_PARAM, "Parameters must match generic drmdatastore.h interface")
+DRM_API DRM_RESULT DRM_CALL DRM_HDS_OpenStore(
+    __in_opt                     DRM_VOID        *f_pOEMContext,
+    __in_bcount( f_cbStoreData ) DRM_BYTE        *f_pbStoreData,
+    __in                         DRM_DWORD        f_cbStoreData,
+    __in                         DRM_DWORD        f_dwGrowBySizeinKB,
+    __out                        DRM_DST_CONTEXT *f_pContextDST );
+PREFAST_POP
+
+
+/**********************************************************************
+** Function:    DRM_HDS_CloseStore
+** Synopsis:    Close the license store.  This will also Commit before close
+** Arguments:   [f_pContextDST] --
+** Returns:     DRM_SUCCESS on success
+** Notes:
+***********************************************************************/
+DRM_API DRM_RESULT DRM_CALL DRM_HDS_CloseStore( __inout DRM_DST_CONTEXT *f_pContextDST );
+
+/**********************************************************************
+** Function:    DRM_HDS_CommitStore
+** Synopsis:    flush unwritten data to disk
+** Arguments:   [f_pContextDST] --
+** Returns:     DRM_SUCCESS on success
+** Notes:
+***********************************************************************/
+DRM_API DRM_RESULT DRM_CALL DRM_HDS_CommitStore( __inout DRM_DST_CONTEXT *f_pContextDST );
+
+
+/**********************************************************************
+** Function:    DRM_HDS_CleanupStore
+** Synopsis:    clean up empty blocks and hidden slot in store
+** Arguments:   [f_pContextDST] --
+** Returns:     DRM_SUCCESS on success
+** Notes:
+***********************************************************************/
+DRM_API DRM_RESULT DRM_CALL DRM_HDS_CleanupStore(
+    __inout DRM_DST_CONTEXT *f_pContextDST,
+    __in    DRM_BOOL         f_fWait );
+
+#define DRM_HDS_OPEN_NAMESPACE_DEFAULT_EXPECTED_SLOT_SIZE 1000
+DRM_API DRM_RESULT DRM_CALL DRM_HDS_OpenNamespace(
+    __inout                            DRM_DST_CONTEXT           *f_pContextDST,
+    __in    const                      DRM_DST_NAMESPACE         *f_pNamespace,
+    __in                               DRM_DST_OPENMODE           f_eOpenMode,
+    __in                               DRM_WORD                   f_wMaxNumChildren,
+    __in                               DRM_DWORD                  f_dwExpectedSlotSize,
+    __out                              DRM_DST_NAMESPACE_CONTEXT *f_pContextNS );
+
+/* remove the entire namespace tree and its nodes in the data store */
+DRM_API DRM_RESULT DRM_CALL DRM_HDS_DeleteNamespace(
+    __inout    DRM_DST_CONTEXT   *f_pContextDST,
+    __inout    DRM_DST_NAMESPACE *f_pNS,
+    __in       DRM_BOOL           f_fWait );
+
+/* start using the specified namespace, any subsequent calls will be based on this namespace */
+DRM_API DRM_RESULT DRM_CALL DRM_HDS_CloseNamespace(
+    __inout    DRM_DST_NAMESPACE_CONTEXT  *f_pContextNS );  /* Namespace context returned from DRM_HDS_OpenNamespace */
+
+
+DRM_API DRM_RESULT DRM_CALL DRM_HDS_CommitNamespace( __inout    DRM_DST_NAMESPACE_CONTEXT  *f_pContextNS );
+
+/*
+** ----------------------------------------------------------------------------
+** Methods to navigate, create, delete, open and close HDS dataslots
+** ----------------------------------------------------------------------------
+*/
+
+/* Initialize a slot hint based on the slot context passed */
+PREFAST_PUSH_DISABLE_EXPLAINED(__WARNING_NONCONST_PARAM, "Parameters must match generic drmdatastore.h interface")
+DRM_API DRM_RESULT DRM_CALL DRM_HDS_MakeSlotHint(
+    __in    DRM_DST_SLOT_CONTEXT  *f_pContextSlot,
+    __out   DRM_DST_SLOT_HINT     *f_pSlotHint );
+PREFAST_POP
+
+/* Create or open dataslot using given key1 and key2 */
+PREFAST_PUSH_DISABLE_EXPLAINED(__WARNING_NONCONST_BUFFER_PARAM_25033, "Out params can't be const")
+DRM_API DRM_RESULT DRM_CALL DRM_HDS_OpenSlot(
+    __in       DRM_DST_NAMESPACE_CONTEXT *f_pContextNS,/* Namespace context returned from DRM_HDS_OpenNamespace */
+    __in       DRM_DWORD                  f_dwMode,
+    __in const DRM_DST_KEY               *f_pHashKey,
+    __in const DRM_DST_KEY               *f_pUniqueKey,
+    __in_opt   DRM_DST_SLOT_HINT         *f_pSlotHint,
+    __inout    DRM_DWORD                 *f_pcbSlotSize,/* current dataslot size */
+    __out      DRM_DST_SLOT_CONTEXT      *f_pContextSlot );/* user given Dataslot context buffer */
+PREFAST_POP
+
+/* Close an opened dataslot */
+DRM_API DRM_RESULT DRM_CALL DRM_HDS_CloseSlot( __inout  DRM_DST_SLOT_CONTEXT  *f_pContextSlot );
+
+/* delete the slot immediately */
+DRM_API DRM_RESULT DRM_CALL DRM_HDS_DeleteSlot(
+    __in       DRM_DST_NAMESPACE_CONTEXT *f_pContextNS,
+    __in const DRM_DST_KEY               *f_pHashKey,
+    __in const DRM_DST_KEY               *f_pUniqueKey,
+    __in_opt   DRM_DST_SLOT_HINT         *f_pSlotHint,
+    __in       DRM_BOOL                   f_fWait );
+
+
+/**********************************************************************
+** Function:    DRM_HDS_InitSlotEnum
+** Synopsis:
+** Arguments:   [f_pContextNS]   -- Namespace context init'd by DRM_HDS_OpenNamespace()
+**              [f_pHashKey]     -- Hashkey, if given to query, if not, enum all will be performed
+**              [f_eLockMode]    -- Flag specifing how to lock the slot
+**              [f_pContextEnum] -- returned Enum context
+** Returns:     DRM_SUCCESS on success
+** Notes:       This is 2 functions in one. If f_pHashKey is given, only the slots
+**              with the same hashkey will be enum'ed. if pHashKey is NULL, all
+**              slots within the namespace will be enum'ed.
+***********************************************************************/
+DRM_API DRM_RESULT DRM_CALL DRM_HDS_InitSlotEnum(
+    __in           DRM_DST_NAMESPACE_CONTEXT *f_pContextNS,
+    __in_opt const DRM_DST_KEY               *f_pHashKey,
+    __in           DRM_DST_LOCKMODE           f_eLockMode,
+    __out          DRM_DST_ENUM_CONTEXT      *f_pContextEnum );
+
+
+/**********************************************************************
+** Function:    DRM_HDS_SlotEnumNext
+** Synopsis:    Get the next slot in the enumeration
+** Arguments:   [f_pcontextEnum] -- Enum Context init'd by DRM_HDS_InitSlotEnum()
+**              [f_pContextSlot] -- Slot Context of the current slot
+**              [f_pHashKey] -- Hashkey of the current slot
+**              [f_pUniqueKey] -- Uniquekey of the current slot
+**              [f_pcbSlot] -- size of the current slot
+** Returns:     DRM_SUCCESS on success
+** Notes:
+***********************************************************************/
+PREFAST_PUSH_DISABLE_EXPLAINED(__WARNING_NONCONST_BUFFER_PARAM_25033, "Out params can't be const")
+DRM_API DRM_RESULT DRM_CALL DRM_HDS_SlotEnumNext(
+    __inout    DRM_DST_ENUM_CONTEXT  *f_pContextEnum,/* setup by DRM_HDS_InitSlotEnum() */
+    __out      DRM_DST_SLOT_CONTEXT  *f_pContextSlot,/* user given Dataslot context buffer */
+    __out_opt  DRM_DST_KEY           *f_pHashKey,    /* optional parameter */
+    __out_opt  DRM_DST_KEY           *f_pUniqueKey,  /* optional parameter */
+    __out_opt  DRM_DWORD             *f_pcbSlot );   /* current dataslot size, optional parameter */
+PREFAST_POP
+
+/**********************************************************************
+** Function:    DRM_HDS_SlotEnumReloadCurrent
+** Synopsis:    Load the current slot in the enumeration
+** Arguments:   [f_pContextEnum] -- Enum Context init'd by DRM_HDS_InitSlotEnum()
+**              [f_pContextSlot] -- Slot Context of the current slot
+**              [f_pHashKey] -- Hashkey of the current slot
+**              [f_pUniqueKey] -- Uniquekey of the current slot
+**              [f_pcbSlot] -- size of the current slot
+** Returns:     DRM_SUCCESS on success
+** Notes:
+***********************************************************************/
+PREFAST_PUSH_DISABLE_EXPLAINED(__WARNING_NONCONST_BUFFER_PARAM_25033, "Out params can't be const")
+DRM_API DRM_RESULT DRM_CALL DRM_HDS_SlotEnumReloadCurrent(
+    __inout    DRM_DST_ENUM_CONTEXT  *f_pContextEnum,       /* setup by DRM_HDS_InitSlotEnum() */
+    __out      DRM_DST_SLOT_CONTEXT  *f_pContextSlot,       /* user given Dataslot context buffer */
+    __out_opt  DRM_DST_KEY           *f_pHashKey,           /* optional parameter */
+    __out_opt  DRM_DST_KEY           *f_pUniqueKey,         /* optional parameter */
+    __out_opt  DRM_DWORD             *f_pcbSlot );          /* current dataslot size, optional parameter */
+PREFAST_POP
+
+/**********************************************************************
+** Function:    DRM_HDS_SlotEnumDeleteCurrent
+** Synopsis:    Delete the current enumerated slot
+** Arguments:   [f_pcontextEnum] -- Enum Context init'd by DRM_HDS_InitSlotEnum()
+**              [f_pcontextSlot] -- Slot Context of the current slot
+** Returns:     DRM_SUCCESS on success
+** Notes:       The enumeration must be init'ed with EXCLUSIVE right.
+***********************************************************************/
+DRM_API DRM_RESULT DRM_CALL DRM_HDS_SlotEnumDeleteCurrent(
+    __inout   DRM_DST_ENUM_CONTEXT  *f_pContextEnum,
+    __inout   DRM_DST_SLOT_CONTEXT  *f_pContextSlot );
+
+
+/* Block Scan API: rapid deletion of multiple slots */
+
+PREFAST_PUSH_DISABLE_EXPLAINED(__WARNING_NONCONST_PARAM, "Parameters must match generic drmdatastore.h interface")
+DRM_API DRM_RESULT DRM_CALL DRM_HDS_BlockScanDelete(
+    __inout                          DRM_DST_NAMESPACE_CONTEXT  *f_pContextNS,
+    __in_ecount( f_cKeysHash )       DRM_DST_KEY                *f_rgKeyHash,
+    __in                             DRM_DWORD                   f_cKeysHash,
+    __in                             DRM_DST_KEY                *f_pkeyUnique,
+    __in                             DRM_BOOL                    f_fWait );
+PREFAST_POP
+
+/*
+** ----------------------------------------------------------------------------
+** Methods to read, write and seek within a dataslot
+** ----------------------------------------------------------------------------
+*/
+
+/**********************************************************************
+** Function:    DRM_HDS_SlotResize
+** Synopsis:    resize an opened dataslot
+** Arguments:   [f_pContextSlot] -- An open slot context
+**              [f_cbSize]       -- New size of the slot
+** Returns:     DRM_SUCCESS on success
+** Notes:
+** Possible cases:
+**
+***********************************************************************/
+DRM_API DRM_RESULT DRM_CALL DRM_HDS_SlotResize(
+    __inout  DRM_DST_SLOT_CONTEXT  *f_pContextSlot,
+    __in     DRM_DWORD              f_cbSize );
+
+PREFAST_PUSH_DISABLE_EXPLAINED(__WARNING_NONCONST_BUFFER_PARAM_25033, "Out params can't be const")
+DRM_API DRM_RESULT DRM_CALL DRM_HDS_SlotSeek(
+    __inout   DRM_DST_SLOT_CONTEXT  *f_pContextSlot,
+    __in      DRM_LONG               f_lOffset,
+    __in      DRM_DST_SEEKMODE       f_eOrigin,
+    __out_opt DRM_DWORD             *f_pdwSeekPointer );/* optional parameter, can be NULL */
+PREFAST_POP
+
+PREFAST_PUSH_DISABLE_EXPLAINED(__WARNING_NONCONST_BUFFER_PARAM_25033, "Out params can't be const")
+DRM_API DRM_RESULT DRM_CALL DRM_HDS_SlotRead(
+    __inout                  DRM_DST_SLOT_CONTEXT  *f_pContextSlot,
+    __in                     DRM_DWORD              f_cbData,
+    __out_bcount( f_cbData ) DRM_BYTE              *f_pbData,
+    __out_opt                DRM_DWORD             *f_pcbRead );
+PREFAST_POP
+
+PREFAST_PUSH_DISABLE_EXPLAINED(__WARNING_NONCONST_BUFFER_PARAM_25033, "Out params can't be const")
+DRM_API DRM_RESULT DRM_CALL DRM_HDS_SlotWrite(
+    __inout                       DRM_DST_SLOT_CONTEXT  *f_pContextSlot,
+    __in                          DRM_DWORD              f_cbData,
+    __in_bcount( f_cbData ) const DRM_BYTE              *f_pbData,
+    __out_opt                     DRM_DWORD             *f_pcbWritten );
+PREFAST_POP
+
+PREFAST_PUSH_DISABLE_EXPLAINED(__WARNING_NONCONST_BUFFER_PARAM_25033, "Out params can't be const")
+DRM_API DRM_RESULT DRM_CALL DRM_HDS_SlotReadPtr(
+    __inout                           DRM_DST_SLOT_CONTEXT  *f_pContextSlot,
+    __deref_out_bcount( *f_pcbData )  DRM_BYTE             **f_ppbData,
+    __out                             DRM_DWORD             *f_pcbData );
+PREFAST_POP
+
+DRM_API DRM_RESULT DRM_CALL DRM_HDS_InitializeDST( __out DRM_DST *f_pDst );
+
+EXIT_PK_NAMESPACE;
+
+PREFAST_POP /* Parameters must match generic drmdatastore.h interface */
+
+#endif  /* __DRM_HDS_H__ */
+
diff --git a/prebuilt-v4.4/noarch/include/drmhds_impl.h b/prebuilt-v4.4/noarch/include/drmhds_impl.h
new file mode 100644
index 0000000..2fcfc96
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmhds_impl.h
@@ -0,0 +1,412 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+
+#ifndef _HDS_IMPL_H
+#define _HDS_IMPL_H
+
+#include <oemmd5types.h>
+#include <drmdatastorecommon.h>
+#include <oemplatform.h>
+#include <drmstkalloctypes.h>
+#include <oemcommon.h>
+#include <drmpragmas.h>
+
+ENTER_PK_NAMESPACE;
+
+/*
+** uncomment the following if do not need DRM_HDS_InitSlotEnum() and DRM_HDS_SlotEnumNext()
+*/
+/* #define _NOENUMALL */
+
+
+/*
+** Note: this is implementation specific.
+*/
+#define DRM_HDS_CONTEXT_LENGTH      2068+DRM_HDS_COPY_BUFFER_SIZE
+#define MAXSLOTPOS                  0xFFFF
+#define ROOTPARENTNUM               0x00
+
+
+#define DRM_E_HDSINVALIDSTORE     DRM_E_INVALID_LICENSE_STORE
+#define DRM_E_HDSSRNCORRUPTED     DRM_E_DST_CORRUPTED
+
+#define DRM_HDS_HASHKEY_SIZE        sizeof( DRM_DST_KEY )
+#define DRM_HDS_UNIQUEKEY_SIZE      sizeof( DRM_DST_KEY )
+#define DRM_HDS_NSNAME_SIZE         16
+
+/* create a namespace tree in the data store */
+#define DRM_HDS_MAXIMUM_CHILDREN 16
+
+
+/* Bloom filter constants for child block
+NOTE: Changing these values will break forward and backward compatibility */
+#define HDS_CHILDBLOCK_BLOOM_MAX_M 128 /* Size of Bloom data in bytes */
+#define HDS_CHILDBLOCK_BLOOM_MAX_K 710 /* Maximum Bloom K coefficient */
+
+#define HDS_CHILDBLOCK_PRERELEASE_BLOOM_K 7  /* Number of Bloom hash functions for V1 file format */
+#define HDS_CHILDBLOCK_PRERELEASE_BLOOM_M 20 /* Size of Bloom data in bytes for V1 file format */
+
+/*
+** Useful macros used in this source file only
+*/
+#define HDS_CONTEXT_LENGTH      ( sizeof( _HdsContext ) + DRM_HDS_CONTEXT_LENGTH )
+
+#define ISVALIDCONTEXT(ctx, eSignature) ( ( ctx ) != NULL && ( ( ctx )->eContextSignature == ( eSignature ) ) )
+
+#define CALC_MAXSLOTCONTEXTLEN  ( sizeof( _SlotContext ) + sizeof( _ChildBlockHDR ) + sizeof( _DataBlockHDR ) )
+
+#define CALC_MAXENUMCONTEXTLEN  ( sizeof( _EnumContext ) + sizeof( _ChildBlockHDR ) - sizeof( _CommBlockHDR ) )
+
+#define CALC_MAXBLOCKHEADERLEN  sizeof( _ChildBlockHDR )
+
+/*
+**  NOTE:
+**  -Child Node number = (Fileposition / NodeSize) + 1
+**  -Node number of the RootNode is always 0
+**  -Uses DRM_USHORT for Nodenum gives roughly 64K nodes in a file. On average, if a node
+**   can store 5 licenses, a license file can store up to 320K licenses.
+**  -If a larger number of licneses need to be stored, DRM_DWORD can be used. This will gives
+**   4096M nodes or 20480M licenses.
+**  -to search a node containing a particular license, we only have to traverse Log(N) times where
+**   N is the number of licenses in the file.
+*/
+
+
+
+
+/******************************************************************************
+** Major implementation data structure
+*******************************************************************************
+*/
+
+
+/*
+** Block Type
+*/
+typedef enum
+{
+    eINVALIDBLOCK = 0x00,
+    eCHILDBLOCK,
+    eDATABLOCK,
+    eFREEBLOCK
+} _EBlockType;
+
+typedef enum
+{
+    eHdsContextSignature  = 0x01,
+    eCfgContextSignature  = 0x02,
+    eSlotContextSignature = 0x03,
+    eEnumContextSignature = 0x04
+} _EContextSignature;
+
+
+/*
+**
+*/
+typedef enum
+{
+    eSlotCtxUninit = 0,
+    eSlotCtxInited,
+    eSlotCtxReady
+} _ESlotContextStatus;
+
+
+typedef enum
+{
+    eSearchSlotDontCare,
+    eSearchDataSlot,
+    eSearchNamespace,
+    eSearchHiddenOnly
+} _ESlotSearchMode;
+
+
+typedef enum
+{
+    eRemoveSlotSetHidden = 1,
+    eRemoveSlotSetNull   = 2,
+    eRemoveSlotPermanent = 3
+} _ERemoveSlotMode;
+
+
+typedef struct __tagDRM_HDS_NAMESPACE_BLOB
+{
+    DRM_BYTE rgb[ DRM_HDS_NSNAME_SIZE ];
+} DRM_HDS_NAMESPACE;
+
+/*
+** Namespace entry in SRN's namespace alloc table
+*/
+typedef struct _tag_NSEntry
+{
+    DRM_WORD  wMaxNumChildren;
+    DRM_WORD  wPadding;
+    DRM_DWORD nNSRBlockNum;                  /* block # of the Namespace Root node */
+    DRM_BYTE  bNSName [ DRM_HDS_NSNAME_SIZE ]; /* Namespace name */
+    DRM_WORD  wBloomBytesM;
+    DRM_WORD  wBloomK;
+} _NSEntry;
+
+
+/* HDS Namespace cache definitions */
+
+#define DRM_HDS_NAMESPACECACHE_FLAG_VALID 0x01
+
+typedef struct _tag_NamespaceCacheEntry
+{
+    DRM_DWORD dwCacheFlags;
+    _NSEntry nsEntry;
+} _NamespaceCacheEntry;
+
+#define DRM_HDS_NAMESPACECACHE_MAX_ENTRIES 8
+
+/*
+** Super Root Node
+*/
+typedef struct _tag_SRN
+{
+    DRM_UINT64    ui64Timestamp;    /* updates every time SRN is updated */
+    DRM_DWORD     dwSRNSize;        /* super root node size */
+    DRM_DWORD     dwBlockSize;      /* File block size */
+    DRM_DWORD     eBlockNumType;    /* DRM_DST_BLKNUMTYPE */
+    DRM_DWORD     nFreeListHead;
+    DRM_DWORD     nNsStoreRootBlockNum;
+    DRM_DWORD     nHighestFormattedBlockNum;  /* block num of the highest formated block */
+    DRM_BYTE      bSRNHash [ MD5DIGESTLEN ];    /* MD5 hash value of SRN */
+} _SRN;
+
+/*
+** HDS context
+*/
+typedef struct _tag_Context
+{
+    OEM_CRITICAL_SECTION oCS;
+    DRM_BOOL    fCSInited;
+    DRM_DWORD   dwContextSize;
+    DRM_BOOL    fInited;
+    DRM_DWORD   eContextSignature;
+    OEM_FILEHDL fp;
+    DRM_VOID   *pOEMContext;
+    DRM_MD5_CTX contextMD5;
+    DRM_DWORD   nGrowbySizeinKB;
+    DRM_DWORD   dwStoreVersion;
+
+    /* computed when HDS is 'opened' */
+    DRM_DWORD   nImagesize_FileBlockHDR;     /* file image size of _CommBlockHDR, not including payload */
+    DRM_DWORD   nImagesize_DataBlockHDR;     /* file image size of _DataBlockHDR, not including payload */
+    DRM_DWORD   nImagesize_DataBlockPayload; /* payload size of a _DataBlockHDR */
+    DRM_DWORD   nDataBlockPayloadPos;        /* payload pos from begining of a _DataBlockHDR */
+
+    /* Cache for namespace store entries */
+    _NamespaceCacheEntry namespaceCache[DRM_HDS_NAMESPACECACHE_MAX_ENTRIES];
+
+    /* work buffer initialized when HDS is opened */
+    DRM_STACK_ALLOCATOR_CONTEXT oHeap;
+
+    _SRN oSRN;    /* super root node, pbStack points to the area after oSRN */
+} _HdsContext;
+
+/*
+** HDS Config context
+*/
+typedef struct _tag_CfgContext
+{
+    DRM_DWORD wContextSize;
+    DRM_DWORD eContextSignature;
+    DRM_BOOL fInited;
+    _HdsContext *pHDS;
+    DRM_BYTE oNamespace[ DRM_HDS_NSNAME_SIZE ];
+
+    /* computed when a Namespace is 'used' */
+    DRM_DWORD nCfgRootBlockNum;
+    DRM_DWORD wMaxNumChildren;                /* # of children of the current selected Namespace */
+    DRM_DWORD nImagesize_ChildBlockHDR;       /* file image size of _ChildBlockHDR, not including payload */
+    DRM_DWORD nImagesize_ChildAllocTable;     /* file image size of ChildAlloc table of _ChildBlockHDR and _NSRootBlock */
+    DRM_DWORD nImagesize_ChildBlockPayload;   /* payload size of _ChildBlockHDR  */
+    DRM_DWORD nChildBlockPayloadPos;          /* payload pos from begining of _ChildBlockHDR */
+    DRM_WORD  wBloomBytesM;
+    DRM_WORD  wBloomK;
+} _NsContext;
+
+
+typedef struct _tag_GenericBlockHeader {
+    DRM_UINT64  ui64TimeStamp;
+    DRM_BYTE    bBlockHash [ MD5DIGESTLEN ];   /* MD5 hash of the above */
+    DRM_DWORD   nParentBlockNum;
+    DRM_BYTE    bBlockType;
+} _CommBlockFileHDR;    /*_FileImage; */
+
+typedef struct _tag_FileBlock
+{
+    /* computed at run time */
+    DRM_DWORD nBlockNum;
+    _NsContext *pNS;
+
+    /* read from file */
+    union
+    {
+        _CommBlockFileHDR _image;
+        DRM_BYTE bFileImage[ sizeof( _CommBlockFileHDR ) ];
+    } File;
+} _CommBlockHDR;
+
+
+typedef struct _tag_ChildBlockHeader
+{
+    DRM_DWORD nFreeMem;
+    DRM_BYTE bBloomData[HDS_CHILDBLOCK_BLOOM_MAX_M];
+    DRM_BYTE bChildAllocTable[DRM_HDS_MAXIMUM_CHILDREN*eDRM_DSTBLKNUM_DWORD];
+    DRM_BYTE bReserved;
+} _ChildBlockFileHDR;
+
+
+typedef struct _tag_ChildBlock
+{
+    _CommBlockHDR oBlockHeader;    /* derive from _CommBlockHDR */
+
+    /* calculated during init'd */
+    DRM_DWORD nCurrSlotPos;
+    DRM_DWORD nNextSlotPos;
+    DRM_DWORD nPayloadSize;
+    union
+    {
+        DRM_BYTE bFileImage[ sizeof(_ChildBlockFileHDR) ];
+        _ChildBlockFileHDR _image;
+    } File;
+} _ChildBlockHDR;
+
+typedef struct _tag_DataBlockHeader {
+    DRM_DWORD nCascadingBlockNum;
+} _DataBlockFileHDR;
+
+
+typedef struct _tag_DataBlock
+{
+    _CommBlockHDR oBlockHeader;    /* derive from _CommBlockHDR */
+
+    DRM_DWORD nPayloadSize;
+    union
+    {
+        DRM_BYTE bFileImage[ sizeof(DRM_DWORD) ];
+        _DataBlockFileHDR _image;
+    } File;
+} _DataBlockHDR;
+
+
+
+typedef enum
+{
+    eSlotIsNamespace = 0x00000001,
+    eSlotIsHidden    = 0x00000002
+} _ESlotAtributes;
+
+/*
+** record header structure precedes the actual storage of data record
+*/
+typedef struct _tag_SlotHeader
+{
+    DRM_DWORD   dwSlotSize;           /* actual Data Record Size */
+    DRM_DWORD   dwAttributes;         /* Attributes for this slot (see _ESlotAtributes) */
+    DRM_DST_KEY oHashkey;
+    DRM_DST_KEY oUniquekey;
+} _SlotHeader;
+
+
+/*
+** License FindFirst /  FindNext context
+*/
+typedef struct _tag_SlotContext
+{
+    DRM_DWORD dwContextSize;
+    DRM_DWORD eContextSignature;
+    DRM_DWORD eStatus;
+    _NsContext *pNS;
+    DRM_DST_LOCKMODE eLockMode;
+
+    /* cache of search result for slot allocation */
+    DRM_DWORD nBlockWithLargestFreeSpace;
+    DRM_DWORD dwLargestSpace;
+
+    _CommBlockHDR oFileBlock;      /* a copy of the file block in _ChildBlockHDR for verification purpose */
+    _CommBlockHDR *pCurrChildBlock; /* pointer of the _ChildBlockHDR containing the Slot, pointing somewhere in bBuff */
+    DRM_DWORD dwSlotPosInBlock;   /* the position in ChildBlock's payload where the slot is located (at begining _SlotHeader ) */
+    _SlotHeader oSlotHeader;    /* Slot header record in _ChildBlockHDR */
+    DRM_DWORD dwSeekPointer;      /* the current position in Slot where next slot read/write occurs */
+
+    /* the following is valid if slot data is stored in _DataBlockHDR chain */
+    DRM_DWORD dwNumofDataBlockVisited;  /* num of _DataBlockHDR visited not including current one */
+    DRM_DWORD dwFirstDataBlockNum;    /* first _DataBlockHDR number in the chain */
+    _CommBlockHDR *pCurrDataBlock;
+
+    /* buffer to contain _ChildBlockHDR and _DataBlockHDR */
+    DRM_BYTE bBuff [1];  /* size = dynamic size of _ChildBlockHDR + _DataBlockHDR */
+} _SlotContext;
+
+/*
+** Slot Enum context
+** this structure's size must be greater than or equal to CALC_MAXENUMCONTEXTLEN
+*/
+typedef struct _tag_EnumContext
+{
+    DRM_DWORD wContextSize;
+    DRM_DWORD eContextSignature;
+    _NsContext *pNS;
+    DRM_BOOL fInited;
+
+    _CommBlockHDR oFileBlock;      /* a copy of the file block in _ChildBlockHDR for verification purpose */
+    _SlotHeader oSlotHeader;    /* current slot header */
+
+    DRM_DST_LOCKMODE eLockMode;
+    DRM_BOOL fIsQuery;             /* TRUE if oHashKey is not NULL, FALSE if enum all */
+    DRM_DST_KEY oHashKey;
+
+    DRM_BOOL fCurrBlockIsValid;
+    _CommBlockHDR oCurrBlock;  /* this field must be located at end of structure */
+} _EnumContext;
+
+typedef struct _tag_BlockScanContext
+{
+    DRM_DWORD                cbContext;
+    DRM_DWORD                eContextSignature;
+    _NsContext              *pcontextNS;
+    DRM_BOOL                 fInited;
+    _CommBlockHDR            blockheader;  /* a copy of the file block in _ChildBlockHDR for verification purpose */
+    _SlotHeader              slotheader;   /* current slot header */
+    DRM_DST_LOCKMODE         lockmode;
+    DRM_DST_KEY              keyUnique;
+    const DRM_DST_KEY       *pkeyHash;  /* array of KIDs to delete */
+    DRM_DWORD                cKeysHash; /* size of array */
+    DRM_DWORD                cKeysFound;  /* number of KIDs marked for deletion thus far */
+    DRM_DWORD                iKeyCurrent; /* index of next unmarked KID in the array */
+    DRM_BOOL                 fCurrBlockIsValid;
+    _ChildBlockHDR           blockheaderCurrent;  /* this field must be located at end of structure */
+} _BlockScanContext;
+
+typedef struct _tag_SlotHint
+{
+    DRM_DWORD nSlotPosInBlock;
+    DRM_DWORD nBlockNum;
+} _SlotHint;
+
+/* HDS context sizes */
+#define DRM_HDS_CONTEXT_LEN             HDS_CONTEXT_LENGTH
+#define DRM_HDS_NAMESPACE_CONTEXT_LEN   (sizeof( _NsContext ))
+#define DRM_HDS_SLOT_CONTEXT_LEN        CALC_MAXSLOTCONTEXTLEN
+#define DRM_HDS_ENUM_CONTEXT_LEN        CALC_MAXENUMCONTEXTLEN
+#define DRM_HDS_SLOT_HINT_LEN           (sizeof(_SlotHint))
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_HDSIMPL_AllocBlockBuffer(
+    __inout _NsContext     *f_pNS,
+    __in    _EBlockType     f_eBlockType,
+    __out   _CommBlockHDR **f_ppBlock );
+
+EXIT_PK_NAMESPACE;
+
+#endif  /* _HDS_IMPL_H */
+
+
diff --git a/prebuilt-v4.4/noarch/include/drmhdsblockheadercache.h b/prebuilt-v4.4/noarch/include/drmhdsblockheadercache.h
new file mode 100644
index 0000000..e7e8934
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmhdsblockheadercache.h
@@ -0,0 +1,37 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __DRM_HDSBLOCKHEADERCACHE__
+#define __DRM_HDSBLOCKHEADERCACHE__
+
+#include <drmtypes.h>
+#include <drmhds_impl.h>
+
+ENTER_PK_NAMESPACE;
+
+DRM_API DRM_RESULT DRM_CALL DRM_HBHC_GetBlockHeaderFromCache(
+    __in     _NsContext     *f_pNS,
+    __in     DRM_DWORD       f_nBlkNum,
+    __inout  _CommBlockHDR **f_ppBlock,
+    __in     DRM_BOOL        f_fGenericHeaderOnly,
+    __out    DRM_BOOL       *f_pfFound );
+
+DRM_API DRM_RESULT DRM_CALL DRM_HBHC_UpdateBlockHeaderCache(
+    __in                                      DRM_DWORD   f_dwBlockNumber,
+    __in_opt                                  OEM_FILEHDL f_hHDSFileHandle,
+    __in                                      DRM_DWORD   f_dwBlockHeaderMetadata,
+    __in_bcount_opt( f_cbBytesToWrite ) const DRM_BYTE   *f_pbBlock,
+    __in                                      DRM_DWORD   f_cbBytesToWrite ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_API_VOID DRM_VOID DRM_CALL DRM_HBHC_ClearBlockHeaderCache(
+    __in    OEM_FILEHDL f_hHDSFileHandle ) DRM_NO_INLINE_ATTRIBUTE;
+
+EXIT_PK_NAMESPACE;
+
+#endif /* __DRM_HDSBLOCKHEADERCACHE__ */
+
diff --git a/prebuilt-v4.4/noarch/include/drmheaderparser.h b/prebuilt-v4.4/noarch/include/drmheaderparser.h
new file mode 100644
index 0000000..1dd19a1
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmheaderparser.h
@@ -0,0 +1,75 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+
+#ifndef __DRMHEADERPARSER_H__
+#define __DRMHEADERPARSER_H__
+
+#include <drmtypes.h>
+#include <oemcryptoctx.h>
+#include <drmpragmas.h>
+
+ENTER_PK_NAMESPACE;
+
+typedef enum __tag_eDRM_HEADER_ATTRIBUTES
+{
+    DRM_HEADER_ATTRIB_VERSION            = 1,
+    DRM_HEADER_ATTRIB_KID                = 2,
+    DRM_HEADER_ATTRIB_LAINFO             = 3,
+    DRM_HEADER_ATTRIB_CHECKSUM           = 4,
+    DRM_HEADER_ATTRIB_SECURITYVERSION    = 5,
+    DRM_HEADER_ATTRIB_OTHER              = 6,
+    DRM_HEADER_ATTRIB_LICENSE_ACQ_V4_URL = 7,
+    DRM_HEADER_ATTRIB_LICENSE_UI_URL     = 8,
+    DRM_HEADER_ATTRIB_DOMAIN_SERVICE_ID  = 9,
+    DRM_HEADER_ATTRIB_DECRYPTOR_SETUP    = 10,
+    DRM_HEADER_ATTRIB_ALGID              = 11,
+    DRM_HEADER_ATTRIB_KIDS               = 12,  /* multi-attribute */
+    DRM_HEADER_ATTRIB_CHECKSUMS          = 13,  /* multi-attribute */
+    DRM_HEADER_ATTRIB_ALGIDS             = 14,  /* multi-attribute */
+} eDRM_HEADER_ATTRIBUTES;
+
+typedef enum __tag_eDRM_HEADER_VERSION
+{
+    DRM_HEADER_VERSION_UNKNOWN           = 0,
+    DRM_HEADER_VERSION_2                 = 1,
+    DRM_HEADER_VERSION_2_4               = 3,
+    DRM_HEADER_VERSION_4                 = 2,
+    DRM_HEADER_VERSION_4_1               = 4,
+    DRM_HEADER_VERSION_4_2               = 5,
+    DRM_HEADER_VERSION_4_3               = 6,
+} eDRM_HEADER_VERSION;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_HDR_GetHeaderVersion(
+    __in const DRM_CONST_STRING     *f_pdstrContentHeader,
+    __out      eDRM_HEADER_VERSION  *f_peVersion );
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_HDR_GetAttribute(
+    __in     const DRM_CONST_STRING       *pdstrContentHeader,
+    __in_opt const DRM_CONST_STRING       *pdstrAttrName,
+    __in           eDRM_HEADER_ATTRIBUTES  eAttribute,
+    __out_opt      DRM_CONST_STRING       *pdstrValue,
+    __out_opt      DRM_DWORD              *pcValues,
+    __out_opt      DRM_CONST_STRING      **prgdstrValues,
+    __in           DRM_WCHAR               chXPathSeparator );
+
+DRM_API DRM_RESULT DRM_CALL DRM_HDR_GetUplink(
+    __in const DRM_CONST_STRING *pdstrContentHeader,
+    __in       DRM_DWORD         dwUplinkNumber,
+    __out      DRM_CONST_STRING *pdstrKid );
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_HDR_Verify(
+    __in     const DRM_CONST_STRING   *pdstrContentHeader,
+    __in_opt const DRM_CONST_STRING   *pdstrPubKey,
+    __in_opt       DRM_CRYPTO_CONTEXT *pContext,
+    __out          DRM_LONG           *plResult );
+
+EXIT_PK_NAMESPACE;
+
+#endif /* __DRMHEADERPARSER_H__ */
+
diff --git a/prebuilt-v4.4/noarch/include/drmheaderparserconstants.h b/prebuilt-v4.4/noarch/include/drmheaderparserconstants.h
new file mode 100644
index 0000000..2b4e388
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmheaderparserconstants.h
@@ -0,0 +1,21 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __DRMHEADERPARSERCONSTANTS_H__
+#define __DRMHEADERPARSERCONSTANTS_H__
+
+#include <drmtypes.h>
+
+ENTER_PK_NAMESPACE;
+
+    extern DRM_GLOBAL_CONST  DRM_CONST_STRING       g_dstrXPathHeaderUplinks;
+
+EXIT_PK_NAMESPACE;
+
+#endif /* __DRMHEADERPARSERCONSTANTS_H__ */
+
diff --git a/prebuilt-v4.4/noarch/include/drmint64.h b/prebuilt-v4.4/noarch/include/drmint64.h
new file mode 100644
index 0000000..43d6166
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmint64.h
@@ -0,0 +1,223 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __DRMINT64_H__
+#define __DRMINT64_H__
+
+#include <drmcompiler.h>
+#include <drmnamespace.h>   /* defining proper namespace (if used) */
+#include <drmsal.h>
+
+ENTER_PK_NAMESPACE;
+
+#if DRM_SUPPORT_NATIVE_64BIT_TYPES
+
+#define DRM_I64LITERAL(a,b) (DRM_INT64)(  ((DRM_INT64) (((DRM_INT64)(a))  << 32))  | ((DRM_INT64)(b)))
+#define DRM_UI64LITERAL(a,b)(DRM_UINT64)( ((DRM_UINT64)(((DRM_UINT64)(a)) << 32))  | ((DRM_UINT64)(b)))
+
+#define FILETIME_TO_UI64( ft, ui64 ) DRM_DO { (ui64) = DRM_UI64LITERAL( (ft).dwHighDateTime, (ft).dwLowDateTime ); } DRM_WHILE_FALSE
+#define NATIVE64_TO_NONNATIVE64( ui64 )
+#define NONNATIVE64_TO_NATIVE64( ui64 )
+
+/*
+** WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING
+** The following macros are not overflow safe.
+** Consider using functions in drmmathsafe.h instead.
+** WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING
+*/
+#define DRM_I64Add(a, b) ((DRM_INT64)( ((DRM_INT64)(a))  + ((DRM_INT64)(b)) ))
+#define DRM_I64Sub(a, b) ((DRM_INT64)( ((DRM_INT64)(a))  - ((DRM_INT64)(b)) ))
+#define DRM_I64Mul(a, b) ((DRM_INT64)( ((DRM_INT64)(a))  * ((DRM_INT64)(b)) ))
+#define DRM_I64Div(a, b) ((DRM_INT64)( ((DRM_INT64)(a))  / ((DRM_INT64)(b)) ))
+#define DRM_I64Mod(a, b) ((DRM_INT64)( ((DRM_INT64)(a))  % ((DRM_INT64)(b)) ))
+#define DRM_I64And(a, b) ((DRM_INT64)( ((DRM_INT64)(a))  & ((DRM_INT64)(b)) ))
+#define DRM_I64ShR(a, b) ((DRM_INT64)( ((DRM_INT64)(a)) >> ((DRM_INT64)(b)) ))
+#define DRM_I64ShL(a, b) ((DRM_INT64)( ((DRM_INT64)(a)) << ((DRM_INT64)(b)) ))
+#define DRM_I64Eql(a, b) ((DRM_INT64)( ((DRM_INT64)(a)) == ((DRM_INT64)(b)) ))
+#define DRM_I64Les(a, b) ((DRM_BOOL)( ((DRM_INT64)(a)) < ((DRM_INT64)(b)) ))
+#define DRM_I64(b) ( (DRM_INT64) (b) )
+#define DRM_I64Asgn(a, b) ( DRM_I64ShL((a),32) | ((DRM_INT64)(b)) )
+#define DRM_UI2I64(b) ((DRM_INT64)(b))
+
+#define DRM_I64ToUI32(b) ((DRM_DWORD)(b))
+#define DRM_I64High32(a) ((DRM_LONG)DRM_I64ShR((a),32))
+#define DRM_I64Low32(a)  ((DRM_LONG)(((DRM_INT64)(a)) & DRM_I64LITERAL(0,0xFFFFFFFF))) /* ignore the sign bit */
+
+#define DRM_UI64Add(a, b) ((DRM_UINT64)( ((DRM_UINT64)(a))  + ((DRM_UINT64)(b)) ))
+#define DRM_UI64Sub(a, b) ((DRM_UINT64)( ((DRM_UINT64)(a))  - ((DRM_UINT64)(b)) ))
+#define DRM_UI64Mul(a, b) ((DRM_UINT64)( ((DRM_UINT64)(a))  * ((DRM_UINT64)(b)) ))
+#define DRM_UI64Div(a, b) ((DRM_UINT64)( ((DRM_UINT64)(a))  / ((DRM_UINT64)(b)) ))
+#define DRM_UI64Mod(a, b) ((DRM_UINT64)( ((DRM_UINT64)(a))  % ((DRM_UINT64)(b)) ))
+#define DRM_UI64And(a, b) ((DRM_UINT64)( ((DRM_UINT64)(a))  & ((DRM_UINT64)(b)) ))
+#define DRM_UI64ShR(a, b) ((DRM_UINT64)( ((DRM_UINT64)(a)) >> ((DRM_UINT64)(b)) ))
+#define DRM_UI64ShL(a, b) ((DRM_UINT64)( ((DRM_UINT64)(a)) << ((DRM_UINT64)(b)) ))
+#define DRM_UI64Eql(a, b) ((DRM_BOOL)( ((DRM_UINT64)(a)) == ((DRM_UINT64)(b)) ))
+#define DRM_UI64Les(a, b) ((DRM_BOOL)( ((DRM_UINT64)(a)) < ((DRM_UINT64)(b)) ))
+#define DRM_UI64(b) ( (DRM_UINT64) (b) )
+/*
+** WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING
+** The preceding macros are not overflow safe.
+** Consider using functions in drmmathsafe.h instead.
+** WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING
+*/
+
+#define DRM_UI64HL(a,b)   ((DRM_UINT64)( DRM_UI64ShL((a),32) | ((DRM_UINT64)(b))))
+#define DRM_UI64High32(a) ((DRM_DWORD)(DRM_UI64ShR((a),32)))
+#define DRM_UI64Low32(a)  ((DRM_DWORD)(((DRM_UINT64)(a)) & DRM_UI64LITERAL(0,0xFFFFFFFF)))
+
+#else /* DRM_SUPPORT_NATIVE_64BIT_TYPES */
+
+#if DRM_64BIT_TARGET
+#error Incompatible configuration. A 64-bit target must natively support 64-bit types - please refer to oemcompiler.h near DRM_NATIVE_64BIT_TYPES_DEFINED
+#endif /* DRM_64BIT_TARGET */
+
+/* DRM_INT64 and DRM_UINT64 keeps 2 32 bit values
+** val[0] keeps low 32 bit
+** val[1] keeps high 32 bit
+** This is valid for both big and little endian CPUs
+*/
+
+typedef struct _DRM_INT64 {
+    unsigned long val[2];
+} DRM_INT64;
+
+typedef struct _DRM_UINT64 {
+    unsigned long val[2];
+} DRM_UINT64;
+
+/*
+** WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING
+** The following macros/functions are not overflow safe.
+** Consider using functions in drmmathsafe.h instead.
+** WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING
+*/
+extern DRM_API DRM_INT64 DRM_CALL DRM_I64Add(const DRM_INT64 a, const DRM_INT64 b);
+extern DRM_API DRM_INT64 DRM_CALL DRM_I64Sub(const DRM_INT64 a, const DRM_INT64 b);
+extern DRM_API DRM_INT64 DRM_CALL DRM_I64Mul(const DRM_INT64 a, const DRM_INT64 b);
+extern DRM_API DRM_INT64 DRM_CALL DRM_I64Div(const DRM_INT64 a, const DRM_INT64 b);
+extern DRM_API DRM_INT64 DRM_CALL DRM_I64Mod(const DRM_INT64 a, const DRM_INT64 b);
+extern DRM_API DRM_INT64 DRM_CALL DRM_I64And(const DRM_INT64 a, const DRM_INT64 b);
+extern DRM_API DRM_INT64 DRM_CALL DRM_I64ShR(const DRM_INT64 a, const DRM_DWORD b);
+extern DRM_API DRM_INT64 DRM_CALL DRM_I64ShL(const DRM_INT64 a, const DRM_DWORD b);
+extern DRM_API DRM_BOOL  DRM_CALL DRM_I64Eql(const DRM_INT64 a, const DRM_INT64 b);
+extern DRM_API DRM_BOOL  DRM_CALL DRM_I64Les(const DRM_INT64 a, const DRM_INT64 b);
+extern DRM_API DRM_INT64 DRM_CALL DRM_I64(const DRM_LONG b);
+extern DRM_API DRM_INT64 DRM_CALL DRM_I64Asgn(const DRM_LONG a, const DRM_LONG b);
+extern DRM_API DRM_INT64 DRM_CALL DRM_UI2I64(const DRM_UINT64 b);
+extern DRM_API DRM_DWORD DRM_CALL DRM_I64ToUI32(const DRM_INT64 b);
+
+extern DRM_API DRM_UINT64 DRM_CALL DRM_UI64Sub(const DRM_UINT64 a, const DRM_UINT64 b);
+extern DRM_API DRM_UINT64 DRM_CALL DRM_UI64Mul(const DRM_UINT64 a, const DRM_UINT64 b);
+extern DRM_API DRM_UINT64 DRM_CALL DRM_UI64Div(const DRM_UINT64 a, const DRM_UINT64 b);
+extern DRM_API DRM_UINT64 DRM_CALL DRM_UI64Mod(const DRM_UINT64 a, const DRM_UINT64 b);
+extern DRM_API DRM_UINT64 DRM_CALL DRM_UI64And(const DRM_UINT64 a, const DRM_UINT64 b);
+extern DRM_API DRM_UINT64 DRM_CALL DRM_UI64ShR(const DRM_UINT64 a, const DRM_DWORD b);
+extern DRM_API DRM_UINT64 DRM_CALL DRM_UI64ShL(const DRM_UINT64 a, const DRM_DWORD b);
+extern DRM_API DRM_BOOL   DRM_CALL DRM_UI64Eql(const DRM_UINT64 a, const DRM_UINT64 b);
+extern DRM_API DRM_BOOL   DRM_CALL DRM_UI64Les(const DRM_UINT64 a, const DRM_UINT64 b);
+extern DRM_API DRM_UINT64 DRM_CALL DRM_UI64(const DRM_DWORD b);
+
+extern DRM_API DRM_UINT64 DRM_CALL DRM_UI64HL(const DRM_DWORD a, const DRM_DWORD b);
+
+#define DRM_UI64ADD_IMPL                                \
+    DRM_UINT64 c;                                       \
+    c.val[0] = a.val[0]+b.val[0];                       \
+    c.val[1] = a.val[1]+b.val[1]+(c.val[0]<a.val[0]);   \
+    return c;
+
+#if DRM_INLINING_SUPPORTED
+DRM_ALWAYS_INLINE DRM_DWORD DRM_CALL DRM_UI64High32( DRM_UINT64 a ) DRM_ALWAYS_INLINE_ATTRIBUTE;
+DRM_ALWAYS_INLINE DRM_DWORD DRM_CALL DRM_UI64High32( DRM_UINT64 a )
+{
+    return a.val[1];
+}
+
+DRM_ALWAYS_INLINE DRM_DWORD DRM_CALL DRM_UI64Low32( DRM_UINT64 a ) DRM_ALWAYS_INLINE_ATTRIBUTE;
+DRM_ALWAYS_INLINE DRM_DWORD DRM_CALL DRM_UI64Low32( DRM_UINT64 a )
+{
+    return a.val[0];
+}
+DRM_ALWAYS_INLINE DRM_UINT64 DRM_CALL DRM_UI64Add( const DRM_UINT64 a, const DRM_UINT64 b ) DRM_ALWAYS_INLINE_ATTRIBUTE;
+DRM_ALWAYS_INLINE DRM_UINT64 DRM_CALL DRM_UI64Add( const DRM_UINT64 a, const DRM_UINT64 b )
+{
+    DRM_UI64ADD_IMPL;
+}
+#else /* DRM_INLINING_SUPPORTED */
+extern DRM_API DRM_DWORD  DRM_CALL DRM_UI64High32( DRM_UINT64 a );
+extern DRM_API DRM_DWORD  DRM_CALL DRM_UI64Low32( DRM_UINT64 a );
+extern DRM_API DRM_UINT64 DRM_CALL DRM_UI64Add(const DRM_UINT64 a, const DRM_UINT64 b);
+#endif /* DRM_INLINING_SUPPORTED */
+/*
+** WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING
+** The preceding macros/functions are not overflow safe.
+** Consider using functions in drmmathsafe.h instead.
+** WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING
+*/
+
+/* Low 32 bit are stored first in
+** DRM_UINT64 structure.
+** Thus we put "b" in first place
+*/
+#define DRM_UI64LITERAL(a,b) { b, a  }
+#define DRM_I64LITERAL(a,b) { b, a  }
+
+#define FILETIME_TO_UI64( ft, ui64 ) DRM_DO {ui64=DRM_UI64HL((ft).dwHighDateTime,(ft).dwLowDateTime);} DRM_WHILE_FALSE
+#define NATIVE64_TO_NONNATIVE64( ui64 ) DRM_DO {ui64=DRM_UI64HL(DRM_UI64Low32(ui64),DRM_UI64High32(ui64));} DRM_WHILE_FALSE /* Reverse the high and low */
+#define NONNATIVE64_TO_NATIVE64( ui64 ) NATIVE64_TO_NONNATIVE64( ui64 )
+
+#endif /* DRM_SUPPORT_NATIVE_64BIT_TYPES */
+
+/*
+** This conversion is common for both native support of 64 bit number and representation as struct
+*/
+#define DRM_I2UI64(b) (*((const DRM_UINT64*)(&(b))))
+
+#define DRM_UI64Add32(a, b) DRM_UI64Add( DRM_UI64(a), DRM_UI64(b) )
+
+#define UI64_TO_FILETIME( ui64, ft ) DRM_DO { (ft).dwHighDateTime = DRM_UI64High32(ui64); (ft).dwLowDateTime = DRM_UI64Low32(ui64); } DRM_WHILE_FALSE
+
+
+#if !DRM_SUPPORT_NATIVE_64BIT_TYPES
+/* DRM_INT64 and DRM_UINT64 is defined to be the same structure */
+#define DRM_I64High32(a) ((long int)DRM_UI64High32(DRM_I2UI64(a)))
+#define DRM_I64Low32(a)  ((long int)DRM_UI64Low32(DRM_I2UI64(a)))
+#endif /* DRM_SUPPORT_NATIVE_64BIT_TYPES */
+
+/* DRM_UI64Eql: a == b */
+/* DRM_UI64Les: a <  b */
+/* DRM_UI64Gre: a >  b */
+/* DRM_UI64LEq: a <= b */
+/* DRM_UI64GEq: a >= b */
+#define DRM_UI64Gre(a, b)   ( DRM_UI64Les( (b), (a) ) )
+#define DRM_UI64LEq(a, b)   ( !( DRM_UI64Les( (b), (a) ) ) )
+#define DRM_UI64GEq(a, b)   ( !( DRM_UI64Les( (a), (b) ) ) )
+
+#define DRM_UI64MIN(a, b)   ( DRM_UI64Les( ( a ), ( b ) ) ? ( a ) : ( b ) )
+#define DRM_UI64MAX(a, b)   ( DRM_UI64Gre( ( a ), ( b ) ) ? ( a ) : ( b ) )
+
+/* DRM_I64Eql: a == b */
+/* DRM_I64Les: a <  b */
+/* DRM_I64Gre: a >  b */
+/* DRM_I64LEq: a <= b */
+/* DRM_I64GEq: a >= b */
+#define DRM_I64Gre(a, b)   ( DRM_I64Les( (b), (a) ) )
+#define DRM_I64LEq(a, b)   ( !( DRM_I64Les( (b), (a) ) ) )
+#define DRM_I64GEq(a, b)   ( !( DRM_I64Les( (a), (b) ) ) )
+
+#define DRM_I64MIN(a, b)   ( DRM_I64Les( ( a ), ( b ) ) ? ( a ) : ( b ) )
+#define DRM_I64MAX(a, b)   ( DRM_I64Gre( ( a ), ( b ) ) ? ( a ) : ( b ) )
+
+#define DRM_UI64_LITERAL_MAX_VALUE      DRM_UI64LITERAL(DRM_MAX_UNSIGNED_TYPE(DRM_DWORD),DRM_MAX_UNSIGNED_TYPE(DRM_DWORD))
+
+/* Note: This value is computed and can not be directly assigned to a declared variable */
+#define DRM_UI64_COMPUTED_MAX_VALUE     DRM_UI64HL(DRM_MAX_UNSIGNED_TYPE(DRM_DWORD),DRM_MAX_UNSIGNED_TYPE(DRM_DWORD))
+
+EXIT_PK_NAMESPACE;
+
+#endif /* __DRMINT64_H__ */
+
diff --git a/prebuilt-v4.4/noarch/include/drmkeyfilecerttypes.h b/prebuilt-v4.4/noarch/include/drmkeyfilecerttypes.h
new file mode 100644
index 0000000..7dc074a
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmkeyfilecerttypes.h
@@ -0,0 +1,27 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef _DRMKEYFILECERTTYPES_H_
+#define _DRMKEYFILECERTTYPES_H_
+
+#include <oemcommon.h>
+
+ENTER_PK_NAMESPACE;
+
+typedef enum DRM_KF_CERT_TYPE
+{
+    eKF_CERT_TYPE_INVALID,
+    eKF_CERT_TYPE_NDT,
+    eKF_CERT_TYPE_WMDRM,
+    eKF_CERT_TYPE_PLAYREADY,
+} DRM_KF_CERT_TYPE;
+
+EXIT_PK_NAMESPACE;
+
+#endif /* _DRMKEYFILECERTTYPES_H_ */
+
diff --git a/prebuilt-v4.4/noarch/include/drmkeygenerator.h b/prebuilt-v4.4/noarch/include/drmkeygenerator.h
new file mode 100644
index 0000000..7344e8e
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmkeygenerator.h
@@ -0,0 +1,69 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __DRMKEYGEN_H__
+#define __DRMKEYGEN_H__
+
+#include <drmnamespace.h>
+#include <oemciphertypes.h>
+
+ENTER_PK_NAMESPACE;
+
+#define DRM_KEYSEED_BASE64_LEN  40
+#define DRM_KEYSEED_BINARY_LEN  CB_BASE64_DECODE(DRM_KEYSEED_BASE64_LEN)
+
+/*
+**
+** NOTE:  All Keygen functions include a NULL termination character
+** in the character count and the string on function return
+**
+*/
+
+DRM_API DRM_RESULT DRM_CALL DRM_KG_GenerateKeyseed(
+    __in_opt                           DRM_VOID        *f_pOEMContext,
+    __out_ecount_opt( *f_pcchKeyseed ) DRM_WCHAR *f_pwszKeyseed,
+    __inout                            DRM_DWORD *f_pcchKeyseed );
+
+DRM_API DRM_RESULT DRM_CALL DRM_KG_GenerateKeyID(
+    __in_opt                         DRM_VOID  *f_pOEMContext,
+    __out_ecount_opt( *f_pcchKeyID ) DRM_WCHAR *f_pwszKeyID,           /* base64 encoded string */
+    __inout                          DRM_DWORD *f_pcchKeyID );
+
+
+DRM_API DRM_RESULT DRM_CALL DRM_KG_GenerateContentKeyB64(
+    __in_ecount( f_cchKeySeed )            const DRM_WCHAR             *f_pwszKeySeed,          /* base64 encoded string */
+    __in                                         DRM_DWORD              f_cchKeySeed,
+    __in_ecount( f_cchKeyID )              const DRM_WCHAR             *f_pwszKeyID,            /* base64 encoded string */
+    __in                                         DRM_DWORD              f_cchKeyID,
+    __in                                         DRM_SUPPORTED_CIPHERS  f_eCipherType,
+    __in                                         DRM_DWORD              f_cbContentKey,
+    __out_ecount_opt(*f_pcchContentKey)          DRM_WCHAR             *f_pwszContentKey,
+    __in                                         DRM_DWORD             *f_pcchContentKey,
+    __out_bcount_opt( f_cbScratchKeySeed )       DRM_BYTE              *f_pbScratchKeySeed,
+    __in                                         DRM_DWORD              f_cbScratchKeySeed );
+
+
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_KG_GenerateContentKeyBinary(
+    __in_bcount( f_cbKeySeed )             const DRM_BYTE               *f_pbKeySeed,
+    __in                                         DRM_DWORD               f_cbKeySeed,
+    __in                                   const DRM_KID                *f_pKID,
+    __in                                         DRM_SUPPORTED_CIPHERS   f_eCipherType,
+    __out_bcount(f_cbContentKey)                 DRM_BYTE               *f_pbContentKey,
+    __in                                         DRM_DWORD               f_cbContentKey,
+    __out_bcount_opt( f_cbScratchKeySeed )       DRM_BYTE               *f_pbScratchKeySeed,
+    __in                                         DRM_DWORD               f_cbScratchKeySeed ) DRM_NO_INLINE_ATTRIBUTE;
+
+
+
+
+
+EXIT_PK_NAMESPACE;
+
+#endif /*__DRMKEYGEN_H__ */
+
diff --git a/prebuilt-v4.4/noarch/include/drmlastinclude.h b/prebuilt-v4.4/noarch/include/drmlastinclude.h
new file mode 100644
index 0000000..f0ee402
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmlastinclude.h
@@ -0,0 +1,19 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifdef __DRMLASTINCLUDE_H__
+#error drmlastinclude.h should be included in each source file as the last include only.
+#endif
+
+#define __DRMLASTINCLUDE_H__
+
+#if DRM_BUILD_PROFILE == DRM_BUILD_PROFILE_IOS
+#include <drmobfusdefslast.h>
+#elif DRM_BUILD_PROFILE == DRM_BUILD_PROFILE_ANDROID
+#include <drmobfusdefslast.h>
+#endif
diff --git a/prebuilt-v4.4/noarch/include/drmlegacyxmlcertrevocation.h b/prebuilt-v4.4/noarch/include/drmlegacyxmlcertrevocation.h
new file mode 100644
index 0000000..2d8cfe0
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmlegacyxmlcertrevocation.h
@@ -0,0 +1,64 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __DRMLEGACYXMLCERTREVOCATION_H__
+#define __DRMLEGACYXMLCERTREVOCATION_H__
+
+#include <oemrsa.h>
+#include <drmmanager.h>
+#include <drmmodulesupport.h>
+
+ENTER_PK_NAMESPACE;
+
+PREFAST_PUSH_DISABLE_EXPLAINED(__WARNING_NONCONST_BUFFER_PARAM_25033, "Out params can't be const")
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_RVK_GetLegacyXMLCertRevocationEntries(
+    __inout_bcount( f_cbRevocationData )   DRM_BYTE                 *f_pbRevocationData,
+    __in                                   DRM_DWORD                 f_cbRevocationData,
+    __out_ecount(1)                        DRM_DWORD                *f_pcEntries,
+    __deref_out_ecount_opt( *f_pcEntries ) LEGACYXMLCERT_CRL_ENTRY **f_ppEntries ) DRM_NO_INLINE_ATTRIBUTE;
+PREFAST_POP /* __WARNING_NONCONST_BUFFER_PARAM_25033 */
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_RVK_VerifyRevocationList(
+    __in     const DRM_GUID                    *f_pguidRevocationType,
+    __in_opt       DRM_REVOCATIONSTORE_CONTEXT *f_pContextRev,
+    __in_opt       DRM_CRYPTO_CONTEXT          *f_pcontextCRYP,
+    __in     const DRM_CONST_STRING            *f_pdstrList,
+    __out          DRM_DWORD                   *f_pidSerial ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_API DRM_RESULT DRM_CALL DRM_RVK_GetLegacyXMLCertList(
+    __in_opt                                       DRM_CRYPTO_CONTEXT           *f_pcontextCRYP,
+    __in                                           DRM_REVOCATIONSTORE_CONTEXT  *f_pContextRev,
+    __in_bcount_opt( *f_pcbRevocationData )  const DRM_BYTE                     *f_pbRevocationData,
+    __inout                                        DRM_DWORD                    *f_pcbRevocationData,
+    __out                                          DRM_DWORD                    *f_pidSerial ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_RESULT DRM_RVK_UpdateLegacyXMLCertRevocationListDecoded(
+    __in                                     DRM_CRYPTO_CONTEXT          *f_pcontextCrypto,
+    __in                                     DRM_REVOCATIONSTORE_CONTEXT *f_pContextRev,
+    __in_ecount(f_cbRevocationList)    const DRM_BYTE                    *f_pbRevocationList,
+    __in                                     DRM_DWORD                    f_cbRevocationList,
+    __in_ecount(f_cbRevocationBuffer)  const DRM_BYTE                    *f_pbRevocationBuffer,
+    __in                                     DRM_DWORD                    f_cbRevocationBuffer,
+    __out_opt                                DRM_BOOL                    *f_pfUpdated,
+    __out_opt                                DRM_DWORD                   *f_pdwVersion );
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_RVK_VerifyLegacyXMLCertCRLSignature(
+    __inout_opt                          DRM_SECURECORE_CONTEXT *f_pSecureCoreCtx,
+    __in_opt                             DRM_SECSTORE_CONTEXT   *f_pcontextSST,
+    __in_opt                             DRM_DST                *f_pDatastore,
+    __in_bcount( f_cbSignedBytes ) const DRM_BYTE               *f_pbSignedBytes,
+    __in                                 DRM_DWORD               f_cbSignedBytes,
+    __in_bcount( f_cbSignature )   const DRM_BYTE               *f_pbSignature,
+    __in                                 DRM_DWORD               f_cbSignature,
+    __in                                 DRM_SUBSTRING           f_dasstrCertificate,
+    __in_opt                             DRM_CRYPTO_CONTEXT     *f_pCryptoCtx ) DRM_NO_INLINE_ATTRIBUTE;
+
+EXIT_PK_NAMESPACE;
+
+#endif /*__DRMLEGACYXMLCERTREVOCATION_H__ */
+
diff --git a/prebuilt-v4.4/noarch/include/drmlegacyxmlcertrsakeys.h b/prebuilt-v4.4/noarch/include/drmlegacyxmlcertrsakeys.h
new file mode 100644
index 0000000..e40eb5d
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmlegacyxmlcertrsakeys.h
@@ -0,0 +1,56 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __DRMXMLRSAKEYS_H
+#define __DRMXMLRSAKEYS_H
+
+#include <drmxmlparser.h>
+#include <drmxmlbuildera.h>
+#include <oemrsa.h>
+
+ENTER_PK_NAMESPACE;
+
+DRM_API DRM_RESULT DRM_CALL DRM_XML_RSA_WritePublicKeyNodeA(
+   __inout        _XMBContextA                  *f_pXMLCtxA,
+   __in_opt const DRM_ANSI_CONST_STRING         *f_pdastrWrapperTag,
+   __in     const DRM_RSA_PUBLIC_KEY_2048BIT    *f_pKeyRSAPublic );
+
+DRM_API DRM_RESULT DRM_CALL DRM_XML_RSA_WritePublicKeyNode(
+   __inout        _XMBContext                *f_pXMLCtx,
+   __in_opt const DRM_CONST_STRING           *f_pdastrWrapperTag,
+   __in     const DRM_RSA_PUBLIC_KEY_2048BIT *f_pKeyRSAPublic );
+
+DRM_API DRM_RESULT DRM_CALL DRM_XML_RSA_ParseBase64PublicKey(
+   __in    const DRM_CONST_STRING           *f_dstrPubKeyModulus,
+   __in    const DRM_CONST_STRING           *f_dstrPubKeyExponent,
+   __inout       DRM_RSA_PUBLIC_KEY_2048BIT *f_pKeyRSAPublic );
+
+DRM_API DRM_RESULT DRM_CALL DRM_XML_RSA_ParseBase64PublicKeyA(
+    __in    const DRM_ANSI_CONST_STRING         *f_dastrPubKeyModulus,
+    __in    const DRM_SUBSTRING                 *f_dasstrPubKeyModulus,
+    __in    const DRM_ANSI_CONST_STRING         *f_dastrPubKeyExponent,
+    __in    const DRM_SUBSTRING                 *f_dasstrPubKeyExponent,
+    __inout       DRM_RSA_PUBLIC_KEY_2048BIT    *f_pKeyRSAPublic );
+
+DRM_API DRM_RESULT DRM_CALL DRM_XML_RSA_WritePrivateKeyNode(
+   __inout        _XMBContext                 *f_pXMLCtx,
+   __in_opt const DRM_CONST_STRING            *f_pdstrWrapperTag,
+   __in     const DRM_RSA_PRIVATE_KEY_2048BIT *f_pKeyRSAPrivate );
+
+DRM_API DRM_RESULT DRM_CALL DRM_XML_RSA_ParseBase64PrivateKey(
+    __in    const DRM_CONST_STRING            *f_dstrPrivKeyPrime0,
+    __in    const DRM_CONST_STRING            *f_dstrPrivKeyPrime1,
+    __in    const DRM_CONST_STRING            *f_dstrPrivKeyCRTExponent0,
+    __in    const DRM_CONST_STRING            *f_dstrPrivKeyCRTExponent1,
+    __in    const DRM_CONST_STRING            *f_dstrPrivKeyIQMP,
+    __inout       DRM_RSA_PRIVATE_KEY_2048BIT *f_pKeyRSAPrivate );
+
+EXIT_PK_NAMESPACE;
+
+#endif /* __DRMXMLRSAKEYS_H__ */
+
diff --git a/prebuilt-v4.4/noarch/include/drmlicacqv3.h b/prebuilt-v4.4/noarch/include/drmlicacqv3.h
new file mode 100644
index 0000000..1ae6fe7
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmlicacqv3.h
@@ -0,0 +1,350 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __DRM_LICACQ_V3_H
+#define __DRM_LICACQ_V3_H
+
+#include <drmxmlsig.h>
+#include <drmnoncestore.h>
+#include <drmmanagertypes.h>
+
+ENTER_PK_NAMESPACE;
+
+/*
+** Define the maximum number of rights
+** that can be requested at one time.
+*/
+#define DRM_MAX_RIGHTS_REQUESTED    1
+
+/*
+** List of license response processing flags
+*/
+typedef enum _DRM_PROCESS_LIC_RESPONSE_FLAG
+{
+    DRM_PROCESS_LIC_RESPONSE_NO_FLAGS                                   = 0x00000000L,      /* No flags (default) - Opt-in response verification, allow all license types */
+    DRM_PROCESS_LIC_RESPONSE_SIGNATURE_NOT_REQUIRED                     = 0x00000001L,      /* Signature is not required, i.e. Opt-out response verification */
+    DRM_PROCESS_LIC_RESPONSE_BLOCK_PERSISTENT_LICENSES                  = 0x00000002L,      /* Persistent licenses are not allowed */
+    DRM_PROCESS_LIC_RESPONSE_BLOCK_SECURESTOP_LICENSES                  = 0x00000004L,      /* Licenses requiring secure stop are not allowed */
+    DRM_PROCESS_LIC_RESPONSE_BLOCK_TEMPORARY_NON_SECURE_STOP_LICENSES   = 0x00000008L,      /* Non-persist licenses that do NOT require secure stop are not allowed */
+
+    DRM_PROCESS_LIC_RESPONSE_INVALID_FLAGS                              = 0xFFFFFFF0L,      /* Used for argument checking */
+} DRM_PROCESS_LIC_RESPONSE_FLAG;
+
+/*
+** There are 4 types of revocation data:
+** PlayReadyApp, PlayReadyRuntime, LegacyXMLCert, and REV_INFO v2.
+*/
+#define MAX_REVLIST_INFO    4
+
+/*
+** Structure that stores the version information of
+** a particular revocation list.
+*/
+typedef struct
+{
+    const DRM_GUID *m_poGUID;
+
+    DRM_DWORD m_dwVersion;
+} _REVLIST_INFO;
+
+/*
+** Structure that encapsulates the all the information
+** needed for the license acquisition challenge XML.
+** When the structure is first created, it should be
+** zeroed to have all of its member fields initialized.
+*/
+typedef struct
+{
+    /* The content header. */
+    DRM_CONST_STRING m_dstrContentHeader;
+
+    /* Total number of rights ( actions ). */
+    DRM_DWORD m_cRights;
+
+    /* The client's current secure system time */
+    DRM_DWORD m_dwClientTime;
+
+    /*
+    ** An array of DRM string pointer that
+    ** defines a set of rights ( actions ).
+    */
+    const DRM_CONST_STRING **m_ppdstrRights;
+
+    /* An array of revocation version information. */
+    _REVLIST_INFO m_rgoRevListInfo[ MAX_REVLIST_INFO ];
+
+    /* Size ( number of characters ) of a device certificate. */
+    DRM_DWORD m_cchDeviceCert;
+
+    /*
+    ** Size ( number of characters ) of a collection of domain
+    ** certificates to be passed to the server. Please note
+    ** it includes the intermediate <CertificateChain>
+    ** tags that separate neighboring domain certificates.
+    */
+    DRM_DWORD m_cchDomainCerts;
+
+    /* The custom data string to be sent to the server. */
+    DRM_ANSI_CONST_STRING m_dastrCustomData;
+
+    /*
+    ** Service ID extracted from the content header. Only those
+    ** domain certificates that match the service ID will
+    ** be incorporated into the challenge. This field is used
+    ** only for domain bound content.
+    */
+    DRM_GUID m_oServiceID;
+
+    /*
+    ** Stack allocator used for getting temporary buffers.
+    ** User should initialize with a buffer that is big enough.
+    */
+    DRM_STACK_ALLOCATOR_CONTEXT m_oStackAllocatorContext;
+
+    /*
+    ** Key information used for XML encryption/signature.
+    ** User should call DRM_SOAPXML_InitXMLKey() to initialize.
+    */
+    DRM_XML_KEY m_oXMLKey;
+
+    /* Pointer to a domain store context. */
+    DRM_DOMAINSTORE_CONTEXT *m_poDomainStoreContext;
+
+    /* Pointer to an OEM specific context. */
+    DRM_VOID *m_poOEMContext;
+
+    /* Nonce associated with the challenge. */
+    DRM_ID m_oNonce;
+
+    /* Pointer to a secure core context. */
+    DRM_SECURECORE_CONTEXT *pSecureCoreCtx;
+} DRM_LICCHLG_CONTEXT_V3;
+
+PREFAST_PUSH_DISABLE_EXPLAINED( __WARNING_POOR_DATA_ALIGNMENT_25021, "Ignore poor data alignment that occurs due to making structures human-readable" )
+
+typedef struct
+{
+    /* Pointer to a license evaluation context. */
+    DRM_LICEVAL_CONTEXT *m_poLicEvalContext;
+
+    /* Pointer to a license store context. */
+    DRM_LICSTORE_CONTEXT *m_poLicStoreContext;
+
+    /* Pointer to a data store context. */
+    DRM_DST  *m_poDatastore;
+
+    /* Pointer to a license buffer. */
+    DRM_BYTE *m_pbLicenseBuffer;
+
+    /* Size of license buffer (in bytes). */
+    DRM_DWORD m_cbLicenseBufferSize;
+
+    /* Pointer to a secure core context. */
+    DRM_SECURECORE_CONTEXT *pSecureCoreCtx;
+
+    /* Pointer to a global secure store context. */
+    DRM_SECSTORE_CONTEXT *m_poSecStoreGlobalContext;
+
+    /* Pointer to a revocation store context. */
+    DRM_REVOCATIONSTORE_CONTEXT *m_poRevStoreContext;
+
+    /* Pointer to a revocation data buffer */
+    DRM_BYTE *m_pbRevocationBuffer;
+
+    /* Size (in bytes) of revocation data buffer */
+    DRM_DWORD m_cbRevocationBuffer;
+
+    /* Pointer to a nonce store context. */
+    DRM_NONCESTORE_CONTEXT *m_poNonceStoreContext;
+
+    /* License response flag */
+    DRM_PROCESS_LIC_RESPONSE_FLAG m_eLicResponseFlag;
+
+} DRM_LICRESP_CONTEXT_V3;
+
+PREFAST_POP /* __WARNING_POOR_DATA_ALIGNMENT_25021 */
+
+/* Define the maximum size in bytes of a transaction ID. */
+#define DRM_MAX_TRANSACTION_ID  100
+
+/*
+** Defines the maximum number of licenses can be contained
+** in a single license response.
+*/
+#define DRM_MAX_LICENSE_ACK     20
+
+/*
+** Structure that is used to store the result of
+** license processing and storage.
+*/
+typedef struct
+{
+    /* KID of the license. */
+    DRM_KID m_oKID;
+
+    /* LID of the license. */
+    DRM_LID m_oLID;
+
+    /* DRM result code of the processing and storage. */
+    DRM_RESULT m_dwResult;
+
+    /* Flag specifying post-processing behavior. */
+    DRM_DWORD m_dwFlags;
+
+} DRM_LICENSE_ACK;
+
+/* Values for m_dwFlags */
+#define DRM_LICENSE_ACK_FLAGS_EMBED 1
+
+
+/* Enumeration of license protocols. */
+typedef enum __tag_DRM_LICENSE_PROTOCOL_TYPE
+{
+    /* Unrecognized protocol. */
+    eUnknownProtocol = 0,
+
+    /* V2 protocol. */
+    eV2Protocol,
+
+    /* V3 protocol. */
+    eV3Protocol
+
+} DRM_LICENSE_PROTOCOL_TYPE;
+
+/* Structure that encapsulates the license processing result. */
+typedef struct
+{
+    /* __inout  Type of license protocol detected. */
+    DRM_LICENSE_PROTOCOL_TYPE m_eType;
+
+    /* __out    Buffer to store the transaction ID. */
+    DRM_BYTE m_rgbTransactionID[ DRM_MAX_TRANSACTION_ID ];
+
+    /*
+    ** __out    Actual size in bytes of the transaction ID.
+    **          Should <= DRM_MAX_TRANSACTION_ID.
+    */
+    DRM_DWORD m_cbTransactionID;
+
+    /*
+    ** __out    Array that contains license processing storage results.
+    **          Not used if m_cMaxAcks > zero.  Refer to m_pAcks.
+    */
+    DRM_LICENSE_ACK m_rgoAcks[ DRM_MAX_LICENSE_ACK ];
+
+    /*
+    ** __inout  Pointer to a caller-allocated array that
+    **          contains license processing storage results.
+    **          Required if the number of licenses > DRM_MAX_LICENSE_ACK.
+    **          If NULL, m_rgoAcks is used.
+    **          Must be NULL or a valid pointer.
+    **          Must be a valid pointer if m_cMaxAcks is non-zero.
+    **          Must be NULL if m_cMaxAcks is zero.
+    */
+    DRM_LICENSE_ACK *m_pAcks;
+
+    /*
+    ** __in     Number of elements in m_pAcks.
+    **          Must be zero if m_pAcks is NULL.
+    **          Must be non-zero if m_pAcks is non-NULL.
+    */
+    DRM_DWORD m_cMaxAcks;
+
+    /*
+    ** __out    Actual number of initialized elements in m_rgoAcks or m_pAcks.
+    **          Will be <= DRM_MAX_LICENSE_ACK if m_pAcks is NULL.
+    **          Will be <= m_cMaxAcks if m_pAcks is non-NULL.
+    **          If Drm_LicenseAcq_ProcessResponse succeeds OR it fails
+    **          with DRM_E_LICACQ_TOO_MANY_LICENSES,
+    **          then on output this member will be set to the number of
+    **          licenses in the response (and can be arbitrarily large).
+    **          In the failure case, this enables the caller to allocate
+    **          a sufficiently large array, assign correct values to
+    **          m_pAcks and m_cMaxAcks, and re-call
+    **          Drm_LicenseAcq_ProcessResponse.
+    */
+    DRM_DWORD m_cAcks;
+
+    /*
+    ** __out    The LA session ID associated with licenses extracted from the response.
+    **          Will be filled only in case of In-memory only licenses.
+    **          Value can be passed later to Drm_StoreMgmt_DeleteInMemoryLicenses
+    **          to remove the associated licenses from the in memory license store
+    **          and for calls to Secure Stop functions.
+    **          Note: Previous PlayReady versions named this "batch ID".
+    */
+    DRM_ID m_idSession;
+
+    /*
+    ** __out    TRUE if this license response has licenses with secure stop.
+    **          FALSE otherwise.
+    */
+    DRM_BOOL   m_fHasSecureStop;
+
+    /*
+    ** __out    TRUE if this license response has persistent licenses.
+    **          FALSE otherwise.
+    */
+    DRM_BOOL   m_fHasPersistentLicenses;
+
+    /* __out    Status code parsed from the server response. */
+    DRM_RESULT m_dwResult;
+
+} DRM_LICENSE_RESPONSE;
+
+/*
+** Internal functions but are called from other files.
+*/
+DRM_API DRM_RESULT DRM_CALL DRM_LA_ParseServiceID(
+    __in  const DRM_CONST_STRING *f_pdstrContentHeader,
+    __out       DRM_GUID         *f_pServiceID );
+
+DRM_API DRM_RESULT DRM_CALL DRM_LA_ParseLicenseAcquisitionURL(
+    __in                     const DRM_CONST_STRING *f_pdstrContentHeader,
+    __in                           DRM_BOOL          f_fSilent,
+    __out_ecount_opt( *f_pcchURL ) DRM_CHAR         *f_pchURL,
+    __inout                        DRM_DWORD        *f_pcchURL );
+
+DRM_API DRM_RESULT DRM_CALL DRM_LA_GenerateChallengeV3(
+    __in                                DRM_LICCHLG_CONTEXT_V3 *f_poLicChlgContext,
+    __out_bcount_opt( *f_pcbChallenge ) DRM_BYTE               *f_pbChallenge,
+    __inout                             DRM_DWORD              *f_pcbChallenge,
+    __in_ecount( 1 )              const PUBKEY_P256            *f_poECC256PubKey );
+
+DRM_API DRM_RESULT DRM_CALL DRM_LA_CheckForCustomData(
+    __in_bcount( f_cbResponse ) const DRM_BYTE *f_pbResponse,
+    __in                              DRM_DWORD f_cbResponse );
+
+DRM_API DRM_RESULT DRM_CALL DRM_LA_ProcessResponseV3(
+    __inout                                         DRM_APP_CONTEXT          *f_poAppContext,
+    __in                                            DRM_LICRESP_CONTEXT_V3   *f_poLicRespContext,
+    __in                                            DRM_ANSI_CONST_STRING    *f_pdastrResponse,
+    __inout                                         DRM_LICENSE_RESPONSE     *f_poLicenseResponse,
+    __out_ecount_part( *f_pcLicAcks, *f_pcLicAcks ) DRM_LICENSE_ACK          *f_poLicAcks,
+    __inout                                         DRM_DWORD                *f_pcLicAcks );
+
+DRM_API DRM_RESULT DRM_CALL DRM_LA_GenerateAckV3(
+    __in_opt                            DRM_VOID                    *f_poOEMContext,
+    __inout                             DRM_SECURECORE_CONTEXT      *f_pSecureCoreCtx,
+    __in                                DRM_STACK_ALLOCATOR_CONTEXT *f_poStackAllocatorContext,
+    __in                                DRM_LICENSE_RESPONSE        *f_poLicenseResponse,
+    __out_bcount_opt( *f_pcbChallenge ) DRM_BYTE                    *f_pbChallenge,
+    __inout                             DRM_DWORD                   *f_pcbChallenge,
+    __in_ecount( 1 )              const PUBKEY_P256                 *f_poECC256PubKey);
+
+DRM_API DRM_RESULT DRM_CALL DRM_LA_ValidateResponseId(
+    __in_bcount( f_cbResponse )   const DRM_BYTE               *f_pbResponse,
+    __in                          const DRM_DWORD               f_cbResponse,
+    __in_bcount( f_cbDeviceId )   const DRM_BYTE               *f_pbDeviceId,
+    __in                          const DRM_DWORD               f_cbDeviceId,
+    __out_opt                           DRM_ID                 *f_pidNonce );
+
+EXIT_PK_NAMESPACE;
+
+#endif /* __DRM_LICACQ_V3_H */
+
diff --git a/prebuilt-v4.4/noarch/include/drmlicacqv3constants.h b/prebuilt-v4.4/noarch/include/drmlicacqv3constants.h
new file mode 100644
index 0000000..cc23206
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmlicacqv3constants.h
@@ -0,0 +1,212 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __DRM_LICACQ_V3_CONSTANTS_H
+#define __DRM_LICACQ_V3_CONSTANTS_H
+
+ENTER_PK_NAMESPACE;
+
+/*
+** ---------------------------------------------------------
+** XML strings used in the construction of license challenge
+** ---------------------------------------------------------
+*/
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrLicAcqRootTag;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrLicAcqVersionTag;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrLicAcqChallenge1Tag;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrLicAcqChallenge2Tag;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrLicAcqLATag;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrLicAcqContentHeaderTag;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrLicAcqSecurityVersionTag;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrLicAcqAppSecurityTag;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrLicAcqSubjectID1Tag;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrLicAcqSubjectID2Tag;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrLicAcqDRMKVersionTag;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrLicAcqRevocationListsTag;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrLicAcqRevListInfoTag;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrLicAcqRevListIDTag;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrLicAcqRevVersionTag;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrLicAcqCertificateChainsTag;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrLicAcqCertificateChainTag;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrLicAcqFeaturesTag;
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrLicAcqFeatureTag;
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrLicAcqFeatureAttribName;
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrLicAcqFeatureAttribNameValueAESCBC;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrLicAcqDataTag;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrLicAcqUplinksTag;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrLicAcqUplinkTag;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrLicAcqKIDTag;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrLicAcqCategoryTag;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrLicAcqCountTag;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrLicAcqDateTag;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrLicAcqVagueTag;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrLicAcqCustomDataTag;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrLicAcqLicenseNonceTag;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrLicAcqClientTimeTag;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrLicAcqRootAttribName;
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrLicAcqRootAttribValue;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrLicAcqChallenge2AttribName;
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrLicAcqChallenge2AttribValue;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrLicAcqChallengeVAAttrib1Name;
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrLicAcqChallengeVAAttrib1Value;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrLicAcqChallengeVAAttrib2Name;
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrLicAcqChallengeVAAttrib2Value;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrLicAcqVersion1Value;
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrLicAcqVersion4Value;
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrLicAcqVersion5Value;
+
+
+/*
+** ---------------------------------------------------------------
+** XML strings used in the construction of license acknowledgement
+** ---------------------------------------------------------------
+*/
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrLicAckRootTag;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrLicAckVersionTag;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrLicAckChallenge1Tag;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrLicAckChallenge2Tag;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrLicAckAckTag;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrLicAckDataTag;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrLicAckTransactionIDTag;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrLicAckLicenseStorageResultsTag;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrLicAckLicenseTag;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrLicAckKIDTag;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrLicAckLIDTag;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrLicAckResultTag;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrLicAckCertificateChainTag;
+
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrLicAckRootAttribName;
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrLicAckRootAttribValue;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrLicAckChallenge2AttribName;
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrLicAckChallenge2AttribValue;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrLicAckAckAttrib1Name;
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrLicAckAckAttrib1Value;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrLicAckAckAttrib2Name;
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrLicAckAckAttrib2Value;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrLicAckVersionValue;
+
+
+/*
+** -----------------------------------------------------
+** XML strings used in the construction of SOAP envelope
+** -----------------------------------------------------
+*/
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrXMLRootTag;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrSOAPEnvelopeTag;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrSOAPBodyTag;
+
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrSOAPEnvelopeAttrib1Name;
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrSOAPEnvelopeAttrib1Value;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrSOAPEnvelopeAttrib2Name;
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrSOAPEnvelopeAttrib2Value;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrSOAPEnvelopeAttrib3Name;
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrSOAPEnvelopeAttrib3Value;
+
+
+/*
+** ---------------------------------------------------
+** XML strings used in the parsing of license response
+** ---------------------------------------------------
+*/
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrLicLicensesPath;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrLicLicensePath;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrAcquireLicenseResultTag;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrLicRevInfoPath;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrRevInfo;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrLicRevocationPath;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrLicTransactionIDPath;
+/*
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrLicRevocationAttribName;
+*/
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrLicSLKPath;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrLicRevocationAttribName;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrLicListIdPath;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrLicListDataPath;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrLicNoncePath;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrLicResponseIdPath;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrLicSigningCertPath;
+
+
+/*
+** ---------------------------------------------------------------
+** XML strings used in the parsing of license acknowledge response
+** ---------------------------------------------------------------
+*/
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrAcquireLicenseResponseTag;
+
+
+EXIT_PK_NAMESPACE;
+
+#endif /* __DRM_LICACQ_V3_CONSTANTS_H */
diff --git a/prebuilt-v4.4/noarch/include/drmlicense.h b/prebuilt-v4.4/noarch/include/drmlicense.h
new file mode 100644
index 0000000..f18949a
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmlicense.h
@@ -0,0 +1,41 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+
+#ifndef __DRMLICENSE_H__
+#define __DRMLICENSE_H__
+
+#include <drmtypes.h>
+#include <oemcryptoctx.h>
+
+ENTER_PK_NAMESPACE;
+
+#define DRM_MAX_LICENSESIZE           36864                        /* 36 * 1024 == 36K max license size */
+#define MAX_DEVICE_CERT_SIZE          36864                        /* 36 * 1024 == 36K max device cert size */
+#define MAX_DEVICE_CERT_TEMPLATE_SIZE ( ( MAX_DEVICE_CERT_SIZE * 6 ) / 10 )/* 60% of max devcert */
+
+#define DRM_AES_CK_CHECKSUM_LENGTH 8
+
+#define LEGACY_KID_B64ENC_LEN   24
+#define DRM_MAX_CHECKSUM        DRM_MAX( DRM_MAX( CHECKSUM_LENGTH, LEGACY_KID_B64ENC_LEN ), DRM_AES_CK_CHECKSUM_LENGTH )
+
+typedef struct __tagDRM_V1Header
+{
+    DRM_BYTE  *pbKeyID;
+    DRM_DWORD  cbKeyID;
+    DRM_BYTE  *pbSecretData;
+    DRM_DWORD  cbSecretData;
+    DRM_BYTE  *pbURL;
+    DRM_DWORD  cbURL;
+    DRM_BYTE   bBuffer[1];
+} DRM_V1Header;
+
+EXIT_PK_NAMESPACE;
+
+#endif /* __DRMLICENSE_H__ */
+
diff --git a/prebuilt-v4.4/noarch/include/drmliceval.h b/prebuilt-v4.4/noarch/include/drmliceval.h
new file mode 100644
index 0000000..405ea33
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmliceval.h
@@ -0,0 +1,62 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __DRMLICEVAL_H__
+#define __DRMLICEVAL_H__
+
+#include <drmsecurestoretypes.h>
+#include <drmxmrformatparser.h>
+#include <drmcallbacks.h>
+#include <drmlicevaltypes.h>
+
+ENTER_PK_NAMESPACE;
+
+DRM_API DRM_RESULT DRM_CALL DRM_LEVL_SearchQualifierGuidInEnablerContainer(
+    __in        DRM_GUID const                    *f_pdguidActionQualifier,
+    __in        DRM_XB_UNKNOWN_CONTAINER const   *f_pEnablerContainer,
+    __in        DRM_WORD const                     f_wContainerType,
+    __in        DRM_WORD const                     f_wObjectType,
+    __inout     DRM_BOOL                          *f_pfFound,
+    __inout_opt DRM_XB_UNKNOWN_CONTAINER const  **f_ppEnablerContainerFound ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_API DRM_RESULT DRM_CALL DRM_LEVL_PerformOperations(
+    __inout         DRM_LICEVAL_CONTEXT          *f_pContextLicEval,
+    __in            eDRM_LICEVAL_OPERATIONS       f_eOperation,
+    __in            eDRM_LICEVAL_OPERATION_STATE  f_eOperationState,
+    __in_opt  const DRM_CONST_STRING             *f_pdstrAction,
+    __out_opt       DRM_BOOL                     *f_pfPerform,
+    __out_opt       DRM_BOOL                     *f_pfActionExisted,
+    __in      const DRM_DST                      *f_pDatastore,
+    __in_opt        DRMPFNPOLICYCALLBACK          f_pfnPolicyCallback,
+    __in_opt  const DRM_VOID                     *f_pv ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_API DRM_RESULT DRM_CALL DRM_LEVL_PerformOperationsXMR(
+    __inout     DRM_LICEVAL_CONTEXT          *f_pContextLicEval,
+    __in        eDRM_LICEVAL_OPERATIONS       f_eOperation,
+    __in        eDRM_LICEVAL_OPERATION_STATE  f_eOperationState,
+    __in_opt    DRM_GUID const               *f_pdguidAction,
+    __in_opt    DRM_GUID const               *f_pdguidActionQualifier,
+    __in        DRM_DWORD const               f_dwRightID,
+    __out_opt   DRM_BOOL                     *f_pfPerform,
+    __out_opt   DRM_BOOL                     *f_pfActionExisted,
+    __in        DRM_DST const                *f_pDatastore,
+    __in_opt    DRMPFNPOLICYCALLBACK          f_pfnPolicyCallback,
+    __in_opt    DRM_VOID const               *f_pv ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_API DRM_RESULT DRM_CALL DRM_LEVL_IsLicenseReadyForDeletion(
+    __inout DRM_LICEVAL_CONTEXT *f_pContextLicEval,
+    __out   DRM_BOOL            *f_pfDelete ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_LEVL_GetMachineDatetime(
+    __inout     DRM_LICEVAL_CONTEXT *f_pContextLicEval,
+    __out       DRM_UINT64          *f_pui64MachineDateTime ) DRM_NO_INLINE_ATTRIBUTE;
+
+EXIT_PK_NAMESPACE;
+
+#endif /* __DRMLICEVAL_H__ */
+
diff --git a/prebuilt-v4.4/noarch/include/drmlicevaltypes.h b/prebuilt-v4.4/noarch/include/drmlicevaltypes.h
new file mode 100644
index 0000000..53be0cd
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmlicevaltypes.h
@@ -0,0 +1,150 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __DRMLICEVALTYPES_H__
+#define __DRMLICEVALTYPES_H__
+
+#include <drmrevocationstore.h>
+#include <drmmetercertstore.h>
+#include <drmlicense.h>
+#include <drmsecurecoretypes.h>
+#include <drmxmrformattypes.h>
+
+ENTER_PK_NAMESPACE;
+
+#define DRM_MAX_ACTIONS 10
+
+/*
+** Flags for use with SetLicense method
+*/
+enum
+{
+    LICEVAL_VERIFY_CERT_WITH_EXPIRYCHECK    = 1,
+    LICEVAL_VERIFY_CERT_WITHOUT_EXPIRYCHECK = 2,
+    LICEVAL_VERIFY_SIGNATURE                = 4,
+    LICEVAL_VERIFY_IGNORE_VERIFICATION      = 8,
+    LICEVAL_IGNORE_SECURESTORE_ENTRY        = 16,
+};
+
+#define LICEVAL_STORE_CHECK_SETTINGS ( LICEVAL_VERIFY_CERT_WITH_EXPIRYCHECK | LICEVAL_VERIFY_SIGNATURE )
+#define LICEVAL_OPEN_CHECK_SETTINGS  ( LICEVAL_VERIFY_CERT_WITHOUT_EXPIRYCHECK | LICEVAL_VERIFY_SIGNATURE )
+
+typedef struct __tagDRM_APPCERT_INFO
+{
+    DRM_DWORD appSec;
+    DRM_DWORD appcd_subject;
+} DRM_APPCERT_INFO;
+
+typedef enum __tag_eDRM_LICEVAL_TIMEBASED_STATE
+{
+    LICEVAL_NOREFERENECE                 = 0,
+    LICEVAL_MACHINEDATETIMEREFERENCED    = 1
+} eDRM_LICEVAL_TIMEBASED_STATE;
+
+/*
+**  Current revocation list values should be placed in this struct and passed to CompleteChain
+**  so licenses can be compared against these values.  This struct is only stored in memory.
+*/
+typedef struct __tagDRM_REVLIST_ID_VALUES
+{
+    DRM_BOOL   fUpdatedRevocationList;
+    DRM_DWORD  playreadyapp;
+    DRM_DWORD  device;
+    DRM_DWORD  legacyxmlcert;
+    DRM_DWORD  runtime;
+    DRM_DWORD  riv;
+    DRM_DWORD  riv2;
+} DRM_REVLIST_ID_VALUES;
+
+typedef struct __tagDRM_LICEVAL_CONTEXT
+{
+    DRM_SECURECORE_CONTEXT       *pSecureCoreCtx;
+    DRM_CONST_STRING              dstrContentHeader;
+    DRM_CONST_STRING              dstrDRMVer;
+    DRM_SECSTORE_CONTEXT         *pcontextSSTLicense;
+    DRM_SECSTORE_CONTEXT         *pcontextSSTGlobal;
+    DRM_SECSTORE_CONTEXT         *pcontextSSTRevocation;
+    DRM_APPCERT_INFO              certinfoSDK;
+    DRM_BOOL                      fAppInfoValid;
+    DRM_APPCERT_INFO              certinfoApp;
+    DRM_DWORD                     dwChainDepth;
+    DRM_BOOL                      fDeviceRegistered;      /* TRUE if the device is registered */
+    DRM_LID                       LID;
+    DRM_KID                       KID;
+    DRM_BOOL                      fGlobalSecStoreWritable;
+    DRM_LONG                      lReasonForFail;
+    DRM_DWORD                     dwFlags;                /* Default as this LICEVAL_OPEN_CHECK_SETTINGS */
+    DRM_BOOL                      fReserved;              /* Must be initialized to 0 */
+    DRM_BOOL                      fSSecureTimeDataLoaded; /* Indicates whether we've already attempted to load the proceeding values */
+    DRM_BOOL                      fSecureTimeDataValid;   /* Is secure time data valid. Must be initialized to 0 */
+    DRM_UINT64                    u64GPStartTime;         /* Grace period duration */
+    DRM_DST                      *pDatastore;
+    DRM_DST                      *pDSTContextMemSST;
+    DRM_BOOL                      fIgnoreTimeBoundLicense;
+    eDRM_LICEVAL_TIMEBASED_STATE  eTimeBasedState;
+    DRM_BYTE                     *pbRevocationBuffer;     /* User gives a point to work in.  This is actually going to be used for revocation from the secure store */
+    DRM_DWORD                     cbRevocationBuffer;     /* Size of the user supplied pointer */
+    DRM_REVLIST_ID_VALUES         idCRLsCurrent;
+    DRM_REVOCATIONSTORE_CONTEXT  *pContextRev;
+    DRM_METERCERT_CONTEXT        *pcontextMeterCert;
+    DRM_ID                        idSecureStop;
+    DRM_DOMAINSTORE_CONTEXT      *pDomainStoreContext;
+    DRM_XMRFORMAT                *plicenseXMR;
+    DRM_DWORD                     rgdwAllowedSourceIDs[XMR_SOURCEID_MAXCOUNT];
+    DRM_DWORD                     cAllowedSourceIDs;
+    DRM_BOOL                      fAllowAllSourceIDs;
+    DRM_BOOL                      fLicenseFromHDS;
+
+    /*
+    ** OUT: When evaluating the Copy right, if the license is domain bound without
+    **  an explicit copy right, but is not bound to any of the domains given
+    **  (or no domains were given), the evaluation will fail because copy isn't allowed,
+    **  but fCopyDestDomainAccountIDRequired will be set to TRUE and the associated data
+    **  will indicate to the caller which domain the copy destination must join
+    **  in order for the copy to be allowed.
+    */
+    DRM_BOOL                      fCopyDestDomainAccountIDRequired;
+    DRM_GUID                      guidCopyDestDomainAccountIDRequired;
+    DRM_DWORD                     dwCopyDestDomainRevisionRequired;
+
+    /*
+    ** OUT: When evaluating the Copy right, if the license is a LEAF license,
+    **  and the license does not have the Copy right, then evaluation will
+    **  still succeed and this value will get set to TRUE.
+    ** It is then the caller's responsibility to validate that this license
+    **  chains up to a valid domain-bound root license before allowing Copy
+    **  to succeed.
+    ** This applies to the Copy right by itself as well as the Copy right
+    **  with either the Copy To PC or Copy To Device action qualifier.
+    ** This does NOT apply to the Copy right with any other action qualifier.
+    */
+    DRM_BOOL                      fDomainBoundRootRequired;
+
+    DRM_UINT64                    ui64RealTimeExpiration;
+    DRM_UINT64                    ui64RealTimeExpirationTicsAfterFirstPlay;
+} DRM_LICEVAL_CONTEXT;
+
+typedef enum __tag_eDRM_LICEVAL_OPERATIONS
+{
+    DRM_LICENSE_EVAL_SELECT               = 1,
+    DRM_LICENSE_EVAL_DELETE               = 2,
+    DRM_LICENSE_EVAL_STORE                = 3,
+    DRM_LICENSE_EVAL_REPORTCLOCK_ROLLBACK = 4, /* Only use DRM_LICENSE_EVAL_DONE_WITH_OPERATION for clock rollback. */
+    DRM_LICENSE_EVAL_ACTION               = 5  /* With ACTION you must provide an action string */
+} eDRM_LICEVAL_OPERATIONS;
+
+typedef enum __tag_eDRM_LICEVAL_OPERATION_STATE
+{
+    DRM_LICENSE_EVAL_CAN_DO_OPERATION    = 1,
+    DRM_LICENSE_EVAL_DONE_WITH_OPERATION = 2
+} eDRM_LICEVAL_OPERATION_STATE;
+
+EXIT_PK_NAMESPACE;
+
+#endif /* __DRMLICEVALTYPES_H__ */
+
diff --git a/prebuilt-v4.4/noarch/include/drmlicgen.h b/prebuilt-v4.4/noarch/include/drmlicgen.h
new file mode 100644
index 0000000..5738c58
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmlicgen.h
@@ -0,0 +1,49 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __DRMLICGEN_H_
+#define __DRMLICGEN_H_ 1
+
+#include <drmmanagertypes.h>
+#include <drmxmrformatbuilder.h>
+#include <drmlicgentypes.h>
+#include <drmmodulesupport.h>
+
+ENTER_PK_NAMESPACE;
+
+PREFAST_PUSH_DISABLE_EXPLAINED( __WARNING_POOR_DATA_ALIGNMENT_25021, "Ignore poor data alignment that occurs due to making structures human-readable" )
+
+typedef struct __tagDRM_LOCAL_LICENSE_SESSION_CONTEXT
+{
+    DRM_APP_CONTEXT                     *poAppContext;
+
+    OEM_CRYPTO_HANDLE                    handleCICK;
+    DRM_VOID                            *pOpaqueHandleEncryption;
+
+    DRM_TEE_BYTE_BLOB                    oCEKB;
+
+    DRM_KID                              kid;
+    DRM_LID                              lid;
+
+    DRM_DWORD                            cbXMRLicense;
+    DRM_BYTE                            *pbXMRLicense;
+
+    DRM_DWORD                            dwRefCount;
+    DRM_BOOL                             fCannotPersist;
+    DRM_LOCAL_LICENSE_TYPE               eLicenseType;
+} DRM_LOCAL_LICENSE_SESSION_CONTEXT;
+
+PREFAST_POP /* __WARNING_POOR_DATA_ALIGNMENT_25021 */
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_LOCALLICENSE_CleanCache(
+    __inout                             DRM_APP_CONTEXT                     *f_poAppContext ) DRM_NO_INLINE_ATTRIBUTE;
+
+EXIT_PK_NAMESPACE;
+
+#endif /* __DRMLICGEN_H_ */
+
diff --git a/prebuilt-v4.4/noarch/include/drmlicgentypes.h b/prebuilt-v4.4/noarch/include/drmlicgentypes.h
new file mode 100644
index 0000000..9bcc904
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmlicgentypes.h
@@ -0,0 +1,131 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __DRMLICGENTYPES_H_
+#define __DRMLICGENTYPES_H_ 1
+
+#include <oemcommon.h>
+#include <oemaescommon.h>
+#include <oemeccp256.h>
+#include <drmxmrformattypes.h>
+
+ENTER_PK_NAMESPACE;
+
+typedef DRM_VOID *DRM_LICENSE_HANDLE;
+#define DRM_LICENSE_HANDLE_INVALID   ((DRM_LICENSE_HANDLE)NULL)
+
+#define DRM_MAX_LOCAL_LICENSE_EXPLICIT_OUTPUT_PROTECTIONS            10
+#define DRM_MAX_LOCAL_LICENSE_EXPLICIT_OUTPUT_PROTECTION_CONFIG_DATA 32
+#define DRM_MAX_LOCAL_LICENSE_PLAY_ENABLERS                          10
+#define DRM_MAX_LOCAL_LICENSE_CACHE_TIME_IN_SECONDS                  18000   /* 5 hours */
+
+#define DRM_LOCAL_LICENSE_MINIMUM_PROTECTION_LEVEL                   0
+
+#define DRM_LOCAL_LICENSE_EXPIRATION_MIN_BEGIN_DATE                  0
+#define DRM_LOCAL_LICENSE_INFINITE_EXPIRATION                        DRM_MAX_UNSIGNED_TYPE( DRM_DWORD )
+
+typedef enum __tag_DRM_LOCAL_LICENSE_TYPE
+{
+    eDRM_LOCAL_LICENSE_LOCAL_BOUND_SIMPLE,
+    eDRM_LOCAL_LICENSE_LOCAL_BOUND_ROOT,
+    eDRM_LOCAL_LICENSE_LEAF
+} DRM_LOCAL_LICENSE_TYPE;
+
+typedef enum __tag_DRM_LOCAL_LICENSE_STORE
+{
+    eDRM_LOCAL_LICENSE_XMR_STORE,
+} DRM_LOCAL_LICENSE_STORE;
+
+typedef struct __tagDRM_LOCAL_LICENSE_EXPIRATION
+{
+    DRM_BOOL                                      fValid;
+    DRM_DWORD                                     dwBeginDate;
+    DRM_DWORD                                     dwEndDate;
+} DRM_LOCAL_LICENSE_EXPIRATION;
+
+typedef struct __tagDRM_LOCAL_LICENSE_EXPIRATION_AFTER_FIRST_PLAY
+{
+    DRM_BOOL                                      fValid;
+    DRM_DWORD                                     dwValue;
+    DRM_DWORD                                     dwComputedEndDate;    /* Only set as output via Drm_License_GetProperty */
+} DRM_LOCAL_LICENSE_EXPIRATION_AFTER_FIRST_PLAY;
+
+typedef struct __tagDRM_LOCAL_LICENSE_SOURCE_ID
+{
+    DRM_BOOL                                      fValid;
+    DRM_DWORD                                     dwSourceId;
+    DRM_BOOL                                      fRestrictedSourceId;
+} DRM_LOCAL_LICENSE_SOURCE_ID;
+
+typedef struct __tagDRM_LOCAL_LICENSE_EXPLICIT_OUTPUT_PROTECTION
+{
+    DRM_GUID                                      oProtectionId;
+    DRM_WORD                                      cbConfigData;
+    DRM_BYTE                                      rgbConfigData[ DRM_MAX_LOCAL_LICENSE_EXPLICIT_OUTPUT_PROTECTION_CONFIG_DATA];
+} DRM_LOCAL_LICENSE_EXPLICIT_OUTPUT_PROTECTION;
+
+/* Analog Video, Digital Audio, Digital Video */
+#define DRM_LOCAL_LICENSE_EXPLICIT_PROTECTION_TYPE_COUNT 3
+
+PREFAST_PUSH_DISABLE_EXPLAINED( __WARNING_POOR_DATA_ALIGNMENT_25021, "Ignore poor data alignment that occurs due to making structures human-readable" )
+
+typedef struct __tagDRM_LOCAL_LICENSE_POLICY_DESCRIPTOR
+{
+    DRM_WORD                                      wSecurityLevel;
+    DRM_BOOL                                      fCannotPersist;
+    DRM_LOCAL_LICENSE_EXPIRATION                  oExpiration;
+    DRM_LOCAL_LICENSE_EXPIRATION_AFTER_FIRST_PLAY oExpirationAfterFirstPlay;
+    DRM_BOOL                                      fRealTimeExpiration;
+    DRM_LOCAL_LICENSE_SOURCE_ID                   oSourceId;
+    DRM_WORD                                      wCompressedDigitalVideo;
+    DRM_WORD                                      wUncompressedDigitalVideo;
+    DRM_WORD                                      wAnalogVideo;
+    DRM_WORD                                      wCompressedDigitalAudio;
+    DRM_WORD                                      wUncompressedDigitalAudio;
+    DRM_WORD                                      cExplicitAnalogVideoOutputProtections;
+    DRM_LOCAL_LICENSE_EXPLICIT_OUTPUT_PROTECTION  rgoExplicitAnalogVideoOutputProtections[ DRM_MAX_LOCAL_LICENSE_EXPLICIT_OUTPUT_PROTECTIONS ];
+    DRM_WORD                                      cExplicitDigitalAudioOutputProtections;
+    DRM_LOCAL_LICENSE_EXPLICIT_OUTPUT_PROTECTION  rgoExplicitDigitalAudioOutputProtections[ DRM_MAX_LOCAL_LICENSE_EXPLICIT_OUTPUT_PROTECTIONS ];
+    DRM_WORD                                      cExplicitDigitalVideoOutputProtections;
+    DRM_LOCAL_LICENSE_EXPLICIT_OUTPUT_PROTECTION  rgoExplicitDigitalVideoOutputProtections[ DRM_MAX_LOCAL_LICENSE_EXPLICIT_OUTPUT_PROTECTIONS ];
+    DRM_WORD                                      cPlayEnablers;
+    DRM_GUID                                      rgoPlayEnablers[ DRM_MAX_LOCAL_LICENSE_PLAY_ENABLERS ];
+} DRM_LOCAL_LICENSE_POLICY_DESCRIPTOR;
+
+PREFAST_POP /* __WARNING_POOR_DATA_ALIGNMENT_25021 */
+
+#define DRM_LOCAL_LICENSE_INITIALIZEPOLICYDESCRIPTOR( pDescriptor ) DRM_DO {    \
+    DRM_LOCAL_LICENSE_POLICY_DESCRIPTOR *__pDescriptor = (pDescriptor);         \
+    OEM_SECURE_ZERO_MEMORY( __pDescriptor, sizeof( *__pDescriptor ) );          \
+    __pDescriptor->wSecurityLevel = 2000;                                       \
+    __pDescriptor->fCannotPersist = TRUE;                                       \
+} DRM_WHILE_FALSE
+
+typedef struct __tagDRM_LOCAL_LICENSE_KEY_CACHE
+{
+    struct __tagDRM_LOCAL_LICENSE_KEY_CACHE *poNextLicenseCache;
+
+    DRM_KID                                  kid;
+    DRM_BOOL                                 fRoot;
+    DRM_BYTE                                 rgbEncryptedAESKeyPair[DRM_AES_BLOCKLEN * 2];
+    DRM_BYTE                                 rgbCICKEncryptedWithPubkey[ECC_P256_CIPHERTEXT_SIZE_IN_BYTES]; /* used on root/simple license */
+    DRM_BYTE                                 rgbCICKEncryptedWithROOTAESECBKey[DRM_AES_BLOCKLEN * 2];       /* used on leaf license */
+    DRMFILETIME                              ftAccessTime;
+} DRM_LOCAL_LICENSE_KEY_CACHE;
+
+typedef struct __tagDRM_LOCAL_LICENSE_CONTEXT
+{
+    OEM_CRYPTO_HANDLE                hAESGenericKeyContent;                       /* Determined on licgen */
+    OEM_CRYPTO_HANDLE                hAESGenericKeyRoot;                          /* Determined on licgen */
+    DRM_LOCAL_LICENSE_KEY_CACHE     *poLicenseKeyCache;
+} DRM_LOCAL_LICENSE_CONTEXT;
+
+EXIT_PK_NAMESPACE;
+
+#endif /* __DRMLICGENTYPES_H_ */
+
diff --git a/prebuilt-v4.4/noarch/include/drmlicreason.h b/prebuilt-v4.4/noarch/include/drmlicreason.h
new file mode 100644
index 0000000..33485e4
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmlicreason.h
@@ -0,0 +1,45 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+
+/* Description: The error codes to indicate the reason why a license is not usable.
+              The error codes are used to give a better feedback to the user.
+              These codes are used in the license to indicate the reason.
+              drm.reason variable is set to this reason.
+*/
+
+#ifndef __LICREASON_H__
+#define __LICREASON_H__
+
+#include <drmnamespace.h>
+
+ENTER_PK_NAMESPACE;
+
+/* Server can help with these values. These are reasons why a license that was just obtained is not usable. */
+enum
+{
+    LR_LICENSE_SUCCESS = 0,     /* MUST be zero so that zero-initialized value is "success" */
+    LR_LICENSE_EXPIRED,
+    LR_LICENSE_NOTENABLED,
+    LR_LICENSE_APPSECLOW,
+    LR_LICENSE_STORE_NOT_ALLOWED,
+    LR_LICENSE_RESTRICTED_SOURCE,
+    LR_LICENSE_SERVER_MAX,
+};
+
+/* Client side detectable reasons */
+enum
+{
+    LR_LICENSE_CLOCK_NOT_SET = LR_LICENSE_SERVER_MAX,   /* MUST not overlap with previous enum */
+    LR_LICENSE_TIME_CHECK_FAILURE,         /* special case for if the current time is before the first use/store time, rollback is detected, etc */
+    LR_LICENSE_EXTENSIBLE_RIGHT_NOT_FOUND
+};
+
+EXIT_PK_NAMESPACE;
+
+#endif /* __LICREASON_H__ */
diff --git a/prebuilt-v4.4/noarch/include/drmlicstore.h b/prebuilt-v4.4/noarch/include/drmlicstore.h
new file mode 100644
index 0000000..c72366e
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmlicstore.h
@@ -0,0 +1,281 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+
+#ifndef __DRM_LICSTORE_H__
+#define __DRM_LICSTORE_H__
+
+#include <drmdatastoretypes.h>
+#include <drmlicevaltypes.h>
+
+ENTER_PK_NAMESPACE;
+
+/*
+** License store context size
+*/
+#define MAX_PRILIC_LIST     10
+
+typedef enum _tageDRM_LICENSE_STORE_TYPE
+{
+    eDRM_LICENSE_STORE_RESERVED1 = 1,   /* backward compat with test code which casts an int to this enum */
+    eDRM_LICENSE_STORE_XMR       = 2
+} eDRM_LICENSE_STORE_TYPE;
+
+/*
+** License store context stucture.
+** This contains the DST namespace context it is using and
+** the local stack info for internal use
+*/
+typedef struct _tagDRM_LICSTORE_CONTEXT
+{
+    DRM_DST_SLOT_CONTEXT       SlotContext;
+    DRM_DST_NAMESPACE_CONTEXT  DstNamespaceContext;
+    DRM_DST                   *pDatastore;
+    DRM_BOOL                   fInited;
+    eDRM_LICENSE_STORE_TYPE    eType;
+} DRM_LICSTORE_CONTEXT;
+
+/*
+** License store modes
+*/
+typedef enum _tageDRM_LICENSE_STORE_MODE
+{
+    /*
+    ** no license found
+    */
+    eDRM_LICENSE_STORE_MODE_NONE                = 0,
+    /*
+    ** a local list of license's KID and LID is loaded for query
+    */
+    eDRM_LICENSE_STORE_MODE_PRIORITIZED         = 1,
+    /*
+    ** enum for licenses matching given KID
+    */
+    eDRM_LICENSE_STORE_MODE_FILTERED            = 2,
+    /*
+    ** enum all licenses
+    */
+    eDRM_LICENSE_STORE_MODE_NATURAL             = 3,
+    /*
+    ** enum licenses matching KID after eDRM_LICENSE_STORE_MODE_PRIORITIZED exhausted
+    */
+    eDRM_LICENSE_STORE_MODE_POST_PRIORITIZED    = 4 ,
+    /*
+    ** enum licenses in reverse priority order
+    */
+    eDRM_LICENSE_STORE_MODE_REVERSE_PRIORITIZED = 5
+} eDRM_LICENSE_STORE_MODE;
+
+/*
+** Prioritized license
+*/
+typedef struct _tagDRM_PRIORITIZED_LICENSE
+{
+    DRM_DWORD         dwPriority;   /* the higher the value, the higher the priority */
+    DRM_LID           LID;
+    DRM_BOOL          fDelete;
+    DRM_DST_SLOT_HINT slotHint;
+} DRM_PRIORITIZED_LICENSE;
+
+/*
+** Prioritized license list
+*/
+typedef struct _tagDRM_PRIORITIZED_LICENSE_LIST
+{
+    DRM_KID                 KID;
+    DRM_DWORD               iNextLicense;
+    DRM_DWORD               cLicenses; /* # of license slot used in the array */
+    DRM_PRIORITIZED_LICENSE rgPrioritizedList[MAX_PRILIC_LIST + 1]; /* one extra for working buffer */
+} DRM_PRIORITIZED_LICENSE_LIST;
+
+/*
+** Non-prioritized license
+*/
+typedef struct _tagDRM_NONPRIORITIZED_LICENSE
+{
+    DRM_BOOL  fCurrIsValid;
+    DRM_KID   CurrKID;
+    DRM_LID   CurrLID;
+} DRM_NONPRIORITIZED_LICENSE;
+
+/*
+** All license list struct for DRM_LICSTOREENUM_CONTEXT
+*/
+typedef struct _tag_DRM_LICSTOREENUM_LICENSE_LIST
+{
+    DRM_PRIORITIZED_LICENSE_LIST  Prioritized;
+    DRM_NONPRIORITIZED_LICENSE    NonPrioritized;
+} DRM_LICSTOREENUM_LICENSE_LIST;
+
+/*
+** License Store enumeration context
+*/
+typedef struct _tag_DRM_LICSTOREENUM_CONTEXT
+{
+    DRM_LICSTORE_CONTEXT    *pLicContext;
+    DRM_DST_ENUM_CONTEXT     DstEnumContext;
+    DRM_DST_SLOT_CONTEXT     SlotContext;
+    DRM_BOOL                 fInited;
+    eDRM_LICENSE_STORE_MODE  eMode;
+    DRM_LICSTOREENUM_LICENSE_LIST List;
+} DRM_LICSTOREENUM_CONTEXT;
+
+/*
+** The maximum number of stores for multiple enumeration
+*/
+#define DRM_LICSTORE_MAX_STORES 4
+
+/*
+** License Store enumeration context for enumeration
+** over multiple stores
+*/
+typedef struct _tag_DRM_LICSTOREENUM_MULTIPLE_CONTEXT
+{
+    DRM_LICSTOREENUM_CONTEXT   rgLicContexts[DRM_LICSTORE_MAX_STORES];
+    DRM_DWORD                  cLicContexts;
+
+    DRM_BOOL                   fInited;
+    eDRM_LICENSE_STORE_MODE    eMode;
+
+    DRM_LICSTOREENUM_CONTEXT  *pCurEnum; /* Pointer to the enumeration context for the next license */
+
+} DRM_LICSTOREENUM_MULTIPLE_CONTEXT;
+
+
+/*
+** API Functions
+*/
+
+DRM_API DRM_RESULT DRM_CALL DRM_LST_Open(
+    __out DRM_LICSTORE_CONTEXT    *f_pLicContext,
+    __in  DRM_DST                 *f_pDatastore,
+    __in  eDRM_LICENSE_STORE_TYPE  f_eLicenseStoreType );
+
+DRM_API DRM_RESULT DRM_CALL DRM_LST_Close(
+    __in DRM_LICSTORE_CONTEXT *f_pLicContext );
+
+DRM_API DRM_RESULT DRM_CALL DRM_LST_AddLicense(
+    __inout                          DRM_LICSTORE_CONTEXT *f_pLicContext,
+    __in                             DRM_DWORD             f_cbLicense,
+    __in_bcount( f_cbLicense )       DRM_BYTE             *f_pbLicense,
+    __in_opt                   const DRM_KID              *f_pKID,
+    __in_opt                   const DRM_LID              *f_pLID,
+    __in                             DRM_DWORD             f_dwPriority );
+
+DRM_API DRM_RESULT DRM_CALL DRM_LST_GetLicense(
+    __in                                    DRM_LICSTORE_CONTEXT *f_pLicContext,
+    __in                              const DRM_KID              *f_pKID,
+    __in                              const DRM_LID              *f_pLID,
+    __in_opt                                DRM_DST_SLOT_HINT    *f_pSlotHint,
+    __out_bcount_opt( *f_pcbLicense )       DRM_BYTE             *f_pbLicense,
+    __inout                                 DRM_DWORD            *f_pcbLicense );
+
+DRM_API DRM_RESULT DRM_CALL DRM_LST_GetLicensePtr(
+    __in                                    DRM_LICSTORE_CONTEXT *f_pLicContext,
+    __in                              const DRM_KID              *f_pKID,
+    __in                              const DRM_LID              *f_pLID,
+    __in_opt                                DRM_DST_SLOT_HINT    *f_pSlotHint,
+    __deref_out_bcount( *f_pcbLicense )     DRM_BYTE            **f_ppbLicense,
+    __out                                   DRM_DWORD            *f_pcbLicense,
+    __out_opt                               DRM_DWORD            *f_pdwPriority );
+
+DRM_API DRM_RESULT DRM_CALL DRM_LST_DeleteLicense(
+    __inout        DRM_LICSTORE_CONTEXT *f_pLicContext,
+    __in     const DRM_KID              *f_pKID,
+    __in     const DRM_LID              *f_pLID,
+    __in_opt       DRM_DST_SLOT_HINT    *f_pSlotHint );
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_LST_DeleteLicenseAndSaveDate(
+    __inout        DRM_LICSTORE_CONTEXT *f_pLicContext,
+    __in     const DRM_KID              *f_pKID,
+    __in     const DRM_LID              *f_pLID,
+    __in_opt       DRM_DST_SLOT_HINT    *f_pSlotHint );
+
+DRM_API DRM_RESULT DRM_CALL DRM_LST_InitEnum(
+    __in            DRM_LICSTORE_CONTEXT     *f_pLicContext,
+    __in_opt  const DRM_KID                  *f_pKID,
+    __in            DRM_BOOL                  f_fPrioritized,
+    __out           DRM_LICSTOREENUM_CONTEXT *f_pLicEnumContext );
+
+DRM_API DRM_RESULT DRM_CALL DRM_LST_InitReverseEnum(
+    __in        DRM_LICSTORE_CONTEXT     *f_pLicContext,
+    __in  const DRM_KID                  *f_pKID,
+    __out       DRM_LICSTOREENUM_CONTEXT *f_pLicEnumContext );
+
+DRM_API DRM_RESULT DRM_CALL DRM_LST_EnumNext(
+    __in      DRM_LICSTOREENUM_CONTEXT *f_pLicEnumContext,
+    __out_opt DRM_KID                 *f_pKID,
+    __out     DRM_LID                 *f_pLID,
+    __out_opt DRM_DST_SLOT_HINT       *f_pSlotHint,
+    __out_opt DRM_DWORD               *f_pcbLicense );
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_LST_EnumDelete( __in DRM_LICSTOREENUM_CONTEXT *f_pLicEnumContext );
+
+DRM_API DRM_RESULT DRM_CALL DRM_LST_EnumDeleteAndSaveDate(
+    __in DRM_LICSTOREENUM_CONTEXT *f_pLicEnumContext );
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_LST_LicCount(
+    __in    DRM_LICSTOREENUM_CONTEXT *f_pLicEnumContext,
+    __out   DRM_DWORD                *f_pcLicenses );
+
+DRM_API DRM_RESULT DRM_CALL DRM_LST_InitEnumMultiple(
+    __in_ecount( f_cLicContexts )       DRM_LICSTORE_CONTEXT              *f_prgbLicContexts[],
+    __in                                DRM_DWORD                          f_cLicContexts,
+    __in_opt                      const DRM_KID                           *f_pKID,
+    __in                                DRM_BOOL                           f_fPrioritized,
+    __out                               DRM_LICSTOREENUM_MULTIPLE_CONTEXT *f_pLicEnumContext );
+
+DRM_API DRM_RESULT DRM_CALL DRM_LST_EnumNextMultiple(
+    __in       DRM_LICSTOREENUM_MULTIPLE_CONTEXT *f_pLicEnumContext,
+    __out_opt  DRM_KID                           *f_pKID,
+    __out      DRM_LID                           *f_pLID,
+    __out_opt  DRM_LICSTORE_CONTEXT             **f_ppLicStore,
+    __out_opt  DRM_DST_SLOT_HINT                 *f_pSlotHint,
+    __out_opt  DRM_DWORD                         *f_pcbLicense );
+
+DRM_API DRM_RESULT DRM_CALL DRM_LST_EnumDeleteMultiple( __in DRM_LICSTOREENUM_MULTIPLE_CONTEXT *f_pLicEnumContext );
+
+/**********************************************************************
+**
+** Function :   pfnStoreCleanupProgress
+**
+** Synopsis :   Callback function to report progress during License
+**              store cleanup
+**
+** Arguments :
+**      [f_pvCallerData]       : Opaque context data provided to DRM_LST_Clean
+**      [f_cLicensesProcessed] : Count of licenses processed
+**      [f_cTotalLicenses]     : Count of total licenses in the store
+**
+** Returns :
+**      DRM_SUCCESS
+**          Success
+**
+**********************************************************************/
+typedef DRM_RESULT ( DRM_CALL *pfnStoreCleanupProgress )(
+    __in  const DRM_VOID    *f_pvCallerData,
+    __in        DRM_DWORD    f_cLicensesProcessed,
+    __in        DRM_DWORD    f_cTotalLicenses );
+
+DRM_API DRM_RESULT DRM_CALL DRM_LST_Clean(
+    __in                        DRM_LICEVAL_CONTEXT       *f_pContextLEVL,
+    __in                        DRM_LICSTORE_CONTEXT      *f_pContextLSTXMR,
+    __in                        DRM_LICSTOREENUM_CONTEXT  *f_pLicStoreEnumContext,
+    __in                        DRM_DWORD                  f_dwFlags,
+    __in_bcount(f_cbBuffer )    DRM_BYTE                  *f_pbBuffer,
+    __in                        DRM_DWORD                  f_cbBuffer,
+    __in_opt              const DRM_VOID                  *f_pvCallerData,
+    __in                        DRM_DWORD                  f_dwCallbackInterval,
+    __in_opt                    pfnStoreCleanupProgress    f_pfnCallback,
+    __in                        DRM_DST                   *f_pDatastore );
+
+EXIT_PK_NAMESPACE;
+
+#endif  /* __DRM_LICSTORE_H__ */
+
+
diff --git a/prebuilt-v4.4/noarch/include/drmmanager.h b/prebuilt-v4.4/noarch/include/drmmanager.h
new file mode 100644
index 0000000..5a656d0
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmmanager.h
@@ -0,0 +1,643 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __DRMMANAGER_H__
+#define __DRMMANAGER_H__
+
+#include <drmrevocationtypes.h>
+#include <drmcontextsizes.h>
+#include <drmenvelope.h>
+#include <drmcallbacks.h>
+#include <drmdomainimp.h>
+#include <drmlicacqv3.h>
+#include <drmmanagertypes.h>
+#include <drmlicgentypes.h>
+#include <drmsecurestoptypes.h>
+#include <drmsecuretimetypes.h>
+
+PREFAST_PUSH_DISABLE_EXPLAINED( __WARNING_NONCONST_BUFFER_PARAM_25033, "Out params can't be const" )
+PREFAST_PUSH_DISABLE_EXPLAINED( __WARNING_NONCONST_PARAM_25004, "Out params can't be const" )
+
+ENTER_PK_NAMESPACE;
+
+DRM_API DRM_RESULT DRM_CALL Drm_Initialize(
+    __in                                    DRM_APP_CONTEXT     *f_poAppContext,
+    __in_opt                                DRM_VOID            *f_pOEMContext,
+    __in_bcount( f_cbOpaqueBuffer )         DRM_BYTE            *f_pbOpaqueBuffer,
+    __in                                    DRM_DWORD            f_cbOpaqueBuffer,
+    __in                              const DRM_CONST_STRING    *f_pdstrDeviceStoreName );
+
+DRM_API DRM_RESULT DRM_CALL Drm_ResizeOpaqueBuffer(
+    __in                                    DRM_APP_CONTEXT     *f_poAppContext,
+    __in_bcount( f_cbOpaqueBuffer )         DRM_BYTE            *f_pbOpaqueBuffer,
+    __in                                    DRM_DWORD            f_cbOpaqueBuffer );
+
+DRM_API DRM_RESULT DRM_CALL Drm_GetOpaqueBuffer(
+    __in                                    DRM_APP_CONTEXT     *f_poAppContext,
+    __deref_out_bcount(*f_pcbOpaqueBuffer)  DRM_BYTE           **f_ppbOpaqueBuffer,
+    __out                                   DRM_DWORD           *f_pcbOpaqueBuffer );
+
+DRM_API DRM_RESULT DRM_CALL Drm_ResizeInMemoryLicenseStore(
+    __in                                    DRM_APP_CONTEXT     *f_poAppContext,
+    __in                                    DRM_DWORD            f_cbInMemoryLicenseBuffer );
+
+DRM_API_VOID DRM_VOID DRM_CALL Drm_Uninitialize(
+    __in DRM_APP_CONTEXT *f_poAppContext );
+
+DRM_API DRM_RESULT DRM_CALL Drm_Reinitialize(
+    __in DRM_APP_CONTEXT *f_poAppContext );
+
+DRM_API_VOID DRM_VOID DRM_CALL Drm_ClearAllCaches( DRM_VOID );
+
+DRM_API DRM_RESULT DRM_CALL Drm_DisableBlobCache(
+    __in    DRM_APP_CONTEXT     *f_poAppContext );
+
+DRM_API DRM_RESULT DRM_CALL Drm_Content_SetProperty(
+    __in                                      DRM_APP_CONTEXT          *f_poAppContext,
+    __in                                      DRM_CONTENT_SET_PROPERTY  f_eProperty,
+    __in_bcount_opt( f_cbPropertyData ) const DRM_BYTE                 *f_pbPropertyData,
+    __in                                      DRM_DWORD                 f_cbPropertyData );
+
+DRM_API DRM_RESULT DRM_CALL Drm_Content_GetProperty(
+    __inout                                DRM_APP_CONTEXT          *f_poAppContext,
+    __in                                   DRM_CONTENT_GET_PROPERTY  f_eProperty,
+    __out_bcount_opt( *f_pcbPropertyData ) DRM_BYTE                 *f_pbPropertyData,
+    __inout                                DRM_DWORD                *f_pcbPropertyData );
+
+DRM_API DRM_RESULT DRM_CALL Drm_Content_UpdateEmbeddedStore(
+    __in    DRM_APP_CONTEXT     *f_poAppContext );
+
+DRM_API DRM_RESULT DRM_CALL Drm_Content_UpdateEmbeddedStore_Commit(
+    __in const DRM_APP_CONTEXT     *f_poAppContext );
+
+DRM_API DRM_RESULT DRM_CALL Drm_Device_GetProperty(
+    __in                                DRM_APP_CONTEXT         *f_poAppContext,
+    __in                                DRM_DEVICE_GET_PROPERTY  f_eProperty,
+    __out_bcount_opt( *f_pcbProperty )  DRM_BYTE                *f_pbProperty,
+    __inout                             DRM_DWORD               *f_pcbProperty );
+
+/*
+** ---------------------------------------
+** License acquisition API functions
+** ---------------------------------------
+*/
+DRM_API DRM_RESULT DRM_CALL Drm_LicenseAcq_GenerateChallenge(
+    __in                                          DRM_APP_CONTEXT  *f_poAppContext,
+    __in_ecount_opt( f_cRights )            const DRM_CONST_STRING *f_rgpdstrRights[ ],
+    __in                                          DRM_DWORD         f_cRights,
+    __in_opt                                const DRM_DOMAIN_ID    *f_poDomainID,
+    __in_ecount_opt( f_cchCustomData )      const DRM_CHAR         *f_pchCustomData,
+    __in                                          DRM_DWORD         f_cchCustomData,
+    __out_ecount_opt( *f_pcchSilentURL )          DRM_CHAR         *f_pchSilentURL,
+    __inout_opt                                   DRM_DWORD        *f_pcchSilentURL,
+    __out_ecount_opt( *f_pcchNonSilentURL )       DRM_CHAR         *f_pchNonSilentURL,
+    __inout_opt                                   DRM_DWORD        *f_pcchNonSilentURL,
+    __out_bcount_opt( *f_pcbChallenge )           DRM_BYTE         *f_pbChallenge,
+    __inout                                       DRM_DWORD        *f_pcbChallenge,
+    __out_opt                                     DRM_ID           *f_pidSession );
+
+DRM_API DRM_RESULT DRM_CALL Drm_LicenseAcq_ProcessResponse(
+    __in                              DRM_APP_CONTEXT                *f_poAppContext,
+    __in                              DRM_PROCESS_LIC_RESPONSE_FLAG   f_dwFlags,
+    __in_bcount( f_cbResponse ) const DRM_BYTE                       *f_pbResponse,
+    __in                              DRM_DWORD                       f_cbResponse,
+    __inout                           DRM_LICENSE_RESPONSE           *f_poLicenseResponse );
+
+DRM_API DRM_RESULT DRM_CALL Drm_LicenseAcq_GenerateAck(
+    __in                                DRM_APP_CONTEXT      *f_poAppContext,
+    __in                                DRM_LICENSE_RESPONSE *f_poLicenseResponse,
+    __out_bcount_opt( *f_pcbChallenge ) DRM_BYTE             *f_pbChallenge,
+    __inout                             DRM_DWORD            *f_pcbChallenge );
+
+DRM_API DRM_RESULT DRM_CALL Drm_LicenseAcq_ProcessAckResponse(
+    __in                        const DRM_APP_CONTEXT *f_poAppContext,
+    __in_bcount( f_cbResponse ) const DRM_BYTE        *f_pbResponse,
+    __in                              DRM_DWORD        f_cbResponse,
+    __out_opt                         DRM_RESULT      *f_pResult );
+
+DRM_API DRM_RESULT DRM_CALL Drm_GetAdditionalResponseData(
+    __in                            const DRM_APP_CONTEXT  *f_poAppContext,
+    __in_bcount( f_cbResponse )     const DRM_BYTE         *f_pbResponse,
+    __in                                  DRM_DWORD         f_cbResponse,
+    __in                                  DRM_DWORD         f_dwDataType,
+    __out_ecount_opt( *f_pcchDataString ) DRM_CHAR         *f_pchDataString,
+    __inout                               DRM_DWORD        *f_pcchDataString );
+
+DRM_API DRM_RESULT DRM_CALL Drm_Reader_Bind(
+    __in                           DRM_APP_CONTEXT      *f_poAppContext,
+    __in_ecount( f_cRights ) const DRM_CONST_STRING     *f_rgpdstrRights[],
+    __in                           DRM_DWORD             f_cRights,
+    __in_opt                       DRMPFNPOLICYCALLBACK  f_pfnPolicyCallback,
+    __in_opt                 const DRM_VOID             *f_pv,
+    __out_opt                      DRM_DECRYPT_CONTEXT  *f_pcontextDCRY );
+
+DRM_API_VOID DRM_VOID DRM_CALL Drm_Reader_Close(
+    __in_ecount_opt( 1 ) DRM_DECRYPT_CONTEXT *f_pcontextDCRY );
+
+DRM_API DRM_RESULT DRM_CALL Drm_Reader_Commit(
+    __in           DRM_APP_CONTEXT      *f_poAppContext,
+    __in_opt       DRMPFNPOLICYCALLBACK  f_pfnPolicyCallback,
+    __in_opt const DRM_VOID             *f_pvCallbackData );
+
+DRM_API DRM_RESULT DRM_CALL Drm_Reader_DecryptLegacy(
+    __in_ecount( 1 )           DRM_DECRYPT_CONTEXT          *f_pDecryptContext,
+    __inout                    DRM_AES_COUNTER_MODE_CONTEXT *f_pCtrContext,
+    __inout_bcount( f_cbData ) DRM_BYTE                     *f_pbData,
+    __in                       DRM_DWORD                     f_cbData );
+
+DRM_API DRM_RESULT DRM_CALL Drm_Reader_DecryptOpaque(
+    __in                                            DRM_DECRYPT_CONTEXT      *f_pDecryptContext,
+    __in                                            DRM_DWORD                 f_cEncryptedRegionMappings,
+    __in_ecount( f_cEncryptedRegionMappings ) const DRM_DWORD                *f_pdwEncryptedRegionMappings,
+    __in                                            DRM_UINT64                f_ui64InitializationVector,
+    __in                                            DRM_DWORD                 f_cbEncryptedContent,
+    __in_bcount( f_cbEncryptedContent )       const DRM_BYTE                 *f_pbEncryptedContent,
+    __out                                           DRM_DWORD                *f_pcbOpaqueClearContent,
+    __deref_out_bcount( *f_pcbOpaqueClearContent )  DRM_BYTE                **f_ppbOpaqueClearContent );
+
+DRM_NO_INLINE DRM_API_VOID DRM_VOID DRM_CALL DRM_Reader_FreeOpaqueDecryptedContent(
+    __in                                     DRM_DECRYPT_CONTEXT     *f_pDecryptContext,
+    __in                                     DRM_DWORD                f_cbOpaqueClearContent,
+    __inout_bcount( f_cbOpaqueClearContent ) DRM_BYTE                *f_pbOpaqueClearContent );
+
+DRM_API DRM_RESULT DRM_CALL Drm_Reader_DecryptMultipleOpaque(
+    __in                                                                 DRM_DECRYPT_CONTEXT      *f_pDecryptContext,
+    __in                                                                 DRM_DWORD                 f_cEncryptedRegionInitializationVectors,
+    __in_ecount( f_cEncryptedRegionInitializationVectors )         const DRM_UINT64               *f_pEncryptedRegionInitializationVectorsHigh,
+    __in_ecount_opt( f_cEncryptedRegionInitializationVectors )     const DRM_UINT64               *f_pEncryptedRegionInitializationVectorsLow,
+    __in_ecount( f_cEncryptedRegionInitializationVectors )         const DRM_DWORD                *f_pEncryptedRegionCounts,
+    __in                                                                 DRM_DWORD                 f_cEncryptedRegionMappings,
+    __in_ecount( f_cEncryptedRegionMappings )                      const DRM_DWORD                *f_pEncryptedRegionMappings,
+    __in                                                                 DRM_DWORD                 f_cEncryptedRegionSkip,
+    __in_ecount_opt( f_cEncryptedRegionSkip )                      const DRM_DWORD                *f_pEncryptedRegionSkip,
+    __in                                                                 DRM_DWORD                 f_cbEncryptedContent,
+    __in_bcount( f_cbEncryptedContent )                            const DRM_BYTE                 *f_pbEncryptedContent,
+    __out                                                                DRM_DWORD                *f_pcbOpaqueClearContent,
+    __deref_out_bcount( *f_pcbOpaqueClearContent )                       DRM_BYTE                **f_ppbOpaqueClearContent );
+
+DRM_API DRM_RESULT DRM_CALL Drm_License_GetProperty(
+    __in                                        DRM_APP_CONTEXT           *f_poAppContext,
+    __in                                        DRM_LICENSE_GET_PROPERTY   f_eProperty,
+    __inout_bcount_opt( *f_pcbExtraData )       DRM_BYTE                  *f_pbExtraData,
+    __in_opt                              const DRM_DWORD                 *f_pcbExtraData,
+    __out_opt                                   DRM_DWORD                 *f_pdwOutputData );
+
+DRM_API DRM_RESULT DRM_CALL Drm_PlayReadyObject_ConvertFromWmdrmHeader(
+    __in_bcount( f_cbWmdrmHeader )  const DRM_BYTE  *f_pbWmdrmHeader,
+    __in                            const DRM_DWORD  f_cbWmdrmHeader,
+    __in_ecount_nz_opt( f_cchPlayReadySilentURL )
+                                    const DRM_WCHAR *f_pwchPlayReadySilentURL,
+    __in                            const DRM_DWORD  f_cchPlayReadySilentURL,
+    __in_ecount_nz_opt( f_cchPlayReadyNonSilentURL )
+                                    const DRM_WCHAR *f_pwchPlayReadyNonSilentURL,
+    __in                            const DRM_DWORD  f_cchPlayReadyNonSilentURL,
+    __in_ecount_nz_opt( f_cchServiceID )
+                                    const DRM_WCHAR *f_pwchServiceID,
+    __in                            const DRM_DWORD  f_cchServiceID,
+    __in                                  DRM_BOOL   f_fIncludeELS,
+    __in_ecount_nz_opt( f_cchCustomAttributes )
+                                    const DRM_WCHAR *f_pwchCustomAttributes,
+    __in                            const DRM_DWORD  f_cchCustomAttributes,
+    __inout_bcount_opt( *f_pcbPlayReadyObject )
+                                          DRM_BYTE  *f_pbPlayReadyObject,
+    __inout                               DRM_DWORD *f_pcbPlayReadyObject );
+
+/*
+** ---------------------------------------
+** Secure Time API functions
+** ---------------------------------------
+*/
+DRM_API DRM_RESULT DRM_CALL Drm_SecureTime_GenerateChallenge(
+    __in                                        DRM_APP_CONTEXT             *f_poAppContext,
+    __out                                       DRM_DWORD                   *f_pcbChallenge,
+    __deref_out_bcount( *f_pcbChallenge )       DRM_BYTE                   **f_ppbChallenge );
+
+DRM_API DRM_RESULT DRM_CALL Drm_SecureTime_ProcessResponse(
+    __in                                        DRM_APP_CONTEXT             *f_poAppContext,
+    __in                                        DRM_DWORD                    f_cbResponse,
+    __in_bcount( f_cbResponse )           const DRM_BYTE                    *f_pbResponse );
+
+DRM_API DRM_RESULT DRM_CALL Drm_SecureTime_GetValue(
+    __in                                        DRM_APP_CONTEXT             *f_poAppContext,
+    __out                                       DRMFILETIME                 *f_pftSystemTime,
+    __out                                       DRM_SECURETIME_CLOCK_TYPE   *f_peClockType );
+
+/*
+** ---------------------------------------
+** Secure Delete API functions
+** ---------------------------------------
+*/
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL Drm_SecureDelete_GenerateChallenge(
+    __in                                    DRM_APP_CONTEXT            *f_poAppContext,
+    __in                              const DRM_ID                     *f_pIdSession,
+    __out                                   DRM_DWORD                  *f_pcbChallenge,
+    __deref_out_bcount(*f_pcbChallenge)     DRM_BYTE                  **f_ppbChallenge );
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL Drm_SecureDelete_ProcessResponse(
+    __in                                        DRM_APP_CONTEXT            *f_poAppContext,
+    __in                                        DRM_DWORD                   f_cbResponse,
+    __in_bcount(f_cbResponse)             const DRM_BYTE                   *f_pbResponse,
+    __out                                       DRM_ID                     *f_pIdSession );
+
+/*
+** ---------------------------------------
+** Store Management API functions
+** ---------------------------------------
+*/
+DRM_API DRM_RESULT DRM_CALL Drm_StoreMgmt_CleanupStore(
+    __in           DRM_APP_CONTEXT        *f_poAppContext,
+    __in           DRM_DWORD               f_dwFlags,
+    __in_opt const DRM_VOID               *f_pvCallerData,
+    __in           DRM_DWORD               f_dwCallbackInterval,
+    __in_opt       pfnStoreCleanupProgress f_pfnCallback );
+
+DRM_API DRM_RESULT DRM_CALL Drm_StoreMgmt_DeleteLicenses(
+    __in            DRM_APP_CONTEXT  *f_poAppContext,
+    __in      const DRM_CONST_STRING *f_pdcstrKID,
+    __in_opt  const DRM_CONST_STRING *f_pdcstrLID,
+    __out_opt       DRM_DWORD        *f_pcLicDeleted );
+
+DRM_API DRM_RESULT DRM_CALL Drm_StoreMgmt_DeleteInMemoryLicenses(
+    __in            DRM_APP_CONTEXT  *f_poAppContext,
+    __in      const DRM_ID           *f_pidSession );
+
+DRM_API DRM_RESULT DRM_CALL Drm_ProcessCommand(
+    __in                                       DRM_APP_CONTEXT *f_poAppContext,
+    __in                                       DRM_DWORD        f_dwOperationCode,
+    __in                                       DRM_DWORD        f_dwRequestArgument1,
+    __in                                       DRM_DWORD        f_dwRequestArgument2,
+    __in                                       DRM_DWORD        f_dwRequestArgument3,
+    __in                                       DRM_DWORD        f_dwRequestArgument4,
+    __in_bcount( f_dwRequestDataLength ) const DRM_BYTE        *f_pbRequestData,
+    __in                                       DRM_DWORD        f_dwRequestDataLength,
+    __out_opt                                  DRM_DWORD       *f_pdwResponseResult1,
+    __out_opt                                  DRM_DWORD       *f_pdwResponseResult2,
+    __out_opt                                  DRM_DWORD       *f_pdwResponseResult3,
+    __out_opt                                  DRM_DWORD       *f_pdwResponseResult4 );
+
+DRM_API DRM_RESULT DRM_CALL Drm_ProcessRequest(
+    __in                                     DRM_APP_CONTEXT *f_poAppContext,
+    __in                                     DRM_DWORD        f_dwOperationCode,
+    __in                                     DRM_DWORD        f_dwRequestArgument1,
+    __in                                     DRM_DWORD        f_dwRequestArgument2,
+    __in                                     DRM_DWORD        f_dwRequestArgument3,
+    __in                                     DRM_DWORD        f_dwRequestArgument4,
+    __out                                    DRM_DWORD       *f_pdwResponseResult1,
+    __out                                    DRM_DWORD       *f_pdwResponseResult2,
+    __out                                    DRM_DWORD       *f_pdwResponseResult3,
+    __out                                    DRM_DWORD       *f_pdwResponseResult4,
+    __out_bcount( *f_pdwResponseDataLength ) DRM_BYTE        *f_pbResponseData,
+    __out                                    DRM_DWORD       *f_pdwResponseDataLength );
+
+/*
+** ---------------------------------------
+** Envelope API functions
+** ---------------------------------------
+*/
+
+DRM_API DRM_RESULT DRM_CALL Drm_Envelope_Open(
+    __in           DRM_APP_CONTEXT            *f_poAppContext,
+    __in_opt       DRM_VOID                   *f_pOEMContext,
+    __in_z   const DRM_WCHAR                  *f_pwszFilename,
+    __out          DRM_ENVELOPED_FILE_CONTEXT *f_pEnvFile );
+
+DRM_API DRM_RESULT DRM_CALL Drm_Envelope_DuplicateFileContext(
+    __in_opt       DRM_VOID                   *f_pOEMContext,
+    __in_z   const DRM_WCHAR                  *f_pwszFilename,
+    __in     const DRM_ENVELOPED_FILE_CONTEXT *f_pSourceHandle,
+    __out          DRM_ENVELOPED_FILE_CONTEXT *f_pNewHandle );
+
+DRM_API DRM_RESULT DRM_CALL Drm_Envelope_InitializeRead(
+    __in DRM_ENVELOPED_FILE_CONTEXT *f_pEnvFile,
+    __in DRM_DECRYPT_CONTEXT        *f_pDecrypt );
+
+DRM_API DRM_RESULT DRM_CALL Drm_Envelope_Close(
+    __in DRM_ENVELOPED_FILE_CONTEXT *f_pEnvFile );
+
+DRM_API DRM_RESULT DRM_CALL Drm_Envelope_GetSize(
+    __in  DRM_ENVELOPED_FILE_CONTEXT *f_pEnvFile,
+    __out DRM_DWORD                  *f_pcbFileSize );
+
+DRM_API DRM_RESULT DRM_CALL Drm_Envelope_Read(
+    __in                                              DRM_ENVELOPED_FILE_CONTEXT *f_pEnvFile,
+    __out_ecount_part( f_cbToRead, *f_pcbBytesRead )  DRM_BYTE                   *f_pbBuffer,
+    __in                                              DRM_DWORD                   f_cbToRead,
+    __out                                             DRM_DWORD                  *f_pcbBytesRead );
+
+DRM_API DRM_RESULT DRM_CALL Drm_Envelope_WritePlayReadyObject(
+    __in         DRM_APP_CONTEXT            *f_poAppContext,
+    __inout_opt  DRM_VOID                   *f_pOEMContext,
+    __in_z const DRM_WCHAR                  *f_pwszFilename,
+    __inout      DRM_ENVELOPED_FILE_CONTEXT *f_pEnvFile );
+
+DRM_API DRM_RESULT DRM_CALL Drm_Envelope_Seek(
+    __in  DRM_ENVELOPED_FILE_CONTEXT *f_pEnvFile,
+    __in  DRM_LONG                    f_lDistanceToMove,
+    __in  DRM_DWORD                   f_dwMoveMethod,
+    __out DRM_DWORD                  *f_pdwNewFilePointer );
+
+DRM_API DRM_RESULT DRM_CALL Drm_Envelope_GetOriginalFilename(
+    __in                                        DRM_ENVELOPED_FILE_CONTEXT *f_pEnvFile,
+    __out_ecount_opt( *f_pcchOriginalFilename ) DRM_WCHAR                  *f_pwszOriginalFilename,
+    __inout                                     DRM_DWORD                  *f_pcchOriginalFilename );
+
+/*
+** ---------------------------------------
+** Revocation API functions
+** ---------------------------------------
+*/
+DRM_API DRM_RESULT DRM_CALL Drm_Revocation_SetBuffer(
+    __inout                                 DRM_APP_CONTEXT *f_poAppContext,
+    __in_bcount_opt( f_cbRevocationBuffer ) DRM_BYTE        *f_pbRevocationBuffer,
+    __in                                    DRM_DWORD        f_cbRevocationBuffer );
+
+DRM_API DRM_RESULT DRM_CALL Drm_Revocation_GetBuffer(
+    __inout                                      DRM_APP_CONTEXT  *f_poAppContext,
+    __deref_out_bcount( *f_pcbRevocationBuffer ) DRM_BYTE        **f_ppbRevocationBuffer,
+    __out                                        DRM_DWORD        *f_pcbRevocationBuffer );
+
+DRM_API DRM_RESULT DRM_CALL Drm_Revocation_GetList(
+    __inout                          DRM_APP_CONTEXT          *f_poAppContext,
+    __in                             DRM_REVOCATION_TYPE_ENUM  f_eRevType,
+    __out_bcount_opt( *f_pcbBuffer ) DRM_BYTE                 *f_pbBuffer,
+    __inout_opt                      DRM_DWORD                *f_pcbBuffer,
+    __out_opt                        DRM_DWORD                *f_pdwVersion );
+
+DRM_API DRM_RESULT DRM_CALL Drm_Revocation_StorePackage(
+    __inout                           DRM_APP_CONTEXT *f_poAppContext,
+    __in_ecount( f_cchPackage ) const DRM_CHAR        *f_pchPackage,
+    __in                              DRM_DWORD        f_cchPackage );
+
+DRM_API DRM_RESULT DRM_CALL Drm_Platform_Initialize( __inout_opt DRM_VOID *f_pvUserCtx );
+
+DRM_API DRM_RESULT DRM_CALL Drm_Platform_Uninitialize( __inout_opt DRM_VOID *f_pvUserCtx );
+
+/*
+** ---------------------------------------
+** Domain API functions
+** ---------------------------------------
+*/
+DRM_API DRM_RESULT DRM_CALL Drm_JoinDomain_GenerateChallenge(
+    __in                                       DRM_APP_CONTEXT *f_poAppContext,
+    __in                                       DRM_DWORD        f_dwFlags,
+    __in_opt                                   DRM_DOMAIN_ID   *f_poDomainID,
+    __in_ecount_opt( f_cchFriendlyName ) const DRM_CHAR        *f_pchFriendlyName,
+    __in                                       DRM_DWORD        f_cchFriendlyName,
+    __in_ecount_opt( f_cchData )         const DRM_CHAR        *f_pchData,
+    __in                                       DRM_DWORD        f_cchData,
+    __out_bcount_opt( *f_pcbChallenge )        DRM_BYTE        *f_pbChallenge,
+    __inout                                    DRM_DWORD       *f_pcbChallenge );
+
+DRM_API DRM_RESULT DRM_CALL Drm_JoinDomain_ProcessResponse(
+    __in                        DRM_APP_CONTEXT              *f_poAppContext,
+    __in                        DRM_PROCESS_DJ_RESPONSE_FLAG  f_dwFlags,
+    __in_bcount( f_cbResponse ) DRM_BYTE                     *f_pbResponse,
+    __in                        DRM_DWORD                     f_cbResponse,
+    __out                       DRM_RESULT                   *f_pResult,
+    __out_opt                   DRM_DOMAIN_ID                *f_poDomainID );
+
+DRM_API DRM_RESULT DRM_CALL Drm_LeaveDomain_GenerateChallenge(
+    __in                                      DRM_APP_CONTEXT *f_poAppContext,
+    __in                                      DRM_DWORD        f_dwFlags,
+    __in_opt                                  DRM_DOMAIN_ID   *f_poDomainID,
+    __in_ecount_opt( f_cchData )        const DRM_CHAR        *f_pchData,
+    __in                                      DRM_DWORD        f_cchData,
+    __out_bcount_opt( *f_pcbChallenge )       DRM_BYTE        *f_pbChallenge,
+    __inout                                   DRM_DWORD       *f_pcbChallenge );
+
+DRM_API DRM_RESULT DRM_CALL Drm_LeaveDomain_ProcessResponse(
+    __in                        const DRM_APP_CONTEXT *f_poAppContext,
+    __in_bcount( f_cbResponse ) const DRM_BYTE        *f_pbResponse,
+    __in                              DRM_DWORD        f_cbResponse,
+    __out                             DRM_RESULT      *f_pResult );
+
+DRM_API DRM_RESULT DRM_CALL Drm_DomainCert_Find(
+    __in                                       DRM_APP_CONTEXT *f_poAppContext,
+    __in                                 const DRM_DOMAIN_ID   *f_poDomainID,
+    __out_bcount_opt( *f_pcbDomainCert )       DRM_BYTE        *f_pbDomainCert,
+    __inout                                    DRM_DWORD       *f_pcbDomainCert );
+
+DRM_API DRM_RESULT DRM_CALL Drm_DomainCert_InitEnum(
+    __in  DRM_APP_CONTEXT              *f_poAppContext,
+    __out DRM_DOMAIN_CERT_ENUM_CONTEXT *f_poDomainCertEnumContext );
+
+DRM_API DRM_RESULT DRM_CALL Drm_DomainCert_EnumNext(
+    __in  DRM_DOMAIN_CERT_ENUM_CONTEXT  *f_poDomainCertEnumContext,
+    __out DRM_DWORD                     *f_pcchDomainCert,
+    __out DRM_DOMAINCERT_INFO           *f_poDomainCertInfo );
+
+/*
+** ---------------------------------------
+** Metering Certificate API Functions
+** ---------------------------------------
+*/
+DRM_API DRM_RESULT DRM_CALL Drm_MeterCert_InitEnum(
+    __in    DRM_APP_CONTEXT     *pAppContext,
+    __out   DRM_METERCERT_ENUM  *pMeterCertEnumContext );
+
+DRM_API DRM_RESULT DRM_CALL Drm_MeterCert_EnumNext(
+    __in                                DRM_METERCERT_ENUM  *pMeterCertEnumContext,
+    __inout                             DRM_MID             *pmid,
+    __out_ecount_opt( *f_cchLAINFO )    DRM_WCHAR           *pwszLAINFO,
+    __out_opt                           DRM_DWORD           *f_cchLAINFO,
+    __out_bcount_opt( *f_pcbMeterCert ) DRM_BYTE            *f_pbMeterCert,
+    __out_opt                           DRM_DWORD           *f_pcbMeterCert );
+
+DRM_API DRM_RESULT DRM_CALL Drm_MeterCert_Update(
+    __in                              DRM_APP_CONTEXT    *pAppContext,
+    __in_bcount( cbMeterCert )  const DRM_BYTE           *pbMeterCert,
+    __in                              DRM_DWORD           cbMeterCert,
+    __out_opt                         DRM_MID            *pmid);
+
+DRM_API DRM_RESULT DRM_CALL Drm_MeterCert_Invalidate(
+    __in       DRM_APP_CONTEXT  *f_pcontextMGR,
+    __in const DRM_MID          *f_pmid );
+
+DRM_API DRM_RESULT DRM_CALL Drm_MeterCert_Delete(
+    __in       DRM_APP_CONTEXT  *f_pcontextMGR,
+    __in const DRM_MID          *f_pmid );
+
+DRM_API DRM_RESULT DRM_CALL Drm_MeterCert_ProcessResponse(
+    __in                              DRM_APP_CONTEXT *f_poAppContext,
+    __in_bcount( f_cbResponse ) const DRM_BYTE        *f_pbResponse,
+    __in                              DRM_DWORD        f_cbResponse,
+    __out                             DRM_RESULT      *f_pResult );
+
+DRM_API DRM_RESULT DRM_CALL Drm_MeterCert_GenerateChallenge(
+    __in                                    DRM_APP_CONTEXT *f_poAppContext,
+    __in                              const DRM_MID         *f_poMID,
+    __in_ecount_opt( f_cchCustomData) const DRM_CHAR        *f_pchCustomData,
+    __in_opt                                DRM_DWORD        f_cchCustomData,
+    __out_bcount_opt( *f_pcbChallenge )     DRM_BYTE        *f_pbChallenge,
+    __inout                                 DRM_DWORD       *f_pcbChallenge );
+
+DRM_API DRM_RESULT DRM_CALL Drm_Metering_GenerateChallenge(
+    __in                                DRM_APP_CONTEXT  *f_poAppContext,
+    __in_bcount( f_cbMeterCert ) const  DRM_BYTE         *f_pbMeterCert,
+    __in                                DRM_DWORD         f_cbMeterCert,
+    __in_ecount_opt( f_cchCustomData )
+                                 const  DRM_CHAR         *f_pchCustomData,
+    __in_opt                            DRM_DWORD         f_cchCustomData,
+    __out_ecount_opt( *f_pcchURL )      DRM_CHAR         *f_pchURL,
+    __inout_opt                         DRM_DWORD        *f_pcchURL,
+    __out_bcount_opt( *f_pcbChallenge ) DRM_BYTE         *f_pbChallenge,
+    __inout                             DRM_DWORD        *f_pcbChallenge );
+
+DRM_API DRM_RESULT DRM_CALL Drm_Metering_ProcessResponse(
+    __in                              DRM_APP_CONTEXT  *f_poAppContext,
+    __in_bcount( f_cbResponse ) const DRM_BYTE         *f_pbResponse,
+    __in                              DRM_DWORD         f_cbResponse,
+    __out                             DRM_DWORD        *f_pfFlags );
+
+/*
+** ---------------------------------------
+** Local License Generation API functions
+** ---------------------------------------
+*/
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL Drm_LocalLicense_InitializePolicyDescriptor(
+    __inout                             DRM_LOCAL_LICENSE_POLICY_DESCRIPTOR *f_poDescriptor ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL Drm_LocalLicense_CreateLicense(
+    __inout                               DRM_APP_CONTEXT                     *f_poAppContext,
+    __in                            const DRM_LOCAL_LICENSE_POLICY_DESCRIPTOR *f_poDescriptor,
+    __in                                  DRM_LOCAL_LICENSE_TYPE               f_eLicenseType,
+    __in                                  DRM_DWORD                            f_dwEncryptionMode,
+    __in                            const DRM_KID                             *f_pKeyId,
+    __in_opt                        const DRM_LICENSE_HANDLE                   f_hRootLicense,
+    __out                                 DRM_LICENSE_HANDLE                  *f_phLicense ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL Drm_LocalLicense_CreatePlayReadyObject(
+    __in_opt                                  DRM_DWORD                            f_cLicenses,
+    __in_ecount_opt( f_cLicenses )      const DRM_LICENSE_HANDLE                  *f_pLicenses,
+    __in_opt                            const DRM_DWORD                            f_cbRMHeader,
+    __in_bcount_opt( f_cbRMHeader )     const DRM_BYTE                            *f_pbRMHeader,
+    __out                                     DRM_DWORD                           *f_pcbPROBlob,
+    __deref_out_bcount( *f_pcbPROBlob )       DRM_BYTE                           **f_ppbPROBlob ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL Drm_LocalLicense_CreateRMHeader(
+    __in                                 eDRM_HEADER_VERSION                  f_eHeaderVersion,
+    __in                                 DRM_SUPPORTED_CIPHERS                f_eCipherType,
+    __in                                 DRM_DWORD                            f_cKeyIds,
+    __in_ecount_opt(f_cKeyIds)     const DRM_KID                             *f_pKeyIds,
+    __out                                DRM_DWORD                           *f_pcbRMHeader,
+    __deref_out_bcount( *f_pcbRMHeader ) DRM_BYTE                           **f_ppbRMHeader ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL Drm_LocalLicense_StoreLicense(
+    __in                          const DRM_LICENSE_HANDLE                   f_hLicense,
+    __in                          const DRM_LOCAL_LICENSE_STORE              f_eLicenseStore ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL Drm_LocalLicense_EncryptOpaque(
+    __in                                          const DRM_LICENSE_HANDLE   f_hLicense,
+    __in                                                DRM_DWORD            f_cEncryptedRegionMappings,
+    __in_ecount( f_cEncryptedRegionMappings )     const DRM_DWORD           *f_pdwEncryptedRegionMappings,
+    __in                                                DRM_DWORD            f_cbOpaqueClearContent,
+    __in_bcount( f_cbOpaqueClearContent )         const DRM_BYTE            *f_pbOpaqueClearContent,
+    __out                                               DRM_DWORD           *f_pcbEncryptedContent,
+    __deref_out_bcount( *f_pcbEncryptedContent )        DRM_BYTE           **f_ppbEncryptedContent,
+    __out                                               DRM_UINT64          *f_pqwIV ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL Drm_LocalLicense_GetKID(
+    __in                          const DRM_LICENSE_HANDLE                   f_hLicense,
+    __out                               DRM_KID                             *f_pKeyID ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL Drm_LocalLicense_GetXMRLicense(
+    __in                           const DRM_LICENSE_HANDLE                   f_hLicense,
+    __out                                DRM_DWORD                           *f_pcbXMRLicense,
+    __deref_out_bcount(*f_pcbXMRLicense) DRM_BYTE                           **f_ppbXMRLicense ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL Drm_LocalLicense_AddRef (
+    __inout                             DRM_LICENSE_HANDLE                   f_hLicense ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL Drm_LocalLicense_Release(
+    __inout                             DRM_LICENSE_HANDLE                  *f_phLicense ) DRM_NO_INLINE_ATTRIBUTE;
+
+/*
+** ---------------------------------------
+** Activation API functions
+** ---------------------------------------
+*/
+DRM_API DRM_RESULT DRM_CALL Drm_Activation_ProcessResponseGenerateChallenge(
+    __inout_bcount( ACTIVATION_CONTEXT_SIZE )  DRM_BYTE        *f_pbActivationCtx,
+    __in_bcount_opt( f_cbResponse )      const DRM_BYTE        *f_pbResponse,
+    __in_opt                                   DRM_DWORD        f_cbResponse,
+    __out_bcount_opt( *f_pcbChallenge )        DRM_BYTE        *f_pbChallenge,
+    __inout                                    DRM_DWORD       *f_pcbChallenge,
+    __out_ecount_opt( *f_pcchUrl )             DRM_CHAR        *f_pszUrl,
+    __inout                                    DRM_DWORD       *f_pcchUrl,
+    __out                                      DRM_RESULT      *f_pResult );
+
+DRM_API DRM_RESULT DRM_CALL Drm_GetContextSizes(
+    __out     DRM_DWORD *f_pdwAppContextSize,
+    __out     DRM_DWORD *f_pdwOpaqueBufferSize,
+    __out     DRM_DWORD *f_pdwDecryptContextSize );
+
+DRM_API DRM_RESULT DRM_CALL Drm_Reader_CloneDecryptContext(
+    __inout_ecount(1)  DRM_DECRYPT_CONTEXT *f_pDecryptContextIn,
+    __out_ecount(1)    DRM_DECRYPT_CONTEXT *f_pDecryptContextOut );
+
+/*
+** ---------------------------------------
+** Policy State API functions
+** ---------------------------------------
+*/
+DRM_API DRM_RESULT DRM_CALL Drm_Policy_GetStateData(
+    __in    DRM_APP_CONTEXT         *f_poAppContext,
+    __in    const DRM_CONST_STRING  *f_pdstrKID,
+    __in    const DRM_CONST_STRING  *f_pdstrStateName,
+    __out_bcount_opt( *f_pcbStateData )
+            DRM_BYTE                *f_pbStateData,
+    __inout DRM_DWORD               *f_pcbStateData );
+
+DRM_API DRM_RESULT DRM_CALL Drm_Policy_SetStateData(
+    __in    DRM_APP_CONTEXT         *f_poAppContext,
+    __in    const DRM_CONST_STRING  *f_pdstrKID,
+    __in    const DRM_CONST_STRING  *f_pdstrStateName,
+    __in_bcount( f_cbStateData )
+            DRM_BYTE                *f_pbStateData,
+    __inout DRM_DWORD                f_cbStateData );
+
+/*
+** ---------------------------------------
+** Secure Stop API functions
+** ---------------------------------------
+*/
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL Drm_SecureStop_GenerateChallenge(
+    __in                                        DRM_APP_CONTEXT            *f_pAppContext,
+    __in_opt                              const DRM_ID                     *f_pidSession,
+    __in                                  const DRM_DWORD                   f_cbPublisherCert,
+    __in_bcount(f_cbPublisherCert)        const DRM_BYTE                   *f_pbPublisherCert,
+    __in                                  const DRM_DWORD                   f_cchCustomData,
+    __in_ecount_opt(f_cchCustomData)      const DRM_CHAR                   *f_pchCustomData,
+    __out                                       DRM_DWORD                  *f_pcbChallenge,
+    __deref_out_bcount(*f_pcbChallenge)         DRM_BYTE                  **f_ppbChallenge );
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL Drm_SecureStop_ProcessResponse(
+    __in                                        DRM_APP_CONTEXT            *f_pAppContext,
+    __in_opt                              const DRM_ID                     *f_pidSession,
+    __in                                  const DRM_DWORD                   f_cbPublisherCert,
+    __in_bcount(f_cbPublisherCert)        const DRM_BYTE                   *f_pbPublisherCert,
+    __in                                  const DRM_DWORD                   f_cbResponse,
+    __in_bcount(f_cbResponse)             const DRM_BYTE                   *f_pbResponse,
+    __out_opt                                   DRM_DWORD                  *f_pcchCustomData,
+    __deref_out_ecount_opt(*f_pcchCustomData)   DRM_CHAR                  **f_ppchCustomData );
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL Drm_SecureStop_EnumerateSessions(
+    __in                                        DRM_APP_CONTEXT            *f_pAppContext,
+    __in                                  const DRM_DWORD                   f_cbPublisherCert,
+    __in_bcount(f_cbPublisherCert)        const DRM_BYTE                   *f_pbPublisherCert,
+    __out                                       DRM_DWORD                  *f_pcidSessions,
+    __deref_out_ecount(*f_pcidSessions)         DRM_ID                    **f_ppidSessions );
+
+PREFAST_POP /* __WARNING_NONCONST_PARAM_25004 */
+PREFAST_POP /* __WARNING_NONCONST_BUFFER_PARAM_25033 */
+
+EXIT_PK_NAMESPACE;
+
+#endif /* __DRMMANAGER_H__ */
+
diff --git a/prebuilt-v4.4/noarch/include/drmmanagerimpl.h b/prebuilt-v4.4/noarch/include/drmmanagerimpl.h
new file mode 100644
index 0000000..05b4a1d
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmmanagerimpl.h
@@ -0,0 +1,32 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __DRMMANAGERIMPL_H__
+#define __DRMMANAGERIMPL_H__
+
+#include <drmmanagertypes.h>
+
+ENTER_PK_NAMESPACE;
+
+DRM_API_VOID DRM_VOID DRM_CALL _FreeDrmAppInternalContexts(
+    __in DRM_APP_CONTEXT_INTERNAL *f_poAppContext );
+
+DRM_API DRM_RESULT DRM_CALL _DoesV4XHeaderHaveEmptyKID(
+    __in  const DRM_APP_CONTEXT_INTERNAL  *f_poAppContextInternal,
+    __out       DRM_BOOL                  *f_pfV4XHeaderHasEmptyKID );
+
+DRM_API DRM_RESULT DRM_CALL _SetupLicEvalObjectToShare(
+    __in DRM_APP_CONTEXT_INTERNAL *f_poAppContextInternal );
+
+DRM_API DRM_BOOL DRM_CALL _BlockTimeBoundLicenses(
+    __in const DRM_APP_CONTEXT_INTERNAL *f_poAppContextInternal );
+
+EXIT_PK_NAMESPACE;
+
+#endif /* __DRMMANAGERIMPL_H__ */
+
diff --git a/prebuilt-v4.4/noarch/include/drmmanagertypes.h b/prebuilt-v4.4/noarch/include/drmmanagertypes.h
new file mode 100644
index 0000000..f0599e9
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmmanagertypes.h
@@ -0,0 +1,252 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __DRMMANAGERTYPES_H__
+#define __DRMMANAGERTYPES_H__
+
+#include <drmcontextsizes.h>
+
+ENTER_PK_NAMESPACE;
+
+#define DRM_REAL_TIME_EXPIRATION_CHECK_BYTE_COUNT   0x100000  /* Check for expiration every 1MB (0x100000 == 1024*1024 == 1,048,578 bytes) of data processed */
+
+typedef struct
+{
+    DRM_BYTE rgbBuffer[ sizeof( DRM_CIPHER_CONTEXT ) ];
+} DRM_DECRYPT_CONTEXT;
+
+typedef struct __tag_DRM_DGP_REE_FEATURE_LIST_4_3
+{
+    DRM_DWORD cbThis;
+    DRM_BOOL fAssembly;
+    DRM_BOOL fPersistentStorePrealloc;
+    DRM_BOOL fECCProfiling;
+    DRM_BOOL fForceAlign;
+    DRM_BOOL fInlineDwordCopy;
+    DRM_BOOL fFileLocking;
+    DRM_BOOL fMultiThreading;
+    DRM_BOOL fNative64BitTypes;
+    DRM_BOOL fPrecomputedECCGlobalTable;
+    DRM_BOOL fTracing;
+    DRM_BOOL fPersistentStoreWriteThrough;
+    DRM_BOOL fAddLicenseWriteThrough;
+    DRM_BOOL fNoOptimizations;
+    DRM_BOOL fDebugBuild;
+    DRM_BOOL fProfiling;
+    DRM_BOOL fActivation;
+    DRM_BOOL fAntirollbackClock;
+    DRM_BOOL fCDMI;
+    DRM_BOOL fCleanStore;
+    DRM_BOOL fErrorCodeContract;
+    DRM_BOOL fPKCRT;
+    DRM_BOOL fDeviceAssets;
+    DRM_BOOL fDomains;
+    DRM_BOOL fEmbeddedLicenseStore;
+    DRM_BOOL fPersistentStore;
+    DRM_BOOL fPersistentStoreBlockHeaderCache;
+    DRM_BOOL fCDMIPersistentStore;
+    DRM_BOOL fContentKeyGeneration;
+    DRM_BOOL fLocalLicenseGeneration;
+    DRM_BOOL fMeteringCertificateRevocation;
+    DRM_BOOL fMetering;
+    DRM_BOOL fModelCertificateRevocation;
+    DRM_BOOL fInMemoryOnlyLicenses;
+    DRM_BOOL fPerformance;
+    DRM_BOOL fReactivation;
+    DRM_BOOL fRevocation;
+    DRM_BOOL fSecureDelete;
+    DRM_BOOL fSecureStop;
+    DRM_BOOL fSecureTime;
+    DRM_BOOL fStructuredSerialization;
+    DRM_BOOL fXmlParsingCache;
+    DRM_BOOL fLicenseAcquisition;
+    DRM_BOOL fLegacyXmlCertificates;
+} DRM_DGP_REE_FEATURE_LIST_4_3;
+
+typedef struct __tag_DRM_DGP_TEE_PROPERTY_LIST_4_3
+{
+    DRM_DWORD cbThis;
+    DRM_BOOL fSUPPORTS_HEVC_HW_DECODING;
+    DRM_BOOL fSUPPORTS_REMOTE_PROVISIONING;
+    DRM_BOOL fSUPPORTS_PRE_PROCESS_ENCRYPTED_DATA;
+    DRM_BOOL fREQUIRES_PRE_PROCESS_ENCRYPTED_DATA_WITH_FULL_FRAMES;
+    DRM_BOOL fREQUIRES_SAMPLE_PROTECTION;
+    DRM_BOOL fSUPPORTS_SECURE_CLOCK;
+    DRM_BOOL fSUPPORTS_SECURE_STOP;
+    DRM_BOOL fSUPPORTS_SECURE_HDCP_TYPE_1;
+    DRM_BOOL fREQUIRES_PREPARE_POLICY_INFO;
+    DRM_BOOL fSUPPORTS_DEBUG_TRACING;
+    DRM_BOOL fREQUIRES_MINIMAL_REVOCATION_DATA;
+    DRM_BOOL fSUPPORTS_OPTIMIZED_CONTENT_KEY2;
+} DRM_DGP_TEE_PROPERTY_LIST_4_3;
+
+typedef struct __tag_DRM_DGP_TEE_API_LIST_4_3
+{
+    DRM_DWORD cbThis;
+    DRM_BOOL fDRM_TEE_BASE_AllocTEEContext;
+    DRM_BOOL fDRM_TEE_BASE_FreeTEEContext;
+    DRM_BOOL fDRM_TEE_BASE_SignDataWithSecureStoreKey;
+    DRM_BOOL fDRM_TEE_BASE_CheckDeviceKeys;
+    DRM_BOOL fDRM_TEE_BASE_GetDebugInformation;
+    DRM_BOOL fDRM_TEE_BASE_GenerateNonce;
+    DRM_BOOL fDRM_TEE_BASE_GetSystemTime;
+    DRM_BOOL fDRM_TEE_LPROV_GenerateDeviceKeys;
+    DRM_BOOL fDRM_TEE_RPROV_GenerateBootstrapChallenge;
+    DRM_BOOL fDRM_TEE_RPROV_ProcessBootstrapResponse;
+    DRM_BOOL fDRM_TEE_RPROV_GenerateProvisioningRequest;
+    DRM_BOOL fDRM_TEE_RPROV_ProcessProvisioningResponse;
+    DRM_BOOL fDRM_TEE_LICPREP_PackageKey;
+    DRM_BOOL fDRM_TEE_SAMPLEPROT_PrepareSampleProtectionKey;
+    DRM_BOOL fDRM_TEE_DECRYPT_PreparePolicyInfo;
+    DRM_BOOL fDRM_TEE_DECRYPT_PrepareToDecrypt;
+    DRM_BOOL fDRM_TEE_DECRYPT_CreateOEMBlobFromCDKB;
+    DRM_BOOL fDRM_TEE_AES128CTR_DecryptContent;
+    DRM_BOOL fDRM_TEE_SIGN_SignHash;
+    DRM_BOOL fDRM_TEE_DOM_PackageKeys;
+    DRM_BOOL fDRM_TEE_RESERVED_20;
+    DRM_BOOL fDRM_TEE_RESERVED_21;
+    DRM_BOOL fDRM_TEE_RESERVED_22;
+    DRM_BOOL fDRM_TEE_RESERVED_23;
+    DRM_BOOL fDRM_TEE_REVOCATION_IngestRevocationInfo;
+    DRM_BOOL fDRM_TEE_LICGEN_CompleteLicense;
+    DRM_BOOL fDRM_TEE_LICGEN_AES128CTR_EncryptContent;
+    DRM_BOOL fDRM_TEE_RESERVED_27;
+    DRM_BOOL fDRM_TEE_RESERVED_28;
+    DRM_BOOL fDRM_TEE_RESERVED_29;
+    DRM_BOOL fDRM_TEE_RESERVED_30;
+    DRM_BOOL fDRM_TEE_RESERVED_31;
+    DRM_BOOL fDRM_TEE_RESERVED_32;
+    DRM_BOOL fDRM_TEE_RESERVED_33;
+    DRM_BOOL fDRM_TEE_H264_PreProcessEncryptedData;
+    DRM_BOOL fDRM_TEE_SECURESTOP_GetGenerationID;
+    DRM_BOOL fDRM_TEE_AES128CTR_DecryptAudioContentMultiple;
+    DRM_BOOL fDRM_TEE_SECURETIME_GenerateChallengeData;
+    DRM_BOOL fDRM_TEE_SECURETIME_ProcessResponseData;
+    DRM_BOOL fDRM_TEE_AES128CTR_DecryptContentMultiple;
+    DRM_BOOL fDRM_TEE_AES128CBC_DecryptContentMultiple;
+    DRM_BOOL fDRM_TEE_SECURESTOP2_GetSigningKeyBlob;
+    DRM_BOOL fDRM_TEE_SECURESTOP2_SignChallenge;
+    DRM_BOOL fDRM_TEE_BASE_GetFeatureInformation;
+} DRM_DGP_TEE_API_LIST_4_3;
+
+typedef enum __tag_DRM_DEVICE_GET_PROPERTY
+{
+    DRM_DGP_RESERVED1                                   = 1,
+    DRM_DGP_RESERVED2                                   = 2,
+    DRM_DGP_RESERVED3                                   = 3,
+    DRM_DGP_PLAYREADY_VERSION                           = 4,
+    DRM_DGP_RESERVED5                                   = 5,
+    DRM_DGP_RESERVED6                                   = 6,
+    DRM_DGP_PLAYREADY_CLIENT_CERTIFICATE_SECURITY_LEVEL = 7,
+    DRM_DGP_PLAYREADY_REE_FEATURE_LIST                  = 8,
+    DRM_DGP_PLAYREADY_TEE_PROPERTY_LIST                 = 9,
+    DRM_DGP_PLAYREADY_TEE_API_LIST                      = 10,
+    DRM_DGP_PLAYREADY_REE_INFORMATION_RAW_XML           = 11,
+    DRM_DGP_PLAYREADY_TEE_INFORMATION_RAW_XML           = 12,
+} DRM_DEVICE_GET_PROPERTY;
+
+PREFAST_PUSH_DISABLE_EXPLAINED( __WARNING_POOR_DATA_ALIGNMENT_25021, "Ignore poor data alignment that occurs due to making structures human-readable" )
+
+/*
+** pbKeyID:      Array of bytes that contains the KeyID from the V1 ASF header object.
+** cbKeyID:      Count of bytes in pbKeyID.
+** pbSecretData: Array of bytes that contains the SecretData from the V1 ASF header.
+** cbSecretData: Count of bytes in pbSecretData.
+** pbURL:        Array of bytes that contains the license acquisition URL from the V1 ASF header.
+** cbURL:        Count of bytes in pbURL.
+*/
+typedef struct
+{
+    const DRM_BYTE *pbKeyID;
+
+    DRM_DWORD       cbKeyID;
+
+    const DRM_BYTE *pbSecretData;
+
+    DRM_DWORD       cbSecretData;
+
+    const DRM_BYTE *pbURL;
+
+    DRM_DWORD       cbURL;
+
+} DRM_CSP_V1_HEADER_DATA;
+
+typedef struct
+{
+    const DRM_BYTE *pbKeyID;        /* For this structure, pbKeyID is a base64-encoded UTF16 string */
+    DRM_DWORD       cbKeyID;
+
+    const DRM_BYTE *pbHeaderData;
+    DRM_DWORD       cbHeaderData;
+
+} DRM_CSP_PLAYREADY_OBJ_WITH_KID_DATA;
+
+PREFAST_POP /* __WARNING_POOR_DATA_ALIGNMENT_25021 */
+
+typedef struct
+{
+    DRM_DWORD      cKIDs;
+    DRM_WCHAR     *rgpwszKIDs[1];
+
+} DRM_CGP_HEADER_KIDS_DATA;
+
+typedef struct
+{
+    eDRM_HEADER_VERSION     eHeaderVersion; /* Only supported values are: DRM_HEADER_VERSION_4 and higher */
+    DRM_SUPPORTED_CIPHERS   eCipherType;
+    DRM_CONST_STRING        dstrKID;        /* dstrKID is a base64-encoded UTF16 string */
+    DRM_CONST_STRING        dstrCheckSum;
+    DRM_CONST_STRING        dstrPlayReadySilentURL;
+    DRM_CONST_STRING        dstrPlayReadyNonSilentURL;
+    DRM_CONST_STRING        dstrServiceID;
+    DRM_CONST_STRING        dstrCustomAttributesXML;
+    DRM_CONST_STRING        dstrDecryptorSetup;         /* If set: "STANDARD" or "ONDEMAND" */
+} DRM_CSP_HEADER_COMPONENTS_DATA;
+
+typedef enum __tag_DRM_LICENSE_GET_PROPERTY
+{
+    DRM_LGP_MIN_SEC_LEVEL = 1,
+    DRM_LGP_SOURCE_ID,
+    DRM_LGP_REVINFO_VERSION,
+    DRM_LGP_MID,
+    DRM_LGP_HAS_INCLUSION_GUID,
+    DRM_LGP_ROOT_LOCAL_LICENSE_POLICY_DESCRIPTOR,
+    DRM_LGP_LEAF_LOCAL_LICENSE_POLICY_DESCRIPTOR,
+    DRM_LGP_CANNOT_PERSIST,
+} DRM_LICENSE_GET_PROPERTY;
+
+typedef struct
+{
+    DRM_CHAR szMID[ DRM_MAX_LICENSE_CHAIN_DEPTH ][ CCH_BASE64_EQUIV( sizeof( DRM_MID ) ) ] ;
+} DRM_LGP_MID_EXTRA_DATA;
+
+typedef struct
+{
+    DRM_GUID guid;
+} DRM_LGP_HAS_INCLUSION_GUID_EXTRA_DATA;
+
+/* Strings to be used from DRMManager */
+extern DRM_GLOBAL_CONST DRM_CONST_STRING      g_dstrDRM_RIGHT_PLAYBACK;
+
+typedef struct
+{
+    /* This data is Opaque.  Do not set any value in it. */
+    DRM_BYTE rgbOpaqueBuffer[ DRM_APP_CONTEXT_BUFFER_SIZE ];
+} DRM_APP_CONTEXT;
+
+#define DRM_STORE_CLEANUP_ALL                           0xFFFFFFFF
+#define DRM_STORE_CLEANUP_DELETE_EXPIRED_LICENSES       0x1
+#define DRM_STORE_CLEANUP_DELETE_REMOVAL_DATE_LICENSES  0x2
+
+/* Minimum OpaqueBuffer size. */
+#define MINIMUM_APPCONTEXT_OPAQUE_BUFFER_SIZE                  ( DRM_MAX_LICENSE_CHAIN_DEPTH * ( DRM_DWORD_ALIGNED_SIZE( DRM_STANDARD_PLAYREADYOBJSIZE ) + DRM_DWORD_ALIGNED_SIZE( DRM_MAX_LICENSESIZE ) ) )
+
+EXIT_PK_NAMESPACE;
+
+#endif /* __DRMMANAGERTYPES_H__ */
+
diff --git a/prebuilt-v4.4/noarch/include/drmmathsafe.h b/prebuilt-v4.4/noarch/include/drmmathsafe.h
new file mode 100644
index 0000000..adef819
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmmathsafe.h
@@ -0,0 +1,471 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __DRMMATHSAFE_H_
+#define __DRMMATHSAFE_H_ 1
+
+#include <drmtypes.h>
+#include <drmresults.h>
+#include <drmdebug.h>
+#include <drmerr.h>
+
+ENTER_PK_NAMESPACE;
+
+#if DRM_INLINING_MATHSAFE_SUPPORTED
+#define DRMMATHSAFEINLINE DRM_ALWAYS_INLINE
+#define DRMMATHSAFEINLINE_ATTRIBUTE DRM_ALWAYS_INLINE_ATTRIBUTE
+#else /* DRM_INLINING_MATHSAFE_SUPPORTED */
+#define DRMMATHSAFEINLINE DRM_NO_INLINE
+#define DRMMATHSAFEINLINE_ATTRIBUTE DRM_NO_INLINE_ATTRIBUTE
+#endif /* DRM_INLINING_MATHSAFE_SUPPORTED */
+
+/* Min values */
+#define DRM_LONG_MIN        ((DRM_LONG)(-2147483647 - 1))
+#define DRM_INT64_MIN       DRM_I64Asgn( 0x80000000, 0 )
+
+/* Max value */
+#define DRM_LONG_MAX        ((DRM_LONG)2147483647)
+#define DRM_INT64_MAX       DRM_I64Asgn( 0x7FFFFFFF, DRM_MAX_UNSIGNED_TYPE( DRM_DWORD ) )
+#define DRM_UINT64_MAX      DRM_UI64HL( DRM_MAX_UNSIGNED_TYPE( DRM_DWORD ), DRM_MAX_UNSIGNED_TYPE( DRM_DWORD ) )
+
+#define DRM_ByteIncOne( arg )       DRM_ByteAdd( (arg), 1, &(arg) )
+#define DRM_WordIncOne( arg )       DRM_WordAdd( (arg), 1, &(arg) )
+#define DRM_DWordIncOne( arg )      DRM_DWordAddSame( &(arg), 1 )
+
+#define DRM_ByteDecOne( arg )       DRM_ByteSub( (arg), 1, &(arg) )
+#define DRM_WordDecOne( arg )       DRM_WordSub( (arg), 1, &(arg) )
+#define DRM_DWordDecOne( arg )      DRM_DWordSubSame( &(arg), 1 )
+
+/* LONG -> SIZE_T conversion */
+#define DRM_LongToSizeT     DRM_LongToDWordPtr
+
+/* DWORD_PTR -> BYTE conversion */
+#if DRM_64BIT_TARGET
+#define DRM_DWordPtrToByte  DRM_UInt64ToByte
+#else /* DRM_64BIT_TARGET */
+#define DRM_DWordPtrToByte  DRM_DWordToByte
+#endif /* DRM_64BIT_TARGET */
+
+/* DWORD_PTR -> SHORT conversion */
+#if DRM_64BIT_TARGET
+#define DRM_DWordPtrToShort DRM_UInt64ToShort
+#else /* DRM_64BIT_TARGET */
+#define DRM_DWordPtrToShort DRM_DWordToShort
+#endif /* DRM_64BIT_TARGET */
+
+/* DWORD_PTR -> WORD conversion */
+#if DRM_64BIT_TARGET
+#define DRM_DWordPtrToWord  DRM_UInt64ToWord
+#else /* DRM_64BIT_TARGET */
+#define DRM_DWordPtrToWord  DRM_DWordToWord
+#endif /* DRM_64BIT_TARGET */
+
+/* DWORD_PTR -> LONG conversion */
+#if DRM_64BIT_TARGET
+#define DRM_DWordPtrToLong  DRM_UInt64ToLong
+#else /* DRM_64BIT_TARGET */
+#define DRM_DWORDPtrToLong  DRM_DWordToLong
+#endif /* DRM_64BIT_TARGET */
+
+/* DWORD_PTR -> DWORD conversion */
+#if DRM_64BIT_TARGET
+#define DRM_DWordPtrToDWord  DRM_UInt64ToDWord
+#endif /* DRM_64BIT_TARGET */
+
+/* SIZE_T -> BYTE conversion */
+#define DRM_SizeTToByte     DRM_DWordPtrToByte
+
+/* SIZE_T -> SHORT conversion */
+#define DRM_SizeTToShort    DRM_DWordPtrToShort
+
+/* SIZE_T -> WORD */
+#define DRM_SizeTToWord     DRM_DWordPtrToWord
+
+/* SIZE_T -> LONG conversion */
+#define DRM_SizeTToLong     DRM_DWordPtrToLong
+
+/* SIZE_T -> DWORD conversion */
+#define DRM_SizeTToDWord    DRM_DWordPtrToDWord
+
+/* INT64 -> DWORDPTR conversion */
+#if DRM_64BIT_TARGET
+#define DRM_Int64ToDWordPtr DRM_Int64ToUInt64
+#else /* DRM_64BIT_TARGET */
+#define DRM_Int64ToDWordPtr DRM_Int64ToDWord
+#endif /* DRM_64BIT_TARGET */
+
+/* INT64 -> SIZE_T conversion */
+#define DRM_Int64ToSizeT       DRM_Int64ToDWordPtr
+
+/* UINT64 -> DWORD_PTR conversion */
+#if !DRM_64BIT_TARGET
+#define DRM_UInt64ToDWordPtr  DRM_UInt64ToDWord
+#endif /* !DRM_64BIT_TARGET */
+
+/* UINT64 -> SIZE_T conversion */
+#define DRM_UInt64ToSizeT    DRM_UInt64ToDWordPtr
+
+/* DWORD_PTR addition */
+/*
+** When using DRM_DWordPtrAdd(), the offset should be multiplied
+** by the sizeof the object where the pointer points to.
+** Ex: A=B+C, where A and B are pointers and C is an offset
+** Should be DRM_DWordPtrAdd(B,C*sizeof(*B), A)
+*/
+#if DRM_64BIT_TARGET
+#define DRM_DWordPtrAdd       DRM_UInt64Add
+#define DRM_DWordPtrAddSame   DRM_UInt64AddSame
+#else /* DRM_64BIT_TARGET */
+#define DRM_DWordPtrAdd       DRM_DWordAdd
+#define DRM_DWordPtrAddSame   DRM_DWordAddSame
+#endif /* DRM_64BIT_TARGET */
+
+/* SIZE_T addition */
+#define DRM_SizeTAdd    DRM_DWordPtrAdd
+
+/* DWORD_PTR subtraction */
+/*
+** When using DRM_DWordPtrSub(), the offset should be multiplied
+** by the sizeof the object where the pointer points to.
+** Ex: A=B-C, where A and B are pointers and C is an offset
+** Should be DRM_DWordPtrSub(B,C*sizeof(*B), A)
+*/
+#if DRM_64BIT_TARGET
+#define DRM_DWordPtrSub    DRM_UInt64Sub
+#else /* DRM_64BIT_TARGET */
+#define DRM_DWordPtrSub    DRM_DWordSub
+#endif /* DRM_64BIT_TARGET */
+
+/* SIZE_T subtraction */
+#define DRM_SizeTSub       DRM_DWordPtrSub
+
+/* DWORD_PTR multiplication */
+#if DRM_64BIT_TARGET
+#define DRM_DWordPtrMult    DRM_UInt64Mult
+#else /* DRM_64BIT_TARGET */
+#define DRM_DWordPtrMult    DRM_DWordMult
+#endif /* DRM_64BIT_TARGET */
+
+/* SIZET multiplicaiton */
+#define DRM_SizeTMult       DRM_DWordPtrMult
+
+#if !DRM_INLINING_MATHSAFE_SUPPORTED
+
+/*=============================================================================
+** Conversion functions
+**
+** There are three reasons for having conversion functions:
+**
+** 1. We are converting from a signed type to an unsigned type of the same
+**    size, or vice-versa.
+**
+** 2. We are converting to a smaller type, and we could therefore possibly
+**    overflow.
+**
+** 3. We are converting to a bigger type, and we are signed and the type we are
+**    converting to is unsigned.
+**
+**=============================================================================
+*/
+
+/* WORD -> BYTE conversion */
+DRM_API DRMMATHSAFEINLINE DRM_RESULT DRM_CALL DRM_WordToByte(
+    __in                      DRM_WORD       f_wOperand,
+    __out_ecount(1)           DRM_BYTE      *f_pbResult ) DRMMATHSAFEINLINE_ATTRIBUTE;
+
+/* LONG -> BYTE conversion */
+DRM_API DRMMATHSAFEINLINE DRM_RESULT DRM_CALL DRM_LongToByte(
+    __in                      DRM_LONG       f_lOperand,
+    __out_ecount(1)           DRM_BYTE      *f_pbResult ) DRMMATHSAFEINLINE_ATTRIBUTE;
+
+/* LONG -> WORD conversion */
+DRM_API DRMMATHSAFEINLINE DRM_RESULT DRM_CALL DRM_LongToWord(
+    __in                      DRM_LONG       f_lOperand,
+    __out_ecount(1)           DRM_WORD      *f_pwResult ) DRMMATHSAFEINLINE_ATTRIBUTE;
+
+/* LONG -> DWORD conversion */
+DRM_API DRMMATHSAFEINLINE DRM_RESULT DRM_CALL DRM_LongToDWord(
+    __in                      DRM_LONG       lOperand,
+    __out_ecount(1)           DRM_DWORD     *f_pdwResult ) DRMMATHSAFEINLINE_ATTRIBUTE;
+
+/* LONG -> DWORD_PTR conversion */
+DRM_API DRMMATHSAFEINLINE DRM_RESULT DRM_CALL DRM_LongToDWordPtr(
+    __in                      DRM_LONG       f_lOperand,
+    __out_ecount(1)           DRM_SIZE_T    *f_pdwpResult ) DRMMATHSAFEINLINE_ATTRIBUTE;
+
+/* DWORD -> BYTE conversion */
+DRM_API DRMMATHSAFEINLINE DRM_RESULT DRM_CALL DRM_DWordToByte(
+    __in                      DRM_DWORD     f_dwOperand,
+    __out_ecount(1)           DRM_BYTE     *f_pbResult ) DRMMATHSAFEINLINE_ATTRIBUTE;
+
+/* DWORD -> WORD conversion */
+DRM_API DRMMATHSAFEINLINE DRM_RESULT DRM_CALL DRM_DWordToWord(
+    __in                      DRM_DWORD     f_dwOperand,
+    __out_ecount(1)           DRM_WORD     *f_pwResult ) DRMMATHSAFEINLINE_ATTRIBUTE;
+
+/* DWORD -> LONG conversion */
+DRM_API DRMMATHSAFEINLINE DRM_RESULT DRM_CALL DRM_DWordToLong(
+    __in                      DRM_DWORD     f_dwOperand,
+    __out_ecount(1)           DRM_LONG     *f_plResult ) DRMMATHSAFEINLINE_ATTRIBUTE;
+
+/* DWORD_PTR -> DWORD conversion */
+#if !DRM_64BIT_TARGET
+DRM_API DRMMATHSAFEINLINE DRM_RESULT DRM_CALL DRM_DWordPtrToDWord(
+    __in                      DRM_SIZE_T     f_dwpOperand,
+    __out_ecount(1)           DRM_DWORD     *f_pdwResult ) DRMMATHSAFEINLINE_ATTRIBUTE;
+#endif /* !DRM_64BIT_TARGET */
+
+/* INT64 -> WORD conversion */
+DRM_API DRMMATHSAFEINLINE DRM_RESULT DRM_CALL DRM_Int64ToWord(
+    __in                      DRM_INT64     f_i64Operand,
+    __out_ecount(1)           DRM_WORD     *f_pwResult ) DRMMATHSAFEINLINE_ATTRIBUTE;
+
+/* INT64 -> BYTE conversion */
+DRM_API DRMMATHSAFEINLINE DRM_RESULT DRM_CALL DRM_Int64ToByte(
+    __in                      DRM_INT64     f_i64Operand,
+    __out_ecount(1)           DRM_BYTE     *f_pbResult ) DRMMATHSAFEINLINE_ATTRIBUTE;
+
+/* INT64 -> LONG conversion */
+DRM_API DRMMATHSAFEINLINE DRM_RESULT DRM_CALL DRM_Int64ToLong(
+    __in                      DRM_INT64     f_i64Operand,
+    __out_ecount(1)           DRM_LONG     *f_plResult ) DRMMATHSAFEINLINE_ATTRIBUTE;
+
+/* INT64 -> DWORD conversion */
+DRM_API DRMMATHSAFEINLINE DRM_RESULT DRM_CALL DRM_Int64ToDWord(
+    __in                      DRM_INT64     f_i64Operand,
+    __out_ecount(1)           DRM_DWORD    *f_pdwResult ) DRMMATHSAFEINLINE_ATTRIBUTE;
+
+/* INT64 -> UINT64 conversion */
+DRM_API DRMMATHSAFEINLINE DRM_RESULT DRM_CALL DRM_Int64ToUInt64(
+    __in                      DRM_INT64     f_i64Operand,
+    __out_ecount(1)           DRM_UINT64   *f_pui64Result ) DRMMATHSAFEINLINE_ATTRIBUTE;
+
+/* UINT64 -> WORD conversion */
+DRM_API DRMMATHSAFEINLINE DRM_RESULT DRM_CALL DRM_UInt64ToWord(
+    __in                      DRM_UINT64     f_ui64Operand,
+    __out_ecount(1)           DRM_WORD      *f_pwResult ) DRMMATHSAFEINLINE_ATTRIBUTE;
+
+/* UINT64 -> BYTE conversion */
+DRM_API DRMMATHSAFEINLINE DRM_RESULT DRM_CALL DRM_UInt64ToByte(
+    __in                      DRM_UINT64     f_ui64Operand,
+    __out_ecount(1)           DRM_BYTE      *f_pbResult ) DRMMATHSAFEINLINE_ATTRIBUTE;
+
+/*  UINT64 -> LONG conversion */
+DRM_API DRMMATHSAFEINLINE DRM_RESULT DRM_CALL DRM_UInt64ToLong(
+    __in                      DRM_UINT64     f_ui64Operand,
+    __out_ecount(1)           DRM_LONG      *f_plResult ) DRMMATHSAFEINLINE_ATTRIBUTE;
+
+/* UINT64 -> DWORD conversion */
+DRM_API DRMMATHSAFEINLINE DRM_RESULT DRM_CALL DRM_UInt64ToDWord(
+    __in                                                                DRM_UINT64     f_ui64Operand,
+    __out_ecount( 1 ) _Post_satisfies_( *f_pdwResult == f_ui64Operand ) DRM_DWORD     *f_pdwResult ) DRMMATHSAFEINLINE_ATTRIBUTE;
+
+/* UINT64 -> DWORD_PTR conversion */
+#if DRM_64BIT_TARGET
+DRM_API DRMMATHSAFEINLINE DRM_RESULT DRM_CALL DRM_UInt64ToDWordPtr(
+    __in                      DRM_UINT64     f_ui64Operand,
+    __out_ecount(1)           DRM_SIZE_T    *f_pdwpResult ) DRMMATHSAFEINLINE_ATTRIBUTE;
+#endif /* DRM_64BIT_TARGET */
+
+/* UINT64 -> INT64 conversion */
+DRM_API DRMMATHSAFEINLINE DRM_RESULT DRM_CALL DRM_UInt64ToInt64(
+    __in                      DRM_UINT64     f_ui64Operand,
+    __out_ecount(1)           DRM_INT64     *f_pi64Result ) DRMMATHSAFEINLINE_ATTRIBUTE;
+
+/*
+** Addition functions
+**
+*/
+
+/* BYTE addition */
+DRM_API DRMMATHSAFEINLINE DRM_RESULT DRM_CALL DRM_ByteAdd(
+    __in                      DRM_BYTE       f_bAugend,
+    __in                      DRM_BYTE       f_bAddend,
+    __out_ecount(1)           DRM_BYTE      *f_pbResult ) DRMMATHSAFEINLINE_ATTRIBUTE;
+
+/* WORD addition */
+DRM_API DRMMATHSAFEINLINE DRM_RESULT DRM_CALL DRM_WordAdd(
+    __in                      DRM_WORD       f_wAugend,
+    __in                      DRM_WORD       f_wAddend,
+    __out_ecount(1)           DRM_WORD      *f_pwResult ) DRMMATHSAFEINLINE_ATTRIBUTE;
+
+/* DWORD addition */
+DRM_API DRMMATHSAFEINLINE DRM_RESULT DRM_CALL DRM_DWordAdd(
+    __in                                                                          DRM_DWORD       f_dwAugend,
+    __in                                                                          DRM_DWORD       f_dwAddend,
+    __out_ecount( 1 ) _Post_satisfies_( *f_pdwResult == f_dwAugend + f_dwAddend ) DRM_DWORD      *f_pdwResult ) DRMMATHSAFEINLINE_ATTRIBUTE;
+DRM_API DRMMATHSAFEINLINE DRM_RESULT DRM_CALL DRM_DWordAddSame(
+    __inout_ecount( 1 ) _Post_satisfies_( *f_pdwAugendResult == _Old_( *f_pdwAugendResult ) + f_dwAddend ) DRM_DWORD       *f_pdwAugendResult,
+    __in                                                                                                   DRM_DWORD        f_dwAddend ) DRMMATHSAFEINLINE_ATTRIBUTE;
+
+/* UINT64 addition */
+DRM_API DRMMATHSAFEINLINE DRM_RESULT DRM_CALL DRM_UInt64Add(
+    __in                                                                                DRM_UINT64       f_ui64Augend,
+    __in                                                                                DRM_UINT64       f_ui64Addend,
+#if DRM_SUPPORT_NATIVE_64BIT_TYPES
+    __out_ecount( 1 ) _Post_satisfies_( *f_pui64Result == f_ui64Augend + f_ui64Addend ) DRM_UINT64      *f_pui64Result )
+#else   /* DRM_SUPPORT_NATIVE_64BIT_TYPES */
+    __out_ecount( 1 )                                                                   DRM_UINT64      *f_pui64Result ) DRMMATHSAFEINLINE_ATTRIBUTE;
+#endif  /* DRM_SUPPORT_NATIVE_64BIT_TYPES */
+DRM_API DRMMATHSAFEINLINE DRM_RESULT DRM_CALL DRM_UInt64AddSame(
+#if DRM_SUPPORT_NATIVE_64BIT_TYPES
+    __inout_ecount( 1 ) _Post_satisfies_( *f_pui64AugendResult == _Old_( *f_pui64AugendResult ) + f_ui64Addend )    DRM_UINT64      *f_pui64AugendResult,
+#else   /* DRM_SUPPORT_NATIVE_64BIT_TYPES */
+    __inout_ecount( 1 )                                                                                             DRM_UINT64      *f_pui64AugendResult,
+#endif  /* DRM_SUPPORT_NATIVE_64BIT_TYPES */
+    __in                                                                                                            DRM_UINT64       f_ui64Addend ) DRMMATHSAFEINLINE_ATTRIBUTE;
+
+/*
+** Subtraction functions
+*/
+
+/* BYTE subtraction */
+DRM_API DRMMATHSAFEINLINE DRM_RESULT DRM_CALL DRM_ByteSub(
+    __in                      DRM_BYTE       f_bMinuend,
+    __in                      DRM_BYTE       f_bSubtrahend,
+    __out_ecount(1)           DRM_BYTE      *f_pbResult ) DRMMATHSAFEINLINE_ATTRIBUTE;
+
+/* WORD subtraction */
+DRM_API DRMMATHSAFEINLINE DRM_RESULT DRM_CALL DRM_WordSub(
+    __in                      DRM_WORD       f_wMinuend,
+    __in                      DRM_WORD       f_wSubtrahend,
+    __out_ecount(1)           DRM_WORD      *f_pwResult ) DRMMATHSAFEINLINE_ATTRIBUTE;
+
+/* DWORD subtraction */
+DRM_API DRMMATHSAFEINLINE DRM_RESULT DRM_CALL DRM_DWordSub(
+    __in                                                                               DRM_DWORD       f_dwMinuend,
+    __in                                                                               DRM_DWORD       f_dwSubtrahend,
+    __out_ecount( 1 ) _Post_satisfies_( *f_pdwResult == f_dwMinuend - f_dwSubtrahend ) DRM_DWORD      *f_pdwResult ) DRMMATHSAFEINLINE_ATTRIBUTE;
+
+DRM_API DRMMATHSAFEINLINE DRM_RESULT DRM_CALL DRM_DWordSubSame(
+    __inout_ecount( 1 ) _Post_satisfies_( *f_pdwMinuend == _Old_( *f_pdwMinuend ) - f_dwSubtrahend ) DRM_DWORD      *f_pdwMinuend,
+    __in                                                                                             DRM_DWORD       f_dwSubtrahend ) DRMMATHSAFEINLINE_ATTRIBUTE;
+
+/* UINT64 subtraction */
+DRM_API DRMMATHSAFEINLINE DRM_RESULT DRM_CALL DRM_UInt64Sub(
+    __in                      DRM_UINT64       f_ui64Minuend,
+    __in                      DRM_UINT64       f_ui64Subtrahend,
+    __out_ecount(1)           DRM_UINT64      *f_pui64Result ) DRMMATHSAFEINLINE_ATTRIBUTE;
+
+/*
+** Multiplication functions
+*/
+
+/* WORD multiplication */
+DRM_API DRMMATHSAFEINLINE DRM_RESULT DRM_CALL DRM_WordMult(
+    __in                      DRM_WORD       f_wMultiplicand,
+    __in                      DRM_WORD       f_wMultiplier,
+    __out_ecount(1)           DRM_WORD      *f_pwResult ) DRMMATHSAFEINLINE_ATTRIBUTE;
+
+/* DWORD multiplication */
+DRM_API DRMMATHSAFEINLINE DRM_RESULT DRM_CALL DRM_DWordMult(
+    __in                                                                                    DRM_DWORD       f_dwMultiplicand,
+    __in                                                                                    DRM_DWORD       f_dwMultiplier,
+    __out_ecount( 1 ) _Post_satisfies_( *f_pdwResult == f_dwMultiplicand * f_dwMultiplier ) DRM_DWORD      *f_pdwResult ) DRMMATHSAFEINLINE_ATTRIBUTE;
+
+/* UINT64 multiplication */
+DRM_API DRMMATHSAFEINLINE DRM_RESULT DRM_UInt64Mult(
+    __in                      DRM_UINT64       f_ui64Multiplicand,
+    __in                      DRM_UINT64       f_ui64Multiplier,
+    __out_ecount(1)           DRM_UINT64      *f_pui64Result ) DRMMATHSAFEINLINE_ATTRIBUTE;
+
+/*
+**
+** signed operations
+**
+** Strongly consider using unsigned numbers.
+**
+** Signed numbers are often used where unsigned numbers should be used.
+** For example file sizes and array indices should always be unsigned.
+** (File sizes should be 64bit integers; array indices should be SIZE_T.)
+** Subtracting a larger positive signed number from a smaller positive
+** signed number with IntSubwill succeed, producing a negative number,
+** that then must not be used as an array index (but can occasionally be
+** used as a pointer index.) Similarly for adding a larger magnitude
+** negative number to a smaller magnitude positive number.
+**
+** drmmathsafe.h does not protect you from such errors. It tells you if your
+** integer operations overflowed, not if you are doing the right thing
+** with your non-overflowed integers.
+**
+** Likewise you can overflow a buffer with a non-overflowed unsigned index.
+*/
+
+/*
+** Signed addition functions
+*/
+
+/* LONG Addition */
+DRM_API DRMMATHSAFEINLINE DRM_RESULT DRM_CALL DRM_LongAdd(
+    __in                      DRM_LONG       f_lAugend,
+    __in                      DRM_LONG       f_lAddend,
+    __out_ecount(1)           DRM_LONG      *f_plResult ) DRMMATHSAFEINLINE_ATTRIBUTE;
+
+
+/* INT64 Addition */
+/*
+** The logic for this 64-bit integer operation is non-trivial
+** when compiler optimizations are taken into account.
+** We have no need to support it, so we don't. No definition is provided
+*/
+DRM_API DRMMATHSAFEINLINE DRM_RESULT DRM_CALL DRM_Int64Add(
+    __in                      DRM_INT64       f_i64Augend,
+    __in                      DRM_INT64       f_i64Addend,
+    __out_ecount(1)           DRM_INT64      *f_pi64Result ) DRMMATHSAFEINLINE_ATTRIBUTE;
+
+/*
+** Signed subtraction functions
+*/
+
+/* LONG Subtraction */
+DRM_API DRMMATHSAFEINLINE DRM_RESULT DRM_CALL DRM_LongSub(
+    __in                      DRM_LONG       f_lMinuend,
+    __in                      DRM_LONG       f_lSubtrahend,
+    __out_ecount(1)           DRM_LONG      *f_plResult ) DRMMATHSAFEINLINE_ATTRIBUTE;
+
+/* INT64 Subtraction */
+/*
+** The logic for this 64-bit integer operation is non-trivial
+** when compiler optimizations are taken into account.
+** We have no need to support it, so we don't. No definition is provided
+*/
+DRM_API DRMMATHSAFEINLINE DRM_RESULT DRM_CALL DRM_Int64Sub(
+    __in                      DRM_INT64       f_i64Minuend,
+    __in                      DRM_INT64       f_i64Subtrahend,
+    __out_ecount(1)           DRM_INT64      *f_pi64Result ) DRMMATHSAFEINLINE_ATTRIBUTE;
+
+/*
+** Signed multiplication functions
+*/
+
+/* LONG multiplication */
+DRM_API DRMMATHSAFEINLINE DRM_RESULT DRM_CALL DRM_LongMult(
+    __in                      DRM_LONG       f_lMultiplicand,
+    __in                      DRM_LONG       f_lMultiplier,
+    __out_ecount(1)           DRM_LONG      *f_plResult ) DRMMATHSAFEINLINE_ATTRIBUTE;
+
+/* INT64 multiplication */
+/*
+** The logic for this 64-bit integer operation is non-trivial
+** when compiler optimizations are taken into account.
+** We have no need to support it, so we don't. No definition is provided
+*/
+DRM_API DRMMATHSAFEINLINE DRM_RESULT DRM_Int64Mult(
+    __in                      DRM_INT64       f_i64Multiplicand,
+    __in                      DRM_INT64       f_i64Multiplier,
+    __out_ecount(1)           DRM_INT64      *f_pi64Result ) DRMMATHSAFEINLINE_ATTRIBUTE;
+
+#endif /* !DRM_INLINING_MATHSAFE_SUPPORTED */
+EXIT_PK_NAMESPACE;
+
+#if DRM_INLINING_MATHSAFE_SUPPORTED
+#include "drmmathsafe_impl.h"
+#endif /* DRM_INLINING_MATHSAFE_SUPPORTED */
+
+#endif /* __DRMMATHSAFE_H_ */
+
diff --git a/prebuilt-v4.4/noarch/include/drmmathsafe_impl.h b/prebuilt-v4.4/noarch/include/drmmathsafe_impl.h
new file mode 100644
index 0000000..d5f1ea0
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmmathsafe_impl.h
@@ -0,0 +1,1049 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#define DRM_BUILDING_DRMMATHSAFE_C
+
+/* Declare intrinsics for Microsoft compilers */
+#if (defined(_M_AMD64) && defined(DRM_MSC_VER) && !defined(DRM_GNUC_MAJOR) && DRM_SUPPORT_NATIVE_64BIT_TYPES && DRM_64BIT_TARGET)
+#define DRMMATHSAFEUSEINTRINSICS 1
+#ifdef __cplusplus
+extern "C"
+{
+#endif /* __cplusplus */
+__checkReturn unsigned __int64 __cdecl _umul128(__in unsigned __int64 Multiplier, __in unsigned __int64 Multiplicand, __out unsigned __int64 *HighProduct);
+#ifdef __cplusplus
+} /* extern "C"*/
+#endif /* __cplusplus */
+PRAGMA_INTRINSIC(_umul128)
+#endif  /* ((defined(_M_IX86) || defined(_M_AMD64)) && !defined(DRM_GNUC_MAJOR) && DRM_SUPPORT_NATIVE_64BIT_TYPES) */
+
+ENTER_PK_NAMESPACE_CODE;
+
+/* WORD -> BYTE conversion */
+DRM_API DRMMATHSAFEINLINE DRM_RESULT DRM_CALL DRM_WordToByte(
+    __in                      DRM_WORD       f_wOperand,
+    __out_ecount(1)           DRM_BYTE      *f_pbResult )
+{
+    DRM_RESULT dr = DRM_SUCCESS;
+
+    DRMASSERT( f_pbResult != NULL );
+    __analysis_assume( f_pbResult != NULL );
+
+    if( DRM_LIKELY( f_wOperand <= DRM_MAX_UNSIGNED_TYPE(DRM_BYTE) ) )
+    {
+        *f_pbResult = (DRM_BYTE)f_wOperand;
+    }
+    else
+    {
+        /*
+        ** Initialize out value to ensure that failure
+        ** to check return value doesn't result in buffer
+        ** overflow if value is then used as pointer offset.
+        */
+        *f_pbResult = (DRM_BYTE)0;
+        dr = DRM_E_ARITHMETIC_OVERFLOW;
+    }
+
+    return dr;
+}
+
+/* LONG -> BYTE conversion */
+DRM_API DRMMATHSAFEINLINE DRM_RESULT DRM_CALL DRM_LongToByte(
+    __in                      DRM_LONG       f_lOperand,
+    __out_ecount(1)           DRM_BYTE      *f_pbResult )
+{
+    DRM_RESULT dr = DRM_SUCCESS;
+
+    DRMASSERT( f_pbResult != NULL );
+    __analysis_assume( f_pbResult != NULL );
+
+    if( DRM_LIKELY( ( 0 <= f_lOperand ) && ( f_lOperand <= DRM_MAX_UNSIGNED_TYPE(DRM_BYTE) ) ) )
+    {
+        *f_pbResult = (DRM_BYTE)f_lOperand;
+    }
+    else
+    {
+        /*
+        ** Initialize out value to ensure that failure
+        ** to check return value doesn't result in buffer
+        ** overflow if value is then used as pointer offset.
+        */
+        *f_pbResult = (DRM_BYTE)0;
+        dr = DRM_E_ARITHMETIC_OVERFLOW;
+    }
+
+    return dr;
+}
+
+/* LONG -> WORD conversion */
+DRM_API DRMMATHSAFEINLINE DRM_RESULT DRM_CALL DRM_LongToWord(
+    __in                      DRM_LONG       f_lOperand,
+    __out_ecount(1)           DRM_WORD      *f_pwResult )
+{
+    DRM_RESULT dr = DRM_SUCCESS;
+
+    DRMASSERT( f_pwResult != NULL );
+    __analysis_assume( f_pwResult != NULL );
+
+    if( DRM_LIKELY( ( 0 <= f_lOperand ) && ( f_lOperand <= DRM_MAX_UNSIGNED_TYPE(DRM_WORD) ) ) )
+    {
+        *f_pwResult = (DRM_WORD)f_lOperand;
+    }
+    else
+    {
+        /*
+        ** Initialize out value to ensure that failure
+        ** to check return value doesn't result in buffer
+        ** overflow if value is then used as pointer offset.
+        */
+        *f_pwResult = (DRM_WORD)0;
+        dr = DRM_E_ARITHMETIC_OVERFLOW;
+    }
+
+    return dr;
+}
+
+/* LONG -> DWORD conversion */
+DRM_API DRMMATHSAFEINLINE DRM_RESULT DRM_CALL DRM_LongToDWord(
+    __in                      DRM_LONG       f_lOperand,
+    __out_ecount(1)           DRM_DWORD     *f_pdwResult )
+{
+    DRM_RESULT dr = DRM_SUCCESS;
+
+    DRMASSERT( f_pdwResult != NULL );
+    __analysis_assume( f_pdwResult != NULL );
+
+    if( DRM_LIKELY( f_lOperand >= 0 ) )
+    {
+        *f_pdwResult = (DRM_DWORD)f_lOperand;
+    }
+    else
+    {
+        /*
+        ** Initialize out value to ensure that failure
+        ** to check return value doesn't result in buffer
+        ** overflow if value is then used as pointer offset.
+        */
+        *f_pdwResult = (DRM_DWORD)0;
+        dr = DRM_E_ARITHMETIC_OVERFLOW;
+    }
+
+    return dr;
+}
+
+/* LONG -> DWORD_PTR conversion */
+DRM_API DRMMATHSAFEINLINE DRM_RESULT DRM_CALL DRM_LongToDWordPtr(
+    __in                      DRM_LONG       f_lOperand,
+    __out_ecount(1)           DRM_SIZE_T    *f_pdwpResult )
+{
+    DRM_RESULT dr = DRM_SUCCESS;
+
+    DRMASSERT( f_pdwpResult != NULL );
+    __analysis_assume( f_pdwpResult != NULL );
+
+    if( DRM_LIKELY( f_lOperand >= 0 ) )
+    {
+        *f_pdwpResult = (DRM_SIZE_T)f_lOperand;
+    }
+    else
+    {
+        /*
+        ** Initialize out value to ensure that failure
+        ** to check return value doesn't result in buffer
+        ** overflow if value is then used as pointer offset.
+        */
+        *f_pdwpResult = (DRM_SIZE_T)0;
+        dr = DRM_E_ARITHMETIC_OVERFLOW;
+    }
+
+    return dr;
+}
+
+/* DWORD -> BYTE conversion */
+DRM_API DRMMATHSAFEINLINE DRM_RESULT DRM_CALL DRM_DWordToByte(
+    __in                      DRM_DWORD     f_dwOperand,
+    __out_ecount(1)           DRM_BYTE     *f_pbResult )
+{
+    DRM_RESULT dr = DRM_SUCCESS;
+
+    DRMASSERT( f_pbResult != NULL );
+    __analysis_assume( f_pbResult != NULL );
+
+    if( DRM_LIKELY( f_dwOperand <= DRM_MAX_UNSIGNED_TYPE(DRM_BYTE) ) )
+    {
+        *f_pbResult = (DRM_BYTE)f_dwOperand;
+    }
+    else
+    {
+        /*
+        ** Initialize out value to ensure that failure
+        ** to check return value doesn't result in buffer
+        ** overflow if value is then used as pointer offset.
+        */
+        *f_pbResult = (DRM_BYTE)0;
+        dr = DRM_E_ARITHMETIC_OVERFLOW;
+    }
+
+    return dr;
+}
+
+/* DWORD -> WORD conversion */
+DRM_API DRMMATHSAFEINLINE DRM_RESULT DRM_CALL DRM_DWordToWord(
+    __in                      DRM_DWORD     f_dwOperand,
+    __out_ecount(1)           DRM_WORD     *f_pwResult )
+{
+    DRM_RESULT dr = DRM_SUCCESS;
+
+    DRMASSERT( f_pwResult != NULL );
+    __analysis_assume( f_pwResult != NULL );
+
+    if( DRM_LIKELY( f_dwOperand <= DRM_MAX_UNSIGNED_TYPE(DRM_WORD) ) )
+    {
+        *f_pwResult = (DRM_WORD)f_dwOperand;
+    }
+    else
+    {
+        /*
+        ** Initialize out value to ensure that failure
+        ** to check return value doesn't result in buffer
+        ** overflow if value is then used as pointer offset.
+        */
+        *f_pwResult = (DRM_WORD)0;
+        dr = DRM_E_ARITHMETIC_OVERFLOW;
+    }
+    return dr;
+}
+
+/* DWORD -> LONG conversion */
+DRM_API DRMMATHSAFEINLINE DRM_RESULT DRM_CALL DRM_DWordToLong(
+    __in                      DRM_DWORD     f_dwOperand,
+    __out_ecount(1)           DRM_LONG     *f_plResult )
+{
+    DRM_RESULT dr = DRM_SUCCESS;
+
+    DRMASSERT( f_plResult != NULL );
+    __analysis_assume( f_plResult != NULL );
+
+    if( DRM_LIKELY( f_dwOperand <= DRM_LONG_MAX ) )
+    {
+        *f_plResult = (DRM_LONG)f_dwOperand;
+    }
+    else
+    {
+        /*
+        ** Initialize out value to ensure that failure
+        ** to check return value doesn't result in buffer
+        ** overflow if value is then used as pointer offset.
+        */
+        *f_plResult = (DRM_LONG)0;
+        dr = DRM_E_ARITHMETIC_OVERFLOW;
+    }
+
+    return dr;
+}
+
+/* DWORD_PTR -> DWORD conversion */
+#if !DRM_64BIT_TARGET
+DRM_API DRMMATHSAFEINLINE DRM_RESULT DRM_CALL DRM_DWordPtrToDWord(
+    __in                      DRM_SIZE_T     f_dwpOperand,
+    __out_ecount(1)           DRM_DWORD     *f_pdwResult )
+{
+    DRMASSERT( f_pdwResult != NULL );
+    __analysis_assume( f_pdwResult != NULL );
+
+    *f_pdwResult = (DRM_DWORD)f_dwpOperand;
+    return DRM_SUCCESS;
+}
+#endif /* !DRM_64BIT_TARGET */
+
+/* INT64 -> WORD conversion */
+DRM_API DRMMATHSAFEINLINE DRM_RESULT DRM_CALL DRM_Int64ToWord(
+    __in                      DRM_INT64     f_i64Operand,
+    __out_ecount(1)           DRM_WORD     *f_pwResult )
+{
+    DRM_RESULT dr = DRM_SUCCESS;
+
+    DRMASSERT( f_pwResult != NULL );
+    __analysis_assume( f_pwResult != NULL );
+
+    if( DRM_LIKELY( DRM_I64GEq( f_i64Operand, DRM_I64Asgn( 0, 0 ) )
+                 && DRM_I64LEq( f_i64Operand, DRM_I64Asgn( 0, DRM_MAX_UNSIGNED_TYPE(DRM_WORD) ) ) ) )
+    {
+        *f_pwResult = (DRM_WORD)DRM_I64Low32( f_i64Operand );
+    }
+    else
+    {
+        /*
+        ** Initialize out value to ensure that failure
+        ** to check return value doesn't result in buffer
+        ** overflow if value is then used as pointer offset.
+        */
+        *f_pwResult = (DRM_WORD)0;
+        dr = DRM_E_ARITHMETIC_OVERFLOW;
+    }
+
+    return dr;
+}
+
+/* INT64 -> BYTE conversion */
+DRM_API DRMMATHSAFEINLINE DRM_RESULT DRM_CALL DRM_Int64ToByte(
+    __in                      DRM_INT64     f_i64Operand,
+    __out_ecount(1)           DRM_BYTE     *f_pbResult )
+{
+    DRM_RESULT dr = DRM_SUCCESS;
+
+    DRMASSERT( f_pbResult != NULL );
+    __analysis_assume( f_pbResult != NULL );
+
+    if( DRM_LIKELY( DRM_I64GEq( f_i64Operand, DRM_I64Asgn( 0, 0 ) )
+                 && DRM_I64LEq( f_i64Operand, DRM_I64Asgn( 0, DRM_MAX_UNSIGNED_TYPE(DRM_BYTE) ) ) ) )
+    {
+        *f_pbResult = (DRM_BYTE)DRM_I64Low32( f_i64Operand );
+    }
+    else
+    {
+        /*
+        ** Initialize out value to ensure that failure
+        ** to check return value doesn't result in buffer
+        ** overflow if value is then used as pointer offset.
+        */
+        *f_pbResult = (DRM_BYTE)0;
+        dr = DRM_E_ARITHMETIC_OVERFLOW;
+    }
+
+    return dr;
+}
+
+/* INT64 -> LONG conversion */
+DRM_API DRMMATHSAFEINLINE DRM_RESULT DRM_CALL DRM_Int64ToLong(
+    __in                      DRM_INT64     f_i64Operand,
+    __out_ecount(1)           DRM_LONG     *f_plResult )
+{
+    DRM_RESULT dr = DRM_SUCCESS;
+
+    DRMASSERT( f_plResult != NULL );
+    __analysis_assume( f_plResult != NULL );
+
+    if( DRM_LIKELY( DRM_I64GEq( f_i64Operand, DRM_I64( DRM_LONG_MIN ) )
+                 && DRM_I64LEq( f_i64Operand, DRM_I64( DRM_LONG_MAX ) ) ) )
+    {
+        *f_plResult = (DRM_LONG)DRM_I64Low32( f_i64Operand );
+    }
+    else
+    {
+        /*
+        ** Initialize out value to ensure that failure
+        ** to check return value doesn't result in buffer
+        ** overflow if value is then used as pointer offset.
+        */
+        *f_plResult = (DRM_LONG)0;
+        dr = DRM_E_ARITHMETIC_OVERFLOW;
+    }
+
+    return dr;
+}
+
+/* INT64 -> DWORD conversion */
+DRM_API DRMMATHSAFEINLINE DRM_RESULT DRM_CALL DRM_Int64ToDWord(
+    __in                      DRM_INT64     f_i64Operand,
+    __out_ecount(1)           DRM_DWORD    *f_pdwResult )
+{
+    DRM_RESULT dr = DRM_SUCCESS;
+
+    DRMASSERT( f_pdwResult != NULL );
+    __analysis_assume( f_pdwResult != NULL );
+
+    if( DRM_LIKELY( DRM_I64GEq( f_i64Operand, DRM_I64Asgn( 0, 0 ) )
+                 && DRM_I64LEq( f_i64Operand, DRM_I64Asgn( 0, DRM_MAX_UNSIGNED_TYPE(DRM_DWORD) ) ) ) )
+    {
+        *f_pdwResult = (DRM_DWORD)DRM_I64ToUI32( f_i64Operand );
+    }
+    else
+    {
+        /*
+        ** Initialize out value to ensure that failure
+        ** to check return value doesn't result in buffer
+        ** overflow if value is then used as pointer offset.
+        */
+        *f_pdwResult = (DRM_DWORD)0;
+        dr = DRM_E_ARITHMETIC_OVERFLOW;
+    }
+
+    return dr;
+}
+
+/* INT64 -> UINT64 conversion */
+DRM_API DRMMATHSAFEINLINE DRM_RESULT DRM_CALL DRM_Int64ToUInt64(
+    __in                      DRM_INT64     f_i64Operand,
+    __out_ecount(1)           DRM_UINT64   *f_pui64Result )
+{
+    DRM_RESULT dr = DRM_SUCCESS;
+
+    DRMASSERT( f_pui64Result != NULL );
+    __analysis_assume( f_pui64Result != NULL );
+
+    if( DRM_LIKELY( DRM_I64GEq( f_i64Operand, DRM_I64Asgn( 0, 0 ) ) ) )
+    {
+        *f_pui64Result = DRM_I2UI64( f_i64Operand );
+    }
+    else
+    {
+        *f_pui64Result = DRM_UI64HL( (DRM_DWORD)0, (DRM_DWORD)0 );
+        dr = DRM_E_ARITHMETIC_OVERFLOW;
+    }
+
+    return dr;
+}
+
+/* UINT64 -> WORD conversion */
+DRM_API DRMMATHSAFEINLINE DRM_RESULT DRM_CALL DRM_UInt64ToWord(
+    __in                      DRM_UINT64     f_ui64Operand,
+    __out_ecount(1)           DRM_WORD      *f_pwResult )
+{
+    DRM_RESULT dr = DRM_SUCCESS;
+
+    DRMASSERT( f_pwResult != NULL );
+    __analysis_assume( f_pwResult != NULL );
+
+    if( DRM_LIKELY( DRM_UI64LEq( f_ui64Operand, DRM_UI64HL( 0, DRM_MAX_UNSIGNED_TYPE(DRM_WORD) ) ) ) )
+    {
+        *f_pwResult = (DRM_WORD)DRM_UI64Low32( f_ui64Operand );
+    }
+    else
+    {
+        /*
+        ** Initialize out value to ensure that failure
+        ** to check return value doesn't result in buffer
+        ** overflow if value is then used as pointer offset.
+        */
+        *f_pwResult = (DRM_WORD)0;
+        dr = DRM_E_ARITHMETIC_OVERFLOW;
+    }
+
+    return dr;
+}
+
+/* UINT64 -> BYTE conversion */
+DRM_API DRMMATHSAFEINLINE DRM_RESULT DRM_CALL DRM_UInt64ToByte(
+    __in                      DRM_UINT64     f_ui64Operand,
+    __out_ecount(1)           DRM_BYTE      *f_pbResult )
+{
+    DRM_RESULT dr = DRM_SUCCESS;
+
+    DRMASSERT( f_pbResult != NULL );
+    __analysis_assume( f_pbResult != NULL );
+
+    if( DRM_LIKELY( DRM_UI64LEq( f_ui64Operand, DRM_UI64HL( 0, DRM_MAX_UNSIGNED_TYPE(DRM_BYTE) ) ) ) )
+    {
+        *f_pbResult = (DRM_BYTE)DRM_UI64Low32( f_ui64Operand );
+    }
+    else
+    {
+        /*
+        ** Initialize out value to ensure that failure
+        ** to check return value doesn't result in buffer
+        ** overflow if value is then used as pointer offset.
+        */
+        *f_pbResult = (DRM_BYTE)0;
+        dr = DRM_E_ARITHMETIC_OVERFLOW;
+    }
+
+    return dr;
+}
+
+/*  UINT64 -> LONG conversion */
+DRM_API DRMMATHSAFEINLINE DRM_RESULT DRM_CALL DRM_UInt64ToLong(
+    __in                      DRM_UINT64     f_ui64Operand,
+    __out_ecount(1)           DRM_LONG      *f_plResult )
+{
+    DRM_RESULT dr = DRM_SUCCESS;
+
+    DRMASSERT( f_plResult != NULL );
+    __analysis_assume( f_plResult != NULL );
+
+    if( DRM_LIKELY( DRM_UI64LEq( f_ui64Operand, DRM_UI64HL( 0, DRM_LONG_MAX ) ) ) )
+    {
+        *f_plResult = (DRM_LONG)DRM_UI64Low32( f_ui64Operand );
+    }
+    else
+    {
+        /*
+        ** Initialize out value to ensure that failure
+        ** to check return value doesn't result in buffer
+        ** overflow if value is then used as pointer offset.
+        */
+        *f_plResult = (DRM_LONG)0;
+        dr = DRM_E_ARITHMETIC_OVERFLOW;
+    }
+
+    return dr;
+}
+
+/* UINT64 -> DWORD conversion */
+DRM_API DRMMATHSAFEINLINE DRM_RESULT DRM_CALL DRM_UInt64ToDWord(
+    __in                                                                DRM_UINT64     f_ui64Operand,
+    __out_ecount( 1 ) _Post_satisfies_( *f_pdwResult == f_ui64Operand ) DRM_DWORD     *f_pdwResult )
+{
+    DRMASSERT( f_pdwResult != NULL );
+    __analysis_assume( f_pdwResult != NULL );
+
+    if( DRM_LIKELY( DRM_UI64High32(f_ui64Operand) == 0 ) )
+    {
+        *f_pdwResult = DRM_UI64Low32( f_ui64Operand );
+#if DRM_SUPPORT_NATIVE_64BIT_TYPES
+        __analysis_assume( *f_pdwResult == f_ui64Operand );
+#endif  /* DRM_SUPPORT_NATIVE_64BIT_TYPES */
+        return DRM_SUCCESS;
+    }
+    else
+    {
+        /*
+        ** Initialize out value to ensure that failure
+        ** to check return value doesn't result in buffer
+        ** overflow if value is then used as pointer offset.
+        */
+        *f_pdwResult = (DRM_DWORD)0;
+        return DRM_E_ARITHMETIC_OVERFLOW;
+    }
+}
+
+/* UINT64 -> DWORD_PTR conversion */
+#if DRM_64BIT_TARGET
+DRM_API DRMMATHSAFEINLINE DRM_RESULT DRM_CALL DRM_UInt64ToDWordPtr(
+    __in                      DRM_UINT64     f_ui64Operand,
+    __out_ecount(1)           DRM_SIZE_T    *f_pdwpResult )
+{
+    DRMASSERT( f_pdwpResult != NULL );
+    __analysis_assume( f_pdwpResult != NULL );
+
+    DRMSIZEASSERT( sizeof( DRM_SIZE_T ), sizeof( DRM_UINT64 ) );
+    *f_pdwpResult = (DRM_SIZE_T)f_ui64Operand;
+    return DRM_SUCCESS;
+}
+#endif /* DRM_64BIT_TARGET */
+
+/* UINT64 -> INT64 conversion */
+DRM_API DRMMATHSAFEINLINE DRM_RESULT DRM_CALL DRM_UInt64ToInt64(
+    __in                      DRM_UINT64     f_ui64Operand,
+    __out_ecount(1)           DRM_INT64     *f_pi64Result )
+{
+    DRM_RESULT dr        = DRM_SUCCESS;
+
+    DRMASSERT( f_pi64Result != NULL );
+    __analysis_assume( f_pi64Result != NULL );
+
+    if( DRM_LIKELY( DRM_UI64High32( f_ui64Operand ) <= DRM_LONG_MAX ) )
+    {
+        *f_pi64Result = DRM_UI2I64( f_ui64Operand );
+    }
+    else
+    {
+        *f_pi64Result = DRM_I64Asgn( 0, 0 );
+        dr = DRM_E_ARITHMETIC_OVERFLOW;
+    }
+
+    return dr;
+}
+
+/*
+** Addition functions
+*/
+
+/* BYTE addition */
+DRM_API DRMMATHSAFEINLINE DRM_RESULT DRM_CALL DRM_ByteAdd(
+    __in                      DRM_BYTE       f_bAugend,
+    __in                      DRM_BYTE       f_bAddend,
+    __out_ecount(1)           DRM_BYTE      *f_pbResult )
+{
+    DRM_DWORD  dwResult = ((DRM_DWORD)f_bAugend) + ((DRM_DWORD)f_bAddend);
+
+    DRMASSERT( f_pbResult != NULL );
+    __analysis_assume( f_pbResult != NULL );
+
+    return DRM_DWordToByte( dwResult, f_pbResult );
+}
+
+/* WORD addition */
+DRM_API DRMMATHSAFEINLINE DRM_RESULT DRM_CALL DRM_WordAdd(
+    __in                      DRM_WORD       f_wAugend,
+    __in                      DRM_WORD       f_wAddend,
+    __out_ecount(1)           DRM_WORD      *f_pwResult )
+{
+    DRM_DWORD  dwResult = ((DRM_DWORD)f_wAugend) + ((DRM_DWORD)f_wAddend);
+
+    DRMASSERT( f_pwResult != NULL );
+    __analysis_assume( f_pwResult != NULL );
+
+    return DRM_DWordToWord( dwResult, f_pwResult );
+}
+
+/* UINT64 addition */
+DRM_API DRMMATHSAFEINLINE DRM_RESULT DRM_CALL DRM_UInt64Add(
+    __in                                                                                DRM_UINT64       f_ui64Augend,
+    __in                                                                                DRM_UINT64       f_ui64Addend,
+#if DRM_SUPPORT_NATIVE_64BIT_TYPES
+    __out_ecount( 1 ) _Post_satisfies_( *f_pui64Result == f_ui64Augend + f_ui64Addend ) DRM_UINT64      *f_pui64Result )
+#else   /* DRM_SUPPORT_NATIVE_64BIT_TYPES */
+    __out_ecount( 1 )                                                                   DRM_UINT64      *f_pui64Result )
+#endif  /* DRM_SUPPORT_NATIVE_64BIT_TYPES */
+{
+    DRM_RESULT dr             = DRM_SUCCESS;
+    DRM_UINT64 ui64ResultLow  = DRM_UI64Add( DRM_UI64HL( 0, DRM_UI64Low32( f_ui64Augend ) ),  DRM_UI64HL( 0, DRM_UI64Low32( f_ui64Addend ) ) );
+    DRM_UINT64 ui64ResultHigh = DRM_UI64Add( DRM_UI64HL( 0, DRM_UI64High32( f_ui64Augend ) ), DRM_UI64HL( 0, DRM_UI64High32( f_ui64Addend ) ) );
+
+    /* Fold any carry into high order dword */
+    ui64ResultHigh = DRM_UI64Add( ui64ResultHigh, DRM_UI64HL( 0, DRM_UI64High32( ui64ResultLow ) ) );
+
+    DRMASSERT( f_pui64Result != NULL );
+    __analysis_assume( f_pui64Result != NULL );
+
+    /* If the high order dword add(s) didn't carry, i.e. are zero, then we did not overflow */
+    if( DRM_LIKELY( DRM_UI64High32( ui64ResultHigh ) == 0 ) )
+    {
+        *f_pui64Result = DRM_UI64HL( DRM_UI64Low32( ui64ResultHigh ), DRM_UI64Low32( ui64ResultLow ) );
+#if DRM_SUPPORT_NATIVE_64BIT_TYPES
+        __analysis_assume( *f_pui64Result == f_ui64Augend + f_ui64Addend );
+#endif  /* DRM_SUPPORT_NATIVE_64BIT_TYPES */
+    }
+    else
+    {
+        *f_pui64Result = DRM_UI64HL( 0, 0 );
+        dr = DRM_E_ARITHMETIC_OVERFLOW;
+    }
+
+    return dr;
+}
+
+DRM_API DRMMATHSAFEINLINE DRM_RESULT DRM_CALL DRM_UInt64AddSame(
+#if DRM_SUPPORT_NATIVE_64BIT_TYPES
+    __inout_ecount( 1 ) _Post_satisfies_( *f_pui64AugendResult == _Old_( *f_pui64AugendResult ) + f_ui64Addend )    DRM_UINT64      *f_pui64AugendResult,
+#else   /* DRM_SUPPORT_NATIVE_64BIT_TYPES */
+    __inout_ecount( 1 )                                                                                             DRM_UINT64      *f_pui64AugendResult,
+#endif  /* DRM_SUPPORT_NATIVE_64BIT_TYPES */
+    __in                                                                                                            DRM_UINT64       f_ui64Addend )
+{
+    DRM_RESULT dr                = DRM_SUCCESS;
+    DRM_UINT64 ui64ResultLow;   /* Initialized later by DRM_UI64Add */
+    DRM_UINT64 ui64ResultHigh;  /* Initialized later by DRM_UI64Add */
+
+    DRMASSERT( f_pui64AugendResult != NULL );
+    __analysis_assume( f_pui64AugendResult != NULL );
+
+    ui64ResultLow  = DRM_UI64Add( DRM_UI64HL( 0, DRM_UI64Low32( *f_pui64AugendResult ) ),  DRM_UI64HL( 0, DRM_UI64Low32( f_ui64Addend ) ) );
+    ui64ResultHigh = DRM_UI64Add( DRM_UI64HL( 0, DRM_UI64High32( *f_pui64AugendResult ) ), DRM_UI64HL( 0, DRM_UI64High32( f_ui64Addend ) ) );
+
+    /* Fold any carry into high order dword */
+    ui64ResultHigh = DRM_UI64Add( ui64ResultHigh, DRM_UI64HL( 0, DRM_UI64High32( ui64ResultLow ) ) );
+
+    /* If the high order dword add(s) didn't carry, i.e. are zero, then we did not overflow */
+    if( DRM_LIKELY( DRM_UI64High32( ui64ResultHigh ) == 0 ) )
+    {
+        DRM_UINT64 ui64Result = DRM_UI64HL( DRM_UI64Low32( ui64ResultHigh ), DRM_UI64Low32( ui64ResultLow ) );
+#if DRM_SUPPORT_NATIVE_64BIT_TYPES
+        __analysis_assume( ui64Result == *f_pui64AugendResult + f_ui64Addend );
+#endif  /* DRM_SUPPORT_NATIVE_64BIT_TYPES */
+        *f_pui64AugendResult = ui64Result;
+    }
+    else
+    {
+        *f_pui64AugendResult = DRM_UI64HL( 0, 0 );
+        dr = DRM_E_ARITHMETIC_OVERFLOW;
+    }
+
+    return dr;
+}
+
+/* DWORD addition */
+DRM_API DRMMATHSAFEINLINE DRM_RESULT DRM_CALL DRM_DWordAdd(
+    __in                                                                          DRM_DWORD       f_dwAugend,
+    __in                                                                          DRM_DWORD       f_dwAddend,
+    __out_ecount( 1 ) _Post_satisfies_( *f_pdwResult == f_dwAugend + f_dwAddend ) DRM_DWORD      *f_pdwResult )
+{
+    DRM_UINT64 ui64result;
+    DRM_UINT64 ui64Augend = DRM_UI64HL( 0, f_dwAugend );
+    DRM_UINT64 ui64Addend = DRM_UI64HL( 0, f_dwAddend );
+
+    DRMASSERT( f_pdwResult != NULL );
+    __analysis_assume( f_pdwResult != NULL );
+
+    ui64result = DRM_UI64Add( ui64Augend, ui64Addend );
+#if DRM_SUPPORT_NATIVE_64BIT_TYPES
+    __analysis_assume( ui64result == f_dwAugend + f_dwAddend );
+#endif  /* DRM_SUPPORT_NATIVE_64BIT_TYPES */
+    return DRM_UInt64ToDWord( ui64result, f_pdwResult );
+}
+
+DRM_API DRMMATHSAFEINLINE DRM_RESULT DRM_CALL DRM_DWordAddSame(
+    __inout_ecount( 1 ) _Post_satisfies_( *f_pdwAugendResult == _Old_( *f_pdwAugendResult ) + f_dwAddend ) DRM_DWORD       *f_pdwAugendResult,
+    __in                                                                                                   DRM_DWORD        f_dwAddend )
+{
+    DRM_UINT64 ui64result;
+
+    DRMASSERT( f_pdwAugendResult != NULL );
+    __analysis_assume( f_pdwAugendResult != NULL );
+
+    ui64result = DRM_UI64Add( DRM_UI64HL( 0, *f_pdwAugendResult ),  DRM_UI64HL( 0, f_dwAddend  ) );
+#if DRM_SUPPORT_NATIVE_64BIT_TYPES
+    __analysis_assume( ui64result == *f_pdwAugendResult + f_dwAddend );
+#endif  /* DRM_SUPPORT_NATIVE_64BIT_TYPES */
+    return DRM_UInt64ToDWord( ui64result, f_pdwAugendResult );
+}
+
+/*
+** Subtraction functions
+*/
+
+/*BYTE subtraction */
+DRM_API DRMMATHSAFEINLINE DRM_RESULT DRM_CALL DRM_ByteSub(
+    __in                      DRM_BYTE       f_bMinuend,
+    __in                      DRM_BYTE       f_bSubtrahend,
+    __out_ecount(1)           DRM_BYTE      *f_pbResult )
+{
+    DRM_RESULT dr = DRM_SUCCESS;
+
+    DRMASSERT( f_pbResult != NULL );
+    __analysis_assume( f_pbResult != NULL );
+
+    if( DRM_LIKELY( f_bMinuend >= f_bSubtrahend ) )
+    {
+        *f_pbResult = (DRM_BYTE)(f_bMinuend - f_bSubtrahend);
+    }
+    else
+    {
+        /*
+        ** Initialize out value to ensure that failure
+        ** to check return value doesn't result in buffer
+        ** overflow if value is then used as pointer offset.
+        */
+        *f_pbResult = (DRM_BYTE)0;
+        dr = DRM_E_ARITHMETIC_OVERFLOW;
+    }
+
+    return dr;
+}
+
+/* WORD subtraction */
+DRM_API DRMMATHSAFEINLINE DRM_RESULT DRM_CALL DRM_WordSub(
+    __in                      DRM_WORD       f_wMinuend,
+    __in                      DRM_WORD       f_wSubtrahend,
+    __out_ecount(1)           DRM_WORD      *f_pwResult )
+{
+    DRM_RESULT dr = DRM_SUCCESS;
+
+    DRMASSERT( f_pwResult != NULL );
+    __analysis_assume( f_pwResult != NULL );
+
+    if( DRM_LIKELY( f_wMinuend >= f_wSubtrahend ) )
+    {
+        *f_pwResult = (DRM_WORD)(f_wMinuend - f_wSubtrahend);
+    }
+    else
+    {
+        /*
+        ** Initialize out value to ensure that failure
+        ** to check return value doesn't result in buffer
+        ** overflow if value is then used as pointer offset.
+        */
+        *f_pwResult = (DRM_WORD)0;
+        dr = DRM_E_ARITHMETIC_OVERFLOW;
+    }
+
+    return dr;
+}
+
+/* DWORD subtraction */
+DRM_API DRMMATHSAFEINLINE DRM_RESULT DRM_CALL DRM_DWordSub(
+    __in                                                                               DRM_DWORD       f_dwMinuend,
+    __in                                                                               DRM_DWORD       f_dwSubtrahend,
+    __out_ecount( 1 ) _Post_satisfies_( *f_pdwResult == f_dwMinuend - f_dwSubtrahend ) DRM_DWORD      *f_pdwResult )
+{
+    DRMASSERT( f_pdwResult != NULL );
+    __analysis_assume( f_pdwResult != NULL );
+
+    if( DRM_LIKELY( f_dwMinuend >= f_dwSubtrahend ) )
+    {
+        *f_pdwResult = (f_dwMinuend - f_dwSubtrahend);
+        return DRM_SUCCESS;
+    }
+    else
+    {
+        /*
+        ** Initialize out value to ensure that failure
+        ** to check return value doesn't result in buffer
+        ** overflow if value is then used as pointer offset.
+        */
+        *f_pdwResult = (DRM_DWORD)0;
+         return DRM_E_ARITHMETIC_OVERFLOW;
+    }
+}
+
+DRM_API DRMMATHSAFEINLINE DRM_RESULT DRM_CALL DRM_DWordSubSame(
+    __inout_ecount( 1 ) _Post_satisfies_( *f_pdwMinuend == _Old_( *f_pdwMinuend ) - f_dwSubtrahend ) DRM_DWORD      *f_pdwMinuend,
+    __in                                                                                             DRM_DWORD       f_dwSubtrahend )
+{
+    DRMASSERT( f_pdwMinuend != NULL );
+    __analysis_assume( f_pdwMinuend != NULL );
+
+    if( DRM_LIKELY( *f_pdwMinuend >= f_dwSubtrahend ) )
+    {
+        *f_pdwMinuend -= f_dwSubtrahend;
+        return DRM_SUCCESS;
+    }
+    else
+    {
+        /*
+        ** Initialize out value to ensure that failure
+        ** to check return value doesn't result in buffer
+        ** overflow if value is then used as pointer offset.
+        */
+        *f_pdwMinuend = (DRM_DWORD)0;
+         return DRM_E_ARITHMETIC_OVERFLOW;
+    }
+}
+
+/* UINT64 subtraction */
+DRM_API DRMMATHSAFEINLINE DRM_RESULT DRM_CALL DRM_UInt64Sub(
+    __in            DRM_UINT64       f_ui64Minuend,
+    __in            DRM_UINT64       f_ui64Subtrahend,
+    __out_ecount(1) DRM_UINT64      *f_pui64Result )
+{
+    DRM_RESULT dr = DRM_SUCCESS;
+
+    DRMASSERT( f_pui64Result != NULL );
+    __analysis_assume( f_pui64Result != NULL );
+
+    if( DRM_LIKELY( DRM_UI64GEq( f_ui64Minuend, f_ui64Subtrahend ) ) )
+    {
+        *f_pui64Result = DRM_UI64Sub( f_ui64Minuend, f_ui64Subtrahend );
+    }
+    else
+    {
+        *f_pui64Result = DRM_UI64HL( 0, 0 );
+        dr = DRM_E_ARITHMETIC_OVERFLOW;
+    }
+
+    return dr;
+}
+
+/*
+** Multiplication functions
+*/
+
+/* WORD multiplication */
+DRM_API DRMMATHSAFEINLINE DRM_RESULT DRM_CALL DRM_WordMult(
+    __in                      DRM_WORD       f_wMultiplicand,
+    __in                      DRM_WORD       f_wMultiplier,
+    __out_ecount(1)           DRM_WORD      *f_pwResult )
+{
+    DRM_DWORD dwResult = ((DRM_DWORD)f_wMultiplicand) * ((DRM_DWORD)f_wMultiplier);
+
+    return DRM_DWordToWord( dwResult, f_pwResult );
+}
+
+/* DWORD multiplication */
+DRM_API DRMMATHSAFEINLINE DRM_RESULT DRM_CALL DRM_DWordMult(
+    __in                                                                                    DRM_DWORD       f_dwMultiplicand,
+    __in                                                                                    DRM_DWORD       f_dwMultiplier,
+    __out_ecount( 1 ) _Post_satisfies_( *f_pdwResult == f_dwMultiplicand * f_dwMultiplier ) DRM_DWORD      *f_pdwResult )
+{
+    DRM_UINT64 ui64Result = DRM_UI64Mul( DRM_UI64HL( 0, f_dwMultiplicand ), DRM_UI64HL( 0, f_dwMultiplier ) );
+
+#if DRM_SUPPORT_NATIVE_64BIT_TYPES
+    __analysis_assume( ui64Result == f_dwMultiplicand * f_dwMultiplier );
+#endif  /* DRM_SUPPORT_NATIVE_64BIT_TYPES */
+    return DRM_UInt64ToDWord( ui64Result, f_pdwResult );
+}
+
+
+#if DRMMATHSAFEUSEINTRINSICS
+
+DRM_API DRMMATHSAFEINLINE DRM_RESULT DRM_UInt64Mult(
+    __in                      DRM_UINT64       f_ui64Multiplicand,
+    __in                      DRM_UINT64       f_ui64Multiplier,
+    __out_ecount(1)           DRM_UINT64      *f_pui64Result )
+{
+    DRM_RESULT dr = DRM_SUCCESS;
+    unsigned __int64 ulLow  = 0;
+    unsigned __int64 ulHigh = 0;
+    ulLow = _umul128( f_ui64Multiplicand, f_ui64Multiplier, &ulHigh );
+    if( ulHigh == 0 )
+    {
+        *f_pui64Result = ulLow;
+        dr = DRM_SUCCESS;
+    }
+    else
+    {
+        *f_pui64Result = 0;
+        dr = DRM_E_ARITHMETIC_OVERFLOW;
+    }
+    return dr;
+}
+
+#else /* DRMMATHSAFEUSEINTRINSICS */
+
+/* UINT64 multiplication */
+DRM_API DRMMATHSAFEINLINE DRM_RESULT DRM_UInt64Mult(
+    __in                      DRM_UINT64       f_ui64Multiplicand,
+    __in                      DRM_UINT64       f_ui64Multiplier,
+    __out_ecount(1)           DRM_UINT64      *f_pui64Result )
+{
+    DRM_RESULT dr = DRM_SUCCESS;
+
+    /*
+    ** 64x64 into 128 is like 32.32 x 32.32.
+    **
+    ** a.b * c.d = a*(c.d) + .b*(c.d) = a*c + a*.d + .b*c + .b*.d
+    ** back in non-decimal notation where A=a*2^32 and C=c*2^32:
+    ** A*C + A*d + b*C + b*d
+    ** So there are four components to add together.
+    **   result = (a*c*2^64) + (a*d*2^32) + (b*c*2^32) + (b*d)
+    **
+    ** a * c must be 0 or there would be bits in the high 64-bits
+    ** a * d must be less than 2^32 or there would be bits in the high 64-bits
+    ** b * c must be less than 2^32 or there would be bits in the high 64-bits
+    ** then there must be no overflow of the resulting values summed up.
+    */
+
+    DRM_DWORD  dw_a       = 0;
+    DRM_DWORD  dw_b       = 0;
+    DRM_DWORD  dw_c       = 0;
+    DRM_DWORD  dw_d       = 0;
+    DRM_UINT64 ad         = DRM_UI64LITERAL( 0, 0 );
+    DRM_UINT64 bc         = DRM_UI64LITERAL( 0, 0 );
+    DRM_UINT64 bd         = DRM_UI64LITERAL( 0, 0 );
+    DRM_UINT64 ui64Result = DRM_UI64LITERAL( 0, 0 );
+
+    DRMASSERT( f_pui64Result != NULL );
+    __analysis_assume( f_pui64Result != NULL );
+
+    dr = DRM_E_ARITHMETIC_OVERFLOW;
+    *f_pui64Result = DRM_UI64HL( 0, 0 );
+
+    dw_a = DRM_UI64High32( f_ui64Multiplicand );
+    dw_c = DRM_UI64High32( f_ui64Multiplier );
+
+    /* common case -- if high dwords are both zero, no chance for overflow */
+    if( DRM_LIKELY( ( dw_a == 0 ) && ( dw_c == 0 ) ) )
+    {
+        dw_b = DRM_UI64Low32( f_ui64Multiplicand );
+        dw_d = DRM_UI64Low32( f_ui64Multiplier );
+
+        *f_pui64Result = DRM_UI64Mul( DRM_UI64HL( 0, dw_b ), DRM_UI64HL( 0, dw_d ) );
+        dr = DRM_SUCCESS;
+    }
+    else
+    {
+        /* a * c must be 0 or there would be bits set in the high 64-bits */
+        if( ( dw_a == 0 )
+         || ( dw_c == 0 ) )
+        {
+            dw_d = DRM_UI64Low32( f_ui64Multiplier );
+
+            /* a * d must be less than 2^32 or there would be bits set in the high 64-bits */
+            ad = DRM_UI64Mul( DRM_UI64HL( 0, dw_a ), DRM_UI64HL( 0, dw_d ) );
+
+            if( DRM_UI64High32( ad ) == 0 )
+            {
+                dw_b = DRM_UI64Low32( f_ui64Multiplicand );
+
+                /* b * c must be less than 2^32 or there would be bits set in the high 64-bits */
+                bc = DRM_UI64Mul( DRM_UI64HL( 0, dw_b ), DRM_UI64HL( 0, dw_c ) );
+
+                if( DRM_UI64High32( bc ) == 0 )
+                {
+                    /*
+                    ** now sum them all up checking for overflow.
+                    ** shifting is safe because we already checked for overflow above
+                    */
+                    if( DRM_SUCCEEDED( DRM_UInt64Add( DRM_UI64ShL( bc, 32 ),
+                                                      DRM_UI64ShL( ad, 32 ), &ui64Result ) ) )
+                    {
+                        /* b * d */
+                        bd = DRM_UI64Mul( DRM_UI64HL( 0, dw_b ), DRM_UI64HL( 0, dw_d ) );
+
+                        if( DRM_SUCCEEDED( DRM_UInt64Add( ui64Result, bd, &ui64Result ) ) )
+                        {
+                             dr = DRM_SUCCESS;
+                            *f_pui64Result = ui64Result;
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    return dr;
+}
+
+#endif /* DRMMATHSAFEUSEINTRINSICS */
+
+/*
+** signed operations
+**
+** Strongly consider using unsigned numbers.
+**
+** Signed numbers are often used where unsigned numbers should be used.
+** For example file sizes and array indices should always be unsigned.
+** (File sizes should be 64bit integers; array indices should be SIZE_T.)
+** Subtracting a larger positive signed number from a smaller positive
+** signed number with IntSubwill succeed, producing a negative number,
+** that then must not be used as an array index (but can occasionally be
+** used as a pointer index.) Similarly for adding a larger magnitude
+** negative number to a smaller magnitude positive number.
+**
+** drmmathsafe.h does not protect you from such errors. It tells you if your
+** integer operations overflowed, not if you are doing the right thing
+** with your non-overflowed integers.
+**
+** Likewise you can overflow a buffer with a non-overflowed unsigned index.
+*/
+
+/*
+** Signed addition functions
+*/
+
+/* LONG Addition */
+DRM_API DRMMATHSAFEINLINE DRM_RESULT DRM_CALL DRM_LongAdd(
+    __in                      DRM_LONG       f_lAugend,
+    __in                      DRM_LONG       f_lAddend,
+    __out_ecount(1)           DRM_LONG      *f_plResult )
+{
+    DRMCASSERT( sizeof(DRM_INT64) > sizeof(DRM_LONG) );
+    return DRM_Int64ToLong( DRM_I64Add( DRM_I64( f_lAugend ), DRM_I64( f_lAddend ) ), f_plResult );
+}
+
+/*
+** Signed subtraction functions
+*/
+
+/* LONG Subtraction */
+DRM_API DRMMATHSAFEINLINE DRM_RESULT DRM_CALL DRM_LongSub(
+    __in                      DRM_LONG       f_lMinuend,
+    __in                      DRM_LONG       f_lSubtrahend,
+    __out_ecount(1)           DRM_LONG      *f_plResult )
+{
+    DRMCASSERT( sizeof( DRM_INT64 ) > sizeof( DRM_LONG ) );
+    return DRM_Int64ToLong( DRM_I64Sub( DRM_I64( f_lMinuend ), DRM_I64( f_lSubtrahend ) ), f_plResult );
+}
+
+/*
+** Signed multiplication functions
+*/
+
+/* LONG multiplication */
+DRM_API DRMMATHSAFEINLINE DRM_RESULT DRM_CALL DRM_LongMult(
+    __in                      DRM_LONG       f_lMultiplicand,
+    __in                      DRM_LONG       f_lMultiplier,
+    __out_ecount(1)           DRM_LONG      *f_plResult )
+{
+    DRMCASSERT( sizeof( DRM_INT64 ) > sizeof( DRM_LONG ) );
+    return DRM_Int64ToLong( DRM_I64Mul( DRM_I64(f_lMultiplicand), DRM_I64(f_lMultiplier) ), f_plResult );
+}
+
+EXIT_PK_NAMESPACE_CODE;
+
diff --git a/prebuilt-v4.4/noarch/include/drmmeterapi.h b/prebuilt-v4.4/noarch/include/drmmeterapi.h
new file mode 100644
index 0000000..577e732
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmmeterapi.h
@@ -0,0 +1,23 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __DRM_METER_API_H
+#define __DRM_METER_API_H
+
+#include <drmmanager.h>
+
+ENTER_PK_NAMESPACE;
+
+DRM_API DRM_RESULT DRM_CALL DRM_METERING_UpdateData(
+    __in                              DRM_APP_CONTEXT   *f_poAppContext,
+    __in_ecount(f_cActions)     const DRM_CONST_STRING  *f_ppdstrActions[],
+    __in                              DRM_DWORD          f_cActions );
+
+EXIT_PK_NAMESPACE;
+
+#endif /* __DRM_METER_API_H */
diff --git a/prebuilt-v4.4/noarch/include/drmmetercertstore.h b/prebuilt-v4.4/noarch/include/drmmetercertstore.h
new file mode 100644
index 0000000..1627809
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmmetercertstore.h
@@ -0,0 +1,228 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __DRM_METERCERT_STORE__
+#define __DRM_METERCERT_STORE__
+
+#include <drmtypes.h>
+#include <drmdatastoretypes.h>
+
+ENTER_PK_NAMESPACE;
+
+typedef struct _tagMeterCertContext
+{
+    DRM_DST_SLOT_CONTEXT      contextDSTSlot;
+    DRM_DST_NAMESPACE_CONTEXT contextNameSpace;
+    DRM_DST                  *pDatastore;
+    DRM_BYTE                 *pbBuffer;
+    DRM_DWORD                 cbBuffer;
+    DRM_BOOL                  fInited;
+} DRM_METERCERT_CONTEXT_PRIVATE;
+
+typedef struct _tagMeterCertEnumContext
+{
+    DRM_METERCERT_CONTEXT_PRIVATE *pcontextMeterCert;
+    DRM_DST_ENUM_CONTEXT      contextDSTEnum;
+    DRM_DST_SLOT_CONTEXT      contextDSTSlot;
+    DRM_BOOL                  fInited;
+    DRM_BOOL                  fAny;
+    DRM_BOOL                  fSkipEnumNext;
+} DRM_METERCERT_ENUM_PRIVATE;
+
+typedef struct __tagDRM_METERCERT_CONTEXT
+{
+    DRM_BYTE rgbOpaqueData [ sizeof(DRM_METERCERT_CONTEXT_PRIVATE) ];
+} DRM_METERCERT_CONTEXT;
+
+typedef struct __tagDRM_METERCERT_ENUM
+{
+    DRM_BYTE rgbOpaqueData [ sizeof(DRM_METERCERT_ENUM_PRIVATE) ];
+} DRM_METERCERT_ENUM;
+
+/* low-level access to the meter cert store */
+
+
+/*********************************************************************
+**
+** Function: DRM_MCS_OpenStore
+**
+** Synopsis: Opens the metercert store
+**
+** Arguments:
+**
+** [f_pDataStore]           -- initialized data store.
+** [f_pbBuffer]             -- Scratch buffer to be used by the store
+** [f_cbBuffer]             -- Size of the scratch buffer, should be at least as big as the
+**                             largest anticipated metercert
+** [f_pcontextMeterCert]    -- returned meter cert context
+**
+** Returns:     DRM_SUCCESS on success or DRM_E_INVALIDARG if the arguments are invalid.
+**
+**********************************************************************/
+
+DRM_API DRM_RESULT DRM_CALL DRM_MCS_OpenStore(
+    __in                      DRM_DST               *f_pDatastore,
+    __in_bcount( f_cbBuffer ) DRM_BYTE              *f_pbBuffer,
+    __in                      DRM_DWORD              f_cbBuffer,
+    __out                     DRM_METERCERT_CONTEXT *f_pcontextMeterCert );
+
+/*********************************************************************
+**
+** Function: DRM_MCS_CloseStore
+**
+** Synopsis: Closes the metercert store
+**
+** Arguments:
+**
+** [f_pcontextMeterCert]    -- initialized meter cert context
+**
+** Returns:     DRM_SUCCESS on success or DRM_E_INVALIDARG if the arguments are invalid.
+**
+**********************************************************************/
+
+DRM_API DRM_RESULT DRM_CALL DRM_MCS_CloseStore(
+    __in  DRM_METERCERT_CONTEXT *f_pcontextMeterCert);
+
+
+/**********************************************************************
+**
+** Function:    DRM_MCS_InitEnum
+**
+** Synopsis:    Initializes an enumeration of metercert store entries
+**
+**
+** Arguments:   [pDrmContext]             -- Opaque DRM Manager context initialized by a call to Drm_Initialize
+**              [f_pcontextMeterCertEnum] -- Opaque context initialized
+**
+** Returns:     DRM_SUCCESS on success or DRM_E_INVALIDARG if the arguments are invalid.
+**
+**********************************************************************/
+
+DRM_API DRM_RESULT DRM_CALL DRM_MCS_InitEnum(
+    __in  DRM_METERCERT_CONTEXT       *f_pcontextMeterCert,
+    __out DRM_METERCERT_ENUM          *f_pcontextMeterCertEnum );
+
+/**********************************************************************
+**
+** Function:    DRM_MCS_EnumNext
+**
+** Synopsis:    Enumerates the next entry in the meter cert store
+**
+**
+** Arguments:   [f_pcontextMeterCertEnum] -- Opaque context initialized by a call to DRM_MCS_InitEnum
+**              [f_pmid]                  -- pointer to the MID of the enumerated entry
+**              [f_pslotHint]             -- slot hint of the enumerated entry
+**
+** Returns:     DRM_SUCCESS on success or DRM_E_INVALIDARG if the arguments are invalid.
+**
+**********************************************************************/
+
+DRM_API DRM_RESULT DRM_CALL DRM_MCS_EnumNext(
+    __in  DRM_METERCERT_ENUM          *f_pcontextMeterCertEnum,
+    __out DRM_MID                     *f_pmid,
+    __out DRM_DST_SLOT_HINT           *f_pslotHint );
+
+/*********************************************************************
+**
+** Function: DRM_MCS_GetMeterCertByMID
+**
+** Synopsis: Looks up the LAINFO and meter cert for a given MID if it exists
+**
+** Arguments:
+**
+** [f_pcontextMeterCert]    -- initialized meter cert context
+** [f_pmid]                 -- pointer to MID to be looked up
+** [f_pwszLAINFO]           -- pointer to a buffer that will hold the LAINFO
+** [f_pcchLAINFO]           -- pointer to the number of wide characters in the LAINFO
+** [f_pwszMeterCert]        -- pointer to a buffer that will hold the meter cert
+** [f_pcchMeterCert]        -- pointer to the number of wide characters in the meter cert
+**
+** Returns:     DRM_SUCCESS on success or DRM_E_INVALIDARG if the arguments are invalid.
+**
+**********************************************************************/
+
+DRM_API DRM_RESULT DRM_CALL DRM_MCS_GetMeterCertByMID(
+    __in                                       DRM_METERCERT_CONTEXT   *f_pcontextMeterCert,
+    __in                                 const DRM_MID                 *f_pmid,
+    __out_ecount_opt(*f_pcchLAINFO)            DRM_WCHAR               *f_pwszLAINFO,
+    __inout_opt                                DRM_DWORD               *f_pcchLAINFO,
+    __out_bcount_opt(*f_pcbMeterCert)          DRM_BYTE                *f_pbMeterCert,
+    __inout_opt                                DRM_DWORD               *f_pcbMeterCert );
+
+/*********************************************************************
+**
+** Function: DRM_MCS_UpdateMeterCert
+**
+** Synopsis:
+**
+** Arguments:
+**
+** [f_pcontextMeterCert]          -- initialized meter cert context
+** [f_pdstrLAINFO]                -- optional LAINFO to store
+** [f_pbMeterCert]                -- optional meter cert to store
+** [f_cbMeterCert]                -- optional size of meter cert to store
+** [f_pmid]                       -- pointer to MID to be added/updated
+**
+** Returns:     DRM_SUCCESS on success or DRM_E_INVALIDARG if the arguments are invalid.
+**
+**********************************************************************/
+
+
+DRM_API DRM_RESULT DRM_CALL DRM_MCS_UpdateMeterCert(
+    __in                                   DRM_METERCERT_CONTEXT      *f_pcontextMeterCert,
+    __in_opt                         const DRM_CONST_STRING           *f_pdstrLAINFO,
+    __in_bcount_opt( f_cbMeterCert ) const DRM_BYTE                   *f_pbMeterCert,
+    __in                                   DRM_DWORD                   f_cbMeterCert,
+    __in                             const DRM_MID                    *f_pmid );
+
+
+/*********************************************************************
+**
+** Function: DRM_MCS_DeleteMeterCert
+**
+** Synopsis: delete the indicated meter cert from the meter cert store; its absense
+**           is not an error
+**
+** Arguments:
+**
+** [f_pcontextMeterCert]    -- initialized METERCERT context
+** [f_pmid]                 -- pointer to MID to be added/updated
+**
+** Returns:     DRM_SUCCESS on success or DRM_E_INVALIDARG if the arguments are invalid.
+**
+**********************************************************************/
+
+DRM_API DRM_RESULT DRM_CALL DRM_MCS_DeleteMeterCert(
+    __in       DRM_METERCERT_CONTEXT  *f_pcontextMeterCert,
+    __in const DRM_MID                *f_pmid );
+
+
+/*********************************************************************
+**
+** Function: DRM_MCS_InvalidateMeterCert
+**
+** Synopsis: invalidate the indicated meter cert from the meter cert store; its absense
+**           is not an error
+**
+** Arguments:
+**
+** [f_pcontextMeterCert]    -- initialized METERCERT context
+** [f_pmid]                 -- pointer to MID to be added/updated
+**
+** Returns:     DRM_SUCCESS on success or DRM_E_INVALIDARG if the arguments are invalid.
+**
+**********************************************************************/
+
+DRM_API DRM_RESULT DRM_CALL DRM_MCS_InvalidateMeterCert(
+    __in       DRM_METERCERT_CONTEXT  *f_pcontextMeterCert,
+    __in const DRM_MID                *f_pmid );
+
+EXIT_PK_NAMESPACE;
+
+#endif /* __DRM_METERCERT_STORE__ */
+
diff --git a/prebuilt-v4.4/noarch/include/drmmeterconstants.h b/prebuilt-v4.4/noarch/include/drmmeterconstants.h
new file mode 100644
index 0000000..27b90a0
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmmeterconstants.h
@@ -0,0 +1,144 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __DRM_METER_CONSTANTS_H
+#define __DRM_METER_CONSTANTS_H
+
+#include <drmtypes.h>
+#include <oemcryptoctx.h>
+
+ENTER_PK_NAMESPACE;
+
+/*
+** ------------------------------------------------------------
+** XML strings used in the construction of meter data challenge
+** ------------------------------------------------------------
+*/
+extern DRM_GLOBAL_CONST  DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrMeterDataRootTag;
+
+extern DRM_GLOBAL_CONST  DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrMeterDataChallenge1Tag;
+
+extern DRM_GLOBAL_CONST  DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrMeterDataChallenge2Tag;
+
+extern DRM_GLOBAL_CONST  DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrMeterDataMeteringDataTag;
+
+extern DRM_GLOBAL_CONST  DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrMeterDataVersionTag;
+
+extern DRM_GLOBAL_CONST  DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrMeterDataMIDTag;
+
+extern DRM_GLOBAL_CONST  DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrMeterDataTIDTag;
+
+extern DRM_GLOBAL_CONST  DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrMeterDataCustomDataTag;
+
+extern DRM_GLOBAL_CONST  DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrMeterDataPartialDataTag;
+
+extern DRM_GLOBAL_CONST  DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrMeterDataDataTag;
+
+extern DRM_GLOBAL_CONST  DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrMeterDataDeviceCertTag;
+
+extern DRM_GLOBAL_CONST  DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrMeterDataRecordsTag;
+
+extern DRM_GLOBAL_CONST  DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrMeterDataRecordTag;
+
+extern DRM_GLOBAL_CONST  DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrMeterDataActionTag;
+
+
+extern DRM_GLOBAL_CONST  DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrMeterDataRootAttribName;
+extern DRM_GLOBAL_CONST  DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrMeterDataRootAttribValue;
+
+extern DRM_GLOBAL_CONST  DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrMeterDataChallenge2AttribName;
+extern DRM_GLOBAL_CONST  DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrMeterDataChallenge2AttribValue;
+
+extern DRM_GLOBAL_CONST  DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrMeterDataMeteringDataAttrib1Name;
+extern DRM_GLOBAL_CONST  DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrMeterDataMeteringDataAttrib1Value;
+
+extern DRM_GLOBAL_CONST  DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrMeterDataMeteringDataAttrib2Name;
+extern DRM_GLOBAL_CONST  DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrMeterDataMeteringDataAttrib2Value;
+
+extern DRM_GLOBAL_CONST  DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrMeterDataRecordAttribName;
+
+extern DRM_GLOBAL_CONST  DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrMeterDataActionAttrib1Name;
+
+extern DRM_GLOBAL_CONST  DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrMeterDataActionAttrib2Name;
+
+
+extern DRM_GLOBAL_CONST  DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrMeterDataVersionValue;
+
+extern DRM_GLOBAL_CONST  DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrMeterDataPartialDataValue;
+
+
+/*
+** ------------------------------------------------------
+** XML strings used in the parsing of meter data response
+** ------------------------------------------------------
+*/
+extern DRM_GLOBAL_CONST  DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrMeterDataMeterCertPath;
+
+extern DRM_GLOBAL_CONST  DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrMeterDataEncryptedDataPath;
+
+extern DRM_GLOBAL_CONST  DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrMeterDataMIDPath;
+
+extern DRM_GLOBAL_CONST  DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrMeterDataTIDPath;
+
+extern DRM_GLOBAL_CONST  DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrMeterDataRecordsPath;
+
+extern DRM_GLOBAL_CONST  DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrMeterDataKIDPath;
+
+extern DRM_GLOBAL_CONST  DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrMeterDataKeyNamePath;
+
+extern DRM_GLOBAL_CONST  DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrMeterDataKeyNameValue;
+
+/*
+** ------------------------------------------------------------
+** XML strings used in the construction of meter cert challenge
+** ------------------------------------------------------------
+*/
+extern DRM_GLOBAL_CONST  DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrMeterCertRootTag;
+
+extern DRM_GLOBAL_CONST  DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrMeterCertChallenge1Tag;
+
+extern DRM_GLOBAL_CONST  DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrMeterCertChallenge2Tag;
+
+extern DRM_GLOBAL_CONST  DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrMeterCertMIDTag;
+
+extern DRM_GLOBAL_CONST  DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrSupportsMeterCertSignatureTag;
+
+extern DRM_GLOBAL_CONST  DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrTrueValue;
+
+extern DRM_GLOBAL_CONST  DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrMeterCertVersionTag;
+
+extern DRM_GLOBAL_CONST  DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrMeterCertCustomDataTag;
+
+extern DRM_GLOBAL_CONST  DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrMeterCertRootAttribName;
+
+extern DRM_GLOBAL_CONST  DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrMeterCertRootAttribValue;
+
+
+extern DRM_GLOBAL_CONST  DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrMeterCertVersion;
+
+
+/*
+** ------------------------------------------------------
+** XML strings used in the parsing of meter cert response
+** ------------------------------------------------------
+*/
+extern DRM_GLOBAL_CONST  DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrMeterCertResponsePath;
+
+extern DRM_GLOBAL_CONST  DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrMeterCertMeterCertPath;
+
+/*
+** -----------------------------
+** Additional metering constants
+** -----------------------------
+*/
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING       g_dstrTagMeterCert;
+
+EXIT_PK_NAMESPACE;
+
+#endif /* __DRM_METER_CONSTANTS_H */
+
diff --git a/prebuilt-v4.4/noarch/include/drmmeterimp.h b/prebuilt-v4.4/noarch/include/drmmeterimp.h
new file mode 100644
index 0000000..bcb882d
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmmeterimp.h
@@ -0,0 +1,217 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __DRMMETERIMPL_H__
+#define __DRMMETERIMPL_H__
+
+#include <drmxmlbuilder.h>
+#include <drmsecurestore.h>
+#include <drmrevocationstore.h>
+#include <drmlicevaltypes.h>
+#include <drmsecurecoretypes.h>
+
+ENTER_PK_NAMESPACE;
+
+#define DRM_METERING_CONTEXT        DRM_SECSTORE_CONTEXT
+
+typedef struct __tagDRM_METERINGENUM_CONTEXT
+{
+    DRM_MID                     oMID;
+    DRM_SECSTOREENUM_CONTEXT    oSecStoreEnum;
+} DRM_METERINGENUM_CONTEXT;
+
+#define DRM_METERINGENUM_CONTEXT_EMPTY { DRM_ID_EMPTY, {0} }
+
+extern DRM_EXPORT_VAR const DRM_KID g_kidTID;
+
+extern DRM_EXPORT_VAR const DRM_KID g_kidTIDPrev;
+
+PREFAST_PUSH_DISABLE_EXPLAINED(__WARNING_NONCONST_BUFFER_PARAM_25033, "Out params can't be const")
+PREFAST_PUSH_DISABLE_EXPLAINED(__WARNING_NONCONST_PARAM_25004, "Out params can't be const")
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_MTR_GetKIDData(
+    __inout                           DRM_METERING_CONTEXT         *f_pmeterstore,
+    __inout                           DRM_STACK_ALLOCATOR_CONTEXT  *f_pstack,
+    __deref_out_ecount(*f_pcbDataOut) DRM_BYTE                    **f_ppbDataOut,
+    __out                             DRM_DWORD                    *f_pcbDataOut );
+PREFAST_POP
+PREFAST_POP
+
+PREFAST_PUSH_DISABLE_EXPLAINED(__WARNING_NONCONST_PARAM_25004, "f_pOEMContext can never be const")
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_MTR_CreateNewTID(
+    __in_opt DRM_VOID *f_pOEMContext,
+    __out    DRM_TID  *f_ptid );
+PREFAST_POP
+
+PREFAST_PUSH_DISABLE_EXPLAINED(__WARNING_NONCONST_PARAM, "Out params can't be const, DRM_DST should not be const")
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_MTR_ReadTIDFromMeteringStore(
+    __in                                     DRM_METERING_CONTEXT   *f_pmeterstore,
+    __in_bcount( OEM_SHA1_DIGEST_LEN ) const DRM_BYTE                f_rgbPasswordSST [ OEM_SHA1_DIGEST_LEN ],
+    __in                               const DRM_MID                *f_pmid,
+    __out                                    DRM_TID                *f_ptid,
+    __out_opt                                DRM_CONST_STRING       *f_pdstrTidBase64,
+    __in                                     DRM_DST                *f_pDatastore );
+PREFAST_POP
+
+PREFAST_PUSH_DISABLE_EXPLAINED(__WARNING_NONCONST_PARAM, "DRM_DST should not be const")
+PREFAST_PUSH_DISABLE_EXPLAINED(__WARNING_NONCONST_PARAM_25004, "Out params can't be const")
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_MTR_WriteTIDToMeteringStore(
+    __inout                                     DRM_METERING_CONTEXT *f_pmeterstore,
+    __in_bcount( OEM_SHA1_DIGEST_LEN )    const DRM_BYTE              f_rgbPasswordSST [ OEM_SHA1_DIGEST_LEN ],
+    __in                                  const DRM_MID              *f_pmid,
+    __in                                  const DRM_TID              *f_ptid,
+    __in                                        DRM_DST              *f_pDatastore );
+PREFAST_POP
+PREFAST_POP
+
+PREFAST_PUSH_DISABLE_EXPLAINED(__WARNING_NONCONST_PARAM, "DRM_DST should not be const")
+DRM_API DRM_RESULT DRM_CALL DRM_MTR_InitEnum(
+    __in  const DRM_MID                   *f_pmid,
+    __out       DRM_METERINGENUM_CONTEXT  *f_pcontextMTREnum,
+    __in        DRM_DST                   *f_pDatastore );
+PREFAST_POP
+
+PREFAST_PUSH_DISABLE_EXPLAINED(__WARNING_NONCONST_BUFFER_PARAM_25033, "Out params can't be const")
+PREFAST_PUSH_DISABLE_EXPLAINED(__WARNING_NONCONST_PARAM_25004, "Out params can't be const")
+DRM_API DRM_RESULT DRM_CALL DRM_MTR_EnumNext(
+    __inout  DRM_METERINGENUM_CONTEXT *f_pcontextMTREnum,
+    __out    DRM_KID                  *f_pkid,
+    __out    DRM_DWORD                *f_pcbData );
+PREFAST_POP
+PREFAST_POP
+
+PREFAST_PUSH_DISABLE_EXPLAINED(__WARNING_NONCONST_PARAM, "DRM_DST should not be const")
+PREFAST_PUSH_DISABLE_EXPLAINED(__WARNING_NONCONST_PARAM_25004, "Out params can't be const")
+DRM_API DRM_RESULT DRM_CALL DRM_MTR_CloseContext(
+    __inout DRM_METERING_CONTEXT *f_pcontextMTR,
+    __in    DRM_DST              *f_pDatastore );
+PREFAST_POP
+PREFAST_POP
+
+PREFAST_PUSH_DISABLE_EXPLAINED(__WARNING_NONCONST_PARAM, "DRM_DST should not be const")
+PREFAST_PUSH_DISABLE_EXPLAINED(__WARNING_NONCONST_PARAM_25004, "Out params can't be const")
+DRM_API DRM_RESULT DRM_CALL DRM_MTR_OpenId(
+    __inout                                  DRM_METERING_CONTEXT *f_pcontextMTR,
+    __in                               const DRM_MID              *f_pmid,
+    __in                               const DRM_KID              *f_pkid,
+    __in_bcount( OEM_SHA1_DIGEST_LEN ) const DRM_BYTE              f_rgbPasswordMTR[ OEM_SHA1_DIGEST_LEN ],
+    __in                                     DRM_DST              *f_pDatastore );
+PREFAST_POP
+PREFAST_POP
+
+PREFAST_PUSH_DISABLE_EXPLAINED(__WARNING_NONCONST_PARAM_25004, "Out params can't be const")
+DRM_API DRM_RESULT DRM_CALL DRM_MTR_IncrementCount(
+    __inout       DRM_METERING_CONTEXT *f_pcontextMTR,
+    __in    const DRM_CONST_STRING     *f_pdstrAction );
+PREFAST_POP
+
+PREFAST_PUSH_DISABLE_EXPLAINED(__WARNING_NONCONST_BUFFER_PARAM_25033, "Out params can't be const")
+PREFAST_PUSH_DISABLE_EXPLAINED(__WARNING_NONCONST_PARAM_25004, "Out params can't be const")
+DRM_API DRM_RESULT DRM_CALL DRM_MTR_CreateMeterStorePassword(
+    __inout                                   DRM_SECURECORE_CONTEXT *f_pSecureCoreCtx,
+    __in                                const DRM_CONST_STRING       *f_pdstrMID,
+    __out_bcount( OEM_SHA1_DIGEST_LEN )       DRM_BYTE                f_rgbPasswordSST[ OEM_SHA1_DIGEST_LEN ] );
+PREFAST_POP
+PREFAST_POP
+
+PREFAST_PUSH_DISABLE_EXPLAINED(__WARNING_NONCONST_BUFFER_PARAM_25033, "Out params can't be const")
+PREFAST_PUSH_DISABLE_EXPLAINED(__WARNING_NONCONST_PARAM_25004, "Out params can't be const")
+DRM_API DRM_RESULT DRM_CALL DRM_MTR_CreateMeterStorePasswordFromBinaryMID(
+    __inout                                   DRM_SECURECORE_CONTEXT *f_pSecureCoreCtx,
+    __in                                const DRM_MID                *f_pmid,
+    __out_bcount( OEM_SHA1_DIGEST_LEN )       DRM_BYTE                f_rgbPasswordSST[ OEM_SHA1_DIGEST_LEN ] );
+PREFAST_POP
+PREFAST_POP
+
+DRM_API DRM_RESULT DRM_CALL DRM_MTR_UpdateData(
+    __inout                       DRM_SECURECORE_CONTEXT  *f_pSecureCoreCtx,
+    __in                    const DRM_MID                 *f_pmid,
+    __in                    const DRM_LID                 *f_plid,
+    __in                    const DRM_KID                 *f_pkid,
+    __in_ecount(f_cActions) const DRM_CONST_STRING        *f_ppdstrActions[],
+    __in                          DRM_DWORD                f_cActions,
+    __in                          DRM_METERING_CONTEXT    *f_pcontextMTR,
+    __in                          DRM_DST                 *f_pDatastore );
+
+DRM_API DRM_RESULT DRM_CALL DRM_MTR_EnumLoadCurrent(
+    __in                                     DRM_METERINGENUM_CONTEXT *f_pcontextMTREnum,
+    __in                                     DRM_METERING_CONTEXT     *f_pcontextMTR,
+    __in_bcount( OEM_SHA1_DIGEST_LEN ) const DRM_BYTE                  f_rgbPasswordMTR[ OEM_SHA1_DIGEST_LEN ],
+    __out                                    DRM_KID                  *f_pkid,
+    __out                                    DRM_DWORD                *f_pcbData );
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_MTR_ParseBinaryMeterCert(
+    __inout                                 DRM_SECURECORE_CONTEXT       *f_pSecureCoreCtx,
+    __inout                                 DRM_DST                      *f_poDSTContext,
+    __inout                                 DRM_SECSTORE_CONTEXT         *f_poSSTContext,
+    __inout_opt                             DRM_REVOCATIONSTORE_CONTEXT  *f_poRevStore,
+    __in_bcount_opt(f_cbRevocationBuffer)   DRM_BYTE                     *f_pbRevocationBuffer,
+    __in                                    DRM_DWORD                     f_cbRevocationBuffer,
+    __in_bcount(f_cbMeterCert)        const DRM_BYTE                     *f_pbMeterCert,
+    __in                              const DRM_DWORD                     f_cbMeterCert,
+    __out                                   DRM_MID                      *f_poMID,
+    __out_ecount_opt(*f_pcchURL)            DRM_CHAR                     *f_pchURL,
+    __inout_opt                             DRM_DWORD                    *f_pcchURL,
+    __out                                   PUBKEY_P256                  *f_poServerPubKey );
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_MTR_GenerateMeterDataChallenge(
+    __inout                                DRM_SECURECORE_CONTEXT       *f_pSecureCoreCtx,
+    __inout                                DRM_DST                      *f_poDSTContext,
+    __inout                                DRM_SECSTORE_CONTEXT         *f_poSSTContext,
+    __inout_opt                            DRM_REVOCATIONSTORE_CONTEXT  *f_poRevStore,
+    __in_bcount_opt(f_cbRevocationBuffer)  DRM_BYTE                     *f_pbRevocationBuffer,
+    __in                                   DRM_DWORD                     f_cbRevocationBuffer,
+    __in_bcount(f_cbStack)                 DRM_BYTE                     *f_pbStack,
+    __in                                   DRM_DWORD                     f_cbStack,
+    __in_bcount(f_cbMeterCert)       const DRM_BYTE                     *f_pbMeterCert,
+    __in                                   DRM_DWORD                     f_cbMeterCert,
+    __in_bcount(f_cbDeviceCert)      const DRM_BYTE                     *f_pbDeviceCert,
+    __in                                   DRM_DWORD                     f_cbDeviceCert,
+    __in_ecount_opt(f_cchCustomData) const DRM_CHAR                     *f_pchCustomData,
+    __in                                   DRM_DWORD                     f_cchCustomData,
+    __out_ecount_opt(*f_pcchURL)           DRM_CHAR                     *f_pchURL,
+    __inout                                DRM_DWORD                    *f_pcchURL,
+    __out_bcount_opt( *f_pcbChallenge )    DRM_BYTE                     *f_pbChallenge,
+    __inout                                DRM_DWORD                    *f_pcbChallenge,
+    __in_ecount( 1 )                 const PUBKEY_P256                  *f_poECC256SignPubKey );
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_MTR_ProcessMeterDataResponse(
+    __inout                                 DRM_SECURECORE_CONTEXT      *f_pSecureCoreCtx,
+    __in                                    DRM_DST                     *f_poDSTContext,
+    __inout                                 DRM_SECSTORE_CONTEXT        *f_poSSTContext,
+    __inout_opt                             DRM_REVOCATIONSTORE_CONTEXT *f_poRevStore,
+    __in_bcount_opt(f_cbRevocationBuffer)   DRM_BYTE                    *f_pbRevocationBuffer,
+    __in                                    DRM_DWORD                    f_cbRevocationBuffer,
+    __inout_bcount(*f_pcbScratch)           DRM_BYTE                    *f_pbScratch,
+    __inout                                 DRM_DWORD                   *f_pcbScratch,
+    __in_bcount(f_cbResponse)         const DRM_BYTE                    *f_pbResponse,
+    __in                                    DRM_DWORD                    f_cbResponse,
+    __inout                                 DRM_BOOL                    *f_pfResponseSignatureChecked,
+    __inout                                 DRM_DWORD                   *f_pdwProtocol,
+    __out_opt                               DRM_RESULT                  *f_pResult );
+
+DRM_API DRM_RESULT DRM_CALL DRM_MTR_GenerateMeterCertChallenge(
+    __inout                                 DRM_SECURECORE_CONTEXT  *f_pSecureCoreCtx,
+    __in                              const DRM_MID                 *f_poMID,
+    __in_ecount_opt(f_cchCustomData)  const DRM_CHAR                *f_pchCustomData,
+    __in                                    DRM_DWORD                f_cchCustomData,
+    __out_bcount_opt(*f_pcbChallenge)       DRM_BYTE                *f_pbChallenge,
+    __inout                                 DRM_DWORD               *f_pcbChallenge );
+
+DRM_API DRM_RESULT DRM_CALL DRM_MTR_ProcessMeterCertResponse(
+    __in                             DRM_LICEVAL_CONTEXT   *f_poLicEvalContext,
+    __in                             DRM_METERCERT_CONTEXT *f_poMeterCertStoreContext,
+    __in_bcount(*f_pcbScratch)       DRM_BYTE              *f_pbScratch,
+    __inout                          DRM_DWORD             *f_pcbScratch,
+    __in_bcount(f_cbResponse)  const DRM_BYTE              *f_pbResponse,
+    __in                             DRM_DWORD              f_cbResponse,
+    __out_opt                        DRM_RESULT            *f_pResult );
+
+EXIT_PK_NAMESPACE;
+
+#endif /* __DRMMETERIMPL_H__ */
+
diff --git a/prebuilt-v4.4/noarch/include/drmmodelrevocation.h b/prebuilt-v4.4/noarch/include/drmmodelrevocation.h
new file mode 100644
index 0000000..73311dc
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmmodelrevocation.h
@@ -0,0 +1,25 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __DRMMODELREVOCATION_H__
+#define __DRMMODELREVOCATION_H__
+
+#include <drmtypes.h>
+#include <drmbcrltypes.h>
+
+ENTER_PK_NAMESPACE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_MODELREVOCATION_CheckIfPlayReadyModelRevoked(
+    __in       DRM_VOID *f_pOEMContext,
+    __in const DRM_BCRL *f_pPRMainCRL,
+    __out      DRM_BOOL *f_pfStoreCRL ) DRM_NO_INLINE_ATTRIBUTE;
+
+EXIT_PK_NAMESPACE;
+
+#endif /*__DRMMODELREVOCATION_H__ */
+
diff --git a/prebuilt-v4.4/noarch/include/drmmodulesupport.h b/prebuilt-v4.4/noarch/include/drmmodulesupport.h
new file mode 100644
index 0000000..ef2be3a
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmmodulesupport.h
@@ -0,0 +1,223 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __DRMMODULESUPPORT_H__
+#define __DRMMODULESUPPORT_H__
+
+#include <drmtypes.h>
+#include <drmactivation.h>
+#include <drmsecurecoretypes.h>
+
+ENTER_PK_NAMESPACE;
+
+/***************************************************************************
+**
+** Declare the DRM_MODULEX_IsModuleXSupported functions for all modules.
+**
+***************************************************************************/
+
+DRM_NO_INLINE DRM_API DRM_BOOL DRM_CALL DRM_ARCLK_IsAntirollbackClockSupported( DRM_VOID ) DRM_NO_INLINE_ATTRIBUTE;
+DRM_API DRM_BOOL DRM_CALL DRM_ARCLK_IsAntirollbackClockUnsupported( DRM_VOID );
+DRM_NO_INLINE DRM_API const DRM_ANSI_CONST_STRING *DRM_CALL DRM_ARCLK_GetReeFeatureXml( DRM_VOID ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_BOOL DRM_CALL DRM_CDMI_IsCdmiSupported( DRM_VOID ) DRM_NO_INLINE_ATTRIBUTE;
+DRM_NO_INLINE DRM_API DRM_BOOL DRM_CALL DRM_CDMI_IsCdmiUnsupported( DRM_VOID ) DRM_NO_INLINE_ATTRIBUTE;
+DRM_NO_INLINE DRM_API const DRM_ANSI_CONST_STRING *DRM_CALL DRM_CDMI_GetReeFeatureXml( DRM_VOID ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_API DRM_BOOL DRM_CALL DRM_CLEANSTORE_IsCleanStoreSupported( DRM_VOID );
+DRM_API DRM_BOOL DRM_CALL DRM_CLEANSTORE_IsCleanStoreUnsupported( DRM_VOID );
+DRM_NO_INLINE DRM_API const DRM_ANSI_CONST_STRING *DRM_CALL DRM_CLEANSTORE_GetReeFeatureXml( DRM_VOID ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_API DRM_BOOL DRM_CALL DRM_CONTRACT_IsContractSupported( DRM_VOID );
+DRM_API DRM_BOOL DRM_CALL DRM_CONTRACT_IsContractUnsupported( DRM_VOID );
+DRM_NO_INLINE DRM_API const DRM_ANSI_CONST_STRING *DRM_CALL DRM_CONTRACT_GetReeFeatureXml( DRM_VOID ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_API DRM_BOOL DRM_CALL DRM_CRT_IsCRTSupported( DRM_VOID );
+DRM_API DRM_BOOL DRM_CALL DRM_CRT_IsCRTUnsupported( DRM_VOID );
+DRM_NO_INLINE DRM_API const DRM_ANSI_CONST_STRING *DRM_CALL DRM_CRT_GetReeFeatureXml( DRM_VOID ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_BOOL DRM_CALL DRM_DEVICEASSETS_IsDeviceAssetsSupported( DRM_VOID ) DRM_NO_INLINE_ATTRIBUTE;
+DRM_NO_INLINE DRM_API DRM_BOOL DRM_CALL DRM_DEVICEASSETS_IsDeviceAssetsUnsupported( DRM_VOID ) DRM_NO_INLINE_ATTRIBUTE;
+DRM_NO_INLINE DRM_API const DRM_ANSI_CONST_STRING *DRM_CALL DRM_DEVICEASSETS_GetReeFeatureXml( DRM_VOID ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_BOOL DRM_CALL DRM_DOMAIN_IsDomainSupported( DRM_VOID ) DRM_NO_INLINE_ATTRIBUTE;
+DRM_API DRM_BOOL DRM_CALL DRM_DOMAIN_IsDomainUnsupported( DRM_VOID );
+DRM_NO_INLINE DRM_API const DRM_ANSI_CONST_STRING *DRM_CALL DRM_DOMAIN_GetReeFeatureXml( DRM_VOID ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_BOOL DRM_CALL DRM_EST_IsESTSupported( DRM_VOID ) DRM_NO_INLINE_ATTRIBUTE;
+DRM_NO_INLINE DRM_API DRM_BOOL DRM_CALL DRM_EST_IsESTUnsupported( DRM_VOID ) DRM_NO_INLINE_ATTRIBUTE;
+DRM_NO_INLINE DRM_API const DRM_ANSI_CONST_STRING *DRM_CALL DRM_EST_GetReeFeatureXml( DRM_VOID ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_API DRM_BOOL DRM_CALL DRM_HDS_IsHDSSupported( DRM_VOID );
+DRM_API DRM_BOOL DRM_CALL DRM_HDS_IsHDSUnsupported( DRM_VOID );
+DRM_NO_INLINE DRM_API const DRM_ANSI_CONST_STRING *DRM_CALL DRM_HDS_GetReeFeatureXml( DRM_VOID ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_API DRM_BOOL DRM_CALL DRM_HBHC_IsHdsBlockHeaderCacheSupported( DRM_VOID );
+DRM_API DRM_BOOL DRM_CALL DRM_HBHC_IsHdsBlockHeaderCacheUnsupported( DRM_VOID );
+DRM_NO_INLINE DRM_API const DRM_ANSI_CONST_STRING *DRM_CALL DRM_HBHC_GetReeFeatureXml( DRM_VOID ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_API DRM_BOOL DRM_CALL DRM_HDSSESSION_IsHDSSessionSupported( DRM_VOID );
+DRM_API DRM_BOOL DRM_CALL DRM_HDSSESSION_IsHDSSessionUnsupported( DRM_VOID );
+DRM_NO_INLINE DRM_API const DRM_ANSI_CONST_STRING *DRM_CALL DRM_HDSSESSION_GetReeFeatureXml( DRM_VOID ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_BOOL DRM_CALL DRM_LICGEN_IsLicGenSupported( DRM_VOID ) DRM_NO_INLINE_ATTRIBUTE;
+DRM_NO_INLINE DRM_API DRM_BOOL DRM_CALL DRM_LICGEN_IsLicGenUnsupported( DRM_VOID ) DRM_NO_INLINE_ATTRIBUTE;
+DRM_NO_INLINE DRM_API const DRM_ANSI_CONST_STRING *DRM_CALL DRM_LICGEN_GetReeFeatureXml( DRM_VOID ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_BOOL DRM_CALL DRM_KG_IsKeyGenSupported( DRM_VOID ) DRM_NO_INLINE_ATTRIBUTE;
+DRM_NO_INLINE DRM_API DRM_BOOL DRM_CALL DRM_KG_IsKeyGenUnsupported( DRM_VOID ) DRM_NO_INLINE_ATTRIBUTE;
+DRM_NO_INLINE DRM_API const DRM_ANSI_CONST_STRING *DRM_CALL DRM_KG_GetReeFeatureXml( DRM_VOID ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_API DRM_BOOL DRM_CALL DRM_METERCERTREVOCATION_IsMeterCertRevocationSupported( DRM_VOID );
+DRM_API DRM_BOOL DRM_CALL DRM_METERCERTREVOCATION_IsMeterCertRevocationUnsupported( DRM_VOID );
+DRM_NO_INLINE DRM_API const DRM_ANSI_CONST_STRING *DRM_CALL DRM_METERCERTREVOCATION_GetReeFeatureXml( DRM_VOID ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_BOOL DRM_CALL DRM_METERING_IsMeteringSupported( DRM_VOID ) DRM_NO_INLINE_ATTRIBUTE;
+DRM_API DRM_BOOL DRM_CALL DRM_METERING_IsMeteringUnsupported( DRM_VOID );
+DRM_NO_INLINE DRM_API const DRM_ANSI_CONST_STRING *DRM_CALL DRM_METERING_GetReeFeatureXml( DRM_VOID ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_BOOL DRM_CALL DRM_MODELREVOCATION_IsModelRevocationSupported( DRM_VOID ) DRM_NO_INLINE_ATTRIBUTE;
+DRM_API DRM_BOOL DRM_CALL DRM_MODELREVOCATION_IsModelRevocationUnsupported( DRM_VOID );
+DRM_NO_INLINE DRM_API const DRM_ANSI_CONST_STRING *DRM_CALL DRM_MODELREVOCATION_GetReeFeatureXml( DRM_VOID ) DRM_NO_INLINE_ATTRIBUTE;
+
+#define DRM_NST_IsNSTSupported()   DRM_EST_IsESTSupported()
+#define DRM_NST_IsNSTUnsupported() DRM_EST_IsESTUnsupported()
+DRM_NO_INLINE DRM_API const DRM_ANSI_CONST_STRING *DRM_CALL DRM_NST_GetReeFeatureXml( DRM_VOID ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_BOOL DRM_CALL DRM_PERF_IsPerformanceSupported( DRM_VOID ) DRM_NO_INLINE_ATTRIBUTE;
+DRM_NO_INLINE DRM_API DRM_BOOL DRM_CALL DRM_PERF_IsPerformanceUnsupported( DRM_VOID ) DRM_NO_INLINE_ATTRIBUTE;
+DRM_NO_INLINE DRM_API const DRM_ANSI_CONST_STRING *DRM_CALL DRM_PERF_GetReeFeatureXml( DRM_VOID ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_BOOL DRM_CALL DRM_PROFILING_IsProfilingSupported( DRM_VOID ) DRM_NO_INLINE_ATTRIBUTE;
+DRM_NO_INLINE DRM_API DRM_BOOL DRM_CALL DRM_PROFILING_IsProfilingUnsupported( DRM_VOID ) DRM_NO_INLINE_ATTRIBUTE;
+DRM_NO_INLINE DRM_API const DRM_ANSI_CONST_STRING *DRM_CALL DRM_PROFILING_GetReeFeatureXml( DRM_VOID ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_BOOL DRM_CALL DRM_REACT_IsReactivationSupported( DRM_VOID ) DRM_NO_INLINE_ATTRIBUTE;
+DRM_NO_INLINE DRM_API DRM_BOOL DRM_CALL DRM_REACT_IsReactivationUnsupported( DRM_VOID ) DRM_NO_INLINE_ATTRIBUTE;
+DRM_NO_INLINE DRM_API const DRM_ANSI_CONST_STRING *DRM_CALL DRM_REACT_GetReeFeatureXml( DRM_VOID ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_BOOL DRM_CALL DRM_REVOCATION_IsRevocationSupported( DRM_VOID ) DRM_NO_INLINE_ATTRIBUTE;
+#define DRM_REVOCATION_IsV1RIVSupported(x) DRM_LEGACYXMLCERT_IsLegacyXMLCertSupported(x)
+DRM_NO_INLINE DRM_API const DRM_ANSI_CONST_STRING *DRM_CALL DRM_REVOCATION_GetReeFeatureXml( DRM_VOID ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_BOOL DRM_CALL DRM_SECUREDELETE_IsSecureDeleteSupported( DRM_VOID ) DRM_NO_INLINE_ATTRIBUTE;
+DRM_NO_INLINE DRM_API DRM_BOOL DRM_CALL DRM_SECUREDELETE_IsSecureDeleteUnsupported( DRM_VOID ) DRM_NO_INLINE_ATTRIBUTE;
+DRM_NO_INLINE DRM_API const DRM_ANSI_CONST_STRING *DRM_CALL DRM_SECUREDELETE_GetReeFeatureXml( DRM_VOID ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_BOOL DRM_CALL DRM_SECURESTOP_IsSecureStopSupported( DRM_VOID ) DRM_NO_INLINE_ATTRIBUTE;
+DRM_NO_INLINE DRM_API DRM_BOOL DRM_CALL DRM_SECURESTOP_IsSecureStopUnsupported( DRM_VOID ) DRM_NO_INLINE_ATTRIBUTE;
+DRM_NO_INLINE DRM_API const DRM_ANSI_CONST_STRING *DRM_CALL DRM_SECURESTOP_GetReeFeatureXml( DRM_VOID ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_BOOL DRM_CALL DRM_SECURETIME_IsSecureTimeSupported( DRM_VOID ) DRM_NO_INLINE_ATTRIBUTE;
+DRM_NO_INLINE DRM_API DRM_BOOL DRM_CALL DRM_SECURETIME_IsSecureTimeUnsupported( DRM_VOID ) DRM_NO_INLINE_ATTRIBUTE;
+DRM_NO_INLINE DRM_API const DRM_ANSI_CONST_STRING *DRM_CALL DRM_SECURETIME_GetReeFeatureXml( DRM_VOID ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_BOOL DRM_CALL DRM_STRUCTURED_IsStructuredSerializationSupported( DRM_VOID ) DRM_NO_INLINE_ATTRIBUTE;
+DRM_NO_INLINE DRM_API DRM_BOOL DRM_CALL DRM_STRUCTURED_IsStructuredSerializationUnsupported( DRM_VOID ) DRM_NO_INLINE_ATTRIBUTE;
+DRM_NO_INLINE DRM_API const DRM_ANSI_CONST_STRING *DRM_CALL DRM_STRUCTURED_GetReeFeatureXml( DRM_VOID ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_API DRM_BOOL DRM_CALL DRM_LEGACYXMLCERT_IsLegacyXMLCertSupported( _In_ DRM_SECURECORE_CONTEXT *f_pSecureCoreCtx ) DRM_NO_INLINE_ATTRIBUTE;
+DRM_API DRM_BOOL DRM_CALL DRM_LEGACYXMLCERT_IsLegacyXMLCertSupported_NoContext( DRM_VOID ) DRM_NO_INLINE_ATTRIBUTE;
+DRM_NO_INLINE DRM_API const DRM_ANSI_CONST_STRING *DRM_CALL DRM_LEGACYXMLCERT_GetReeFeatureXml( DRM_VOID ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_API DRM_BOOL DRM_CALL DRM_XMLHASH_IsXmlHashSupported( DRM_VOID );
+DRM_API DRM_BOOL DRM_CALL DRM_XMLHASH_IsXmlHashUnsupported( DRM_VOID );
+DRM_NO_INLINE DRM_API const DRM_ANSI_CONST_STRING *DRM_CALL DRM_XMLHASH_GetReeFeatureXml( DRM_VOID ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_BOOL DRM_CALL DRM_H264_IsSupported( DRM_VOID ) DRM_NO_INLINE_ATTRIBUTE;
+/*
+** The H.264 slice header parsing code is only linked into the TEE and only when the DRM_TEE_H264_PreProcessEncryptedData API is supported.
+** Because there is no public API associated with this functionality, and we may or may not add one in the future, we do not include this in
+** the FeatureXml information we send to the server since it's effectively FALSE for the REE and TEE support is specified by relevant TEE API
+** information.  If we add a public API for this later, that is when we will add associated FeatureXml API.
+*/
+
+DRM_NO_INLINE DRM_API DRM_BOOL DRM_CALL DRM_COCKTAIL_IsSupported( DRM_VOID ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_BOOL DRM_CALL DRM_LICACQ_IsLicacqSupported( DRM_VOID ) DRM_NO_INLINE_ATTRIBUTE;
+DRM_NO_INLINE DRM_API const DRM_ANSI_CONST_STRING *DRM_CALL DRM_LICACQ_GetReeFeatureXml( DRM_VOID ) DRM_NO_INLINE_ATTRIBUTE;
+
+typedef const DRM_ANSI_CONST_STRING *( DRM_CALL *pfnReeFeatureXmlFunc )();
+
+#define DRM_ALL_REE_FEATURE_XML_FUNCS                               \
+            DRM_ACTIVATION_GetReeFeatureXml,                        \
+            DRM_ARCLK_GetReeFeatureXml,                             \
+            DRM_CDMI_GetReeFeatureXml,                              \
+            DRM_CLEANSTORE_GetReeFeatureXml,                        \
+            DRM_CONTRACT_GetReeFeatureXml,                          \
+            DRM_CRT_GetReeFeatureXml,                               \
+            DRM_DEVICEASSETS_GetReeFeatureXml,                      \
+            DRM_DOMAIN_GetReeFeatureXml,                            \
+            DRM_EST_GetReeFeatureXml,                               \
+            DRM_HDS_GetReeFeatureXml,                               \
+            DRM_HBHC_GetReeFeatureXml,                              \
+            DRM_HDSSESSION_GetReeFeatureXml,                        \
+            DRM_KG_GetReeFeatureXml,                                \
+            DRM_LICGEN_GetReeFeatureXml,                            \
+            DRM_METERCERTREVOCATION_GetReeFeatureXml,               \
+            DRM_METERING_GetReeFeatureXml,                          \
+            DRM_MODELREVOCATION_GetReeFeatureXml,                   \
+            DRM_NST_GetReeFeatureXml,                               \
+            DRM_PERF_GetReeFeatureXml,                              \
+            DRM_REACT_GetReeFeatureXml,                             \
+            DRM_REVOCATION_GetReeFeatureXml,                        \
+            DRM_SECUREDELETE_GetReeFeatureXml,                      \
+            DRM_SECURESTOP_GetReeFeatureXml,                        \
+            DRM_SECURETIME_GetReeFeatureXml,                        \
+            DRM_STRUCTURED_GetReeFeatureXml,                        \
+            DRM_LEGACYXMLCERT_GetReeFeatureXml,                     \
+            DRM_XMLHASH_GetReeFeatureXml,                           \
+            DRM_LICACQ_GetReeFeatureXml,                            \
+
+typedef DRM_BOOL ( DRM_CALL *pfnReeFeatureIsSupported )();
+
+/* 
+** DRM_CRT_IsCRTUnsupported is included because thir will be XML in the REE Features
+** segment when CRT is not supported. EST is included twice because one is for
+** DRM_NST_IsNSTSupported, but because that is just a macro that runs DRM_EST_IsESTSupported,
+** DRM_EST_IsESTSupported is used in its place. 
+*/
+#define DRM_ALL_REE_FEATURE_IS_SUPPORTED_FUNCS                      \
+        DRM_ACTIVATION_IsActivationSupported,                       \
+        DRM_ARCLK_IsAntirollbackClockSupported,                     \
+        DRM_CDMI_IsCdmiSupported,                                   \
+        DRM_CLEANSTORE_IsCleanStoreSupported,                       \
+        DRM_CONTRACT_IsContractSupported,                           \
+        DRM_CRT_IsCRTSupported,                                     \
+        DRM_DEVICEASSETS_IsDeviceAssetsSupported,                   \
+        DRM_DOMAIN_IsDomainSupported,                               \
+        DRM_EST_IsESTSupported,                                     \
+        DRM_HDS_IsHDSSupported,                                     \
+        DRM_HBHC_IsHdsBlockHeaderCacheSupported,                    \
+        DRM_HDSSESSION_IsHDSSessionSupported,                       \
+        DRM_KG_IsKeyGenSupported,                                   \
+        DRM_LICGEN_IsLicGenSupported,                               \
+        DRM_METERCERTREVOCATION_IsMeterCertRevocationSupported,     \
+        DRM_METERING_IsMeteringSupported,                           \
+        DRM_MODELREVOCATION_IsModelRevocationSupported,             \
+        DRM_EST_IsESTSupported,                                     \
+        DRM_PERF_IsPerformanceSupported,                            \
+        DRM_REACT_IsReactivationSupported,                          \
+        DRM_REVOCATION_IsRevocationSupported,                       \
+        DRM_SECUREDELETE_IsSecureDeleteSupported,                   \
+        DRM_SECURESTOP_IsSecureStopSupported,                       \
+        DRM_SECURETIME_IsSecureTimeSupported,                       \
+        DRM_STRUCTURED_IsStructuredSerializationSupported,          \
+        DRM_XMLHASH_IsXmlHashSupported,                             \
+        DRM_LICACQ_IsLicacqSupported,                               \
+
+typedef DRM_BOOL ( DRM_CALL *pfnReeFeatureIsSupportedWithSecureCore )( _In_ DRM_SECURECORE_CONTEXT *f_pSecureCoreCtx );
+
+#define DRM_ALL_REE_FEATURE_IS_SUPPORTED_FUNCS_WITH_SECURE_CORE     \
+        DRM_LEGACYXMLCERT_IsLegacyXMLCertSupported,                 \
+
+
+EXIT_PK_NAMESPACE;
+
+#endif  /* __DRMMODULESUPPORT_H__ */
+
diff --git a/prebuilt-v4.4/noarch/include/drmnamespace.h b/prebuilt-v4.4/noarch/include/drmnamespace.h
new file mode 100644
index 0000000..ac14eff
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmnamespace.h
@@ -0,0 +1,73 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __DRMNAMESPACE_H__
+#define __DRMNAMESPACE_H__
+
+#include <drmfeatures.h>
+
+/*
+# Abstract:
+#
+# This file contains compiler directives for disabling certain compiler-time warnings
+# and allow the PK environment to be compiled under elevated warning level
+#
+#
+*/
+
+/*
+** Set namespace, USE_PK_NAMESPACES is defined in build profile
+*/
+#ifdef __cplusplus
+
+#if USE_PK_NAMESPACES
+/*
+**  Place PK functions in a specific namespace
+*/
+#define ENTER_EXTERN_C_NAMESPACE extern "C" {
+#define EXIT_EXTERN_C_NAMESPACE }
+#define ENTER_PK_NAMESPACE namespace PK {
+#define EXIT_PK_NAMESPACE };
+#define USING_PK_NAMESPACE using namespace PK;
+#define ENTER_PK_NAMESPACE_CODE namespace PK {
+#define EXIT_PK_NAMESPACE_CODE };
+#else /* USE_PK_NAMESPACES */
+/*
+**  Make PK functions appear as simple C functions
+*/
+#define ENTER_EXTERN_C_NAMESPACE extern "C" {
+#define EXIT_EXTERN_C_NAMESPACE }
+#define ENTER_PK_NAMESPACE extern "C" {
+#define EXIT_PK_NAMESPACE }
+#define USING_PK_NAMESPACE
+#define ENTER_PK_NAMESPACE_CODE extern "C" {
+#define EXIT_PK_NAMESPACE_CODE }
+#endif /* USE_PK_NAMESPACES */
+
+#if DRM_INCLUDE_PK_NAMESPACE_USING_STATEMENT
+namespace PK {} /* Make sure namespace is defined before using statement */
+using namespace PK;
+#endif /* DRM_INCLUDE_PK_NAMESPACE_USING_STATEMENT */
+
+#else /* __cplusplus */
+
+/*
+**  Building as C - no need to change prototypes
+*/
+#define ENTER_EXTERN_C_NAMESPACE
+#define EXIT_EXTERN_C_NAMESPACE
+#define ENTER_PK_NAMESPACE
+#define EXIT_PK_NAMESPACE
+#define USING_PK_NAMESPACE
+#define ENTER_PK_NAMESPACE_CODE
+#define EXIT_PK_NAMESPACE_CODE
+
+#endif /* __cplusplus */
+
+#endif  /* __DRMNAMESPACE_H__ */
+
diff --git a/prebuilt-v4.4/noarch/include/drmnoncestore.h b/prebuilt-v4.4/noarch/include/drmnoncestore.h
new file mode 100644
index 0000000..de27d41
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmnoncestore.h
@@ -0,0 +1,128 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __DRM_NONCE_STORE_H
+#define __DRM_NONCE_STORE_H
+
+#include <drmdatastoretypes.h>
+#include <drmembeddedstore_impl.h>
+#include <drmlicstore.h>
+#include <drmmodulesupport.h>
+
+ENTER_PK_NAMESPACE;
+
+/* Define the maximum number of tokens that could be associated with the nonce store */
+#define DRM_MAX_NST_TOKEN_COUNT 100
+
+/* The data structure of a nonce token. */
+typedef struct _tag_DRM_NONCE_TOKEN
+{
+    /* Nonce value. */
+    DRM_ID m_oNonce;
+
+    /* Flag indicating how many licenses have been associated with the token. */
+    DRM_DWORD m_cAllocated;
+
+    /* Indicate wether the token is used or not */
+    DRM_BOOL m_fUsed;
+
+    /* Indicate wether the token has been used to process a license acquisition response or not */
+    DRM_BOOL m_fProcessed;
+} DRM_NONCE_TOKEN;
+
+/* The context of the nonce store. */
+typedef struct _tagDRM_NONCESTORE_CONTEXT_INTERNAL
+{
+    /* Pointer to an OEM context. */
+    DRM_VOID *m_pvOEMContext;
+
+    /* Data store context. */
+    DRM_DST m_oDataStore;
+
+    /* Data store context using embedded store implementation. */
+    DRM_EST_CONTEXT m_oESTContext;
+
+    /* License store context. */
+    DRM_LICSTORE_CONTEXT *m_poLicStoreContext;
+
+    /* Nonce store buffer. */
+    DRM_BYTE *m_pbBuffer;
+
+    /* Size of nonce store buffer. */
+    DRM_DWORD m_cbBuffer;
+
+    /* Flag indicating whether this structure is initialized. */
+    DRM_BOOL m_fInited;
+
+    /* List of nonce tokens. */
+    DRM_NONCE_TOKEN *m_pTokens[DRM_MAX_NST_TOKEN_COUNT];
+
+    /* Count of Tokens currently allocated */
+    DRM_DWORD m_countTokensAllocated;
+
+    DRM_DWORD m_dwWriteIndex;
+} DRM_NONCESTORE_CONTEXT_INTERNAL;
+
+/* The context of the nonce store in the form of a BLOB. */
+typedef struct __tagDRM_NONCESTORE_CONTEXT
+{
+    DRM_BYTE rgbOpaqueData[ sizeof( DRM_NONCESTORE_CONTEXT_INTERNAL ) ];
+} DRM_NONCESTORE_CONTEXT;
+
+DRM_API DRM_RESULT DRM_CALL DRM_NST_Open(
+    __in_opt                        DRM_VOID                *f_pvOEMContext,
+    __in_bcount( f_cbNonceStore )   DRM_BYTE                *f_pbNonceStore,
+    __in                            DRM_DWORD                f_cbNonceStore,
+    __out                           DRM_LICSTORE_CONTEXT    *f_poLicStoreContext,
+    __out                           DRM_NONCESTORE_CONTEXT  *f_poNonceStore );
+
+DRM_API DRM_RESULT DRM_CALL DRM_NST_Close(
+    __in                            DRM_NONCESTORE_CONTEXT  *f_poNonceStore );
+
+DRM_API DRM_RESULT DRM_CALL DRM_NST_SetNonce(
+    __in                            DRM_NONCESTORE_CONTEXT  *f_poNonceStore,
+    __in                            DRM_ID                  *f_poNonce );
+
+DRM_API DRM_RESULT DRM_CALL DRM_NST_AddLicense(
+    __in                            DRM_NONCESTORE_CONTEXT  *f_poNonceStore,
+    __in                            DRM_DWORD                f_cbLicense,
+    __in_bcount( f_cbLicense )      DRM_BYTE                *f_pbLicense,
+    __in const                      DRM_KID                 *f_poKID,
+    __in const                      DRM_LID                 *f_poLID,
+    __in                            DRM_DWORD                f_cLicenses,
+    __out_opt                       DRM_ID                  *f_pidSession );
+
+DRM_API DRM_RESULT DRM_CALL DRM_NST_DeleteLicenses(
+    __in_ecount(1)                  DRM_NONCESTORE_CONTEXT  *f_poNonceStore,
+    __in_ecount(1)            const DRM_ID                  *f_pidSession );
+
+DRM_API DRM_RESULT DRM_CALL DRM_NST_DeleteLicenseByKIDLID(
+    __in_ecount( 1 )                DRM_NONCESTORE_CONTEXT *f_poNonceStore,
+    __in_ecount( 1 )          const DRM_KID                *f_pKID,
+    __in_ecount_opt( 1 )      const DRM_LID                *f_pLID,
+    __out_opt                       DRM_DWORD              *f_pcLicDeleted );
+
+DRM_API DRM_RESULT DRM_CALL DRM_NST_GetLicenses(
+    __in_ecount(1)                          DRM_NONCESTORE_CONTEXT *f_poNonceStore,
+    __in_ecount(1)                    const DRM_ID                 *f_pidSession,
+    __inout                                 DRM_DWORD              *f_pcLicenses,
+    __out_ecount_opt(*f_pcLicenses)         DRM_LID                *f_pLicenses );
+
+DRM_API DRM_RESULT DRM_CALL DRM_NST_ProcessNonce(
+    __in_ecount( 1 )       DRM_NONCESTORE_CONTEXT *f_poNonceStore,
+    __in_ecount( 1 ) const DRM_ID                 *f_pidSession );
+
+DRM_API DRM_RESULT DRM_CALL DRM_NST_GetNonceForLicense(
+    _In_          DRM_NONCESTORE_CONTEXT *f_poNonceStore,
+    _In_    const DRM_LID                *f_pLID,
+    _Out_         DRM_ID                 *f_pidSession );
+
+EXIT_PK_NAMESPACE;
+
+#endif /* __DRM_NONCE_STORE_H */
+
diff --git a/prebuilt-v4.4/noarch/include/drmnonceverify.h b/prebuilt-v4.4/noarch/include/drmnonceverify.h
new file mode 100644
index 0000000..1d8c59f
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmnonceverify.h
@@ -0,0 +1,23 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef _DRMNONCEVERIFY_H_
+#define _DRMNONCEVERIFY_H_ 1
+
+#include <drmtypes.h>
+
+ENTER_PK_NAMESPACE;
+
+DRM_API DRM_RESULT DRM_CALL DRM_NONCE_VerifyNonce(
+    __in const DRM_ID                 *f_poNonce,
+    __in const DRM_LID                *f_poLID,
+    __in       DRM_DWORD               f_cLicenses ) DRM_NO_INLINE_ATTRIBUTE;
+
+EXIT_PK_NAMESPACE;
+
+#endif /* _DRMNONCEVERIFY_H_ */
\ No newline at end of file
diff --git a/prebuilt-v4.4/noarch/include/drmoutputleveltypes.h b/prebuilt-v4.4/noarch/include/drmoutputleveltypes.h
new file mode 100644
index 0000000..379eb45
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmoutputleveltypes.h
@@ -0,0 +1,263 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+/****************************************************************************************************
+**                                                                                                 **
+** Most structures in this file are versioned for binary compatibility.                            **
+**                                                                                                 **
+** Your application code should always use the versioned structure names, e.g.                     **
+** DRM_PLAY_OPL_3_0 and not DRM_PLAY_OPL_LATEST, so that it can be upgraded to future              **
+** PK versions without callback implementation changes excluding any required by                   **
+** any changes to the PlayReady compliance and robustness rules for that future version.           **
+**                                                                                                 **
+** If your application is only talking to the latest version of the PK,                            **
+** only the *_LATEST structures/constants are relevant for versioned structures.                   **
+**                                                                                                 **
+** However, if your application is designed to talk to multiple versions of the PK,                **
+** you may need to check the version on a structure and, if it's older than latest,                **
+** cast it to the older structure corresponding to that version.                                   **
+**                                                                                                 **
+** For example, if the version of the structure you receive matches the _2_0 constant              **
+** instead of the _LATEST constant, you need to cast that structure to the _2_0                    **
+** structure instead of directly using the _3_0 structure you received.                            **
+** This will be the case when your application talks to the PK 2.0 version of the PK               **
+** but not when it talks to the PK 3.0 version of the PK.                                          **
+**                                                                                                 **
+** In addition, some versions of the PK did not properly set their structure versions.             **
+** If the older PKs you are talking include any which indicate "Patch required" below,             **
+** each older PK must be patched or you will receive incorrect structure versions.                 **
+**                                                                                                 **
+****************************************************************************************************/
+
+/****************************************************************************************************
+**                                                                                                 **
+** WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING **
+**                                                                                                 **
+** You should ignore this warning if you are a developer who has licensed the PK from Microsoft.   **
+**                                                                                                 **
+** This warning is for Microsoft internal developers working on the porting kit itself.            **
+**                                                                                                 **
+** Structures in this file must NOT be modified at a binary/layout level.                          **
+** Doing so will break PK customer upgrade scenarios.                                              **
+**                                                                                                 **
+** Instead, create new versioned definitions of any impacted structures, add new version #defines, **
+** and update any impacted _LATEST typdef/#define lines to point to the updated versions.          **
+**                                                                                                 **
+** The only existing lines of code in this file that should CHANGE are the _LATEST lines.          **
+** typedef ... DRM_PLAY_OPL_LATEST and #define VER_DRM_PLAY_OPL_LATEST ... should ALWAYS change.   **
+** Other existing typedefs/#defines should only change if they are being modified from the         **
+** previous version, i.e. newer structure definitions CAN/SHOULD depend on older structure         **
+** definitions whenever possible using new typedefs/#defines (e.g. typedef foo_3_0 foo_4_5).       **
+**                                                                                                 **
+** Other than that, changes should result only in ADDED code for new structures/constants.         **
+**                                                                                                 **
+** PK source code (most code under source\...) should use the _LATEST structures.                  **
+** Exception: The comment in drmcallbacktypes.h uses the current versioned structure.              **
+**                                                                                                 **
+** PK test/tools code (all code under test\..., code under source\tools\... and a few others)      **
+** should always use the *versioned* structures just like an end customer will as described above. **
+** This means that code should continue to compile/work as-is after changes to the source code!    **
+** New test/tools code should be added as appropriate to act on any new data in the structures!    **
+**                                                                                                 **
+** Breaking changes are fine as long as versioning is done properly, but ALL changes must be       **
+** versioned regardless of whether they are breaking or not - e.g. adding a new member at the      **
+** end of a structure still requires updated structure versions.                                   **
+**                                                                                                 **
+** For example, compare DRM_PLAY_OPL_2_0 versus DRM_PLAY_OPL_3_0.                                  **
+** Even if only the dvopi member was added, a new structure version would have been introduced.    **
+**                                                                                                 **
+** WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING **
+**                                                                                                 **
+****************************************************************************************************/
+
+#ifndef __DRM_OUTPUTLEVELTYPES_H__
+#define __DRM_OUTPUTLEVELTYPES_H__
+
+#include <drmtypes.h>
+
+ENTER_PK_NAMESPACE;
+
+static DRM_GLOBAL_CONST DRM_WORD DRM_DEFAULT_MINIMUM_SECURITY_LEVEL = 100;
+
+#define DRM_MAX_EXPLICIT_OUTPUT_PROTECTION_CONFIG_DATA      32
+
+typedef struct __tagDRM_MINIMUM_OUTPUT_PROTECTION_LEVELS
+{
+    DRM_WORD wCompressedDigitalVideo;
+    DRM_WORD wUncompressedDigitalVideo;
+    DRM_WORD wAnalogVideo;
+    DRM_WORD wCompressedDigitalAudio;
+    DRM_WORD wUncompressedDigitalAudio;
+} DRM_MINIMUM_OUTPUT_PROTECTION_LEVELS;
+
+/* Exists only to maintain binary compatibility of structures. */
+typedef struct __tagDRM_OPL_OUTPUT_IDS_RESERVED
+{
+    DRM_WORD  cIds;
+    DRM_GUID  *rgIds;
+} DRM_OPL_OUTPUT_IDS_RESERVED;
+
+
+/*
+** Structures representing a single output protection entry.
+** Structures changed in 3.0 QFE 3 to change dwConfigData to rgbConfigData/cbConfigData.
+** 2.0:                     No patch required.  Versions are properly set to 2 or 3.
+** 3.0 (with QFE 3) to 4.0: Patch required to properly set versions to 4 instead of 2 or 3.
+** 4.1+:                    No patch required.  Versions are properly set to 4.
+*/
+
+/* 2.0 structures */
+#define VER_DRM_ANALOG_VIDEO_OUTPUT_PROTECTION_2_0      2
+#define VER_DRM_AUDIO_OUTPUT_PROTECTION_2_0             3
+typedef struct __tagDRM_OUTPUT_PROTECTION_2_0
+{
+    DRM_DWORD   dwVersion;
+    DRM_GUID    guidId;
+    DRM_DWORD   dwConfigData;
+} DRM_OUTPUT_PROTECTION_2_0;
+
+typedef DRM_OUTPUT_PROTECTION_2_0 DRM_ANALOG_VIDEO_OUTPUT_PROTECTION_2_0;
+typedef DRM_OUTPUT_PROTECTION_2_0 DRM_AUDIO_OUTPUT_PROTECTION_2_0;
+
+/* 3.0 (with QFE 3) definitions */
+#define VER_DRM_ANALOG_VIDEO_OUTPUT_PROTECTION_3_0      4
+#define VER_DRM_AUDIO_OUTPUT_PROTECTION_3_0             4
+#define VER_DRM_DIGITAL_VIDEO_OUTPUT_PROTECTION_3_0     4
+typedef struct __tagDRM_OUTPUT_PROTECTION_3_0
+{
+    DRM_DWORD   dwVersion;
+    DRM_GUID    guidId;
+    DRM_BYTE    rgbConfigData[ DRM_MAX_EXPLICIT_OUTPUT_PROTECTION_CONFIG_DATA ];
+    DRM_DWORD   cbConfigData;
+} DRM_OUTPUT_PROTECTION_3_0;
+
+typedef DRM_OUTPUT_PROTECTION_3_0 DRM_ANALOG_VIDEO_OUTPUT_PROTECTION_3_0;
+typedef DRM_OUTPUT_PROTECTION_3_0 DRM_AUDIO_OUTPUT_PROTECTION_3_0;
+typedef DRM_OUTPUT_PROTECTION_3_0 DRM_DIGITAL_VIDEO_OUTPUT_PROTECTION_3_0;
+
+/* latest definitions */
+#define VER_DRM_ANALOG_VIDEO_OUTPUT_PROTECTION_LATEST   VER_DRM_ANALOG_VIDEO_OUTPUT_PROTECTION_3_0
+#define VER_DRM_AUDIO_OUTPUT_PROTECTION_LATEST          VER_DRM_AUDIO_OUTPUT_PROTECTION_3_0
+#define VER_DRM_DIGITAL_VIDEO_OUTPUT_PROTECTION_LATEST  VER_DRM_DIGITAL_VIDEO_OUTPUT_PROTECTION_3_0
+typedef DRM_ANALOG_VIDEO_OUTPUT_PROTECTION_3_0          DRM_ANALOG_VIDEO_OUTPUT_PROTECTION_LATEST;
+typedef DRM_AUDIO_OUTPUT_PROTECTION_3_0                 DRM_AUDIO_OUTPUT_PROTECTION_LATEST;
+typedef DRM_DIGITAL_VIDEO_OUTPUT_PROTECTION_3_0         DRM_DIGITAL_VIDEO_OUTPUT_PROTECTION_LATEST;
+typedef DRM_OUTPUT_PROTECTION_3_0                       DRM_OUTPUT_PROTECTION_LATEST;
+
+
+
+/*
+** Structures each representing a list of output protection entries.
+** Structures changed in 3.0 QFE 3 due to change in child structure DRM_OUTPUT_PROTECTION_*.
+** 2.x:                     No patch required.  Versions are properly set to 0.
+** 3.0 (with QFE 3) to 4.0: Patch required to properly set versions to 1 instead of 0.
+** 4.1+:                    No patch required.  Versions are properly set to 1.
+*/
+
+/* 2.0 definitions */
+#define VER_DRM_ANALOG_VIDEO_OUTPUT_PROTECTION_IDS_2_0      0
+#define VER_DRM_AUDIO_OUTPUT_PROTECTION_IDS_2_0             0
+typedef struct __tagDRM_ANALOG_VIDEO_OUTPUT_PROTECTION_IDS_2_0
+{
+    DRM_DWORD   dwVersion;
+    DRM_WORD    cEntries;
+    DRM_ANALOG_VIDEO_OUTPUT_PROTECTION_2_0 *rgVop;
+} DRM_ANALOG_VIDEO_OUTPUT_PROTECTION_IDS_2_0;
+
+typedef struct __tagDRM_AUDIO_OUTPUT_PROTECTION_IDS_2_0
+{
+    DRM_DWORD   dwVersion;
+    DRM_WORD    cEntries;
+    DRM_AUDIO_OUTPUT_PROTECTION_2_0 *rgAop;
+} DRM_AUDIO_OUTPUT_PROTECTION_IDS_2_0;
+
+/* 3.0 (with QFE 3) definitions */
+#define VER_DRM_ANALOG_VIDEO_OUTPUT_PROTECTION_IDS_3_0      1
+#define VER_DRM_AUDIO_OUTPUT_PROTECTION_IDS_3_0             1
+#define VER_DRM_DIGITAL_VIDEO_OUTPUT_PROTECTION_IDS_3_0     1
+typedef struct __tagDRM_ANALOG_VIDEO_OUTPUT_PROTECTION_IDS_3_0
+{
+    DRM_DWORD   dwVersion;
+    DRM_WORD    cEntries;
+    DRM_ANALOG_VIDEO_OUTPUT_PROTECTION_3_0 *rgVop;
+} DRM_ANALOG_VIDEO_OUTPUT_PROTECTION_IDS_3_0;
+
+typedef struct __tagDRM_AUDIO_OUTPUT_PROTECTION_IDS_3_0
+{
+    DRM_DWORD   dwVersion;
+    DRM_WORD    cEntries;
+    DRM_AUDIO_OUTPUT_PROTECTION_3_0 *rgAop;
+} DRM_AUDIO_OUTPUT_PROTECTION_IDS_3_0;
+
+typedef struct __tagDRM_DIGITAL_VIDEO_OUTPUT_PROTECTION_IDS_3_0
+{
+    DRM_DWORD   dwVersion;
+    DRM_WORD    cEntries;
+    DRM_DIGITAL_VIDEO_OUTPUT_PROTECTION_3_0 *rgVop;
+} DRM_DIGITAL_VIDEO_OUTPUT_PROTECTION_IDS_3_0;
+
+/* latest definitions */
+#define VER_DRM_ANALOG_VIDEO_OUTPUT_PROTECTION_IDS_LATEST   VER_DRM_ANALOG_VIDEO_OUTPUT_PROTECTION_IDS_3_0
+#define VER_DRM_AUDIO_OUTPUT_PROTECTION_IDS_LATEST          VER_DRM_AUDIO_OUTPUT_PROTECTION_IDS_3_0
+#define VER_DRM_DIGITAL_VIDEO_OUTPUT_PROTECTION_IDS_LATEST  VER_DRM_DIGITAL_VIDEO_OUTPUT_PROTECTION_IDS_3_0
+typedef DRM_ANALOG_VIDEO_OUTPUT_PROTECTION_IDS_3_0  DRM_ANALOG_VIDEO_OUTPUT_PROTECTION_IDS_LATEST;
+typedef DRM_AUDIO_OUTPUT_PROTECTION_IDS_3_0         DRM_AUDIO_OUTPUT_PROTECTION_IDS_LATEST;
+typedef DRM_DIGITAL_VIDEO_OUTPUT_PROTECTION_IDS_3_0 DRM_DIGITAL_VIDEO_OUTPUT_PROTECTION_IDS_LATEST;
+
+
+
+/*
+** Structure representing all output protection information.
+** Structure changed in 3.0 QFE 3 to add dvopi member.
+** Structure changed in 3.0 QFE 3 due to change in child structures DRM_*_OUTPUT_PROTECTION_IDS_*.
+** 2.x:                     No patch required.  Version is properly set to 0.
+** 3.0 (with QFE 3) to 4.0: Patch required to properly set versions to 1 instead of 0.
+** 4.1+:        No patch required.  Version is properly set to 1.
+*/
+
+/* 2.0 definitions */
+#define VER_DRM_PLAY_OPL_2_0    0
+typedef struct __tagDRM_PLAY_OPL_2_0
+{
+    DRM_DWORD                                   dwVersion;
+    DRM_MINIMUM_OUTPUT_PROTECTION_LEVELS        minOPL;
+    DRM_OPL_OUTPUT_IDS_RESERVED                 oplIdReserved;
+    DRM_ANALOG_VIDEO_OUTPUT_PROTECTION_IDS_2_0  vopi;
+    DRM_AUDIO_OUTPUT_PROTECTION_IDS_2_0         aopi;
+} DRM_PLAY_OPL_2_0;
+
+/* 3.0 (with QFE 3) definitions */
+#define VER_DRM_PLAY_OPL_3_0    2
+typedef struct __tagDRM_PLAY_OPL_3_0
+{
+    DRM_DWORD                                   dwVersion;
+    DRM_MINIMUM_OUTPUT_PROTECTION_LEVELS        minOPL;
+    DRM_OPL_OUTPUT_IDS_RESERVED                 oplIdReserved;
+    DRM_ANALOG_VIDEO_OUTPUT_PROTECTION_IDS_3_0  vopi;
+    DRM_AUDIO_OUTPUT_PROTECTION_IDS_3_0         aopi;
+    DRM_DIGITAL_VIDEO_OUTPUT_PROTECTION_IDS_3_0 dvopi;
+} DRM_PLAY_OPL_3_0;
+
+/* latest definitions */
+#define VER_DRM_PLAY_OPL_LATEST VER_DRM_PLAY_OPL_3_0
+typedef DRM_PLAY_OPL_3_0 DRM_PLAY_OPL_LATEST;
+
+
+/* typedefs which enable client code using legacy struct names to continue to compile */
+typedef DRM_OPL_OUTPUT_IDS_RESERVED                 DRM_OPL_OUTPUT_IDS;
+typedef DRM_OUTPUT_PROTECTION_2_0                   DRM_OUTPUT_PROTECTION_EX;
+typedef DRM_ANALOG_VIDEO_OUTPUT_PROTECTION_2_0      DRM_VIDEO_OUTPUT_PROTECTION_EX;
+typedef DRM_AUDIO_OUTPUT_PROTECTION_2_0             DRM_AUDIO_OUTPUT_PROTECTION_EX;
+typedef DRM_ANALOG_VIDEO_OUTPUT_PROTECTION_IDS_2_0  DRM_VIDEO_OUTPUT_PROTECTION_IDS_EX;
+typedef DRM_AUDIO_OUTPUT_PROTECTION_IDS_2_0         DRM_AUDIO_OUTPUT_PROTECTION_IDS_EX;
+typedef DRM_PLAY_OPL_2_0                            DRM_PLAY_OPL_EX2;
+
+EXIT_PK_NAMESPACE;
+
+#endif /* __DRM_OUTPUTLEVELTYPES_H__ */
+
diff --git a/prebuilt-v4.4/noarch/include/drmperformance.h b/prebuilt-v4.4/noarch/include/drmperformance.h
new file mode 100644
index 0000000..ed6aff1
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmperformance.h
@@ -0,0 +1,58 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __DRM_PERFORMANCE__
+#define __DRM_PERFORMANCE__
+
+#include <drmtypes.h>
+#include <drmpragmas.h>
+
+ENTER_PK_NAMESPACE;
+
+typedef enum
+{
+    eDRM_PERF_LogTag_Enter      = 0,
+    eDRM_PERF_LogTag_Exit       = 1,
+    eDRM_PERF_LogTag_Separator  = 2
+} eDRM_PERF_LogTag;
+
+typedef enum
+{
+    eDRM_PERF_LogFunction_Drm_Initialize                        = 0,
+    eDRM_PERF_LogFunction_Drm_Reader_Bind                       = 1,
+    eDRM_PERF_LogFunction_Drm_Reader_Commit                     = 2,
+    eDRM_PERF_LogFunction_Drm_Reader_Decrypt                    = 3,
+    eDRM_PERF_LogFunction_Drm_StoreMgmt_CleanupStore            = 4,
+    eDRM_PERF_LogFunction_Drm_ACT_GenerateChallengeInternal     = 5,
+    eDRM_PERF_LogFunction_Drm_ACT_ProcessWSDLResponseInternal   = 6,
+    eDRM_PERF_LogFunction__EvaluateRealTimeExpiration           = 7,
+    eDRM_PERF_LogFunction_Oem_Aes_CtrProcessData                = 8,
+} eDRM_PERF_LogFunction;
+
+DRM_API DRM_RESULT DRM_CALL DRM_PERF_AllocateLogBuffer(
+    __in const DRM_DWORD  f_dwNumberOfEntries );
+
+DRM_API_VOID DRM_VOID DRM_CALL DRM_PERF_FreeLogBuffer( DRM_VOID );
+
+DRM_API DRM_RESULT DRM_CALL DRM_PERF_DumpLogBuffer(
+    __in_z const DRM_CHAR  *f_pszFilename );
+
+DRM_API DRM_RESULT DRM_CALL DRM_PERF_On( DRM_VOID );
+
+DRM_API_VOID DRM_VOID DRM_CALL DRM_PERF_Off( DRM_VOID );
+
+DRM_API_VOID DRM_VOID DRM_CALL DRM_PERF_LogMicrosecondCount(
+    __in   const      eDRM_PERF_LogTag      f_eLogTag,
+    __in   const      eDRM_PERF_LogFunction f_eLogFunction );
+
+DRM_API DRM_RESULT DRM_CALL DRM_PERF_LogSeparator( DRM_VOID );
+
+EXIT_PK_NAMESPACE;
+
+#endif  /* __DRM_PERFORMANCE__ */
+
diff --git a/prebuilt-v4.4/noarch/include/drmplayreadyobj.h b/prebuilt-v4.4/noarch/include/drmplayreadyobj.h
new file mode 100644
index 0000000..0ecf4ef
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmplayreadyobj.h
@@ -0,0 +1,154 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __DRMPLAYREADYOBJ_H__
+#define __DRMPLAYREADYOBJ_H__
+
+#include <oemciphertypes.h>
+#include <drmembeddedstore_impl.h>
+#include <drmheaderparser.h>
+#include <drmmodulesupport.h>
+
+ENTER_PK_NAMESPACE;
+
+#define DRM_MAX_HEADERDATASIZE        ( 5 * 1024 )                         /* 5K of header data  */
+#define DRM_MAX_HEADERDATA_KID_COUNT  ((DRM_DWORD)300)                     /* No more than 300 KIDs allowed in a header */
+
+/*
+** PlayReady Data Header Format
+**
+** Field         | Type
+** -----------------------------
+** Data Size     | DWORD
+** Record Count  | WORD
+*/
+#define SIZE_OF_DRM_PLAYREADY_DATA_HEADER   ( sizeof( DRM_DWORD ) + sizeof( DRM_WORD ) )
+
+/*
+** PlayReady Record Header Format
+**
+** Field         | Type
+** -----------------------------
+** Record Type   | WORD
+** Record Size   | WORD
+*/
+#define SIZE_OF_DRM_PLAYREADY_RECORD_HEADER ( 2 * sizeof( DRM_WORD ) )
+#define SIZE_OF_PLAYREADY_EMBEDDED_LICENSE_SPACE (1024*10)
+
+/*
+** Contains space for the PlayReady Object header, two record headers,
+** XML header data, and the embedded license store.
+*/
+#define DRM_STANDARD_PLAYREADYOBJSIZE   ( SIZE_OF_DRM_PLAYREADY_DATA_HEADER + 2 * SIZE_OF_DRM_PLAYREADY_RECORD_HEADER + DRM_MAX_HEADERDATASIZE + MAX_EMBEDDED_STORE_LEN )
+
+typedef enum __tag_eDRMPlayReady_RECORD_TYPES
+{
+    PLAYREADY_WRMHEADER              = 0x0001,
+    PLAYREADY_V4_SIGNATURE           = 0x0002,
+    PLAYREADY_EMBEDDED_LICENSE_STORE = 0x0003
+} eDRMPlayReady_RECORD_TYPES;
+
+#define RECORD_TYPE_TO_BIT( eRecordType )                   ( 1 << ( ( (DRM_DWORD)(eRecordType) ) - 1 ) )
+#define IS_RECORD_TYPE_BIT_SET( eBitMask, eRecordType )     ( ( (eBitMask) & RECORD_TYPE_TO_BIT(eRecordType) ) != 0 )
+
+typedef enum __tag_eDRM_DECRYPTORSETUP_TYPE
+{
+    DRM_DECRYPTORSETUP_INVALID     = 0,
+    DRM_DECRYPTORSETUP_ONDEMAND    = 1,
+    DRM_DECRYPTORSETUP_MAX_DEFINED = 1,
+} eDRM_DECRYPTORSETUP_TYPE;
+
+DRM_API DRM_RESULT DRM_CALL DRM_PRO_GetRMHeaderVersion(
+    __in_bcount( f_cbHeader ) const DRM_BYTE            *f_pbHeader,
+    __in                      const DRM_DWORD            f_cbHeader,
+    __out_ecount( 1 )               eDRM_HEADER_VERSION *f_peVersion );
+
+DRM_API DRM_RESULT DRM_CALL DRM_PRO_IsValidObject(
+    __in_bcount( f_cbBuffer ) const DRM_BYTE  *f_pbBuffer,
+    __in                      const DRM_DWORD  f_cbBuffer,
+    __out_opt                       DRM_DWORD *f_pdwRecordTypeBitMask );
+
+DRM_API DRM_RESULT DRM_CALL DRM_PRO_GetRecord(
+    __in_bcount( f_cbBuffer )                const DRM_BYTE   *f_pbBuffer,
+    __in                                     const DRM_DWORD   f_cbBuffer,
+    __in                                           DRM_WORD    f_wRecordType,
+    __deref_out_bcount(*f_pcbEmbeddedRecord)       DRM_BYTE  **f_ppbEmbeddedRecord,
+    __out                                          DRM_DWORD  *f_pcbEmbeddedRecord );
+
+DRM_API DRM_RESULT DRM_CALL DRM_PRO_Create(
+    __in_opt                                  DRM_CONST_STRING           *f_pdstrPlayReadyHeader,
+    __out_bcount_opt( *f_pcbPlayReadyObject ) DRM_BYTE                   *f_pbPlayReadyObject,
+    __inout                                   DRM_DWORD                  *f_pcbPlayReadyObject,
+    __in                                      DRM_DWORD                   f_cbEmbeddedStore );
+
+DRM_API DRM_RESULT DRM_CALL DRM_PRO_GetCipherTypeFromPlayReadyHeader(
+    __in_bcount( f_cbPlayReadyHeader ) const DRM_BYTE                 *f_pbPlayReadyHeader,
+    __in                                     DRM_DWORD                 f_cbPlayReadyHeader,
+    __out                                    DRM_SUPPORTED_CIPHERS    *f_peCipherType );
+
+DRM_API DRM_RESULT DRM_CALL DRM_PRO_GetCipherType(
+    __in_bcount( f_cbPlayReadyObject ) const DRM_BYTE                 *f_pbPlayReadyObject,
+    __in                                     DRM_DWORD                 f_cbPlayReadyObject,
+    __out                                    DRM_SUPPORTED_CIPHERS    *f_peCipherType );
+
+DRM_API DRM_RESULT DRM_CALL DRM_PRO_GetDecryptorSetupTypeFromPlayReadyHeader(
+    __in_ecount( f_cbPlayReadyHeader ) const DRM_BYTE                 *f_pbPlayReadyHeader,
+    __in                                     DRM_DWORD                 f_cbPlayReadyHeader,
+    __out_ecount( 1 )                        eDRM_DECRYPTORSETUP_TYPE *f_peDecryptorSetupType );
+
+DRM_API DRM_RESULT DRM_CALL DRM_PRO_GetDecryptorSetupType(
+    __in_ecount( f_cbPlayReadyObject ) const DRM_BYTE                 *f_pbPlayReadyObject,
+    __in                                     DRM_DWORD                 f_cbPlayReadyObject,
+    __out_ecount( 1 )                        eDRM_DECRYPTORSETUP_TYPE *f_peDecryptorSetupType );
+
+DRM_API DRM_RESULT DRM_CALL DRM_PRO_CalculateRMHeaderChecksum(
+    __in                                const DRM_SUPPORTED_CIPHERS             f_eCipherType,
+    __in_bcount( f_cbContentKey )       const DRM_BYTE                         *f_pbContentKey,
+    __in                                const DRM_DWORD                         f_cbContentKey,
+    __in_ecount_opt( 1 )                const DRM_KID                          *f_pKID,
+    __inout_bcount_opt( *f_pcbChecksum )      DRM_BYTE                         *f_pbChecksum,
+    __in                                      DRM_DWORD                        *f_pcbChecksum );
+
+DRM_API DRM_RESULT DRM_CALL DRM_PRO_CreateRMHeader(
+    __in                                const eDRM_HEADER_VERSION    f_eWRMHeaderVersion,
+    __in                                const DRM_SUPPORTED_CIPHERS  f_eCipherType,
+    __in                                      DRM_DWORD              f_cKIDs,
+    __in_ecount_nz( f_cKIDs )           const DRM_CONST_STRING      *f_pdstrKIDs,
+    __in_ecount_nz_opt( f_cKIDs )       const DRM_CONST_STRING      *f_pdstrCheckSums,
+    __in_ecount_nz_opt( 1 )             const DRM_CONST_STRING      *f_pdstrPlayReadySilentURL,
+    __in_ecount_nz_opt( 1 )             const DRM_CONST_STRING      *f_pdstrPlayReadyNonSilentURL,
+    __in_ecount_nz_opt( 1 )             const DRM_CONST_STRING      *f_pdstrServiceID,
+    __in_ecount_nz_opt( 1 )             const DRM_CONST_STRING      *f_pdstrCustomAttributesXML,
+    __in_ecount_nz_opt( 1 )             const DRM_CONST_STRING      *f_pdstrDecryptorSetup,
+    __inout_bcount_opt( *f_pcbRightsManagementHeader )
+                                              DRM_BYTE              *f_pbRightsManagementHeader,
+    __in                                      DRM_DWORD             *f_pcbRightsManagementHeader );
+
+DRM_API DRM_RESULT DRM_CALL DRM_PRO_ConvertHeaderFromWmdrmToPlayReady(
+    __in_bcount( f_cbWmdrmHeader )      const DRM_BYTE  *f_pbWmdrmHeader,
+    __in                                const DRM_DWORD  f_cbWmdrmHeader,
+    __in_ecount_nz_opt( f_cchPlayReadySilentURL )
+                                        const DRM_WCHAR *f_pwchPlayReadySilentURL,
+    __in                                const DRM_DWORD  f_cchPlayReadySilentURL,
+    __in_ecount_nz_opt( f_cchPlayReadyNonSilentURL )
+                                        const DRM_WCHAR *f_pwchPlayReadyNonSilentURL,
+    __in                                const DRM_DWORD  f_cchPlayReadyNonSilentURL,
+    __in_ecount_nz_opt( f_cchServiceID )
+                                        const DRM_WCHAR *f_pwchServiceID,
+    __in                                const DRM_DWORD  f_cchServiceID,
+    __in_ecount_nz_opt( f_cchCustomAttributes )
+                                        const DRM_WCHAR *f_pwchCustomAttributes,
+    __in                                const DRM_DWORD  f_cchCustomAttributes,
+    __inout_bcount_opt( *f_pcbPlayReadyHeader )
+                                              DRM_BYTE  *f_pbPlayReadyHeader,
+    __in                                      DRM_DWORD *f_pcbPlayReadyHeader );
+
+EXIT_PK_NAMESPACE;
+
+#endif /* __DRMPLAYREADYOBJ_H__ */
+
diff --git a/prebuilt-v4.4/noarch/include/drmplayreadyobjconstants.h b/prebuilt-v4.4/noarch/include/drmplayreadyobjconstants.h
new file mode 100644
index 0000000..dd304a7
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmplayreadyobjconstants.h
@@ -0,0 +1,31 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __DRMPLAYREADYOBJCONSTANTS_H__
+#define __DRMPLAYREADYOBJCONSTANTS_H__
+
+#include <drmtypes.h>
+
+ENTER_PK_NAMESPACE;
+
+    extern DRM_GLOBAL_CONST  DRM_CONST_STRING       g_dstrOpenNodeWRMHeaderV4;
+    extern DRM_GLOBAL_CONST  DRM_CONST_STRING       g_dstrOpenNodeWRMHeaderV4_1;
+    extern DRM_GLOBAL_CONST  DRM_CONST_STRING       g_dstrOpenNodeWRMHeaderV4_2;
+    extern DRM_GLOBAL_CONST  DRM_CONST_STRING       g_dstrOpenNodeWRMHeaderV4_3;
+    extern DRM_GLOBAL_CONST  DRM_CONST_STRING       g_dstrTagV2;
+    extern DRM_GLOBAL_CONST  DRM_CONST_STRING       g_dstrTagV2_4;
+    extern DRM_GLOBAL_CONST  DRM_CONST_STRING       g_dstrTagV4;
+    extern DRM_GLOBAL_CONST  DRM_CONST_STRING       g_dstrTagV4_1;
+    extern DRM_GLOBAL_CONST  DRM_CONST_STRING       g_dstrTagV4_2;
+    extern DRM_GLOBAL_CONST  DRM_CONST_STRING       g_dstrTagV4_3;
+    extern DRM_GLOBAL_CONST  DRM_CONST_STRING       g_dstrTagContentXML;
+
+EXIT_PK_NAMESPACE;
+
+#endif /* __DRMPLAYREADYOBJCONSTANTS_H__ */
+
diff --git a/prebuilt-v4.4/noarch/include/drmpragmas.h b/prebuilt-v4.4/noarch/include/drmpragmas.h
new file mode 100644
index 0000000..0db1723
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmpragmas.h
@@ -0,0 +1,117 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __DRMPRAGMAS_H__
+#define __DRMPRAGMAS_H__
+
+#include <drmcompiler.h>
+
+/*
+# Abstract:
+#
+# This file contains compiler directives for disabling certain compiler-time warnings
+# and allow the PK environment to be compiled under elevated warning level.
+#
+# For example, Microsoft compiler can use warning level /W4
+#
+*/
+
+#ifndef TRUE
+    #define TRUE  1
+#endif
+
+#ifndef FALSE
+    #define FALSE 0
+#endif
+
+#if defined (DRM_MSC_VER)
+
+/*
+** We need to ignore unknown pragmas if not using prefast.
+*/
+#ifndef _PREFAST_
+    #pragma warning(disable:4068)
+#endif
+
+/*
+** Pragmas to disable. These warnings are expected.
+*/
+#pragma warning(disable:4100)  /* unreferenced formal parameter */
+#pragma warning(disable:4510)  /* default constructor not possible for structure w/const field */
+#pragma warning(disable:4512)  /* assignment operator not possible for struct w/const field */
+#pragma warning(disable:4610)  /* struct non-instantiatable due to const field */
+
+/*
+** Pragmas to enable.  These warnings are explicitly enabled at level 3.
+*/
+#pragma warning(3:4101) /* unreferenced local variable */
+#pragma warning(3:4152) /* nonstandard extension, function/data pointer conversion in expression */
+#pragma warning(3:4189) /* local variable is initialized but not referenced */
+#pragma warning(3:4244) /* conversion from 'type1' to 'type2', possible loss of data */
+#pragma warning(3:4245) /* conversion from 'type1' to 'type2', signed/unsigned mismatch */
+#pragma warning(3:4287) /* 'operator' : unsigned/negative constant mismatch */
+#pragma warning(3:4302) /* 'conversion' : truncation from 'type 1' to 'type 2' */
+#pragma warning(3:4310) /* cast truncates constant value */
+#pragma warning(3:4365) /* 'action' : conversion from 'type_1' to 'type_2', signed/unsigned mismatch */
+#pragma warning(3:4505) /* unreferenced local function has been removed */
+#pragma warning(3:4826) /* Conversion from 'type1 ' to 'type_2' is sign-extended. This may cause unexpected runtime behavior. */
+
+#if ( DRM_MSC_VER >= 1900 )
+#pragma warning(3:4127)         /* "conditional expression is constant" */
+#else   /* ( DRM_MSC_VER >= 1900 ) */
+#pragma warning(disable:4127)   /* "conditional expression is constant" */
+#endif  /* ( DRM_MSC_VER >= 1900 ) */
+
+/*
+** Pragmas to disable.  These warnings are expected but are specific to amd64 and ia64.
+*/
+#if defined(_M_AMD64) || defined(_M_IA64)
+#pragma warning(disable:4366) /* The result of the unary operator may be unaligned */
+#endif /* _M_AMD64 */
+
+/*
+** Disable select PREfast warnings.
+*/
+#ifdef _PREFAST_
+#include <drmsal.h>
+__pragma(prefast(disable:__WARNING_ENUM_TYPEDEF_5496,"typedef is required in strict ANSI C"))
+__pragma(prefast(disable:__WARNING_ENUM_TYPEDEF_25096,"typedef is required in strict ANSI C"))
+__pragma(prefast(disable:__WARNING_POOR_DATA_ALIGNMENT_25021,"Since PlayReady ships as source code, it is more important for types to be human-readable for member sequencing than minimum sized."))
+__pragma(prefast(disable:__WARNING_UNUSED_ASSIGNMENT_28931,"Debug code often assigns values to variables which are then never referenced in order to enable viewing in the debugger."))
+#endif
+
+#define DRM_DO do
+
+#define DRM_WHILE_FALSE             \
+__pragma( warning( push ) )         \
+__pragma( warning( disable:4127 ) ) \
+   while( FALSE )                   \
+__pragma( warning( pop ) )
+
+#define DRM_WHILE_TRUE              \
+__pragma( warning( push ) )         \
+__pragma( warning( disable:4127 ) ) \
+   while( TRUE )                    \
+__pragma( warning( pop ) )
+
+#define DRM_FOR_INFINITE for( ;; )
+
+#else /* DRM_MSC_VER */
+
+#define DRM_DO do
+
+#define DRM_WHILE_FALSE while( FALSE )
+
+#define DRM_WHILE_TRUE while( TRUE )
+
+#define DRM_FOR_INFINITE for( ;; )
+
+#endif  /* DRM_MSC_VER */
+
+#endif  /* __DRMPRAGMAS_H__ */
+
diff --git a/prebuilt-v4.4/noarch/include/drmprofile.h b/prebuilt-v4.4/noarch/include/drmprofile.h
new file mode 100644
index 0000000..ead2066
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmprofile.h
@@ -0,0 +1,218 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __DRMPROFILE_H__
+#define __DRMPROFILE_H__
+
+#include <drmprofileconstants.h>
+#include <drmprofiletypes.h>
+
+/* OEM function to retrieve global profile context. */
+#include <oemprofile.h>
+
+ENTER_PK_NAMESPACE;
+
+#if DRM_SUPPORT_PROFILING
+
+    extern DRM_DWORD Perf_String_Data( DRM_CONST_STRING * pdstrIn );
+
+    extern DRM_DWORD Perf_Binary_Data( DRM_BYTE * pbIn, DRM_DWORD dwSize );
+
+    extern DRM_RESULT Perf_Log_Profile( PERF_SCOPE_CONTEXT * pScopeContext, DRM_DWORD nScopeLevel );
+
+    extern DRM_RESULT Perf_Enter_Scope( PERF_SCOPE_CONTEXT * pScopeContext );
+
+    extern DRM_RESULT Perf_Leave_Scope( PERF_SCOPE_CONTEXT * pScopeContext );
+
+    extern DRM_RESULT Perf_Enter_Agg_Scope( PERF_AGG_SCOPE_CONTEXT ** ppAggScopeContext, DRM_DWORD dwScopeID );
+
+    extern DRM_RESULT Perf_Leave_Agg_Scope( PERF_AGG_SCOPE_CONTEXT * pAggScopeContext, DRM_DWORD dwDuration );
+
+    extern DRM_RESULT Perf_Start_Profiling( DRM_VOID *pOEMContext, DRM_CONST_STRING *dstrPerfFileName );
+
+    extern DRM_RESULT Perf_Stop_Profiling( DRM_VOID );
+
+    extern DRM_RESULT Perf_Init_ProfileStack( DRM_VOID );
+
+    /* Macro definitions. */
+
+    /* Returns the performance counter's currrent count in microseconds. */
+    static DRM_UINT64 PERF_MICROSECONDS_PER_SECOND = DRM_UI64LITERAL( 0,1000000 );
+    #define PERF_CURRENT_MICROSECOND_COUNT  \
+        ( DRM_UI64Low32( DRM_UI64Div( DRM_UI64Mul( Oem_Clock_QueryPerformanceCounter( NULL ), PERF_MICROSECONDS_PER_SECOND ), Oem_Clock_QueryPerformanceFrequency( NULL ) ) ) )
+
+    /* Macros used for normal scope sampling. */
+    #define PERF_SCOPE_DETAIL_LEVEL_X( DetailLevel)         ScopeContext.m_nDetailLevel = ( DetailLevel );
+
+    #define PERF_SCOPE_FEATURE_SET_X( FeatureSet)           ScopeContext.m_nFeatureSet = ( FeatureSet );
+
+    #define PERF_ENTER_SCOPE_X( ModuleID, FuncID, BlockID ) { \
+                                                            PERF_SCOPE_CONTEXT ScopeContext = { 0 }; \
+                                                            ScopeContext.m_dwScopeID = PERF_SCOPE_ID( ( ModuleID ), ( FuncID ), ( BlockID ) ); \
+                                                            ScopeContext.m_nDetailLevel = 1; \
+                                                            ScopeContext.m_nFeatureSet = 0; \
+                                                            ScopeContext.m_eTraceLevel = TRACE_FATAL; \
+                                                            Perf_Enter_Scope(&ScopeContext); \
+                                                            DRM_TRACE_ENTER_SCOPE( TRACE_DEFAULT_ROBUST, ScopeContext.m_dwScopeID );
+
+    #define PERF_LEAVE_SCOPE_X                              Perf_Leave_Scope( &ScopeContext );  \
+                                                            DRM_TRACE_LEAVE_SCOPE( TRACE_DEFAULT_ROBUST, ScopeContext.m_dwScopeID, dr ); \
+                                                            }
+
+    #define PERF_ENTER_SCOPE( ModuleID, FuncID )            PERF_ENTER_SCOPE_X( ModuleID, FuncID, 1 )
+
+    #define PERF_LEAVE_SCOPE                                PERF_LEAVE_SCOPE_X;
+
+    /* Macros used for aggregated scope sampling. */
+    #define PERF_AGG_SCOPE_DETAIL_LEVEL_X( DetailLevel )    pAggScopeContext->m_nDetailLevel = ( DetailLevel );
+
+    #define PERF_AGG_SCOPE_FEATURE_SET_X( FeatureSet )      pAggScopeContext->m_nFeatureSet = ( FeatureSet );
+
+    #define PERF_ENTER_AGG_SCOPE_X( ModuleID, FuncID, BlockID ) { \
+                                                            static PERF_AGG_SCOPE_CONTEXT * pAggScopeContext = NULL; \
+                                                            DRM_DWORD dwPerfAggEnterTick = PERF_CURRENT_MICROSECOND_COUNT; \
+                                                            Perf_Enter_Agg_Scope( &pAggScopeContext, PERF_SCOPE_ID( ( ModuleID ), ( FuncID ), ( BlockID ) ) );
+
+    #define PERF_LEAVE_AGG_SCOPE_X                          dwPerfAggEnterTick = PERF_CURRENT_MICROSECOND_COUNT - dwPerfAggEnterTick; \
+                                                            Perf_Leave_Agg_Scope( pAggScopeContext, dwPerfAggEnterTick ); \
+                                                            }
+
+    #define PERF_ENTER_AGG_SCOPE( ModuleID, FuncID )        PERF_ENTER_AGG_SCOPE_X( ModuleID, FuncID, 1 )
+
+    #define PERF_LEAVE_AGG_SCOPE                            PERF_LEAVE_AGG_SCOPE_X;
+
+    /* Below are macros that are used externally by the code to be profiled. */
+
+    /* Macros used for global context setup. */
+    #define DRM_PROFILING_GLOBAL_DETAIL_LEVEL( DetailLevel )    \
+                                                            Oem_Profiling_GetProfileContext()->m_nDetailLevel = ( DetailLevel );
+
+    #define DRM_PROFILING_GLOBAL_FEATURE_SET( FeatureSet )  Oem_Profiling_GetProfileContext()->m_nFeatureSet = ( FeatureSet );
+
+    #define DRM_PROFILING_STRING_HASH( pstrIn )             ( Perf_String_Data( ( DRM_CONST_STRING * )pstrIn ) )
+
+    #define DRM_PROFILING_BINARY_HASH( pbIn, dwSize )       ( Perf_Binary_Data( pbIn, dwSize ) )
+
+    #if PROFILE_USER_DATA
+
+        #define DRM_PROFILING_USER_DATA_1( UserData )       ScopeContext.m_dwUserData1 = ( UserData );
+
+        #define DRM_PROFILING_USER_DATA_2( UserData )       ScopeContext.m_dwUserData2 = ( UserData );
+
+    #else
+
+        #define DRM_PROFILING_USER_DATA_1( UserData )
+
+        #define DRM_PROFILING_USER_DATA_2( UserData )
+
+    #endif  /* PROFILE_USER_DATA */
+
+    /* Define generic macros used in the source code. */
+    #if PROFILE_USE_SCOPE
+
+        #define DRM_PROFILING_DETAIL_LEVEL( DetailLevel )   PERF_SCOPE_DETAIL_LEVEL_X( DetailLevel )
+
+        #define DRM_PROFILING_FEATURE_SET( FeatureSet )     PERF_SCOPE_FEATURE_SET_X( FeatureSet )
+
+        #define DRM_PROFILING_ENTER_SCOPE_X                 PERF_ENTER_SCOPE_X
+
+        #define DRM_PROFILING_LEAVE_SCOPE_X                 PERF_LEAVE_SCOPE_X
+
+        #define DRM_PROFILING_ENTER_SCOPE                   PERF_ENTER_SCOPE
+
+        #define DRM_PROFILING_LEAVE_SCOPE                   PERF_LEAVE_SCOPE
+
+    #endif  /* PROFILE_USE_SCOPE */
+
+    #if PROFILE_USE_AGG_SCOPE
+
+        #define DRM_PROFILING_DETAIL_LEVEL( DetailLevel )   PERF_AGG_SCOPE_DETAIL_LEVEL_X(DetailLevel)
+
+        #define DRM_PROFILING_FEATURE_SET( FeatureSet )     PERF_AGG_SCOPE_FEATURE_SET_X(FeatureSet)
+
+        #define DRM_PROFILING_ENTER_SCOPE_X                 PERF_ENTER_AGG_SCOPE_X
+
+        #define DRM_PROFILING_LEAVE_SCOPE_X                 PERF_LEAVE_AGG_SCOPE_X
+
+        #define DRM_PROFILING_ENTER_SCOPE                   PERF_ENTER_AGG_SCOPE
+
+        #define DRM_PROFILING_LEAVE_SCOPE                   PERF_LEAVE_AGG_SCOPE
+
+    #endif  /* PROFILE_USE_AGG_SCOPE */
+
+    #define DRM_Start_Profiling( x, y ) Perf_Start_Profiling( x, y )
+
+    #define DRM_Stop_Profiling()        Perf_Stop_Profiling()
+
+    #define DRM_Init_ProfileStack()     Perf_Init_ProfileStack()
+
+#else   /* DRM_SUPPORT_PROFILING */
+
+    #define DRM_PROFILING_USER_DATA_1( UserData )
+
+    #define DRM_PROFILING_USER_DATA_2( UserData )
+
+    #define DRM_PROFILING_DETAIL_LEVEL( DetailLevel )
+
+    #define DRM_PROFILING_FEATURE_SET( FeatureSet )
+
+    #define DRM_PROFILING_ENTER_SCOPE_X( ModuleID, FuncID, BlockID )
+
+    #define DRM_PROFILING_LEAVE_SCOPE_X()
+
+    #if DRM_SUPPORT_TRACING
+
+        typedef struct _trace_scope_context
+        {
+            /* Scope ID. */
+            DRM_DWORD m_dwScopeID;
+
+            /* Trace level of the current scope. */
+            eTraceLevel m_eTraceLevel;
+
+            /* Current component ID. */
+            DRM_DWORD m_dwComponent;
+
+        } TRACE_SCOPE_CONTEXT;
+
+        #define DRM_PROFILING_ENTER_SCOPE( ModuleID, FuncID )       { \
+                                                                    TRACE_SCOPE_CONTEXT ScopeContext = { 0 }; \
+                                                                    ScopeContext.m_dwScopeID = PERF_SCOPE_ID( ( ModuleID ), ( FuncID ), 1 ); \
+                                                                    ScopeContext.m_eTraceLevel = TRACE_FATAL; \
+                                                                    DRM_TRACE_ENTER_SCOPE( TRACE_DEFAULT_ROBUST, ScopeContext.m_dwScopeID );
+
+        #define DRM_PROFILING_LEAVE_SCOPE                           DRM_TRACE_LEAVE_SCOPE( TRACE_DEFAULT_ROBUST, ScopeContext.m_dwScopeID, dr ); }
+
+    #else
+
+        #define DRM_PROFILING_ENTER_SCOPE( ModuleID, FuncID )
+
+        #define DRM_PROFILING_LEAVE_SCOPE
+
+    #endif  /* DRM_SUPPORT_TRACING */
+
+    #define DRM_PROFILING_GLOBAL_DETAIL_LEVEL( DetailLevel )
+
+    #define DRM_PROFILING_GLOBAL_FEATURE_SET( FeatureSet )
+
+    #define DRM_PROFILING_STRING_HASH( pstrIn )
+
+    #define DRM_PROFILING_BINARY_HASH( pstrIn )
+
+    #define DRM_Start_Profiling( x, y ) DRM_SUCCESS
+
+    #define DRM_Stop_Profiling()        DRM_SUCCESS
+
+    #define DRM_Init_ProfileStack()     DRM_SUCCESS
+
+#endif /* DRM_SUPPORT_PROFILING */
+
+EXIT_PK_NAMESPACE;
+
+#endif    /* __DRMPROFILE_H__ */
+
diff --git a/prebuilt-v4.4/noarch/include/drmprofileconstants.h b/prebuilt-v4.4/noarch/include/drmprofileconstants.h
new file mode 100644
index 0000000..f39660d
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmprofileconstants.h
@@ -0,0 +1,602 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __DRMPROFILECONSTANTS_H__
+#define __DRMPROFILECONSTANTS_H__
+
+/* Note: Do not insert entries.  Always add at the end.  Missing entries were used in previous versions. */
+#define PERF_MOD_BLACKBOX                       1
+#define PERF_MOD_DRMCHAIN                       2
+#define PERF_MOD_DRMHDS                         3
+#define PERF_MOD_DRMHDSIMPL                     4
+#define PERF_MOD_DRMLICACQREQ                   5
+#define PERF_MOD_DRMLICACQRESP                  6
+#define PERF_MOD_DRMLICEVAL                     7
+#define PERF_MOD_DRMLICSTORE                    8
+#define PERF_MOD_DRMSECSTORE                    9
+#define PERF_MOD_DEVICEDEVCERT                  11
+#define PERF_MOD_DRM_APP                        12
+#define PERF_MOD_METERING                       13
+#define PERF_MOD_OEMFILEIO                      14
+#define PERF_MOD_DRMHDRPARSER                   18
+#define PERF_MOD_DRMUTILITIES                   23
+#define PERF_MOD_DRMXMLPARSER                   24
+#define PERF_MOD_DRMBASE64                      25
+#define PERF_MOD_OEMINFO                        26
+#define PERF_MOD_DRMCIPHER                      27
+#define PERF_MOD_DESKEY                         28
+#define PERF_MOD_RC4                            29
+#define PERF_MOD_DRMCBC                         30
+#define PERF_MOD_OEMAES                         32
+#define PERF_MOD_DRMAES                         33
+#define PERF_MOD_DRMSHA256                      35
+#define PERF_MOD_DRM_ECC_P256                   36
+#define PERF_MOD_BCERT                          37      /* Binary Certificates */
+#define PERF_MOD_DOMAINSTORE                    38      /* Domain store */
+#define PERF_MOD_DOMAINAPI                      39      /* Domain APIs */
+#define PERF_MOD_XMLSIG                         40      /* XML encryption/signature */
+#define PERF_MOD_SOAPXML                        41      /* SOAP/XML utility */
+#define PERF_MOD_LICACQV3                       42      /* V3 license acquisition */
+#define PERF_MOD_UTF8                           43      /* UTF-8 */
+#define PERF_MOD_DRMHMAC                        44
+#define PERF_MOD_REVOCATION                     48
+#define PERF_MOD_RSA                            49
+#define PERF_MOD_DRMPRO                         55      /* PlayReady Object APIs */
+#define PERF_MOD_DRMEMB                         56      /* License Embedding APIs */
+#define PERF_MOD_DRMXMLBUILDER                  57      /* Both UTF-16 and UTF-8 XML builders */
+#define PERF_MOD_NDCERT                         58      /* ND Certificates */
+#define PERF_MOD_BLOBCACHE                      59      /* BLOB Cache */
+#define PERF_MOD_ACTIVATION                     60
+
+/* blackbox\blackbox.c */
+#define PERF_FUNC_DRM_BBX_CipherKeySetup                    1
+#define PERF_FUNC_DRM_BBX_StoreDomainPrivateKeys            2
+#define PERF_FUNC_DRM_BBX_HashValue                         3
+#define PERF_FUNC_DRM_BBX_SymmetricVerify                   4
+#define PERF_FUNC_DRM_BBX_Initialize                        5
+#define PERF_FUNC_DRM_BBX_CanBind                           6
+#define PERF_FUNC__DecryptContentKeyXML                     7
+#define PERF_FUNC_VerifyChecksum                            8
+#define PERF_FUNC__GetDevicePrivkey                         9
+#define PERF_FUNC_DRM_BBX_RebindSLK                         10
+#define PERF_FUNC_DRM_BBX_DecryptLicense                    11
+#define PERF_FUNC_DRM_BBX_SymmetricCipher                   12
+#define PERF_FUNC_DRM_BBX_Legacy_SymmetricCipher            13
+
+/* core\drmblobcache.c */
+#define PERF_FUNC_DRM_BLOBCACHE_Verify          1
+#define PERF_FUNC_DRM_BLOBCACHE_Update          2
+
+/* core\drmchain.c */
+#define PERF_FUNC__PerformActions                   1
+#define PERF_FUNC__ProcessEndOfChain                2
+#define PERF_FUNC_DRM_LIC_CompleteLicenseChain      3
+#define PERF_FUNC_DRM_LIC_ReportActions             4
+#define PERF_FUNC_DRM_LIC_CheckClockRollback        5
+#define PERF_FUNC__GetLicenseInfoAndSetup           6
+#define PERF_FUNC__ValidateRevocationVersions       7
+
+/* core\drmhds.c */
+#define PERF_FUNC_DRM_HDS_OpenStore             1
+#define PERF_FUNC_DRM_HDS_CloseStore            2
+#define PERF_FUNC_DRM_HDS_OpenNamespace         3
+#define PERF_FUNC_DRM_HDS_OpenSlot              4
+#define PERF_FUNC_DRM_HDS_InitSlotEnum          5
+#define PERF_FUNC_DRM_HDS_SlotEnumNext          6
+
+/* core\drmhds.c */
+#define PERF_FUNC__HdsGetPutBlockHDR                    1
+#define PERF_FUNC__HdsGetPutBlockPayload                2
+#define PERF_FUNC__HdsSearchSlotInFile                  3
+#define PERF_FUNC__HdsHashToChildBlock                  4
+#define PERF_FUNC__HdsSearchSlotInBlock                 5
+#define PERF_FUNC__HdsCopyBlockBuffer                   6
+#define PERF_FUNC_DRM_HDSIMPL_AllocBlockBuffer          7
+#define PERF_FUNC__HdsHashKeyToIndex                    8
+#define PERF_FUNC__HdsLoadBlockHDR                      9
+#define PERF_FUNC__HdsLoadSRN                           10
+#define PERF_FUNC__HdsGenSRNHash                        11
+#define PERF_FUNC__WriteSRN                             12
+#define PERF_FUNC__ReadSRN                              13
+#define PERF_FUNC__WriteCommonBlockHeader               14
+#define PERF_FUNC__ReadCommonBlockHeader                15
+#define PERF_FUNC__WriteChildBlockHeader                16
+#define PERF_FUNC__ReadChildBlockHeader                 17
+#define PERF_FUNC__WriteDataBlockHeader                 18
+#define PERF_FUNC__ReadDataBlockHeader                  19
+#define PERF_FUNC__HdsGenBlockHash                      20
+#define PERF_FUNC__HdsGetPutChildBlockNum               21
+#define PERF_FUNC__HdsExpandStore                       22
+#define PERF_FUNC__HdsUpdateSRN                         23
+#define PERF_FUNC__HdsAllocBlock                        24
+#define PERF_FUNC__HdsFreeBlock                         25
+#define PERF_FUNC__HdsLocateFreeBlockForSlot            26
+#define PERF_FUNC__HdsCreateOversizedSlot               27
+#define PERF_FUNC__HdsOpenSlotFromHint                  28
+#define PERF_FUNC__HdsAllocSlotInFile                   29
+#define PERF_FUNC__HdsTraverseBlocksInPostOrder         30
+#define PERF_FUNC__HdsOpenSlot                          31
+#define PERF_FUNC__HdsVerifySlotContext                 32
+#define PERF_FUNC__HdsReadWriteSlot                     33
+#define PERF_FUNC__HdsAdjustChildPayload                34
+#define PERF_FUNC__HdsFindLeftmostLeafBlock             35
+#define PERF_FUNC__HdsCopySlot_Child2Child              36
+#define PERF_FUNC__HdsCopyChildPayload                  37
+#define PERF_FUNC__HdsDefragmentFile                    38
+#define PERF_FUNC__HdsDeleteSubTree                     39
+#define PERF_FUNC__HdsTraverseNextRightSiblingBlock     40
+
+/* core\drmliceval.c */
+#define PERF_FUNC_DRM_LEVL_PerformOperationsXMR                             6
+
+/* core\drmlicstore.c */
+#define PERF_FUNC__InitEnum                     1
+#define PERF_FUNC_DRM_LST_EnumNext              2
+#define PERF_FUNC_DRM_LST_Open                  3
+#define PERF_FUNC_DRM_LST_Close                 4
+#define PERF_FUNC_DRM_LST_GetLicense            5
+
+/* core\drmsecstore.c */
+#define PERF_FUNC_DRM_SST_OpenKeyTokens                   1
+#define PERF_FUNC_DRM_SST_CreateGlobalStorePassword       2
+#define PERF_FUNC_DRM_SST_CreateLicenseStatePassword      3
+#define PERF_FUNC_DRM_SST_CloseKey                        4
+#define PERF_FUNC_DRM_SST_GetData                         5
+#define PERF_FUNC_DRM_SST_SetData                         6
+#define PERF_FUNC_DRM_SST_GetTokenValue                   7
+#define PERF_FUNC_DRM_SST_SetExplicitResolutionTokenValue 8
+#define PERF_FUNC__VerifySlotHash                         9
+
+/* core\drmplayreadyobj.c */
+#define PERF_FUNC_DRM_PRO_Create                                   1
+#define PERF_FUNC_DRM_PRO_GetCipherTypeFromPlayReadyHeader         2
+#define PERF_FUNC_DRM_PRO_GetCipherType                            3
+#define PERF_FUNC_DRM_PRO_ConvertHeaderFromWmdrmToPlayReady        4
+#define PERF_FUNC_Drm_PlayReadyObject_ConvertFromWmdrmHeader       5
+#define PERF_FUNC_DRM_PRO_CreateRightsManagementHeader             6
+#define PERF_FUNC_DRM_PRO_GetRMHeaderChecksum                      7
+#define PERF_FUNC_DRM_PRO_GetDecryptorSetupTypeFromPlayReadyHeader 8
+#define PERF_FUNC_DRM_PRO_GetDecryptorSetupType                    9
+
+
+/* devcertparser\devcert.c */
+#define PERF_FUNC_DRM_DCP_GetAttribute          1
+#define PERF_FUNC_DRM_DCP_LoadPropertiesCache   2
+
+/* devicedevcert\devicedevcert.c */
+/* modules\symopt\real\symoptdevicedevcertreal.c */
+#define PERF_FUNC__CompareMachineId                             1
+#define PERF_FUNC_DRM_DDC_Certificates_Initialize               3
+
+/* drmmanager\drmmanager.c */
+/* modules\secure_clock\real\secureclockmanager.c */
+#define PERF_FUNC_Drm_Initialize                                1
+#define PERF_FUNC_Drm_Uninitialize                              2
+#define PERF_FUNC_Drm_LicenseAcq_GenerateChallenge              3
+#define PERF_FUNC_Drm_Device_GetProperty                        4
+#define PERF_FUNC_Drm_LicenseAcq_ProcessResponse                5
+#define PERF_FUNC_Drm_Reader_Bind                               6
+#define PERF_FUNC_Drm_Reader_Commit                             7
+#define PERF_FUNC_DRM_CLK_Drm_SecureClock_ProcessResponseImpl   10
+#define PERF_FUNC_DRM_CLK_Drm_SecureClock_GenerateChallengeImpl 11
+#define PERF_FUNC_DRM_CLK_Drm_SecureClock_GetValueImpl          12
+#define PERF_FUNC_Drm_StoreMgmt_CleanupStore                    13
+#define PERF_FUNC_DRM_CLK_CheckSecureClock                      15
+#define PERF_FUNC__SetupLicEvalObjectToShare                    16
+#define PERF_FUNC_Drm_Envelope_Open                             20
+#define PERF_FUNC_Drm_Envelope_InitializeRead                   21
+#define PERF_FUNC_Drm_Envelope_Close                            22
+#define PERF_FUNC_Drm_Envelope_GetSize                          23
+#define PERF_FUNC_Drm_Envelope_Read                             24
+#define PERF_FUNC_Drm_Envelope_Seek                             25
+#define PERF_FUNC_Drm_StoreMgmt_DeleteLicenses                  26
+#define PERF_FUNC_Drm_License_GetProperty                       27
+#define PERF_FUNC_Drm_Content_UpdateEmbeddedStore               28
+#define PERF_FUNC_Drm_Content_GetProperty                       29
+#define PERF_FUNC_Drm_Envelope_WritePlayReadyObject             30
+#define PERF_FUNC_Drm_Content_UpdateEmbeddedStore_Commit        31
+#define PERF_FUNC_Drm_Revocation_SetBuffer                      32
+#define PERF_FUNC_Drm_Activation_ProcessResponseGenerateChallenge 33
+
+/* modules\metering\real\drmmeterimpv1.c */
+/* modules\metering\real\drmmeterimp.c */
+/* modules\metering\real\drmmeterapi.c */
+#define PERF_FUNC_DRM_MTR_UpdateData                        1
+#define PERF_FUNC_DRM_MTR_ProcessMeterResponse              2
+#define PERF_FUNC__BuildMeterCertChallengeXML               3
+#define PERF_FUNC__ProcessMeterCertInResponse               4
+#define PERF_FUNC_DRM_MTR_GenerateMeterCertChallenge        5
+#define PERF_FUNC_DRM_MTR_ProcessMeterCertResponse          6
+#define PERF_FUNC_Drm_Metering_GenerateChallenge            7
+#define PERF_FUNC_Drm_Metering_ProcessResponse              8
+#define PERF_FUNC_Drm_MeterCert_Update                      9
+#define PERF_FUNC_Drm_MeterCert_InitEnum                    10
+#define PERF_FUNC_Drm_MeterCert_EnumNext                    11
+#define PERF_FUNC__DecryptCipherData                        12
+#define PERF_FUNC_Drm_MeterCert_GenerateChallenge           13
+#define PERF_FUNC_Drm_MeterCert_ProcessResponse             14
+#define PERF_FUNC_DRM_MTR_GenerateMeterDataChallenge        15
+#define PERF_FUNC_DRM_MTR_ProcessMeterDataResponse          16
+#define PERF_FUNC_DRM_MTR_ParseBinaryMeterCert              17
+#define PERF_FUNC__ProcessMeterDataResponse                 18
+#define PERF_FUNC__CalcMaximumChallengeCharCount            19
+#define PERF_FUNC__CalcFixedUnencryptedChallengeCharCount   20
+#define PERF_FUNC__CalcFixedEncryptedChallengeCharCount     21
+#define PERF_FUNC__CalcVariableChallengeCharCount           22
+#define PERF_FUNC__ProcessAllKIDs                           23
+#define PERF_FUNC__CalcKIDDataCharCount                     24
+#define PERF_FUNC__BuildKIDDataXML                          25
+#define PERF_FUNC__BuildMeterDataChallengeXML               26
+#define PERF_FUNC__BuildMeterDataChallengeDataXML           27
+#define PERF_FUNC__PrepareMeterChallengeContext             28
+#define PERF_FUNC_Drm_GetMeterCert_By_MID                   29
+
+/* modules\activation\real\drmactivationinternal.c */
+#define PERF_FUNC_DRM_ACT_GenerateChallengeInternal     1
+#define PERF_FUNC_DRM_ACT_ProcessWSDLResponseInternal   2
+
+/* oem\ansi\oemfileio.c */
+#define PERF_FUNC_Oem_File_SetFilePointer       1
+#define PERF_FUNC_Oem_File_Lock                 2
+#define PERF_FUNC_Oem_File_Unlock               3
+#define PERF_FUNC_Oem_File_Open                 4
+#define PERF_FUNC_Oem_File_Read                 5
+#define PERF_FUNC_Oem_File_Write                6
+#define PERF_FUNC_Oem_File_GetSize              7
+#define PERF_FUNC_Oem_File_FlushBuffers         8
+
+/* modules\secure_clock\real\secureclockrequest.c */
+#define PERF_FUNC_DRM_CLK_CreateChallenge       1
+
+/* secure_clock\secureclockresponse.c */
+#define PERF_FUNC_DRM_CLK_ProcessResponse       1
+
+/* core\drmutilities.c */
+/* core\drmutilitieslite.c */
+/* modules\certcache\real\certcachereal.c */
+#define PERF_FUNC__CheckCertificate                         1
+#define PERF_FUNC_DRM_CERTCACHE_VerifyCachedCertificate     2
+
+/* modules\xmlparser\common\drmxmlparserlite.c */
+#define PERF_FUNC__GetXMLSubNodeW               1
+#define PERF_FUNC_DRM_XML_GetSubNodeByPath      2
+#define PERF_FUNC_DRM_XML_GetNodeAttribute      3
+#define PERF_FUNC_DRM_XML_GetSubNodeA           4
+#define PERF_FUNC__GetXMLSubNodeA               5
+
+/* oem\ansi\oeminfo.c */
+/* oem\wince\oeminfo.c */
+#define PERF_FUNC_Oem_Device_GetModelInfo       1
+
+/* core\drmcipher.c */
+#define PERF_FUNC_DRM_CPHR_InitDecrypt          1
+#define PERF_FUNC_DRM_CPHR_Decrypt              2
+#define PERF_FUNC_DRM_CPHR_Encrypt              3
+#define PERF_FUNC_DRM_CPHR_Init                 4
+
+/* oem\common\aes\oemaes.c */
+#define PERF_FUNC_Oem_Aes_SetKey                1
+#define PERF_FUNC_Oem_Aes_EncryptOne            2
+#define PERF_FUNC_Oem_Aes_DecryptOne            3
+
+/* oem\common\AES\oemaesmulti.c */
+#define PERF_FUNC_Oem_Aes_CtrProcessData        1
+#define PERF_FUNC_Oem_Aes_EcbEncryptData        2
+#define PERF_FUNC_Oem_Aes_EcbDecryptData        3
+#define PERF_FUNC_Omac1_GenerateSignTag         4
+#define PERF_FUNC_Omac1_GenerateSignInfo        5
+#define PERF_FUNC_Oem_Omac1_Sign                6
+#define PERF_FUNC_Oem_Omac1_Verify              7
+#define PERF_FUNC_Oem_Aes_CbcEncryptData        8
+#define PERF_FUNC_Oem_Aes_CbcDecryptData        9
+
+/* certs\drmbcertbuilder.c */
+/* certs\drmbcertparser.c */
+#define PERF_FUNC_calcManufacturerInfoSize                      1
+#define PERF_FUNC_calcKeyInfoSize                               2
+#define PERF_FUNC_calcFeatureInfoSize                           3
+#define PERF_FUNC_calcSignatureInfoSize                         4
+#define PERF_FUNC_calcDomainInfoSize                            5
+#define PERF_FUNC_calcCertSize                                  6
+#define PERF_FUNC_checkBuffer                                   7
+#define PERF_FUNC_addAlignedData                                8
+#define PERF_FUNC_updateCertChainHeader                         9
+#define PERF_FUNC_addCertChainHeader                            10
+#define PERF_FUNC_addCertHeader                                 11
+#define PERF_FUNC_addCertObjectHeader                           12
+#define PERF_FUNC_addCertBasicInfo                              13
+#define PERF_FUNC_addCertFeatureInfo                            14
+#define PERF_FUNC_addCertKeyInfo                                15
+#define PERF_FUNC_addCertManufacturerString                     16
+#define PERF_FUNC_addCertManufacturerInfo                       17
+#define PERF_FUNC_addCertSignatureInfo                          18
+#define PERF_FUNC_addCertDomainInfo                             19
+#define PERF_FUNC_addCertPCInfo                                 20
+#define PERF_FUNC_addCertDeviceInfo                             21
+#define PERF_FUNC_BCert_AddCert                                 22
+#define PERF_FUNC_DRM_BCert_GetSecurityVersion                  23
+#define PERF_FUNC_addCertSecurityVersion                        24
+#define PERF_FUNC_verifyAdjacentCerts                           25
+#define PERF_FUNC_getObjectHeader                               26
+#define PERF_FUNC_parseCertHeader                               27
+#define PERF_FUNC_parseCertBasicInfo                            28
+#define PERF_FUNC_parseDomainInfo                               29
+#define PERF_FUNC_parsePCInfo                                   30
+#define PERF_FUNC_parseDeviceInfo                               31
+#define PERF_FUNC_parseFeatureInfo                              32
+#define PERF_FUNC_parseManufacturerString                       33
+#define PERF_FUNC_parseSignatureInfo                            34
+#define PERF_FUNC_parseKeyInfo                                  35
+#define PERF_FUNC_parseCertificate                              36
+#define PERF_FUNC_DRM_BCert_FindObjectInCertByType              37
+#define PERF_FUNC_DRM_BCert_GetChainHeader                      38
+#define PERF_FUNC_DRM_BCert_ParseCertificateChain               39
+#define PERF_FUNC_DRM_BCert_GetCertificate                      40
+#define PERF_FUNC_DRM_BCert_GetPublicKey                        41
+#define PERF_FUNC_addCertSilverLightInfo                        42
+#define PERF_FUNC_parseSilverLightInfo                          43
+#define PERF_FUNC_DRM_BCert_VerifySignature                     44
+#define PERF_FUNC_calcExtDataSignKeyInfoSize                    45
+#define PERF_FUNC_calcExtDataContainerSize                      46
+#define PERF_FUNC_addExtDataSignKeyInfo                         47
+#define PERF_FUNC_addExtDataContainer                           48
+#define PERF_FUNC_BCert_AddExtendedDataToCert                   49
+#define PERF_FUNC_verifyExtDataSignature                        50
+#define PERF_FUNC_parseExtDataSignKeyInfo                       51
+#define PERF_FUNC_parseExtDataContainer                         52
+#define PERF_FUNC_addCertMeteringInfo                           53
+#define PERF_FUNC_calcMeteringInfoSize                          54
+#define PERF_FUNC_parseSecurityVersion                          55
+#define PERF_FUNC_DRM_BCert_GetPublicKeyByUsage                 56
+#define PERF_FUNC_parseServerInfo                               57
+#define PERF_FUNC_addCertServerInfo                             58
+#define PERF_FUNC_DRM_BCert_GetManufacturerStrings              59
+#define PERF_FUNC_BCert_AddCert_BBX                             60
+
+/* domainstore\drmdomainstore.c */
+#define PERF_FUNC__DomainStore_AddData          1
+#define PERF_FUNC__DomainStore_GetData          2
+#define PERF_FUNC__DomainStore_DeleteData       3
+#define PERF_FUNC__DomainStore_InitEnumData     4
+#define PERF_FUNC__DomainStore_EnumNextData     5
+#define PERF_FUNC_DRM_DOMST_OpenStore           6
+#define PERF_FUNC_DRM_DOMST_CloseStore          7
+#define PERF_FUNC_DRM_DOMST_DeleteKeys          8
+
+/* domain\drmdomainimp.c */
+/* domain\drmdomainkeyxmrparser.c */
+#define PERF_FUNC__BuildJoinChallengeDataXML                1
+#define PERF_FUNC__BuildLeaveChallengeDataXML               2
+#define PERF_FUNC__BuildJoinChallengeXML                    3
+#define PERF_FUNC__BuildLeaveChallengeXML                   4
+#define PERF_FUNC_DRM_DOMKEYXMR_GetHeader                   5
+#define PERF_FUNC_DRM_DOMKEYXMR_GetSessionKey               6
+#define PERF_FUNC_DRM_DOMKEYXMR_GetPrivKeyContainer         7
+#define PERF_FUNC_DRM_DOMKEYXMR_GetPrivKey                  8
+#define PERF_FUNC__ProcessJoinDataFromResponse              9
+#define PERF_FUNC__ParseLeaveDomainChallengeQueryData       10
+#define PERF_FUNC_DRM_DOM_GenerateJoinChallenge             11
+#define PERF_FUNC_DRM_DOM_ProcessJoinResponse               12
+#define PERF_FUNC_DRM_DOM_GenerateLeaveChallenge            13
+#define PERF_FUNC_DRM_DOM_ProcessLeaveResponse              14
+#define PERF_FUNC_DRM_DOM_FindCert                          15
+#define PERF_FUNC_DRM_DOM_InitCertEnum                      16
+#define PERF_FUNC_DRM_DOM_EnumNextCert                      17
+#define PERF_FUNC__ParseJoinDomainChallengeQueryData        18
+
+/* core\drmxmlsig.c */
+#define PERF_FUNC__CalcSHA256Hash                               1
+#define PERF_FUNC__VerifySHA256Hash                             2
+#define PERF_FUNC__BuildCipherDataNode                          3
+#define PERF_FUNC_DRM_XMLSIG_ExtractCipherData                  4
+#define PERF_FUNC__BuildSignedInfoNode                          5
+#define PERF_FUNC__BuildSignatureValueNode                      6
+#define PERF_FUNC__BuildPublicKeyInfoNodeWithName               7
+#define PERF_FUNC__ExtractPublicKeyByName                       8
+#define PERF_FUNC__BuildECC256PublicKeyInfoNode                 9
+#define PERF_FUNC__ExtractECC256PublicKey                       10
+#define PERF_FUNC_DRM_XMLSIG_BuildEncryptedKeyInfoNode          11
+#define PERF_FUNC_DRM_XMLSIG_BuildEncryptedDataNode             12
+#define PERF_FUNC_DRM_XMLSIG_BuildSignatureNode                 13
+#define PERF_FUNC_DRM_XMLSIG_VerifySignature                    14
+
+/* core\drmsoapxmlutility.c */
+#define PERF_FUNC_DRM_SOAPXML_EncodeData                  1
+#define PERF_FUNC_DRM_SOAPXML_DecodeData                  2
+#define PERF_FUNC_DRM_SOAPXML_GetDeviceCert               3
+#define PERF_FUNC_DRM_SOAPXML_InitXMLKey                  4
+#define PERF_FUNC_DRM_SOAPXML_EncryptDataWithXMLKey       5
+#define PERF_FUNC_DRM_SOAPXML_BuildSOAPHeaderXML          6
+#define PERF_FUNC__ParseCustomData                        7
+#define PERF_FUNC__ParseCustomDataByPath                  8
+#define PERF_FUNC_DRM_SOAPXML_ParseStatusCode             9
+#define PERF_FUNC_Drm_GetAdditionalResponseData           10
+#define PERF_FUNC_DRM_SOAPXML_GetAdditionalResponseData   11
+#define PERF_FUNC_DRM_SOAPXML_ParseCustomDataForProtocol  12
+#define PERF_FUNC_DRM_SOAPXML_ValidateProtocolSignature   13
+#define PERF_FUNC_DRM_SOAPXML_BuildClientInfo             14
+#define PERF_FUNC__GetAdditionalResponseExceptionData     15
+#define PERF_FUNC__GetAdditionalResponseDomainIDData      16
+
+/* core\drmlicacqv3.c */
+/* drmmanager\drmmanager.c */
+#define PERF_FUNC__CalcDeviceCertCharCount                1
+#define PERF_FUNC__CalcDomainCertsCharCount               2
+#define PERF_FUNC__BuildDomainCertsXML                    3
+#define PERF_FUNC__BuildCertChainsXML                     4
+#define PERF_FUNC__BuildRevListInfoXML                    5
+#define PERF_FUNC__BuildLicenseChallengeDataXML           6
+#define PERF_FUNC__BuildLicenseAcknowledgementDataXML     7
+#define PERF_FUNC__BuildLicenseChallengeXML               8
+#define PERF_FUNC__BuildLicenseAcknowledgementXML         9
+#define PERF_FUNC__GetLicenseState                        11
+#define PERF_FUNC__PrepareUplinks                         12
+#define PERF_FUNC__PrepareLicenseChallenge                13
+#define PERF_FUNC_DRM_LA_ParseLicenseAcquisitionURL       14
+#define PERF_FUNC_DRM_LA_ProcessLicenseV3                 15
+#define PERF_FUNC__ExtractLicensesFromLicenseResponse     16
+#define PERF_FUNC_DRM_LA_ProcessRevocationPackage         17
+#define PERF_FUNC__ExtractDataFromLicenseResponse         18
+#define PERF_FUNC__GenerateLicenseChallengeV3             19
+#define PERF_FUNC__ProcessLicenseResponseV3               20
+#define PERF_FUNC_Drm_LicenseAcq_GenerateAck              21
+#define PERF_FUNC_Drm_LicenseAcq_ProcessAckResponse       22
+
+/* core\drmutf.c */
+#define PERF_FUNC_DRM_UTF8_VerifyBytes          1
+
+/* core\drmhmac.c */
+#define PERF_FUNC_DRM_HMAC_CreateMAC            1
+#define PERF_FUNC_DRM_HMAC_VerifyMAC            2
+
+/* oem\common\ecc\base\oemeccp256.c */
+/* oem\common\ecc\baseimpl\oemeccp256impl.c */
+#define PERF_FUNC_OEM_ECDSA_Verify_P256                             1
+#define PERF_FUNC_OEM_ECDSA_Sign_P256                               2
+#define PERF_FUNC_OEM_ECC_GenKeyPair_P256                           3
+#define PERF_FUNC_OEM_ECC_Encrypt_P256                              4
+#define PERF_FUNC_OEM_ECC_Decrypt_P256                              5
+#define PERF_FUNC_OEM_ECC_CanMapToPoint_P256                        6
+#define PERF_FUNC_OEM_ECC_GenerateHMACKey_P256                      7
+#define PERF_FUNC_Convert_P256_PointToPlaintext                     8
+#define PERF_FUNC_OEM_ECC_GenKeyPairRestrictedPriv_P256             9
+#define PERF_FUNC_Convert_P256_PointToBigEndianBytes                10
+#define PERF_FUNC_Convert_P256_PlaintextToPoint                     11
+#define PERF_FUNC_Convert_P256_ModularIntToDigitsModOrder           12
+#define PERF_FUNC_Convert_P256_ModularIntToBigEndianBytesModOrder   13
+#define PERF_FUNC_Convert_P256_DigitsToBigEndianBytes               14
+#define PERF_FUNC_DRM_ECC_MapX2PointP256                            15
+#define PERF_FUNC_Convert_P256_BigEndianBytesToPoint                16
+#define PERF_FUNC_Convert_P256_BigEndianBytesToModular              17
+#define PERF_FUNC_Convert_P256_BigEndianBytesToDigitsModOrder       18
+#define PERF_FUNC_Convert_DigitsToBigEndianBytes                    19
+#define PERF_FUNC_Convert_P256_BigEndianBytesToDigits               20
+#define PERF_FUNC_Convert_BigEndianBytesToDigits                    21
+
+/* crypto\drmsha256\drmsha256.c */
+#define PERF_FUNC_OEM_SHA256_Init               1
+#define PERF_FUNC_OEM_SHA256_UpdateOffset       2
+#define PERF_FUNC_OEM_SHA256_Finalize           3
+#define PERF_FUNC_SHA256_Transform              4
+
+/* Revocation */
+/* core\drmrevocation.c */
+/* modules\devicerevocation\real\devicerevocationimplreal.c */
+/* modules\legacyxmlcert\real\drmlegacyxmlcertrevocationreal.c */
+/* core\drmrevocationstore.c */
+/* core\drmbcrlparser.c*/
+#define PERF_FUNC__CheckCertInRevocationList                        3
+#define PERF_FUNC_DRM_RVK_UpdateRevocationVersionsCache             7
+#define PERF_FUNC_DRM_RVK_VerifyRevocationList                      8
+#define PERF_FUNC_DRM_RVK_UpdateRevocationList                      9
+#define PERF_FUNC_DRM_RVK_GetLegacyXMLCertList                      10
+#define PERF_FUNC_DRM_RVK_GetSSTRevocationList                      11
+#define PERF_FUNC_DRM_RVK_VerifyLegacyXMLCertRevocationList         12
+#define PERF_FUNC_DRM_RVK_UpdateLegacyXMLCertRevocationList         13
+#define PERF_FUNC_DRM_RVK_UpdateLegacyXMLCertRevocationListDecoded  14
+#define PERF_FUNC_DRM_RVK_VerifyLegacyXMLCertCRLSignature           15
+#define PERF_FUNC_DRM_RVK_GetLegacyXMLCertRevocationEntries         16
+#define PERF_FUNC_DRM_RVK_VerifyBinaryLegacyXMLCertSignature        17
+#define PERF_FUNC_DRM_RVK_VerifyRevocationInfo                      18
+#define PERF_FUNC_DRM_RVK_GetCurrentRevocationInfo                  19
+#define PERF_FUNC_DRM_RVK_StoreRevocationLists                      20
+#define PERF_FUNC_DRM_RVK_StoreRevInfo                              21
+#define PERF_FUNC__ExtractRevocationList                            23
+#define PERF_FUNC_DRM_RVK_GetCRL                                    24
+#define PERF_FUNC_DRM_RVK_SetCRL                                    25
+#define PERF_FUNC_DRM_RVS_InitRevocationStore                       26
+#define PERF_FUNC_DRM_RVS_StoreRevocationData                       27
+#define PERF_FUNC__CreateRevocationStorePassword                    28
+#define PERF_FUNC__LoopkupRevocationLIDFromGUID                     29
+#define PERF_FUNC_DRM_RVS_GetRevocationData                         30
+#define PERF_FUNC_DRM_BCrl_VerifySignature                          31
+#define PERF_FUNC_DRM_RVK_GetDeviceRevocationList                   33
+#define PERF_FUNC__UpdateRevocationList                             34
+/* RSA */
+/* oem\common\RSA\oaeppssimpl\oemrsaoaeppssimpl.c */
+/* oem\common\RSA\base\oemrsa.c */
+#define PERF_FUNC__OAEPDecode                                       1
+#define PERF_FUNC__GenerateMGF1Mask                                 2
+#define PERF_FUNC__OAEPEncode                                       3
+#define PERF_FUNC__PSSEncode                                        4
+#define PERF_FUNC__PSSVerify                                        5
+#define PERF_FUNC__BigEndianBytesToDigits                           6
+#define PERF_FUNC__DigitsToBigEndianBytes                           7
+#define PERF_FUNC_OEM_RSA_SetPublicKey_2048BIT                      8
+#define PERF_FUNC_OEM_RSA_SetPrivateKey_2048BIT                     9
+#define PERF_FUNC_OEM_RSA_ParsePublicKey_2048BIT                    10
+#define PERF_FUNC_OEM_RSA_ZeroPublicKey_2048BIT                     11
+#define PERF_FUNC_OEM_RSA_ZeroPrivateKey_2048BIT                    12
+#define PERF_FUNC__ModularExponentiate                              13
+#define PERF_FUNC_OEM_RSA_Decrypt_2048BIT                           14
+#define PERF_FUNC_OEM_RSA_OaepDecrypt_2048BIT                       15
+#define PERF_FUNC_OEM_RSA_OaepEncrypt_2048BIT                       16
+#define PERF_FUNC_OEM_RSA_OaepEncrypt_4096BIT                       17
+#define PERF_FUNC_OEM_RSA_PssSign_2048BIT                           18
+#define PERF_FUNC_OEM_RSA_PssVerify_2048BIT                         19
+#define PERF_FUNC_OEM_RSA_PssVerify_4096BIT                         20
+#define PERF_FUNC_OEM_RSA_PssSign_4096BIT                           21
+#define PERF_FUNC_OEM_RSA_OaepDecrypt_4096BIT                       22
+
+
+
+/* modules\legacyxmlcert\real\drmlegacyxmlcertrsakeysreal.c */
+#define PERF_FUNC_DRM_XML_RSA_WritePublicKeyNodeA                  12
+#define PERF_FUNC_DRM_XML_RSA_WritePublicKeyNode                   13
+#define PERF_FUNC_DRM_XML_RSA_ParseBase64PublicKey                 15
+#define PERF_FUNC_DRM_XML_RSA_ParseBase64PublicKeyA                16
+#define PERF_FUNC_DRM_XML_RSA_WritePrivateKeyNode                  17
+#define PERF_FUNC_DRM_XML_RSA_ParseBase64PrivateKey                18
+
+/* core\drmembedding.c */
+#define PERF_FUNC_DRM_EMB_UpdateEmbeddedStore                       1
+
+/* DRM XML builder, UTF-8 and UTF-16 */
+/* modules\xmlbuilder\common\drmxmlbuilderalite.c */
+/* modules\xmlbuilder\common\drmxmlbuilderulite.c */
+/* modules\xmlbuilder\real\drmxmlbuilder.c */
+#define PERF_FUNC_DRM_XMB_CreateDocumentA                   1
+#define PERF_FUNC_DRM_XMB_CloseDocumentA                    2
+#define PERF_FUNC_DRM_XMB_OpenNodeA                         3
+#define PERF_FUNC_DRM_XMB_CloseCurrNodeA                    4
+#define PERF_FUNC_DRM_XMB_AddAttributeA                     5
+#define PERF_FUNC_DRM_XMB_AddDataA                          6
+#define PERF_FUNC_DRM_XMB_WriteTagA                         7
+#define PERF_FUNC_DRM_XMB_AddCDataA                         8
+#define PERF_FUNC_DRM_XMB_WriteCDATATagA                    9
+#define PERF_FUNC_DRM_XMB_ReserveSpaceA                     10
+#define PERF_FUNC_DRM_XMB_ShiftDataFromCurrentPositionA     11
+#define PERF_FUNC_DRM_XMB_ShiftCurrentPointerA              12
+#define PERF_FUNC_DRM_XMB_GetCurrentBufferPointerA          13
+#define PERF_FUNC_DRM_XMB_AppendNodeA                       14
+#define PERF_FUNC_DRM_XMB_AESEncryptAndCloseCurrNodeA       15
+#define PERF_FUNC_DRM_XMB_RSASignAndCloseCurrNodeA          16
+#define PERF_FUNC_DRM_XMB_HashAndRSASignAndCloseCurrNodeA   17
+#define PERF_FUNC_DRM_XMB_HashAndCloseCurrNodeA             18
+
+/* Start wide-char function with some gap in values */
+#define PERF_FUNC_DRM_XMB_CreateDocument                    22
+#define PERF_FUNC_DRM_XMB_ReallocDocument                   23
+#define PERF_FUNC_DRM_XMB_CloseDocument                     24
+#define PERF_FUNC_DRM_XMB_OpenNode                          25
+#define PERF_FUNC_DRM_XMB_CloseCurrNode                     26
+#define PERF_FUNC_DRM_XMB_GetCurrNodeName                   27
+#define PERF_FUNC_DRM_XMB_AddAttribute                      28
+#define PERF_FUNC_DRM_XMB_AddData                           29
+#define PERF_FUNC_DRM_XMB_ReserveSpace                      30
+#define PERF_FUNC_DRM_XMB_AddCData                          31
+#define PERF_FUNC_DRM_XMB_AppendNode                        32
+#define PERF_FUNC_DRM_XMB_AddXMLNode                        33
+#define PERF_FUNC_DRM_XMB_WriteTag                          34
+#define PERF_FUNC_DRM_XMB_WriteCDATATag                     35
+#define PERF_FUNC_DRM_XMB_EncryptAndCloseCurrNode           36
+#define PERF_FUNC_DRM_XMB_SignAndCloseCurrNode              37
+#define PERF_FUNC_DRM_XMB_KeyedHashAndCloseCurrNode         38
+
+#endif   /* #ifndef __DRMPROFILECONSTANTS_H__ */
+
diff --git a/prebuilt-v4.4/noarch/include/drmprofiletypes.h b/prebuilt-v4.4/noarch/include/drmprofiletypes.h
new file mode 100644
index 0000000..dea8ce6
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmprofiletypes.h
@@ -0,0 +1,202 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __DRMPROFILETYPES_H__
+#define __DRMPROFILETYPES_H__
+
+#include <drmtypes.h>
+#include <drmtrace.h>
+#include <oemcommon.h>
+
+ENTER_PK_NAMESPACE;
+
+/* Maxmimum size of cached sample buffer in bytes, should be a multiple of 16 bytes. */
+#define MAX_PROFILE_BUFFER_SIZE     92160
+
+/*
+** Scope ID is made up of three components: Module ID (12 bits), Function ID (12 bits) and Block ID (7 bits)
+** This Macro has been moved out from conditional compilation so that perftool can access it without turning
+** ON profiling.
+*/
+#define PERF_SCOPE_ID( ModuleID, FuncID, BlockID )  ( ( ( ( ModuleID ) & 0x0fff ) << 19 ) + ( ( ( FuncID ) & 0x0fff ) << 7 ) + ( ( BlockID ) & 0x007f ) )
+
+#if DRM_SUPPORT_PROFILING
+
+    /* Flag to indicate whether to enable user data logging. */
+    /* User data logging is not supported under aggregated scope sampling. */
+    #define PROFILE_USER_DATA       0
+
+    /* PROFILE_USE_SCOPE is defined to use normal scope sampling mechanism. */
+    #define PROFILE_USE_SCOPE       1
+
+    /* PROFILE_USE_AGG_SCOPE is defined to use aggregated scope sampling mechanism. */
+    #define PROFILE_USE_AGG_SCOPE   0
+
+    /* PROFILE_STACK_SIZE should be turned on to get the max. stack utilization by DRM APIs. */
+    #define PROFILE_STACK_SIZE      0
+
+    /* Note: One and only one of the above two definitions can be 1. */
+    #if ( PROFILE_USE_SCOPE && PROFILE_USE_AGG_SCOPE ) || ( !PROFILE_USE_SCOPE && !PROFILE_USE_AGG_SCOPE )
+        #error One and only one of PROFILE_USE_SCOPE and PROFILE_USE_AGG_SCOPE can be 1.
+    #endif
+
+    #if ( PROFILE_USER_DATA && !PROFILE_USE_SCOPE )
+        #error User data logging is supported only under normal scope sampling.
+    #endif
+
+    #if ( PROFILE_USER_DATA && PROFILE_USE_AGG_SCOPE )
+        #error User data logging is not supported under aggregated scope sampling.
+    #endif
+
+    /* Maximum levels of nested scope calls. */
+    #define MAX_PROFILE_SCOPE_LEVEL     512
+
+    /* Maximum number of aggregated scopes. */
+    #define MAX_PROFILE_AGG_SCOPES      1024
+
+    /*
+    ** PERF_AGG_SCOPE_CONTEXT is used to store aggregated information of a scope.
+    ** All PERF_AGG_SCOPE_CONTEXT structures are stored in global memory and
+    ** are persisted at the end of profiling.
+    */
+    typedef struct _perf_scope_agg_context
+    {
+        /* Define detail level of logging for this scope. 0: do not check detail level. */
+        DRM_DWORD m_nDetailLevel;
+
+        /* Define feature set this scope belongs to. 0: do not check feature set. */
+        DRM_DWORD m_nFeatureSet;
+
+        /* Scope ID. */
+        DRM_DWORD m_dwScopeID;
+
+        /* Aggregated duration of the scope. */
+        DRM_DWORD m_dwDuration;
+
+        /* Total call count of the scope. */
+        DRM_DWORD m_dwCallCount;
+
+    } PERF_AGG_SCOPE_CONTEXT;
+
+    /* PERF_GLOBAL_CONTEXT is the global context of the profiling machanism. */
+    typedef struct _perf_global_context
+    {
+        /* Scope stack. */
+        DRM_DWORD m_dwScopeID[ MAX_PROFILE_SCOPE_LEVEL ];
+
+        /* Point to top of the scope stack. */
+        DRM_DWORD m_nCurrScope;
+
+        /* Logging scopes with detail level < this value.  */
+        DRM_DWORD m_nDetailLevel;
+
+        /* Logging scopes within a specific group of feature sets. */
+        DRM_DWORD m_nFeatureSet;
+
+        /* Next PER_AGG_SCOPE_CONTEXT slot number to be assigned. */
+        DRM_DWORD m_nCurrAggScope;
+
+        /* File handle for normal scope samples. */
+        OEM_FILEHDL m_fp;
+
+        /* File handle for aggregated scope samples. */
+        OEM_FILEHDL m_fpAgg;
+
+        /* Buffer to cache normal scope samples to minimize I/O. */
+        DRM_BYTE m_bBuffer[ MAX_PROFILE_BUFFER_SIZE ];
+
+        /* Next m_bBuffer slot to be assigned. */
+        DRM_DWORD m_dwBufferIndex;
+
+        /* Global aggregated scope context. */
+        PERF_AGG_SCOPE_CONTEXT m_AggScopes[ MAX_PROFILE_AGG_SCOPES ];
+
+        /* Flag indicating whether the profiling machanism is enable or not. */
+        DRM_BOOL m_bRunning;
+
+        /* Flag to prevent recursive profiling. */
+        DRM_BOOL m_bInProfile;
+
+        /* Time spent in writing profiling logs to the disk. */
+        DRM_DWORD m_dwLogWriteDuration;
+
+        #if PROFILE_USER_DATA
+            /* File handle for user data logging. */
+            OEM_FILEHDL * m_fpUserData;
+
+            /* Buffer to cache user data to minimize I/O. */
+            DRM_BYTE m_bBufferUserData[ MAX_PROFILE_BUFFER_SIZE ];
+
+            /* Next m_bBufferUserData slot to be assigned. */
+            DRM_DWORD m_dwBufferUserDataIndex;
+        #endif
+
+        #if PROFILE_STACK_SIZE
+            /* File handle for logging stack size data. */
+            OEM_FILEHDL  m_fpStackSize;
+
+            /* Max stack usage deteted so far for current PK API (scopelevel = 2). */
+            DRM_DWORD m_dwMaxStackSize;
+
+            /* Stack base - relative to this stack size will be calculated. */
+            DRM_SIZE_T m_dwStackBase;
+
+            /* Scope ID of the PK API leading to max stack usage. */
+            DRM_DWORD m_dwMaxStackSizeScopeID;
+
+            /* Max stack usage over all the PK APIs involved in a specific scenario. */
+            DRM_DWORD m_dwMaxStackSizeinScenario;
+        #endif
+
+    } PERF_GLOBAL_CONTEXT;
+
+    typedef struct _perf_scope_context
+    {
+        /* Define detail level of logging for this scope. 0: do not check detail level. */
+        DRM_DWORD m_nDetailLevel;
+
+        /* Define feature set this scope belongs to. 0: do not check feature set. */
+        DRM_DWORD m_nFeatureSet;
+
+        /* Scope ID. */
+        DRM_DWORD m_dwScopeID;
+
+        /* Parent scope ID. */
+        DRM_DWORD m_dwParentScopeID;
+
+        /* Duration of the scope. */
+        DRM_DWORD m_dwDuration;
+
+        #if PROFILE_USER_DATA
+            /* Custom user data per context. */
+            DRM_DWORD m_dwUserData1;
+
+            DRM_DWORD m_dwUserData2;
+
+            /* More user data can be defined afterwards. */
+        #endif
+
+        /*
+        ** Trace level of the current scope.
+        ** If both profiling and tracing are enabled, the
+        ** scope level tracing control will stay in the
+        ** perf scope context.
+        **/
+        eTraceLevel m_eTraceLevel;
+
+        /* Current component ID. */
+        DRM_DWORD m_dwComponent;
+
+    } PERF_SCOPE_CONTEXT;
+
+#endif /* DRM_SUPPORT_PROFILING */
+
+EXIT_PK_NAMESPACE;
+
+#endif    /* __DRMPROFILETYPES_H__ */
+
diff --git a/prebuilt-v4.4/noarch/include/drmprovisioningformat_generated.h b/prebuilt-v4.4/noarch/include/drmprovisioningformat_generated.h
new file mode 100644
index 0000000..25f12d5
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmprovisioningformat_generated.h
@@ -0,0 +1,146 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+/* This source was autogenerated by xbgen.
+** DO NOT EDIT THIS SOURCE MANUALLY.
+** If changes need to be applied update the XML and regenerate this source.
+*/
+/*
+** This file defines the following generated formats
+** DRM_PROVISIONING_RESPONSE_MESSAGE
+** DRM_PROVISIONING_REQUEST_MESSAGE
+*/
+#ifndef __PROVISIONINGFORMATS_H__
+#define __PROVISIONINGFORMATS_H__ 1
+
+ENTER_PK_NAMESPACE;
+
+PREFAST_PUSH_DISABLE_EXPLAINED( __WARNING_POOR_DATA_ALIGNMENT_25021, "Ignore poor alignment of XBinary data structures" );
+
+#define DRM_PROVISIONING_CURRENT_VERSION 1
+#define DRM_PROVISIONING_HWID_LENGTH 16
+#define DRM_TEE_RPROV_STACK_SIZE 1024
+
+typedef enum __tagDRM_PROVISIONING_RESPONSE_MESSAGE_TYPES 
+{
+    DRM_PROVISIONING_CERT_ENTRY_TYPE                = 0x1,
+    DRM_PROVISIONING_RESPONSE_SIGNATURE_ENTRY_TYPE  = 0x3,
+    DRM_PROVISIONING_RESPONSE_DATA_ENTRY_TYPE       = 0x4,
+} DRM_PROVISIONING_RESPONSE_MESSAGE_TYPES;
+/* Count Includes XB_OBJECT_GLOBAL_HEADER */
+#define DRM_PROVISIONING_RESPONSE_MESSAGE_TYPE_COUNT       4
+#define DRM_PROVISIONING_RESPONSE_MESSAGE_FORMAT_ID        XB_DEFINE_QWORD_FORMAT_ID( 'P', 'K', 'P', 'R', 'V', 'R', 'S', 'P' )
+
+typedef struct __tagDRM_PROVISIONING_CERT
+{
+    DRM_BOOL             fValid;
+    DRM_XB_BYTEARRAY     xbbaCert;
+} DRM_PROVISIONING_CERT;
+
+typedef struct __tagDRM_PROVISIONING_RESPONSE_DATA
+{
+    DRM_BOOL             fValid;
+    DRM_DWORD            dwSecurityLevel;
+    DRM_XB_BYTEARRAY     xbbaNonce;
+    DRM_UINT64           qwClientTimestamp;
+    DRM_UINT64           qwTimestamp;
+} DRM_PROVISIONING_RESPONSE_DATA;
+
+typedef struct __tagDRM_PROVISIONING_RESPONSE_SIGNATURE
+{
+    DRM_BOOL             fValid;
+    DRM_WORD             wSignatureType;
+    DRM_XB_BYTEARRAY     xbbaSignature;
+} DRM_PROVISIONING_RESPONSE_SIGNATURE;
+
+typedef struct __tagDRM_PROVISIONING_RESPONSE_MESSAGE
+{
+    DRM_BOOL                                fValid;
+    DRM_PROVISIONING_CERT                   Cert;
+    DRM_PROVISIONING_RESPONSE_DATA          ResponseData;
+    DRM_PROVISIONING_RESPONSE_SIGNATURE     Signature;
+} DRM_PROVISIONING_RESPONSE_MESSAGE;
+
+DRM_EXPORT_VAR extern DRM_GLOBAL_CONST DRM_XB_FORMAT_DESCRIPTION s_DRM_PROVISIONING_RESPONSE_MESSAGE_FormatDescription[1];
+
+typedef enum __tagDRM_PROVISIONING_REQUEST_MESSAGE_TYPES 
+{
+    DRM_PROVISIONING_REQUEST_DATA_ENTRY_TYPE         = 0x1,
+    DRM_PROVISIONING_PUBKEYS_ENTRY_TYPE              = 0x2,
+    DRM_PROVISIONING_VERSIONS_ENTRY_TYPE             = 0x3,
+    DRM_PROVISIONING_REQUEST_SIGNATURE_ENTRY_TYPE    = 0x4,
+    DRM_PROVISIONING_MODEL_AUTHORIZATION_ENTRY_TYPE  = 0x5,
+} DRM_PROVISIONING_REQUEST_MESSAGE_TYPES;
+/* Count Includes XB_OBJECT_GLOBAL_HEADER */
+#define DRM_PROVISIONING_REQUEST_MESSAGE_TYPE_COUNT       6
+#define DRM_PROVISIONING_REQUEST_MESSAGE_FORMAT_ID        XB_DEFINE_QWORD_FORMAT_ID( 'P', 'K', 'P', 'R', 'V', 'R', 'E', 'Q' )
+
+typedef struct __tagDRM_PROVISIONING_REQUEST_DATA
+{
+    DRM_BOOL             fValid;
+    DRM_WORD             wRequestType;
+    DRM_DWORD            dwFeaturesRequested;
+    DRM_UINT64           qwClientTimestamp;
+    DRM_XB_BYTEARRAY     xbbaSecureMediaPathCapabilities;
+    DRM_WORD             wEncryptionType;
+    DRM_XB_BYTEARRAY     xbbaHWId;
+    DRM_XB_BYTEARRAY     xbbaAppId;
+    DRM_XB_BYTEARRAY     xbbaNonce;
+} DRM_PROVISIONING_REQUEST_DATA;
+
+typedef struct __tagDRM_PROVISIONING_PUBKEYS
+{
+    DRM_BOOL             fValid;
+    DRM_XB_BYTEARRAY     xbbaSigningPubKey;
+    DRM_XB_BYTEARRAY     xbbaEncryptionPubKey;
+    DRM_XB_BYTEARRAY     xbbaPRNDPubKeyDeprecated;
+} DRM_PROVISIONING_PUBKEYS;
+
+typedef struct __tagDRM_PROVISIONING_VERSIONS
+{
+    DRM_BOOL      fValid;
+    DRM_DWORD     dwOEMTEEVersion;
+    DRM_DWORD     dwPKMajorVersion;
+    DRM_DWORD     dwPKMinorVersion;
+    DRM_DWORD     dwPKBuildVersion;
+    DRM_DWORD     dwPKQFEVersion;
+} DRM_PROVISIONING_VERSIONS;
+
+typedef struct __tagDRM_PROVISIONING_MODEL_AUTHORIZATION
+{
+    DRM_BOOL             fValid;
+    DRM_WORD             wSignatureType;
+    DRM_XB_BYTEARRAY     xbbaCertificate;
+    DRM_XB_BYTEARRAY     xbbaSignedData;
+    DRM_XB_BYTEARRAY     xbbaSignature;
+} DRM_PROVISIONING_MODEL_AUTHORIZATION;
+
+typedef struct __tagDRM_PROVISIONING_REQUEST_SIGNATURE
+{
+    DRM_BOOL             fValid;
+    DRM_WORD             wSignatureType;
+    DRM_XB_BYTEARRAY     xbbaSignature;
+} DRM_PROVISIONING_REQUEST_SIGNATURE;
+
+typedef struct __tagDRM_PROVISIONING_REQUEST_MESSAGE
+{
+    DRM_BOOL                                 fValid;
+    DRM_PROVISIONING_REQUEST_DATA            RequestData;
+    DRM_PROVISIONING_PUBKEYS                 PubKeys;
+    DRM_PROVISIONING_VERSIONS                Versions;
+    DRM_PROVISIONING_MODEL_AUTHORIZATION     ModelAuth;
+    DRM_PROVISIONING_REQUEST_SIGNATURE       Signature;
+} DRM_PROVISIONING_REQUEST_MESSAGE;
+
+DRM_EXPORT_VAR extern DRM_GLOBAL_CONST DRM_XB_FORMAT_DESCRIPTION s_DRM_PROVISIONING_REQUEST_MESSAGE_FormatDescription[1];
+
+PREFAST_POP;
+
+EXIT_PK_NAMESPACE;
+
+#endif /* __PROVISIONINGFORMATS_H__ */
diff --git a/prebuilt-v4.4/noarch/include/drmremovaldatestore.h b/prebuilt-v4.4/noarch/include/drmremovaldatestore.h
new file mode 100644
index 0000000..e40054d
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmremovaldatestore.h
@@ -0,0 +1,67 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __DRM_REMOVAL_DATE_STORE__
+#define __DRM_REMOVAL_DATE_STORE__
+
+#include <drmremovaldatestorecontext.h>
+
+ENTER_PK_NAMESPACE;
+
+DRM_API DRM_RESULT DRM_CALL DRM_RDS_OpenStore(
+    __inout_ecount( 1 )   DRM_DST                  *f_pDatastore,
+    __out_ecount( 1 )     DRM_REMOVAL_DATE_CONTEXT *f_pcontextRemovalDateOut);
+
+DRM_API DRM_RESULT DRM_CALL DRM_RDS_CloseStore(
+    __inout_ecount( 1 )   DRM_REMOVAL_DATE_CONTEXT *f_pcontextRemovalDateIn);
+
+DRM_API DRM_RESULT DRM_CALL DRM_RDS_DeleteLicenseEntry(
+    __inout_ecount( 1 )        DRM_DST             *f_pDatastore,
+    __in_ecount( 1 )     const DRM_KID             *f_pKID,
+    __in_ecount_opt( 1 ) const DRM_LID             *f_pLID );
+
+DRM_API DRM_RESULT DRM_CALL DRM_RDS_EnumDeleteCurrent(
+    __inout_ecount( 1 )   DRM_REMOVAL_DATE_ENUM    *f_pcontextRemovalDateEnum );
+
+DRM_API DRM_RESULT DRM_CALL DRM_RDS_InitEnum(
+    __inout_ecount( 1 )   DRM_REMOVAL_DATE_CONTEXT *f_pcontextRemovalDate,
+    __in                  DRM_DST_LOCKMODE          f_eLockMode,
+    __out_ecount( 1 )     DRM_REMOVAL_DATE_ENUM    *f_pcontextRemovalDateEnum );
+
+DRM_API DRM_RESULT DRM_CALL DRM_RDS_EnumNext(
+    __inout_ecount( 1 )   DRM_REMOVAL_DATE_ENUM    *f_pcontextRemovalDateEnum,
+    __out_ecount( 1 )     DRM_DWORD                *f_pdwRemovalDate,
+    __out_ecount( 1 )     DRM_KID                  *f_pKID,
+    __out_ecount_opt( 1 ) DRM_DST_SLOT_HINT        *f_pslotHint,
+    __out_ecount_opt( 1 ) DRM_DWORD                *f_pcLicenses );
+
+DRM_API DRM_RESULT DRM_CALL DRM_RDS_AddRemovalDate(
+    __inout_ecount( 1 )        DRM_DST                    *f_pDatastore,
+    __in_ecount_opt( 1 )       DRM_DST_NAMESPACE_CONTEXT  *f_pDstNamespaceContext,
+    __in                       DRM_DWORD                   f_dwRemovalDate,
+    __in_ecount( 1 )     const DRM_KID                    *f_pKID,
+    __in_ecount( 1 )     const DRM_LID                    *f_pLID,
+    __in_ecount_opt( 1 ) const DRM_DST_SLOT_HINT          *f_pSlotHint );
+
+DRM_API DRM_RESULT DRM_CALL DRM_RDS_GetRemovalDateEntry(
+   __inout_ecount( 1 )            DRM_REMOVAL_DATE_CONTEXT *f_pcontextRemovalDate,
+   __in                           DRM_DWORD                 f_dwRemovalDate,
+   __in_ecount( 1 )         const DRM_KID                  *f_pKID,
+   __in_ecount_opt( 1 )           DRM_DST_SLOT_HINT        *f_pslotHint,
+   __inout_ecount( 1 )            DRM_DWORD                *f_pcbData,
+   __out_bcount(*f_pcbData)       DRM_BYTE                 *f_pbData,
+   __out_ecount( 1 )              DRM_DWORD                *f_pcEntries );
+
+DRM_API DRM_RESULT DRM_CALL DRM_RDS_GetLicenseCount(
+    __inout_ecount( 1 )         DRM_DST                  *f_pDatastore,
+    __in_ecount_opt( 1 ) const  DRM_DWORD                *f_pdwRemovalDate,
+    __out_ecount( 1 )           DRM_DWORD                *f_pcLicenses );
+
+EXIT_PK_NAMESPACE;
+
+#endif /* __DRM_REMOVAL_DATE_STORE__ */
diff --git a/prebuilt-v4.4/noarch/include/drmremovaldatestorecontext.h b/prebuilt-v4.4/noarch/include/drmremovaldatestorecontext.h
new file mode 100644
index 0000000..5a29c4e
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmremovaldatestorecontext.h
@@ -0,0 +1,58 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __DRM_REMOVAL_DATE_STORE_CONTEXT__
+#define __DRM_REMOVAL_DATE_STORE_CONTEXT__
+
+#include <drmtypes.h>
+#include <drmdatastoretypes.h>
+
+ENTER_PK_NAMESPACE;
+
+typedef struct _tagRemovalDateContext
+{
+    DRM_DST_SLOT_CONTEXT      contextDSTSlot;
+    DRM_DST_NAMESPACE_CONTEXT contextNameSpace;
+    DRM_DST                  *pDatastore;
+    DRM_BOOL                  fInited;
+} DRM_REMOVAL_DATE_CONTEXT_PRIVATE;
+
+
+typedef struct _tagRemovalDateEnumContext
+{
+    DRM_REMOVAL_DATE_CONTEXT_PRIVATE *pcontextRemovalDate;
+    DRM_DST_ENUM_CONTEXT              contextDSTEnum;
+    DRM_DST_SLOT_CONTEXT              contextDSTSlot;
+    DRM_BOOL                          fInited;
+    DRM_BOOL                          fAny;
+    DRM_BOOL                          fSkipEnumNext;
+} DRM_REMOVAL_DATE_ENUM_PRIVATE;
+
+typedef struct _tagDrmRemovalDateEntry
+{
+    DRM_LID           lid;
+    DRM_DST_SLOT_HINT slotHint;
+} DRM_REMOVAL_DATE_ENTRY;
+
+#define DRM_REMOVAL_DATE_ENTRY_EMPTY { DRM_ID_EMPTY, {0} }
+
+/* opaque versions of contexts, corresponding to those actually declared in drmremvoaldatestore.c */
+
+typedef struct __tagDRM_REMOVAL_DATE_CONTEXT
+{
+    DRM_BYTE rgbOpaqueData [ sizeof(DRM_REMOVAL_DATE_CONTEXT_PRIVATE) ];
+} DRM_REMOVAL_DATE_CONTEXT;
+
+typedef struct __tagDRM_REMOVAL_DATE_ENUM
+{
+    DRM_BYTE rgbOpaqueData [ sizeof(DRM_REMOVAL_DATE_ENUM_PRIVATE) ];
+} DRM_REMOVAL_DATE_ENUM;
+
+EXIT_PK_NAMESPACE;
+
+#endif /* __DRM_REMOVAL_DATE_STORE_CONTEXT__ */
diff --git a/prebuilt-v4.4/noarch/include/drmresults.h b/prebuilt-v4.4/noarch/include/drmresults.h
new file mode 100644
index 0000000..21b8e6f
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmresults.h
@@ -0,0 +1,5837 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __DRMRESULTS_H__
+#define __DRMRESULTS_H__
+
+/*
+** This file contains all the DRM_RESULTS required for building Porting Kit
+** applications.
+**
+** NOTE: PC and Services error codes should ****NOT**** be added here, 
+**       but rather to the files discussed in the comments further down
+**       regarding them.
+**
+** NOTE: DRM_RESULTS can be converted into Windows HRESULTS without any
+**       changes. The FACILITY values below are carefully selected to allow
+**       for this.
+**
+*/
+
+#include <oemresults.h>
+
+#define DRM_FAILED(Status) ((DRM_RESULT)(Status)<0)
+#define DRM_SUCCEEDED(Status) ((DRM_RESULT)(Status) >= 0)
+
+#define DRM_S_BASECODE                          0xC000
+#define DRM_E_BASECODE                          0xC000
+#define DRM_E_PK_BASECODE                       0xA000
+
+
+/*
+** !!!!!!  VERY IMPORTANT, PLEASE READ !!!!!
+**
+**  NOTE: The following ranges are reserved and should never be used to define PK error codes.
+**  The range from 80040000 to 80040fff is reserved for Windows error codes.
+**  The range from 80041000 to 80047fff is reserved for non-PlayReady Microsoft error codes.
+**  The range from 8004b000 to 8004bfff is reserved for PlayReady PC error codes.
+**  The range from 8004e000 to 8004ffff is reserved for PlayReady PC error codes.
+**
+**  NOTE: The following ranges are OK to be used for PK errors.
+**  The range from 80048000 to 8004afff is reserved for PlayReady PK error codes.
+**  The range from 8004c000 to 8004dfff is reserved for PlayReady PK error codes.
+**      Exceptions:
+**           The sub-range 8004c600 to 8004c6ff is reserved for PlayReady Server and Services error codes.
+**           The sub-range 8004dc80 to 8004ddff is reserved for OEM-defined PlayReady PK error codes.
+**
+**  There's a range of error codes that is only applicable to the PC and should
+**  not be included here. These errors are in common\include, files:
+**  msprerr.h
+**  drmndbridgeerr.h
+**  errorservice.h
+**  To prevent overlaps of PK and PC error codes, please assume that:
+**  The range from 0x8004B000 to 0x8004BEFF is reserved for the PC (error codes).
+**  The range from 0x0004B000 to 0x0004BEFF is reserved for the PC (success codes).
+**  The range from 0x8004BE00 to 0x8004BFFF is reserved for the Modern SDK (error codes).
+**  The range from 0x0004BE00 to 0x0004BFFF is reserved for the Modern SDK (success codes).
+**  The following three defines represent the basecodes for the PC.
+*/
+#define DRM_E_NDBRIDGEONLY_BASECODE     0xB000
+#define DRM_E_MSPRSDK_BASECODE          0xB800
+#define DRM_E_MODERN_BASECODE           0xBE00
+
+#define DRM_FACILITY_ITF DRM_FACILITY_CORE
+
+#define MAKE_DRM_RESULT(sev,fac,code) \
+    ((DRM_RESULT) (((unsigned long)(sev)<<30) | ((unsigned long)(fac)<<16) | ((unsigned long)(code))) )
+
+/* ============================================================
+**
+** Standard Success values
+**
+** ============================================================
+*/
+
+/*
+ *  Values are 32 bit values laid out as follows:
+ *
+ *   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
+ *   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
+ *  +-+-+-+-+-+---------------------+-------------------------------+
+ *  |S|R|C|N|r|    Facility         |               Code            |
+ *  +-+-+-+-+-+---------------------+-------------------------------+
+ *
+ *  where
+ *
+ *      S - Severity - indicates success/fail
+ *
+ *          0 - Success
+ *          1 - Fail (COERROR)
+ *
+ *      R - reserved portion of the facility code, corresponds to NT's
+ *              second severity bit.
+ *
+ *      C - reserved portion of the facility code, corresponds to NT's
+ *              C field.
+ *
+ *      N - reserved portion of the facility code. Used to indicate a
+ *              mapped NT status value.
+ *
+ *      r - reserved portion of the facility code. Reserved for internal
+ *              use. Used to indicate HRESULT values that are not status
+ *              values, but are instead message ids for display strings.
+ *
+ *      Facility - is the facility code
+ *
+ *      Code - is the facility's status code
+ *
+ *
+ * Define the facility codes
+ *
+ */
+#define DRM_FACILITY_STANDARD            0x0
+#define DRM_FACILITY_COM_STORAGE         0x3
+#define DRM_FACILITY_CORE                0x4
+#define DRM_FACILITY_WIN32               0x7
+#define DRM_FACILITY_NETSHOW             0xD
+
+
+/*
+ * Define the severity codes
+ *
+ */
+#define DRM_SEVERITY_SUCCESS             0x0
+#define DRM_SEVERITY_ERROR               0x2
+#define DRM_SEVERITY_NETSHOW_ERROR       0x3
+
+
+/*
+ * MessageId: DRM_SUCCESS
+ *
+ * MessageText:
+ *
+ * Operation was successful.
+ *
+ */
+#define DRM_SUCCESS                      ((DRM_RESULT)0x00000000L)
+
+/*
+ * MessageId: DRM_S_FALSE
+ *
+ * MessageText:
+ *
+ * Operation was successful, but returned a FALSE test condition.
+ *
+ */
+#define DRM_S_FALSE                      ((DRM_RESULT)0x00000001L)
+
+/*
+ * MessageId: DRM_S_MORE_DATA
+ *
+ * MessageText:
+ *
+ * Operation was successful, but more data is available.
+ *
+ */
+#define DRM_S_MORE_DATA                  ((DRM_RESULT)0x00000002L)
+
+
+
+/* ============================================================
+**
+** Standard error messages (0x8000xxxx)
+**
+** ============================================================
+*/
+
+/*
+ * MessageId: DRM_E_OUTOFMEMORY
+ *
+ * MessageText:
+ *
+ * Insufficient resources exist to complete the request.
+ *
+ */
+#define DRM_E_OUTOFMEMORY                ((DRM_RESULT)0x80000002L)
+
+/*
+ * MessageId: DRM_E_NOTIMPL
+ *
+ * MessageText:
+ *
+ * The requested operation is not implemented.
+ *
+ */
+#define DRM_E_NOTIMPL                    ((DRM_RESULT)0x80004001L)
+
+/*
+ * MessageId: DRM_E_POINTER
+ *
+ * MessageText:
+ *
+ * Invalid pointer.
+ *
+ */
+#define DRM_E_POINTER                    ((DRM_RESULT)0x80004003L)
+
+/*
+ * MessageId: DRM_E_FAIL
+ *
+ * MessageText:
+ *
+ * The requested operation failed.
+ *
+ */
+#define DRM_E_FAIL                       ((DRM_RESULT)0x80004005L)
+
+
+/* ============================================================
+**
+** Error messages shared with Win32 (0x8007xxxx)
+**
+** ============================================================
+*/
+
+/*
+ * MessageId: DRM_E_WIN32_FILE_NOT_FOUND
+ *
+ * MessageText:
+ *
+ * The system cannot find the file specified.
+ *
+ */
+#define DRM_E_WIN32_FILE_NOT_FOUND       ((DRM_RESULT)0x80070002L)
+
+/*
+ * MessageId: DRM_E_HANDLE
+ *
+ * MessageText:
+ *
+ * Invalid handle.
+ *
+ */
+#define DRM_E_HANDLE                     ((DRM_RESULT)0x80070006L)
+
+/*
+ * MessageId: DRM_E_WIN32_NO_MORE_FILES
+ *
+ * MessageText:
+ *
+ * There are no more files.
+ *
+ */
+#define DRM_E_WIN32_NO_MORE_FILES        ((DRM_RESULT)0x80070012L)
+
+/*
+ * MessageId: DRM_E_INVALIDARG
+ *
+ * MessageText:
+ *
+ * The parameter is incorrect.
+ *
+ */
+#define DRM_E_INVALIDARG                 ((DRM_RESULT)0x80070057L)
+
+/*
+ * MessageId: DRM_E_BUFFERTOOSMALL
+ *
+ * MessageText:
+ *
+ * The data area passed to a function is too small.
+ *
+ */
+#define DRM_E_BUFFERTOOSMALL             ((DRM_RESULT)0x8007007AL)
+
+/*
+ * MessageId: DRM_E_NOMORE
+ *
+ * MessageText:
+ *
+ * No more data is available.
+ *
+ */
+#define DRM_E_NOMORE                     ((DRM_RESULT)0x80070103L)
+
+/*
+ * MessageId: DRM_E_ARITHMETIC_OVERFLOW
+ *
+ * MessageText:
+ *
+ * Arithmetic result exceeded maximum value.
+ *
+ */
+#define DRM_E_ARITHMETIC_OVERFLOW        ((DRM_RESULT)0x80070216L)
+
+/*
+ * MessageId: DRM_E_NOT_FOUND
+ *
+ * MessageText:
+ *
+ * Element not found.
+ *
+ */
+#define DRM_E_NOT_FOUND                  ((DRM_RESULT)0x80070490L)
+
+/*
+ * MessageId: DRM_E_INVALID_COMMAND_LINE
+ *
+ * MessageText:
+ *
+ * Invalid command line argument.
+ *
+ */
+#define DRM_E_INVALID_COMMAND_LINE       ((DRM_RESULT)0x80070667L)
+
+
+/* ============================================================
+**
+** Error messages shared with COM Storage (mostly file errors)
+** (0x8003xxxx)
+**
+** ============================================================
+*/
+
+/*
+ * MessageId: DRM_E_FILENOTFOUND
+ *
+ * MessageText:
+ *
+ * A requested file could not be found.
+ *
+ */
+#define DRM_E_FILENOTFOUND               ((DRM_RESULT)0x80030002L)
+
+/*
+ * MessageId: DRM_E_FILEOPEN
+ *
+ * MessageText:
+ *
+ * A request failed due to a file being open.
+ *
+ */
+#define DRM_E_FILEOPEN                   ((DRM_RESULT)0x8003006EL)
+
+
+/* ============================================================
+**
+** NetShow Errors from NsError.h (0xc00Dxxxx)
+**
+** ============================================================
+*/
+
+/*
+ * MessageId: DRM_E_PARAMETERS_MISMATCHED
+ *
+ * MessageText:
+ *
+ * A problem has occurred in the Digital Rights Management component.
+ *
+ */
+#define DRM_E_PARAMETERS_MISMATCHED      ((DRM_RESULT)0xC00D272FL)
+
+/*
+ * MessageId: DRM_E_FAILED_TO_STORE_LICENSE
+ *
+ * MessageText:
+ *
+ * License storage is not working.
+ *
+ */
+#define DRM_E_FAILED_TO_STORE_LICENSE    ((DRM_RESULT)0xC00D2712L)
+
+/*
+ * MessageId: DRM_E_NOT_ALL_STORED
+ *
+ * MessageText:
+ *
+ * Some of the licenses could not be stored.
+ *
+ */
+#define DRM_E_NOT_ALL_STORED             ((DRM_RESULT)0xC00D275FL)
+
+
+/* ============================================================
+**
+** Vista crypto errors, 0x80040e80-0x80040e8f.
+**
+** ============================================================
+*/
+
+/*
+ * MessageId: DRM_E_VERIFICATION_FAILURE
+ *
+ * MessageText:
+ *
+ * Validation of a Longhorn certificate failed.
+ *
+ */
+#define DRM_E_VERIFICATION_FAILURE       ((DRM_RESULT)0x80040E80L)
+
+/*
+ * MessageId: DRM_E_RSA_SIGNATURE_ERROR
+ *
+ * MessageText:
+ *
+ * Error in RSA(PSS) signature.
+ *
+ */
+#define DRM_E_RSA_SIGNATURE_ERROR        ((DRM_RESULT)0x80040E82L)
+
+/*
+ * MessageId: DRM_E_BAD_RSA_EXPONENT
+ *
+ * MessageText:
+ *
+ * An incorrect RSA exponent was supplied for a public key.
+ *
+ */
+#define DRM_E_BAD_RSA_EXPONENT           ((DRM_RESULT)0x80040E86L)
+
+/*
+ * MessageId: DRM_E_P256_CONVERSION_FAILURE
+ *
+ * MessageText:
+ *
+ * An error occurred while converting between P256 types.
+ *
+ */
+#define DRM_E_P256_CONVERSION_FAILURE    ((DRM_RESULT)0x80040E87L)
+
+/*
+ * MessageId: DRM_E_P256_PKCRYPTO_FAILURE
+ *
+ * MessageText:
+ *
+ * An error occurred in an asymmetric P256 cryptographic operation.
+ *
+ */
+#define DRM_E_P256_PKCRYPTO_FAILURE      ((DRM_RESULT)0x80040E88L)
+
+/*
+ * MessageId: DRM_E_P256_PLAINTEXT_MAPPING_FAILURE
+ *
+ * MessageText:
+ *
+ * An error occurred while attempting to map a plaintext array to a EC Point: There is no conversion for this byte array to a EC Point.
+ *
+ */
+#define DRM_E_P256_PLAINTEXT_MAPPING_FAILURE ((DRM_RESULT)0x80040E89L)
+
+/*
+ * MessageId: DRM_E_P256_INVALID_SIGNATURE
+ *
+ * MessageText:
+ *
+ * The ECDSA signature to be verified was not a valid signature format.
+ *
+ */
+#define DRM_E_P256_INVALID_SIGNATURE     ((DRM_RESULT)0x80040E8AL)
+
+/*
+ * MessageId: DRM_E_P256_ECDSA_VERIFICATION_ERROR
+ *
+ * MessageText:
+ *
+ * The ECDSA verification algorithm encountered an unknown error.
+ *
+ */
+#define DRM_E_P256_ECDSA_VERIFICATION_ERROR ((DRM_RESULT)0x80040E8BL)
+
+/*
+ * MessageId: DRM_E_P256_ECDSA_SIGNING_ERROR
+ *
+ * MessageText:
+ *
+ * The ECDSA signature algorithm encountered an unknown error.
+ *
+ */
+#define DRM_E_P256_ECDSA_SIGNING_ERROR   ((DRM_RESULT)0x80040E8CL)
+
+/*
+ * MessageId: DRM_E_P256_HMAC_KEYGEN_FAILURE
+ *
+ * MessageText:
+ *
+ * Could not generate a valid HMAC key under constraint where CK || HMACK is a valid x coord on the EC (P256).
+ *
+ */
+#define DRM_E_P256_HMAC_KEYGEN_FAILURE   ((DRM_RESULT)0x80040E8DL)
+
+
+/* ============================================================
+**
+** IContentHeader errors: error codes from DRM_E_CH_BASECODE+0
+** to DRM_E_CH_BASECODE+0x7F, 0x80041100-0x8004117f.
+**
+** ============================================================
+*/
+
+#define DRM_E_CH_BASECODE                ((DRM_RESULT)0x80041100L)
+
+/*
+ * MessageId: DRM_E_CH_VERSION_MISSING
+ *
+ * MessageText:
+ *
+ * Missing content header version.
+ *
+ */
+#define DRM_E_CH_VERSION_MISSING         ((DRM_RESULT)0x80041103L)
+
+/*
+ * MessageId: DRM_E_CH_KID_MISSING
+ *
+ * MessageText:
+ *
+ * Missing KID attribute in content header.
+ *
+ */
+#define DRM_E_CH_KID_MISSING             ((DRM_RESULT)0x80041104L)
+
+/*
+ * MessageId: DRM_E_CH_LAINFO_MISSING
+ *
+ * MessageText:
+ *
+ * Missing LAINFO attribute in content header.
+ *
+ */
+#define DRM_E_CH_LAINFO_MISSING          ((DRM_RESULT)0x80041105L)
+
+/*
+ * MessageId: DRM_E_CH_CHECKSUM_MISSING
+ *
+ * MessageText:
+ *
+ * Missing content header checksum.
+ *
+ */
+#define DRM_E_CH_CHECKSUM_MISSING        ((DRM_RESULT)0x80041106L)
+
+/*
+ * MessageId: DRM_E_CH_INVALID_HEADER
+ *
+ * MessageText:
+ *
+ * Invalid content header.
+ *
+ */
+#define DRM_E_CH_INVALID_HEADER          ((DRM_RESULT)0x80041108L)
+
+/*
+ * MessageId: DRM_E_CH_INVALID_CHECKSUM
+ *
+ * MessageText:
+ *
+ * Invalid checksum in the header.
+ *
+ */
+#define DRM_E_CH_INVALID_CHECKSUM        ((DRM_RESULT)0x80041109L)
+
+/*
+ * MessageId: DRM_E_CH_UNABLE_TO_VERIFY
+ *
+ * MessageText:
+ *
+ * Unable to verify signature of content header.
+ *
+ */
+#define DRM_E_CH_UNABLE_TO_VERIFY        ((DRM_RESULT)0x8004110AL)
+
+/*
+ * MessageId: DRM_E_CH_UNSUPPORTED_VERSION
+ *
+ * MessageText:
+ *
+ * Unsupported content header version.
+ *
+ */
+#define DRM_E_CH_UNSUPPORTED_VERSION     ((DRM_RESULT)0x8004110BL)
+
+/*
+ * MessageId: DRM_E_CH_BAD_KEY
+ *
+ * MessageText:
+ *
+ * Invalid key.
+ *
+ */
+#define DRM_E_CH_BAD_KEY                 ((DRM_RESULT)0x8004110EL)
+
+/*
+ * MessageId: DRM_E_CH_INCOMPATIBLE_HEADER_TYPE
+ *
+ * MessageText:
+ *
+ * Incompatible content header type.
+ *
+ */
+#define DRM_E_CH_INCOMPATIBLE_HEADER_TYPE ((DRM_RESULT)0x8004110FL)
+
+/*
+ * MessageId: DRM_E_HEADER_ALREADY_SET
+ *
+ * MessageText:
+ *
+ * Content header type is already set. Reinitialize is required.
+ *
+ */
+#define DRM_E_HEADER_ALREADY_SET         ((DRM_RESULT)0x80041110L)
+
+/*
+ * MessageId: DRM_E_CH_MULTIPLE_KIDS
+ *
+ * MessageText:
+ *
+ * Content header includes multiple KIDs.  The operation requested is unsupported.
+ *
+ */
+#define DRM_E_CH_MULTIPLE_KIDS           ((DRM_RESULT)0x80041111L)
+
+
+/* ============================================================
+**
+** CD Migration Tool errors: error codes from DRM_E_CH_BASECODE+0x80
+** to DRM_E_CH_BASECODE+0xFF, 0x80041180-0x800411ff.
+**
+** ============================================================
+*/
+
+#define DRM_E_CDMIGRATIONTOOL_BASECODE                ((DRM_RESULT)0x80041180L)
+#define DRM_E_CDMIGRATIONTOOL_MAXCODE                 ((DRM_RESULT)0x800411FFL)
+
+/*
+ * MessageId: DRM_E_CDMIGRATIONTOOL_INVALID_FILE
+ *
+ * MessageText:
+ *
+ * File cannot be migrated because it is invalid.
+ *
+ */
+#define DRM_E_CDMIGRATIONTOOL_INVALID_FILE ((DRM_RESULT)0x80041180L)
+
+
+/*
+ * MessageId: DRM_E_CDMIGRATIONTOOL_FILE_IS_NOT_CD_RIPPED
+ *
+ * MessageText:
+ *
+ * File cannot be migrated because it was not ripped from CD.
+ *
+ */
+#define DRM_E_CDMIGRATIONTOOL_FILE_IS_NOT_CD_RIPPED ((DRM_RESULT)0x80041181L)
+
+
+/*
+ * MessageId: DRM_E_CDMIGRATIONTOOL_FILE_IS_NOT_PROTECTED
+ *
+ * MessageText:
+ *
+ * File cannot be migrated because it is not protected.
+ *
+ */
+#define DRM_E_CDMIGRATIONTOOL_FILE_IS_NOT_PROTECTED ((DRM_RESULT)0x80041182L)
+
+
+/*
+ * MessageId: DRM_E_CDMIGRATIONTOOL_LICENSE_KID_INVALID
+ *
+ * MessageText:
+ *
+ * File cannot be migrated because the server returned a license with an invalid KID.
+ *
+ */
+#define DRM_E_CDMIGRATIONTOOL_LICENSE_KID_INVALID ((DRM_RESULT)0x80041183L)
+
+
+/*
+ * MessageId: DRM_E_CDMIGRATIONTOOL_LICENSE_KID_MISMATCH
+ *
+ * MessageText:
+ *
+ * File cannot be migrated because the server returned a license with a KID that did not match the content.
+ *
+ */
+#define DRM_E_CDMIGRATIONTOOL_LICENSE_KID_MISMATCH ((DRM_RESULT)0x80041184L)
+
+
+/*
+ * MessageId: DRM_E_CDMIGRATIONTOOL_LICENSE_CONTENT_KEY_INVALID
+ *
+ * MessageText:
+ *
+ * File cannot be migrated because the server returned a license with an invalid content key.
+ *
+ */
+#define DRM_E_CDMIGRATIONTOOL_LICENSE_CONTENT_KEY_INVALID ((DRM_RESULT)0x80041185L)
+
+
+/*
+ * MessageId: DRM_E_CDMIGRATIONTOOL_INVALID_ASF_FORMAT
+ *
+ * MessageText:
+ *
+ * File cannot be migrated because the ASF is corrupt.
+ *
+ */
+#define DRM_E_CDMIGRATIONTOOL_INVALID_ASF_FORMAT ((DRM_RESULT)0x80041186L)
+
+
+/*
+ * MessageId: DRM_E_CDMIGRATIONTOOL_INVALID_ASF_PACKETS
+ *
+ * MessageText:
+ *
+ * File cannot be migrated because the ASF packets are corrupt.
+ *
+ */
+#define DRM_E_CDMIGRATIONTOOL_INVALID_ASF_PACKETS ((DRM_RESULT)0x80041187L)
+
+
+/*
+ * MessageId: DRM_E_CDMIGRATIONTOOL_CONTENT_KEY_CACHE_CORRUPT
+ *
+ * MessageText:
+ *
+ * File cannot be migrated because the content key obtained from the local cache is invalid.
+ *
+ */
+#define DRM_E_CDMIGRATIONTOOL_CONTENT_KEY_CACHE_CORRUPT ((DRM_RESULT)0x80041188L)
+
+
+/*
+ * MessageId: DRM_E_CDMIGRATIONTOOL_FILE_WRITE_ERROR
+ *
+ * MessageText:
+ *
+ * File cannot be migrated because the file could not be written.
+ *
+ */
+#define DRM_E_CDMIGRATIONTOOL_FILE_WRITE_ERROR ((DRM_RESULT)0x80041189L)
+
+
+/*
+ * MessageId: DRM_E_CDMIGRATIONTOOL_CANCELLED
+ *
+ * MessageText:
+ *
+ * File migration was cancelled.
+ *
+ */
+#define DRM_E_CDMIGRATIONTOOL_CANCELLED  ((DRM_RESULT)0x8004118AL)
+
+
+/* ============================================================
+**
+** License parsing results: error codes from 0x80041200-0x800412ff.
+**
+** ============================================================
+*/
+
+#define DRM_E_LIC_BASECODE           ((DRM_RESULT)0x80041200L)
+
+/*
+ * MessageId: DRM_E_LIC_UNSUPPORTED_VALUE
+ *
+ * MessageText:
+ *
+ *  DRM_E_LIC_UNSUPPORTED_VALUE
+ *
+ */
+#define DRM_E_LIC_UNSUPPORTED_VALUE      ((DRM_RESULT)0x80041207L)
+
+
+/* ============================================================
+**
+** CDMI: error codes from 0x80041300-0x8004137f.
+**
+** ============================================================
+*/
+
+#define DRM_E_CDMI_BASECODE          ((DRM_RESULT)0x80041300L)
+
+/*
+ * MessageId: DRM_E_CDMI_INVALID_INITIALIZATION_DATA
+ *
+ * MessageText:
+ *
+ * Invalid initialization data.
+ *
+ */
+#define DRM_E_CDMI_INVALID_INITIALIZATION_DATA ((DRM_RESULT)0x80041301L)
+
+/*
+ * MessageId: DRM_E_CDMI_PERSISTENT_LICENSE_FOR_NON_PERSISTENT_LICENSE_SESSION
+ *
+ * MessageText:
+ *
+ * A persistent license was provided for a session that was not persistent-license.
+ *
+ */
+#define DRM_E_CDMI_PERSISTENT_LICENSE_FOR_NON_PERSISTENT_LICENSE_SESSION ((DRM_RESULT)0x80041302L)
+
+/*
+ * MessageId: DRM_E_CDMI_SECURE_STOP_LICENSE_FOR_NON_PERSISTENT_USAGE_RECORD_SESSION
+ *
+ * MessageText:
+ *
+ * A secure stop license was provided for a session that was not persistent-usage-record.
+ *
+ */
+#define DRM_E_CDMI_SECURE_STOP_LICENSE_FOR_NON_PERSISTENT_USAGE_RECORD_SESSION ((DRM_RESULT)0x80041303L)
+
+/*
+ * MessageId: DRM_E_CDMI_TEMPORARY_LICENSE_FOR_NON_TEMPORARY_SESSION
+ *
+ * MessageText:
+ *
+ * An in-memory-only license without secure-stop was provided for a session that was not temporary.
+ *
+ */
+#define DRM_E_CDMI_TEMPORARY_LICENSE_FOR_NON_TEMPORARY_SESSION ((DRM_RESULT)0x80041304L)
+
+/*
+ * MessageId: DRM_E_CDMI_UNSUPPORTED_KEY_SYSTEM
+ *
+ * MessageText:
+ *
+ * The requested key system is not supported by PlayReady.
+ *
+ */
+#define DRM_E_CDMI_UNSUPPORTED_KEY_SYSTEM ((DRM_RESULT)0x80041305L)
+
+/*
+ * MessageId: DRM_E_CDMI_UNSUPPORTED_INITIALIZATION_DATA_TYPES
+ *
+ * MessageText:
+ *
+ * None of the requested initialization data types are supported by PlayReady.
+ *
+ */
+#define DRM_E_CDMI_UNSUPPORTED_INITIALIZATION_DATA_TYPES ((DRM_RESULT)0x80041306L)
+
+/*
+ * MessageId: DRM_E_CDMI_UNSUPPORTED_DISTINCTIVE_IDENTIFIER
+ *
+ * MessageText:
+ *
+ * The requested distinctive identifier setting is not supported by PlayReady.
+ *
+ */
+#define DRM_E_CDMI_UNSUPPORTED_DISTINCTIVE_IDENTIFIER ((DRM_RESULT)0x80041307L)
+
+/*
+ * MessageId: DRM_E_CDMI_UNSUPPORTED_SESSION_TYPE
+ *
+ * MessageText:
+ *
+ * The requested session type is not supported by PlayReady.
+ *
+ */
+#define DRM_E_CDMI_UNSUPPORTED_SESSION_TYPE ((DRM_RESULT)0x80041308L)
+
+/*
+ * MessageId: DRM_E_CDMI_UNSUPPORTED_INITIALIZATION_DATA
+ *
+ * MessageText:
+ *
+ * The provided initialization data is not supported by PlayReady.
+ *
+ */
+#define DRM_E_CDMI_UNSUPPORTED_INITIALIZATION_DATA ((DRM_RESULT)0x80041309L)
+
+/*
+ * MessageId: DRM_E_CDMI_SESSION_ALREADY_USED
+ *
+ * MessageText:
+ *
+ * The session has already been used.
+ *
+ */
+#define DRM_E_CDMI_SESSION_ALREADY_USED  ((DRM_RESULT)0x8004130AL)
+
+/*
+ * MessageId: DRM_E_CDMI_SESSION_UNINITIALIZED
+ *
+ * MessageText:
+ *
+ * The session is not yet initialized.
+ *
+ */
+#define DRM_E_CDMI_SESSION_UNINITIALIZED ((DRM_RESULT)0x8004130BL)
+
+/*
+ * MessageId: DRM_E_CDMI_SESSION_CLOSED
+ *
+ * MessageText:
+ *
+ * The session is closed.
+ *
+ */
+#define DRM_E_CDMI_SESSION_CLOSED        ((DRM_RESULT)0x8004130CL)
+
+/*
+ * MessageId: DRM_E_CDMI_SESSION_ID_NOT_FOUND
+ *
+ * MessageText:
+ *
+ * The given session ID could not be found.
+ *
+ */
+#define DRM_E_CDMI_SESSION_ID_NOT_FOUND  ((DRM_RESULT)0x8004130DL)
+
+/*
+ * MessageId: DRM_E_CDMI_SESSION_TYPE_MISMATCH
+ *
+ * MessageText:
+ *
+ * The given session was initialized with a different session type than the session being loaded or Load/Remove was called on a temporary session.
+ *
+ */
+#define DRM_E_CDMI_SESSION_TYPE_MISMATCH ((DRM_RESULT)0x8004130EL)
+
+/* ============================================================
+**
+** Legacy errors: error codes from 0x80048000-0x800480ff.
+**
+** ============================================================
+*/
+
+#define DRM_E_LEGACY_BASECODE                ((DRM_RESULT)0x80048000L)
+
+/*
+ * MessageId: DRM_E_LIC_KEY_DECODE_FAILURE
+ *
+ * MessageText:
+ *
+ * Key decode failure.
+ *
+ */
+#define DRM_E_LIC_KEY_DECODE_FAILURE     ((DRM_RESULT)0x80048007L)
+
+/*
+ * MessageId: DRM_E_KEY_MISMATCH
+ *
+ * MessageText:
+ *
+ * A public/private keypair is mismatched.
+ *
+ */
+#define DRM_E_KEY_MISMATCH               ((DRM_RESULT)0x80048014L)
+
+/*
+ * MessageId: DRM_E_INVALID_SIGNATURE
+ *
+ * MessageText:
+ *
+ * License signature failure.
+ *
+ */
+#define DRM_E_INVALID_SIGNATURE          ((DRM_RESULT)0x800480CFL)
+
+/*
+ * MessageId: DRM_E_CIPHER_NOT_INITIALIZED
+ *
+ * MessageText:
+ *
+ * The DRM Cipher routines were not correctly initialized before calling encryption/decryption routines.
+ *
+ */
+#define DRM_E_CIPHER_NOT_INITIALIZED     ((DRM_RESULT)0x800480D2L)
+
+/*
+ * MessageId: DRM_E_DECRYPT_NOT_INITIALIZED
+ *
+ * MessageText:
+ *
+ * The DRM decrypt routines were not correctly initialized before trying to decrypt data.
+ *
+ */
+#define DRM_E_DECRYPT_NOT_INITIALIZED    ((DRM_RESULT)0x800480D3L)
+
+/*
+ * MessageId: DRM_E_SECURESTORE_LOCK_NOT_OBTAINED
+ *
+ * MessageText:
+ *
+ * Before reading or writing data to securestore in raw mode, first the lock must be obtained using DRM_SST_OpenData.
+ *
+ */
+#define DRM_E_SECURESTORE_LOCK_NOT_OBTAINED ((DRM_RESULT)0x800480D4L)
+
+/*
+ * MessageId: DRM_E_PKCRYPTO_FAILURE
+ *
+ * MessageText:
+ *
+ * An error occurred in an asymmetric cryptographic operation.
+ *
+ */
+#define DRM_E_PKCRYPTO_FAILURE           ((DRM_RESULT)0x800480D5L)
+
+/*
+ * MessageId: DRM_E_INVALID_DST_SLOT_SIZE
+ *
+ * MessageText:
+ *
+ * Invalid DST slot size is specified.
+ *
+ */
+#define DRM_E_INVALID_DST_SLOT_SIZE      ((DRM_RESULT)0x800480D6L)
+
+
+/* ============================================================
+**
+** DRM utility results: error codes from 0x80049000-0x800490ff.
+**
+** ============================================================
+*/
+
+#define DRMUTIL_BASECODE       ((DRM_RESULT)0x80049000L)
+
+/*
+ * MessageId: DRM_E_UNSUPPORTED_VERSION
+ *
+ * MessageText:
+ *
+ *  DRM_E_UNSUPPORTED_VERSION
+ *
+ */
+#define DRM_E_UNSUPPORTED_VERSION        ((DRM_RESULT)0x80049005L)
+
+
+/* ============================================================
+**
+** PK specific errors (from 0x8004a000 to 0x8004afff)
+**
+** ============================================================
+*/
+
+/*
+ * MessageId: DRM_E_REVOCATION_GUID_NOT_RECOGNIZED
+ *
+ * MessageText:
+ *
+ * The revocation list type GUID was not recognized
+ *
+ */
+#define DRM_E_REVOCATION_GUID_NOT_RECOGNIZED ((DRM_RESULT)0x8004A002L)
+
+/*
+ * MessageId: DRM_E_LIC_CHAIN_TOO_DEEP
+ *
+ * MessageText:
+ *
+ * The license chained deeper than this implementation can handle
+ *
+ */
+#define DRM_E_LIC_CHAIN_TOO_DEEP         ((DRM_RESULT)0x8004A003L)
+
+/*
+ * MessageId: DRM_E_DEVICE_SECURITY_LEVEL_TOO_LOW
+ *
+ * MessageText:
+ *
+ * The security level of the remote device is too low to receive the license
+ *
+ */
+#define DRM_E_DEVICE_SECURITY_LEVEL_TOO_LOW ((DRM_RESULT)0x8004A004L)
+
+/*
+ * MessageId: DRM_E_DST_BLOCK_CACHE_CORRUPT
+ *
+ * MessageText:
+ *
+ * The block header cache returned invalid data
+ *
+ */
+#define DRM_E_DST_BLOCK_CACHE_CORRUPT    ((DRM_RESULT)0x8004A005L)
+
+/*
+ * MessageId: DRM_E_DST_BLOCK_CACHE_MISS
+ *
+ * MessageText:
+ *
+ * The block header cache didn't contain the requested block header
+ *
+ */
+#define DRM_E_DST_BLOCK_CACHE_MISS       ((DRM_RESULT)0x8004A007L)
+
+/*
+ * MessageId: DRM_E_INVALID_METERRESPONSE_SIGNATURE
+ *
+ * MessageText:
+ *
+ * Invalid signature in meter response
+ *
+ */
+#define DRM_E_INVALID_METERRESPONSE_SIGNATURE ((DRM_RESULT)0x8004A013L)
+
+/*
+ * MessageId: DRM_E_METERSTORE_DATA_NOT_FOUND
+ *
+ * MessageText:
+ *
+ * Metering data slot not found due to bad data in response file
+ *
+ */
+#define DRM_E_METERSTORE_DATA_NOT_FOUND  ((DRM_RESULT)0x8004A016L)
+
+/*
+ * MessageId: DRM_E_INVALID_REVOCATION_LIST
+ *
+ * MessageText:
+ *
+ * The revocation list version does not match the current revocation version
+ *
+ */
+#define DRM_E_INVALID_REVOCATION_LIST    ((DRM_RESULT)0x8004A018L)
+
+/*
+ * MessageId: DRM_E_ENVELOPE_CORRUPT
+ *
+ * MessageText:
+ *
+ * The envelope archive or file is corrupt
+ *
+ */
+#define DRM_E_ENVELOPE_CORRUPT           ((DRM_RESULT)0x8004A019L)
+
+/*
+ * MessageId: DRM_E_ENVELOPE_FILE_NOT_COMPATIBLE
+ *
+ * MessageText:
+ *
+ * The envelope file is not compatible with this version of the porting kit
+ *
+ */
+#define DRM_E_ENVELOPE_FILE_NOT_COMPATIBLE ((DRM_RESULT)0x8004A01AL)
+
+/*
+ * MessageId: DRM_E_EXTENDED_RESTRICTION_NOT_UNDERSTOOD
+ *
+ * MessageText:
+ *
+ * An extensible restriction was not understood by the app, and is mark as being required
+ *
+ */
+#define DRM_E_EXTENDED_RESTRICTION_NOT_UNDERSTOOD ((DRM_RESULT)0x8004A01BL)
+
+/*
+ * MessageId: DRM_E_OUTDATED_REVOCATION_LIST
+ *
+ * MessageText:
+ *
+ * The revocation list is outdated. It is required for the revocation list to be refreshed at least every 90 days.
+ *
+ */
+#define DRM_E_OUTDATED_REVOCATION_LIST   ((DRM_RESULT)0x8004A01EL)
+
+
+/* ============================================================
+**
+** Drm Core errors (from 0x8004c000 to 0x8004dfff)
+**
+** ============================================================
+*/
+
+/*
+ * MessageId: DRM_E_DEVICE_NOT_INITIALIZED
+ *
+ * MessageText:
+ *
+ * This device has not been initialized against a DRM init service
+ *
+ */
+#define DRM_E_DEVICE_NOT_INITIALIZED     ((DRM_RESULT)0x8004C001L)
+
+/*
+ * MessageId: DRM_E_DRM_NOT_INITIALIZED
+ *
+ * MessageText:
+ *
+ * The app has not call DRM_Init properly
+ *
+ */
+#define DRM_E_DRM_NOT_INITIALIZED        ((DRM_RESULT)0x8004C002L)
+
+/*
+ * MessageId: DRM_E_INVALID_LICENSE
+ *
+ * MessageText:
+ *
+ * The license is invalid
+ *
+ */
+#define DRM_E_INVALID_LICENSE            ((DRM_RESULT)0x8004C006L)
+
+/*
+ * MessageId: DRM_E_LICENSE_EXPIRED
+ *
+ * MessageText:
+ *
+ * The license has expired either by depleting a play count or via an end time.
+ *
+ */
+#define DRM_E_LICENSE_EXPIRED            ((DRM_RESULT)0x8004C009L)
+
+/*
+ * MessageId: DRM_E_RIGHTS_NOT_AVAILABLE
+ *
+ * MessageText:
+ *
+ * The rights the app has requested are not available in the license
+ *
+ */
+#define DRM_E_RIGHTS_NOT_AVAILABLE       ((DRM_RESULT)0x8004C00BL)
+
+/*
+ * MessageId: DRM_E_WRONG_TOKEN_TYPE
+ *
+ * MessageText:
+ *
+ * The token parameter was of an incompatible type.
+ *
+ */
+#define DRM_E_WRONG_TOKEN_TYPE           ((DRM_RESULT)0x8004C00DL)
+
+/*
+ * MessageId: DRM_E_LICENSE_NOT_BOUND
+ *
+ * MessageText:
+ *
+ * A license has not been bound to. Decrypt can not happen without a successful bind call
+ *
+ */
+#define DRM_E_LICENSE_NOT_BOUND          ((DRM_RESULT)0x8004C00FL)
+
+/*
+ * MessageId: DRM_E_HASH_MISMATCH
+ *
+ * MessageText:
+ *
+ * A Keyed Hash check failed.
+ *
+ */
+#define DRM_E_HASH_MISMATCH              ((DRM_RESULT)0x8004C010L)
+
+/*
+ * MessageId: DRM_E_LICENSE_NOT_FOUND
+ *
+ * MessageText:
+ *
+ * A license was not found in the license store.
+ *
+ */
+#define DRM_E_LICENSE_NOT_FOUND          ((DRM_RESULT)0x8004C013L)
+
+/*
+ * MessageId: DRM_E_LICENSE_VERSION_NOT_SUPPORTED
+ *
+ * MessageText:
+ *
+ * The DRM license version is not supported by the DRM version on the device.
+ *
+ */
+#define DRM_E_LICENSE_VERSION_NOT_SUPPORTED ((DRM_RESULT)0x8004C014L)
+
+/*
+ * MessageId: DRM_E_UNSUPPORTED_ALGORITHM
+ *
+ * MessageText:
+ *
+ * The encryption algorithm required for this operation is not supported.
+ *
+ */
+#define DRM_E_UNSUPPORTED_ALGORITHM      ((DRM_RESULT)0x8004C016L)
+
+/*
+ * MessageId: DRM_E_INVALID_LICENSE_STORE
+ *
+ * MessageText:
+ *
+ * The license store version number is incorrect, or the store is invalid in some other way.
+ *
+ */
+#define DRM_E_INVALID_LICENSE_STORE      ((DRM_RESULT)0x8004C019L)
+
+/*
+ * MessageId: DRM_E_FILE_READ_ERROR
+ *
+ * MessageText:
+ *
+ * There was an error reading a file.
+ *
+ */
+#define DRM_E_FILE_READ_ERROR            ((DRM_RESULT)0x8004C01AL)
+
+/*
+ * MessageId: DRM_E_FILE_WRITE_ERROR
+ *
+ * MessageText:
+ *
+ * There was an error writing a file.
+ *
+ */
+#define DRM_E_FILE_WRITE_ERROR           ((DRM_RESULT)0x8004C01BL)
+
+/*
+ * MessageId: DRM_E_DST_STORE_FULL
+ *
+ * MessageText:
+ *
+ * The data store is full.
+ *
+ */
+#define DRM_E_DST_STORE_FULL             ((DRM_RESULT)0x8004C01DL)
+
+/*
+ * MessageId: DRM_E_NO_XML_OPEN_TAG
+ *
+ * MessageText:
+ *
+ * XML open tag not found
+ *
+ */
+#define DRM_E_NO_XML_OPEN_TAG            ((DRM_RESULT)0x8004C01EL)
+
+/*
+ * MessageId: DRM_E_NO_XML_CLOSE_TAG
+ *
+ * MessageText:
+ *
+ * XML close tag not found
+ *
+ */
+#define DRM_E_NO_XML_CLOSE_TAG           ((DRM_RESULT)0x8004C01FL)
+
+/*
+ * MessageId: DRM_E_INVALID_XML_TAG
+ *
+ * MessageText:
+ *
+ * Invalid XML tag
+ *
+ */
+#define DRM_E_INVALID_XML_TAG            ((DRM_RESULT)0x8004C020L)
+
+/*
+ * MessageId: DRM_E_NO_XML_CDATA
+ *
+ * MessageText:
+ *
+ * No XML CDATA found
+ *
+ */
+#define DRM_E_NO_XML_CDATA               ((DRM_RESULT)0x8004C021L)
+
+/*
+ * MessageId: DRM_E_DST_NAMESPACE_NOT_FOUND
+ *
+ * MessageText:
+ *
+ * No DST Namespace found
+ *
+ */
+#define DRM_E_DST_NAMESPACE_NOT_FOUND    ((DRM_RESULT)0x8004C023L)
+
+/*
+ * MessageId: DRM_E_DST_SLOT_NOT_FOUND
+ *
+ * MessageText:
+ *
+ * DST Dataslot not found
+ *
+ */
+#define DRM_E_DST_SLOT_NOT_FOUND         ((DRM_RESULT)0x8004C024L)
+
+/*
+ * MessageId: DRM_E_DST_SLOT_EXISTS
+ *
+ * MessageText:
+ *
+ * DST Dataslot already exists
+ *
+ */
+#define DRM_E_DST_SLOT_EXISTS            ((DRM_RESULT)0x8004C025L)
+
+/*
+ * MessageId: DRM_E_DST_CORRUPTED
+ *
+ * MessageText:
+ *
+ * The data store is corrupted
+ *
+ */
+#define DRM_E_DST_CORRUPTED              ((DRM_RESULT)0x8004C026L)
+
+/*
+ * MessageId: DRM_E_DST_SEEK_ERROR
+ *
+ * MessageText:
+ *
+ * There was an error attempting to seek in the Data Store
+ *
+ */
+#define DRM_E_DST_SEEK_ERROR             ((DRM_RESULT)0x8004C027L)
+
+/*
+ * MessageId: DRM_E_INVALID_SECURESTORE_PASSWORD
+ *
+ * MessageText:
+ *
+ * The password used to open the secure store key was not able to validate the secure store hash.
+ *
+ */
+#define DRM_E_INVALID_SECURESTORE_PASSWORD ((DRM_RESULT)0x8004C029L)
+
+/*
+ * MessageId: DRM_E_SECURESTORE_CORRUPT
+ *
+ * MessageText:
+ *
+ * The secure store is corrupt
+ *
+ */
+#define DRM_E_SECURESTORE_CORRUPT        ((DRM_RESULT)0x8004C02AL)
+
+/*
+ * MessageId: DRM_E_SECURESTORE_FULL
+ *
+ * MessageText:
+ *
+ * The current secure store key is full. No more data can be added.
+ *
+ */
+#define DRM_E_SECURESTORE_FULL           ((DRM_RESULT)0x8004C02BL)
+
+/*
+ * MessageId: DRM_E_DUPLICATED_HEADER_ATTRIBUTE
+ *
+ * MessageText:
+ *
+ * Duplicated attribute in Header
+ *
+ */
+#define DRM_E_DUPLICATED_HEADER_ATTRIBUTE ((DRM_RESULT)0x8004C02DL)
+
+/*
+ * MessageId: DRM_E_NO_KID_IN_HEADER
+ *
+ * MessageText:
+ *
+ * No KID attribute in Header
+ *
+ */
+#define DRM_E_NO_KID_IN_HEADER           ((DRM_RESULT)0x8004C02EL)
+
+/*
+ * MessageId: DRM_E_NO_LAINFO_IN_HEADER
+ *
+ * MessageText:
+ *
+ * No LAINFO attribute in Header
+ *
+ */
+#define DRM_E_NO_LAINFO_IN_HEADER        ((DRM_RESULT)0x8004C02FL)
+
+/*
+ * MessageId: DRM_E_NO_CHECKSUM_IN_HEADER
+ *
+ * MessageText:
+ *
+ * No Checksum attribute in Header
+ *
+ */
+#define DRM_E_NO_CHECKSUM_IN_HEADER      ((DRM_RESULT)0x8004C030L)
+
+/*
+ * MessageId: DRM_E_DST_BLOCK_MISMATCH
+ *
+ * MessageText:
+ *
+ * DST block mismatch
+ *
+ */
+#define DRM_E_DST_BLOCK_MISMATCH         ((DRM_RESULT)0x8004C031L)
+
+/*
+ * MessageId: DRM_E_DST_EXISTS
+ *
+ * MessageText:
+ *
+ * A DST already exists in the specified location
+ *
+ */
+#define DRM_E_DST_EXISTS                 ((DRM_RESULT)0x8004C034L)
+
+/*
+ * MessageId: DRM_E_INVALID_DEVICE_CERTIFICATE
+ *
+ * MessageText:
+ *
+ * The device certificate is invalid.
+ *
+ */
+#define DRM_E_INVALID_DEVICE_CERTIFICATE ((DRM_RESULT)0x8004C035L)
+
+/*
+ * MessageId: DRM_E_DST_LOCK_FAILED
+ *
+ * MessageText:
+ *
+ * Locking a segment of the DST failed.
+ *
+ */
+#define DRM_E_DST_LOCK_FAILED            ((DRM_RESULT)0x8004C036L)
+
+/*
+ * MessageId: DRM_E_FILE_SEEK_ERROR
+ *
+ * MessageText:
+ *
+ * File Seek Error
+ *
+ */
+#define DRM_E_FILE_SEEK_ERROR            ((DRM_RESULT)0x8004C037L)
+
+/*
+ * MessageId: DRM_E_DST_NOT_LOCKED_EXCLUSIVE
+ *
+ * MessageText:
+ *
+ * Existing lock is not exclusive
+ *
+ */
+#define DRM_E_DST_NOT_LOCKED_EXCLUSIVE   ((DRM_RESULT)0x8004C038L)
+
+/*
+ * MessageId: DRM_E_DST_EXCLUSIVE_LOCK_ONLY
+ *
+ * MessageText:
+ *
+ * Only exclusive lock is accepted
+ *
+ */
+#define DRM_E_DST_EXCLUSIVE_LOCK_ONLY    ((DRM_RESULT)0x8004C039L)
+
+/*
+ * MessageId: DRM_E_HEADER_NOT_SET
+ *
+ * MessageText:
+ *
+ * Content header is not set
+ *
+ */
+#define DRM_E_HEADER_NOT_SET             ((DRM_RESULT)0x8004C03CL)
+
+/*
+ * MessageId: DRM_E_MACHINE_ID_MISMATCH
+ *
+ * MessageText:
+ *
+ * The device has Machine Id different from that in devcert.
+ *
+ */
+#define DRM_E_MACHINE_ID_MISMATCH        ((DRM_RESULT)0x8004C03EL)
+
+/*
+ * MessageId: DRM_E_CLK_INVALID_RESPONSE
+ *
+ * MessageText:
+ *
+ * The secure clock response is invalid.
+ *
+ */
+#define DRM_E_CLK_INVALID_RESPONSE       ((DRM_RESULT)0x8004C03FL)
+
+/*
+ * MessageId: DRM_E_DEVCERT_EXCEEDS_SIZE_LIMIT
+ *
+ * MessageText:
+ *
+ * The device certificate exceeds max size
+ *
+ */
+#define DRM_E_DEVCERT_EXCEEDS_SIZE_LIMIT ((DRM_RESULT)0x8004C043L)
+
+/*
+ * MessageId: DRM_E_PRIVKEY_READ_ERROR
+ *
+ * MessageText:
+ *
+ * Can't get device private key
+ *
+ */
+#define DRM_E_PRIVKEY_READ_ERROR         ((DRM_RESULT)0x8004C047L)
+
+/*
+ * MessageId: DRM_E_DEVCERT_TEMPLATE_READ_ERROR
+ *
+ * MessageText:
+ *
+ * Can't get the device certificate template
+ *
+ */
+#define DRM_E_DEVCERT_TEMPLATE_READ_ERROR ((DRM_RESULT)0x8004C049L)
+
+/*
+ * MessageId: DRM_E_CLK_NOT_SUPPORTED
+ *
+ * MessageText:
+ *
+ * The secure clock is not supported.
+ *
+ */
+#define DRM_E_CLK_NOT_SUPPORTED          ((DRM_RESULT)0x8004C04AL)
+
+/*
+ * MessageId: DRM_E_METERING_NOT_SUPPORTED
+ *
+ * MessageText:
+ *
+ * The Metering is not supported.
+ *
+ */
+#define DRM_E_METERING_NOT_SUPPORTED     ((DRM_RESULT)0x8004C04CL)
+
+/*
+ * MessageId: DRM_E_XMLNOTFOUND
+ *
+ * MessageText:
+ *
+ * a required XML tag was not found
+ *
+ */
+#define DRM_E_XMLNOTFOUND                ((DRM_RESULT)0x8004C04FL)
+
+/*
+ * MessageId: DRM_E_METERING_WRONG_TID
+ *
+ * MessageText:
+ *
+ * wrong TID sent on metering response
+ *
+ */
+#define DRM_E_METERING_WRONG_TID         ((DRM_RESULT)0x8004C050L)
+
+/*
+ * MessageId: DRM_E_METERING_STORE_CORRUPT
+ *
+ * MessageText:
+ *
+ * The metering store is corrupt
+ *
+ */
+#define DRM_E_METERING_STORE_CORRUPT     ((DRM_RESULT)0x8004C052L)
+
+/*
+ * MessageId: DRM_E_CERTIFICATE_REVOKED
+ *
+ * MessageText:
+ *
+ * A certificate given to DRM was revoked.
+ *
+ */
+#define DRM_E_CERTIFICATE_REVOKED        ((DRM_RESULT)0x8004C053L)
+
+/*
+ * MessageId: DRM_E_CRYPTO_FAILED
+ *
+ * MessageText:
+ *
+ * A cryptographic operation failed.
+ *
+ */
+#define DRM_E_CRYPTO_FAILED              ((DRM_RESULT)0x8004C054L)
+
+/*
+ * MessageId: DRM_E_STACK_CORRUPT
+ *
+ * MessageText:
+ *
+ * The stack allocator context is corrupt. Likely a buffer overrun problem.
+ *
+ */
+#define DRM_E_STACK_CORRUPT              ((DRM_RESULT)0x8004C055L)
+
+/*
+ * MessageId: DRM_E_V1_LICENSE_CHAIN_NOT_SUPPORTED
+ *
+ * MessageText:
+ *
+ * License chaining with V1 content is not supported.
+ *
+ */
+#define DRM_E_V1_LICENSE_CHAIN_NOT_SUPPORTED ((DRM_RESULT)0x8004C057L)
+
+/*
+ * MessageId: DRM_E_CLK_NOT_SET
+ *
+ * MessageText:
+ *
+ * Time based licenses can not be used because the secure clock is not set on the device.
+ *
+ */
+#define DRM_E_CLK_NOT_SET                ((DRM_RESULT)0x8004C05BL)
+
+/*
+ * MessageId: DRM_E_NO_CLK_SUPPORTED
+ *
+ * MessageText:
+ *
+ * Time based licenses can not be used because the device does not support any clock.
+ *
+ */
+#define DRM_E_NO_CLK_SUPPORTED           ((DRM_RESULT)0x8004C05CL)
+
+/*
+ * MessageId: DRM_E_NO_URL
+ *
+ * MessageText:
+ *
+ * Can not find URL info.
+ *
+ */
+#define DRM_E_NO_URL                     ((DRM_RESULT)0x8004C05DL)
+
+/*
+ * MessageId: DRM_E_UNKNOWN_DEVICE_PROPERTY
+ *
+ * MessageText:
+ *
+ * Unknown device property.
+ *
+ */
+#define DRM_E_UNKNOWN_DEVICE_PROPERTY    ((DRM_RESULT)0x8004C05EL)
+
+/*
+ * MessageId: DRM_E_RIV_TOO_SMALL
+ *
+ * MessageText:
+ *
+ * RIV on the machine is too small.
+ *
+ */
+#define DRM_E_RIV_TOO_SMALL              ((DRM_RESULT)0x8004C063L)
+
+/*
+ * MessageId: DRM_E_STACK_ALREADY_INITIALIZED
+ *
+ * MessageText:
+ *
+ * DRM_STK_Init called for initialized stack
+ *
+ */
+#define DRM_E_STACK_ALREADY_INITIALIZED  ((DRM_RESULT)0x8004C064L)
+
+/*
+ * MessageId: DRM_E_DEVCERT_REVOKED
+ *
+ * MessageText:
+ *
+ * The device certificate given to DRM is revoked.
+ *
+ */
+#define DRM_E_DEVCERT_REVOKED            ((DRM_RESULT)0x8004C065L)
+
+/*
+ * MessageId: DRM_E_OEM_RSA_DECRYPTION_ERROR
+ *
+ * MessageText:
+ *
+ * Error in OEM RSA Decryption.
+ *
+ */
+#define DRM_E_OEM_RSA_DECRYPTION_ERROR   ((DRM_RESULT)0x8004C066L)
+
+/*
+ * MessageId: DRM_E_OEM_RSA_ENCRYPTION_ERROR
+ *
+ * MessageText:
+ *
+ * Error in OEM RSA Encryption process
+ *
+ */
+#define DRM_E_OEM_RSA_ENCRYPTION_ERROR   ((DRM_RESULT)0x8004C069L)
+
+/*
+ * MessageId: DRM_E_DST_NAMESPACE_EXISTS
+ *
+ * MessageText:
+ *
+ * The DST Namespace already exists.
+ *
+ */
+#define DRM_E_DST_NAMESPACE_EXISTS       ((DRM_RESULT)0x8004C06AL)
+
+/*
+ * MessageId: DRM_E_PERF_SCOPING_ERROR
+ *
+ * MessageText:
+ *
+ * Error in performance scope context
+ *
+ */
+#define DRM_E_PERF_SCOPING_ERROR         ((DRM_RESULT)0x8004C06BL)
+
+/*
+ * MessageId: DRM_E_OEM_RSA_INVALID_PRIVATE_KEY
+ *
+ * MessageText:
+ *
+ * Invalid private key.
+ *
+ */
+#define DRM_E_OEM_RSA_INVALID_PRIVATE_KEY ((DRM_RESULT)0x8004C06DL)
+
+/*
+ * MessageId: DRM_E_NO_OPL_CALLBACK
+ *
+ * MessageText:
+ *
+ * There is no callback function to process the output restrictions specified in the license
+ *
+ */
+#define DRM_E_NO_OPL_CALLBACK            ((DRM_RESULT)0x8004C06EL)
+
+/*
+ * MessageId: DRM_E_INVALID_PLAYREADY_OBJECT
+ *
+ * MessageText:
+ *
+ * Structure of PlayReady object is invalid
+ *
+ */
+#define DRM_E_INVALID_PLAYREADY_OBJECT   ((DRM_RESULT)0x8004C06FL)
+
+/*
+ * MessageId: DRM_E_DUPLICATE_LICENSE
+ *
+ * MessageText:
+ *
+ * There is already a license in the store with the same KID & LID
+ *
+ */
+#define DRM_E_DUPLICATE_LICENSE          ((DRM_RESULT)0x8004C070L)
+
+/*
+ * MessageId: DRM_E_RECORD_NOT_FOUND
+ *
+ * MessageText:
+ *
+ * Record with requested type was not found in PlayReady object.
+ *
+ */
+#define DRM_E_RECORD_NOT_FOUND           ((DRM_RESULT)0x8004C072L)
+
+/*
+ * MessageId: DRM_E_BUFFER_BOUNDS_EXCEEDED
+ *
+ * MessageText:
+ *
+ * An array is being referenced outside of it's bounds.
+ *
+ */
+#define DRM_E_BUFFER_BOUNDS_EXCEEDED     ((DRM_RESULT)0x8004C073L)
+
+/*
+ * MessageId: DRM_E_INVALID_BASE64
+ *
+ * MessageText:
+ *
+ * An input string contains invalid Base64 characters.
+ *
+ */
+#define DRM_E_INVALID_BASE64             ((DRM_RESULT)0x8004C074L)
+
+/*
+ * MessageId: DRM_E_PROTOCOL_VERSION_NOT_SUPPORTED
+ *
+ * MessageText:
+ *
+ * The protocol version is not supported.
+ *
+ */
+#define DRM_E_PROTOCOL_VERSION_NOT_SUPPORTED ((DRM_RESULT)0x8004C075L)
+
+/*
+ * MessageId: DRM_E_INVALID_LICENSE_RESPONSE_SIGNATURE
+ *
+ * MessageText:
+ *
+ * Cannot verify license acquisition's response because signature is invalid.
+ *
+ */
+#define DRM_E_INVALID_LICENSE_RESPONSE_SIGNATURE ((DRM_RESULT)0x8004C076L)
+
+/*
+ * MessageId: DRM_E_INVALID_LICENSE_RESPONSE_ID
+ *
+ * MessageText:
+ *
+ * Cannot verify license acquisition's response because response ID is invalid.
+ *
+ */
+#define DRM_E_INVALID_LICENSE_RESPONSE_ID ((DRM_RESULT)0x8004C077L)
+
+/*
+ * MessageId: DRM_E_LICENSE_RESPONSE_SIGNATURE_MISSING
+ *
+ * MessageText:
+ *
+ * Cannot verify license acquisition's response because either response ID, license nonce or signature is missing.
+ *
+ */
+#define DRM_E_LICENSE_RESPONSE_SIGNATURE_MISSING ((DRM_RESULT)0x8004C078L)
+
+/*
+ * MessageId: DRM_E_INVALID_DOMAIN_JOIN_RESPONSE_SIGNATURE
+ *
+ * MessageText:
+ *
+ * Cannot verify domain join response because signature is invalid.
+ *
+ */
+#define DRM_E_INVALID_DOMAIN_JOIN_RESPONSE_SIGNATURE ((DRM_RESULT)0x8004C079L)
+
+/*
+ * MessageId: DRM_E_DOMAIN_JOIN_RESPONSE_SIGNATURE_MISSING
+ *
+ * MessageText:
+ *
+ * Cannot verify domain join response because either signing certificate chain or signature is missing.
+ *
+ */
+#define DRM_E_DOMAIN_JOIN_RESPONSE_SIGNATURE_MISSING ((DRM_RESULT)0x8004C07AL)
+
+/*
+ * MessageId: DRM_E_ACTIVATION_REQUIRED
+ *
+ * MessageText:
+ *
+ * The device must be activated before initialization can succeed.
+ *
+ */
+#define DRM_E_ACTIVATION_REQUIRED        ((DRM_RESULT)0x8004C07BL)
+
+/*
+ * MessageId: DRM_E_ACTIVATION_INTERNAL_ERROR
+ *
+ * MessageText:
+ *
+ * A server error occurred during device activation.
+ *
+ */
+#define DRM_E_ACTIVATION_INTERNAL_ERROR  ((DRM_RESULT)0x8004C07CL)
+
+/*
+ * MessageId: DRM_E_ACTIVATION_GROUP_CERT_REVOKED_ERROR
+ *
+ * MessageText:
+ *
+ * The activation group cert has been revoked and the application must be updated with a new client lib.
+ *
+ */
+#define DRM_E_ACTIVATION_GROUP_CERT_REVOKED_ERROR ((DRM_RESULT)0x8004C07DL)
+
+/*
+ * MessageId: DRM_E_ACTIVATION_NEW_CLIENT_LIB_REQUIRED_ERROR
+ *
+ * MessageText:
+ *
+ * The client lib used by the application is not supported and must be updated.
+ *
+ */
+#define DRM_E_ACTIVATION_NEW_CLIENT_LIB_REQUIRED_ERROR ((DRM_RESULT)0x8004C07EL)
+
+/*
+ * MessageId: DRM_E_ACTIVATION_BAD_REQUEST
+ *
+ * MessageText:
+ *
+ * The activation request is invalid
+ *
+ */
+#define DRM_E_ACTIVATION_BAD_REQUEST     ((DRM_RESULT)0x8004C07FL)
+
+/*
+ * MessageId: DRM_E_FILEIO_ERROR
+ *
+ * MessageText:
+ *
+ * Encountered a system error during file I/O.
+ *
+ */
+#define DRM_E_FILEIO_ERROR               ((DRM_RESULT)0x8004C080L)
+
+/*
+ * MessageId: DRM_E_UPLINK_LICENSE_NOT_FOUND
+ *
+ * MessageText:
+ *
+ * A license was found in the license store but no license was found for its uplink ID.
+ *
+ */
+#define DRM_E_UPLINK_LICENSE_NOT_FOUND   ((DRM_RESULT)0x8004C082L)
+
+/*
+ * MessageId: DRM_E_ACTIVATION_CLIENT_ALREADY_CURRENT
+ *
+ * MessageText:
+ *
+ * The activation client already has the lastest verion.
+ *
+ */
+#define DRM_E_ACTIVATION_CLIENT_ALREADY_CURRENT ((DRM_RESULT)0x8004C083L)
+
+/*
+ * MessageId: DRM_E_LICENSE_REALTIME_EXPIRED
+ *
+ * MessageText:
+ *
+ * The license has expired during decryption due to the RealTimeExpiration Restriction.
+ *
+ */
+#define DRM_E_LICENSE_REALTIME_EXPIRED   ((DRM_RESULT)0x8004C084L)
+
+/*
+ * MessageId: DRM_E_DECRYPTOR_CANNOT_CLONE
+ *
+ * MessageText:
+ *
+ * The decryptor cannot be cloned due to restrictions in the corresponding license.
+ *
+ */
+#define DRM_E_DECRYPTOR_CANNOT_CLONE     ((DRM_RESULT)0x8004C085L)
+
+/*
+ * MessageId: DRM_E_ACTIVATION_REQUIRED_REACTIVATION_POSSIBLE
+ *
+ * MessageText:
+ *
+ * The device must be activated or reactivated before initialization can succeed.
+ *
+ */
+#define DRM_E_ACTIVATION_REQUIRED_REACTIVATION_POSSIBLE ((DRM_RESULT)0x8004C086L)
+
+
+/* ------------------------------------------------------------
+**
+** License evaluator errors: error codes from DRM_E_BASECODE+0xC0 to
+** DRM_E_BASECODE+0xDF, 0x8004c0c0-0x8004c0df.
+**
+** ------------------------------------------------------------
+*/
+
+#define DRM_E_LICEVAL_BASECODE                  DRM_E_BASECODE+0xC0
+
+/*
+ * MessageId: DRM_E_LICEVAL_LICENSE_NOT_SUPPLIED
+ *
+ * MessageText:
+ *
+ * License not supplied in the liceval context
+ *
+ */
+#define DRM_E_LICEVAL_LICENSE_NOT_SUPPLIED ((DRM_RESULT)0x8004C0C0L)
+
+/*
+ * MessageId: DRM_E_LICEVAL_KID_MISMATCH
+ *
+ * MessageText:
+ *
+ * Mismatch between KID from header and the one inside license
+ *
+ */
+#define DRM_E_LICEVAL_KID_MISMATCH       ((DRM_RESULT)0x8004C0C1L)
+
+/*
+ * MessageId: DRM_E_LICEVAL_REQUIRED_REVOCATION_LIST_NOT_AVAILABLE
+ *
+ * MessageText:
+ *
+ * Failed to update content revocation
+ *
+ */
+#define DRM_E_LICEVAL_REQUIRED_REVOCATION_LIST_NOT_AVAILABLE ((DRM_RESULT)0x8004C0C4L)
+
+
+/* ------------------------------------------------------------
+**
+** XMR parser and builder errors: error codes from DRM_E_BASECODE+0xE0 to
+** DRM_E_BASECODE+0xFF, 0x8004c0e0-0x8004c0ff.
+**
+** ------------------------------------------------------------
+*/
+
+#define DRM_E_XMR_BASECODE                      DRM_E_BASECODE+0xE0
+
+/*
+ * MessageId: DRM_E_XMR_REQUIRED_OBJECT_MISSING
+ *
+ * MessageText:
+ *
+ * XMR license doesn't have one or more required objects.
+ *
+ */
+#define DRM_E_XMR_REQUIRED_OBJECT_MISSING ((DRM_RESULT)0x8004C0E2L)
+
+/*
+ * MessageId: DRM_E_XMR_LICENSE_NOT_BINDABLE
+ *
+ * MessageText:
+ *
+ * XMR license cannot be bound to because of the Cannot Bind right
+ *
+ */
+#define DRM_E_XMR_LICENSE_NOT_BINDABLE   ((DRM_RESULT)0x8004C0E5L)
+
+
+/* ------------------------------------------------------------
+**
+** Device certificate errors: error codes from DRM_E_BASECODE+0x200 to
+** DRM_E_BASECODE+0x2FF, 0x8004c200-0x8004c2ff.
+**
+** ------------------------------------------------------------
+*/
+
+#define DRM_E_CERT_BASECODE                  DRM_E_BASECODE+0x200
+
+/*
+ * MessageId: DRM_E_INVALID_DEVCERT_ATTRIBUTE
+ *
+ * MessageText:
+ *
+ * The attributes in the Device certificate are invalid
+ *
+ */
+#define DRM_E_INVALID_DEVCERT_ATTRIBUTE  ((DRM_RESULT)0x8004C200L)
+
+
+/* ------------------------------------------------------------
+**
+** Test errors: error codes from DRM_E_BASECODE+0x300 to
+** DRM_E_BASECODE+0x3E7, 0x8004c300-0x8004c3e7.
+**
+** ------------------------------------------------------------
+*/
+
+#define DRM_E_TEST_BASECODE        DRM_E_BASECODE+0x300
+#define DRM_S_TEST_BASECODE        DRM_S_BASECODE+0x300
+
+/*
+ * MessageId: DRM_S_TEST_SKIP_FILE
+ *
+ * MessageText:
+ *
+ * Skip processing this file, not an eror.
+ *
+ */
+#define DRM_S_TEST_SKIP_FILE             ((DRM_RESULT)0x0004C300L)
+
+/*
+ * MessageId: DRM_S_TEST_CONVERTED_FILE
+ *
+ * MessageText:
+ *
+ * The file was converted to a PlayReady file during the action.
+ *
+ */
+#define DRM_S_TEST_CONVERTED_FILE        ((DRM_RESULT)0x0004C301L)
+
+/*
+ * MessageId: DRM_E_TEST_ENCRYPT_ERROR
+ *
+ * MessageText:
+ *
+ * Error in encryption of cipher text.
+ *
+ */
+#define DRM_E_TEST_ENCRYPT_ERROR         ((DRM_RESULT)0x8004C302L)
+
+/*
+ * MessageId: DRM_E_TEST_RC4KEY_FAILED
+ *
+ * MessageText:
+ *
+ * RC4 key failed during crypto operations.
+ *
+ */
+#define DRM_E_TEST_RC4KEY_FAILED         ((DRM_RESULT)0x8004C303L)
+
+/*
+ * MessageId: DRM_E_TEST_DECRYPT_ERROR
+ *
+ * MessageText:
+ *
+ * Error in cipher text decryption.
+ *
+ */
+#define DRM_E_TEST_DECRYPT_ERROR         ((DRM_RESULT)0x8004C304L)
+
+/*
+ * MessageId: DRM_E_TEST_HMAC_FAILURE
+ *
+ * MessageText:
+ *
+ * Error in hashed data in HMAC operation.
+ *
+ */
+#define DRM_E_TEST_HMAC_FAILURE          ((DRM_RESULT)0x8004C307L)
+
+/*
+ * MessageId: DRM_E_TEST_INVALIDARG
+ *
+ * MessageText:
+ *
+ * Error in the number of arguments or argument data in Test files.
+ *
+ */
+#define DRM_E_TEST_INVALIDARG            ((DRM_RESULT)0x8004C308L)
+
+/*
+ * MessageId: DRM_E_TEST_UNEXPECTED_REVINFO_RESULT
+ *
+ * MessageText:
+ *
+ * Revocation cache result was not as expected.
+ *
+ */
+#define DRM_E_TEST_UNEXPECTED_REVINFO_RESULT ((DRM_RESULT)0x8004C30CL)
+
+/*
+ * MessageId: DRM_E_TEST_RIV_MISMATCH
+ *
+ * MessageText:
+ *
+ * Revocation Info Version(RIV) mismatch.
+ *
+ */
+#define DRM_E_TEST_RIV_MISMATCH          ((DRM_RESULT)0x8004C30DL)
+
+/*
+ * MessageId: DRM_E_TEST_URL_ERROR
+ *
+ * MessageText:
+ *
+ * There is an error in the URL from the challenge generated.
+ *
+ */
+#define DRM_E_TEST_URL_ERROR             ((DRM_RESULT)0x8004C310L)
+
+/*
+ * MessageId: DRM_E_TEST_MID_MISMATCH
+ *
+ * MessageText:
+ *
+ * The MIDs returned from the DRM_MANAGER_CONTEXT does not match the test input.
+ *
+ */
+#define DRM_E_TEST_MID_MISMATCH          ((DRM_RESULT)0x8004C311L)
+
+/*
+ * MessageId: DRM_E_TEST_METER_CERTIFICATE_MISMATCH
+ *
+ * MessageText:
+ *
+ * The input data does not match with the Metering certificate returned from the license.
+ *
+ */
+#define DRM_E_TEST_METER_CERTIFICATE_MISMATCH ((DRM_RESULT)0x8004C312L)
+
+/*
+ * MessageId: DRM_E_TEST_SOURCE_ID_MISMATCH
+ *
+ * MessageText:
+ *
+ * The input data and license state returned from the license do not match.
+ *
+ */
+#define DRM_E_TEST_SOURCE_ID_MISMATCH    ((DRM_RESULT)0x8004C316L)
+
+/*
+ * MessageId: DRM_E_TEST_UNEXPECTED_LICENSE_COUNT
+ *
+ * MessageText:
+ *
+ * The input data and the number of license from the KID do not match.
+ *
+ */
+#define DRM_E_TEST_UNEXPECTED_LICENSE_COUNT ((DRM_RESULT)0x8004C317L)
+
+/*
+ * MessageId: DRM_E_TEST_UNEXPECTED_DEVICE_PROPERTY
+ *
+ * MessageText:
+ *
+ * Unknown device property.
+ *
+ */
+#define DRM_E_TEST_UNEXPECTED_DEVICE_PROPERTY ((DRM_RESULT)0x8004C318L)
+
+/*
+ * MessageId: DRM_E_TEST_DRMMANAGER_MISALIGNED_BYTES
+ *
+ * MessageText:
+ *
+ * Error due to misalignment of bytes.
+ *
+ */
+#define DRM_E_TEST_DRMMANAGER_MISALIGNED_BYTES ((DRM_RESULT)0x8004C319L)
+
+/*
+ * MessageId: DRM_E_TEST_OPL_MISMATCH
+ *
+ * MessageText:
+ *
+ * The minimum levels of the compressed/uncompressed Digital and Analog Video do not match the OPL.
+ *
+ */
+#define DRM_E_TEST_OPL_MISMATCH          ((DRM_RESULT)0x8004C31BL)
+
+/*
+ * MessageId: DRM_E_TEST_INVALID_OPL_CALLBACK
+ *
+ * MessageText:
+ *
+ * The callback type supplied is not valid.
+ *
+ */
+#define DRM_E_TEST_INVALID_OPL_CALLBACK  ((DRM_RESULT)0x8004C31CL)
+
+/*
+ * MessageId: DRM_E_TEST_INCOMPLETE
+ *
+ * MessageText:
+ *
+ * The test function failed to complete.
+ *
+ */
+#define DRM_E_TEST_INCOMPLETE            ((DRM_RESULT)0x8004C31DL)
+
+/*
+ * MessageId: DRM_E_TEST_UNEXPECTED_OUTPUT
+ *
+ * MessageText:
+ *
+ * The output of the function being tested does not match the expected output.
+ *
+ */
+#define DRM_E_TEST_UNEXPECTED_OUTPUT     ((DRM_RESULT)0x8004C31EL)
+
+/*
+ * MessageId: DRM_E_TEST_TOO_SLOW
+ *
+ * MessageText:
+ *
+ * The performance test failed because DRM took longer than its maximum time.
+ *
+ */
+#define DRM_E_TEST_TOO_SLOW              ((DRM_RESULT)0x8004C322L)
+
+/*
+ * MessageId: DRM_E_TEST_LICENSESTORE_NOT_OPEN
+ *
+ * MessageText:
+ *
+ * The License Store contexts in the App Manager context are not open.
+ *
+ */
+#define DRM_E_TEST_LICENSESTORE_NOT_OPEN ((DRM_RESULT)0x8004C323L)
+
+/*
+ * MessageId: DRM_E_TEST_VARIABLE_NOT_SET
+ *
+ * MessageText:
+ *
+ * A global variable needed for test execution has not been set correctly.
+ *
+ */
+#define DRM_E_TEST_VARIABLE_NOT_SET      ((DRM_RESULT)0x8004C325L)
+
+/*
+ * MessageId: DRM_E_TEST_NOMORE
+ *
+ * MessageText:
+ *
+ * The same as DRM_E_NOMORE, only explicitly used in test code.
+ *
+ */
+#define DRM_E_TEST_NOMORE                ((DRM_RESULT)0x8004C326L)
+
+/*
+ * MessageId: DRM_E_TEST_FILE_LOAD_ERROR
+ *
+ * MessageText:
+ *
+ * There was an error loading a test data file.
+ *
+ */
+#define DRM_E_TEST_FILE_LOAD_ERROR       ((DRM_RESULT)0x8004C327L)
+
+/*
+ * MessageId: DRM_E_TEST_UNSUPPORTED_FILE_FORMAT
+ *
+ * MessageText:
+ *
+ * A file format is being used which is not supported by the test function.
+ *
+ */
+#define DRM_E_TEST_UNSUPPORTED_FILE_FORMAT ((DRM_RESULT)0x8004C329L)
+
+/*
+ * MessageId: DRM_E_TEST_PARSING_ERROR
+ *
+ * MessageText:
+ *
+ * There was an error parsing input parameter.
+ *
+ */
+#define DRM_E_TEST_PARSING_ERROR         ((DRM_RESULT)0x8004C32AL)
+
+/*
+ * MessageId: DRM_E_TEST_NOTIMPL
+ *
+ * MessageText:
+ *
+ * The specified test API is not implemented.
+ *
+ */
+#define DRM_E_TEST_NOTIMPL               ((DRM_RESULT)0x8004C32BL)
+
+/*
+ * MessageId: DRM_E_TEST_VARIABLE_NOTFOUND
+ *
+ * MessageText:
+ *
+ * The specified test varaible was not found in the shared variable table.
+ *
+ */
+#define DRM_E_TEST_VARIABLE_NOTFOUND     ((DRM_RESULT)0x8004C32CL)
+
+/*
+ * MessageId: DRM_E_TEST_VARIABLE_LISTFULL
+ *
+ * MessageText:
+ *
+ * The shared test variable table is full.
+ *
+ */
+#define DRM_E_TEST_VARIABLE_LISTFULL     ((DRM_RESULT)0x8004C32DL)
+
+/*
+ * MessageId: DRM_E_TEST_UNEXPECTED_CONTENT_PROPERTY
+ *
+ * MessageText:
+ *
+ * Unknown content property.
+ *
+ */
+#define DRM_E_TEST_UNEXPECTED_CONTENT_PROPERTY ((DRM_RESULT)0x8004C32EL)
+
+/*
+ * MessageId: DRM_E_TEST_PRO_HEADER_NOT_SET
+ *
+ * MessageText:
+ *
+ * PlayReady Object Header not set.
+ *
+ */
+#define DRM_E_TEST_PRO_HEADER_NOT_SET    ((DRM_RESULT)0x8004C32FL)
+
+/*
+ * MessageId: DRM_E_TEST_NON_PRO_HEADER_TYPE
+ *
+ * MessageText:
+ *
+ * Incompatible header - PlayReady Object Header expected.
+ *
+ */
+#define DRM_E_TEST_NON_PRO_HEADER_TYPE   ((DRM_RESULT)0x8004C330L)
+
+/*
+ * MessageId: DRM_E_TEST_INVALID_FILE
+ *
+ * MessageText:
+ *
+ * The data file given was invalid.
+ *
+ */
+#define DRM_E_TEST_INVALID_FILE          ((DRM_RESULT)0x8004C334L)
+
+/*
+ * MessageId: DRM_E_TEST_METERING_DATA_INCORRECT
+ *
+ * MessageText:
+ *
+ * The metering data reported is incorrect.
+ *
+ */
+#define DRM_E_TEST_METERING_DATA_INCORRECT ((DRM_RESULT)0x8004C336L)
+
+/*
+ * MessageId: DRM_E_TEST_FILE_NOT_OPEN
+ *
+ * MessageText:
+ *
+ * The handle variable for a test file is NULL. This indicates that a file was not opened.
+ *
+ */
+#define DRM_E_TEST_FILE_NOT_OPEN         ((DRM_RESULT)0x8004C338L)
+
+/*
+ * MessageId: DRM_E_TEST_TUX_TEST_SKIPPED
+ *
+ * MessageText:
+ *
+ * TUX cannot find the speficied test case in target dll. Test Skipped.
+ *
+ */
+#define DRM_E_TEST_TUX_TEST_SKIPPED      ((DRM_RESULT)0x8004C33BL)
+
+/*
+ * MessageId: DRM_E_TEST_KEYFILE_VERIFICATION_FAILURE
+ *
+ * MessageText:
+ *
+ * Verification of the Keyfile context failed.
+ *
+ */
+#define DRM_E_TEST_KEYFILE_VERIFICATION_FAILURE ((DRM_RESULT)0x8004C33CL)
+
+/*
+ * MessageId: DRM_E_TEST_DATA_VERIFICATION_FAILURE
+ *
+ * MessageText:
+ *
+ * Data does not match expected value and failed verification.
+ *
+ */
+#define DRM_E_TEST_DATA_VERIFICATION_FAILURE ((DRM_RESULT)0x8004C33DL)
+
+/*
+ * MessageId: DRM_E_TEST_NET_FAIL
+ *
+ * MessageText:
+ *
+ * The Test failed to perform Network I/O.
+ *
+ */
+#define DRM_E_TEST_NET_FAIL              ((DRM_RESULT)0x8004C33EL)
+
+/*
+ * MessageId: DRM_E_TEST_CLEANUP_FAIL
+ *
+ * MessageText:
+ *
+ * A failure occurred during the test case cleanup phase.
+ *
+ */
+#define DRM_E_TEST_CLEANUP_FAIL          ((DRM_RESULT)0x8004C33FL)
+
+/*
+ * MessageId: DRM_E_TEST_LICGEN_UNSUPPORTED_VALUE
+ *
+ * MessageText:
+ *
+ * A property used during license generation is not supported.
+ *
+ */
+#define DRM_E_TEST_LICGEN_UNSUPPORTED_VALUE ((DRM_RESULT)0x8004C340L)
+
+
+/* ------------------------------------------------------------
+**
+** Errors of the range 0x8004c3e8-0x8004c3f8 (range is where
+** *decimal* +1000 starts.
+**
+** ------------------------------------------------------------
+*/
+
+/*
+ * MessageId: DRM_E_LOGICERR
+ *
+ * MessageText:
+ *
+ * DRM code has a logic error in it.  This result should never be returned.  There is an unhandled code path if it is returned.
+ *
+ */
+#define DRM_E_LOGICERR                   ((DRM_RESULT)0x8004C3E8L)
+
+/*
+ * MessageId: DRM_E_INVALID_REV_INFO
+ *
+ * MessageText:
+ *
+ * The rev info blob is invalid.
+ *
+ */
+#define DRM_E_INVALID_REV_INFO           ((DRM_RESULT)0x8004C3E9L)
+
+/*
+ * MessageId: DRM_E_REVOCATION_BUFFER_TOO_SMALL
+ *
+ * MessageText:
+ *
+ * The revocation buffer is too small.
+ *
+ */
+#define DRM_E_REVOCATION_BUFFER_TOO_SMALL ((DRM_RESULT)0x8004C3EBL)
+
+/*
+ * MessageId: DRM_E_DST_NOT_COMPATIBLE
+ *
+ * MessageText:
+ *
+ * The data store version is incompatible with this version of DRM.
+ *
+ */
+#define DRM_E_DST_NOT_COMPATIBLE         ((DRM_RESULT)0x8004C3EDL)
+
+/*
+ * MessageId: DRM_E_RSA_DECRYPTION_ERROR
+ *
+ * MessageText:
+ *
+ * The data block/Encoded message used in OAEP decoding is incorrect.
+ *
+ */
+#define DRM_E_RSA_DECRYPTION_ERROR       ((DRM_RESULT)0x8004C3F0L)
+
+/*
+ * MessageId: DRM_E_OEM_RSA_MESSAGE_TOO_BIG
+ *
+ * MessageText:
+ *
+ * The base message buffer is larger than the given modulus.
+ *
+ */
+#define DRM_E_OEM_RSA_MESSAGE_TOO_BIG    ((DRM_RESULT)0x8004C3F1L)
+
+/*
+ * MessageId: DRM_E_METERCERT_NOT_FOUND
+ *
+ * MessageText:
+ *
+ * The metering certificate was not found in the store.
+ *
+ */
+#define DRM_E_METERCERT_NOT_FOUND        ((DRM_RESULT)0x8004C3F2L)
+
+/*
+ * MessageId: DRM_E_MODULAR_ARITHMETIC_FAILURE
+ *
+ * MessageText:
+ *
+ * A failure occurred in bignum modular arithmetic.
+ *
+ */
+#define DRM_E_MODULAR_ARITHMETIC_FAILURE ((DRM_RESULT)0x8004C3F3L)
+
+/*
+ * MessageId: DRM_E_REVOCATION_INVALID_PACKAGE
+ *
+ * MessageText:
+ *
+ * The revocation package is invalid
+ *
+ */
+#define DRM_E_REVOCATION_INVALID_PACKAGE ((DRM_RESULT)0x8004C3F5L)
+
+/*
+ * MessageId: DRM_E_VAR_NOT_INITIALIZED
+ *
+ * MessageText:
+ *
+ * Variable was not initialized.
+ *
+ */
+#define DRM_E_VAR_NOT_INITIALIZED        ((DRM_RESULT)0x8004C3F7L)
+
+
+/* ------------------------------------------------------------
+**
+** Domain errors: error codes from DRM_E_BASECODE+0x500 to
+** DRM_E_BASECODE+0x57F, 0x8004c500-0x8004c57f.
+**
+** ------------------------------------------------------------
+*/
+
+#define DRM_E_DOMAIN_BASECODE       DRM_E_BASECODE + 0x500
+
+/*
+ * MessageId: DRM_E_DOMAIN_INVALID_GUID
+ *
+ * MessageText:
+ *
+ * Not a correct GUID.
+ *
+ */
+#define DRM_E_DOMAIN_INVALID_GUID        ((DRM_RESULT)0x8004C500L)
+
+/*
+ * MessageId: DRM_E_DOMAIN_INVALID_CUSTOM_DATA_TYPE
+ *
+ * MessageText:
+ *
+ * Not a valid custom data type.
+ *
+ */
+#define DRM_E_DOMAIN_INVALID_CUSTOM_DATA_TYPE ((DRM_RESULT)0x8004C501L)
+
+/*
+ * MessageId: DRM_E_DOMAIN_STORE_ADD_DATA
+ *
+ * MessageText:
+ *
+ * Failed to add data into the domain store.
+ *
+ */
+#define DRM_E_DOMAIN_STORE_ADD_DATA      ((DRM_RESULT)0x8004C502L)
+
+/*
+ * MessageId: DRM_E_DOMAIN_STORE_GET_DATA
+ *
+ * MessageText:
+ *
+ * Failed to retrieve data from the domain store.
+ *
+ */
+#define DRM_E_DOMAIN_STORE_GET_DATA      ((DRM_RESULT)0x8004C503L)
+
+/*
+ * MessageId: DRM_E_DOMAIN_STORE_DELETE_DATA
+ *
+ * MessageText:
+ *
+ * Failed to delete data from the domain store.
+ *
+ */
+#define DRM_E_DOMAIN_STORE_DELETE_DATA   ((DRM_RESULT)0x8004C504L)
+
+/*
+ * MessageId: DRM_E_DOMAIN_STORE_OPEN_STORE
+ *
+ * MessageText:
+ *
+ * Failed to open the domain store.
+ *
+ */
+#define DRM_E_DOMAIN_STORE_OPEN_STORE    ((DRM_RESULT)0x8004C505L)
+
+/*
+ * MessageId: DRM_E_DOMAIN_STORE_CLOSE_STORE
+ *
+ * MessageText:
+ *
+ * Failed to close the domain store.
+ *
+ */
+#define DRM_E_DOMAIN_STORE_CLOSE_STORE   ((DRM_RESULT)0x8004C506L)
+
+/*
+ * MessageId: DRM_E_DOMAIN_BIND_LICENSE
+ *
+ * MessageText:
+ *
+ * Failed to bind to the domain license.
+ *
+ */
+#define DRM_E_DOMAIN_BIND_LICENSE        ((DRM_RESULT)0x8004C507L)
+
+/*
+ * MessageId: DRM_E_DOMAIN_INVALID_CUSTOM_DATA
+ *
+ * MessageText:
+ *
+ * Not a valid custom data.
+ *
+ */
+#define DRM_E_DOMAIN_INVALID_CUSTOM_DATA ((DRM_RESULT)0x8004C508L)
+
+/*
+ * MessageId: DRM_E_DOMAIN_NOT_FOUND
+ *
+ * MessageText:
+ *
+ * No domain information is found.
+ *
+ */
+#define DRM_E_DOMAIN_NOT_FOUND           ((DRM_RESULT)0x8004C509L)
+
+/*
+ * MessageId: DRM_E_DOMAIN_INVALID_DOMKEYXMR_DATA
+ *
+ * MessageText:
+ *
+ * The domain join response contains invalid domain privkey XMR data.
+ *
+ */
+#define DRM_E_DOMAIN_INVALID_DOMKEYXMR_DATA ((DRM_RESULT)0x8004C50AL)
+
+/*
+ * MessageId: DRM_E_DOMAIN_STORE_INVALID_KEY_RECORD
+ *
+ * MessageText:
+ *
+ * Invalid format of domain private key record read from the domain store.
+ *
+ */
+#define DRM_E_DOMAIN_STORE_INVALID_KEY_RECORD ((DRM_RESULT)0x8004C50BL)
+
+/*
+ * MessageId: DRM_E_DOMAIN_JOIN_TOO_MANY_KEYS
+ *
+ * MessageText:
+ *
+ * The server returned too many domain keys for the client to handle.
+ *
+ */
+#define DRM_E_DOMAIN_JOIN_TOO_MANY_KEYS  ((DRM_RESULT)0x8004C50CL)
+
+
+/* ------------------------------------------------------------
+**
+** PC errors returned by core logic: error codes from DRM_E_BASECODE+0x580 to
+** DRM_E_BASECODE+0x5FF, 0x8004c580-0x8004c5ff.
+**
+** ------------------------------------------------------------
+*/
+
+#define DRM_E_PC_BASECODE           DRM_E_BASECODE + 0x580
+
+/*
+ * MessageId: DRM_E_DEVICE_DOMAIN_JOIN_REQUIRED
+ *
+ * MessageText:
+ *
+ * This error code communicates to the application that the device is not a member of a domain. The app can uses this error code in turn to decide whether it needs to join the domain or not
+ *
+ */
+#define DRM_E_DEVICE_DOMAIN_JOIN_REQUIRED ((DRM_RESULT)0x8004C580L)
+
+
+/* ------------------------------------------------------------
+**
+** Server errors returned by core logic: error codes from DRM_E_BASECODE+0x600
+** to DRM_E_BASECODE+0x6FF, 0x8004c600-0x8004c6ff.
+**
+** ------------------------------------------------------------
+*/
+
+#define DRM_E_SERVER_BASECODE       DRM_E_BASECODE + 0x600
+
+/*
+ * MessageId: DRM_E_SERVER_INTERNAL_ERROR
+ *
+ * MessageText:
+ *
+ * An internal server error occurred.
+ *
+ */
+#define DRM_E_SERVER_INTERNAL_ERROR      ((DRM_RESULT)0x8004C600L)
+
+/*
+ * MessageId: DRM_E_SERVER_INVALID_MESSAGE
+ *
+ * MessageText:
+ *
+ * The message sent to the server was invalid.
+ *
+ */
+#define DRM_E_SERVER_INVALID_MESSAGE     ((DRM_RESULT)0x8004C601L)
+
+/*
+ * MessageId: DRM_E_SERVER_DEVICE_LIMIT_REACHED
+ *
+ * MessageText:
+ *
+ * The device limit for the domain has been reached.
+ *
+ */
+#define DRM_E_SERVER_DEVICE_LIMIT_REACHED ((DRM_RESULT)0x8004C602L)
+
+/*
+ * MessageId: DRM_E_SERVER_INDIV_REQUIRED
+ *
+ * MessageText:
+ *
+ * Individualization of the client is required.
+ *
+ */
+#define DRM_E_SERVER_INDIV_REQUIRED      ((DRM_RESULT)0x8004C603L)
+
+/*
+ * MessageId: DRM_E_SERVER_SERVICE_SPECIFIC
+ *
+ * MessageText:
+ *
+ * An error specific to the service has occurred.
+ *
+ */
+#define DRM_E_SERVER_SERVICE_SPECIFIC    ((DRM_RESULT)0x8004C604L)
+
+/*
+ * MessageId: DRM_E_SERVER_DOMAIN_REQUIRED
+ *
+ * MessageText:
+ *
+ * A Domain certificate is required.
+ *
+ */
+#define DRM_E_SERVER_DOMAIN_REQUIRED     ((DRM_RESULT)0x8004C605L)
+
+/*
+ * MessageId: DRM_E_SERVER_RENEW_DOMAIN
+ *
+ * MessageText:
+ *
+ * The Domain certificate needs to be renewed.
+ *
+ */
+#define DRM_E_SERVER_RENEW_DOMAIN        ((DRM_RESULT)0x8004C606L)
+
+/*
+ * MessageId: DRM_E_SERVER_UNKNOWN_METERINGID
+ *
+ * MessageText:
+ *
+ * The metering identifier is unknown.
+ *
+ */
+#define DRM_E_SERVER_UNKNOWN_METERINGID  ((DRM_RESULT)0x8004C607L)
+
+/*
+ * MessageId: DRM_E_SERVER_COMPUTER_LIMIT_REACHED
+ *
+ * MessageText:
+ *
+ * The computer limit for the domain has been reached.
+ *
+ */
+#define DRM_E_SERVER_COMPUTER_LIMIT_REACHED ((DRM_RESULT)0x8004C608L)
+
+/*
+ * MessageId: DRM_E_SERVER_PROTOCOL_FALLBACK
+ *
+ * MessageText:
+ *
+ * The client should fallback to the V2 license acquisition protocol.
+ *
+ */
+#define DRM_E_SERVER_PROTOCOL_FALLBACK   ((DRM_RESULT)0x8004C609L)
+
+/*
+ * MessageId: DRM_E_SERVER_NOT_A_MEMBER
+ *
+ * MessageText:
+ *
+ * The client was removed from the domain in an offline fashion and thus still has a domain cert, but not a valid domain membership.
+ *
+ */
+#define DRM_E_SERVER_NOT_A_MEMBER        ((DRM_RESULT)0x8004C60AL)
+
+/*
+ * MessageId: DRM_E_SERVER_PROTOCOL_VERSION_MISMATCH
+ *
+ * MessageText:
+ *
+ * The protocol version specified was not supported by the server.
+ *
+ */
+#define DRM_E_SERVER_PROTOCOL_VERSION_MISMATCH ((DRM_RESULT)0x8004C60BL)
+
+/*
+ * MessageId: DRM_E_SERVER_UNKNOWN_ACCOUNTID
+ *
+ * MessageText:
+ *
+ * The account identifier is unknown.
+ *
+ */
+#define DRM_E_SERVER_UNKNOWN_ACCOUNTID   ((DRM_RESULT)0x8004C60CL)
+
+/*
+ * MessageId: DRM_E_SERVER_PROTOCOL_REDIRECT
+ *
+ * MessageText:
+ *
+ * The protocol has a redirect.
+ *
+ */
+#define DRM_E_SERVER_PROTOCOL_REDIRECT   ((DRM_RESULT)0x8004C60DL)
+
+/*
+ * MessageId: DRM_E_SERVER_UNKNOWN_TRANSACTIONID
+ *
+ * MessageText:
+ *
+ * The transaction identifier is unknown.
+ *
+ */
+#define DRM_E_SERVER_UNKNOWN_TRANSACTIONID ((DRM_RESULT)0x8004C610L)
+
+/*
+ * MessageId: DRM_E_SERVER_INVALID_LICENSEID
+ *
+ * MessageText:
+ *
+ * The license identifier is invalid.
+ *
+ */
+#define DRM_E_SERVER_INVALID_LICENSEID   ((DRM_RESULT)0x8004C611L)
+
+/*
+ * MessageId: DRM_E_SERVER_MAXIMUM_LICENSEID_EXCEEDED
+ *
+ * MessageText:
+ *
+ * The maximum number of license identifiers in the request was exceeded.
+ *
+ */
+#define DRM_E_SERVER_MAXIMUM_LICENSEID_EXCEEDED ((DRM_RESULT)0x8004C612L)
+
+
+/* ------------------------------------------------------------
+** DRM_E_BASECODE + 0x680 - DRM_E_BASECODE + 0x6ff (0x8004c680-0x8004c6ff)
+** are reserved for DRM Services.
+**
+** See source\common\services\inc\svcerrors.h for Services error codes.
+**
+** ------------------------------------------------------------
+*/
+
+#define DRM_E_SERVICES_BASECODE     (DRM_E_BASECODE + 0x680)
+
+/* ------------------------------------------------------------
+**
+** License acquisition protocol errors: error codes from DRM_E_BASECODE+0x700
+** to DRM_E_BASECODE+0x77F, 0x8004c700-0x8004c77f.
+**
+** ------------------------------------------------------------
+*/
+
+#define DRM_E_LICACQ_BASECODE       DRM_E_BASECODE + 0x700
+
+/*
+ * MessageId: DRM_E_LICACQ_TOO_MANY_LICENSES
+ *
+ * MessageText:
+ *
+ * There are too many licenses in the license response.
+ *
+ */
+#define DRM_E_LICACQ_TOO_MANY_LICENSES   ((DRM_RESULT)0x8004C700L)
+
+/*
+ * MessageId: DRM_E_LICACQ_ACK_TRANSACTION_ID_TOO_BIG
+ *
+ * MessageText:
+ *
+ * The Transaction ID specified by the server exceeds the allocated buffer.
+ *
+ */
+#define DRM_E_LICACQ_ACK_TRANSACTION_ID_TOO_BIG ((DRM_RESULT)0x8004C701L)
+
+
+/* ------------------------------------------------------------
+**
+** Binary certificate errors: error codes from DRM_E_BASECODE+0x800
+** to DRM_E_BASECODE+0x8FF, 0x8004c800-0x8004c8ff.
+**
+** ------------------------------------------------------------
+*/
+
+#define DRM_E_BCERT_BASECODE     DRM_E_BASECODE + 0x800
+
+/*
+ * MessageId: DRM_E_BCERT_INVALID_SIGNATURE_TYPE
+ *
+ * MessageText:
+ *
+ * An invalid signature type was encountered
+ *
+ */
+#define DRM_E_BCERT_INVALID_SIGNATURE_TYPE ((DRM_RESULT)0x8004C800L)
+
+/*
+ * MessageId: DRM_E_BCERT_CHAIN_TOO_DEEP
+ *
+ * MessageText:
+ *
+ * There are, or there would be, too many certificates in the certificate chain
+ *
+ */
+#define DRM_E_BCERT_CHAIN_TOO_DEEP       ((DRM_RESULT)0x8004C801L)
+
+/*
+ * MessageId: DRM_E_BCERT_INVALID_CERT_TYPE
+ *
+ * MessageText:
+ *
+ * An invalid certificate type was encountered
+ *
+ */
+#define DRM_E_BCERT_INVALID_CERT_TYPE    ((DRM_RESULT)0x8004C802L)
+
+/*
+ * MessageId: DRM_E_BCERT_INVALID_FEATURE
+ *
+ * MessageText:
+ *
+ * An invalid feature entry was encountered OR the porting kit was linked with mutually incompatible features or features incompatible with the certificate
+ *
+ */
+#define DRM_E_BCERT_INVALID_FEATURE      ((DRM_RESULT)0x8004C803L)
+
+/*
+ * MessageId: DRM_E_BCERT_INVALID_KEY_USAGE
+ *
+ * MessageText:
+ *
+ * An invalid public key usage was encountered
+ *
+ */
+#define DRM_E_BCERT_INVALID_KEY_USAGE    ((DRM_RESULT)0x8004C804L)
+
+/*
+ * MessageId: DRM_E_BCERT_INVALID_SECURITY_VERSION
+ *
+ * MessageText:
+ *
+ * An invalid Indiv Box security version was encountered
+ *
+ */
+#define DRM_E_BCERT_INVALID_SECURITY_VERSION ((DRM_RESULT)0x8004C805L)
+
+/*
+ * MessageId: DRM_E_BCERT_INVALID_KEY_TYPE
+ *
+ * MessageText:
+ *
+ * An invalid public key type was encountered
+ *
+ */
+#define DRM_E_BCERT_INVALID_KEY_TYPE     ((DRM_RESULT)0x8004C806L)
+
+/*
+ * MessageId: DRM_E_BCERT_INVALID_KEY_LENGTH
+ *
+ * MessageText:
+ *
+ * An invalid public key length was encountered
+ *
+ */
+#define DRM_E_BCERT_INVALID_KEY_LENGTH   ((DRM_RESULT)0x8004C807L)
+
+/*
+ * MessageId: DRM_E_BCERT_INVALID_MAX_LICENSE_CHAIN_DEPTH
+ *
+ * MessageText:
+ *
+ * An invalid maximum license chain depth was encountered
+ *
+ */
+#define DRM_E_BCERT_INVALID_MAX_LICENSE_CHAIN_DEPTH ((DRM_RESULT)0x8004C80AL)
+
+/*
+ * MessageId: DRM_E_BCERT_INVALID_SECURITY_LEVEL
+ *
+ * MessageText:
+ *
+ * An invalid security level was encountered
+ *
+ */
+#define DRM_E_BCERT_INVALID_SECURITY_LEVEL ((DRM_RESULT)0x8004C80BL)
+
+/*
+ * MessageId: DRM_E_BCERT_PRIVATE_KEY_NOT_SPECIFIED
+ *
+ * MessageText:
+ *
+ * A private key for signing the certificate was not provided to the builder
+ *
+ */
+#define DRM_E_BCERT_PRIVATE_KEY_NOT_SPECIFIED ((DRM_RESULT)0x8004C80CL)
+
+/*
+ * MessageId: DRM_E_BCERT_ISSUER_KEY_NOT_SPECIFIED
+ *
+ * MessageText:
+ *
+ * An issuer key was not provided to the builder
+ *
+ */
+#define DRM_E_BCERT_ISSUER_KEY_NOT_SPECIFIED ((DRM_RESULT)0x8004C80DL)
+
+/*
+ * MessageId: DRM_E_BCERT_ACCOUNT_ID_NOT_SPECIFIED
+ *
+ * MessageText:
+ *
+ * An account ID was not provided to the builder
+ *
+ */
+#define DRM_E_BCERT_ACCOUNT_ID_NOT_SPECIFIED ((DRM_RESULT)0x8004C80EL)
+
+/*
+ * MessageId: DRM_E_BCERT_SERVICE_ID_NOT_SPECIFIED
+ *
+ * MessageText:
+ *
+ * A service provider ID was not provided to the builder
+ *
+ */
+#define DRM_E_BCERT_SERVICE_ID_NOT_SPECIFIED ((DRM_RESULT)0x8004C80FL)
+
+/*
+ * MessageId: DRM_E_BCERT_DOMAIN_URL_NOT_SPECIFIED
+ *
+ * MessageText:
+ *
+ * A domain URL was not provided to the builder
+ *
+ */
+#define DRM_E_BCERT_DOMAIN_URL_NOT_SPECIFIED ((DRM_RESULT)0x8004C811L)
+
+/*
+ * MessageId: DRM_E_BCERT_DOMAIN_URL_TOO_LONG
+ *
+ * MessageText:
+ *
+ * The domain URL contains too many ASCII characters
+ *
+ */
+#define DRM_E_BCERT_DOMAIN_URL_TOO_LONG  ((DRM_RESULT)0x8004C812L)
+
+/*
+ * MessageId: DRM_E_BCERT_CERT_ID_NOT_SPECIFIED
+ *
+ * MessageText:
+ *
+ * A certificate ID was not provided to the builder
+ *
+ */
+#define DRM_E_BCERT_CERT_ID_NOT_SPECIFIED ((DRM_RESULT)0x8004C816L)
+
+/*
+ * MessageId: DRM_E_BCERT_PUBLIC_KEY_NOT_SPECIFIED
+ *
+ * MessageText:
+ *
+ * A public key for the certificate was not provided to the builder or not found by the parser
+ *
+ */
+#define DRM_E_BCERT_PUBLIC_KEY_NOT_SPECIFIED ((DRM_RESULT)0x8004C817L)
+
+/*
+ * MessageId: DRM_E_BCERT_KEY_USAGES_NOT_SPECIFIED
+ *
+ * MessageText:
+ *
+ * The public key usage information was not provided to the builder or not found by the parser
+ *
+ */
+#define DRM_E_BCERT_KEY_USAGES_NOT_SPECIFIED ((DRM_RESULT)0x8004C818L)
+
+/*
+ * MessageId: DRM_E_BCERT_STRING_NOT_NULL_TERMINATED
+ *
+ * MessageText:
+ *
+ * Data string is not null-teminated
+ *
+ */
+#define DRM_E_BCERT_STRING_NOT_NULL_TERMINATED ((DRM_RESULT)0x8004C819L)
+
+/*
+ * MessageId: DRM_E_BCERT_BASICINFO_CERT_EXPIRED
+ *
+ * MessageText:
+ *
+ * Certificate is expired
+ *
+ */
+#define DRM_E_BCERT_BASICINFO_CERT_EXPIRED ((DRM_RESULT)0x8004C81CL)
+
+/*
+ * MessageId: DRM_E_BCERT_ISSUERKEY_KEYINFO_MISMATCH
+ *
+ * MessageText:
+ *
+ * The cert's Issuer Key does not match key info in the next cert
+ *
+ */
+#define DRM_E_BCERT_ISSUERKEY_KEYINFO_MISMATCH ((DRM_RESULT)0x8004C81EL)
+
+/*
+ * MessageId: DRM_E_BCERT_INVALID_CHAIN_HEADER_TAG
+ *
+ * MessageText:
+ *
+ * Cert chain header tag is invalid
+ *
+ */
+#define DRM_E_BCERT_INVALID_CHAIN_HEADER_TAG ((DRM_RESULT)0x8004C821L)
+
+/*
+ * MessageId: DRM_E_BCERT_INVALID_CHAIN_VERSION
+ *
+ * MessageText:
+ *
+ * Cert chain version is invalid
+ *
+ */
+#define DRM_E_BCERT_INVALID_CHAIN_VERSION ((DRM_RESULT)0x8004C822L)
+
+/*
+ * MessageId: DRM_E_BCERT_INVALID_CHAIN_LENGTH
+ *
+ * MessageText:
+ *
+ * Cert chain length value is invalid
+ *
+ */
+#define DRM_E_BCERT_INVALID_CHAIN_LENGTH ((DRM_RESULT)0x8004C823L)
+
+/*
+ * MessageId: DRM_E_BCERT_INVALID_CERT_VERSION
+ *
+ * MessageText:
+ *
+ * Cert version is invalid
+ *
+ */
+#define DRM_E_BCERT_INVALID_CERT_VERSION ((DRM_RESULT)0x8004C825L)
+
+/*
+ * MessageId: DRM_E_BCERT_INVALID_SIGNEDCERT_LENGTH
+ *
+ * MessageText:
+ *
+ * Length of signed portion of certificate is invalid
+ *
+ */
+#define DRM_E_BCERT_INVALID_SIGNEDCERT_LENGTH ((DRM_RESULT)0x8004C827L)
+
+/*
+ * MessageId: DRM_E_BCERT_INVALID_PLATFORM_IDENTIFIER
+ *
+ * MessageText:
+ *
+ * An invalid Platform Identifier was specified
+ *
+ */
+#define DRM_E_BCERT_INVALID_PLATFORM_IDENTIFIER ((DRM_RESULT)0x8004C828L)
+
+/*
+ * MessageId: DRM_E_BCERT_INVALID_EXTDATARECORD
+ *
+ * MessageText:
+ *
+ * An invalid extended data record
+ *
+ */
+#define DRM_E_BCERT_INVALID_EXTDATARECORD ((DRM_RESULT)0x8004C82AL)
+
+/*
+ * MessageId: DRM_E_BCERT_EXTDATA_PRIVKEY_MUST_PRESENT
+ *
+ * MessageText:
+ *
+ * Extended data record length must be present.
+ *
+ */
+#define DRM_E_BCERT_EXTDATA_PRIVKEY_MUST_PRESENT ((DRM_RESULT)0x8004C82CL)
+
+/*
+ * MessageId: DRM_E_BCERT_HWIDINFO_IS_MISSING
+ *
+ * MessageText:
+ *
+ * The PC certificate is correct but is not ready to use because has no HWID information
+ *
+ */
+#define DRM_E_BCERT_HWIDINFO_IS_MISSING  ((DRM_RESULT)0x8004C82FL)
+
+/*
+ * MessageId: DRM_E_BCERT_METERING_ID_NOT_SPECIFIED
+ *
+ * MessageText:
+ *
+ * An metering ID was not provided to the builder
+ *
+ */
+#define DRM_E_BCERT_METERING_ID_NOT_SPECIFIED ((DRM_RESULT)0x8004C833L)
+
+/*
+ * MessageId: DRM_E_BCERT_METERING_URL_NOT_SPECIFIED
+ *
+ * MessageText:
+ *
+ * A metering URL was not provided to the builder
+ *
+ */
+#define DRM_E_BCERT_METERING_URL_NOT_SPECIFIED ((DRM_RESULT)0x8004C834L)
+
+/*
+ * MessageId: DRM_E_BCERT_METERING_URL_TOO_LONG
+ *
+ * MessageText:
+ *
+ * The metering URL contains too many ASCII characters
+ *
+ */
+#define DRM_E_BCERT_METERING_URL_TOO_LONG ((DRM_RESULT)0x8004C835L)
+
+/*
+ * MessageId: DRM_E_BCERT_VERIFICATION_ERRORS
+ *
+ * MessageText:
+ *
+ * Verification errors are found while parsing cert chain
+ *
+ */
+#define DRM_E_BCERT_VERIFICATION_ERRORS  ((DRM_RESULT)0x8004C836L)
+
+/*
+ * MessageId: DRM_E_BCERT_REQUIRED_KEYUSAGE_MISSING
+ *
+ * MessageText:
+ *
+ * Required key usage is missing
+ *
+ */
+#define DRM_E_BCERT_REQUIRED_KEYUSAGE_MISSING ((DRM_RESULT)0x8004C837L)
+
+/*
+ * MessageId: DRM_E_BCERT_NO_PUBKEY_WITH_REQUESTED_KEYUSAGE
+ *
+ * MessageText:
+ *
+ * The certificate does not contain a public key with the requested key usage
+ *
+ */
+#define DRM_E_BCERT_NO_PUBKEY_WITH_REQUESTED_KEYUSAGE ((DRM_RESULT)0x8004C838L)
+
+/*
+ * MessageId: DRM_E_BCERT_MANUFACTURER_STRING_TOO_LONG
+ *
+ * MessageText:
+ *
+ * The manufacturer string is too long
+ *
+ */
+#define DRM_E_BCERT_MANUFACTURER_STRING_TOO_LONG ((DRM_RESULT)0x8004C839L)
+
+/*
+ * MessageId: DRM_E_BCERT_TOO_MANY_PUBLIC_KEYS
+ *
+ * MessageText:
+ *
+ * There are too many public keys in the certificate
+ *
+ */
+#define DRM_E_BCERT_TOO_MANY_PUBLIC_KEYS ((DRM_RESULT)0x8004C83AL)
+
+/*
+ * MessageId: DRM_E_BCERT_INVALID_WARNING_DAYS
+ *
+ * MessageText:
+ *
+ * An invalid server certificate expiration warning days. Warning days must be greater than zero.
+ *
+ */
+#define DRM_E_BCERT_INVALID_WARNING_DAYS ((DRM_RESULT)0x8004C83CL)
+
+/*
+ * MessageId: DRM_E_BCERT_INVALID_DIGEST
+ *
+ * MessageText:
+ *
+ * The certificate digest is invalid.
+ *
+ */
+#define DRM_E_BCERT_INVALID_DIGEST       ((DRM_RESULT)0x8004C83DL)
+
+/*
+ * MessageId: DRM_E_BCERT_MANUFACTURING_INFO_REQUIRED
+ *
+ * MessageText:
+ *
+ * This certificate type requires Manufacturer Name, Model Name, and Model Number to be set.
+ *
+ */
+#define DRM_E_BCERT_MANUFACTURING_INFO_REQUIRED ((DRM_RESULT)0x8004C83EL)
+
+
+/* ------------------------------------------------------------
+**
+** XML Signature/Encryption errors: error codes from DRM_E_BASECODE+0x900
+** to DRM_E_BASECODE+0x9FF, 0x8004c900-0x8004c9ff.
+**
+** ------------------------------------------------------------
+*/
+
+#define DRM_E_XMLSIG_BASECODE       DRM_E_BASECODE + 0x900
+
+/*
+ * MessageId: DRM_E_XMLSIG_ECDSA_VERIFY_FAILURE
+ *
+ * MessageText:
+ *
+ * Error in ECDSA signature verification.
+ *
+ */
+#define DRM_E_XMLSIG_ECDSA_VERIFY_FAILURE ((DRM_RESULT)0x8004C900L)
+
+/*
+ * MessageId: DRM_E_XMLSIG_SHA_VERIFY_FAILURE
+ *
+ * MessageText:
+ *
+ * Error in SHA verification.
+ *
+ */
+#define DRM_E_XMLSIG_SHA_VERIFY_FAILURE  ((DRM_RESULT)0x8004C901L)
+
+/*
+ * MessageId: DRM_E_XMLSIG_FORMAT
+ *
+ * MessageText:
+ *
+ * The format of XML signature or encryption segment is incorrect.
+ *
+ */
+#define DRM_E_XMLSIG_FORMAT              ((DRM_RESULT)0x8004C902L)
+
+/*
+ * MessageId: DRM_E_XMLSIG_PUBLIC_KEY_ID
+ *
+ * MessageText:
+ *
+ * Invalud pre-shared public key ID.
+ *
+ */
+#define DRM_E_XMLSIG_PUBLIC_KEY_ID       ((DRM_RESULT)0x8004C903L)
+
+/*
+ * MessageId: DRM_E_XMLSIG_INVALID_KEY_FORMAT
+ *
+ * MessageText:
+ *
+ * Invalid type of public/private key format.
+ *
+ */
+#define DRM_E_XMLSIG_INVALID_KEY_FORMAT  ((DRM_RESULT)0x8004C904L)
+
+/*
+ * MessageId: DRM_E_XMLSIG_SHA_HASH_SIZE
+ *
+ * MessageText:
+ *
+ * Size of hash is unexpected.
+ *
+ */
+#define DRM_E_XMLSIG_SHA_HASH_SIZE       ((DRM_RESULT)0x8004C905L)
+
+/*
+ * MessageId: DRM_E_XMLSIG_ECDSA_SIGNATURE_SIZE
+ *
+ * MessageText:
+ *
+ * Size of ECDSA signature is unexpected.
+ *
+ */
+#define DRM_E_XMLSIG_ECDSA_SIGNATURE_SIZE ((DRM_RESULT)0x8004C906L)
+
+
+/* ------------------------------------------------------------
+**
+** UTF8 encoding errors: error codes from DRM_E_BASECODE+0xA00
+** to DRM_E_BASECODE+0xAFF, 0x8004ca00-0x8004caff.
+**
+** ------------------------------------------------------------
+*/
+
+#define DRM_E_UTF_BASECODE       DRM_E_BASECODE + 0xa00
+
+/*
+ * MessageId: DRM_E_UTF_UNEXPECTED_END
+ *
+ * MessageText:
+ *
+ * Unexpected end of data in the middle of multibyte character.
+ *
+ */
+#define DRM_E_UTF_UNEXPECTED_END         ((DRM_RESULT)0x8004CA00L)
+
+/*
+ * MessageId: DRM_E_UTF_INVALID_CODE
+ *
+ * MessageText:
+ *
+ * UTF character maps into a code with invalid value.
+ *
+ */
+#define DRM_E_UTF_INVALID_CODE           ((DRM_RESULT)0x8004CA01L)
+
+
+/* ------------------------------------------------------------
+**
+** XML SOAP errors: error codes from DRM_E_BASECODE+0xB00
+** to DRM_E_BASECODE+0xBFF, 0x8004cb00-0x8004cbff.
+**
+** ------------------------------------------------------------
+*/
+
+#define DRM_E_SOAPXML_BASECODE       DRM_E_BASECODE + 0xb00
+
+/*
+ * MessageId: DRM_E_SOAPXML_INVALID_STATUS_CODE
+ *
+ * MessageText:
+ *
+ * Status code contained in the server error response is invalid.
+ *
+ */
+#define DRM_E_SOAPXML_INVALID_STATUS_CODE ((DRM_RESULT)0x8004CB00L)
+
+/*
+ * MessageId: DRM_E_SOAPXML_XML_FORMAT
+ *
+ * MessageText:
+ *
+ * Cannot parse out expected XML node.
+ *
+ */
+#define DRM_E_SOAPXML_XML_FORMAT         ((DRM_RESULT)0x8004CB01L)
+
+/*
+ * MessageId: DRM_E_SOAPXML_WRONG_MESSAGE_TYPE
+ *
+ * MessageText:
+ *
+ * The message type associated with the soap message is wrong.
+ *
+ */
+#define DRM_E_SOAPXML_WRONG_MESSAGE_TYPE ((DRM_RESULT)0x8004CB02L)
+
+/*
+ * MessageId: DRM_E_SOAPXML_SIGNATURE_MISSING
+ *
+ * MessageText:
+ *
+ * The message did not have a signature and needed one
+ *
+ */
+#define DRM_E_SOAPXML_SIGNATURE_MISSING  ((DRM_RESULT)0x8004CB03L)
+
+/*
+ * MessageId: DRM_E_SOAPXML_PROTOCOL_NOT_SUPPORTED
+ *
+ * MessageText:
+ *
+ * The requested protocol is not supported by the DRM SOAP parser.
+ *
+ */
+#define DRM_E_SOAPXML_PROTOCOL_NOT_SUPPORTED ((DRM_RESULT)0x8004CB04L)
+
+/*
+ * MessageId: DRM_E_SOAPXML_DATA_NOT_FOUND
+ *
+ * MessageText:
+ *
+ * The requested data is not found in the response.
+ *
+ */
+#define DRM_E_SOAPXML_DATA_NOT_FOUND     ((DRM_RESULT)0x8004CB05L)
+
+
+/* ------------------------------------------------------------
+**
+** Generic crypto errors: error codes from DRM_E_BASECODE+0xC00
+** to DRM_E_BASECODE+0xCFF, 0x8004cc00-0x8004ccff.
+**
+** ------------------------------------------------------------
+*/
+
+#define DRM_E_CRYPTO_BASECODE       DRM_E_BASECODE + 0xc00
+
+/*
+ * MessageId: DRM_E_CRYPTO_PUBLIC_KEY_NOT_MATCH
+ *
+ * MessageText:
+ *
+ * The public key associated with an encrypted domain private from the server does not match any public key on the device.
+ *
+ */
+#define DRM_E_CRYPTO_PUBLIC_KEY_NOT_MATCH ((DRM_RESULT)0x8004CC00L)
+
+/*
+ * MessageId: DRM_E_UNABLE_TO_RESOLVE_LOCATION_TREE
+ *
+ * MessageText:
+ *
+ * Unable to derive the key.  May be due to blackout or no rights to the service, etc.
+ *
+ */
+#define DRM_E_UNABLE_TO_RESOLVE_LOCATION_TREE ((DRM_RESULT)0x8004CC01L)
+
+
+/* ------------------------------------------------------------
+**
+** TEE errors: error codes from DRM_E_BASECODE+0xD10
+** to DRM_E_BASECODE+0xDFF, 0x8004cd10-0x8004cdff.
+**
+** ------------------------------------------------------------
+*/
+
+#define DRM_E_TEE_BASECODE       DRM_E_BASECODE + 0xd10
+
+/*
+ * MessageId: DRM_E_TEE_INVALID_KEY_DATA
+ *
+ * MessageText:
+ *
+ * The key data given to the TEE was invalid.
+ *
+ */
+#define DRM_E_TEE_INVALID_KEY_DATA       ((DRM_RESULT)0x8004CD10L)
+
+/*
+ * MessageId: DRM_E_TEE_PROVISIONING_REQUIRED
+ *
+ * MessageText:
+ *
+ * Provisioning is required.
+ *
+ */
+#define DRM_E_TEE_PROVISIONING_REQUIRED  ((DRM_RESULT)0x8004CD11L)
+
+/*
+ * MessageId: DRM_E_TEE_INVALID_HWDRM_STATE
+ *
+ * MessageText:
+ *
+ * The HWDRM state is invalid, e.g. the TEE context is invalid.  Reinitialization is required.
+ *
+ */
+#define DRM_E_TEE_INVALID_HWDRM_STATE    ((DRM_RESULT)0x8004CD12L)
+
+/*
+ * MessageId: DRM_E_TEE_PROVISIONING_REQUEST_EXPIRED
+ *
+ * MessageText:
+ *
+ * Provisioning request expired.
+ *
+ */
+#define DRM_E_TEE_PROVISIONING_REQUEST_EXPIRED ((DRM_RESULT)0x8004CD13L)
+
+/*
+ * MessageId: DRM_E_TEE_CLOCK_NOT_SET
+ *
+ * MessageText:
+ *
+ * The TEE secure clock needs to be reset.
+ *
+ */
+#define DRM_E_TEE_CLOCK_NOT_SET          ((DRM_RESULT)0x8004CD14L)
+
+/*
+ * MessageId: DRM_E_TEE_BLOB_ACCESS_DENIED
+ *
+ * MessageText:
+ *
+ * The blob data is protected and cannot be transfered outside of the TEE.
+ *
+ */
+#define DRM_E_TEE_BLOB_ACCESS_DENIED     ((DRM_RESULT)0x8004CD15L)
+
+/*
+ * MessageId: DRM_E_TEE_PROVISIONING_BAD_NONCE
+ *
+ * MessageText:
+ *
+ * Malformed nonce
+ *
+ */
+#define DRM_E_TEE_PROVISIONING_BAD_NONCE ((DRM_RESULT)0x8004CD16L)
+
+/*
+ * MessageId: DRM_E_TEE_PROVISIONING_NONCE_MISMATCH
+ *
+ * MessageText:
+ *
+ * Nonce mismatch. Possibly another request has happened in parallel.
+ *
+ */
+#define DRM_E_TEE_PROVISIONING_NONCE_MISMATCH ((DRM_RESULT)0x8004CD17L)
+
+/*
+ * MessageId: DRM_E_TEE_ROOT_KEY_CHANGED
+ *
+ * MessageText:
+ *
+ * The root-most TEE key has changed without maintaining key history.  All TEE-bound data is now invalid.
+ *
+ */
+#define DRM_E_TEE_ROOT_KEY_CHANGED       ((DRM_RESULT)0x8004CD18L)
+
+/*
+ * MessageId: DRM_E_TEE_PROVISIONING_INVALID_RESPONSE
+ *
+ * MessageText:
+ *
+ * Invalid provisioning response.
+ *
+ */
+#define DRM_E_TEE_PROVISIONING_INVALID_RESPONSE ((DRM_RESULT)0x8004CD19L)
+
+/*
+ * MessageId: DRM_E_TEE_PROXY_INVALID_SERIALIZATION_MESSAGE
+ *
+ * MessageText:
+ *
+ * Invalid TEE proxy serialization message.
+ *
+ */
+#define DRM_E_TEE_PROXY_INVALID_SERIALIZATION_MESSAGE ((DRM_RESULT)0x8004CD1AL)
+
+/*
+ * MessageId: DRM_E_TEE_PROXY_INVALID_SERIALIZATION_TYPE
+ *
+ * MessageText:
+ *
+ * Invalid TEE proxy serialization type.
+ *
+ */
+#define DRM_E_TEE_PROXY_INVALID_SERIALIZATION_TYPE ((DRM_RESULT)0x8004CD1BL)
+
+/*
+ * MessageId: DRM_E_TEE_LAYER_UNINITIALIZED
+ *
+ * MessageText:
+ *
+ * TEE Layer is not initialized.
+ *
+ */
+#define DRM_E_TEE_LAYER_UNINITIALIZED    ((DRM_RESULT)0x8004CD1CL)
+
+/*
+ * MessageId: DRM_E_TEE_INVALID_HEADER_FOOTER_SIZE
+ *
+ * MessageText:
+ *
+ * The OEM defined TEE message header/footer size was not a multiple of 8 bytes.
+ *
+ */
+#define DRM_E_TEE_INVALID_HEADER_FOOTER_SIZE ((DRM_RESULT)0x8004CD1DL)
+
+/*
+ * MessageId: DRM_E_TEE_MESSAGE_TOO_LARGE
+ *
+ * MessageText:
+ *
+ * TEE method invocation message is too large.
+ *
+ */
+#define DRM_E_TEE_MESSAGE_TOO_LARGE      ((DRM_RESULT)0x8004CD1EL)
+
+/*
+ * MessageId: DRM_E_TEE_CLOCK_DRIFTED
+ *
+ * MessageText:
+ *
+ * TEE clock drift detected.
+ *
+ */
+#define DRM_E_TEE_CLOCK_DRIFTED          ((DRM_RESULT)0x8004CD1FL)
+
+/*
+ * MessageId: DRM_E_TEE_PROXY_INVALID_BUFFER_ALIGNMENT
+ *
+ * MessageText:
+ *
+ * The TEE serialization buffer is incorrectly aligned.  It requires 8-byte alignment.
+ *
+ */
+#define DRM_E_TEE_PROXY_INVALID_BUFFER_ALIGNMENT ((DRM_RESULT)0x8004CD20L)
+
+/*
+ * MessageId: DRM_E_TEE_PROXY_INVALID_ALIGNMENT
+ *
+ * MessageText:
+ *
+ * The TEE serialization buffer has parameters that are not properly aligned.
+ *
+ */
+#define DRM_E_TEE_PROXY_INVALID_ALIGNMENT ((DRM_RESULT)0x8004CD21L)
+
+/*
+ * MessageId: DRM_E_TEE_OUTPUT_PROTECTION_REQUIREMENTS_NOT_MET
+ *
+ * MessageText:
+ *
+ * The TEE has detected that certain output requirements are not being satisfied. Most commonly HDCP is required but not enabled on all available outputs.
+ *
+ */
+#define DRM_E_TEE_OUTPUT_PROTECTION_REQUIREMENTS_NOT_MET ((DRM_RESULT)0x8004CD22L)
+
+
+/* ------------------------------------------------------------
+**
+** Nonce store errors: error codes from DRM_E_BASECODE+0x1000
+** to DRM_E_BASECODE+0x10FF, 0x8004d000-0x8004d0ff.
+**
+** ------------------------------------------------------------
+*/
+
+#define DRM_E_NONCE_STORE_BASECODE       DRM_E_BASECODE + 0x1000
+
+/*
+ * MessageId: DRM_E_NONCE_STORE_TOKEN_NOT_FOUND
+ *
+ * MessageText:
+ *
+ * The matching nonce store token is not found.
+ *
+ */
+#define DRM_E_NONCE_STORE_TOKEN_NOT_FOUND ((DRM_RESULT)0x8004D000L)
+
+/*
+ * MessageId: DRM_E_NONCE_STORE_OPEN_STORE
+ *
+ * MessageText:
+ *
+ * Fail to open nonce store.
+ *
+ */
+#define DRM_E_NONCE_STORE_OPEN_STORE     ((DRM_RESULT)0x8004D001L)
+
+/*
+ * MessageId: DRM_E_NONCE_STORE_CLOSE_STORE
+ *
+ * MessageText:
+ *
+ * Fail to close nonce store.
+ *
+ */
+#define DRM_E_NONCE_STORE_CLOSE_STORE    ((DRM_RESULT)0x8004D002L)
+
+/*
+ * MessageId: DRM_E_NONCE_STORE_ADD_LICENSE
+ *
+ * MessageText:
+ *
+ * There is already a license associated with the nonce store token.
+ *
+ */
+#define DRM_E_NONCE_STORE_ADD_LICENSE    ((DRM_RESULT)0x8004D003L)
+
+
+/* ------------------------------------------------------------
+**
+** Policy State errors: error codes from DRM_E_BASECODE+0x1200 to
+** DRM_E_BASECODE+0x12FF, 0x8004d200-0x8004d2ff.
+**
+** ------------------------------------------------------------
+*/
+
+#define DRM_E_POLICYSTATE_BASECODE              DRM_E_BASECODE+0x1200
+
+/*
+ * MessageId: DRM_E_POLICYSTATE_NOT_FOUND
+ *
+ * MessageText:
+ *
+ * The policy state is not found in the secure store.
+ *
+ */
+#define DRM_E_POLICYSTATE_NOT_FOUND      ((DRM_RESULT)0x8004D200L)
+
+/*
+ * MessageId: DRM_E_POLICYSTATE_CORRUPTED
+ *
+ * MessageText:
+ *
+ * The policy state is not stored as a valid internal format in the secure store.
+ *
+ */
+#define DRM_E_POLICYSTATE_CORRUPTED      ((DRM_RESULT)0x8004D201L)
+
+
+/* ------------------------------------------------------------
+**
+** Extensible Binary errors: error codes from DRM_E_BASECODE+0x1400 to
+** DRM_E_BASECODE+0x14FF, 0x8004d400-0x8004d4ff.
+**
+** ------------------------------------------------------------
+*/
+
+#define DRM_E_XB_BASECODE              DRM_E_BASECODE+0x1400
+
+/*
+ * MessageId: DRM_E_XB_OBJECT_NOTFOUND
+ *
+ * MessageText:
+ *
+ * The extensible binary object was not found.
+ *
+ */
+#define DRM_E_XB_OBJECT_NOTFOUND         ((DRM_RESULT)0x8004D400L)
+
+/*
+ * MessageId: DRM_E_XB_INVALID_OBJECT
+ *
+ * MessageText:
+ *
+ * The extensible binary object format was invalid.
+ *
+ */
+#define DRM_E_XB_INVALID_OBJECT          ((DRM_RESULT)0x8004D401L)
+
+/*
+ * MessageId: DRM_E_XB_OBJECT_ALREADY_EXISTS
+ *
+ * MessageText:
+ *
+ * A single instance extensible binary object was encountered more than once.
+ *
+ */
+#define DRM_E_XB_OBJECT_ALREADY_EXISTS   ((DRM_RESULT)0x8004D402L)
+
+/*
+ * MessageId: DRM_E_XB_REQUIRED_OBJECT_MISSING
+ *
+ * MessageText:
+ *
+ * A required extensible binary object was not found during building.
+ *
+ */
+#define DRM_E_XB_REQUIRED_OBJECT_MISSING ((DRM_RESULT)0x8004D403L)
+
+/*
+ * MessageId: DRM_E_XB_UNKNOWN_ELEMENT_TYPE
+ *
+ * MessageText:
+ *
+ * An extensible binary object description contained an element of an unknown type.
+ *
+ */
+#define DRM_E_XB_UNKNOWN_ELEMENT_TYPE    ((DRM_RESULT)0x8004D404L)
+
+/*
+ * MessageId: DRM_E_XB_INVALID_VERSION
+ *
+ * MessageText:
+ *
+ * The serialized object version could not be found in the extensible binary object description.
+ *
+ */
+#define DRM_E_XB_INVALID_VERSION         ((DRM_RESULT)0x8004D405L)
+
+/*
+ * MessageId: DRM_E_XB_MAX_UNKNOWN_CONTAINER_DEPTH
+ *
+ * MessageText:
+ *
+ * The maximum unknown container depth was reached.
+ *
+ */
+#define DRM_E_XB_MAX_UNKNOWN_CONTAINER_DEPTH ((DRM_RESULT)0x8004D406L)
+
+/*
+ * MessageId: DRM_E_XB_INVALID_ALIGNMENT
+ *
+ * MessageText:
+ *
+ * The serialized message buffer is not properly aligned according to the XBinary format description.
+ *
+ */
+#define DRM_E_XB_INVALID_ALIGNMENT       ((DRM_RESULT)0x8004D407L)
+
+/*
+ * MessageId: DRM_E_XB_OBJECT_OUT_OF_RANGE
+ *
+ * MessageText:
+ *
+ * An extensible binary object size or count is out of the range specified by the attributes 'MinSize' and 'MaxSize'.
+ *
+ */
+#define DRM_E_XB_OBJECT_OUT_OF_RANGE     ((DRM_RESULT)0x8004D408L)
+
+/* ------------------------------------------------------------
+** DRM_E_BASECODE + 0x1600 - DRM_E_BASECODE + 0x16ff (0x8004d600-0x8004d6ff)
+** are reserved for additional DRM Services error codes.
+**
+** See source\common\services\inc\svcerrors.h for Services error codes.
+**
+** ------------------------------------------------------------
+*/
+
+#define DRM_E_SERVICES_BASECODE_EX     (DRM_E_BASECODE + 0x1600)
+
+
+/* ------------------------------------------------------------
+**
+** LicGen errors: error codes from DRM_E_BASECODE + 0x1900 to
+** DRM_E_BASECODE + 0x19ff, 0x8004d900-0x8004d9ff.
+**
+** ------------------------------------------------------------
+*/
+
+#define DRM_E_LICGEN_BASECODE			(DRM_E_BASECODE + 0x1900)
+
+/*
+ * MessageId: DRM_E_LICGEN_CANNOT_PERSIST_LICENSE
+ *
+ * MessageText:
+ *
+ * A non-persistent license cannot be stored in the license store.
+ *
+ */
+#define DRM_E_LICGEN_CANNOT_PERSIST_LICENSE ((DRM_RESULT)0x8004D901L)
+
+/*
+ * MessageId: DRM_E_LICGEN_ROOT_LICENSE_CANNOT_ENCRYPT
+ *
+ * MessageText:
+ *
+ * A root license should not be used to encrypt content.
+ *
+ */
+#define DRM_E_LICGEN_ROOT_LICENSE_CANNOT_ENCRYPT ((DRM_RESULT)0x8004D904L)
+
+/*
+ * MessageId: DRM_E_LICGEN_EMBED_LOCAL_LICENSE
+ *
+ * MessageText:
+ *
+ * A local bound license cannot be embedded.
+ *
+ */
+#define DRM_E_LICGEN_EMBED_LOCAL_LICENSE ((DRM_RESULT)0x8004D905L)
+
+/*
+ * MessageId: DRM_E_LICGEN_DUPLICATE_PLAY_ENABLER
+ *
+ * MessageText:
+ *
+ * A license descriptor contains a duplicate play enabler.
+ *
+ */
+#define DRM_E_LICGEN_DUPLICATE_PLAY_ENABLER ((DRM_RESULT)0x8004D908L)
+
+/*
+ * MessageId: DRM_E_LICGEN_CHILD_SECURITY_LEVEL_TOO_LOW
+ *
+ * MessageText:
+ *
+ * The security level of the chained license is too low.
+ *
+ */
+#define DRM_E_LICGEN_CHILD_SECURITY_LEVEL_TOO_LOW ((DRM_RESULT)0x8004D909L)
+
+/* ------------------------------------------------------------
+**
+** H264 errors: error codes from DRM_E_BASECODE + 0x1A00 to
+** DRM_E_BASECODE + 0x1Aff, 0x8004da00-0x8004daff.
+**
+** ------------------------------------------------------------
+*/
+#define DRM_E_H264_BASECODE      (DRM_E_BASECODE + 0x1A00)
+#define DRM_E_H264_FINALCODE     (DRM_E_BASECODE + 0x1AFF)
+
+/*
+ * MessageId: DRM_E_H264_PARSING_FAILED
+ *
+ * MessageText:
+ *
+ * The H264 was unable to be parsed.
+ *
+ */
+#define DRM_E_H264_PARSING_FAILED        ((DRM_RESULT)0x8004DA00L)
+
+/*
+ * MessageId: DRM_E_H264_SPS_PROFILE
+ *
+ * MessageText:
+ *
+ * SPS-specific H264 parsing error
+ *
+ */
+#define DRM_E_H264_SPS_PROFILE           ((DRM_RESULT)0x8004DA01L)
+
+
+#define DRM_E_H264_MINIMUM DRM_E_H264_SPS_PROFILE
+
+/*
+ * MessageId: DRM_E_H264_SPS_IDC
+ *
+ * MessageText:
+ *
+ * SPS-specific H264 parsing error
+ *
+ */
+#define DRM_E_H264_SPS_IDC               ((DRM_RESULT)0x8004DA02L)
+
+/*
+ * MessageId: DRM_E_H264_SPS_SPSID
+ *
+ * MessageText:
+ *
+ * SPS-specific H264 parsing error
+ *
+ */
+#define DRM_E_H264_SPS_SPSID             ((DRM_RESULT)0x8004DA03L)
+
+/*
+ * MessageId: DRM_E_H264_SPS_FRAMENUM
+ *
+ * MessageText:
+ *
+ * SPS-specific H264 parsing error
+ *
+ */
+#define DRM_E_H264_SPS_FRAMENUM          ((DRM_RESULT)0x8004DA04L)
+
+/*
+ * MessageId: DRM_E_H264_SPS_POCTYPE
+ *
+ * MessageText:
+ *
+ * SPS-specific H264 parsing error
+ *
+ */
+#define DRM_E_H264_SPS_POCTYPE           ((DRM_RESULT)0x8004DA05L)
+
+/*
+ * MessageId: DRM_E_H264_SPS_POCLSB
+ *
+ * MessageText:
+ *
+ * SPS-specific H264 parsing error
+ *
+ */
+#define DRM_E_H264_SPS_POCLSB            ((DRM_RESULT)0x8004DA06L)
+
+/*
+ * MessageId: DRM_E_H264_SPS_POCCYCLE
+ *
+ * MessageText:
+ *
+ * SPS-specific H264 parsing error
+ *
+ */
+#define DRM_E_H264_SPS_POCCYCLE          ((DRM_RESULT)0x8004DA07L)
+
+/*
+ * MessageId: DRM_E_H264_SPS_NUMREFFRAMES
+ *
+ * MessageText:
+ *
+ * SPS-specific H264 parsing error
+ *
+ */
+#define DRM_E_H264_SPS_NUMREFFRAMES      ((DRM_RESULT)0x8004DA08L)
+
+/*
+ * MessageId: DRM_E_H264_SPS_CHROMATOP
+ *
+ * MessageText:
+ *
+ * SPS-specific H264 parsing error
+ *
+ */
+#define DRM_E_H264_SPS_CHROMATOP         ((DRM_RESULT)0x8004DA09L)
+
+/*
+ * MessageId: DRM_E_H264_SPS_CHROMABOTTOM
+ *
+ * MessageText:
+ *
+ * SPS-specific H264 parsing error
+ *
+ */
+#define DRM_E_H264_SPS_CHROMABOTTOM      ((DRM_RESULT)0x8004DA0AL)
+
+/*
+ * MessageId: DRM_E_H264_SPS_NALHRD
+ *
+ * MessageText:
+ *
+ * SPS-specific H264 parsing error
+ *
+ */
+#define DRM_E_H264_SPS_NALHRD            ((DRM_RESULT)0x8004DA0BL)
+
+/*
+ * MessageId: DRM_E_H264_SPS_VLDHRD
+ *
+ * MessageText:
+ *
+ * SPS-specific H264 parsing error
+ *
+ */
+#define DRM_E_H264_SPS_VLDHRD            ((DRM_RESULT)0x8004DA0CL)
+
+/*
+ * MessageId: DRM_E_H264_SPS_VUIBPPD
+ *
+ * MessageText:
+ *
+ * SPS-specific H264 parsing error
+ *
+ */
+#define DRM_E_H264_SPS_VUIBPPD           ((DRM_RESULT)0x8004DA0DL)
+
+/*
+ * MessageId: DRM_E_H264_SPS_VUIBPMD
+ *
+ * MessageText:
+ *
+ * SPS-specific H264 parsing error
+ *
+ */
+#define DRM_E_H264_SPS_VUIBPMD           ((DRM_RESULT)0x8004DA0EL)
+
+/*
+ * MessageId: DRM_E_H264_SPS_VUIMMLH
+ *
+ * MessageText:
+ *
+ * SPS-specific H264 parsing error
+ *
+ */
+#define DRM_E_H264_SPS_VUIMMLH           ((DRM_RESULT)0x8004DA0FL)
+
+/*
+ * MessageId: DRM_E_H264_SPS_VUIMMLV
+ *
+ * MessageText:
+ *
+ * SPS-specific H264 parsing error
+ *
+ */
+#define DRM_E_H264_SPS_VUIMMLV           ((DRM_RESULT)0x8004DA10L)
+
+/*
+ * MessageId: DRM_E_H264_SPS_VUINRF
+ *
+ * MessageText:
+ *
+ * SPS-specific H264 parsing error
+ *
+ */
+#define DRM_E_H264_SPS_VUINRF            ((DRM_RESULT)0x8004DA11L)
+
+/*
+ * MessageId: DRM_E_H264_SPS_VUIMDFB
+ *
+ * MessageText:
+ *
+ * SPS-specific H264 parsing error
+ *
+ */
+#define DRM_E_H264_SPS_VUIMDFB           ((DRM_RESULT)0x8004DA12L)
+
+/*
+ * MessageId: DRM_E_H264_SPS_WIDTH_HEIGHT
+ *
+ * MessageText:
+ *
+ * SPS-specific H264 parsing error
+ *
+ */
+#define DRM_E_H264_SPS_WIDTH_HEIGHT      ((DRM_RESULT)0x8004DA13L)
+
+/*
+ * MessageId: DRM_E_H264_SPS_AREA
+ *
+ * MessageText:
+ *
+ * SPS-specific H264 parsing error
+ *
+ */
+#define DRM_E_H264_SPS_AREA              ((DRM_RESULT)0x8004DA14L)
+
+/*
+ * MessageId: DRM_E_H264_SPS_MINHEIGHT2
+ *
+ * MessageText:
+ *
+ * SPS-specific H264 parsing error
+ *
+ */
+#define DRM_E_H264_SPS_MINHEIGHT2        ((DRM_RESULT)0x8004DA15L)
+
+/*
+ * MessageId: DRM_E_H264_SPS_MINHEIGHT3
+ *
+ * MessageText:
+ *
+ * SPS-specific H264 parsing error
+ *
+ */
+#define DRM_E_H264_SPS_MINHEIGHT3        ((DRM_RESULT)0x8004DA16L)
+
+/*
+ * MessageId: DRM_E_H264_SPS_CROPWIDTH
+ *
+ * MessageText:
+ *
+ * SPS-specific H264 parsing error
+ *
+ */
+#define DRM_E_H264_SPS_CROPWIDTH         ((DRM_RESULT)0x8004DA17L)
+
+/*
+ * MessageId: DRM_E_H264_SPS_CROPHEIGHT
+ *
+ * MessageText:
+ *
+ * SPS-specific H264 parsing error
+ *
+ */
+#define DRM_E_H264_SPS_CROPHEIGHT        ((DRM_RESULT)0x8004DA18L)
+
+/*
+ * MessageId: DRM_E_H264_SPS_MORE_RBSP
+ *
+ * MessageText:
+ *
+ * SPS-specific H264 parsing error
+ *
+ */
+#define DRM_E_H264_SPS_MORE_RBSP         ((DRM_RESULT)0x8004DA19L)
+
+/*
+ * MessageId: DRM_E_H264_SPS_CHROMA_IDC
+ *
+ * MessageText:
+ *
+ * SPS-specific H264 parsing error
+ *
+ */
+#define DRM_E_H264_SPS_CHROMA_IDC        ((DRM_RESULT)0x8004DA1AL)
+
+/*
+ * MessageId: DRM_E_H264_SPS_BITDEPTHLUMA
+ *
+ * MessageText:
+ *
+ * SPS-specific H264 parsing error
+ *
+ */
+#define DRM_E_H264_SPS_BITDEPTHLUMA      ((DRM_RESULT)0x8004DA1BL)
+
+/*
+ * MessageId: DRM_E_H264_SPS_BITDEPTHCHROMA
+ *
+ * MessageText:
+ *
+ * SPS-specific H264 parsing error
+ *
+ */
+#define DRM_E_H264_SPS_BITDEPTHCHROMA    ((DRM_RESULT)0x8004DA1CL)
+
+/*
+ * MessageId: DRM_E_H264_SPS_DELTASCALE1
+ *
+ * MessageText:
+ *
+ * SPS-specific H264 parsing error
+ *
+ */
+#define DRM_E_H264_SPS_DELTASCALE1       ((DRM_RESULT)0x8004DA1DL)
+
+/*
+ * MessageId: DRM_E_H264_SPS_DELTASCALE2
+ *
+ * MessageText:
+ *
+ * SPS-specific H264 parsing error
+ *
+ */
+#define DRM_E_H264_SPS_DELTASCALE2       ((DRM_RESULT)0x8004DA1EL)
+
+/*
+ * MessageId: DRM_E_H264_BITSTREAM_TOOMANY
+ *
+ * MessageText:
+ *
+ * Bitstream-specific H264 parsing error
+ *
+ */
+#define DRM_E_H264_BITSTREAM_TOOMANY     ((DRM_RESULT)0x8004DA30L)
+
+/*
+ * MessageId: DRM_E_H264_BITSTREAM_TOOSHORT1
+ *
+ * MessageText:
+ *
+ * Bitstream-specific H264 parsing error
+ *
+ */
+#define DRM_E_H264_BITSTREAM_TOOSHORT1   ((DRM_RESULT)0x8004DA31L)
+
+/*
+ * MessageId: DRM_E_H264_BITSTREAM_TOOSHORT2
+ *
+ * MessageText:
+ *
+ * Bitstream-specific H264 parsing error
+ *
+ */
+#define DRM_E_H264_BITSTREAM_TOOSHORT2   ((DRM_RESULT)0x8004DA32L)
+
+/*
+ * MessageId: DRM_E_H264_BITSTREAM_TOOSHORT3
+ *
+ * MessageText:
+ *
+ * Bitstream-specific H264 parsing error
+ *
+ */
+#define DRM_E_H264_BITSTREAM_TOOSHORT3   ((DRM_RESULT)0x8004DA33L)
+
+/*
+ * MessageId: DRM_E_H264_BITSTREAM_TOOSHORT4
+ *
+ * MessageText:
+ *
+ * Bitstream-specific H264 parsing error
+ *
+ */
+#define DRM_E_H264_BITSTREAM_TOOSHORT4   ((DRM_RESULT)0x8004DA34L)
+
+/*
+ * MessageId: DRM_E_H264_BITSTREAM_TOOSHORT5
+ *
+ * MessageText:
+ *
+ * Bitstream-specific H264 parsing error
+ *
+ */
+#define DRM_E_H264_BITSTREAM_TOOSHORT5   ((DRM_RESULT)0x8004DA35L)
+
+/*
+ * MessageId: DRM_E_H264_BITSTREAM_EXGOLOBMTOOLONG1
+ *
+ * MessageText:
+ *
+ * Bitstream-specific H264 parsing error
+ *
+ */
+#define DRM_E_H264_BITSTREAM_EXGOLOBMTOOLONG1 ((DRM_RESULT)0x8004DA36L)
+
+/*
+ * MessageId: DRM_E_H264_BITSTREAM_EXGOLOBMTOOLONG2
+ *
+ * MessageText:
+ *
+ * Bitstream-specific H264 parsing error
+ *
+ */
+#define DRM_E_H264_BITSTREAM_EXGOLOBMTOOLONG2 ((DRM_RESULT)0x8004DA37L)
+
+/*
+ * MessageId: DRM_E_H264_NALU_NO_START_CODE
+ *
+ * MessageText:
+ *
+ * Nalu-specific H264 parsing error
+ *
+ */
+#define DRM_E_H264_NALU_NO_START_CODE    ((DRM_RESULT)0x8004DA40L)
+
+/*
+ * MessageId: DRM_E_H264_NALU_ALL_ZERO
+ *
+ * MessageText:
+ *
+ * Nalu-specific H264 parsing error
+ *
+ */
+#define DRM_E_H264_NALU_ALL_ZERO         ((DRM_RESULT)0x8004DA41L)
+
+/*
+ * MessageId: DRM_E_H264_NALU_EMULATION
+ *
+ * MessageText:
+ *
+ * Nalu-specific H264 parsing error
+ *
+ */
+#define DRM_E_H264_NALU_EMULATION        ((DRM_RESULT)0x8004DA42L)
+
+/*
+ * MessageId: DRM_E_H264_PPS_PPSID
+ *
+ * MessageText:
+ *
+ * PPS-specific H264 parsing error
+ *
+ */
+#define DRM_E_H264_PPS_PPSID             ((DRM_RESULT)0x8004DA50L)
+
+/*
+ * MessageId: DRM_E_H264_PPS_SPSID
+ *
+ * MessageText:
+ *
+ * PPS-specific H264 parsing error
+ *
+ */
+#define DRM_E_H264_PPS_SPSID             ((DRM_RESULT)0x8004DA51L)
+
+/*
+ * MessageId: DRM_E_H264_PPS_SPS_NOT_FOUND
+ *
+ * MessageText:
+ *
+ * PPS-specific H264 parsing error
+ *
+ */
+#define DRM_E_H264_PPS_SPS_NOT_FOUND     ((DRM_RESULT)0x8004DA52L)
+
+/*
+ * MessageId: DRM_E_H264_PPS_NUM_SLICE_GROUPS
+ *
+ * MessageText:
+ *
+ * PPS-specific H264 parsing error
+ *
+ */
+#define DRM_E_H264_PPS_NUM_SLICE_GROUPS  ((DRM_RESULT)0x8004DA53L)
+
+/*
+ * MessageId: DRM_E_H264_PPS_SLICE_GROUP_MAX
+ *
+ * MessageText:
+ *
+ * PPS-specific H264 parsing error
+ *
+ */
+#define DRM_E_H264_PPS_SLICE_GROUP_MAX   ((DRM_RESULT)0x8004DA54L)
+
+/*
+ * MessageId: DRM_E_H264_PPS_RUN_LENGTH
+ *
+ * MessageText:
+ *
+ * PPS-specific H264 parsing error
+ *
+ */
+#define DRM_E_H264_PPS_RUN_LENGTH        ((DRM_RESULT)0x8004DA55L)
+
+/*
+ * MessageId: DRM_E_H264_PPS_TOP_LEFT
+ *
+ * MessageText:
+ *
+ * PPS-specific H264 parsing error
+ *
+ */
+#define DRM_E_H264_PPS_TOP_LEFT          ((DRM_RESULT)0x8004DA56L)
+
+/*
+ * MessageId: DRM_E_H264_PPS_SLICE_GROUP_RATE
+ *
+ * MessageText:
+ *
+ * PPS-specific H264 parsing error
+ *
+ */
+#define DRM_E_H264_PPS_SLICE_GROUP_RATE  ((DRM_RESULT)0x8004DA57L)
+
+/*
+ * MessageId: DRM_E_H264_PPS_SLICE_GROUP_MAP
+ *
+ * MessageText:
+ *
+ * PPS-specific H264 parsing error
+ *
+ */
+#define DRM_E_H264_PPS_SLICE_GROUP_MAP   ((DRM_RESULT)0x8004DA58L)
+
+/*
+ * MessageId: DRM_E_H264_PPS_SLICE_GROUP_ID
+ *
+ * MessageText:
+ *
+ * PPS-specific H264 parsing error
+ *
+ */
+#define DRM_E_H264_PPS_SLICE_GROUP_ID    ((DRM_RESULT)0x8004DA59L)
+
+/*
+ * MessageId: DRM_E_H264_PPS_REF_IDX_L0
+ *
+ * MessageText:
+ *
+ * PPS-specific H264 parsing error
+ *
+ */
+#define DRM_E_H264_PPS_REF_IDX_L0        ((DRM_RESULT)0x8004DA5AL)
+
+/*
+ * MessageId: DRM_E_H264_PPS_REF_IDX_L1
+ *
+ * MessageText:
+ *
+ * PPS-specific H264 parsing error
+ *
+ */
+#define DRM_E_H264_PPS_REF_IDX_L1        ((DRM_RESULT)0x8004DA5BL)
+
+/*
+ * MessageId: DRM_E_H264_PPS_WEIGHTED_BIPRED
+ *
+ * MessageText:
+ *
+ * PPS-specific H264 parsing error
+ *
+ */
+#define DRM_E_H264_PPS_WEIGHTED_BIPRED   ((DRM_RESULT)0x8004DA5CL)
+
+/*
+ * MessageId: DRM_E_H264_PPS_PIC_INIT_QP
+ *
+ * MessageText:
+ *
+ * PPS-specific H264 parsing error
+ *
+ */
+#define DRM_E_H264_PPS_PIC_INIT_QP       ((DRM_RESULT)0x8004DA5DL)
+
+/*
+ * MessageId: DRM_E_H264_PPS_PIC_INIT_QS
+ *
+ * MessageText:
+ *
+ * PPS-specific H264 parsing error
+ *
+ */
+#define DRM_E_H264_PPS_PIC_INIT_QS       ((DRM_RESULT)0x8004DA5EL)
+
+/*
+ * MessageId: DRM_E_H264_PPS_PIC_CHROMA_QP
+ *
+ * MessageText:
+ *
+ * PPS-specific H264 parsing error
+ *
+ */
+#define DRM_E_H264_PPS_PIC_CHROMA_QP     ((DRM_RESULT)0x8004DA5FL)
+
+/*
+ * MessageId: DRM_E_H264_PPS_REDUN_PIC_COUNT
+ *
+ * MessageText:
+ *
+ * PPS-specific H264 parsing error
+ *
+ */
+#define DRM_E_H264_PPS_REDUN_PIC_COUNT   ((DRM_RESULT)0x8004DA61L)
+
+/*
+ * MessageId: DRM_E_H264_PPS_DELTA_SCALE1
+ *
+ * MessageText:
+ *
+ * PPS-specific H264 parsing error
+ *
+ */
+#define DRM_E_H264_PPS_DELTA_SCALE1      ((DRM_RESULT)0x8004DA62L)
+
+/*
+ * MessageId: DRM_E_H264_PPS_DELTA_SCALE2
+ *
+ * MessageText:
+ *
+ * PPS-specific H264 parsing error
+ *
+ */
+#define DRM_E_H264_PPS_DELTA_SCALE2      ((DRM_RESULT)0x8004DA63L)
+
+/*
+ * MessageId: DRM_E_H264_PPS_SECOND_CHROMA_QP
+ *
+ * MessageText:
+ *
+ * PPS-specific H264 parsing error
+ *
+ */
+#define DRM_E_H264_PPS_SECOND_CHROMA_QP  ((DRM_RESULT)0x8004DA64L)
+
+/*
+ * MessageId: DRM_E_H264_PPS_MORE_RBSP
+ *
+ * MessageText:
+ *
+ * PPS-specific H264 parsing error
+ *
+ */
+#define DRM_E_H264_PPS_MORE_RBSP         ((DRM_RESULT)0x8004DA65L)
+
+/*
+ * MessageId: DRM_E_H264_SH_SLICE_TYPE
+ *
+ * MessageText:
+ *
+ * Slice-Header-specific H264 parsing error
+ *
+ */
+#define DRM_E_H264_SH_SLICE_TYPE         ((DRM_RESULT)0x8004DA70L)
+
+/*
+ * MessageId: DRM_E_H264_SH_SLICE_TYPE_UNSUPPORTED
+ *
+ * MessageText:
+ *
+ * Slice-Header-specific H264 parsing error
+ *
+ */
+#define DRM_E_H264_SH_SLICE_TYPE_UNSUPPORTED ((DRM_RESULT)0x8004DA71L)
+
+/*
+ * MessageId: DRM_E_H264_SH_PPSID
+ *
+ * MessageText:
+ *
+ * Slice-Header-specific H264 parsing error
+ *
+ */
+#define DRM_E_H264_SH_PPSID              ((DRM_RESULT)0x8004DA72L)
+
+/*
+ * MessageId: DRM_E_H264_SH_PPS_NOT_FOUND
+ *
+ * MessageText:
+ *
+ * Slice-Header-specific H264 parsing error
+ *
+ */
+#define DRM_E_H264_SH_PPS_NOT_FOUND      ((DRM_RESULT)0x8004DA73L)
+
+/*
+ * MessageId: DRM_E_H264_SH_SPS_NOT_FOUND
+ *
+ * MessageText:
+ *
+ * Slice-Header-specific H264 parsing error
+ *
+ */
+#define DRM_E_H264_SH_SPS_NOT_FOUND      ((DRM_RESULT)0x8004DA74L)
+
+/*
+ * MessageId: DRM_E_H264_SH_SLICE_TYPE_PROFILE
+ *
+ * MessageText:
+ *
+ * Slice-Header-specific H264 parsing error
+ *
+ */
+#define DRM_E_H264_SH_SLICE_TYPE_PROFILE ((DRM_RESULT)0x8004DA75L)
+
+/*
+ * MessageId: DRM_E_H264_SH_IDR_FRAME_NUM
+ *
+ * MessageText:
+ *
+ * Slice-Header-specific H264 parsing error
+ *
+ */
+#define DRM_E_H264_SH_IDR_FRAME_NUM      ((DRM_RESULT)0x8004DA76L)
+
+/*
+ * MessageId: DRM_E_H264_SH_FIRST_MB_IN_SLICE
+ *
+ * MessageText:
+ *
+ * Slice-Header-specific H264 parsing error
+ *
+ */
+#define DRM_E_H264_SH_FIRST_MB_IN_SLICE  ((DRM_RESULT)0x8004DA77L)
+
+/*
+ * MessageId: DRM_E_H264_SH_IDR_PIC_ID
+ *
+ * MessageText:
+ *
+ * Slice-Header-specific H264 parsing error
+ *
+ */
+#define DRM_E_H264_SH_IDR_PIC_ID         ((DRM_RESULT)0x8004DA78L)
+
+/*
+ * MessageId: DRM_E_H264_SH_REDUN_PIC_COUNT
+ *
+ * MessageText:
+ *
+ * Slice-Header-specific H264 parsing error
+ *
+ */
+#define DRM_E_H264_SH_REDUN_PIC_COUNT    ((DRM_RESULT)0x8004DA79L)
+
+/*
+ * MessageId: DRM_E_H264_SH_NUM_REF_IDX_LX0
+ *
+ * MessageText:
+ *
+ * Slice-Header-specific H264 parsing error
+ *
+ */
+#define DRM_E_H264_SH_NUM_REF_IDX_LX0    ((DRM_RESULT)0x8004DA7AL)
+
+/*
+ * MessageId: DRM_E_H264_SH_NUM_REF_IDX_LX1
+ *
+ * MessageText:
+ *
+ * Slice-Header-specific H264 parsing error
+ *
+ */
+#define DRM_E_H264_SH_NUM_REF_IDX_LX1    ((DRM_RESULT)0x8004DA7BL)
+
+/*
+ * MessageId: DRM_E_H264_SH_REF_PIC_LIST_REORDER0
+ *
+ * MessageText:
+ *
+ * Slice-Header-specific H264 parsing error
+ *
+ */
+#define DRM_E_H264_SH_REF_PIC_LIST_REORDER0 ((DRM_RESULT)0x8004DA7CL)
+
+/*
+ * MessageId: DRM_E_H264_SH_REF_PIC_LIST_REORDER1
+ *
+ * MessageText:
+ *
+ * Slice-Header-specific H264 parsing error
+ *
+ */
+#define DRM_E_H264_SH_REF_PIC_LIST_REORDER1 ((DRM_RESULT)0x8004DA7DL)
+
+/*
+ * MessageId: DRM_E_H264_SH_LUMA_WEIGHT_DENOM
+ *
+ * MessageText:
+ *
+ * Slice-Header-specific H264 parsing error
+ *
+ */
+#define DRM_E_H264_SH_LUMA_WEIGHT_DENOM  ((DRM_RESULT)0x8004DA7EL)
+
+/*
+ * MessageId: DRM_E_H264_SH_CHROMA_WEIGHT_DENOM
+ *
+ * MessageText:
+ *
+ * Slice-Header-specific H264 parsing error
+ *
+ */
+#define DRM_E_H264_SH_CHROMA_WEIGHT_DENOM ((DRM_RESULT)0x8004DA7FL)
+
+/*
+ * MessageId: DRM_E_H264_SH_WP_WEIGHT_LUMA0
+ *
+ * MessageText:
+ *
+ * Slice-Header-specific H264 parsing error
+ *
+ */
+#define DRM_E_H264_SH_WP_WEIGHT_LUMA0    ((DRM_RESULT)0x8004DA80L)
+
+/*
+ * MessageId: DRM_E_H264_SH_WP_OFFSET_LUMA0
+ *
+ * MessageText:
+ *
+ * Slice-Header-specific H264 parsing error
+ *
+ */
+#define DRM_E_H264_SH_WP_OFFSET_LUMA0    ((DRM_RESULT)0x8004DA81L)
+
+/*
+ * MessageId: DRM_E_H264_SH_WP_WEIGHT_CHROMA0
+ *
+ * MessageText:
+ *
+ * Slice-Header-specific H264 parsing error
+ *
+ */
+#define DRM_E_H264_SH_WP_WEIGHT_CHROMA0  ((DRM_RESULT)0x8004DA82L)
+
+/*
+ * MessageId: DRM_E_H264_SH_WP_OFFSET_CHROMA0
+ *
+ * MessageText:
+ *
+ * Slice-Header-specific H264 parsing error
+ *
+ */
+#define DRM_E_H264_SH_WP_OFFSET_CHROMA0  ((DRM_RESULT)0x8004DA83L)
+
+/*
+ * MessageId: DRM_E_H264_SH_WP_WEIGHT_LUMA1
+ *
+ * MessageText:
+ *
+ * Slice-Header-specific H264 parsing error
+ *
+ */
+#define DRM_E_H264_SH_WP_WEIGHT_LUMA1    ((DRM_RESULT)0x8004DA84L)
+
+/*
+ * MessageId: DRM_E_H264_SH_WP_OFFSET_LUMA1
+ *
+ * MessageText:
+ *
+ * Slice-Header-specific H264 parsing error
+ *
+ */
+#define DRM_E_H264_SH_WP_OFFSET_LUMA1    ((DRM_RESULT)0x8004DA85L)
+
+/*
+ * MessageId: DRM_E_H264_SH_WP_WEIGHT_CHROMA1
+ *
+ * MessageText:
+ *
+ * Slice-Header-specific H264 parsing error
+ *
+ */
+#define DRM_E_H264_SH_WP_WEIGHT_CHROMA1  ((DRM_RESULT)0x8004DA86L)
+
+/*
+ * MessageId: DRM_E_H264_SH_WP_OFFSET_CHROMA1
+ *
+ * MessageText:
+ *
+ * Slice-Header-specific H264 parsing error
+ *
+ */
+#define DRM_E_H264_SH_WP_OFFSET_CHROMA1  ((DRM_RESULT)0x8004DA87L)
+
+/*
+ * MessageId: DRM_E_H264_SH_NUM_REF_PIC_MARKING
+ *
+ * MessageText:
+ *
+ * Slice-Header-specific H264 parsing error
+ *
+ */
+#define DRM_E_H264_SH_NUM_REF_PIC_MARKING ((DRM_RESULT)0x8004DA88L)
+
+/*
+ * MessageId: DRM_E_H264_SH_MMCO4_DUPLICATE
+ *
+ * MessageText:
+ *
+ * Slice-Header-specific H264 parsing error
+ *
+ */
+#define DRM_E_H264_SH_MMCO4_DUPLICATE    ((DRM_RESULT)0x8004DA89L)
+
+/*
+ * MessageId: DRM_E_H264_SH_MMCO4_MAX_LONG_TERM_FRAME
+ *
+ * MessageText:
+ *
+ * Slice-Header-specific H264 parsing error
+ *
+ */
+#define DRM_E_H264_SH_MMCO4_MAX_LONG_TERM_FRAME ((DRM_RESULT)0x8004DA8AL)
+
+/*
+ * MessageId: DRM_E_H264_SH_MMCO5_DUPLICATE
+ *
+ * MessageText:
+ *
+ * Slice-Header-specific H264 parsing error
+ *
+ */
+#define DRM_E_H264_SH_MMCO5_DUPLICATE    ((DRM_RESULT)0x8004DA8BL)
+
+/*
+ * MessageId: DRM_E_H264_SH_MMCO5_FOLLOWS_MMC06
+ *
+ * MessageText:
+ *
+ * Slice-Header-specific H264 parsing error
+ *
+ */
+#define DRM_E_H264_SH_MMCO5_FOLLOWS_MMC06 ((DRM_RESULT)0x8004DA8CL)
+
+/*
+ * MessageId: DRM_E_H264_SH_MMCO5_COEXIST_MMCO_1_OR_3
+ *
+ * MessageText:
+ *
+ * Slice-Header-specific H264 parsing error
+ *
+ */
+#define DRM_E_H264_SH_MMCO5_COEXIST_MMCO_1_OR_3 ((DRM_RESULT)0x8004DA8DL)
+
+/*
+ * MessageId: DRM_E_H264_SH_MMCO6_DUPLICATE
+ *
+ * MessageText:
+ *
+ * Slice-Header-specific H264 parsing error
+ *
+ */
+#define DRM_E_H264_SH_MMCO6_DUPLICATE    ((DRM_RESULT)0x8004DA8EL)
+
+/*
+ * MessageId: DRM_E_H264_SH_MODEL_NUMBER
+ *
+ * MessageText:
+ *
+ * Slice-Header-specific H264 parsing error
+ *
+ */
+#define DRM_E_H264_SH_MODEL_NUMBER       ((DRM_RESULT)0x8004DA8FL)
+
+/*
+ * MessageId: DRM_E_H264_SH_SLICE_QP
+ *
+ * MessageText:
+ *
+ * Slice-Header-specific H264 parsing error
+ *
+ */
+#define DRM_E_H264_SH_SLICE_QP           ((DRM_RESULT)0x8004DA90L)
+
+/*
+ * MessageId: DRM_E_H264_SH_LF_ALPHA_C0_OFFSET
+ *
+ * MessageText:
+ *
+ * Slice-Header-specific H264 parsing error
+ *
+ */
+#define DRM_E_H264_SH_LF_ALPHA_C0_OFFSET ((DRM_RESULT)0x8004DA91L)
+
+/*
+ * MessageId: DRM_E_H264_SH_LF_BETA_OFFSET
+ *
+ * MessageText:
+ *
+ * Slice-Header-specific H264 parsing error
+ *
+ */
+#define DRM_E_H264_SH_LF_BETA_OFFSET     ((DRM_RESULT)0x8004DA92L)
+
+/*
+ * MessageId: DRM_E_H264_SH_SLICE_GROUP_CHANGE
+ *
+ * MessageText:
+ *
+ * Slice-Header-specific H264 parsing error
+ *
+ */
+#define DRM_E_H264_SH_SLICE_GROUP_CHANGE ((DRM_RESULT)0x8004DA93L)
+
+
+#define DRM_E_H264_MAXIMUM DRM_E_H264_SH_SLICE_GROUP_CHANGE
+
+/* ------------------------------------------------------------
+**
+** Provisioning errors: error codes from DRM_E_BASECODE + 0x1B00 to
+** DRM_E_BASECODE + 0x1Bff, 0x8004db00-0x8004dbff.
+**
+** ------------------------------------------------------------
+*/
+#define DRM_E_RPROV_BASECODE      (DRM_E_BASECODE + 0x1B00)
+#define DRM_E_RPROV_FINALCODE     (DRM_E_BASECODE + 0x1BFF)
+
+/*
+ * MessageId: DRM_E_RPROV_INVALID_REQUEST
+ *
+ * MessageText:
+ *
+ * Invalid Remote provisioning request received.
+ *
+ */
+#define DRM_E_RPROV_INVALID_REQUEST      ((DRM_RESULT)0x8004DB00L)
+
+/*
+ * MessageId: DRM_E_RPROV_VERSION_MISSMATCH
+ *
+ * MessageText:
+ *
+ * Invalid Remote provisioning version received.
+ *
+ */
+#define DRM_E_RPROV_VERSION_MISSMATCH    ((DRM_RESULT)0x8004DB01L)
+
+/*
+ * MessageId: DRM_E_RPROV_INVALID_RESPONSE
+ *
+ * MessageText:
+ *
+ * Invalid response received.
+ *
+ */
+#define DRM_E_RPROV_INVALID_RESPONSE     ((DRM_RESULT)0x8004DB02L)
+
+/*
+ * MessageId: DRM_E_RPROV_BOOTSTRAP_FAILURE
+ *
+ * MessageText:
+ *
+ * Remote provisioning bootstrap failed.
+ *
+ */
+#define DRM_E_RPROV_BOOTSTRAP_FAILURE    ((DRM_RESULT)0x8004DB03L)
+
+/*
+ * MessageId: DRM_E_FIRMWARE_REVOKED
+ *
+ * MessageText:
+ *
+ * TEE Firmware is revoked; firmware update necessary.
+ *
+ */
+#define DRM_E_FIRMWARE_REVOKED           ((DRM_RESULT)0x8004DB04L)
+
+/*
+ * MessageId: DRM_E_RPROV_SKIP_BOOTSTRAP
+ *
+ * MessageText:
+ *
+ * Remote provisioning does not need bootstrap.
+ *
+ */
+#define DRM_E_RPROV_SKIP_BOOTSTRAP       ((DRM_RESULT)0x8004DB05L)
+
+
+/* ============================================================
+**
+** Secure stop errors: error codes from DRM_E_BASECODE + 0x1C00 to
+** DRM_E_BASECODE + 0x1CFF, 0x8004dc00-0x8004dc7f.
+**
+** ============================================================
+*/
+
+#define DRM_E_SECURESTOP_BASECODE  (DRM_E_BASECODE + 0x1C00)
+#define DRM_E_SECURESTOP_FINALCODE (DRM_E_BASECODE + 0x1C7F)
+
+/*
+ * MessageId: DRM_E_SECURESTOP_STORE_CORRUPT
+ *
+ * MessageText:
+ *
+ * The secure stop store is corrupted.
+ *
+ */
+#define DRM_E_SECURESTOP_STORE_CORRUPT   ((DRM_RESULT)0x8004DC00L)
+
+/*
+ * MessageId: DRM_E_SECURESTOP_SESSION_LOCKED
+ *
+ * MessageText:
+ *
+ * The secure stop session is locked and may not be modified.
+ *
+ */
+#define DRM_E_SECURESTOP_SESSION_LOCKED  ((DRM_RESULT)0x8004DC02L)
+
+/*
+ * MessageId: DRM_E_SECURESTOP_SESSION_CORRUPT
+ *
+ * MessageText:
+ *
+ * The secure stop session data is corrupted.
+ *
+ */
+#define DRM_E_SECURESTOP_SESSION_CORRUPT ((DRM_RESULT)0x8004DC03L)
+
+/*
+ * MessageId: DRM_E_SECURESTOP_SESSION_ACTIVE
+ *
+ * MessageText:
+ *
+ * The secure stop session is active and cannot be locked.
+ *
+ */
+#define DRM_E_SECURESTOP_SESSION_ACTIVE  ((DRM_RESULT)0x8004DC04L)
+
+/*
+ * MessageId: DRM_E_SECURESTOP_SESSION_NOT_FOUND
+ *
+ * MessageText:
+ *
+ * The secure stop session could not be found in the data store.
+ *
+ */
+#define DRM_E_SECURESTOP_SESSION_NOT_FOUND ((DRM_RESULT)0x8004DC05L)
+
+/*
+ * MessageId: DRM_E_SECURESTOP_INVALID_RESPONSE
+ *
+ * MessageText:
+ *
+ * The secure stop response is invalid.
+ *
+ */
+#define DRM_E_SECURESTOP_INVALID_RESPONSE ((DRM_RESULT)0x8004DC06L)
+
+/*
+ * MessageId: DRM_E_SECURESTOP_SESSION_STOPPED
+ *
+ * MessageText:
+ *
+ * The secure stop session is stopped and may not be used for decryption.
+ *
+ */
+#define DRM_E_SECURESTOP_SESSION_STOPPED ((DRM_RESULT)0x8004DC07L)
+
+/*
+ * MessageId: DRM_E_SECURESTOP_INVALID_PUBLISHER_ID
+ *
+ * MessageText:
+ *
+ * Trying to generate a challenge with a publisher ID that doesn't match the one associated with the session.
+ *
+ */
+#define DRM_E_SECURESTOP_INVALID_PUBLISHER_ID ((DRM_RESULT)0x8004DC08L)
+
+/*
+ * MessageId: DRM_E_SECURESTOP_PUBLISHER_ID_INCONSISTENT
+ *
+ * MessageText:
+ *
+ * Licenses acquired within the same session don't have the same secure stop publisher ID.
+ *
+ */
+#define DRM_E_SECURESTOP_PUBLISHER_ID_INCONSISTENT ((DRM_RESULT)0x8004DC09L)
+
+/*
+ * MessageId: DRM_E_SECURESTOP_INCONSISTENT
+ *
+ * MessageText:
+ *
+ * Some licenses acquired within the same session have secure stop while others don't.
+ *
+ */
+#define DRM_E_SECURESTOP_INCONSISTENT    ((DRM_RESULT)0x8004DC0AL)
+
+/* ============================================================
+**
+** 0x8004dc80 to 0x8004ddff are reserved for OEM-defined errors
+**
+** ============================================================
+*/
+
+/* Nothing should be added here - Reserved for OEM error codes. */
+
+
+/* ============================================================
+**
+** Secure time errors: error codes from DRM_E_BASECODE + 0x1E00 to
+** DRM_E_BASECODE + 0x1EFF, 0x8004de00-0x8004deff.
+**
+** ============================================================
+*/
+
+#define DRM_E_SECURETIME_BASECODE  (DRM_E_BASECODE + 0x1E00)
+#define DRM_E_SECURETIME_FINALCODE (DRM_E_BASECODE + 0x1EFF)
+
+/*
+ * MessageId: DRM_E_SECURETIME_INVALID_REQUEST_DATA
+ *
+ * MessageText:
+ *
+ * The secure time client request data is invalid.
+ *
+ */
+#define DRM_E_SECURETIME_INVALID_REQUEST_DATA ((DRM_RESULT)0x8004DE00L)
+
+/*
+ * MessageId: DRM_E_SECURETIME_CLOCK_NOT_SET
+ *
+ * MessageText:
+ *
+ * The secure time clock has not been set.
+ *
+ */
+#define DRM_E_SECURETIME_CLOCK_NOT_SET   ((DRM_RESULT)0x8004DE01L)
+
+/*
+ * MessageId: DRM_E_SECURETIME_RESPONSE_TIMEOUT
+ *
+ * MessageText:
+ *
+ * The secure time server response timed out.
+ *
+ */
+#define DRM_E_SECURETIME_RESPONSE_TIMEOUT ((DRM_RESULT)0x8004DE02L)
+
+/*
+ * MessageId: DRM_E_SECURETIME_SERVER_SECURITY_LEVEL_TOO_LOW
+ *
+ * MessageText:
+ *
+ * The secure time server's security level is too low for the client.
+ *
+ */
+#define DRM_E_SECURETIME_SERVER_SECURITY_LEVEL_TOO_LOW ((DRM_RESULT)0x8004DE03L)
+
+
+/* ============================================================
+**
+** LSRD errors: error codes from DRM_E_BASECODE + 0x1F00 to
+** DRM_E_BASECODE + 0x1F05, 0x8004df00-0x8004df05.
+**
+** ============================================================
+*/
+
+#define DRM_E_LSRD_BASECODE  (DRM_E_BASECODE + 0x1F00)
+#define DRM_E_LSRD_FINALCODE (DRM_E_BASECODE + 0x1F05)
+
+/*
+ * MessageId: DRM_E_LSRD_DETECTED
+ *
+ * MessageText:
+ *
+ * HDS file rollback is detected.
+ *
+ */
+#define DRM_E_LSRD_DETECTED              ((DRM_RESULT)0x8004DF00L)
+
+/*
+ * MessageId: DRM_E_LSRD_INVALID_ACL
+ *
+ * MessageText:
+ *
+ * The ACL of the HDS Registry Subkey is invalid.
+ *
+ */
+#define DRM_E_LSRD_INVALID_ACL           ((DRM_RESULT)0x8004DF01L)
+
+/*
+ * MessageId: DRM_E_LSRD_DETECTION_IN_PROGRESS
+ *
+ * MessageText:
+ *
+ * The client is currently processing LSRD check operation. Concurrent operations are not allowed.
+ *
+ */
+#define DRM_E_LSRD_DETECTION_IN_PROGRESS ((DRM_RESULT)0x8004DF02L)
+
+/*
+ * MessageId: DRM_E_LSRD_ACL_NOT_PRESENT
+ *
+ * MessageText:
+ *
+ * The security descriptor does not contain an ACL.
+ *
+ */
+#define DRM_E_LSRD_ACL_NOT_PRESENT       ((DRM_RESULT)0x8004DF03L)
+
+/*
+ * MessageId: DRM_E_LSRD_INVALID_COMMAND
+ *
+ * MessageText:
+ *
+ * The PlayReady Process received an invalid command.
+ *
+ */
+#define DRM_E_LSRD_INVALID_COMMAND       ((DRM_RESULT)0x8004DF04L)
+
+/*
+ * MessageId: DRM_E_LSRD_SEQUENCE_NUMBER_IS_AT_MAX_LIMIT
+ *
+ * MessageText:
+ *
+ * The LSRD sequence number has reached its maximum limit.
+ *
+ */
+#define DRM_E_LSRD_SEQUENCE_NUMBER_IS_AT_MAX_LIMIT ((DRM_RESULT)0x8004DF05L)
+
+
+/* ============================================================
+**
+** Secure Delete errors: error codes from DRM_E_BASECODE + 0x1FA0 to
+** DRM_E_BASECODE + 0x1FAF, 0x8004dfa0-0x8004dfaf.
+**
+** ============================================================
+*/
+
+#define DRM_E_SECUREDELETE_BASECODE  (DRM_E_BASECODE + 0x1FA0)
+#define DRM_E_SECUREDELETE_FINALCODE (DRM_E_BASECODE + 0x1FAF)
+
+/*
+ * MessageId: DRM_E_SECUREDELETE_INVALID_RESPONSE
+ *
+ * MessageText:
+ *
+ * The secure delete response is invalid.
+ *
+ */
+#define DRM_E_SECUREDELETE_INVALID_RESPONSE ((DRM_RESULT)0x8004DFA0L)
+
+
+/* ------------------------------------------------------------
+**
+** Available range 0x8004dfb0-0x8004dfff.
+**
+** ------------------------------------------------------------
+*/
+
+/* Insert new PKCore sub-error facilities here */
+
+
+/* ============================================================
+**
+** PC specific errors (from 0x8004e000 to 0x8004ffff)
+**
+** ============================================================
+*/
+
+/* Nothing should be added here - PC error codes are not here. */
+
+
+/* ============================================================
+**
+** Deprecated errors.  Returned in previous versions of PlayReady but not in the current version.
+** Note: No new error codes should be defined with the same values as these.
+**
+** ============================================================
+*/
+
+#define DRM_E_DEPRECATED_CH_ATTR_MISSING                                           ((DRM_RESULT)0x80041107L)
+#define DRM_E_DEPRECATED_CH_UNSUPPORTED_HASH_ALGORITHM                             ((DRM_RESULT)0x8004110CL)
+#define DRM_E_DEPRECATED_CH_UNSUPPORTED_SIGN_ALGORITHM                             ((DRM_RESULT)0x8004110DL)
+#define DRM_E_DEPRECATED_CH_NOT_SIGNED                                             ((DRM_RESULT)0x80041113L)
+#define DRM_E_DEPRECATED_CH_UNKNOWN_ERROR                                          ((DRM_RESULT)0x80041116L)
+#define DRM_E_DEPRECATED_LIC_INIT_FAILURE                                          ((DRM_RESULT)0x80041201L)
+#define DRM_E_DEPRECATED_LIC_LICENSE_NOTSET                                        ((DRM_RESULT)0x80041202L)
+#define DRM_E_DEPRECATED_LIC_PARAM_NOT_OPTIONAL                                    ((DRM_RESULT)0x80041203L)
+#define DRM_E_DEPRECATED_LIC_MEMORY_ALLOCATION_ERROR                               ((DRM_RESULT)0x80041204L)
+#define DRM_E_DEPRECATED_LIC_INVALID_LICENSE                                       ((DRM_RESULT)0x80041205L)
+#define DRM_E_DEPRECATED_LIC_FIELD_MISSING                                         ((DRM_RESULT)0x80041206L)
+#define DRM_E_DEPRECATED_LIC_UNKNOWN_ERROR                                         ((DRM_RESULT)0x80041208L)
+#define DRM_E_DEPRECATED_LIC_INVALID_REVLIST                                       ((DRM_RESULT)0x80041209L)
+#define DRM_E_DEPRECATED_LIC_EXPIRED_CERT                                          ((DRM_RESULT)0x8004120AL)
+#define DRM_E_DEPRECATED_CPRMEXP_NOERROR                                           ((DRM_RESULT)0x80041400L)
+#define DRM_E_DEPRECATED_CPRMEXP_PARAM_NOT_OPTIONAL                                ((DRM_RESULT)0x80041401L)
+#define DRM_E_DEPRECATED_CPRMEXP_MEMORY_ALLOCATION_ERROR                           ((DRM_RESULT)0x80041402L)
+#define DRM_E_DEPRECATED_CPRMEXP_NO_OPERANDS_IN_EXPRESSION                         ((DRM_RESULT)0x80041403L)
+#define DRM_E_DEPRECATED_CPRMEXP_INVALID_TOKEN                                     ((DRM_RESULT)0x80041404L)
+#define DRM_E_DEPRECATED_CPRMEXP_INVALID_CONSTANT                                  ((DRM_RESULT)0x80041405L)
+#define DRM_E_DEPRECATED_CPRMEXP_INVALID_VARIABLE                                  ((DRM_RESULT)0x80041406L)
+#define DRM_E_DEPRECATED_CPRMEXP_INVALID_FUNCTION                                  ((DRM_RESULT)0x80041407L)
+#define DRM_E_DEPRECATED_CPRMEXP_INVALID_ARGUMENT                                  ((DRM_RESULT)0x80041408L)
+#define DRM_E_DEPRECATED_CPRMEXP_INVALID_CONTEXT                                   ((DRM_RESULT)0x80041409L)
+#define DRM_E_DEPRECATED_CPRMEXP_ENDOFBUFFER                                       ((DRM_RESULT)0x8004140AL)
+#define DRM_E_DEPRECATED_CPRMEXP_MISSING_OPERAND                                   ((DRM_RESULT)0x8004140BL)
+#define DRM_E_DEPRECATED_CPRMEXP_OVERFLOW                                          ((DRM_RESULT)0x8004140CL)
+#define DRM_E_DEPRECATED_CPRMEXP_UNDERFLOW                                         ((DRM_RESULT)0x8004140DL)
+#define DRM_E_DEPRECATED_CPRMEXP_INCORRECT_NUM_ARGS                                ((DRM_RESULT)0x8004140EL)
+#define DRM_E_DEPRECATED_CPRMEXP_VARIABLE_EXPECTED                                 ((DRM_RESULT)0x8004140FL)
+#define DRM_E_DEPRECATED_CPRMEXP_RETRIEVAL_FAILURE                                 ((DRM_RESULT)0x80041410L)
+#define DRM_E_DEPRECATED_CPRMEXP_UPDATE_FAILURE                                    ((DRM_RESULT)0x80041411L)
+#define DRM_E_DEPRECATED_CPRMEXP_STRING_UNTERMINATED                               ((DRM_RESULT)0x80041412L)
+#define DRM_E_DEPRECATED_CPRMEXP_UPDATE_UNSUPPORTED                                ((DRM_RESULT)0x80041413L)
+#define DRM_E_DEPRECATED_CPRMEXP_ISOLATED_OPERAND_OR_OPERATOR                      ((DRM_RESULT)0x80041414L)
+#define DRM_E_DEPRECATED_CPRMEXP_UNMATCHED                                         ((DRM_RESULT)0x80041415L)
+#define DRM_E_DEPRECATED_CPRMEXP_WRONG_TYPE_OPERAND                                ((DRM_RESULT)0x80041416L)
+#define DRM_E_DEPRECATED_CPRMEXP_TOO_MANY_OPERANDS                                 ((DRM_RESULT)0x80041417L)
+#define DRM_E_DEPRECATED_CPRMEXP_UNKNOWN_PARSE_ERROR                               ((DRM_RESULT)0x80041418L)
+#define DRM_E_DEPRECATED_CPRMEXP_UNSUPPORTED_FUNCTION                              ((DRM_RESULT)0x80041419L)
+#define DRM_E_DEPRECATED_CPRMEXP_CLOCK_REQUIRED                                    ((DRM_RESULT)0x8004141AL)
+#define DRM_E_DEPRECATED_LIC_SIGNATURE_FAILURE                                     ((DRM_RESULT)0x80048008L)
+#define DRM_E_DEPRECATED_LIC_KEY_AND_CERT_MISMATCH                                 ((DRM_RESULT)0x80048013L)
+#define DRM_E_DEPRECATED_SYNC_ENTRY_NOT_FOUND                                      ((DRM_RESULT)0x800480D0L)
+#define DRM_E_DEPRECATED_STACK_TOO_SMALL                                           ((DRM_RESULT)0x800480D1L)
+#define DRM_E_DEPRECATED_EXPIRED_CERT                                              ((DRM_RESULT)0x80049006L)
+#define DRM_E_DEPRECATED_DRMUTIL_INVALID_CERT                                      ((DRM_RESULT)0x80049007L)
+#define DRM_E_DEPRECATED_DEVICE_NOT_REGISTERED                                     ((DRM_RESULT)0x8004A000L)
+#define DRM_E_DEPRECATED_TOO_MANY_INCLUSION_GUIDS                                  ((DRM_RESULT)0x8004A001L)
+#define DRM_E_DEPRECATED_CONTRACT_FAILED                                           ((DRM_RESULT)0x8004A006L)
+#define DRM_E_DEPRECATED_INVALID_LICENSE_REVOCATION_LIST_SIGNATURE                 ((DRM_RESULT)0x8004A014L)
+#define DRM_E_DEPRECATED_INVALID_METERCERT_SIGNATURE                               ((DRM_RESULT)0x8004A015L)
+#define DRM_E_DEPRECATED_NO_LICENSES_TO_SYNC                                       ((DRM_RESULT)0x8004A017L)
+#define DRM_E_DEPRECATED_INVALID_SLK                                               ((DRM_RESULT)0x8004A01CL)
+#define DRM_E_DEPRECATED_DEVCERT_MODEL_MISMATCH                                    ((DRM_RESULT)0x8004A01DL)
+#define DRM_E_DEPRECATED_DSTR_NOT_FOUND                                            ((DRM_RESULT)0x8004A01FL)
+#define DRM_E_DEPRECATED_INVALID_RIGHT                                             ((DRM_RESULT)0x8004C003L)
+#define DRM_E_DEPRECATED_INCOMPATABLE_LICENSE_SIZE                                 ((DRM_RESULT)0x8004C004L)
+#define DRM_E_DEPRECATED_INVALID_LICENSE_FLAGS                                     ((DRM_RESULT)0x8004C005L)
+#define DRM_E_DEPRECATED_CONDITION_FAIL                                            ((DRM_RESULT)0x8004C007L)
+#define DRM_E_DEPRECATED_CONDITION_NOT_SUPPORTED                                   ((DRM_RESULT)0x8004C008L)
+#define DRM_E_DEPRECATED_LICENSE_NOT_YET_VALID                                     ((DRM_RESULT)0x8004C00AL)
+#define DRM_E_DEPRECATED_LICENSE_MISMATCH                                          ((DRM_RESULT)0x8004C00CL)
+#define DRM_E_DEPRECATED_NO_RIGHTS_REQUESTED                                       ((DRM_RESULT)0x8004C00EL)
+#define DRM_E_DEPRECATED_INVALID_TIME                                              ((DRM_RESULT)0x8004C011L)
+#define DRM_E_DEPRECATED_LICENSESTORE_NOT_FOUND                                    ((DRM_RESULT)0x8004C012L)
+#define DRM_E_DEPRECATED_INVALID_BIND_ID                                           ((DRM_RESULT)0x8004C015L)
+#define DRM_E_DEPRECATED_ALGORITHM_NOT_SET                                         ((DRM_RESULT)0x8004C017L)
+#define DRM_E_DEPRECATED_LICENSE_SERVER_NEEDS_KEY                                  ((DRM_RESULT)0x8004C018L)
+#define DRM_E_DEPRECATED_CLIENT_TIME_INVALID                                       ((DRM_RESULT)0x8004C01CL)
+#define DRM_E_DEPRECATED_DST_NAMESPACE_FULL                                        ((DRM_RESULT)0x8004C022L)
+#define DRM_E_DEPRECATED_DST_NAMESPACE_IN_USE                                      ((DRM_RESULT)0x8004C028L)
+#define DRM_E_DEPRECATED_NO_ACTION_IN_LICENSE_REQUEST                              ((DRM_RESULT)0x8004C02CL)
+#define DRM_E_DEPRECATED_BACKUP_EXISTS                                             ((DRM_RESULT)0x8004C032L)
+#define DRM_E_DEPRECATED_LICENSE_TOO_LONG                                          ((DRM_RESULT)0x8004C033L)
+#define DRM_E_DEPRECATED_DST_RESERVED_KEY_DETECTED                                 ((DRM_RESULT)0x8004C03AL)
+#define DRM_E_DEPRECATED_V1_NOT_SUPPORTED                                          ((DRM_RESULT)0x8004C03BL)
+#define DRM_E_DEPRECATED_NEED_DEVCERT_INDIV                                        ((DRM_RESULT)0x8004C03DL)
+#define DRM_E_DEPRECATED_CLK_INVALID_DATE                                          ((DRM_RESULT)0x8004C040L)
+#define DRM_E_DEPRECATED_CLK_UNSUPPORTED_VALUE                                     ((DRM_RESULT)0x8004C041L)
+#define DRM_E_DEPRECATED_INVALID_DEVCERT_TEMPLATE                                  ((DRM_RESULT)0x8004C042L)
+#define DRM_E_DEPRECATED_DEVCERT_TEMPLATE_EXCEEDS_SIZE_LIMIT                       ((DRM_RESULT)0x8004C044L)
+#define DRM_E_DEPRECATED_DEVCERT_READ_ERROR                                        ((DRM_RESULT)0x8004C045L)
+#define DRM_E_DEPRECATED_DEVCERT_WRITE_ERROR                                       ((DRM_RESULT)0x8004C046L)
+#define DRM_E_DEPRECATED_PRIVKEY_WRITE_ERROR                                       ((DRM_RESULT)0x8004C048L)
+#define DRM_E_DEPRECATED_DEVCERT_INDIV_NOT_SUPPORTED                               ((DRM_RESULT)0x8004C04BL)
+#define DRM_E_DEPRECATED_CLK_RESET_STATE_READ_ERROR                                ((DRM_RESULT)0x8004C04DL)
+#define DRM_E_DEPRECATED_CLK_RESET_STATE_WRITE_ERROR                               ((DRM_RESULT)0x8004C04EL)
+#define DRM_E_DEPRECATED_METERING_INVALID_COMMAND                                  ((DRM_RESULT)0x8004C051L)
+#define DRM_E_DEPRECATED_UNKNOWN_BINDING_KEY                                       ((DRM_RESULT)0x8004C056L)
+#define DRM_E_DEPRECATED_WRONG_TOKEN_TYPE                                          ((DRM_RESULT)0x8004C058L)
+#define DRM_E_DEPRECATED_POLICY_METERING_DISABLED                                  ((DRM_RESULT)0x8004C059L)
+#define DRM_E_DEPRECATED_POLICY_ONLINE_DISABLED                                    ((DRM_RESULT)0x8004C05AL)
+#define DRM_E_DEPRECATED_METERING_MID_MISMATCH                                     ((DRM_RESULT)0x8004C05FL)
+#define DRM_E_DEPRECATED_METERING_RESPONSE_DECRYPT_FAILED                          ((DRM_RESULT)0x8004C060L)
+#define DRM_E_DEPRECATED_INVALID_DEVSTORE_ATTRIBUTE                                ((DRM_RESULT)0x8004C067L)
+#define DRM_E_DEPRECATED_INVALID_DEVSTORE_ENTRY                                    ((DRM_RESULT)0x8004C068L)
+#define DRM_E_DEPRECATED_PRECISION_ARITHMETIC_FAIL                                 ((DRM_RESULT)0x8004C06CL)
+#define DRM_E_DEPRECATED_REVOCATION_NOT_SUPPORTED                                  ((DRM_RESULT)0x8004C071L)
+#define DRM_E_DEPRECATED_DISK_SPACE_ERROR                                          ((DRM_RESULT)0x8004C081L)
+#define DRM_E_DEPRECATED_LRB_NO_LGPUBKEY                                           ((DRM_RESULT)0x8004C0A0L)
+#define DRM_E_DEPRECATED_LRB_INVALID_SIGNATURE                                     ((DRM_RESULT)0x8004C0A1L)
+#define DRM_E_DEPRECATED_LRB_LGPUBKEY_MISMATCH                                     ((DRM_RESULT)0x8004C0A2L)
+#define DRM_E_DEPRECATED_LRB_INVALID_LICENSE_DATA                                  ((DRM_RESULT)0x8004C0A3L)
+#define DRM_E_DEPRECATED_LICEVAL_LICENSE_REVOKED                                   ((DRM_RESULT)0x8004C0C2L)
+#define DRM_E_DEPRECATED_LICEVAL_UPDATE_FAILURE                                    ((DRM_RESULT)0x8004C0C3L)
+#define DRM_E_DEPRECATED_LICEVAL_INVALID_PRND_LICENSE                              ((DRM_RESULT)0x8004C0C5L)
+#define DRM_E_DEPRECATED_XMR_OBJECT_ALREADY_EXISTS                                 ((DRM_RESULT)0x8004C0E0L)
+#define DRM_E_DEPRECATED_XMR_OBJECT_NOT_FOUND                                      ((DRM_RESULT)0x8004C0E1L)
+#define DRM_E_DEPRECATED_XMR_INVALID_UNKNOWN_OBJECT                                ((DRM_RESULT)0x8004C0E3L)
+#define DRM_E_DEPRECATED_XMR_LICENSE_BINDABLE                                      ((DRM_RESULT)0x8004C0E4L)
+#define DRM_E_DEPRECATED_XMR_UNSUPPORTED_XMR_VERSION                               ((DRM_RESULT)0x8004C0E6L)
+#define DRM_E_DEPRECATED_NOT_CRL_BLOB                                              ((DRM_RESULT)0x8004C100L)
+#define DRM_E_DEPRECATED_BAD_CRL_BLOB                                              ((DRM_RESULT)0x8004C101L)
+#define DRM_E_DEPRECATED_TEST_PKCRYPTO_FAILURE                                     ((DRM_RESULT)0x8004C300L)
+#define DRM_E_DEPRECATED_TEST_PKSIGN_VERIFY_ERROR                                  ((DRM_RESULT)0x8004C301L)
+#define DRM_E_DEPRECATED_TEST_DESKEY_FAILED                                        ((DRM_RESULT)0x8004C305L)
+#define DRM_E_DEPRECATED_TEST_CBC_INVERSEMAC_FAILURE                               ((DRM_RESULT)0x8004C306L)
+#define DRM_E_DEPRECATED_TEST_DEVICE_PRIVATE_KEY_INCORRECTLY_STORED                ((DRM_RESULT)0x8004C30AL)
+#define DRM_E_DEPRECATED_TEST_DRMMANAGER_CONTEXT_NULL                              ((DRM_RESULT)0x8004C30BL)
+#define DRM_E_DEPRECATED_TEST_LICENSE_STATE_MISMATCH                               ((DRM_RESULT)0x8004C313L)
+#define DRM_E_DEPRECATED_TEST_LICENSE_RESPONSE_ERROR                               ((DRM_RESULT)0x8004C31AL)
+#define DRM_E_DEPRECATED_TEST_DLA_NO_CONTENT_HEADER                                ((DRM_RESULT)0x8004C31FL)
+#define DRM_E_DEPRECATED_TEST_DLA_CONTENT_HEADER_FOUND                             ((DRM_RESULT)0x8004C320L)
+#define DRM_E_DEPRECATED_TEST_SYNC_LSD_INCORRECT                                   ((DRM_RESULT)0x8004C321L)
+#define DRM_E_DEPRECATED_TEST_DEVICE_NOT_INITED                                    ((DRM_RESULT)0x8004C324L)
+#define DRM_E_DEPRECATED_TEST_LICENSE_ACQ_FAILED                                   ((DRM_RESULT)0x8004C328L)
+#define DRM_E_DEPRECATED_TEST_INVALID_DEVICE_WRAPPER                               ((DRM_RESULT)0x8004C331L)
+#define DRM_E_DEPRECATED_TEST_INVALID_WMDM_WRAPPER                                 ((DRM_RESULT)0x8004C332L)
+#define DRM_E_DEPRECATED_TEST_INVALID_WPD_WRAPPER                                  ((DRM_RESULT)0x8004C333L)
+#define DRM_E_DEPRECATED_TEST_PROPERTY_NOT_FOUND                                   ((DRM_RESULT)0x8004C335L)
+#define DRM_E_DEPRECATED_TEST_FILE_ALREADY_OPEN                                    ((DRM_RESULT)0x8004C337L)
+#define DRM_E_DEPRECATED_TEST_PICT_COLUMN_TOO_WIDE                                 ((DRM_RESULT)0x8004C339L)
+#define DRM_E_DEPRECATED_TEST_PICT_COLUMN_MISMATCH                                 ((DRM_RESULT)0x8004C33AL)
+#define DRM_E_DEPRECATED_SYNCLIST_NOT_SUPPORTED                                    ((DRM_RESULT)0x8004C3EAL)
+#define DRM_E_DEPRECATED_DEVICE_ALREADY_REGISTERED                                 ((DRM_RESULT)0x8004C3ECL)
+#define DRM_E_DEPRECATED_FEATURE_NOT_SUPPORTED                                     ((DRM_RESULT)0x8004C3F4L)
+#define DRM_E_DEPRECATED_HWID_ERROR                                                ((DRM_RESULT)0x8004C3F6L)
+#define DRM_E_DEPRECATED_LICACQ_ACK_MESSAGE_NOT_CREATED                            ((DRM_RESULT)0x8004C702L)
+#define DRM_E_DEPRECATED_INITIATORS_UNKNOWN_TYPE                                   ((DRM_RESULT)0x8004C780L)
+#define DRM_E_DEPRECATED_INITIATORS_INVALID_SERVICEID                              ((DRM_RESULT)0x8004C781L)
+#define DRM_E_DEPRECATED_INITIATORS_INVALID_ACCOUNTID                              ((DRM_RESULT)0x8004C782L)
+#define DRM_E_DEPRECATED_INITIATORS_INVALID_MID                                    ((DRM_RESULT)0x8004C783L)
+#define DRM_E_DEPRECATED_INITIATORS_MISSING_DC_URL                                 ((DRM_RESULT)0x8004C784L)
+#define DRM_E_DEPRECATED_INITIATORS_MISSING_CONTENT_HEADER                         ((DRM_RESULT)0x8004C785L)
+#define DRM_E_DEPRECATED_INITIATORS_MISSING_LAURL_IN_CONTENT_HEADER                ((DRM_RESULT)0x8004C786L)
+#define DRM_E_DEPRECATED_INITIATORS_MISSING_METERCERT_URL                          ((DRM_RESULT)0x8004C787L)
+#define DRM_E_DEPRECATED_BCERT_INVALID_MAX_LICENSE_SIZE                            ((DRM_RESULT)0x8004C808L)
+#define DRM_E_DEPRECATED_BCERT_INVALID_MAX_HEADER_SIZE                             ((DRM_RESULT)0x8004C809L)
+#define DRM_E_DEPRECATED_BCERT_CLIENT_ID_NOT_SPECIFIED                             ((DRM_RESULT)0x8004C810L)
+#define DRM_E_DEPRECATED_BCERT_HARDWARE_ID_NOT_SPECIFIED                           ((DRM_RESULT)0x8004C813L)
+#define DRM_E_DEPRECATED_BCERT_HARDWARE_ID_TOO_LONG                                ((DRM_RESULT)0x8004C814L)
+#define DRM_E_DEPRECATED_BCERT_SERIAL_NUM_NOT_SPECIFIED                            ((DRM_RESULT)0x8004C815L)
+#define DRM_E_DEPRECATED_BCERT_OBJECTHEADER_LEN_TOO_BIG                            ((DRM_RESULT)0x8004C81AL)
+#define DRM_E_DEPRECATED_BCERT_INVALID_ISSUERKEY_LENGTH                            ((DRM_RESULT)0x8004C81BL)
+#define DRM_E_DEPRECATED_BCERT_UNEXPECTED_OBJECT_HEADER                            ((DRM_RESULT)0x8004C81DL)
+#define DRM_E_DEPRECATED_BCERT_INVALID_MAX_KEY_USAGES                              ((DRM_RESULT)0x8004C81FL)
+#define DRM_E_DEPRECATED_BCERT_INVALID_MAX_FEATURES                                ((DRM_RESULT)0x8004C820L)
+#define DRM_E_DEPRECATED_BCERT_INVALID_CERT_HEADER_TAG                             ((DRM_RESULT)0x8004C824L)
+#define DRM_E_DEPRECATED_BCERT_INVALID_CERT_LENGTH                                 ((DRM_RESULT)0x8004C826L)
+#define DRM_E_DEPRECATED_BCERT_INVALID_NUMBER_EXTDATARECORDS                       ((DRM_RESULT)0x8004C829L)
+#define DRM_E_DEPRECATED_BCERT_EXTDATA_LENGTH_MUST_PRESENT                         ((DRM_RESULT)0x8004C82BL)
+#define DRM_E_DEPRECATED_BCERT_INVALID_EXTDATA_LENGTH                              ((DRM_RESULT)0x8004C82DL)
+#define DRM_E_DEPRECATED_BCERT_EXTDATA_IS_NOT_PROVIDED                             ((DRM_RESULT)0x8004C82EL)
+#define DRM_E_DEPRECATED_BCERT_INVALID_EXTDATA_SIGNED_LENGTH                       ((DRM_RESULT)0x8004C830L)
+#define DRM_E_DEPRECATED_BCERT_INVALID_EXTDATA_RECORD_TYPE                         ((DRM_RESULT)0x8004C831L)
+#define DRM_E_DEPRECATED_BCERT_EXTDATAFLAG_CERT_TYPE_MISMATCH                      ((DRM_RESULT)0x8004C832L)
+#define DRM_E_DEPRECATED_BCERT_OBJECTHEADER_LEN_TOO_SMALL                          ((DRM_RESULT)0x8004C83BL)
+#define DRM_E_DEPRECATED_SECURE_TRACE_BAD_GLOBAL_DATA_POINTER                      ((DRM_RESULT)0x8004CD00L)
+#define DRM_E_DEPRECATED_SECURE_TRACE_INVALID_GLOBAL_DATA                          ((DRM_RESULT)0x8004CD01L)
+#define DRM_E_DEPRECATED_SECURE_TRACE_FORMATTING_ERROR                             ((DRM_RESULT)0x8004CD02L)
+#define DRM_E_DEPRECATED_SECURE_TRACE_BAD_SCHEME_DATA_POINTER                      ((DRM_RESULT)0x8004CD03L)
+#define DRM_E_DEPRECATED_SECURE_TRACE_BAD_PER_THREAD_AES_DATA_POINTER              ((DRM_RESULT)0x8004CD04L)
+#define DRM_E_DEPRECATED_SECURE_TRACE_BAD_PER_THREAD_AES_BUFFER_POINTER            ((DRM_RESULT)0x8004CD05L)
+#define DRM_E_DEPRECATED_SECURE_TRACE_AES_INSUFFICIENT_BUFFER                      ((DRM_RESULT)0x8004CD06L)
+#define DRM_E_DEPRECATED_SECURE_TRACE_VERSION_MISMATCH                             ((DRM_RESULT)0x8004CD07L)
+#define DRM_E_DEPRECATED_SECURE_TRACE_UNEXPECTED_ERROR                             ((DRM_RESULT)0x8004CD08L)
+#define DRM_E_DEPRECATED_ND_MUST_REVALIDATE                                        ((DRM_RESULT)0x8004CE00L)
+#define DRM_E_DEPRECATED_ND_INVALID_MESSAGE                                        ((DRM_RESULT)0x8004CE01L)
+#define DRM_E_DEPRECATED_ND_INVALID_MESSAGE_TYPE                                   ((DRM_RESULT)0x8004CE02L)
+#define DRM_E_DEPRECATED_ND_INVALID_MESSAGE_VERSION                                ((DRM_RESULT)0x8004CE03L)
+#define DRM_E_DEPRECATED_ND_INVALID_SESSION                                        ((DRM_RESULT)0x8004CE04L)
+#define DRM_E_DEPRECATED_ND_MEDIA_SESSION_LIMIT_REACHED                            ((DRM_RESULT)0x8004CE05L)
+#define DRM_E_DEPRECATED_ND_UNABLE_TO_VERIFY_PROXIMITY                             ((DRM_RESULT)0x8004CE06L)
+#define DRM_E_DEPRECATED_ND_INVALID_PROXIMITY_RESPONSE                             ((DRM_RESULT)0x8004CE07L)
+#define DRM_E_DEPRECATED_ND_DEVICE_LIMIT_REACHED                                   ((DRM_RESULT)0x8004CE08L)
+#define DRM_E_DEPRECATED_ND_BAD_REQUEST                                            ((DRM_RESULT)0x8004CE09L)
+#define DRM_E_DEPRECATED_ND_FAILED_SEEK                                            ((DRM_RESULT)0x8004CE0AL)
+#define DRM_E_DEPRECATED_ND_INVALID_CONTEXT                                        ((DRM_RESULT)0x8004CE0BL)
+#define DRM_E_DEPRECATED_ASF_BAD_ASF_HEADER                                        ((DRM_RESULT)0x8004CF00L)
+#define DRM_E_DEPRECATED_ASF_BAD_PACKET_HEADER                                     ((DRM_RESULT)0x8004CF01L)
+#define DRM_E_DEPRECATED_ASF_BAD_PAYLOAD_HEADER                                    ((DRM_RESULT)0x8004CF02L)
+#define DRM_E_DEPRECATED_ASF_BAD_DATA_HEADER                                       ((DRM_RESULT)0x8004CF03L)
+#define DRM_E_DEPRECATED_ASF_INVALID_OPERATION                                     ((DRM_RESULT)0x8004CF04L)
+#define DRM_E_DEPRECATED_ASF_AES_PAYLOAD_FOUND                                     ((DRM_RESULT)0x8004CF05L)
+#define DRM_E_DEPRECATED_ASF_EXTENDED_STREAM_PROPERTIES_OBJ_NOT_FOUND              ((DRM_RESULT)0x8004CF06L)
+#define DRM_E_DEPRECATED_ASF_INVALID_DATA                                          ((DRM_RESULT)0x8004CF20L)
+#define DRM_E_DEPRECATED_ASF_TOO_MANY_PAYLOADS                                     ((DRM_RESULT)0x8004CF21L)
+#define DRM_E_DEPRECATED_ASF_BANDWIDTH_OVERRUN                                     ((DRM_RESULT)0x8004CF22L)
+#define DRM_E_DEPRECATED_ASF_INVALID_STREAM_NUMBER                                 ((DRM_RESULT)0x8004CF23L)
+#define DRM_E_DEPRECATED_ASF_LATE_SAMPLE                                           ((DRM_RESULT)0x8004CF24L)
+#define DRM_E_DEPRECATED_ASF_NOT_ACCEPTING                                         ((DRM_RESULT)0x8004CF25L)
+#define DRM_E_DEPRECATED_ASF_UNEXPECTED                                            ((DRM_RESULT)0x8004CF26L)
+#define DRM_E_DEPRECATED_LICGEN_POLICY_NOT_SUPPORTED                               ((DRM_RESULT)0x8004D100L)
+#define DRM_E_DEPRECATED_MOVE_DENIED                                               ((DRM_RESULT)0x8004D300L)
+#define DRM_E_DEPRECATED_INVALID_MOVE_RESPONSE                                     ((DRM_RESULT)0x8004D301L)
+#define DRM_E_DEPRECATED_MOVE_NONCE_MISMATCH                                       ((DRM_RESULT)0x8004D302L)
+#define DRM_E_DEPRECATED_MOVE_TXID_MISMATCH                                        ((DRM_RESULT)0x8004D303L)
+#define DRM_E_DEPRECATED_MOVE_STORE_OPEN_STORE                                     ((DRM_RESULT)0x8004D304L)
+#define DRM_E_DEPRECATED_MOVE_STORE_CLOSE_STORE                                    ((DRM_RESULT)0x8004D305L)
+#define DRM_E_DEPRECATED_MOVE_STORE_ADD_DATA                                       ((DRM_RESULT)0x8004D306L)
+#define DRM_E_DEPRECATED_MOVE_STORE_GET_DATA                                       ((DRM_RESULT)0x8004D307L)
+#define DRM_E_DEPRECATED_MOVE_FORMAT_INVALID                                       ((DRM_RESULT)0x8004D308L)
+#define DRM_E_DEPRECATED_MOVE_SIGNATURE_INVALID                                    ((DRM_RESULT)0x8004D309L)
+#define DRM_E_DEPRECATED_COPY_DENIED                                               ((DRM_RESULT)0x8004D30AL)
+#define DRM_E_DEPRECATED_KEYFILE_INVALID_PLATFORM                                  ((DRM_RESULT)0x8004D500L)
+#define DRM_E_DEPRECATED_KEYFILE_TOO_LARGE                                         ((DRM_RESULT)0x8004D501L)
+#define DRM_E_DEPRECATED_KEYFILE_PRIVATE_KEY_NOT_FOUND                             ((DRM_RESULT)0x8004D502L)
+#define DRM_E_DEPRECATED_KEYFILE_CERTIFICATE_CHAIN_NOT_FOUND                       ((DRM_RESULT)0x8004D503L)
+#define DRM_E_DEPRECATED_KEYFILE_KEY_NOT_FOUND                                     ((DRM_RESULT)0x8004D504L)
+#define DRM_E_DEPRECATED_KEYFILE_UNKNOWN_DECRYPTION_METHOD                         ((DRM_RESULT)0x8004D505L)
+#define DRM_E_DEPRECATED_KEYFILE_INVALID_SIGNATURE                                 ((DRM_RESULT)0x8004D506L)
+#define DRM_E_DEPRECATED_KEYFILE_INTERNAL_DECRYPTION_BUFFER_TOO_SMALL              ((DRM_RESULT)0x8004D507L)
+#define DRM_E_DEPRECATED_KEYFILE_PLATFORMID_MISMATCH                               ((DRM_RESULT)0x8004D508L)
+#define DRM_E_DEPRECATED_KEYFILE_CERTIFICATE_ISSUER_KEY_MISMATCH                   ((DRM_RESULT)0x8004D509L)
+#define DRM_E_DEPRECATED_KEYFILE_ROBUSTNESSVERSION_MISMATCH                        ((DRM_RESULT)0x8004D50AL)
+#define DRM_E_DEPRECATED_KEYFILE_FILE_NOT_CLOSED                                   ((DRM_RESULT)0x8004D50BL)
+#define DRM_E_DEPRECATED_KEYFILE_NOT_INITED                                        ((DRM_RESULT)0x8004D50CL)
+#define DRM_E_DEPRECATED_KEYFILE_FORMAT_INVALID                                    ((DRM_RESULT)0x8004D50DL)
+#define DRM_E_DEPRECATED_KEYFILE_UPDATE_NOT_ALLOWED                                ((DRM_RESULT)0x8004D50EL)
+#define DRM_E_DEPRECATED_PRND_MESSAGE_VERSION_INVALID                              ((DRM_RESULT)0x8004D700L)
+#define DRM_E_DEPRECATED_PRND_MESSAGE_WRONG_TYPE                                   ((DRM_RESULT)0x8004D701L)
+#define DRM_E_DEPRECATED_PRND_MESSAGE_INVALID                                      ((DRM_RESULT)0x8004D702L)
+#define DRM_E_DEPRECATED_PRND_SESSION_ID_INVALID                                   ((DRM_RESULT)0x8004D703L)
+#define DRM_E_DEPRECATED_PRND_PROXIMITY_DETECTION_REQUEST_CHANNEL_TYPE_UNSUPPORTED ((DRM_RESULT)0x8004D704L)
+#define DRM_E_DEPRECATED_PRND_PROXIMITY_DETECTION_RESPONSE_INVALID                 ((DRM_RESULT)0x8004D705L)
+#define DRM_E_DEPRECATED_PRND_PROXIMITY_DETECTION_RESPONSE_TIMEOUT                 ((DRM_RESULT)0x8004D706L)
+#define DRM_E_DEPRECATED_PRND_LICENSE_REQUEST_CID_CALLBACK_REQUIRED                ((DRM_RESULT)0x8004D707L)
+#define DRM_E_DEPRECATED_PRND_LICENSE_RESPONSE_CLMID_INVALID                       ((DRM_RESULT)0x8004D708L)
+#define DRM_E_DEPRECATED_PRND_CERTIFICATE_NOT_RECEIVER                             ((DRM_RESULT)0x8004D709L)
+#define DRM_E_DEPRECATED_PRND_CANNOT_RENEW_USING_NEW_SESSION                       ((DRM_RESULT)0x8004D70AL)
+#define DRM_E_DEPRECATED_PRND_INVALID_CUSTOM_DATA_TYPE                             ((DRM_RESULT)0x8004D70BL)
+#define DRM_E_DEPRECATED_PRND_CLOCK_OUT_OF_SYNC                                    ((DRM_RESULT)0x8004D70CL)
+#define DRM_E_DEPRECATED_PRND_CANNOT_REBIND_PRND_RECEIVED_LICENSE                  ((DRM_RESULT)0x8004D70DL)
+#define DRM_E_DEPRECATED_PRND_CANNOT_REGISTER_USING_EXISTING_SESSION               ((DRM_RESULT)0x8004D70EL)
+#define DRM_E_DEPRECATED_PRND_BUSY_PERFORMING_RENEWAL                              ((DRM_RESULT)0x8004D70FL)
+#define DRM_E_DEPRECATED_PRND_LICENSE_REQUEST_INVALID_ACTION                       ((DRM_RESULT)0x8004D710L)
+#define DRM_E_DEPRECATED_PRND_TRANSMITTER_UNAUTHORIZED                             ((DRM_RESULT)0x8004D711L)
+#define DRM_E_DEPRECATED_PRND_TX_SESSION_EXPIRED                                   ((DRM_RESULT)0x8004D712L)
+#define DRM_E_DEPRECATED_PRND_INCOMPLETE_PROXIMITY_DETECTION                       ((DRM_RESULT)0x8004D713L)
+#define DRM_E_DEPRECATED_PRND_INVALID_CERT_DIGEST                                  ((DRM_RESULT)0x8004D714L)
+#define DRM_E_DEPRECATED_OEMHAL_NOT_INITIALIZED                                    ((DRM_RESULT)0x8004D780L)
+#define DRM_E_DEPRECATED_OEMHAL_OUT_OF_KEY_REGISTERS                               ((DRM_RESULT)0x8004D781L)
+#define DRM_E_DEPRECATED_OEMHAL_KEYS_IN_USE                                        ((DRM_RESULT)0x8004D782L)
+#define DRM_E_DEPRECATED_OEMHAL_NO_KEY                                             ((DRM_RESULT)0x8004D783L)
+#define DRM_E_DEPRECATED_OEMHAL_UNSUPPORTED_KEY_TYPE                               ((DRM_RESULT)0x8004D784L)
+#define DRM_E_DEPRECATED_OEMHAL_UNSUPPORTED_KEY_WRAPPING_FORMAT                    ((DRM_RESULT)0x8004D785L)
+#define DRM_E_DEPRECATED_OEMHAL_UNSUPPORTED_KEY_LENGTH                             ((DRM_RESULT)0x8004D786L)
+#define DRM_E_DEPRECATED_OEMHAL_UNSUPPORTED_HASH_TYPE                              ((DRM_RESULT)0x8004D787L)
+#define DRM_E_DEPRECATED_OEMHAL_UNSUPPORTED_SIGNATURE_SCHEME                       ((DRM_RESULT)0x8004D788L)
+#define DRM_E_DEPRECATED_OEMHAL_BUFFER_TOO_LARGE                                   ((DRM_RESULT)0x8004D789L)
+#define DRM_E_DEPRECATED_OEMHAL_SAMPLE_ENCRYPTION_MODE_NOT_PERMITTED               ((DRM_RESULT)0x8004D78AL)
+#define DRM_E_DEPRECATED_M2TS_PAT_PID_IS_NOT_ZERO                                  ((DRM_RESULT)0x8004D800L)
+#define DRM_E_DEPRECATED_M2TS_PTS_NOT_EXIST                                        ((DRM_RESULT)0x8004D801L)
+#define DRM_E_DEPRECATED_M2TS_PES_PACKET_LENGTH_NOT_SPECIFIED                      ((DRM_RESULT)0x8004D802L)
+#define DRM_E_DEPRECATED_M2TS_OUTPUT_BUFFER_FULL                                   ((DRM_RESULT)0x8004D803L)
+#define DRM_E_DEPRECATED_M2TS_CONTEXT_NOT_INITIALIZED                              ((DRM_RESULT)0x8004D804L)
+#define DRM_E_DEPRECATED_M2TS_NEED_KEY_DATA                                        ((DRM_RESULT)0x8004D805L)
+#define DRM_E_DEPRECATED_M2TS_DDPLUS_FORMAT_INVALID                                ((DRM_RESULT)0x8004D806L)
+#define DRM_E_DEPRECATED_M2TS_NOT_UNIT_START_PACKET                                ((DRM_RESULT)0x8004D807L)
+#define DRM_E_DEPRECATED_M2TS_TOO_MANY_SUBSAMPLES                                  ((DRM_RESULT)0x8004D808L)
+#define DRM_E_DEPRECATED_M2TS_TABLE_ID_INVALID                                     ((DRM_RESULT)0x8004D809L)
+#define DRM_E_DEPRECATED_M2TS_PACKET_SYNC_BYTE_INVALID                             ((DRM_RESULT)0x8004D80AL)
+#define DRM_E_DEPRECATED_M2TS_ADAPTATION_LENGTH_INVALID                            ((DRM_RESULT)0x8004D80BL)
+#define DRM_E_DEPRECATED_M2TS_PAT_HEADER_INVALID                                   ((DRM_RESULT)0x8004D80CL)
+#define DRM_E_DEPRECATED_M2TS_PMT_HEADER_INVALID                                   ((DRM_RESULT)0x8004D80DL)
+#define DRM_E_DEPRECATED_M2TS_PES_START_CODE_NOT_FOUND                             ((DRM_RESULT)0x8004D80EL)
+#define DRM_E_DEPRECATED_M2TS_STREAM_OR_PACKET_TYPE_CHANGED                        ((DRM_RESULT)0x8004D80FL)
+#define DRM_E_DEPRECATED_M2TS_INTERNAL_ERROR                                       ((DRM_RESULT)0x8004D810L)
+#define DRM_E_DEPRECATED_M2TS_ADTS_FORMAT_INVALID                                  ((DRM_RESULT)0x8004D811L)
+#define DRM_E_DEPRECATED_M2TS_MPEGA_FORMAT_INVALID                                 ((DRM_RESULT)0x8004D812L)
+#define DRM_E_DEPRECATED_M2TS_CA_DESCRIPTOR_LENGTH_INVALID                         ((DRM_RESULT)0x8004D813L)
+#define DRM_E_DEPRECATED_M2TS_CRC_FIELD_INVALID                                    ((DRM_RESULT)0x8004D814L)
+#define DRM_E_DEPRECATED_M2TS_INCOMPLETE_SECTION_HEADER                            ((DRM_RESULT)0x8004D815L)
+#define DRM_E_DEPRECATED_M2TS_INVALID_UNALIGNED_DATA                               ((DRM_RESULT)0x8004D816L)
+#define DRM_E_DEPRECATED_M2TS_GET_ENCRYPTED_DATA_FIRST                             ((DRM_RESULT)0x8004D817L)
+#define DRM_E_DEPRECATED_M2TS_CANNOT_CHANGE_PARAMETER                              ((DRM_RESULT)0x8004D818L)
+#define DRM_E_DEPRECATED_M2TS_UNKNOWN_PACKET                                       ((DRM_RESULT)0x8004D819L)
+#define DRM_E_DEPRECATED_M2TS_DROP_PACKET                                          ((DRM_RESULT)0x8004D820L)
+#define DRM_E_DEPRECATED_M2TS_DROP_PES                                             ((DRM_RESULT)0x8004D821L)
+#define DRM_E_DEPRECATED_M2TS_INCOMPLETE_PES                                       ((DRM_RESULT)0x8004D822L)
+#define DRM_E_DEPRECATED_M2TS_WAITED_TOO_LONG                                      ((DRM_RESULT)0x8004D823L)
+#define DRM_E_DEPRECATED_M2TS_SECTION_LENGTH_INVALID                               ((DRM_RESULT)0x8004D824L)
+#define DRM_E_DEPRECATED_M2TS_PROGRAM_INFO_LENGTH_INVALID                          ((DRM_RESULT)0x8004D825L)
+#define DRM_E_DEPRECATED_M2TS_PES_HEADER_INVALID                                   ((DRM_RESULT)0x8004D826L)
+#define DRM_E_DEPRECATED_M2TS_ECM_PAYLOAD_OVER_LIMIT                               ((DRM_RESULT)0x8004D827L)
+#define DRM_E_DEPRECATED_M2TS_SET_CA_PID_FAILED                                    ((DRM_RESULT)0x8004D828L)
+#define DRM_E_DEPRECATED_LICGEN_PERSISTENT_REMOTE_LICENSE                          ((DRM_RESULT)0x8004D902L)
+#define DRM_E_DEPRECATED_LICGEN_EXPIRE_AFTER_FIRST_PLAY_REMOTE_LICENSE             ((DRM_RESULT)0x8004D903L)
+#define DRM_E_DEPRECATED_LICGEN_LOCAL_LICENSE_WITH_REMOTE_CERTIFICATE              ((DRM_RESULT)0x8004D906L)
+#define DRM_E_DEPRECATED_LICGEN_PLAY_ENABLER_REMOTE_LICENSE                        ((DRM_RESULT)0x8004D907L)
+#endif /*__DRMRESULTS_H__ */
+
diff --git a/prebuilt-v4.4/noarch/include/drmrevocation.h b/prebuilt-v4.4/noarch/include/drmrevocation.h
new file mode 100644
index 0000000..ec40cb7
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmrevocation.h
@@ -0,0 +1,110 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+
+#ifndef __DRMREVOCATION_H__
+#define __DRMREVOCATION_H__
+
+#include <drmliceval.h>
+#include <drmrevocationstore.h>
+#include <drmrevocationtypes.h>
+#include <drmmodulesupport.h>
+
+ENTER_PK_NAMESPACE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_RVK_ProcessRevocationInfoXML(
+    __in                                      DRM_REVOCATIONSTORE_CONTEXT *f_pContextRev,
+    __in_ecount(f_cchRevocationInfoXML) const DRM_CHAR                    *f_pchRevocationInfoXML,
+    __in                                      DRM_DWORD                    f_cchRevocationInfoXML,
+    __in_ecount(f_cbRevocationBuffer)         DRM_BYTE                    *f_pbRevocationBuffer,
+    __in                                      DRM_DWORD                    f_cbRevocationBuffer,
+    __out_opt                                 DRM_BOOL                    *f_pfUpdated ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_API DRM_RESULT DRM_CALL DRM_RVK_UpdateRevocationVersionsCache(
+    __inout                              DRM_REVOCATIONSTORE_CONTEXT *f_pContextRev,
+    __inout                              DRM_REVLIST_ID_VALUES       *f_pRevListIDs,
+    __inout_opt                          DRM_REVLIST_ID_VALUES       *f_pRevListIDsCopy,
+    __in                                 DRM_BOOL                     f_fVerifySignature,
+    __out_bcount( f_cbRevocationBuffer ) DRM_BYTE                    *f_pbRevocationBuffer,
+    __in                                 DRM_DWORD                    f_cbRevocationBuffer,
+    __out_opt                            DRM_BOOL                    *f_pfUpdated ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_API DRM_RESULT DRM_CALL DRM_RVK_VerifyRevInfoSafe(
+    __in                                      DRM_REVOCATIONSTORE_CONTEXT *f_pContextRev,
+    __in                                const DRM_GUID                    *f_pguidRevocationType,
+    __in_bcount( f_cbRevocationInfo )   const DRM_BYTE                    *f_pbRevocationInfo,
+    __in                                      DRM_DWORD                    f_cbRevocationInfo,
+    __in_bcount( f_cbRevocationBuffer ) const DRM_BYTE                    *f_pbRevocationBuffer,
+    __in                                      DRM_DWORD                    f_cbRevocationBuffer,
+    __inout_opt                               DRM_REVLIST_ID_VALUES       *f_pRevList,
+    __out                                     DRM_RLVI                    *f_pnewRLVI,
+    __out_opt                                 DRM_BOOL                    *f_pfRIV2,
+    __out                                     DRM_BOOL                    *f_pfVerified ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_API DRM_RESULT DRM_CALL DRM_RVK_ProcessRevocationPackage(
+    __in                                 const DRM_ANSI_CONST_STRING       *f_pdastrResponse,
+    __in                                       DRM_REVOCATIONSTORE_CONTEXT *f_pRevStoreContext,
+    __in                                       DRM_DWORD                    f_cbRevocationBuffer,
+    __inout_bcount( f_cbRevocationBuffer )     DRM_BYTE                    *f_pbRevocationBuffer,
+    __inout                                    DRM_REVLIST_ID_VALUES       *f_pRevListIDs,
+    __inout_opt                                DRM_REVLIST_ID_VALUES       *f_pRevListIDsCopy ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_API DRM_RESULT DRM_CALL DRM_RVK_VerifyRevocationInfo(
+    __inout                             DRM_SECURECORE_CONTEXT *f_pSecureCoreCtx,
+    __in_bcount( f_cbRevInfo )    const DRM_BYTE               *f_pbRevInfo,
+    __in                                DRM_DWORD               f_cbRevInfo,
+    __out                               DRM_RLVI               *f_pRLVI,
+    __in_opt                            DRM_SECSTORE_CONTEXT   *f_pcontextSST,
+    __in_opt                            DRM_DST                *f_pDatastore ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_BOOL DRM_RVK_IsWrappedCRL(
+    __in const DRM_CONST_STRING *f_pdstrRevocationList );
+
+DRM_API DRM_RESULT DRM_CALL DRM_RVK_VerifySigningCert(
+    __in                          const DRM_ANSI_CONST_STRING       *f_pdastrResponse,
+    __in                          const DRM_SUBSTRING               *f_pdasstrResponse,
+    __in                          const DRM_ANSI_CONST_STRING       *f_pdastrCertNodePath,
+    __in_bcount( f_cbBcertBuffer )      DRM_BYTE                    *f_pbBCertBuffer,
+    __in                                DRM_DWORD                    f_cbBcertBuffer,
+    __in_bcount( f_cbRevocationBuffer ) DRM_BYTE                    *f_pbRevocationBuffer,
+    __in                                DRM_DWORD                    f_cbRevocationBuffer,
+    __inout                             DRM_SECURECORE_CONTEXT      *f_pSecureCoreCtx,
+    __in                                DRM_SECSTORE_CONTEXT        *f_pSecStoreGlobalContext,
+    __in                                DRM_DST                     *f_pDatastore,
+    __in                                DRM_REVOCATIONSTORE_CONTEXT *f_pRevStoreContext );
+
+#define DRM_APP_REVOCATION_VERSION_NONE    0xFFFFFFFF
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_RVK_GetCRL(
+    __in                                DRM_REVOCATIONSTORE_CONTEXT  *f_pContextRev,
+    __in                          const DRM_GUID                     *f_pguidRevocationType,
+    __out_bcount_opt( *f_pcbCRL )       DRM_BYTE                     *f_pbCRL,
+    __inout                             DRM_DWORD                    *f_pcbCRL,
+    __out_opt                           DRM_DWORD                    *f_pdwCRLVersion ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_API DRM_RESULT DRM_CALL DRM_RVK_SetCRL(
+    __in                                      DRM_REVOCATIONSTORE_CONTEXT  *f_pContextRev,
+    __in                                const DRM_GUID                     *f_pguidRevocationType,
+    __in_bcount( f_cbCRL )                    DRM_BYTE                     *f_pbCRL,
+    __in                                      DRM_DWORD                     f_cbCRL,
+    __in_bcount( f_cbRevocationBuffer )       DRM_BYTE                     *f_pbRevocationBuffer,
+    __in                                      DRM_DWORD                     f_cbRevocationBuffer,
+    __out                                     DRM_BOOL                     *f_pfUpdated ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_RVK_CheckRevInfoForExpiration(
+    __in                                DRM_REVOCATIONSTORE_CONTEXT  *f_pContextRev,
+    __in                          const DRM_GUID                     *f_pguidRevocationType,
+    __in_opt                      const DRM_ID                       *f_pidSession,
+    __out_bcount_opt( *f_pcbRevInfo )   DRM_BYTE                     *f_pbRevInfo,
+    __inout                             DRM_DWORD                    *f_pcbRevInfo ) DRM_NO_INLINE_ATTRIBUTE;
+
+
+EXIT_PK_NAMESPACE;
+
+#endif /* __DRMREVOCATION_H__ */
+
diff --git a/prebuilt-v4.4/noarch/include/drmrevocationconstants.h b/prebuilt-v4.4/noarch/include/drmrevocationconstants.h
new file mode 100644
index 0000000..237f80e
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmrevocationconstants.h
@@ -0,0 +1,26 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __DRMREVOCATIONCONSTANTS_H__
+#define __DRMREVOCATIONCONSTANTS_H__
+
+#include <drmtypes.h>
+
+ENTER_PK_NAMESPACE;
+
+extern DRM_GLOBAL_CONST  DRM_LID g_lidRevocationInfo;
+extern DRM_GLOBAL_CONST  DRM_LID g_lidRevocationInfo2;
+extern DRM_GLOBAL_CONST  DRM_LID g_lidDeviceRevocation;
+extern DRM_GLOBAL_CONST  DRM_LID g_lidLegacyXMLCert_Revocation;
+extern DRM_GLOBAL_CONST  DRM_LID g_lidPRRTRevocation;
+extern DRM_GLOBAL_CONST  DRM_LID g_lidPRAppRevocation;
+
+EXIT_PK_NAMESPACE;
+
+#endif /* __DRMREVOCATIONCONSTANTS_H__ */
+
diff --git a/prebuilt-v4.4/noarch/include/drmrevocationenum.h b/prebuilt-v4.4/noarch/include/drmrevocationenum.h
new file mode 100644
index 0000000..e56f241
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmrevocationenum.h
@@ -0,0 +1,27 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __DRMREVOCATIONENUM_H__
+#define __DRMREVOCATIONENUM_H__
+
+#include <drmtypes.h>
+
+ENTER_PK_NAMESPACE;
+
+typedef enum _DRM_REVOCATION_TYPE_ENUM
+{
+    DRM_REVOCATION_TYPE_WMDRM_ND,
+    DRM_REVOCATION_TYPE_WMDRM_REVINFO,
+    DRM_REVOCATION_TYPE_PLAYREADY_APP,
+    DRM_REVOCATION_TYPE_PLAYREADY_RUNTIME,
+    DRM_REVOCATION_TYPE_PLAYREADY_REVINFO2
+} DRM_REVOCATION_TYPE_ENUM;
+
+EXIT_PK_NAMESPACE;
+
+#endif /* __DRMREVOCATIONENUM_H__ */
diff --git a/prebuilt-v4.4/noarch/include/drmrevocationstore.h b/prebuilt-v4.4/noarch/include/drmrevocationstore.h
new file mode 100644
index 0000000..52ef599
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmrevocationstore.h
@@ -0,0 +1,114 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __DRM_REVOCATIONSTORE_H__
+#define __DRM_REVOCATIONSTORE_H__
+
+#include <drmdatastoretypes.h>
+#include <drmsecurestoretypes.h>
+#include <drmsecurecoretypes.h>
+
+ENTER_PK_NAMESPACE;
+
+typedef struct _tag_RevocationStoreContext
+{
+    DRM_DST                      *pDatastore;
+    DRM_SECSTORE_CONTEXT         *pContextSST;
+    DRM_SECURECORE_CONTEXT       *pSecureCoreCtx;
+    DRM_BOOL                      fInitedPassword;
+    DRM_BYTE                      rgbPassword[ OEM_SHA1_DIGEST_LEN ];
+} _RevocationStoreContext;
+
+typedef struct __tagDRM_REVOCATIONSTORE_CONTEXT{
+    DRM_BYTE rgbOpaqueBuffer[ sizeof( _RevocationStoreContext ) ];
+} DRM_REVOCATIONSTORE_CONTEXT;
+
+/**********************************************************************
+**
+** Function:    DRM_RVS_InitRevocationStore
+**
+** Synopsis:    Initializes a revocation store context
+**
+** Arguments:   [f_pDatastore]         -- DST context
+**              [f_pContextSST]        -- secure store context
+**              [f_pContextBB]         -- blackbox context
+**              [f_pContextRev]        -- revocation store context
+**
+** Returns:     DRM_SUCCESS on success or failed with,
+**              DRM_E_INVALIDARG if a parameter is incorrect or
+**              other errors found in drmresults.h
+**
+** Notes:
+**
+**********************************************************************/
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_RVS_InitRevocationStore(
+    __in  const DRM_DST                      *f_pDatastore,
+    __in  const DRM_SECSTORE_CONTEXT         *f_pContextSST,
+    __in  const DRM_SECURECORE_CONTEXT       *f_pSecureCoreCtx,
+    __out       DRM_REVOCATIONSTORE_CONTEXT  *f_pContextRev );
+
+/**********************************************************************
+**
+** Function:    DRM_RVS_StoreRevocationData
+**
+** Synopsis:    Stores data in the revocation store
+**
+** Arguments:   [f_pContextRev]        -- revocation store context
+**              [f_pRevGUID]           -- GUID of data to store
+**              [f_pbRevocationData]   -- pointer to data to store
+**              [f_cbRevocationData]   -- size of data to store
+**
+** Returns:     DRM_SUCCESS on success or failed with,
+**              DRM_E_INVALIDARG if a parameter is incorrect or
+**              other errors found in drmresults.h
+**
+** Notes:
+**
+**********************************************************************/
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_RVS_StoreRevocationData(
+    __inout                               DRM_REVOCATIONSTORE_CONTEXT *f_pContextRev,
+    __in                            const DRM_GUID                    *f_pRevGUID,
+    __in_bcount(f_cbRevocationData) const DRM_BYTE                    *f_pbRevocationData,
+    __in                            const DRM_DWORD                    f_cbRevocationData );
+
+/**********************************************************************
+**
+** Function:    DRM_RVS_GetRevocationData
+**
+** Synopsis:    Retrieves data from the revocation store
+**
+** Arguments:   [f_pContextRev]        -- revocation store context
+**              [f_pRevGUID]           -- GUID of data to retrieve
+**              [f_pbRevocationData]   -- pointer to buffer to hold returned data
+**              [f_cbRevocationData]   -- size of buffer
+**
+** Returns:     DRM_SUCCESS on success or failed with,
+**              DRM_E_INVALIDARG if a parameter is incorrect or
+**              other errors found in drmresults.h
+**
+** Notes:
+**
+**********************************************************************/
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_RVS_GetRevocationData(
+    __inout                                            DRM_REVOCATIONSTORE_CONTEXT *f_pContextRev,
+    __in                                         const DRM_GUID                    *f_pRevGUID,
+    __out_bcount_opt( *f_pcbRevocationData )           DRM_BYTE                    *f_pbRevocationData,
+    __inout                                            DRM_DWORD                   *f_pcbRevocationData );
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_RVS_LoopkupRevocationLIDFromGUID(
+    __in  const DRM_GUID  *f_pRevGUID,
+    __out const DRM_ID   **f_pLID );
+
+EXIT_PK_NAMESPACE;
+
+#endif  /* __DRM_REVOCATIONSTORE_H__ */
+
+
diff --git a/prebuilt-v4.4/noarch/include/drmrevocationtypes.h b/prebuilt-v4.4/noarch/include/drmrevocationtypes.h
new file mode 100644
index 0000000..8f332e1
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmrevocationtypes.h
@@ -0,0 +1,106 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+
+#ifndef __DRMREVOCATIONTYPES_H__
+#define __DRMREVOCATIONTYPES_H__
+
+#include <oemsha1.h>
+#include <drmtypes.h>
+#include <drmrevocationenum.h>
+
+ENTER_PK_NAMESPACE;
+
+typedef struct __tagDRM_RLVI_RECORD
+{
+    DRM_GUID   listID;
+    DRM_UINT64 qwVersion;
+} DRM_RLVI_RECORD;
+
+typedef struct __tagDRM_RLVI_HEAD
+{
+    DRM_DWORD   dwID;
+    DRM_DWORD   cbSignedBytes;
+    DRM_BYTE    bFormatVersion;
+    DRM_BYTE    bReserved[3];
+    DRM_DWORD   dwRIV;
+    DRMFILETIME ftIssuedTime;
+    DRM_DWORD   dwRecordCount;
+} DRM_RLVI_HEAD;
+
+typedef struct __tagDRM_RLVI_SIGNATURE
+{
+    DRM_BYTE  bSignatureType;
+    DRM_DWORD ibSignature;
+    DRM_DWORD cbSignature;
+} DRM_RLVI_SIGNATURE;
+
+typedef struct __tagDRM_RLVI_CERTCHAIN
+{
+    DRM_DWORD  cbCertChain;
+    DRM_DWORD  ibCertChain;
+} DRM_RLVI_CERTCHAIN;
+
+typedef struct __tagDRM_RLVI
+{
+    DRM_RLVI_HEAD       head;
+    DRM_DWORD           ibEntries;    /* Byte offset to the entries in the revocation info */
+    DRM_RLVI_SIGNATURE  signature;
+    DRM_RLVI_CERTCHAIN  certchain;
+} DRM_RLVI;
+
+typedef struct
+{    DRM_GUID guidRevocationList;
+    DRM_BYTE *pbRevocationList;
+    DRM_DWORD cbRevocationList;
+} DRM_RVK_LIST;
+
+#define RLVI_MAGIC_NUM_V1   ((DRM_DWORD) 0x524C5649) /* 'RLVI' */
+#define RLVI_MAGIC_NUM_V2   ((DRM_DWORD) 0x524C5632) /* 'RLV2' */
+
+#define RLVI_FORMAT_VERSION_V1 ((DRM_BYTE)  1)
+#define RLVI_FORMAT_VERSION_V2 ((DRM_BYTE)  2)
+#define RLVI_SIGNATURE_TYPE_1  ((DRM_BYTE)  1)
+#define RLVI_SIGNATURE_SIZE_1  ((DRM_DWORD) 128)
+#define RLVI_SIGNATURE_TYPE_2  ((DRM_BYTE)  2)
+#define RLVI_SIGNATURE_SIZE_2  ((DRM_DWORD) 256)
+
+#define DRM_NO_PREVIOUS_CRL 0xFFFFFFFF
+
+/*
+** CRL defines
+*/
+#define LEGACYXMLCERT_CRL_ENTRY_SIZE                     OEM_SHA1_DIGEST_LEN
+#define LEGACYXMLCERT_CRL_SIGNATURE_TYPE_RSA_SHA1        2
+#define LEGACYXMLCERT_CRL_SIGNATURE_LEN_RSA_SHA1         128
+
+/* Recommeded revocation buffer size. */
+#define REVOCATION_BUFFER_SIZE                      ( 30 * 1024 )
+
+typedef struct
+{
+    DRM_BYTE val[ LEGACYXMLCERT_CRL_ENTRY_SIZE ];
+
+} LEGACYXMLCERT_CRL_ENTRY;
+
+typedef DRM_BYTE DRM_RevocationEntry[32];
+
+#define MAX_REVOCATION_EXPIRE_TIME    ( 90 * 24 * 60 * 60 ) /* 90 days */
+
+/*
+** For Perf, MAX_REVOCATION_EXPIRE_TICS was pre-calculated.
+** If C_TICS_PER_SECOND is changed, make sure this expression is also updated.
+**
+** MAX_REVOCATION_EXPIRE_TICS = MAX_REVOCATION_EXPIRE_TIME * C_TICS_PER_SECOND
+*/
+
+#define MAX_REVOCATION_EXPIRE_TICS    ( DRM_UI64HL( 0x46B8, 0xE92D8000 ) )
+
+EXIT_PK_NAMESPACE;
+
+#endif /* __DRMREVOCATIONTYPES_H__ */
diff --git a/prebuilt-v4.4/noarch/include/drmrivcrlparser.h b/prebuilt-v4.4/noarch/include/drmrivcrlparser.h
new file mode 100644
index 0000000..de18093
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmrivcrlparser.h
@@ -0,0 +1,100 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __DRMRIVCRLPARSER_H__
+#define __DRMRIVCRLPARSER_H__
+
+#include <drmbcrltypes.h>
+
+ENTER_PK_NAMESPACE;
+
+#define SECURE_COPY_FROMBUFFER(to, from, index, size, buffersize) DRM_DO {  \
+    DRM_DWORD __dwSpaceRequired=0;                                          \
+    ChkDR(DRM_DWordAdd(index,size,&__dwSpaceRequired));                     \
+    ChkBOOL(__dwSpaceRequired<=(buffersize),DRM_E_BUFFERTOOSMALL);          \
+    OEM_SECURE_MEMCPY((DRM_BYTE*)(to),&(from[(index)]),(size));             \
+    (index)=(__dwSpaceRequired);                                            \
+} DRM_WHILE_FALSE
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_RVK_FindEntryInRevInfo(
+    __in                     const DRM_RLVI    *f_prlvi,
+    __in_bcount(f_cbRevInfo) const DRM_BYTE    *f_pbRevInfo,
+    __in                           DRM_DWORD    f_cbRevInfo,
+    __in                     const DRM_GUID    *f_pguidEntry,
+    __out                          DRM_DWORD   *f_pdwVersion ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_RVK_ParseRevocationInfoHeader(
+    __in_bcount( f_cbRevInfo ) const DRM_BYTE           *f_pbRevInfo,
+    __in                             DRM_DWORD           f_cbRevInfo,
+    __out                            DRM_RLVI           *f_pRLVI,
+    __inout                          DRM_DWORD          *f_pidxRevInfo ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_RVK_ParseRevocationInfo(
+    __in_bcount( f_cbRevInfo ) const DRM_BYTE           *f_pbRevInfo,
+    __in                             DRM_DWORD           f_cbRevInfo,
+    __out_ecount(1)                  DRM_RLVI           *f_pRLVI,
+    __out_ecount_opt(1)              DRM_DWORD          *f_pcbSignedBytes ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_API DRM_RESULT DRM_CALL DRM_RVK_VerifyRevocationInfoV2Only(
+    __inout_opt                      DRM_VOID               *f_pvOemCtx,
+    __inout_opt                      DRM_CRYPTO_CONTEXT     *f_pCryptContext,
+    __in_bcount( f_cbRevInfo ) const DRM_BYTE               *f_pbRevInfo,
+    __in                             DRM_DWORD               f_cbRevInfo,
+    __out                            DRM_RLVI               *f_pRLVI ) DRM_NO_INLINE_ATTRIBUTE;
+
+/*********************************************************************
+**
+**  Parses the unsigned portion of Playready/Silverlight CRL from
+**  binary to data structure.
+**
+**  NOTE: The parser does not make copies of the DRM_RevocationEntry
+**        data, it just points to them in the f_pbCrlData buffer so
+**        you cannot free the f_pbCrlData and still have a valid f_poCrl
+**        data structure.
+**
+*********************************************************************/
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_BCrl_ParseUnsignedCrl(
+    __in_bcount(f_cbCrlData) const DRM_BYTE       *f_pbCrlData,
+    __in                     const DRM_DWORD       f_cbCrlData,
+    __out                    DRM_DWORD            *f_pcbSignedMessageLength,
+    __out                    DRM_BCRL             *f_poCrl ) DRM_NO_INLINE_ATTRIBUTE;
+
+/*********************************************************************
+**
+**  Parses the entire Playready/Silverlight CRL from
+**  binary to data structure.
+**
+**  NOTE: The parser does not make copies of the DRM_RevocationEntry
+**        data, it just points to them in the f_pbCrlData buffer so
+**        you cannot free the f_pbCrlData and still have a valid f_poCrl
+**        data structure.
+**
+*********************************************************************/
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_BCrl_ParseSignedCrl(
+    __in_bcount(f_cbCrlData) const DRM_BYTE        *f_pbCrlData,
+    __in                     const DRM_DWORD        f_cbCrlData,
+    __out_ecount_opt(1)            DRM_DWORD       *f_pcbSignedMessageLength,
+    __out                          DRM_BCRL_Signed *f_poCrl ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_BCrl_VerifySignature(
+    __inout_opt                             DRM_VOID               *f_pOemTeeContextAllowNULL,
+    __inout_opt                             DRM_CRYPTO_CONTEXT     *f_pCryptoContext,
+    __in_bcount(f_cbSignedBytes)      const DRM_BYTE               *f_pbSignedBytes,
+    __in                                    DRM_DWORD               f_cbSignedBytes,
+    __in_bcount(f_cbSignature)        const DRM_BYTE               *f_pbSignature,
+    __in                                    DRM_DWORD               f_cbSignature,
+    __in_bcount(f_cbCertificateChain) const DRM_BYTE               *f_pbCertificateChain,
+    __in                                    DRM_DWORD               f_cbCertificateChain,
+    __in_ecount_opt(1)                const PUBKEY_P256            *f_pRootPubkey ) DRM_NO_INLINE_ATTRIBUTE;
+
+EXIT_PK_NAMESPACE;
+
+#endif /* __DRMRIVCRLPARSER_H__ */
+
diff --git a/prebuilt-v4.4/noarch/include/drmsal.h b/prebuilt-v4.4/noarch/include/drmsal.h
new file mode 100644
index 0000000..1129c2c
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmsal.h
@@ -0,0 +1,879 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __DRMSAL_H__
+#define __DRMSAL_H__
+
+#include <drmcompiler.h>
+
+#if (defined( _PREFAST_ )) || ( defined (DRM_MSC_VER) && ( defined (_M_IX86) || defined (_M_IA64) || defined (_M_AMD64) || defined (_M_ARM) || defined (_M_ARM64) ) )
+    /*
+    ** Values that used to be defined in suppress.h, for back compat
+    */
+    #define __WARNING_ENUM_TYPEDEF_5496                                  5496
+    #define __WARNING_UNINITIALIZED_MEMORY_6001                          6001
+    #define __WARNING_DEREFERENCING_NULL_POINTER_6011                    6011
+    #define __WARNING_RETURN_VALUE_IGNORED_6031                          6031
+    #define __WARNING_ZERO_TERMINATION_MISSING_6054                      6054
+    #define __WARNING_RETURNING_UNINITIALIZED_MEMORY_6101                6101
+    #define __WARNING_USING_FAILED_RESULT_6102                           6102
+    #define __WARNING_RETURN_FAILED_RESULT_6103                          6103
+    #define __WARNING_INVALID_HRESULT_COMPARE_6219                       6219
+    #define __WARNING_INVALID_HRESULT_COMPARE_TO_INTEGER_6221            6221
+    #define __WARNING_LOCAL_DECLARATION_HIDES_GLOBAL_6244                6244
+    #define __WARNING_IGNORED_BY_COMMA_6319                              6319
+    #define __WARNING_EXCEPTION_EXECUTE_HANDLER_6320                     6320
+    #define __WARNING_EXCEPT_BLOCK_EMPTY_6322                            6322
+    #define __WARNING_CONSTANT_CONSTANT_COMPARISON_6326                  6326
+    #define __WARNING_POTENTIAL_ARGUMENT_TYPE_MISMATCH_6328              6328
+    #define __WARNING_POTENTIAL_ARGUMENT_TYPE_MISMATCH_6340              6340
+    #define __WARNING_READ_OVERRUN_6385                                  6385
+    #define __WARNING_WRITE_OVERRUN_6386                                 6386
+    #define __WARNING_INVALID_PARAMETER_6387                             6387
+    #define __WARNING_INVALID_PARAMETER_6388                             6388
+    #define __WARNING_MUSTCHECK_ON_VOID_6505                             6505
+    #define __WARNING_ENCODE_GLOBAL_FUNCTION_POINTER_22110              22110
+    #define __WARNING_PREDICTABLE_FUNCTION_POINTER_22112                22112
+    #define __WARNING_IMPLICIT_CTOR_25001                               25001
+    #define __WARNING_NONCONST_LOCAL_VARIABLE_25003                     25003
+    #define __WARNING_NONCONST_PARAM_25004                              25004
+    #define __WARNING_NONCONST_FUNCTION_25005                           25005
+    #define __WARNING_STATIC_FUNCTION_25007                             25007
+    #define __WARNING_MISSING_OVERRIDE_25014                            25014
+    #define __WARNING_DOESNT_OVERRIDE_25015                             25015
+    #define __WARNING_SAME_MEMBER_25020                                 25020
+    #define __WARNING_POOR_DATA_ALIGNMENT_25021                         25021
+    #define __WARNING_DANGEROUS_POINTERCAST_25024                       25024
+    #define __WARNING_UNSAFE_STRING_FUNCTION_25025                      25025
+    #define __WARNING_FUNCTION_NEEDS_REVIEW_25028                       25028
+    #define __WARNING_HRESULT_NOT_CHECKED_25031                         25031
+    #define __WARNING_NONCONST_LOCAL_BUFFER_PTR_25032                   25032
+    #define __WARNING_NONCONST_BUFFER_PARAM_25033                       25033
+    #define __WARNING_TRUE_CONSTANT_EXPRESSION_IN_AND_25037             25037
+    #define __WARNING_FALSE_CONSTANT_EXPRESSION_IN_AND_25038            25038
+    #define __WARNING_IF_CONDITION_IS_ALWAYS_TRUE_25041                 25041
+    #define __WARNING_IF_CONDITION_IS_ALWAYS_FALSE_25042                25042
+    #define __WARNING_LOCAL_BSTR_SHOULD_BE_CONST_WCHAR_PTR_25043        25043
+    #define __WARNING_USE_SELECT_ANY_25046                              25046
+    #define __WARNING_STRINGCONST_ASSIGNED_TO_NONCONST_25048            25048
+    #define __WARNING_COUNT_REQUIRED_FOR_WRITABLE_BUFFER_25057          25057
+    #define __WARNING_CAST_CAN_BE_CONST_25058                           25058
+    #define __WARNING_SUPERFLUOUS_CAST_25059                            25059
+    #define __WARNING_BACKWARD_JUMP_25061                               25061
+    #define __WARNING_USE_WIDE_API_25068                                25068
+    #define __WARNING_NO_MEMBERINIT_25070                               25070
+    #define __WARNING_NO_MEMBERINIT_BEFORE_CONSTRUCTOR_BODY_25071       25071
+    #define __WARNING_WRONG_MEMBERINIT_ORDER_25073                      25073
+    #define __WARNING_URL_NEEDS_REVIEW_25085                            25085
+    #define __WARNING_SD_REQUIRED_FOR_NAMED_OBJECT_25086                25086
+    #define __WARNING_FORMAL_CAN_BE_BOOL_25093                          25093
+    #define __WARNING_ENUM_TYPEDEF_25096                                25096
+    #define __WARNING_INTEGRAL_CAST_TO_OBJECT_WITH_VTABLE_25098         25098
+    #define __WARNING_DEPRECATED_LANGUAGE_TYPE_USED_25113               25113
+    #define __WARNING_COUNT_REQUIRED_FOR_VOIDPTR_BUFFER_25120           25120
+    #define __WARNING_POSSIBLE_STRCPY_LOOP_25126                        25126
+    #define __WARNING_IMPLICIT_TEMPLATECTOR_25134                       25134
+    #define __WARNING_LOCAL_ARRAY_SHOULD_BE_POINTER_25137               25137
+    #define __WARNING_PRINTF_NEEDS_REVIEW_25141                         25141
+    #define __WARNING_WRITABLE_GLOBAL_FUNCTION_POINTER_25143            25143
+    #define __WARNING_MISSING_ANNOTATION_25352                          25352
+    #define __WARNING_DEPRECATED_OVERRIDE_25359                         25359
+    #define __WARNING_OBSOLETE_OVERRIDE_25360                           25360
+    #define __WARNING_BUFFER_OVERFLOW_26000                             26000
+    #define __WARNING_BUFFER_UNDERFLOW_26001                            26001
+    #define __WARNING_READ_UNTRACKED_BUFFER_26002                       26002
+    #define __WARNING_WRITE_UNTRACKED_BUFFER_26003                      26003
+    #define __WARNING_ZERO_LENGTH_ARRAY_26005                           26005
+    #define __WARNING_INCORRECT_ANNOTATION_26007                        26007
+    #define __WARNING_POTENTIAL_OVERFLOW_26010                          26010
+    #define __WARNING_POTENTIAL_UNDERFLOW_26011                         26011
+    #define __WARNING_UNTRACKED_BUFFER_UNANNOTATABLE_26012              26012
+    #define __WARNING_COMPLEX_EXPRESSION_26013                          26013
+    #define __WARNING_INCORRECT_VALIDATION_26014                        26014
+    #define __WARNING_POTENTIAL_OVERFLOW_26015                          26015
+    #define __WARNING_POTENTIAL_BUFFER_OVERFLOW_NULLTERMINATED_26016    26016
+    #define __WARNING_POTENTIAL_OVERFLOW_26017                          26017
+    #define __WARNING_POTENTIAL_BUFFER_OVERFLOW_NULLTERMINATED_26018    26018
+    #define __WARNING_INCORRECT_VALIDATION_26019                        26019
+    #define __WARNING_POTENTIAL_OVERFLOW_26025                          26025
+    #define __WARNING_PRECONDITION_NULLTERMINATION_VIOLATION_26035      26035
+    #define __WARNING_POSTCONDITION_NULLTERMINATION_VIOLATION_26036     26036
+    #define __WARNING_POTENTIAL_NULLTERMINATION_VIOLATION_26037         26037
+    #define __WARNING_POTENTIAL_POSTCONDITION_BUFFER_OVERFLOW_26040     26040
+    #define __WARNING_INCORRECT_VALIDATION_POSTCONDITION_26044          26044
+    #define __WARNING_HIGH_PRIORITY_OVERFLOW_POSTCONDITION_26045        26045
+    #define __WARNING_IRREDUCIBLE_CONTROL_FLOW_GRAPH_26051              26051
+    #define __WARNING_POTENTIALLY_UNCONSTRAINED_CALL_26052              26052
+    #define __WARNING_POTENTIAL_OVERFLOW_LOOP_DEPENDENT_26053           26053
+    #define __WARNING_PRECONDITION_RANGE_VIOLATION_26060                26060
+    #define __WARNING_POSTCONDITION_RANGE_VIOLATION_26061               26061
+    #define __WARNING_POTENTIAL_RANGE_PRECONDITION_VIOLATION_26070      26070
+    #define __WARNING_POTENTIAL_RANGE_POSTCONDITION_VIOLATION_26071     26071
+    #define __WARNING_CALLER_FAILING_TO_HOLD_LOCK_26110                 26110
+    #define __WARNING_MISSING_LOCK_HELD_ANNOTATION_26130                26130
+    #define __WARNING_MISSING_LOCK_ANNOTATION_26135                     26135
+    #define __WARNING_FAILING_TO_RELEASE_LOCK_26165                     26165
+    #define __WARNING_FAILING_TO_HOLD_LOCK_26166                        26166
+    #define __WARNING_RELEASING_UNHELD_LOCK_26167                       26167
+    #define __WARNING_INCORRECT_ANNOTATION_STRING_ASSUMED_26706         26706
+    #define __WARNING_INCORRECT_ANNOTATION_26707                        26707
+    #define __WARNING_PRECONDITION_NULLTERMINATION_VIOLATION_26735      26735
+    #define __WARNING_EXPR_NOT_TRUE_AT_THIS_CALL_28020                  28020
+    #define __WARNING_INCONSISTENT_ANNOTATION_28052                     28052
+    #define __WARNING_CONSIDER_USING_ANOTHER_FUNCTION_28159             28159
+    #define __WARNING_DEREFERENCING_COPY_OF_NULL_POINTER_28182          28182
+    #define __WARNING_POINTER_COPY_COULD_BE_NULL_28183                  28183
+    #define __WARNING_REQUIREMENT_NOT_SATISFIED_EXPR_NOT_TRUE_28196     28196
+    #define __WARNING_USING_POSSIBLY_UNINITIALIZED_MEMORY_28199         28199
+    #define __WARNING_INCONSISTENT_ANNOTATED_OVERRIDDEN_FUNCTION_28204  28204
+    #define __WARNING_UNMATCHED_ANNO_TREE_28218                         28218
+    #define __WARNING_INCONSISTENT_ANNOTATION_28251                     28251
+    #define __WARNING_INCONSISTENT_ANNOTATION_28252                     28252
+    #define __WARNING_INCONSISTENT_ANNOTATION_28253                     28253
+    #define __WARNING_SPEC_INVALID_SYNTAX2_28285                        28285
+    #define __WARNING_SPEC_INVALID_SYNTAX2_28286                        28286
+    #define __WARNING_NO_ANNOTATIONS_FOR_FIRST_DECLARATION_28301        28301
+    #define __WARNING_NO_SAL_VERSION_28310                              28310
+    #define __WARNING_OBSOLETE_SAL_VERSION_28311                        28311
+    #define __WARNING_OBSOLETE_SAL_VERSION_ON_DEF_28312                 28312
+    #define __WARNING_UNANNOTATED_BUFFER_28718                          28718
+    #define __WARNING_BANNED_API_28719                                  28719
+    #define __WARNING_BANNED_API_28726                                  28726
+    #define __WARNING_BANNED_API_28727                                  28727
+    #define __WARNING_CYCLOMATIC_COMPLEXITY_28734                       28734
+    #define __WARNING_BANNED_STRLEN_API_28750                           28750
+    #define __WARNING_BANNED_CRYPTO_API_USAGE_28755                     28755
+    #define __WARNING_REDUNDANT_POINTER_TEST_28922                      28922
+    #define __WARNING_UNUSED_POINTER_ASSIGNMENT_28930                   28930
+    #define __WARNING_UNUSED_ASSIGNMENT_28931                           28931
+    #define __WARNING_UNREACHABLE_CODE_28940                            28940
+    #define __WARNING_USE_HTTPS_30100                                   30100
+    #define __WARNING_VARIANTCLEAR_NOSAL_33006                          33006
+    #define __WARNING_CALLING_SET_THREAD_LOCALE_38010                   38010
+    #define __WARNING_ANSI_APICALL_38020                                38020
+    #define __WARNING_CLIPBOARD_ANSI_38022                              38022
+    #define __WARNING_DOMAIN_NAMES_MUST_BE_WORLD_READY_38026            38026
+
+    /*
+    ** Include the Standard Annotation Langauge header for compilers that have it (ie MSVC)
+    */
+    PREFAST_PUSH_DISABLE_EXPLAINED( __WARNING_USE_SELECT_ANY_25046, "Ignore warnings in non-PlayReady headers" )
+    #include <specstrings.h>
+    PREFAST_POP     /* __WARNING_USE_SELECT_ANY_25046 */
+
+    #ifndef __WARNING_ANSI_APICALL
+        #define __WARNING_ANSI_APICALL 38020
+    #endif /* __WARNING_ANSI_APICALL */
+
+    #ifndef UNREFERENCED_PARAMETER
+        #define UNREFERENCED_PARAMETER(p) (p)
+    #endif
+
+
+    #define PREFAST_PUSH_IGNORE_WARNINGS_IN_NON_PLAYREADY_HEADERS                                                                                    \
+        PREFAST_PUSH_DISABLE_EXPLAINED( __WARNING_NONCONST_PARAM_25004, "Ignore warnings in non-PlayReady headers" )                                 \
+        PREFAST_PUSH_DISABLE_EXPLAINED( __WARNING_POOR_DATA_ALIGNMENT_25021, "Ignore warnings in non-PlayReady headers" )                            \
+        PREFAST_PUSH_DISABLE_EXPLAINED( __WARNING_DANGEROUS_POINTERCAST_25024, "Ignore warnings in non-PlayReady headers" )                          \
+        PREFAST_PUSH_DISABLE_EXPLAINED( __WARNING_UNSAFE_STRING_FUNCTION_25025, "Ignore warnings in non-PlayReady headers" )                         \
+        PREFAST_PUSH_DISABLE_EXPLAINED( __WARNING_FUNCTION_NEEDS_REVIEW_25028, "Ignore warnings in non-PlayReady headers" )                          \
+        PREFAST_PUSH_DISABLE_EXPLAINED( __WARNING_HRESULT_NOT_CHECKED_25031, "Ignore warnings in non-PlayReady headers" )                            \
+        PREFAST_PUSH_DISABLE_EXPLAINED( __WARNING_NONCONST_LOCAL_BUFFER_PTR_25032, "Ignore warnings in non-PlayReady headers" )                      \
+        PREFAST_PUSH_DISABLE_EXPLAINED( __WARNING_NONCONST_BUFFER_PARAM_25033, "Ignore warnings in non-PlayReady headers" )                          \
+        PREFAST_PUSH_DISABLE_EXPLAINED( __WARNING_TRUE_CONSTANT_EXPRESSION_IN_AND_25037, "Ignore warnings in non-PlayReady headers" )                \
+        PREFAST_PUSH_DISABLE_EXPLAINED( __WARNING_IF_CONDITION_IS_ALWAYS_TRUE_25041, "Ignore warnings in non-PlayReady headers" )                    \
+        PREFAST_PUSH_DISABLE_EXPLAINED( __WARNING_LOCAL_BSTR_SHOULD_BE_CONST_WCHAR_PTR_25043, "Ignore warnings in non-PlayReady headers" )           \
+        PREFAST_PUSH_DISABLE_EXPLAINED( __WARNING_USE_SELECT_ANY_25046, "Ignore warnings in non-PlayReady headers" )                                 \
+        PREFAST_PUSH_DISABLE_EXPLAINED( __WARNING_CAST_CAN_BE_CONST_25058, "Ignore warnings in non-PlayReady headers" )                              \
+        PREFAST_PUSH_DISABLE_EXPLAINED( __WARNING_NO_MEMBERINIT_BEFORE_CONSTRUCTOR_BODY_25071, "Ignore warnings in non-PlayReady headers" )          \
+        PREFAST_PUSH_DISABLE_EXPLAINED( __WARNING_FORMAL_CAN_BE_BOOL_25093, "Ignore warnings in non-PlayReady headers" )                             \
+        PREFAST_PUSH_DISABLE_EXPLAINED( __WARNING_ENUM_TYPEDEF_25096, "Ignore warnings in non-PlayReady headers" )                                   \
+        PREFAST_PUSH_DISABLE_EXPLAINED( __WARNING_DEPRECATED_LANGUAGE_TYPE_USED_25113, "Ignore warnings in non-PlayReady headers" )                  \
+        PREFAST_PUSH_DISABLE_EXPLAINED( __WARNING_POTENTIAL_BUFFER_OVERFLOW_NULLTERMINATED_26018, "Ignore warnings in non-PlayReady headers" )       \
+        PREFAST_PUSH_DISABLE_EXPLAINED( __WARNING_PRECONDITION_NULLTERMINATION_VIOLATION_26035, "Ignore warnings in non-PlayReady headers" )         \
+        PREFAST_PUSH_DISABLE_EXPLAINED( __WARNING_POSTCONDITION_NULLTERMINATION_VIOLATION_26036, "Ignore warnings in non-PlayReady headers" )        \
+        PREFAST_PUSH_DISABLE_EXPLAINED( __WARNING_HIGH_PRIORITY_OVERFLOW_POSTCONDITION_26045, "Ignore warnings in non-PlayReady headers" )           \
+        PREFAST_PUSH_DISABLE_EXPLAINED( __WARNING_EXPR_NOT_TRUE_AT_THIS_CALL_28020, "Ignore warnings in non-PlayReady headers" )                     \
+        PREFAST_PUSH_DISABLE_EXPLAINED( __WARNING_CONSIDER_USING_ANOTHER_FUNCTION_28159, "Ignore warnings in non-PlayReady headers" )                \
+        PREFAST_PUSH_DISABLE_EXPLAINED( __WARNING_REQUIREMENT_NOT_SATISFIED_EXPR_NOT_TRUE_28196, "Ignore warnings in non-PlayReady headers" )        \
+        PREFAST_PUSH_DISABLE_EXPLAINED( __WARNING_SPEC_INVALID_SYNTAX2_28285, "Ignore warnings in non-PlayReady headers" )                           \
+        PREFAST_PUSH_DISABLE_EXPLAINED( __WARNING_BANNED_API_28727, "Ignore warnings in non-PlayReady headers" )
+
+    #define PREFAST_POP_IGNORE_WARNINGS_IN_NON_PLAYREADY_HEADERS                                                                                     \
+        PREFAST_POP     /* __WARNING_BANNED_API_28727 */                                                                                             \
+        PREFAST_POP     /* __WARNING_SPEC_INVALID_SYNTAX2_28285 */                                                                                   \
+        PREFAST_POP     /* __WARNING_REQUIREMENT_NOT_SATISFIED_EXPR_NOT_TRUE_28196 */                                                                \
+        PREFAST_POP     /* __WARNING_CONSIDER_USING_ANOTHER_FUNCTION_28159 */                                                                        \
+        PREFAST_POP     /* __WARNING_EXPR_NOT_TRUE_AT_THIS_CALL_28020 */                                                                             \
+        PREFAST_POP     /* __WARNING_HIGH_PRIORITY_OVERFLOW_POSTCONDITION_26045 */                                                                   \
+        PREFAST_POP     /* __WARNING_POSTCONDITION_NULLTERMINATION_VIOLATION_26036 */                                                                \
+        PREFAST_POP     /* __WARNING_PRECONDITION_NULLTERMINATION_VIOLATION_26035 */                                                                 \
+        PREFAST_POP     /* __WARNING_POTENTIAL_BUFFER_OVERFLOW_NULLTERMINATED_26018 */                                                               \
+        PREFAST_POP     /* __WARNING_DEPRECATED_LANGUAGE_TYPE_USED_25113 */                                                                          \
+        PREFAST_POP     /* __WARNING_ENUM_TYPEDEF_25096 */                                                                                           \
+        PREFAST_POP     /* __WARNING_FORMAL_CAN_BE_BOOL_25093 */                                                                                     \
+        PREFAST_POP     /* __WARNING_NO_MEMBERINIT_BEFORE_CONSTRUCTOR_BODY_25071 */                                                                  \
+        PREFAST_POP     /* __WARNING_CAST_CAN_BE_CONST_25058 */                                                                                      \
+        PREFAST_POP     /* __WARNING_USE_SELECT_ANY_25046 */                                                                                         \
+        PREFAST_POP     /* __WARNING_LOCAL_BSTR_SHOULD_BE_CONST_WCHAR_PTR_25043 */                                                                   \
+        PREFAST_POP     /* __WARNING_IF_CONDITION_IS_ALWAYS_TRUE_25041 */                                                                            \
+        PREFAST_POP     /* __WARNING_TRUE_CONSTANT_EXPRESSION_IN_AND_25037 */                                                                        \
+        PREFAST_POP     /* __WARNING_NONCONST_BUFFER_PARAM_25033 */                                                                                  \
+        PREFAST_POP     /* __WARNING_NONCONST_LOCAL_BUFFER_PTR_25032 */                                                                              \
+        PREFAST_POP     /* __WARNING_HRESULT_NOT_CHECKED_25031 */                                                                                    \
+        PREFAST_POP     /* __WARNING_FUNCTION_NEEDS_REVIEW_25028 */                                                                                  \
+        PREFAST_POP     /* __WARNING_UNSAFE_STRING_FUNCTION_25025 */                                                                                 \
+        PREFAST_POP     /* __WARNING_DANGEROUS_POINTERCAST_25024 */                                                                                  \
+        PREFAST_POP     /* __WARNING_POOR_DATA_ALIGNMENT_25021 */                                                                                    \
+        PREFAST_POP     /* __WARNING_NONCONST_PARAM_25004 */
+
+
+
+#else
+
+    /*
+    ** Ensure the SAL tags are a no-op during compilation.
+    */
+    #undef __ecount
+    #undef __bcount
+    #undef __in
+    #undef __in_ecount
+    #undef __in_bcount
+    #undef __in_z
+    #undef __in_ecount_z
+    #undef __in_bcount_z
+    #undef __in_nz
+    #undef __in_ecount_nz
+    #undef __in_bcount_nz
+    #undef __out
+    #undef __out_ecount
+    #undef __out_bcount
+    #undef __out_ecount_part
+    #undef __out_bcount_part
+    #undef __out_ecount_full
+    #undef __out_bcount_full
+    #undef __out_z
+    #undef __out_z_opt
+    #undef __out_ecount_z
+    #undef __out_bcount_z
+    #undef __out_ecount_part_z
+    #undef __out_bcount_part_z
+    #undef __out_ecount_full_z
+    #undef __out_bcount_full_z
+    #undef __out_nz
+    #undef __out_nz_opt
+    #undef __out_ecount_nz
+    #undef __out_bcount_nz
+    #undef __inout
+    #undef __inout_ecount
+    #undef __inout_bcount
+    #undef __inout_ecount_part
+    #undef __inout_bcount_part
+    #undef __inout_ecount_full
+    #undef __inout_bcount_full
+    #undef __inout_z
+    #undef __inout_ecount_z
+    #undef __inout_bcount_z
+    #undef __inout_nz
+    #undef __inout_ecount_nz
+    #undef __inout_bcount_nz
+    #undef __ecount_opt
+    #undef __bcount_opt
+    #undef __in_opt
+    #undef __in_ecount_opt
+    #undef __in_bcount_opt
+    #undef __in_z_opt
+    #undef __in_ecount_z_opt
+    #undef __in_bcount_z_opt
+    #undef __in_nz_opt
+    #undef __in_ecount_nz_opt
+    #undef __in_bcount_nz_opt
+    #undef __out_opt
+    #undef __out_ecount_opt
+    #undef __out_bcount_opt
+    #undef __out_ecount_part_opt
+    #undef __out_bcount_part_opt
+    #undef __out_ecount_full_opt
+    #undef __out_bcount_full_opt
+    #undef __out_ecount_z_opt
+    #undef __out_bcount_z_opt
+    #undef __out_ecount_part_z_opt
+    #undef __out_bcount_part_z_opt
+    #undef __out_ecount_full_z_opt
+    #undef __out_bcount_full_z_opt
+    #undef __out_ecount_nz_opt
+    #undef __out_bcount_nz_opt
+    #undef __inout_opt
+    #undef __inout_ecount_opt
+    #undef __inout_bcount_opt
+    #undef __inout_ecount_part_opt
+    #undef __inout_bcount_part_opt
+    #undef __inout_ecount_full_opt
+    #undef __inout_bcount_full_opt
+    #undef __inout_z_opt
+    #undef __inout_ecount_z_opt
+    #undef __inout_ecount_z_opt
+    #undef __inout_bcount_z_opt
+    #undef __inout_nz_opt
+    #undef __inout_ecount_nz_opt
+    #undef __inout_bcount_nz_opt
+    #undef __deref_ecount
+    #undef __deref_bcount
+    #undef __deref_out
+    #undef __deref_out_ecount
+    #undef __deref_out_bcount
+    #undef __deref_out_ecount_part
+    #undef __deref_out_bcount_part
+    #undef __deref_out_ecount_full
+    #undef __deref_out_bcount_full
+    #undef __deref_out_z
+    #undef __deref_out_ecount_z
+    #undef __deref_out_bcount_z
+    #undef __deref_out_nz
+    #undef __deref_out_ecount_nz
+    #undef __deref_out_bcount_nz
+    #undef __deref_inout
+    #undef __deref_inout_z
+    #undef __deref_inout_ecount
+    #undef __deref_inout_bcount
+    #undef __deref_inout_ecount_part
+    #undef __deref_inout_bcount_part
+    #undef __deref_inout_ecount_full
+    #undef __deref_inout_bcount_full
+    #undef __deref_inout_z
+    #undef __deref_inout_ecount_z
+    #undef __deref_inout_bcount_z
+    #undef __deref_inout_nz
+    #undef __deref_inout_ecount_nz
+    #undef __deref_inout_bcount_nz
+    /* Note: Opt at the end of a __deref TYPE **ppfoo means *ppfoo may be NULL on OUTPUT */
+    #undef __deref_ecount_opt
+    #undef __deref_bcount_opt
+    #undef __deref_out_opt
+    #undef __deref_out_ecount_opt
+    #undef __deref_out_bcount_opt
+    #undef __deref_out_ecount_part_opt
+    #undef __deref_out_bcount_part_opt
+    #undef __deref_out_ecount_full_opt
+    #undef __deref_out_bcount_full_opt
+    #undef __deref_out_z_opt
+    #undef __deref_out_ecount_z_opt
+    #undef __deref_out_bcount_z_opt
+    #undef __deref_out_nz_opt
+    #undef __deref_out_ecount_nz_opt
+    #undef __deref_out_bcount_nz_opt
+    #undef __deref_inout_opt
+    #undef __deref_inout_ecount_opt
+    #undef __deref_inout_bcount_opt
+    #undef __deref_inout_ecount_part_opt
+    #undef __deref_inout_bcount_part_opt
+    #undef __deref_inout_ecount_full_opt
+    #undef __deref_inout_bcount_full_opt
+    #undef __deref_inout_z_opt
+    #undef __deref_inout_ecount_z_opt
+    #undef __deref_inout_bcount_z_opt
+    #undef __deref_inout_nz_opt
+    #undef __deref_inout_ecount_nz_opt
+    #undef __deref_inout_bcount_nz_opt
+    /* Note: Opt at the start of a __deref TYPE **ppfoo means ppfoo may be NULL on INPUT */
+    #undef __deref_opt_in_ecount
+    #undef __deref_opt_ecount
+    #undef __deref_opt_bcount
+    #undef __deref_opt_out
+    #undef __deref_opt_out_z
+    #undef __deref_opt_out_ecount
+    #undef __deref_opt_out_bcount
+    #undef __deref_opt_out_ecount_part
+    #undef __deref_opt_out_bcount_part
+    #undef __deref_opt_out_ecount_full
+    #undef __deref_opt_out_bcount_full
+    #undef __deref_opt_inout
+    #undef __deref_opt_inout_ecount
+    #undef __deref_opt_inout_bcount
+    #undef __deref_opt_inout_ecount_part
+    #undef __deref_opt_inout_bcount_part
+    #undef __deref_opt_inout_ecount_full
+    #undef __deref_opt_inout_bcount_full
+    #undef __deref_opt_inout_z
+    #undef __deref_opt_inout_ecount_z
+    #undef __deref_opt_inout_bcount_z
+    #undef __deref_opt_inout_nz
+    #undef __deref_opt_inout_ecount_nz
+    #undef __deref_opt_inout_bcount_nz
+    #undef __deref_opt_ecount_opt
+    #undef __deref_opt_bcount_opt
+    #undef __deref_opt_out_opt
+    #undef __deref_opt_out_ecount_opt
+    #undef __deref_opt_out_bcount_opt
+    #undef __deref_opt_out_ecount_part_opt
+    #undef __deref_opt_out_bcount_part_opt
+    #undef __deref_opt_out_ecount_full_opt
+    #undef __deref_opt_out_bcount_full_opt
+    #undef __deref_opt_out_z_opt
+    #undef __deref_opt_out_ecount_z_opt
+    #undef __deref_opt_out_bcount_z_opt
+    #undef __deref_opt_out_nz_opt
+    #undef __deref_opt_out_ecount_nz_opt
+    #undef __deref_opt_out_bcount_nz_opt
+    #undef __deref_opt_inout_opt
+    #undef __deref_opt_inout_ecount_opt
+    #undef __deref_opt_inout_bcount_opt
+    #undef __deref_opt_inout_ecount_part_opt
+    #undef __deref_opt_inout_bcount_part_opt
+    #undef __deref_opt_inout_ecount_full_opt
+    #undef __deref_opt_inout_bcount_full_opt
+    #undef __deref_opt_inout_z_opt
+    #undef __deref_opt_inout_ecount_z_opt
+    #undef __deref_opt_inout_bcount_z_opt
+    #undef __deref_opt_inout_nz_opt
+    #undef __deref_opt_inout_ecount_nz_opt
+    #undef __deref_opt_inout_bcount_nz_opt
+    #undef __success
+    #undef __nullterminated
+    #undef __nullnullterminated
+    #undef __reserved
+    #undef __checkReturn
+    #undef __typefix
+    #undef __override
+    #undef __callback
+    #undef __format_string
+    #undef __blocksOn
+    #undef __control_entrypoint
+    #undef __data_entrypoint
+    #undef __analysis_assume
+    #undef _In_count_
+    #undef _Out_opt_cap_
+    #undef _Deref_pre_z_
+    #undef _Deref_pre_opt_z_
+    #undef _Deref_post_opt_z_
+    #undef _Deref_post_opt_count_
+    #undef _Deref_prepost_z_
+    #undef _Acquires_lock_
+    #undef _Releases_lock_
+    #undef __in_xcount
+    #undef _Deref_pre_maybenull_
+
+    #undef __drv_freesMem
+    #undef __fallthrough
+    #undef _At_
+    #undef _At_buffer_
+    #undef _When_
+    #undef _Success_
+    #undef _On_failure_
+    #undef _Always_
+    #undef _Const_
+    #undef _In_
+    #undef _In_opt_
+    #undef _In_z_
+    #undef _In_opt_z_
+    #undef _In_reads_
+    #undef _In_reads_opt_
+    #undef _In_reads_bytes_
+    #undef _In_reads_bytes_opt_
+    #undef _In_reads_or_z_
+    #undef _In_reads_or_z_opt_
+    #undef _Out_
+    #undef _Out_opt_
+    #undef _Out_writes_
+    #undef _Out_writes_opt_
+    #undef _Out_writes_bytes_
+    #undef _Out_writes_bytes_opt_
+    #undef _Out_writes_z_
+    #undef _Out_writes_opt_z_
+    #undef _Out_writes_to_
+    #undef _Out_writes_to_opt_
+    #undef _Out_writes_all_
+    #undef _Out_writes_all_opt_
+    #undef _Out_writes_bytes_to_
+    #undef _Out_writes_bytes_to_opt_
+    #undef _Out_writes_bytes_all_
+    #undef _Out_writes_bytes_all_opt_
+    #undef _Inout_
+    #undef _Inout_opt_
+    #undef _Inout_z_
+    #undef _Inout_opt_z_
+    #undef _Inout_updates_
+    #undef _Inout_updates_opt_
+    #undef _Inout_updates_z_
+    #undef _Inout_updates_opt_z_
+    #undef _Inout_updates_to_
+    #undef _Inout_updates_to_opt_
+    #undef _Inout_updates_bytes_
+    #undef _Inout_updates_bytes_opt_
+    #undef _Outptr_
+    #undef _Outptr_result_maybenull_
+    #undef _Outptr_opt_
+    #undef _Outptr_opt_result_maybenull_
+    #undef _Outptr_result_z_
+    #undef _Outptr_opt_result_z_
+    #undef _Outptr_result_maybenull_z_
+    #undef _Outptr_opt_result_maybenull_z_
+    #undef _Outptr_result_nullonfailure_
+    #undef _Outptr_opt_result_nullonfailure_
+    #undef _Outptr_result_buffer_
+    #undef _Outptr_opt_result_buffer_
+    #undef _Outptr_result_buffer_to_
+    #undef _Outptr_opt_result_buffer_to_
+    #undef _Outptr_result_buffer_maybenull_
+    #undef _Outptr_opt_result_buffer_maybenull_
+    #undef _Outptr_result_bytebuffer_
+    #undef _Outptr_opt_result_bytebuffer_
+    #undef _Outptr_result_bytebuffer_maybenull_
+    #undef _Outptr_opt_result_bytebuffer_maybenull_
+    #undef _Ret_writes_bytes_to_
+    #undef _Check_return_
+    #undef _Printf_format_string_
+    #undef _Post_equal_to_
+    #undef _Pre_satisfies_
+    #undef _Post_satisfies_
+    #undef _Field_size_full_opt_
+    #undef _Field_size_bytes_full_opt_
+    #undef _Field_range_
+    #undef _Pre_readable_size_
+    #undef _Pre_readable_byte_size_
+    #undef _Null_terminated_
+    #undef _Post_maybenull_
+    #undef _Analysis_assume_
+    #undef _Analysis_assume_nullterminated_
+    #undef _Iter_
+    #undef _String_length_
+    #undef _Old_
+
+
+    #define __ecount(size)
+    #define __bcount(size)
+    #define __in
+    #define __in_ecount(size)
+    #define __in_bcount(size)
+    #define __in_z
+    #define __in_ecount_z(size)
+    #define __in_bcount_z(size)
+    #define __in_nz
+    #define __in_ecount_nz(size)
+    #define __in_bcount_nz(size)
+    #define __out
+    #define __out_ecount(size)
+    #define __out_bcount(size)
+    #define __out_ecount_part(size,length)
+    #define __out_bcount_part(size,length)
+    #define __out_ecount_full(size)
+    #define __out_bcount_full(size)
+    #define __out_z
+    #define __out_z_opt
+    #define __out_ecount_z(size)
+    #define __out_bcount_z(size)
+    #define __out_ecount_part_z(size,length)
+    #define __out_bcount_part_z(size,length)
+    #define __out_ecount_full_z(size)
+    #define __out_bcount_full_z(size)
+    #define __out_nz
+    #define __out_nz_opt
+    #define __out_ecount_nz(size)
+    #define __out_bcount_nz(size)
+    #define __inout
+    #define __inout_ecount(size)
+    #define __inout_bcount(size)
+    #define __inout_ecount_part(size,length)
+    #define __inout_bcount_part(size,length)
+    #define __inout_ecount_full(size)
+    #define __inout_bcount_full(size)
+    #define __inout_z
+    #define __inout_ecount_z(size)
+    #define __inout_bcount_z(size)
+    #define __inout_nz
+    #define __inout_ecount_nz(size)
+    #define __inout_bcount_nz(size)
+    #define __ecount_opt(size)
+    #define __bcount_opt(size)
+    #define __in_opt
+    #define __in_ecount_opt(size)
+    #define __in_bcount_opt(size)
+    #define __in_z_opt
+    #define __in_ecount_z_opt(size)
+    #define __in_bcount_z_opt(size)
+    #define __in_nz_opt
+    #define __in_ecount_nz_opt(size)
+    #define __in_bcount_nz_opt(size)
+    #define __out_opt
+    #define __out_ecount_opt(size)
+    #define __out_bcount_opt(size)
+    #define __out_ecount_part_opt(size,length)
+    #define __out_bcount_part_opt(size,length)
+    #define __out_ecount_full_opt(size)
+    #define __out_bcount_full_opt(size)
+    #define __out_ecount_z_opt(size)
+    #define __out_bcount_z_opt(size)
+    #define __out_ecount_part_z_opt(size,length)
+    #define __out_bcount_part_z_opt(size,length)
+    #define __out_ecount_full_z_opt(size)
+    #define __out_bcount_full_z_opt(size)
+    #define __out_ecount_nz_opt(size)
+    #define __out_bcount_nz_opt(size)
+    #define __inout_opt
+    #define __inout_ecount_opt(size)
+    #define __inout_bcount_opt(size)
+    #define __inout_ecount_part_opt(size,length)
+    #define __inout_bcount_part_opt(size,length)
+    #define __inout_ecount_full_opt(size)
+    #define __inout_bcount_full_opt(size)
+    #define __inout_z_opt
+    #define __inout_ecount_z_opt(size)
+    #define __inout_ecount_z_opt(size)
+    #define __inout_bcount_z_opt(size)
+    #define __inout_nz_opt
+    #define __inout_ecount_nz_opt(size)
+    #define __inout_bcount_nz_opt(size)
+    #define __deref_ecount(size)
+    #define __deref_bcount(size)
+    #define __deref_out
+    #define __deref_out_ecount(size)
+    #define __deref_out_bcount(size)
+    #define __deref_out_ecount_part(size,length)
+    #define __deref_out_bcount_part(size,length)
+    #define __deref_out_ecount_full(size)
+    #define __deref_out_bcount_full(size)
+    #define __deref_out_z
+    #define __deref_out_ecount_z(size)
+    #define __deref_out_bcount_z(size)
+    #define __deref_out_nz
+    #define __deref_out_ecount_nz(size)
+    #define __deref_out_bcount_nz(size)
+    #define __deref_inout
+    #define __deref_inout_z
+    #define __deref_inout_ecount(size)
+    #define __deref_inout_bcount(size)
+    #define __deref_inout_ecount_part(size,length)
+    #define __deref_inout_bcount_part(size,length)
+    #define __deref_inout_ecount_full(size)
+    #define __deref_inout_bcount_full(size)
+    #define __deref_inout_z
+    #define __deref_inout_ecount_z(size)
+    #define __deref_inout_bcount_z(size)
+    #define __deref_inout_nz
+    #define __deref_inout_ecount_nz(size)
+    #define __deref_inout_bcount_nz(size)
+    #define __deref_ecount_opt(size)
+    #define __deref_bcount_opt(size)
+    #define __deref_out_opt
+    #define __deref_out_ecount_opt(size)
+    #define __deref_out_bcount_opt(size)
+    #define __deref_out_ecount_part_opt(size,length)
+    #define __deref_out_bcount_part_opt(size,length)
+    #define __deref_out_ecount_full_opt(size)
+    #define __deref_out_bcount_full_opt(size)
+    #define __deref_out_z_opt
+    #define __deref_out_ecount_z_opt(size)
+    #define __deref_out_bcount_z_opt(size)
+    #define __deref_out_nz_opt
+    #define __deref_out_ecount_nz_opt(size)
+    #define __deref_out_bcount_nz_opt(size)
+    #define __deref_inout_opt
+    #define __deref_inout_ecount_opt(size)
+    #define __deref_inout_bcount_opt(size)
+    #define __deref_inout_ecount_part_opt(size,length)
+    #define __deref_inout_bcount_part_opt(size,length)
+    #define __deref_inout_ecount_full_opt(size)
+    #define __deref_inout_bcount_full_opt(size)
+    #define __deref_inout_z_opt
+    #define __deref_inout_ecount_z_opt(size)
+    #define __deref_inout_bcount_z_opt(size)
+    #define __deref_inout_nz_opt
+    #define __deref_inout_ecount_nz_opt(size)
+    #define __deref_inout_bcount_nz_opt(size)
+    #define __deref_opt_in_ecount(size)
+    #define __deref_opt_ecount(size)
+    #define __deref_opt_bcount(size)
+    #define __deref_opt_out
+    #define __deref_opt_out_z
+    #define __deref_opt_out_ecount(size)
+    #define __deref_opt_out_bcount(size)
+    #define __deref_opt_out_ecount_part(size,length)
+    #define __deref_opt_out_bcount_part(size,length)
+    #define __deref_opt_out_ecount_full(size)
+    #define __deref_opt_out_bcount_full(size)
+    #define __deref_opt_inout
+    #define __deref_opt_inout_ecount(size)
+    #define __deref_opt_inout_bcount(size)
+    #define __deref_opt_inout_ecount_part(size,length)
+    #define __deref_opt_inout_bcount_part(size,length)
+    #define __deref_opt_inout_ecount_full(size)
+    #define __deref_opt_inout_bcount_full(size)
+    #define __deref_opt_inout_z
+    #define __deref_opt_inout_ecount_z(size)
+    #define __deref_opt_inout_bcount_z(size)
+    #define __deref_opt_inout_nz
+    #define __deref_opt_inout_ecount_nz(size)
+    #define __deref_opt_inout_bcount_nz(size)
+    #define __deref_opt_ecount_opt(size)
+    #define __deref_opt_bcount_opt(size)
+    #define __deref_opt_out_opt
+    #define __deref_opt_out_ecount_opt(size)
+    #define __deref_opt_out_bcount_opt(size)
+    #define __deref_opt_out_ecount_part_opt(size,length)
+    #define __deref_opt_out_bcount_part_opt(size,length)
+    #define __deref_opt_out_ecount_full_opt(size)
+    #define __deref_opt_out_bcount_full_opt(size)
+    #define __deref_opt_out_z_opt
+    #define __deref_opt_out_ecount_z_opt(size)
+    #define __deref_opt_out_bcount_z_opt(size)
+    #define __deref_opt_out_nz_opt
+    #define __deref_opt_out_ecount_nz_opt(size)
+    #define __deref_opt_out_bcount_nz_opt(size)
+    #define __deref_opt_inout_opt
+    #define __deref_opt_inout_ecount_opt(size)
+    #define __deref_opt_inout_bcount_opt(size)
+    #define __deref_opt_inout_ecount_part_opt(size,length)
+    #define __deref_opt_inout_bcount_part_opt(size,length)
+    #define __deref_opt_inout_ecount_full_opt(size)
+    #define __deref_opt_inout_bcount_full_opt(size)
+    #define __deref_opt_inout_z_opt
+    #define __deref_opt_inout_ecount_z_opt(size)
+    #define __deref_opt_inout_bcount_z_opt(size)
+    #define __deref_opt_inout_nz_opt
+    #define __deref_opt_inout_ecount_nz_opt(size)
+    #define __deref_opt_inout_bcount_nz_opt(size)
+    #define __success(expr)
+    #define __nullterminated
+    #define __nullnullterminated
+    #define __reserved
+    #define __checkReturn
+    #define __typefix(ctype)
+    #define __override
+    #define __callback
+    #define __format_string
+    #define __blocksOn(resource)
+    #define __control_entrypoint(category)
+    #define __data_entrypoint(category)
+    #define __analysis_assume(expr)
+    #define _In_count_(size)
+    #define _Out_opt_cap_(size)
+    #define _Deref_pre_z_
+    #define _Deref_pre_opt_z_
+    #define _Deref_post_opt_z_
+    #define _Deref_post_opt_count_(size)
+    #define _Deref_prepost_z_
+    #define _Deref_pre_maybenull_
+    #define _Acquires_lock_(lock)
+    #define _Releases_lock_(lock)
+    #define __in_xcount(size)
+
+    #define __fallthrough
+    #define __drv_freesMem(type)
+    #define _At_(target, annos)
+    #define _At_buffer_(target, iter, bound, annos)
+    #define _When_(expr,anno)
+    #define _On_failure_(annos)
+    #define _Success_(expr)
+    #define _Always_(annos)
+    #define _Const_
+    #define _In_
+    #define _In_opt_
+    #define _In_z_
+    #define _In_opt_z_
+    #define _In_reads_(size)
+    #define _In_reads_opt_(size)
+    #define _In_reads_bytes_(size)
+    #define _In_reads_bytes_opt_(size)
+    #define _In_reads_or_z_(size)
+    #define _In_reads_or_z_opt_(size)
+    #define _Out_
+    #define _Out_opt_
+    #define _Out_writes_(size)
+    #define _Out_writes_opt_(size)
+    #define _Out_writes_bytes_(size)
+    #define _Out_writes_bytes_opt_(size)
+    #define _Out_writes_z_(size)
+    #define _Out_writes_opt_z_(size)
+    #define _Out_writes_to_(size,count)
+    #define _Out_writes_to_opt_(size,count)
+    #define _Out_writes_all_(size)
+    #define _Out_writes_all_opt_(size)
+    #define _Out_writes_bytes_to_(size,count)
+    #define _Out_writes_bytes_to_opt_(size,count)
+    #define _Out_writes_bytes_all_(size)
+    #define _Out_writes_bytes_all_opt_(size)
+    #define _Inout_
+    #define _Inout_opt_
+    #define _Inout_z_
+    #define _Inout_opt_z_
+    #define _Inout_updates_(size)
+    #define _Inout_updates_opt_(size)
+    #define _Inout_updates_z_(size)
+    #define _Inout_updates_opt_z_(size)
+    #define _Inout_updates_to_(size,count)
+    #define _Inout_updates_to_opt_(size,count)
+    #define _Inout_updates_bytes_(size)
+    #define _Inout_updates_bytes_opt_(size)
+    #define _Outptr_
+    #define _Outptr_result_maybenull_
+    #define _Outptr_opt_
+    #define _Outptr_opt_result_maybenull_
+    #define _Outptr_result_z_
+    #define _Outptr_opt_result_z_
+    #define _Outptr_result_maybenull_z_
+    #define _Outptr_opt_result_maybenull_z_
+    #define _Outptr_result_nullonfailure_
+    #define _Outptr_opt_result_nullonfailure_
+    #define _Outptr_result_buffer_(size)
+    #define _Outptr_opt_result_buffer_(size)
+    #define _Outptr_result_buffer_to_(size, count)
+    #define _Outptr_opt_result_buffer_to_(size, count)
+    #define _Outptr_result_buffer_maybenull_(size)
+    #define _Outptr_opt_result_buffer_maybenull_(size)
+    #define _Outptr_result_bytebuffer_(size)
+    #define _Outptr_opt_result_bytebuffer_(size)
+    #define _Outptr_result_bytebuffer_maybenull_(size)
+    #define _Outptr_opt_result_bytebuffer_maybenull_(size)
+    #define _Ret_writes_bytes_to_(size,count)
+    #define _Check_return_
+    #define _Printf_format_string_
+    #define _Post_equal_to_(expr)
+    #define _Pre_satisfies_(cond)
+    #define _Post_satisfies_(cond)
+    #define _Field_size_full_opt_(size)
+    #define _Field_size_bytes_full_opt_(expr)
+    #define _Field_range_(min,max)
+    #define _Pre_readable_size_(size)
+    #define _Pre_readable_byte_size_(size)
+    #define _Null_terminated_
+    #define _Post_maybenull_
+    #define _Analysis_assume_(expr)
+    #define _Analysis_assume_nullterminated_(str)
+    #define _Iter_
+    #define _String_length_(str)
+    #define _Old_(param)
+
+    #define PREFAST_PUSH_IGNORE_WARNINGS_IN_NON_PLAYREADY_HEADERS
+    #define PREFAST_POP_IGNORE_WARNINGS_IN_NON_PLAYREADY_HEADERS
+
+#endif
+
+#ifndef DRM_MSC_VER
+#ifndef UNREFERENCED_PARAMETER
+#define UNREFERENCED_PARAMETER(p)
+#endif  /* UNREFERENCED_PARAMETER */
+#endif  /* DRM_MSC_VER */
+
+#if DRM_API_DEFAULT
+#undef DRM_API
+#define DRM_API  __checkReturn
+#define DRM_API_VOID
+#endif /* DRM_API_DEFAULT */
+
+
+/*
+** for DRM_TEE_ APIs DRM_TEE_BYTE_BLOB parameters are not optional
+** yet for some their inner pb variables are. This annotation describes that
+*/
+#define __in_tee_opt __in
+#define __inout_tee_opt __inout
+
+#define _Out_writes_bts_(size) _Out_writes_to_opt_(_Old_(size),size) _Post_satisfies_(size <= _Old_(size))
+#define _Out_writes_bts2_(p,size) _Out_writes_bts_(size) _When_(p == NULL, _Post_satisfies_(return<0))
+
+#endif  /* __DRMSAL_H__ */
+
diff --git a/prebuilt-v4.4/noarch/include/drmsecurecore.h b/prebuilt-v4.4/noarch/include/drmsecurecore.h
new file mode 100644
index 0000000..79052a1
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmsecurecore.h
@@ -0,0 +1,121 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef _DRMSECURECORE_H_
+#define _DRMSECURECORE_H_ 1
+
+#include <drmsecurecoreconstants.h>
+#include <drmsecurecorefuncptrdefs.h>
+#include <oemciphertypes.h>
+#include <drmnoncestore.h>
+#include <drmrevocationstore.h>
+#include <drmsecurecoretypes.h>
+#include <drmlicgentypes.h>
+#include <drmlicgen.h>
+#include <drmxmlbuildera.h>
+
+PREFAST_PUSH_DISABLE_EXPLAINED( __WARNING_NONCONST_PARAM_25004, "Prefast Noise: DRM_SECURECORE_CONTEXT* should not be const." );
+PREFAST_PUSH_DISABLE_EXPLAINED( __WARNING_NONCONST_BUFFER_PARAM_25033, "Prefast Noise: DRM_SECURECORE_CONTEXT* should not be const." );
+
+ENTER_PK_NAMESPACE;
+
+typedef DRM_API DRM_RESULT (DRM_CALL *LPFN_DRM_SECURECORE_FUNCTBL_INITIALIZER)(
+    __inout                             DRM_VOID                *f_pSecureCoreFuncTbl );
+
+#define DRM_SC_DEF_FOR_EXTCALLERS   1
+
+#include <drmsecurecore_template.h>
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_SECURECORE_FUNCTBL_Initializer(
+    __inout                             DRM_VOID                *f_pSecureCoreFuncTbl );
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_SECURECORE_TEE_FUNCTBL_Initializer(
+    __inout                             DRM_VOID                *f_pSecureCoreFuncTbl );
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_SECURECORE_NOTEE_FUNCTBL_Initializer(
+    __inout                             DRM_VOID                *f_pSecureCoreFuncTbl );
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_SECURECORE_INT_FUNCTBL_Initializer(
+    __inout                             DRM_VOID                *f_pSecureCoreFuncTbl );
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_SECURECORE_NOSCINIT_FUNCTBL_Initializer(
+    __inout                             DRM_VOID                *f_pSecureCoreFuncTbl );
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_SECURECORE_PreInitialize(
+    __in                                                      LPFN_DRM_SECURECORE_FUNCTBL_INITIALIZER     f_pfnSecureCoreFuncTblInit,
+    __inout                                                   DRM_SECURECORE_CONTEXT                     *f_pSecureCoreCtx,
+    __in_opt                                                  DRM_VOID                                   *f_pOEMContext,
+    __out                                                     DRM_VOID                                  **f_ppvPreInitializeContext,
+    __out                                                     DRM_ID                                     *f_pCurrentAppId,
+    __out                                                     DRM_ID                                     *f_pUniqueId,
+    __out_opt                                                 DRM_SECURECORE_VERSIONINFO                 *f_pSecureCoreVerInfo,
+    __out_ecount_opt( DRM_TEE_METHOD_FUNCTION_MAP_COUNT )     DRM_DWORD                                  *f_pdwFunctionMap ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_SECURECORE_Initialize(
+    __in                                                      LPFN_DRM_SECURECORE_FUNCTBL_INITIALIZER     f_pfnSecureCoreFuncTblInit,
+    __inout                                                   DRM_SECURECORE_CONTEXT                     *f_pSecureCoreCtx,
+    __in_opt                                                  DRM_VOID                                   *f_pOEMContext,
+    __in                                                      DRM_DWORD                                   f_cchVersion,
+    __in_ecount( f_cchVersion )                               DRM_CHAR                                   *f_pszVersion,
+    __in                                                      DRM_DST                                    *f_pHDS,
+    __in_opt                                            const DRM_CONST_STRING                           *f_pdstrDeviceStoreName,
+    __in                                                      DRM_DWORD                                   f_cbWorkingBuffer,
+    __inout_bcount( f_cbWorkingBuffer )                       DRM_BYTE                                   *f_pbWorkingBuffer,
+    __inout_opt                                               DRM_VOID                                  **f_ppvPreInitializeContext,
+    __in_opt                                                  DRM_ID                                     *f_pCurrentAppId,
+    __out_opt                                                 DRM_SECURECORE_VERSIONINFO                 *f_pSecureCoreVerInfo,
+    __out_ecount_opt( DRM_TEE_METHOD_FUNCTION_MAP_COUNT )     DRM_DWORD                                  *f_pdwFunctionMap ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_BOOL DRM_CALL DRM_SECURECORE_IsInternal( DRM_VOID ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_SECURECORE_GetDeviceCertData(
+    __inout                               DRM_SECURECORE_CONTEXT    *f_pSecureCoreCtx,
+    __in                                  DRM_BOOL                   f_fB64Encoded,
+    __out_ecount_opt( *f_pcchDeviceCert ) DRM_CHAR                  *f_pchDeviceCert,
+    __inout_opt                           DRM_DWORD                 *f_pcchDeviceCert,
+    __out_ecount_opt( 1 )                 PUBKEY_P256               *f_poECC256SignPubKey,
+    __out_ecount_opt( 1 )                 DRM_DWORD                 *f_pdwSecurityLevel ) DRM_NO_INLINE_ATTRIBUTE;
+
+_Pre_satisfies_( ( f_poXMLContext == NULL ) != ( f_pcbXml == NULL ) )
+_Pre_satisfies_( f_poXMLContext == NULL || f_poXMLContext->ichNextString < f_poXMLContext->cchBuffer )
+_Pre_satisfies_( f_poXMLContext == NULL || f_poXMLContext->ichNextOpenNode < f_poXMLContext->cchBuffer )
+_Post_satisfies_( f_poXMLContext == NULL || f_poXMLContext->ichNextString < f_poXMLContext->cchBuffer )
+_Post_satisfies_( f_poXMLContext == NULL || f_poXMLContext->ichNextOpenNode < f_poXMLContext->cchBuffer )
+_At_( f_poXMLContext->cchBuffer, _Const_ )
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_SECURECORE_BuildReeFeatureXml(
+    _In_              DRM_SECURECORE_CONTEXT    *f_pSecureCoreCtx,
+    _Inout_opt_       _XMBContextA              *f_poXMLContext,
+    _Inout_opt_       DRM_DWORD                 *f_pcbXml );
+
+_Pre_satisfies_( ( f_poXMLContext == NULL ) != ( f_pcbXml == NULL ) )
+_Pre_satisfies_( f_poXMLContext == NULL || f_poXMLContext->ichNextString < f_poXMLContext->cchBuffer )
+_Pre_satisfies_( f_poXMLContext == NULL || f_poXMLContext->ichNextOpenNode < f_poXMLContext->cchBuffer )
+_Post_satisfies_( f_poXMLContext == NULL || f_poXMLContext->ichNextString < f_poXMLContext->cchBuffer )
+_Post_satisfies_( f_poXMLContext == NULL || f_poXMLContext->ichNextOpenNode < f_poXMLContext->cchBuffer )
+_At_( f_poXMLContext->cchBuffer, _Const_ )
+DRM_API DRM_RESULT DRM_CALL DRM_SECURECORE_AddReeFeatures(
+    _In_              DRM_SECURECORE_CONTEXT *f_pSecureCoreCtx,
+    _Inout_opt_       _XMBContextA           *f_poXMLContext,
+    _Inout_opt_       DRM_DWORD              *f_pcbXml );
+
+/*
+** Licenses and Domains use the exact same password except that the
+** former uses the LID while the latter uses the Domain Account ID,
+** so there's no reason to create a separate API for domains.
+*/
+#define DRM_SECURECORE_CreateDomainStorePassword DRM_SECURECORE_CreateLicenseStateStorePassword
+
+#undef DRM_SC_DEF_FOR_EXTCALLERS
+
+EXIT_PK_NAMESPACE;
+
+PREFAST_POP; /* __WARNING_NONCONST_BUFFER_PARAM_25033 */
+PREFAST_POP; /* __WARNING_NONCONST_PARAM_25004 */
+
+#endif /* _DRMSECURECORE_H_ */
+
diff --git a/prebuilt-v4.4/noarch/include/drmsecurecore_int.h b/prebuilt-v4.4/noarch/include/drmsecurecore_int.h
new file mode 100644
index 0000000..62f119e
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmsecurecore_int.h
@@ -0,0 +1,59 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef _DRMSECURECORE_INT_H_
+#define _DRMSECURECORE_INT_H_ 1
+
+#include <drmsecurecoreconstants.h>
+#include <oemciphertypes.h>
+#include <drmnoncestore.h>
+#include <drmrevocationstore.h>
+#include <drmlicgentypes.h>
+#include <drmlicgen.h>
+#include <drmblackboxtypes_bbxonly.h>
+
+PREFAST_PUSH_DISABLE_EXPLAINED( __WARNING_NONCONST_PARAM_25004, "Prefast Noise: DRM_SECURECORE_CONTEXT* should not be const." );
+PREFAST_PUSH_DISABLE_EXPLAINED( __WARNING_NONCONST_BUFFER_PARAM_25033, "Prefast Noise: DRM_SECURECORE_CONTEXT* should not be const." );
+
+ENTER_PK_NAMESPACE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_SECURECORE_INT_PreInitialize(
+    __in_opt                                                  DRM_VOID                       *f_pOEMContext,
+    __out                                                     DRM_VOID                      **f_ppvPreInitializeContext,
+    __out                                                     DRM_ID                         *f_pCurrentAppId,
+    __out                                                     DRM_ID                         *f_pUniqueId,
+    __out_opt                                                 DRM_SECURECORE_VERSIONINFO     *f_pSecureCoreVerInfo,
+    __out_ecount_opt( DRM_TEE_METHOD_FUNCTION_MAP_COUNT )     DRM_DWORD                      *f_pdwFunctionMap ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_SECURECORE_INT_Initialize(
+    __inout                                                   DRM_SECURECORE_CONTEXT         *f_pSecureCoreCtx,
+    __in_opt                                                  DRM_VOID                       *f_pOEMContext,
+    __in                                                      DRM_DWORD                       f_cchVersion,
+    __in_ecount( f_cchVersion )                               DRM_CHAR                       *f_pszVersion,
+    __in                                                      DRM_DST                        *f_pHDS,
+    __in_opt                                            const DRM_CONST_STRING               *f_pdstrDeviceStoreName,
+    __in                                                      DRM_DWORD                       f_cbWorkingBuffer,
+    __inout_bcount( f_cbWorkingBuffer )                       DRM_BYTE                       *f_pbWorkingBuffer,
+    __inout_opt                                               DRM_VOID                      **f_ppvPreInitializeContext,
+    __in_opt                                                  DRM_ID                         *f_pCurrentAppId,
+    __out_opt                                                 DRM_SECURECORE_VERSIONINFO     *f_pSecureCoreVerInfo,
+    __out_ecount_opt( DRM_TEE_METHOD_FUNCTION_MAP_COUNT )     DRM_DWORD                      *f_pdwFunctionMap ) DRM_NO_INLINE_ATTRIBUTE;
+
+#define DRM_SC_DEF_FOR_INT 1
+
+#include <drmsecurecore_template.h>
+
+#undef DRM_SC_DEF_FOR_INT
+
+EXIT_PK_NAMESPACE;
+
+PREFAST_POP; /* __WARNING_NONCONST_BUFFER_PARAM_25033 */
+PREFAST_POP; /* __WARNING_NONCONST_PARAM_25004 */
+
+#endif /* _DRMSECURECORE_INT_H_ */
+
diff --git a/prebuilt-v4.4/noarch/include/drmsecurecore_notee.h b/prebuilt-v4.4/noarch/include/drmsecurecore_notee.h
new file mode 100644
index 0000000..3ef811e
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmsecurecore_notee.h
@@ -0,0 +1,58 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef _DRMSECURECORE_NOTEE_H_
+#define _DRMSECURECORE_NOTEE_H_ 1
+
+#include <drmsecurecoreconstants.h>
+#include <oemciphertypes.h>
+#include <drmnoncestore.h>
+#include <drmrevocationstore.h>
+#include <drmlicgentypes.h>
+#include <drmlicgen.h>
+
+PREFAST_PUSH_DISABLE_EXPLAINED( __WARNING_NONCONST_PARAM_25004, "Prefast Noise: DRM_SECURECORE_CONTEXT* should not be const." );
+PREFAST_PUSH_DISABLE_EXPLAINED( __WARNING_NONCONST_BUFFER_PARAM_25033, "Prefast Noise: DRM_SECURECORE_CONTEXT* should not be const." );
+
+ENTER_PK_NAMESPACE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_SECURECORE_NOTEE_PreInitialize(
+    __in_opt                                                  DRM_VOID                       *f_pOEMContext,
+    __out                                                     DRM_VOID                      **f_ppvPreInitializeContext,
+    __out                                                     DRM_ID                         *f_pCurrentAppId,
+    __out                                                     DRM_ID                         *f_pUniqueId,
+    __out_opt                                                 DRM_SECURECORE_VERSIONINFO     *f_pSecureCoreVerInfo,
+    __out_ecount_opt( DRM_TEE_METHOD_FUNCTION_MAP_COUNT )     DRM_DWORD                      *f_pdwFunctionMap ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_SECURECORE_NOTEE_Initialize(
+    __inout                                                   DRM_SECURECORE_CONTEXT         *f_pSecureCoreCtx,
+    __in_opt                                                  DRM_VOID                       *f_pOEMContext,
+    __in                                                      DRM_DWORD                       f_cchVersion,
+    __in_ecount( f_cchVersion )                               DRM_CHAR                       *f_pszVersion,
+    __in                                                      DRM_DST                        *f_pHDS,
+    __in_opt                                            const DRM_CONST_STRING               *f_pdstrDeviceStoreName,
+    __in                                                      DRM_DWORD                       f_cbWorkingBuffer,
+    __inout_bcount( f_cbWorkingBuffer )                       DRM_BYTE                       *f_pbWorkingBuffer,
+    __inout_opt                                               DRM_VOID                      **f_ppvPreInitializeContext,
+    __in_opt                                                  DRM_ID                         *f_pCurrentAppId,
+    __out_opt                                                 DRM_SECURECORE_VERSIONINFO     *f_pSecureCoreVerInfo,
+    __out_ecount_opt( DRM_TEE_METHOD_FUNCTION_MAP_COUNT )     DRM_DWORD                      *f_pdwFunctionMap ) DRM_NO_INLINE_ATTRIBUTE;
+
+#define DRM_SC_DEF_FOR_NOTEE 1
+
+#include <drmsecurecore_template.h>
+
+#undef DRM_SC_DEF_FOR_NOTEE
+
+EXIT_PK_NAMESPACE;
+
+PREFAST_POP; /* __WARNING_NONCONST_BUFFER_PARAM_25033 */
+PREFAST_POP; /* __WARNING_NONCONST_PARAM_25004 */
+
+#endif /* _DRMSECURECORE_NOTEE_H_ */
+
diff --git a/prebuilt-v4.4/noarch/include/drmsecurecore_tee.h b/prebuilt-v4.4/noarch/include/drmsecurecore_tee.h
new file mode 100644
index 0000000..45f49e1
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmsecurecore_tee.h
@@ -0,0 +1,94 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef _DRMSECURECORE_H_
+#define _DRMSECURECORE_H_ 1
+
+#include <drmsecurecoreconstants.h>
+#include <oemciphertypes.h>
+#include <drmnoncestore.h>
+#include <drmrevocationstore.h>
+#include <drmlicgentypes.h>
+#include <drmlicgen.h>
+
+PREFAST_PUSH_DISABLE_EXPLAINED( __WARNING_NONCONST_PARAM_25004, "Prefast Noise: DRM_SECURECORE_CONTEXT* should not be const." );
+PREFAST_PUSH_DISABLE_EXPLAINED( __WARNING_NONCONST_BUFFER_PARAM_25033, "Prefast Noise: DRM_SECURECORE_CONTEXT* should not be const." );
+
+ENTER_PK_NAMESPACE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_SECURECORE_TEE_BASE_OpenConfigNamespace(
+    __in    DRM_DST                     *f_pHDS,
+    __out   DRM_DST_NAMESPACE_CONTEXT   *f_pNsCtx,
+    __out   DRM_BOOL                    *f_pfNsOpen ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_SECURECORE_TEE_BASE_SlotWriteHelper(
+    __in                       DRM_DST                     *f_pHDS,
+    __in                       DRM_DST_NAMESPACE_CONTEXT   *f_pNsCtx,
+    __in                       DRM_DST_SLOT_CONTEXT        *f_pSlot,
+    __inout                    DRM_BOOL                    *f_pfSlotOpen,
+    __in                       DRM_DWORD                    f_cbOld,
+    __in                       DRM_DWORD                    f_cbNew,
+    __in_ecount(f_cbNew) const DRM_BYTE                    *f_pbNew,
+    __in                 const DRM_ID                      *f_pidSlot ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_SECURECORE_TEE_BASE_SlotDeleteHelper(
+    __inout  const DRM_DST                   *f_pHDS,
+    __in           DRM_DST_NAMESPACE_CONTEXT *f_pNsCtx,
+    __in     const DRM_ID                    *f_pidSlot ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_SECURECORE_TEE_VerifyAndStoreCertAndPPKB(
+    __inout                          DRM_TEE_PROXY_CONTEXT       *f_pTeeCtx,
+    __in                             DRM_DST                     *f_pHDS,
+    __in                             DRM_DWORD                    f_cbOldPPKB,
+    __in                             DRM_DWORD                    f_cbNewPPKB,
+    __in_bcount( f_cbNewPPKB ) const DRM_BYTE                    *f_pbNewPPKB,
+    __in                             DRM_DWORD                    f_cbOldCert,
+    __in                             DRM_DWORD                    f_cbNewCert,
+    __in_bcount( f_cbNewCert ) const DRM_BYTE                    *f_pbNewCert,
+    __inout_opt                      DRM_CRYPTO_CONTEXT          *f_pCryptoContext,
+    __inout_opt                      DRM_DST_NAMESPACE_CONTEXT   *f_pNsCtx,
+    __inout_opt                      DRM_DST_SLOT_CONTEXT        *f_pSlotPPKB,
+    __inout_opt                      DRM_BOOL                    *f_pfSlotPPKBOpen,
+    __inout_opt                      DRM_DST_SLOT_CONTEXT        *f_pSlotCert,
+    __inout_opt                      DRM_BOOL                    *f_pfSlotCertOpen ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_SECURECORE_TEE_PreInitialize(
+    __in_opt                                                  DRM_VOID                       *f_pOEMContext,
+    __out                                                     DRM_VOID                      **f_ppvPreInitializeContext,
+    __out                                                     DRM_ID                         *f_pCurrentAppId,
+    __out                                                     DRM_ID                         *f_pUniqueId,
+    __out_opt                                                 DRM_SECURECORE_VERSIONINFO     *f_pSecureCoreVerInfo,
+    __out_ecount_opt( DRM_TEE_METHOD_FUNCTION_MAP_COUNT )     DRM_DWORD                      *f_pdwFunctionMap ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_SECURECORE_TEE_Initialize(
+    __inout                                                   DRM_SECURECORE_CONTEXT         *f_pSecureCoreCtx,
+    __in_opt                                                  DRM_VOID                       *f_pOEMContext,
+    __in                                                      DRM_DWORD                       f_cchVersion,
+    __in_ecount( f_cchVersion )                               DRM_CHAR                       *f_pszVersion,
+    __in                                                      DRM_DST                        *f_pHDS,
+    __in_opt                                            const DRM_CONST_STRING               *f_pdstrDeviceStoreName,
+    __in                                                      DRM_DWORD                       f_cbWorkingBuffer,
+    __inout_bcount( f_cbWorkingBuffer )                       DRM_BYTE                       *f_pbWorkingBuffer,
+    __inout_opt                                               DRM_VOID                      **f_ppvPreInitializeContext,
+    __in_opt                                                  DRM_ID                         *f_pCurrentAppId,
+    __out_opt                                                 DRM_SECURECORE_VERSIONINFO     *f_pSecureCoreVerInfo,
+    __out_ecount_opt( DRM_TEE_METHOD_FUNCTION_MAP_COUNT )     DRM_DWORD                      *f_pdwFunctionMap ) DRM_NO_INLINE_ATTRIBUTE;
+
+#define DRM_SC_DEF_FOR_TEE 1
+
+#include <drmsecurecore_template.h>
+
+#undef DRM_SC_DEF_FOR_TEE
+
+EXIT_PK_NAMESPACE;
+
+PREFAST_POP; /* __WARNING_NONCONST_BUFFER_PARAM_25033 */
+PREFAST_POP; /* __WARNING_NONCONST_PARAM_25004 */
+
+#endif /* _DRMSECURECORE_H_ */
+
diff --git a/prebuilt-v4.4/noarch/include/drmsecurecore_template.h b/prebuilt-v4.4/noarch/include/drmsecurecore_template.h
new file mode 100644
index 0000000..13c167c
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmsecurecore_template.h
@@ -0,0 +1,517 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#if defined(DRM_SC_DEF_FOR_EXTCALLERS)
+#define DRM_GET_FUNCNAME(FUNCNAME) DRM_SECURECORE_##FUNCNAME
+#elif defined(DRM_SC_DEF_FOR_INT)
+#define DRM_GET_FUNCNAME(FUNCNAME) DRM_SECURECORE_INT_##FUNCNAME
+#elif defined(DRM_SC_DEF_FOR_TEE)
+#define DRM_GET_FUNCNAME(FUNCNAME) DRM_SECURECORE_TEE_##FUNCNAME
+#elif defined(DRM_SC_DEF_FOR_NOTEE)
+#define DRM_GET_FUNCNAME(FUNCNAME) DRM_SECURECORE_NOTEE_##FUNCNAME
+#else
+#define DRM_GET_FUNCNAME(FUNCNAME)
+#endif
+
+#if defined(DRM_SC_DEF_FOR_FUNCPTR)
+#define DRM_SIGNATURE_POSTFIX
+#define DRM_GET_FUNCTION_SIGNATURE(FUNCNAME, APITYPE, RETTYPE)         typedef APITYPE RETTYPE (DRM_CALL *LPFN_DRM_SECURECORE_##FUNCNAME)
+#define DRM_GET_FUNCTION_SIGNATURE_WOTYPE(FUNCNAME, APITYPE, RETTYPE)   typedef APITYPE RETTYPE (DRM_CALL *LPFN_DRM_SECURECORE_##FUNCNAME)
+#else
+#define DRM_SIGNATURE_POSTFIX DRM_NO_INLINE_ATTRIBUTE
+#define DRM_GET_FUNCTION_SIGNATURE(FUNCNAME, APITYPE, RETTYPE)         DRM_NO_INLINE APITYPE RETTYPE DRM_CALL DRM_GET_FUNCNAME(FUNCNAME)
+#define DRM_GET_FUNCTION_SIGNATURE_WOTYPE(FUNCNAME, APITYPE, RETTYPE)   DRM_NO_INLINE APITYPE RETTYPE DRM_CALL DRM_SECURECORE_##FUNCNAME
+#endif
+
+DRM_GET_FUNCTION_SIGNATURE( PreUninitialize, DRM_API_VOID, DRM_VOID )(
+    __inout                             DRM_SECURECORE_CONTEXT   *f_pSecureCoreCtx,
+    __inout                             DRM_VOID                **f_ppvPreInitializeContext ) DRM_SIGNATURE_POSTFIX;
+
+DRM_GET_FUNCTION_SIGNATURE( Uninitialize, DRM_API_VOID, DRM_VOID )(
+    __inout                             DRM_SECURECORE_CONTEXT   *f_pSecureCoreCtx ) DRM_SIGNATURE_POSTFIX;
+
+DRM_GET_FUNCTION_SIGNATURE( GetCertificate, DRM_API, DRM_RESULT )(
+    __inout                             DRM_SECURECORE_CONTEXT  *f_pSecureCoreCtx,
+    __inout                             DRM_DWORD               *f_pcbCert,
+    __out_bcount(*f_pcbCert)            DRM_BYTE                *f_pbCert ) DRM_SIGNATURE_POSTFIX;
+
+DRM_GET_FUNCTION_SIGNATURE( GetCertificateWeakRef, DRM_API, DRM_RESULT )(
+    __inout                               DRM_SECURECORE_CONTEXT   *f_pSecureCoreCtx,
+    __in                                  DRM_KF_CERT_TYPE          f_eCertType,
+    __out_ecount(1)                       DRM_DWORD                *f_pcbCertData,
+    __deref_out_ecount(*f_pcbCertData)    DRM_BYTE                **f_ppbCertData ) DRM_SIGNATURE_POSTFIX;
+
+DRM_GET_FUNCTION_SIGNATURE( IsSystemPropertySet, DRM_API, DRM_BOOL )(
+    __inout                         DRM_SECURECORE_CONTEXT   *f_pSecureCoreCtx,
+    __in                            DRM_TEE_PROPERTY          f_eProperty ) DRM_SIGNATURE_POSTFIX;
+
+DRM_GET_FUNCTION_SIGNATURE( GetVersionInformation, DRM_API, DRM_RESULT )(
+    __inout                                             DRM_SECURECORE_CONTEXT     *f_pSecureCoreCtx,
+    __out_opt                                           DRM_SECURECORE_VERSIONINFO *f_pSecureCoreVerInfo,
+    __out_ecount_opt(DRM_TEE_METHOD_FUNCTION_MAP_COUNT) DRM_DWORD                  *f_pdwFunctionMap ) DRM_SIGNATURE_POSTFIX;
+
+DRM_GET_FUNCTION_SIGNATURE( GetIsRunningInHWDRM, DRM_API, DRM_BOOL )(
+    __inout     DRM_SECURECORE_CONTEXT     *f_pSecureCoreCtx ) DRM_SIGNATURE_POSTFIX;
+
+DRM_GET_FUNCTION_SIGNATURE( SetStorePasswordCallback, DRM_API_VOID, DRM_VOID )(
+    __inout                             DRM_SECURECORE_CONTEXT                              *f_pSecureCoreCtx,
+    __in_opt                            DRM_SECURECORE_TEE_DATA_STORE_PASSWORD_CALLBACK      f_pfnStorePasswordCallback ) DRM_SIGNATURE_POSTFIX;
+
+DRM_GET_FUNCTION_SIGNATURE( HasTeeData, DRM_API, DRM_BOOL )(
+    __inout                                             DRM_SECURECORE_CONTEXT     *f_pSecureCoreCtx ) DRM_SIGNATURE_POSTFIX;
+
+DRM_GET_FUNCTION_SIGNATURE( GetDeviceKeySignPublicKeyWeakRef, DRM_API, DRM_RESULT )(
+    __inout                                             DRM_SECURECORE_CONTEXT     *f_pSecureCoreCtx,
+    __deref_inout                                       PUBKEY_P256               **f_ppoPublicKeyWeakRef ) DRM_SIGNATURE_POSTFIX;
+
+DRM_GET_FUNCTION_SIGNATURE( GetDeviceKeyEncryptPublicKeyWeakRef, DRM_API, DRM_RESULT )(
+    __inout                                             DRM_SECURECORE_CONTEXT     *f_pSecureCoreCtx,
+    __deref_inout                                       PUBKEY_P256               **f_ppoPublicKeyWeakRef ) DRM_SIGNATURE_POSTFIX;
+
+DRM_GET_FUNCTION_SIGNATURE( GetRKBWeakRef, DRM_API, DRM_RESULT )(
+    __inout                                             DRM_SECURECORE_CONTEXT     *f_pSecureCoreCtx,
+    __deref_inout                                       DRM_TEE_BYTE_BLOB         **f_ppoRKBWeakRef ) DRM_SIGNATURE_POSTFIX;
+
+DRM_GET_FUNCTION_SIGNATURE( GetOpaqueKeyFileContextWeakRef, DRM_API, DRM_RESULT )(
+    __inout                                             DRM_SECURECORE_CONTEXT     *f_pSecureCoreCtx,
+    __deref_inout                                       DRM_VOID                  **f_ppoOpaqueKeyfileContextWeakRef ) DRM_SIGNATURE_POSTFIX;
+
+DRM_GET_FUNCTION_SIGNATURE( GetError, DRM_API, DRM_RESULT )(
+    __inout                                             DRM_SECURECORE_CONTEXT     *f_pSecureCoreCtx ) DRM_SIGNATURE_POSTFIX;
+
+DRM_GET_FUNCTION_SIGNATURE( SetError, DRM_API, DRM_RESULT )(
+    __inout                                             DRM_SECURECORE_CONTEXT     *f_pSecureCoreCtx,
+    __in                                                DRM_RESULT                  f_drError ) DRM_SIGNATURE_POSTFIX;
+
+DRM_GET_FUNCTION_SIGNATURE( CreateGlobalStorePassword, DRM_API, DRM_RESULT )(
+    __inout                             DRM_SECURECORE_CONTEXT   *f_pSecureCoreCtx,
+    __out_bcount( OEM_SHA1_DIGEST_LEN ) DRM_BYTE                 *f_pbPasswordSST ) DRM_SIGNATURE_POSTFIX;
+
+DRM_GET_FUNCTION_SIGNATURE( CreateRevocationStorePassword, DRM_API, DRM_RESULT )(
+    __inout                             DRM_SECURECORE_CONTEXT   *f_pSecureCoreCtx,
+    __out_bcount( OEM_SHA1_DIGEST_LEN ) DRM_BYTE                 *f_pbPasswordSST ) DRM_SIGNATURE_POSTFIX;
+
+DRM_GET_FUNCTION_SIGNATURE( CreateLicenseStateStorePassword, DRM_API, DRM_RESULT )(
+    __inout                             DRM_SECURECORE_CONTEXT   *f_pSecureCoreCtx,
+    __in                          const DRM_ID                   *f_pLID,
+    __out_bcount( OEM_SHA1_DIGEST_LEN ) DRM_BYTE                 *f_pbPasswordSST ) DRM_SIGNATURE_POSTFIX;
+
+DRM_GET_FUNCTION_SIGNATURE( CreateMeterStorePassword, DRM_API, DRM_RESULT )(
+    __inout                                                                       DRM_SECURECORE_CONTEXT  *f_pSecureCoreCtx,
+    __in_bcount( CCH_BASE64_EQUIV( sizeof(DRM_MID) ) * sizeof(DRM_WCHAR) )  const DRM_BYTE                *f_pbBase64MID,
+    __out_bcount( OEM_SHA1_DIGEST_LEN )                                           DRM_BYTE                *f_pbPasswordSST ) DRM_SIGNATURE_POSTFIX;
+
+DRM_GET_FUNCTION_SIGNATURE( CreateSecureStopStorePassword, DRM_API, DRM_RESULT )(
+    __inout                             DRM_SECURECORE_CONTEXT   *f_pSecureCoreCtx,
+    __out_bcount( OEM_SHA1_DIGEST_LEN ) DRM_BYTE                 *f_pbPasswordSST ) DRM_SIGNATURE_POSTFIX;
+
+DRM_GET_FUNCTION_SIGNATURE( CreateBlobCachePassword, DRM_API, DRM_RESULT )(
+    __inout                             DRM_SECURECORE_CONTEXT   *f_pSecureCoreCtx,
+    __in                                       DRM_DWORD                 f_cbBlob1,
+    __in_ecount( f_cbBlob1 )             const DRM_BYTE                 *f_pbBlob1,
+    __out_bcount( OEM_SHA1_DIGEST_LEN )        DRM_BYTE                 *f_pbPasswordSST ) DRM_SIGNATURE_POSTFIX;
+
+DRM_GET_FUNCTION_SIGNATURE( CleanupPublicKeyContext, DRM_API_VOID, DRM_VOID )(
+    __inout                                    DRM_SECURECORE_CONTEXT   *f_pSecureCoreCtx,
+    __inout_ecount(1)                          DRM_PUBLIC_KEY_CONTEXT   *f_pKeyContext ) DRM_SIGNATURE_POSTFIX;
+
+DRM_GET_FUNCTION_SIGNATURE( TransferPublicKeyContext, DRM_API, DRM_RESULT )(
+    __inout                             DRM_SECURECORE_CONTEXT   *f_pSecureCoreCtx,
+    __out_ecount(1)                     DRM_PUBLIC_KEY_CONTEXT   *f_pDestinationKeyContext,
+    __inout_ecount(1)                   DRM_PUBLIC_KEY_CONTEXT   *f_pSourceKeyContext ) DRM_SIGNATURE_POSTFIX;
+
+DRM_GET_FUNCTION_SIGNATURE( DuplicatePublicKeyContext, DRM_API, DRM_RESULT )(
+    __inout                             DRM_SECURECORE_CONTEXT   *f_pSecureCoreCtx,
+    __out_ecount(1)                     DRM_PUBLIC_KEY_CONTEXT   *f_pDestinationKeyContext,
+    __inout_ecount(1)                   DRM_PUBLIC_KEY_CONTEXT   *f_pSourceKeyContext ) DRM_SIGNATURE_POSTFIX;
+
+DRM_GET_FUNCTION_SIGNATURE( SignRMPChallenge, DRM_API, DRM_RESULT )(
+    __inout                             DRM_SECURECORE_CONTEXT    *f_pSecureCoreCtx,
+    __in                                DRM_DWORD                  f_cbToSign,
+    __in_bcount( f_cbToSign )     const DRM_BYTE                  *f_pbToSign,
+    __in                          const PUBKEY_P256               *f_pPubKey,
+    __out                               SIGNATURE_P256            *f_pSignature ) DRM_SIGNATURE_POSTFIX;
+
+DRM_GET_FUNCTION_SIGNATURE( CertCachingInitialize, DRM_API, DRM_RESULT )(
+    __inout                         DRM_SECURECORE_CONTEXT               *f_pSecureCoreCtx,
+    __inout_ecount( 1 )             DRM_BINARY_DEVICE_CERT_CACHED_VALUES *f_pCache,
+    __in_bcount(f_cbCertData) const DRM_BYTE                             *f_pbCertData,
+    __in                      const DRM_DWORD                             f_cbCertData,
+    __in                            DRM_DWORD                             f_dwChainLength,
+    __in                            DRM_DWORD                             f_bOffset,
+    __out_ecount( 1 )               OEM_CRYPTO_HANDLE                    *f_phCertChainPubKey ) DRM_SIGNATURE_POSTFIX;
+
+DRM_GET_FUNCTION_SIGNATURE( UnwrapPublicKeyHandle, DRM_API, DRM_RESULT )(
+    __inout                                 DRM_SECURECORE_CONTEXT *f_pSecureCoreCtx,
+    __in                                    OEM_CRYPTO_HANDLE       f_hWrappingKey,
+    __in_bcount( f_cbCertificate )    const DRM_BYTE               *f_pbCertificate,
+    __in                                    DRM_DWORD               f_cbCertificate,
+    __in                                    DRM_DWORD               f_iKeyInCert,
+    __inout_ecount( 1 )                     DRM_PUBLIC_KEY_CONTEXT *f_pKeyContext ) DRM_SIGNATURE_POSTFIX;
+
+DRM_GET_FUNCTION_SIGNATURE( CompleteCaching, DRM_API_VOID, DRM_VOID )(
+    __inout                         DRM_SECURECORE_CONTEXT               *f_pSecureCoreCtx,
+    __inout_ecount_opt( 1 )         DRM_BINARY_DEVICE_CERT_CACHED_VALUES *f_pCache,
+    __in                            DRM_RESULT                            f_drCachingResult,
+    __inout_ecount_opt( 1 )         OEM_CRYPTO_HANDLE                    *f_phCertChainPubKey ) DRM_SIGNATURE_POSTFIX;
+
+DRM_GET_FUNCTION_SIGNATURE( CleanupCache, DRM_API_VOID, DRM_VOID )(
+    __inout                         DRM_SECURECORE_CONTEXT               *f_pSecureCoreCtx,
+    __inout_ecount_opt( 1 )         DRM_BINARY_DEVICE_CERT_CACHED_VALUES *f_pCache ) DRM_SIGNATURE_POSTFIX;
+
+DRM_GET_FUNCTION_SIGNATURE( ProcessLicenseForStorage, DRM_API, DRM_RESULT )(
+    __inout                                 DRM_SECURECORE_CONTEXT  *f_pSecureCoreCtx,
+    __in_opt                                DRM_DOMAINSTORE_CONTEXT *f_poDomainStoreContext,
+    __in                              const DRM_XMRFORMAT           *f_pXMRLicense,
+    __in                                    DRM_DWORD                f_cbLicense,
+    __in_bcount( f_cbLicense )        const DRM_BYTE                *f_pbLicense,
+    __inout                                 DRM_DST                 *f_pHDS,
+    __out_opt                               DRM_TEE_BYTE_BLOB       *f_pLKB ) DRM_SIGNATURE_POSTFIX;
+
+DRM_GET_FUNCTION_SIGNATURE( DeleteLicenseLKB, DRM_API, DRM_RESULT )(
+    __inout        DRM_SECURECORE_CONTEXT   *f_pSecureCoreCtx,
+    __inout        DRM_DST                  *f_pHDS,
+    __in     const DRM_ID                   *f_pLID ) DRM_SIGNATURE_POSTFIX;
+
+DRM_GET_FUNCTION_SIGNATURE( GenerateNonce, DRM_API, DRM_RESULT )(
+    __inout                                 DRM_SECURECORE_CONTEXT  *f_pSecureCoreCtx,
+    __inout_opt                             DRM_NONCESTORE_CONTEXT  *f_poNonceStoreContext,
+    __out                                   DRM_ID                  *f_pNonce ) DRM_SIGNATURE_POSTFIX;
+
+DRM_GET_FUNCTION_SIGNATURE( GetSystemTime, DRM_API, DRM_RESULT )(
+    __inout                                 DRM_SECURECORE_CONTEXT  *f_pSecureCoreCtx,
+    __out                                   DRM_UINT64              *f_pui64SystemTime ) DRM_SIGNATURE_POSTFIX;
+
+DRM_GET_FUNCTION_SIGNATURE( GetFeatureInformationWeakRef, DRM_API, DRM_RESULT )(
+    __inout                                 DRM_SECURECORE_CONTEXT  *f_pSecureCoreCtx,
+    __deref_out                             DRM_TEE_BYTE_BLOB      **f_ppTeeXmlWeakRef ) DRM_SIGNATURE_POSTFIX;
+
+DRM_GET_FUNCTION_SIGNATURE( IsREEFeatureSupported, DRM_API, DRM_RESULT )(
+    _Inout_                                 DRM_SECURECORE_CONTEXT  *f_pSecureCoreCtx,
+    _In_                                    DRM_REE_FEATURE_ENUM     f_eReeFeature,
+    _Out_                                   DRM_BOOL                *f_pfIsSupported );
+
+DRM_GET_FUNCTION_SIGNATURE( PreparePolicyInfo, DRM_API, DRM_RESULT )(
+    __inout                                 DRM_SECURECORE_CONTEXT  *f_pSecureCoreCtx,
+    __in                                    DRM_DWORD                f_dwChainLen,
+    __in_ecount( f_dwChainLen )       const DRM_BINDING_INFO        *f_pBindingInfos,
+    __in                                    DRM_DWORD                f_dwDecryptionMode,
+    __out                                   DRM_TEE_BYTE_BLOB       *f_pOEMPolicyInfo ) DRM_SIGNATURE_POSTFIX;
+
+DRM_GET_FUNCTION_SIGNATURE( PrepareToDecrypt, DRM_API, DRM_RESULT )(
+    __inout                                 DRM_SECURECORE_CONTEXT  *f_pSecureCoreCtx,
+    __in                                    DRM_DOMAINSTORE_CONTEXT *f_poDomainStoreContext,
+    __in                                    DRM_DWORD                f_dwChainLen,
+    __in_ecount( f_dwChainLen )       const DRM_BINDING_INFO        *f_pBindingInfos,
+    __inout_opt                             DRM_TEE_BYTE_BLOB       *f_pLKB,
+    __in_opt                          const DRM_TEE_BYTE_BLOB       *f_pSPKB,
+    __inout                                 DRM_DST                 *f_pHDS,
+    __inout                                 DRM_DWORD               *f_pdwDecryptionMode,
+    __in_opt                                DRM_VOID                *f_pvCipherUserContext,
+    __out                                   DRM_CIPHER_CONTEXT      *f_pCipherContext ) DRM_SIGNATURE_POSTFIX;
+
+DRM_GET_FUNCTION_SIGNATURE( CreateOEMBlobFromCDKB, DRM_API, DRM_RESULT )(
+    __inout                                 DRM_SECURECORE_CONTEXT  *f_pSecureCoreCtx,
+    __in                                    DRM_CIPHER_CONTEXT      *f_pCipherContext,
+    __in                                    DRM_DWORD                f_cbOEMInitData,
+    __in_bcount( f_cbOEMInitData )    const DRM_BYTE                *f_pbOEMInitData ) DRM_SIGNATURE_POSTFIX;
+
+DRM_GET_FUNCTION_SIGNATURE( CloseDecryptContext, DRM_API_VOID, DRM_VOID )(
+    __inout                                 DRM_CIPHER_CONTEXT      *f_pCipherContext ) DRM_SIGNATURE_POSTFIX;
+
+DRM_GET_FUNCTION_SIGNATURE( DuplicateDecryptContext, DRM_API, DRM_RESULT )(
+    __out                                   DRM_CIPHER_CONTEXT      *f_pDuplicateCipherContext,
+    __in                                    DRM_CIPHER_CONTEXT      *f_pSourceCipherContext ) DRM_SIGNATURE_POSTFIX;
+
+DRM_GET_FUNCTION_SIGNATURE( PrepareSampleProtectionKey, DRM_API, DRM_RESULT )(
+    __inout                                         DRM_SECURECORE_CONTEXT   *f_pSecureCoreCtx,
+    __in                                            DRM_DWORD                 f_cbCertificate,
+    __in_bcount( f_cbCertificate )            const DRM_BYTE                 *f_pbCertificate,
+    __out                                           DRM_TEE_BYTE_BLOB        *f_pSPKB,
+    __out                                           CIPHERTEXT_P256          *f_pEncryptedKey ) DRM_SIGNATURE_POSTFIX;
+
+DRM_GET_FUNCTION_SIGNATURE( DecryptContentLegacy, DRM_API, DRM_RESULT )(
+    __in                                            DRM_CIPHER_CONTEXT              *f_pCipherContext,
+    __inout_opt                                     DRM_AES_COUNTER_MODE_CONTEXT    *f_pCtrContext,
+    __in                                            DRM_DWORD                        f_cbData,
+    __inout_bcount( f_cbData )                      DRM_BYTE                        *f_pbData ) DRM_SIGNATURE_POSTFIX;
+
+PREFAST_PUSH_DISABLE_EXPLAINED( __WARNING_NONCONST_BUFFER_PARAM_25033, "f_pbEncryptedContent is inout" )
+DRM_GET_FUNCTION_SIGNATURE( DecryptContent, DRM_API, DRM_RESULT )(
+    __in                                            DRM_CIPHER_CONTEXT       *f_pCipherContext,
+    __in                                            DRM_DWORD                 f_cEncryptedRegionMappings,
+    __in_ecount( f_cEncryptedRegionMappings ) const DRM_DWORD                *f_pdwEncryptedRegionMappings,
+    __in                                            DRM_UINT64                f_ui64InitializationVector,
+    __in                                            DRM_DWORD                 f_cbEncryptedContent,
+    __in_bcount( f_cbEncryptedContent )       const DRM_BYTE                 *f_pbEncryptedContent,
+    __out                                           DRM_DWORD                *f_pcbOpaqueClearContent,
+    __deref_out_bcount( *f_pcbOpaqueClearContent )  DRM_BYTE                **f_ppbOpaqueClearContent ) DRM_SIGNATURE_POSTFIX;
+PREFAST_POP /* __WARNING_NONCONST_BUFFER_PARAM_25033 */
+
+PREFAST_PUSH_DISABLE_EXPLAINED( __WARNING_NONCONST_BUFFER_PARAM_25033, "f_pbEncryptedContent is inout" )
+DRM_GET_FUNCTION_SIGNATURE( DecryptAudioContentMultiple, DRM_API, DRM_RESULT )(
+    __in                                            DRM_CIPHER_CONTEXT       *f_pCipherContext,
+    __in                                            DRM_DWORD                 f_cInitializationVectors,
+    __in_ecount( f_cInitializationVectors )   const DRM_UINT64               *f_pui64InitializationVectors,
+    __in_ecount( f_cInitializationVectors )   const DRM_DWORD                *f_pInitializationVectorSizes,
+    __in                                            DRM_DWORD                 f_cbEncryptedContent,
+    __inout_bcount( f_cbEncryptedContent )          DRM_BYTE                 *f_pbEncryptedContent ) DRM_SIGNATURE_POSTFIX;
+PREFAST_POP /* __WARNING_NONCONST_BUFFER_PARAM_25033 */
+
+DRM_GET_FUNCTION_SIGNATURE( AES128CTR_DecryptContentMultiple, DRM_API, DRM_RESULT )(
+    __in                                                                 DRM_CIPHER_CONTEXT       *f_pCipherContext,
+    __in                                                                 DRM_DWORD                 f_cEncryptedRegionInitializationVectors,
+    __in_ecount( f_cEncryptedRegionInitializationVectors )         const DRM_UINT64               *f_pEncryptedRegionInitializationVectorsHigh,
+    __in_ecount_opt( f_cEncryptedRegionInitializationVectors )     const DRM_UINT64               *f_pEncryptedRegionInitializationVectorsLow,
+    __in_ecount( f_cEncryptedRegionInitializationVectors )         const DRM_DWORD                *f_pEncryptedRegionCounts,
+    __in                                                                 DRM_DWORD                 f_cEncryptedRegionMappings,
+    __in_ecount( f_cEncryptedRegionMappings )                      const DRM_DWORD                *f_pEncryptedRegionMappings,
+    __in                                                                 DRM_DWORD                 f_cEncryptedRegionSkip,
+    __in_ecount_opt( f_cEncryptedRegionSkip )                      const DRM_DWORD                *f_pEncryptedRegionSkip,
+    __in                                                                 DRM_DWORD                 f_cbEncryptedContent,
+    __in_bcount( f_cbEncryptedContent )                            const DRM_BYTE                 *f_pbEncryptedContent,
+    __out                                                                DRM_DWORD                *f_pcbOpaqueClearContent,
+    __deref_out_bcount( *f_pcbOpaqueClearContent )                       DRM_BYTE                **f_ppbOpaqueClearContent ) DRM_SIGNATURE_POSTFIX;
+
+DRM_GET_FUNCTION_SIGNATURE( AES128CBC_DecryptContentMultiple, DRM_API, DRM_RESULT )(
+    __in                                                                 DRM_CIPHER_CONTEXT       *f_pCipherContext,
+    __in                                                                 DRM_DWORD                 f_cEncryptedRegionInitializationVectors,
+    __in_ecount( f_cEncryptedRegionInitializationVectors )         const DRM_UINT64               *f_pEncryptedRegionInitializationVectorsHigh,
+    __in_ecount_opt( f_cEncryptedRegionInitializationVectors )     const DRM_UINT64               *f_pEncryptedRegionInitializationVectorsLow,
+    __in_ecount( f_cEncryptedRegionInitializationVectors )         const DRM_DWORD                *f_pEncryptedRegionCounts,
+    __in                                                                 DRM_DWORD                 f_cEncryptedRegionMappings,
+    __in_ecount( f_cEncryptedRegionMappings )                      const DRM_DWORD                *f_pEncryptedRegionMappings,
+    __in                                                                 DRM_DWORD                 f_cEncryptedRegionSkip,
+    __in_ecount_opt( f_cEncryptedRegionSkip )                      const DRM_DWORD                *f_pEncryptedRegionSkip,
+    __in                                                                 DRM_DWORD                 f_cbEncryptedContent,
+    __in_bcount( f_cbEncryptedContent )                            const DRM_BYTE                 *f_pbEncryptedContent,
+    __out                                                                DRM_DWORD                *f_pcbOpaqueClearContent,
+    __deref_out_bcount( *f_pcbOpaqueClearContent )                       DRM_BYTE                **f_ppbOpaqueClearContent ) DRM_SIGNATURE_POSTFIX;
+
+DRM_GET_FUNCTION_SIGNATURE( FreeDecryptedContent, DRM_API_VOID, DRM_VOID )(
+    __inout                                      DRM_CIPHER_CONTEXT  *f_pCipherContext,
+    __in                                         DRM_DWORD            f_cbOpaqueClearContent,
+    __inout_bcount_opt( f_cbOpaqueClearContent ) DRM_BYTE            *f_pbOpaqueClearContent ) DRM_SIGNATURE_POSTFIX;
+
+DRM_GET_FUNCTION_SIGNATURE( PrepareDomainKeysForStorage, DRM_API, DRM_RESULT )(
+    __inout                                                                           DRM_SECURECORE_CONTEXT     *f_pSecureCoreCtx,
+    __in                                                                              DRM_DWORD                   f_dwProtocolVersion,
+    __in                                                                              DRM_DWORD                   f_cbDomainKeysData,
+    __in_bcount( f_cbDomainKeysData )                                           const DRM_BYTE                   *f_pbDomainKeysData,
+    __in                                                                              DRM_DWORD                   f_cbDomainCert,
+    __in_bcount( f_cbDomainCert )                                               const DRM_BYTE                   *f_pbDomainCert,
+    __out_ecount( 1 )                                                                 DRM_DWORD                  *f_pcPrivateDomainKeys,
+    __out_ecount( 1 )                                                                 DRM_DWORD                  *f_pcbPrivateDomainKeys,
+    __deref_out_ecount( (*f_pcPrivateDomainKeys)*(*f_pcbPrivateDomainKeys) )          DRM_BYTE                  **f_ppbPrivateDomainKeys,
+    __deref_out_ecount( *f_pcPrivateDomainKeys )                                      DRM_DWORD                 **f_ppdwRevisions ) DRM_SIGNATURE_POSTFIX;
+
+DRM_GET_FUNCTION_SIGNATURE( DeleteDomainLKBs, DRM_API, DRM_RESULT )(
+    __inout                                              DRM_SECURECORE_CONTEXT      *f_pSecureCoreCtx,
+    __in                                                 DRM_DOMAINSTORE_CONTEXT     *f_poDomainStoreContext,
+    __in                                           const DRM_GUID                    *f_poDomainAccountID ) DRM_SIGNATURE_POSTFIX;
+
+DRM_GET_FUNCTION_SIGNATURE( BASE_FreeBlob, DRM_API_VOID, DRM_VOID )(
+    __inout                                              DRM_SECURECORE_CONTEXT      *f_pSecureCoreCtx,
+    __inout                                              DRM_TEE_BYTE_BLOB           *f_pBlob ) DRM_SIGNATURE_POSTFIX;
+
+DRM_GET_FUNCTION_SIGNATURE( EscrowRevocationInfo, DRM_API, DRM_RESULT )(
+    __inout                                             DRM_SECURECORE_CONTEXT       *f_pSecureCoreCtx,
+    __in                                                DRM_REVOCATIONSTORE_CONTEXT  *f_pRevocationStoreContext,
+    __in_opt                                      const DRM_ID                       *f_pidSession ) DRM_SIGNATURE_POSTFIX;
+
+DRM_GET_FUNCTION_SIGNATURE( ReleaseLicense, DRM_API, DRM_RESULT )(
+    __inout                                                DRM_SECURECORE_CONTEXT              *f_pSecureCoreCtx,
+    __inout                                                DRM_LICENSE_HANDLE                  *f_phLicense )  DRM_SIGNATURE_POSTFIX;
+
+DRM_GET_FUNCTION_SIGNATURE( BuildLicense, DRM_API, DRM_RESULT )(
+    __inout                                                DRM_SECURECORE_CONTEXT              *f_pSecureCoreCtx,
+    __inout                                                DRM_SECURECORE_CONTEXT              *f_pRootSecureCoreCtx,
+    __in                                                   DRM_LOCAL_LICENSE_TYPE               f_eLicenseType,
+    __in                                                   DRM_DWORD                            f_dwEncryptionMode,
+    __inout                                                DRM_LOCAL_LICENSE_SESSION_CONTEXT   *f_poLocalLicenseSession,
+    __in                                             const DRM_LOCAL_LICENSE_SESSION_CONTEXT   *f_phRootLicenseSession,
+    __inout                                                DRM_LOCAL_LICENSE_CONTEXT           *f_poLocalLicenseContext,
+    __in                                                   DRM_DWORD                            f_cbRevInfo,
+    __in                                                   DRM_DWORD                            f_cbRevInfoAndRuntimeCRL,
+    __in_bcount( f_cbRevInfoAndRuntimeCRL )          const DRM_BYTE                            *f_pbRevInfoAndRuntimeCRL,
+    __in                                                   DRM_WORD                             f_wSecurityLevel,
+    __in                                                   DRM_DWORD                            f_cbPartialLicense,
+    __in_bcount( f_cbPartialLicense )                const DRM_BYTE                            *f_pbPartialLicense,
+    __inout                                                DRM_DST                             *f_pHDS )  DRM_SIGNATURE_POSTFIX;
+
+DRM_GET_FUNCTION_SIGNATURE( FindAndCleanLicenseKeyCache, DRM_API, DRM_RESULT )(
+    __inout                                                DRM_SECURECORE_CONTEXT               *f_pSecureCoreCtx,
+    __inout                                                DRM_LOCAL_LICENSE_CONTEXT            *f_poLocalLicenseContext,
+    __in                                             const DRM_KID                              *f_pKid,
+    __out_opt                                              DRM_LOCAL_LICENSE_KEY_CACHE         **f_ppoLicenseKeyCache ) DRM_SIGNATURE_POSTFIX;
+
+DRM_GET_FUNCTION_SIGNATURE( InitLocalLicenseContext, DRM_API, DRM_RESULT )(
+    __inout                                                DRM_SECURECORE_CONTEXT              *f_pSecureCoreCtx,
+    __out                                                  DRM_LOCAL_LICENSE_CONTEXT           *f_ppLocalLicenseContext ) DRM_SIGNATURE_POSTFIX;
+
+DRM_GET_FUNCTION_SIGNATURE( CleanLocalLicenseContext, DRM_API_VOID, DRM_VOID )(
+    __inout_opt                                            DRM_SECURECORE_CONTEXT              *f_pSecureCoreCtx,
+    __out_opt                                              DRM_LOCAL_LICENSE_CONTEXT           *f_pLocalLicenseContext ) DRM_SIGNATURE_POSTFIX;
+
+DRM_GET_FUNCTION_SIGNATURE( EncryptOpaque, DRM_API, DRM_RESULT )(
+    __inout                                                DRM_SECURECORE_CONTEXT              *f_pSecureCoreCtx,
+    __in                                             const DRM_LICENSE_HANDLE                  *f_phLicense,
+    __in                                                   DRM_DWORD                            f_cEncryptedRegionMappings,
+    __in_ecount( f_cEncryptedRegionMappings )        const DRM_DWORD                           *f_pdwEncryptedRegionMappings,
+    __in                                                   DRM_DWORD                            f_cbOpaqueClearContent,
+    __in_bcount( f_cbOpaqueClearContent )            const DRM_BYTE                            *f_pbOpaqueClearContent,
+    __out                                                  DRM_DWORD                           *f_pcbEncryptedContent,
+    __deref_out_bcount( *f_pcbEncryptedContent )           DRM_BYTE                           **f_ppbEncryptedContent,
+    __out                                                  DRM_UINT64                          *f_pqwIV ) DRM_SIGNATURE_POSTFIX;
+
+DRM_GET_FUNCTION_SIGNATURE( ValidateMachineID, DRM_API, DRM_RESULT )(
+    __in                                        const DRM_SECURECORE_CONTEXT                  *f_pSecureCoreCtx ) DRM_SIGNATURE_POSTFIX;
+
+DRM_GET_FUNCTION_SIGNATURE( CheckDeviceKeys, DRM_API, DRM_RESULT )(
+    __in                                        const DRM_SECURECORE_CONTEXT                  *f_pSecureCoreCtx ) DRM_SIGNATURE_POSTFIX;
+
+DRM_GET_FUNCTION_SIGNATURE( SECURETIME_GenerateChallengeData, DRM_API, DRM_RESULT )(
+    __inout                                           DRM_SECURECORE_CONTEXT                  *f_pSecureCoreCtx,
+    __out                                             DRM_DWORD                               *f_pcbChallengeData,
+    __deref_out_bcount( *f_pcbChallengeData )         DRM_BYTE                               **f_ppbChallengeData )  DRM_SIGNATURE_POSTFIX;
+
+DRM_GET_FUNCTION_SIGNATURE( SECURETIME_ProcessResponseData, DRM_API, DRM_RESULT )(
+    __inout                                           DRM_SECURECORE_CONTEXT                  *f_pSecureCoreCtx,
+    __in                                              DRM_DWORD                                f_cbResponseData,
+    __in_bcount( f_cbResponseData )             const DRM_BYTE                                *f_pResponseData,
+    __in                                              DRM_DWORD                                f_cbSignature,
+    __in_bcount( f_cbSignature )                const DRM_BYTE                                *f_pbSignature,
+    __in                                              DRM_DWORD                                f_cbServerCert,
+    __in_bcount( f_cbServerCert )               const DRM_BYTE                                *f_pbServerCert ) DRM_SIGNATURE_POSTFIX;
+
+#if defined(DRM_SC_DEF_FOR_EXTCALLERS) || defined(DRM_SC_DEF_FOR_TEE)
+
+DRM_GET_FUNCTION_SIGNATURE_WOTYPE( H264_PreProcessEncryptedData, DRM_API, DRM_RESULT )(
+    __in                                                        DRM_CIPHER_CONTEXT       *f_pCipherContext,
+    __inout_ecount( 1 )                                         DRM_UINT64               *f_pui64InitializationVector,
+    __in                                                        DRM_DWORD                 f_cEncryptedRegionMappings,
+    __in_ecount( f_cEncryptedRegionMappings )             const DRM_DWORD                *f_pdwEncryptedRegionMappings,
+    __in                                                        DRM_DWORD                 f_cbEncryptedTranscryptedFullFrame,
+    __inout_bcount_opt( f_cbEncryptedTranscryptedFullFrame )    DRM_BYTE                 *f_pbEncryptedTranscryptedFullFrame,
+    __in                                                        DRM_DWORD                 f_cbEncryptedPartialFrame,
+    __in_bcount( f_cbEncryptedPartialFrame )              const DRM_BYTE                 *f_pbEncryptedPartialFrame,
+    __in                                                        DRM_DWORD                 f_cdwOffsetData,
+    __in_ecount_opt( f_cdwOffsetData )                    const DRM_DWORD                *f_pdwOffsetData,
+    __in                                                        DRM_DWORD                 f_cbOpaqueState,
+    __in_bcount_opt( f_cbOpaqueState )                    const DRM_BYTE                 *f_pbOpaqueState,
+    __out                                                       DRM_DWORD                *f_pcbOpaqueStateUpdated,
+    __deref_out_bcount_opt( *f_pcbOpaqueStateUpdated )          DRM_BYTE                **f_ppbOpaqueStateUpdated,
+    __out                                                       DRM_DWORD                *f_pcbSliceHeaders,
+    __deref_out_bcount_opt( *f_pcbSliceHeaders )                DRM_BYTE                **f_ppbSliceHeaders,
+    __out                                                       DRM_DWORD                *f_pcbOpaqueFrameData,
+    __deref_out_bcount_opt( *f_pcbOpaqueFrameData )             DRM_BYTE                **f_ppbOpaqueFrameData ) DRM_SIGNATURE_POSTFIX;
+
+DRM_GET_FUNCTION_SIGNATURE_WOTYPE( RPROV_PrepareProvisioningChallengeForNetwork, DRM_API, DRM_RESULT )(
+    __in                                          DRM_DWORD                   f_cbChallenge,
+    __in_bcount( f_cbChallenge )            const DRM_BYTE                   *f_pbChallenge,
+    __in                                          DRM_DWORD                   f_cbServerBlob,
+    __in_bcount_opt( f_cbServerBlob )       const DRM_BYTE                   *f_pbServerBlob,
+    __out                                         DRM_DWORD                  *f_pcbNetworkChallenge,
+    __deref_out_bcount( *f_pcbNetworkChallenge )  DRM_BYTE                  **f_ppbNetworkChallenge ) DRM_SIGNATURE_POSTFIX;
+
+DRM_GET_FUNCTION_SIGNATURE_WOTYPE( RPROV_PrepareBootstrapProvisioningChallengeForNetwork, DRM_API, DRM_RESULT )(
+    __in                                          DRM_DWORD                   f_cbChallenge,
+    __in_bcount( f_cbChallenge )            const DRM_BYTE                   *f_pbChallenge,
+    __in                                          DRM_DWORD                   f_cbServerBlob,
+    __in_bcount_opt( f_cbServerBlob )       const DRM_BYTE                   *f_pbServerBlob,
+    __out                                         DRM_DWORD                  *f_pcbNetworkChallenge,
+    __deref_out_bcount( *f_pcbNetworkChallenge )  DRM_BYTE                  **f_ppbNetworkChallenge,
+    __in                                          DRM_DWORD                   f_dwType,
+    __in                                          DRM_DWORD                   f_dwStep ) DRM_SIGNATURE_POSTFIX;
+
+/* Declares DRM_SECURECORE_RPROV_ParseProvisioningResponseFromNetwork and similar functions */
+DRM_GET_FUNCTION_SIGNATURE_WOTYPE( RPROV_ParseProvisioningResponseFromNetwork, DRM_API, DRM_RESULT )(
+    __in                                            DRM_DWORD     f_cbNetworkResponse,
+    __in_bcount( f_cbNetworkResponse )    const     DRM_BYTE     *f_pbNetworkResponse,
+    __out                                           DRM_DWORD    *f_pcbResponse,
+    __deref_out_bcount( *f_pcbResponse )            DRM_BYTE    **f_ppbResponse,
+    __out_opt                                       DRM_DWORD    *f_pcbServerBlob,
+    __deref_opt_out_bcount_opt( *f_pcbServerBlob )  DRM_BYTE    **f_ppbServerBlob ) DRM_SIGNATURE_POSTFIX;
+
+DRM_GET_FUNCTION_SIGNATURE_WOTYPE( RPROV_GenerateBootstrapChallenge, DRM_API, DRM_RESULT )(
+    __inout                                               DRM_SECURECORE_CONTEXT     *f_pSecureCoreCtx,
+    __in                                                  DRM_DWORD                   f_cbRProvContext,
+    __in_bcount_opt( f_cbRProvContext )             const DRM_BYTE                   *f_pbRProvContext,
+    __out                                                 DRM_DWORD                  *f_pcbRProvContextUpdated,
+    __deref_out_bcount( *f_pcbRProvContextUpdated )       DRM_BYTE                  **f_ppbRProvContextUpdated,
+    __out                                                 DRM_DWORD                  *f_pcbChallenge,
+    __deref_out_bcount( *f_pcbChallenge )                 DRM_BYTE                  **f_ppbChallenge,
+    __out                                                 DRM_DWORD                  *f_pdwType,
+    __out                                                 DRM_DWORD                  *f_pdwStep ) DRM_SIGNATURE_POSTFIX;
+
+DRM_GET_FUNCTION_SIGNATURE_WOTYPE( RPROV_ProcessBootstrapResponse, DRM_API, DRM_RESULT )(
+    __inout                                               DRM_SECURECORE_CONTEXT     *f_pSecureCoreCtx,
+    __in                                                  DRM_DWORD                   f_cbResponse,
+    __in_bcount_opt( f_cbResponse )                 const DRM_BYTE                   *f_pbResponse,
+    __in                                                  DRM_DWORD                   f_cbRProvContext,
+    __in_bcount_opt( f_cbRProvContext )             const DRM_BYTE                   *f_pbRProvContext,
+    __out                                                 DRM_DWORD                  *f_pcbRProvContextUpdated,
+    __deref_out_bcount( *f_pcbRProvContextUpdated )       DRM_BYTE                  **f_ppbRProvContextUpdated,
+    __out                                                 DRM_DWORD                  *f_pcbTPKB,
+    __deref_out_bcount( *f_pcbTPKB )                      DRM_BYTE                  **f_ppbTPKB ) DRM_SIGNATURE_POSTFIX;
+
+DRM_GET_FUNCTION_SIGNATURE_WOTYPE( RPROV_GenerateProvisioningRequest, DRM_API, DRM_RESULT )(
+    __inout                                               DRM_SECURECORE_CONTEXT     *f_pSecureCoreCtx,
+    __in                                                  DRM_DWORD                   f_cbTPKB,
+    __in_bcount( f_cbTPKB )                         const DRM_BYTE                   *f_pbTPKB,
+    __in                                            const DRM_ID                     *f_pbApplicationID,
+    __out                                                 DRM_DWORD                  *f_pcbChallenge,
+    __deref_out_bcount( *f_pcbChallenge )                 DRM_BYTE                  **f_ppbChallenge ) DRM_SIGNATURE_POSTFIX;
+
+DRM_GET_FUNCTION_SIGNATURE_WOTYPE( RPROV_ProcessProvisioningResponse, DRM_API, DRM_RESULT )(
+    __inout                                               DRM_SECURECORE_CONTEXT     *f_pSecureCoreCtx,
+    __in                                                  DRM_DST                    *f_pHDS,
+    __in                                                  DRM_DWORD                   f_cbResponse,
+    __in_bcount( f_cbResponse )                     const DRM_BYTE                   *f_pbResponse,
+    __in                                                  DRM_DWORD                   f_cbTPKB,
+    __in_bcount( f_cbTPKB )                         const DRM_BYTE                   *f_pbTPKB ) DRM_SIGNATURE_POSTFIX;
+
+DRM_GET_FUNCTION_SIGNATURE_WOTYPE( SignHash, DRM_API, DRM_RESULT )(
+    __inout                                              DRM_SECURECORE_CONTEXT      *f_pSecureCoreCtx,
+    __in                                                 DRM_DWORD                    f_cbToSign,
+    __in_bcount( f_cbToSign )                      const DRM_BYTE                    *f_pbToSign,
+    __out                                                SIGNATURE_P256              *f_pSignature ) DRM_SIGNATURE_POSTFIX;
+
+DRM_GET_FUNCTION_SIGNATURE_WOTYPE( GetSecureStopGenerationID, DRM_API, DRM_RESULT )(
+    __inout                                             DRM_SECURECORE_CONTEXT       *f_pSecureCoreCtx,
+    __in                                          const DRM_ID                       *f_pidEnvironment,
+    __out                                               DRM_DWORD                    *f_pdwGenerationID ) DRM_SIGNATURE_POSTFIX;
+
+DRM_GET_FUNCTION_SIGNATURE_WOTYPE( SECURESTOP2_GetSigningKeyBlob, DRM_API, DRM_RESULT )(
+    __inout                                             DRM_SECURECORE_CONTEXT       *f_pSecureCoreCtx,
+    __in                                          const DRM_TEE_BYTE_BLOB            *f_pCDKB,
+    __out                                               DRM_TEE_BYTE_BLOB            *f_pSSKB ) DRM_SIGNATURE_POSTFIX;
+
+DRM_GET_FUNCTION_SIGNATURE_WOTYPE( SECURESTOP2_ReadSSKBFromDecryptor, DRM_API, DRM_RESULT )(
+    __inout                                             DRM_SECURECORE_CONTEXT       *f_pSecureCoreCtx,
+    __in_opt                                      const DRM_CIPHER_CONTEXT           *f_pDecryptor,
+    __inout                                             DRM_DWORD                    *f_pcbSSKB,
+    __out_bcount( *f_pcbSSKB )                          DRM_BYTE                     *f_pbSSKB ) DRM_SIGNATURE_POSTFIX;
+
+DRM_GET_FUNCTION_SIGNATURE_WOTYPE( SECURESTOP2_SignChallenge, DRM_API, DRM_RESULT )(
+    __inout                                             DRM_SECURECORE_CONTEXT       *f_pSecureCoreCtx,
+    __in                                                DRM_DWORD                     f_cbSSKB,
+    __in_bcount_opt( f_cbSSKB )                   const DRM_BYTE                     *f_pbSSKB,
+    __in                                                DRM_DWORD                     f_cbUnsignedChallenge,
+    __in_bcount( f_cbUnsignedChallenge )          const DRM_BYTE                     *f_pbUnsignedChallenge,
+    __out                                               SIGNATURE_P256               *f_pBasicSignature,
+    __out                                               SIGNATURE_P256               *f_pAdditionalSignature,
+    __out                                               DRM_ID                       *f_pidSecureStopSession,
+    __out                                               DRM_ID                       *f_pKID ) DRM_SIGNATURE_POSTFIX;
+
+#endif //defined(SC_DEF_FOR_EXTCALLERS) || defined(SC_DEF_FOR_TEE)
+
+#undef DRM_GET_FUNCNAME
+#undef DRM_SIGNATURE_POSTFIX
+#undef DRM_GET_FUNCTION_SIGNATURE
+#undef DRM_GET_FUNCTION_SIGNATURE_WOTYPE
diff --git a/prebuilt-v4.4/noarch/include/drmsecurecoreconstants.h b/prebuilt-v4.4/noarch/include/drmsecurecoreconstants.h
new file mode 100644
index 0000000..29244ad
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmsecurecoreconstants.h
@@ -0,0 +1,24 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef _DRMSECURECORECONSTANTS_H_
+#define _DRMSECURECORECONSTANTS_H_ 1
+
+#include <drmdatastoretypes.h>
+
+ENTER_PK_NAMESPACE;
+
+extern DRM_GLOBAL_CONST  DRM_ID g_idPPKBSlot;
+extern DRM_GLOBAL_CONST  DRM_ID g_idCertSlot;
+extern DRM_GLOBAL_CONST  DRM_ID g_idAppIDSlot;
+extern DRM_GLOBAL_CONST  DRM_DST_NAMESPACE g_namespaceConfig;
+
+EXIT_PK_NAMESPACE;
+
+#endif /* _DRMSECURECORECONSTANTS_H_ */
+
diff --git a/prebuilt-v4.4/noarch/include/drmsecurecorefuncptrdefs.h b/prebuilt-v4.4/noarch/include/drmsecurecorefuncptrdefs.h
new file mode 100644
index 0000000..e7a3407
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmsecurecorefuncptrdefs.h
@@ -0,0 +1,147 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef _DRMSECURECOREFUNCDEFS_H_
+#define _DRMSECURECOREFUNCDEFS_H_ 1
+
+#include <drmsecurecoreconstants.h>
+#include <oemciphertypes.h>
+#include <drmnoncestore.h>
+#include <drmrevocationstore.h>
+#include <drmsecurecoretypes.h>
+#include <drmlicgen.h>
+
+PREFAST_PUSH_DISABLE_EXPLAINED(__WARNING_NONCONST_PARAM_25004, "Prefast Noise: DRM_SECURECORE_CONTEXT* should not be const.");
+
+#define SECURE_CORE_FUNCTION_LIST                                           \
+    ACTIVITY(AES128CBC_DecryptContentMultiple)                              \
+    ACTIVITY(AES128CTR_DecryptContentMultiple)                              \
+    ACTIVITY(BASE_FreeBlob)                                                 \
+    ACTIVITY(BuildLicense)                                                  \
+    ACTIVITY(CertCachingInitialize)                                         \
+    ACTIVITY(CleanLocalLicenseContext)                                      \
+    ACTIVITY(CleanupCache)                                                  \
+    ACTIVITY(CleanupPublicKeyContext)                                       \
+    ACTIVITY(CloseDecryptContext)                                           \
+    ACTIVITY(CompleteCaching)                                               \
+    ACTIVITY(CreateBlobCachePassword)                                       \
+    ACTIVITY(CreateGlobalStorePassword)                                     \
+    ACTIVITY(CreateLicenseStateStorePassword)                               \
+    ACTIVITY(CreateMeterStorePassword)                                      \
+    ACTIVITY(CreateOEMBlobFromCDKB)                                         \
+    ACTIVITY(CreateRevocationStorePassword)                                 \
+    ACTIVITY(CreateSecureStopStorePassword)                                 \
+    ACTIVITY(DecryptContent)                                                \
+    ACTIVITY(DecryptAudioContentMultiple)                                   \
+    ACTIVITY(DecryptContentLegacy)                                          \
+    ACTIVITY(DeleteDomainLKBs)                                              \
+    ACTIVITY(DuplicateDecryptContext)                                       \
+    ACTIVITY(DuplicatePublicKeyContext)                                     \
+    ACTIVITY(EncryptOpaque)                                                 \
+    ACTIVITY(EscrowRevocationInfo)                                          \
+    ACTIVITY(FindAndCleanLicenseKeyCache)                                   \
+    ACTIVITY(FreeDecryptedContent)                                          \
+    ACTIVITY(GenerateNonce)                                                 \
+    ACTIVITY(GetCertificate)                                                \
+    ACTIVITY(GetCertificateWeakRef)                                         \
+    ACTIVITY(GetDeviceKeyEncryptPublicKeyWeakRef)                           \
+    ACTIVITY(GetDeviceKeySignPublicKeyWeakRef)                              \
+    ACTIVITY(GetOpaqueKeyFileContextWeakRef)                                \
+    ACTIVITY(GetError)                                                      \
+    ACTIVITY(SetError)                                                      \
+    ACTIVITY(GetRKBWeakRef)                                                 \
+    ACTIVITY(GetSystemTime)                                                 \
+    ACTIVITY(GetFeatureInformationWeakRef)                                  \
+    ACTIVITY(GetVersionInformation)                                         \
+    ACTIVITY(GetIsRunningInHWDRM)                                           \
+    ACTIVITY(HasTeeData)                                                    \
+    ACTIVITY(InitLocalLicenseContext)                                       \
+    ACTIVITY(IsREEFeatureSupported)                                         \
+    ACTIVITY(IsSystemPropertySet)                                           \
+    ACTIVITY(PrepareDomainKeysForStorage)                                   \
+    ACTIVITY(PreparePolicyInfo)                                             \
+    ACTIVITY(PrepareSampleProtectionKey)                                    \
+    ACTIVITY(PrepareToDecrypt)                                              \
+    ACTIVITY(ProcessLicenseForStorage)                                      \
+    ACTIVITY(DeleteLicenseLKB)                                              \
+    ACTIVITY(ReleaseLicense)                                                \
+    ACTIVITY(SetStorePasswordCallback)                                      \
+    ACTIVITY(SignRMPChallenge)                                              \
+    ACTIVITY(TransferPublicKeyContext)                                      \
+    ACTIVITY(UnwrapPublicKeyHandle)                                         \
+    ACTIVITY(ValidateMachineID)                                             \
+    ACTIVITY(CheckDeviceKeys)                                               \
+    ACTIVITY(SECURETIME_GenerateChallengeData)                              \
+    ACTIVITY(SECURETIME_ProcessResponseData)                                \
+
+#define ACTIVITY_INITIALIZE_SC_FUNCTION_POINTERS(FUNCNAME, POINTER, IMPL)                                                                                          \
+    POINTER->pfnDRM_SECURECORE_##FUNCNAME                                                  = DRM_SECURECORE_##IMPL##_##FUNCNAME;                                   \
+
+ENTER_PK_NAMESPACE;
+
+typedef DRM_API DRM_RESULT( DRM_CALL *LPFN_DRM_SECURECORE_PreInitialize )(
+    __in_opt                                                  DRM_VOID                       *f_pOEMContext,
+    __out                                                     DRM_VOID                      **f_ppvPreInitializeContext,
+    __out                                                     DRM_ID                         *f_pCurrentAppId,
+    __out                                                     DRM_ID                         *f_pUniqueId,
+    __out_opt                                                 DRM_SECURECORE_VERSIONINFO     *f_pSecureCoreVerInfo,
+    __out_ecount_opt( DRM_TEE_METHOD_FUNCTION_MAP_COUNT )     DRM_DWORD                      *f_pdwFunctionMap );
+
+typedef DRM_API DRM_RESULT( DRM_CALL *LPFN_DRM_SECURECORE_Initialize )(
+    __inout                                                   DRM_SECURECORE_CONTEXT         *f_pSecureCoreCtx,
+    __in_opt                                                  DRM_VOID                       *f_pOEMContext,
+    __in                                                      DRM_DWORD                       f_cchVersion,
+    __in_ecount( f_cchVersion )                               DRM_CHAR                       *f_pszVersion,
+    __in                                                      DRM_DST                        *f_pHDS,
+    __in_opt                                            const DRM_CONST_STRING               *f_pdstrDeviceStoreName,
+    __in                                                      DRM_DWORD                       f_cbWorkingBuffer,
+    __inout_bcount( f_cbWorkingBuffer )                       DRM_BYTE                       *f_pbWorkingBuffer,
+    __inout_opt                                               DRM_VOID                      **f_ppvPreInitializeContext,
+    __in_opt                                                  DRM_ID                         *f_pCurrentAppId,
+    __out_opt                                                 DRM_SECURECORE_VERSIONINFO     *f_pSecureCoreVerInfo,
+    __out_ecount_opt( DRM_TEE_METHOD_FUNCTION_MAP_COUNT )     DRM_DWORD                      *f_pdwFunctionMap );
+
+#define DRM_SC_DEF_FOR_FUNCPTR 1
+
+#include <drmsecurecore_template.h>
+
+#undef DRM_SC_DEF_FOR_FUNCPTR
+
+#define ACTIVITY(FUNCNAME)\
+    LPFN_DRM_SECURECORE_##FUNCNAME                                               pfnDRM_SECURECORE_##FUNCNAME;
+
+typedef struct __tagDRM_SECURECORE_FUNCTIONPTRS
+{
+    SECURE_CORE_FUNCTION_LIST
+
+    /* Special functions - not defined for all SecureCores */
+    LPFN_DRM_SECURECORE_PreInitialize                                               pfnDRM_SECURECORE_PreInitialize;
+    LPFN_DRM_SECURECORE_PreUninitialize                                             pfnDRM_SECURECORE_PreUninitialize;
+    LPFN_DRM_SECURECORE_Initialize                                                  pfnDRM_SECURECORE_Initialize;
+    LPFN_DRM_SECURECORE_Uninitialize                                                pfnDRM_SECURECORE_Uninitialize;
+} DRM_SECURECORE_FUNCTION_POINTERS;
+#undef ACTIVITY
+
+typedef struct __tagDRM_SECURECORE_DECRYPT_FUNCTIONPTRS
+{
+    LPFN_DRM_SECURECORE_CloseDecryptContext                                         pfnDRM_SECURECORE_CloseDecryptContext;
+    LPFN_DRM_SECURECORE_DecryptContent                                              pfnDRM_SECURECORE_DecryptContent;
+    LPFN_DRM_SECURECORE_DecryptAudioContentMultiple                                 pfnDRM_SECURECORE_DecryptAudioContentMultiple;
+    LPFN_DRM_SECURECORE_DecryptContentLegacy                                        pfnDRM_SECURECORE_DecryptContentLegacy;
+    LPFN_DRM_SECURECORE_DuplicateDecryptContext                                     pfnDRM_SECURECORE_DuplicateDecryptContext;
+    LPFN_DRM_SECURECORE_FreeDecryptedContent                                        pfnDRM_SECURECORE_FreeDecryptedContent;
+    LPFN_DRM_SECURECORE_AES128CBC_DecryptContentMultiple                            pfnDRM_SECURECORE_AES128CBC_DecryptContentMultiple;
+    LPFN_DRM_SECURECORE_AES128CTR_DecryptContentMultiple                            pfnDRM_SECURECORE_AES128CTR_DecryptContentMultiple;
+} DRM_SECURECORE_DECRYPT_FUNCTION_POINTERS;
+
+EXIT_PK_NAMESPACE;
+
+PREFAST_POP; /* __WARNING_NONCONST_PARAM_25004 */
+
+#endif /* _DRMSECURECOREFUNCDEF_H_ */
+
diff --git a/prebuilt-v4.4/noarch/include/drmsecurecoretypes.h b/prebuilt-v4.4/noarch/include/drmsecurecoretypes.h
new file mode 100644
index 0000000..c29b94c
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmsecurecoretypes.h
@@ -0,0 +1,106 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef _DRMSECURECORETYPES_H_
+#define _DRMSECURECORETYPES_H_ 1
+
+#include <drmkeyfilecerttypes.h>
+#include <drmteetypes.h>
+#include <drmblackboxtypes.h>
+#include <oemteetypes.h>
+
+ENTER_PK_NAMESPACE;
+
+typedef enum __tagDRM_REE_FEATURE_ENUM
+{
+    DRM_REE_FEATURE_ENUM_AESCBCS        = 0x0001,
+    DRM_REE_FEATURE_ENUM_SECURESTOP2    = 0x0002,
+} DRM_REE_FEATURE_ENUM;
+
+typedef DRM_RESULT( DRM_CALL* DRM_SECURECORE_TEE_DATA_STORE_PASSWORD_CALLBACK )(
+    __inout                               DRM_VOID    *f_pvUserCtx,
+    __in                                  DRM_BOOL     f_fRead,
+    __in                                  DRM_DWORD    f_cbToSign,
+    __in_bcount( f_cbToSign )       const DRM_BYTE    *f_pbToSign,
+    __inout_bcount( OEM_SHA1_DIGEST_LEN ) DRM_BYTE    *f_pbPasswordSST );
+
+/*
+** Maximum number of nonces to be stored in memory in a single session
+*/
+#define DRM_MAX_NONCE_COUNT_PER_SESSION ((DRM_DWORD)(100))
+
+typedef struct __tagDRM_NKB_DATA
+{
+    DRM_TEE_BYTE_BLOB     rgNKBs[DRM_MAX_NONCE_COUNT_PER_SESSION];
+    DRM_ID                rgNonces[DRM_MAX_NONCE_COUNT_PER_SESSION];
+    DRM_DWORD             cNonces;
+} DRM_NKB_DATA;
+
+typedef struct __tagDRM_SECURECORE_TEE_DATA
+{
+    DRM_TEE_PROXY_CONTEXT *pTeeCtx;
+    DRM_TEE_BYTE_BLOB      oCertificate;
+    DRM_TEE_BYTE_BLOB      oPPKB;
+    DRM_TEE_BYTE_BLOB      oRKB;
+    DRM_TEE_BYTE_BLOB      oSPKB;
+    DRM_TEE_BYTE_BLOB      oTeeFeatureInformationXml;
+    DRM_NKB_DATA           oNKBData;
+    DRM_RESULT             drError;     /* Hold error codes returned from the TEE that will trigger reprovisioning */
+
+    DRM_SECURECORE_TEE_DATA_STORE_PASSWORD_CALLBACK     pfnStorePasswordCallback;
+} DRM_SECURECORE_TEE_DATA;
+
+typedef struct __tagDRM_SECURECORE_INTERNAL_DATA
+{
+    DRM_VOID         *pOpaqueKeyFileContext;
+    DRM_VOID         *pOpaqueBlackBoxContext;
+    DRM_VOID         *pOpaqueKeyHandleCallbacks;
+} DRM_SECURECORE_INTERNAL_DATA;
+
+typedef struct __tagDRM_SECURECORE_CONTEXT
+{
+    union
+    {
+        DRM_SECURECORE_TEE_DATA             *pSecureCoreTeeData;
+        DRM_SECURECORE_INTERNAL_DATA        *pSecureCoreInternalData;
+    } uData;
+
+    DRM_VOID                                *pOEMContext;
+    DRM_CLIENT_INFO                         *pClientInfo;
+    DRM_CRYPTO_CONTEXT                      *pCryptoContext;
+    DRM_BINARY_DEVICE_CERT_CACHED_VALUES    *pCertCache;
+    DRM_VOID                                *pFuncTbl;
+    DRM_BOOL                                 fIsRunningInHWDRM;
+    DRM_BOOL                                 fDisableBlobCache;
+} DRM_SECURECORE_CONTEXT;
+
+typedef struct __tagDRM_SECURECORE_VERSIONINFO
+{
+    DRM_DWORD       dwPKMajorVersion;
+    DRM_DWORD       dwPKMinorVersion;
+    DRM_DWORD       dwPKBuildVersion;
+    DRM_DWORD       dwPKQFEVersion;
+    DRM_DWORD       dwOEMVersion;
+    DRM_DWORD       cbSystemProperties;
+    const DRM_BYTE *pbSystemPropertiesWeakRef;
+    DRM_DWORD       cchOEMManufacturerName;
+    DRM_WCHAR      *pwszOEMManufacturerNameWeakRef;
+    DRM_DWORD       cchOEMModelName;
+    DRM_WCHAR      *pwszOEMModelNameWeakRef;
+    DRM_DWORD       cchOEMModelNumber;
+    DRM_WCHAR      *pwszOEMModelNumberWeakRef;
+    DRM_DWORD       cbOEMVersion2;
+    DRM_BYTE       *pbOEMVersion2WeakRef;
+} DRM_SECURECORE_VERSIONINFO;
+
+#define DRM_SECURECORE_DisableBlobCache( __pSecureCoreCtx ) DRM_DO { (__pSecureCoreCtx)->fDisableBlobCache = TRUE; } DRM_WHILE_FALSE
+
+EXIT_PK_NAMESPACE;
+
+#endif /* _DRMSECURECORETYPES_H_ */
+
diff --git a/prebuilt-v4.4/noarch/include/drmsecuredelete.h b/prebuilt-v4.4/noarch/include/drmsecuredelete.h
new file mode 100644
index 0000000..713fb0d
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmsecuredelete.h
@@ -0,0 +1,68 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef _DRMSECUREDELETE_H_
+#define _DRMSECUREDELETE_H_ 1
+
+#include <drmsecurecoretypes.h>
+
+ENTER_PK_NAMESPACE;
+
+/*********************************************************************
+**
+** Function: DRM_SECUREDELETE_GenerateChallenge
+**
+** Synopsis: This function generates a message challenge.
+**
+** Arguments:
+**
+** [f_pSecureCore]          -- Pointer to a secure core context.
+** [f_pIdSession]           -- Id for the session to be deleted.
+** [f_pcbChallenge]         -- The secure stop challenge size in bytes.
+** [f_ppbChallenge]         -- The secure stop challenge buffer.
+**
+** Returns:                 DRM_SUCCESS on success.
+**                          DRM_E_INVALIDARG if the arguments are invalid.
+**                          DRM_E_NOMORE if there are no messages in the HDS.
+**
+** Notes:                   Caller must free f_ppbChallenge using
+**                          Oem_MemFree after use.
+**
+*********************************************************************/
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_SECUREDELETE_GenerateChallenge(
+    __inout                                 DRM_SECURECORE_CONTEXT     *f_pSecureCore,
+    __in                              const DRM_ID                     *f_pIdSession,
+    __in                                    DRM_DWORD                   f_cKeyIDs,
+    __in_ecount(f_cKeyIDs)            const DRM_ID                     *f_rgKeyIDs,
+    __out                                   DRM_DWORD                  *f_pcbChallenge,
+    __deref_out_bcount(*f_pcbChallenge)     DRM_BYTE                  **f_ppbChallenge );
+
+/*********************************************************************
+**
+** Function: DRM_SECUREDELETE_ProcessResponse
+**
+** Synopsis: This function processes a message response.
+**
+** Arguments:
+**
+** [f_cbResponse]           -- The secure stop response size in bytes.
+** [f_pbResponse]           -- The secure stop response buffer.
+** [f_pIdSession]           -- The Session Id received in the response.
+**
+** Returns:                 DRM_SUCCESS on success.
+**                          DRM_E_INVALIDARG if the arguments are invalid.
+**
+**********************************************************************/
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_SECUREDELETE_ProcessResponse(
+    __in                                  const DRM_DWORD                   f_cbResponse,
+    __in_bcount(f_cbResponse)             const DRM_BYTE                   *f_pbResponse,
+    __out                                       DRM_ID                     *f_pIdSession );
+
+EXIT_PK_NAMESPACE;
+
+#endif /* _DRMSECUREDELETE_H_ */
diff --git a/prebuilt-v4.4/noarch/include/drmsecuredeleteconstants.h b/prebuilt-v4.4/noarch/include/drmsecuredeleteconstants.h
new file mode 100644
index 0000000..98310ba
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmsecuredeleteconstants.h
@@ -0,0 +1,55 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef _DRMSECUREDELETECONSTANTS_H_
+#define _DRMSECUREDELETECONSTANTS_H_ 1
+
+#include <drmtypes.h>
+
+ENTER_PK_NAMESPACE;
+
+/*
+** XML strings used in the construction of a secure delete challenge.
+*/
+
+extern DRM_GLOBAL_CONST DRM_ANSI_CONST_STRING g_dastrSecureDeleteRootTag;
+extern DRM_GLOBAL_CONST DRM_ANSI_CONST_STRING g_dastrSecureDeleteLicenseDataTag;
+extern DRM_GLOBAL_CONST DRM_ANSI_CONST_STRING g_dastrSecureDeleteRootAttribName;
+extern DRM_GLOBAL_CONST DRM_ANSI_CONST_STRING g_dastrSecureDeleteRootAttribValue;
+extern DRM_GLOBAL_CONST DRM_ANSI_CONST_STRING g_dastrSecureDeleteChallenge1Tag;
+extern DRM_GLOBAL_CONST DRM_ANSI_CONST_STRING g_dastrSecureDeleteChallenge2Tag;
+extern DRM_GLOBAL_CONST DRM_ANSI_CONST_STRING g_dastrSecureDeleteChallenge2AttribName;
+extern DRM_GLOBAL_CONST DRM_ANSI_CONST_STRING g_dastrSecureDeleteChallenge2AttribValue;
+extern DRM_GLOBAL_CONST DRM_ANSI_CONST_STRING g_dastrSecureDeleteDataAttrib1Name;
+extern DRM_GLOBAL_CONST DRM_ANSI_CONST_STRING g_dastrSecureDeleteDataAttrib1Value;
+extern DRM_GLOBAL_CONST DRM_ANSI_CONST_STRING g_dastrSecureDeleteDataAttrib2Name;
+extern DRM_GLOBAL_CONST DRM_ANSI_CONST_STRING g_dastrSecureDeleteDataAttrib2Value;
+extern DRM_GLOBAL_CONST DRM_ANSI_CONST_STRING g_dastrSecureDeleteVersionTag;
+extern DRM_GLOBAL_CONST DRM_ANSI_CONST_STRING g_dastrSecureDeleteSessionID;
+extern DRM_GLOBAL_CONST DRM_ANSI_CONST_STRING g_dastrSecureDeleteKIDS;
+extern DRM_GLOBAL_CONST DRM_ANSI_CONST_STRING g_dastrSecureDeleteKID;
+extern DRM_GLOBAL_CONST DRM_ANSI_CONST_STRING g_dastrSecureDeleteCertificateChainTag;
+extern DRM_GLOBAL_CONST DRM_ANSI_CONST_STRING g_dastrSecureDeleteDataTag;
+
+/*
+** XML strings used in the parsing of a secure delete response.
+*/
+
+extern DRM_GLOBAL_CONST DRM_ANSI_CONST_STRING g_dastrSecureDeleteVersionPath;
+extern DRM_GLOBAL_CONST DRM_ANSI_CONST_STRING g_dastrSecureDeleteSessionIDPath;
+
+/*
+** XML strings used in both the challenge and the response.
+*/
+
+extern DRM_GLOBAL_CONST DRM_ANSI_CONST_STRING g_dastrSecureDeleteVersionValue;
+
+
+EXIT_PK_NAMESPACE;
+
+#endif /* _DRMSECUREDELETECONSTANTS_H_ */
diff --git a/prebuilt-v4.4/noarch/include/drmsecurestop.h b/prebuilt-v4.4/noarch/include/drmsecurestop.h
new file mode 100644
index 0000000..a09cedc
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmsecurestop.h
@@ -0,0 +1,271 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef _DRMSECURESTOP_H_
+#define _DRMSECURESTOP_H_ 1
+
+#include <oemciphertypes.h>
+#include <drmbytemanip.h>
+#include <drmsecurecoretypes.h>
+#include <drmsecurestoretypes.h>
+#include <drmsecurestoptypes.h>
+
+ENTER_PK_NAMESPACE;
+
+/*********************************************************************
+**
+** Function: DRM_SECURESTOP_Initialize
+**
+** Synopsis: This function initializes a secure store context for
+**           secure stop.
+**
+** Arguments:
+**
+** [f_pSecureCore]          -- Pointer to a secure core context.
+** [f_pDatastore]           -- Pointer to an initialized data store.
+**
+** Returns:                 DRM_SUCCESS on success.
+**                          DRM_E_INVALIDARG if the arguments are invalid.
+**
+**********************************************************************/
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_SECURESTOP_Initialize(
+    __inout                                 DRM_SECURECORE_CONTEXT     *f_pSecureCore,
+    __in                                    DRM_DST                    *f_pDatastore );
+
+/*********************************************************************
+**
+** Function: DRM_SECURESTOP_CreateSession
+**
+** Synopsis: This function creates a new secure stop session.
+**
+** Arguments:
+**
+** [f_pSecureCore]          -- Pointer to a secure core context.
+** [f_pDatastore]           -- Pointer to an initialized data store.
+** [f_pidSession]           -- The ID used to identify this session.
+** [f_pidPublisher]         -- The ID of the application publisher.
+** [f_cidLicenses]          -- The count of license ID's.
+** [f_pidLicenses]          -- The ID's of the licenses.
+** [f_pSession]             -- The secure stop session.
+**
+** Returns:                 DRM_SUCCESS on success.
+**                          DRM_E_INVALIDARG if the arguments are invalid.
+**
+**********************************************************************/
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_SECURESTOP_CreateSession(
+    __inout                                 DRM_SECURECORE_CONTEXT     *f_pSecureCore,
+    __in                                    DRM_DST                    *f_pDatastore,
+    __in_opt                          const DRM_ID                     *f_pidSession,
+    __in                              const DRM_ID                     *f_pidPublisher,
+    __in                              const DRM_DWORD                   f_cidLicenses,
+    __in_ecount_opt(f_cidLicenses)    const DRM_LID                    *f_pidLicenses,
+    __out                                   DRM_SECURESTOP_SESSION     *f_pSession );
+
+/*********************************************************************
+**
+** Function: DRM_SECURESTOP_BindDecryptor
+**
+** Synopsis: This function binds a decryptor to a secure stop session.
+**
+** Arguments:
+**
+** [f_pSecureCore]          -- Pointer to a secure core context.
+** [f_pDatastore]           -- Pointer to an initialized data store.
+** [f_pSession]             -- The secure stop session.
+** [f_pDecryptor]           -- A pointer to the decryptor.
+**
+** Returns:                 DRM_SUCCESS on success.
+**                          DRM_E_INVALIDARG if the arguments are invalid.
+**
+**********************************************************************/
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_SECURESTOP_BindDecryptor(
+    __inout                                 DRM_SECURECORE_CONTEXT     *f_pSecureCore,
+    __in                                    DRM_DST                    *f_pDatastore,
+    __inout                                 DRM_SECURESTOP_SESSION     *f_pSession,
+    __in                              const DRM_CIPHER_CONTEXT         *f_pDecryptor );
+
+/*********************************************************************
+**
+** Function: DRM_SECURESTOP_UpdateSession
+**
+** Synopsis: This function updates a secure stop session.
+**
+** Arguments:
+**
+** [f_pSecureCore]          -- Pointer to a secure core context.
+** [f_pDatastore]           -- Pointer to an initialized data store.
+** [f_pSession]             -- The secure stop session.
+** [f_fSuspend]             -- Indicate whether playback is suspended.
+**
+** Returns:                 DRM_SUCCESS on success.
+**                          DRM_E_INVALIDARG if the arguments are invalid.
+**
+**********************************************************************/
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_SECURESTOP_UpdateSession(
+    __inout                                 DRM_SECURECORE_CONTEXT     *f_pSecureCore,
+    __in                                    DRM_DST                    *f_pDatastore,
+    __inout                                 DRM_SECURESTOP_SESSION     *f_pSession,
+    __in                                    DRM_BOOL                    f_fSuspend );
+
+/*********************************************************************
+**
+** Function: DRM_SECURESTOP_UnbindDecryptor
+**
+** Synopsis: This function unbinds a decryptor from a secure stop session.
+**
+** Arguments:
+**
+** [f_pSecureCore]          -- Pointer to a secure core context.
+** [f_pDatastore]           -- Pointer to an initialized data store.
+** [f_pSession]             -- The secure stop session.
+** [f_pDecryptor]           -- A pointer to the decryptor.
+**
+** Returns:                 DRM_SUCCESS on success.
+**                          DRM_E_INVALIDARG if the arguments are invalid.
+**
+**********************************************************************/
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_SECURESTOP_UnbindDecryptor(
+    __inout                                 DRM_SECURECORE_CONTEXT     *f_pSecureCore,
+    __in                                    DRM_DST                    *f_pDatastore,
+    __inout                                 DRM_SECURESTOP_SESSION     *f_pSession,
+    __in                              const DRM_CIPHER_CONTEXT         *f_pDecryptor );
+
+/*********************************************************************
+**
+** Function: DRM_SECURESTOP_GenerateChallenge
+**
+** Synopsis: This function generates a message challenge.
+**
+** Arguments:
+**
+** [f_pSecureCore]          -- Pointer to a secure core context.
+** [f_pDatastore]           -- Pointer to an initialized data store.
+** [f_pSession]             -- The secure stop session.
+** [f_pPublicKey]           -- The publisher certificate public key.
+** [f_cchCustomData]        -- The challenge custom data string length.
+** [f_pchCustomData]        -- The challenge custom data string buffer.
+** [f_pcbChallenge]         -- The secure stop challenge size in bytes.
+** [f_ppbChallenge]         -- The secure stop challenge buffer.
+**
+** Returns:                 DRM_SUCCESS on success.
+**                          DRM_E_INVALIDARG if the arguments are invalid.
+**                          DRM_E_NOMORE if there are no messages in the HDS.
+**
+** Notes:                   Caller must free f_ppbChallenge using
+**                          Oem_MemFree after use.
+**
+*********************************************************************/
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_SECURESTOP_GenerateChallenge(
+    __inout                                 DRM_SECURECORE_CONTEXT     *f_pSecureCore,
+    __in                                    DRM_DST                    *f_pDatastore,
+    __inout                                 DRM_SECURESTOP_SESSION     *f_pSession,
+    __in                              const PUBKEY_P256                *f_pPublicKey,
+    __in                              const DRM_DWORD                   f_cchCustomData,
+    __in_ecount_opt(f_cchCustomData)  const DRM_CHAR                   *f_pchCustomData,
+    __out                                   DRM_DWORD                  *f_pcbChallenge,
+    __deref_out_bcount(*f_pcbChallenge)     DRM_BYTE                  **f_ppbChallenge );
+
+/*********************************************************************
+**
+** Function: DRM_SECURESTOP_ProcessResponse
+**
+** Synopsis: This function processes a message response.
+**
+** Arguments:
+**
+** [f_pSecureCore]          -- Pointer to a secure core context.
+** [f_pDatastore]           -- Pointer to an initialized data store.
+** [f_pSession]             -- The secure stop session.
+** [f_cbResponse]           -- The secure stop response size in bytes.
+** [f_pbResponse]           -- The secure stop response buffer.
+** [f_pcchCustomData]       -- The response custom data string length.
+** [f_ppchCustomData]       -- The response custom data string buffer.
+**
+** Returns:                 DRM_SUCCESS on success.
+**                          DRM_E_INVALIDARG if the arguments are invalid.
+**
+**********************************************************************/
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_SECURESTOP_ProcessResponse(
+    __inout                                     DRM_SECURECORE_CONTEXT     *f_pSecureCore,
+    __in                                        DRM_DST                    *f_pDatastore,
+    __inout                                     DRM_SECURESTOP_SESSION     *f_pSession,
+    __in                                  const DRM_DWORD                   f_cbResponse,
+    __in_bcount(f_cbResponse)             const DRM_BYTE                   *f_pbResponse,
+    __out_opt                                   DRM_DWORD                  *f_pcchCustomData,
+    __deref_out_ecount_opt(*f_pcchCustomData)   DRM_CHAR                  **f_ppchCustomData );
+
+/*********************************************************************
+**
+** Function: DRM_SECURESTOP_EnumerateSessions
+**
+** Synopsis: This function enumerates existing secure stop sessions.
+**
+** Arguments:
+**
+** [f_pSecureCore]          -- Pointer to a secure core context.
+** [f_pDatastore]           -- Pointer to an initialized data store.
+** [f_pidPublisher]         -- The ID of the application publisher.
+** [f_pcidSessions]         -- The count of session ID's.
+** [f_ppidSessions]         -- The enumerated session ID's.
+**
+** Returns:                 DRM_SUCCESS on success.
+**                          DRM_E_INVALIDARG if the arguments are invalid.
+**
+** Notes:                   Caller must free f_ppidSessions using
+**                          Oem_MemFree after use.
+**
+**********************************************************************/
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_SECURESTOP_EnumerateSessions(
+    __inout                                 DRM_SECURECORE_CONTEXT     *f_pSecureCore,
+    __in                                    DRM_DST                    *f_pDatastore,
+    __in                              const DRM_ID                     *f_pidPublisher,
+    __out                                   DRM_DWORD                  *f_pcidSessions,
+    __deref_out_ecount(*f_pcidSessions)     DRM_ID                    **f_ppidSessions );
+
+/*********************************************************************
+**
+** Function: DRM_SECURESTOP_LoadSession
+**
+** Synopsis: This function loads an existing secure stop session.
+**
+** Arguments:
+**
+** [f_pSecureCore]          -- Pointer to a secure core context.
+** [f_pDatastore]           -- Pointer to an initialized data store.
+** [f_pidSession]           -- The ID used to identify this session.
+** [f_pidPublisher]         -- The ID of the application publisher.
+** [f_pSession]             -- The secure stop session.
+**
+** Returns:                 DRM_SUCCESS on success.
+**                          DRM_E_INVALIDARG if the arguments are invalid.
+**
+**********************************************************************/
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_SECURESTOP_LoadSession(
+    __inout                                 DRM_SECURECORE_CONTEXT     *f_pSecureCore,
+    __in                                    DRM_DST                    *f_pDatastore,
+    __in                              const DRM_ID                     *f_pidSession,
+    __in_opt                          const DRM_ID                     *f_pidPublisher,
+    __out                                   DRM_SECURESTOP_SESSION     *f_pSession );
+
+/*********************************************************************
+**
+** Function: DRM_SECURESTOP_DeleteSession
+**
+** Synopsis: This function deletes an existing secure stop session.
+**
+** Arguments:
+**
+** [f_pidSession]           -- The ID used to identify this session.
+**
+**********************************************************************/
+DRM_NO_INLINE DRM_API_VOID DRM_VOID DRM_CALL DRM_SECURESTOP_DeleteSession(
+    __inout                                 DRM_SECURESTOP_SESSION     *f_pSession );
+
+EXIT_PK_NAMESPACE;
+
+#endif /* _DRMSECURESTOP_H_ */
diff --git a/prebuilt-v4.4/noarch/include/drmsecurestopconstants.h b/prebuilt-v4.4/noarch/include/drmsecurestopconstants.h
new file mode 100644
index 0000000..9082b52
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmsecurestopconstants.h
@@ -0,0 +1,67 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef _DRMSECURESTOPCONSTANTS_H_
+#define _DRMSECURESTOPCONSTANTS_H_ 1
+
+#include <drmtypes.h>
+
+ENTER_PK_NAMESPACE;
+
+/*
+** XML strings used in the construction of a secure stop challenge
+*/
+
+extern DRM_GLOBAL_CONST DRM_ANSI_CONST_STRING g_dastrSecureStopRootTag;
+extern DRM_GLOBAL_CONST DRM_ANSI_CONST_STRING g_dastrSecureStopRootAttribName;
+extern DRM_GLOBAL_CONST DRM_ANSI_CONST_STRING g_dastrSecureStopRootAttribValue;
+extern DRM_GLOBAL_CONST DRM_ANSI_CONST_STRING g_dastrSecureStopChallenge1Tag;
+extern DRM_GLOBAL_CONST DRM_ANSI_CONST_STRING g_dastrSecureStopChallenge2Tag;
+extern DRM_GLOBAL_CONST DRM_ANSI_CONST_STRING g_dastrSecureStopChallenge2AttribName;
+extern DRM_GLOBAL_CONST DRM_ANSI_CONST_STRING g_dastrSecureStopChallenge2AttribValue;
+extern DRM_GLOBAL_CONST DRM_ANSI_CONST_STRING g_dastrSecureStopDataTag;
+extern DRM_GLOBAL_CONST DRM_ANSI_CONST_STRING g_dastrSecureStopDataAttrib1Name;
+extern DRM_GLOBAL_CONST DRM_ANSI_CONST_STRING g_dastrSecureStopDataAttrib1Value;
+extern DRM_GLOBAL_CONST DRM_ANSI_CONST_STRING g_dastrSecureStopDataAttrib2Name;
+extern DRM_GLOBAL_CONST DRM_ANSI_CONST_STRING g_dastrSecureStopDataAttrib2Value;
+extern DRM_GLOBAL_CONST DRM_ANSI_CONST_STRING g_dastrSecureStopVersionTag;
+extern DRM_GLOBAL_CONST DRM_ANSI_CONST_STRING g_dastrSecureStopVersionValue;
+extern DRM_GLOBAL_CONST DRM_ANSI_CONST_STRING g_dastrSecureStopPublisherIDTag;
+extern DRM_GLOBAL_CONST DRM_ANSI_CONST_STRING g_dastrSecureStopTransactionIDTag;
+extern DRM_GLOBAL_CONST DRM_ANSI_CONST_STRING g_dastrSecureStopCustomDataTag;
+extern DRM_GLOBAL_CONST DRM_ANSI_CONST_STRING g_dastrSecureStopClearDataTag;
+extern DRM_GLOBAL_CONST DRM_ANSI_CONST_STRING g_dastrSecureStopRecordsTag;
+extern DRM_GLOBAL_CONST DRM_ANSI_CONST_STRING g_dastrSecureStopRecordTag;
+extern DRM_GLOBAL_CONST DRM_ANSI_CONST_STRING g_dastrSecureStopRecordAttribName;
+extern DRM_GLOBAL_CONST DRM_ANSI_CONST_STRING g_dastrSecureStopStartTimeTag;
+extern DRM_GLOBAL_CONST DRM_ANSI_CONST_STRING g_dastrSecureStopUpdateTimeTag;
+extern DRM_GLOBAL_CONST DRM_ANSI_CONST_STRING g_dastrSecureStopStoppedTag;
+extern DRM_GLOBAL_CONST DRM_ANSI_CONST_STRING g_dastrSecureStopStoppedValueTrue;
+extern DRM_GLOBAL_CONST DRM_ANSI_CONST_STRING g_dastrSecureStopStoppedValueFalse;
+extern DRM_GLOBAL_CONST DRM_ANSI_CONST_STRING g_dastrSecureStopCertificateChainTag;
+
+/*
+** XML strings used in the parsing of a secure stop response
+*/
+
+extern DRM_GLOBAL_CONST DRM_ANSI_CONST_STRING g_dastrSecureStopResponsePath;
+extern DRM_GLOBAL_CONST DRM_ANSI_CONST_STRING g_dastrSecureStopVersionPath;
+extern DRM_GLOBAL_CONST DRM_ANSI_CONST_STRING g_dastrSecureStopPublisherIDPath;
+extern DRM_GLOBAL_CONST DRM_ANSI_CONST_STRING g_dastrSecureStopTransactionIDPath;
+extern DRM_GLOBAL_CONST DRM_ANSI_CONST_STRING g_dastrSecureStopPublisherCertTag;
+extern DRM_GLOBAL_CONST DRM_ANSI_CONST_STRING g_dastrSecureStopCustomDataPath;
+extern DRM_GLOBAL_CONST DRM_ANSI_CONST_STRING g_dastrSecureStopEncryptedDataPath;
+extern DRM_GLOBAL_CONST DRM_ANSI_CONST_STRING g_dastrSecureStopKeyNamePath;
+extern DRM_GLOBAL_CONST DRM_ANSI_CONST_STRING g_dastrSecureStopKeyNameValue;
+extern DRM_GLOBAL_CONST DRM_ANSI_CONST_STRING g_dastrSecureStopRecordsPath;
+extern DRM_GLOBAL_CONST DRM_ANSI_CONST_STRING g_dastrSecureStopSessionIDPath;
+extern DRM_GLOBAL_CONST DRM_ANSI_CONST_STRING g_dastrSecureStopSignaturePath;
+
+EXIT_PK_NAMESPACE;
+
+#endif /* _DRMSECURESTOPCONSTANTS_H_ */
diff --git a/prebuilt-v4.4/noarch/include/drmsecurestopinternal.h b/prebuilt-v4.4/noarch/include/drmsecurestopinternal.h
new file mode 100644
index 0000000..4a5b609
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmsecurestopinternal.h
@@ -0,0 +1,69 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef _DRMSECURESTOPINTERNAL_H_
+#define _DRMSECURESTOPINTERNAL_H_ 1
+
+#include <oemciphertypes.h>
+#include <drmbytemanip.h>
+#include <drmsecurecoretypes.h>
+#include <drmsecurestoretypes.h>
+#include <drmsecurestoptypes.h>
+
+ENTER_PK_NAMESPACE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_SECURESTOP_INTERNAL_Initialize(
+    __in                                        DRM_APP_CONTEXT            *f_pAppContext );
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_SECURESTOP_INTERNAL_UnInitialize(
+    __inout                                     DRM_APP_CONTEXT            *f_pAppContext );
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_SECURESTOP_INTERNAL_ParseAndVerifyPublisherCert(
+    __in                                        DRM_APP_CONTEXT_INTERNAL   *f_pInternal,
+    __in                                  const DRM_DWORD                   f_cbPublisherCert,
+    __in_bcount(f_cbPublisherCert)        const DRM_BYTE                   *f_pbPublisherCert,
+    __out_opt                                   DRM_ID                     *f_pidPublisher,
+    __out_opt                                   PUBKEY_P256                *f_pPublicKey );
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_SECURESTOP_INTERNAL_GetSessionByLicenseID(
+    __in                                        DRM_SECURESTOP_CONTEXT     *f_pSecureStop,
+    __in                                  const DRM_LID                    *f_pLicenseID,
+    __deref_out_ecount(1)                       DRM_SECURESTOP_SESSION    **f_ppSession );
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_SECURESTOP_INTERNAL_GetSessionBySessionID(
+    __in                                        DRM_SECURESTOP_CONTEXT     *f_pSecureStop,
+    __in                                  const DRM_ID                     *f_pidSession,
+    __out                                       DRM_SECURESTOP_SESSION    **f_ppSession );
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_SECURESTOP_INTERNAL_CloseSessionDecryptors(
+    __in                                  const DRM_APP_CONTEXT            *f_pAppContext,
+    __inout                                     DRM_SECURESTOP_SESSION     *f_pSession );
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_SECURESTOP_INTERNAL_CloseAllDecryptors(
+    __inout                                     DRM_APP_CONTEXT            *f_pAppContext );
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_SECURESTOP_INTERNAL_CreateSession(
+    __in                                        DRM_APP_CONTEXT            *f_pAppContext,
+    __in_opt                              const DRM_ID                     *f_pidPublisher,
+    __in_opt                              const DRM_ID                     *f_pidSession,
+    __in                                  const DRM_DWORD                   f_cidLicenses,
+    __in_ecount_opt(f_cidLicenses)        const DRM_LID                    *f_pidLicenses );
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_SECURESTOP_INTERNAL_BindDecryptor(
+    __in                                        DRM_APP_CONTEXT            *f_pAppContext,
+    __inout                                     DRM_CIPHER_CONTEXT         *f_pCipherContext );
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_SECURESTOP_INTERNAL_UpdateSession(
+    __inout                                     DRM_CIPHER_CONTEXT         *f_pCipherContext );
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_SECURESTOP_INTERNAL_UnbindDecryptor(
+    __inout                                     DRM_CIPHER_CONTEXT         *f_pCipherContext );
+
+EXIT_PK_NAMESPACE;
+
+#endif /* _DRMSECURESTOPINTERNAL_H_ */
diff --git a/prebuilt-v4.4/noarch/include/drmsecurestoptypes.h b/prebuilt-v4.4/noarch/include/drmsecurestoptypes.h
new file mode 100644
index 0000000..b41fedb
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmsecurestoptypes.h
@@ -0,0 +1,89 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef _DRMSECURESTOPTYPES_H_
+#define _DRMSECURESTOPTYPES_H_ 1
+
+ENTER_PK_NAMESPACE;
+
+#define DRM_SECURESTOP_MAX_MESSAGES     100
+#define DRM_SECURESTOP_MAX_TRANSACTIONS 100
+/* Secure stop update interval is 60 seconds (one minute) per EME W3C Editor's Draft 13 December 2019 */
+#define DRM_SECURESTOP_UPDATE_INTERVAL  60
+#define DRM_SECURESTOP_MAX_CB_SSKB      1024
+
+typedef struct __tag_DRM_SECURESTOP_MESSAGE
+{
+    DRM_ID      idSession;
+    DRM_ID      idPublisher;
+    DRM_DWORD   dwStartTime;
+    DRM_DWORD   dwUpdateTime;
+    DRM_BOOL    fStopped;
+    DRM_BOOL    fSuspended;
+    DRM_BOOL    fLocked;
+} DRM_SECURESTOP_MESSAGE;
+
+#define DRM_SECURESTOP_MESSAGE_EMPTY { DRM_ID_EMPTY, DRM_ID_EMPTY, 0, 0, FALSE, FALSE, FALSE }
+
+typedef struct __tag_DRM_SECURESTOP_DECRYPTOR
+{
+    DRM_CIPHER_CONTEXT                    *pCipherContext;
+    struct __tag_DRM_SECURESTOP_DECRYPTOR *pNext;
+} DRM_SECURESTOP_DECRYPTOR;
+
+typedef struct __tag_DRM_SECURESTOP_SESSION
+{
+    DRM_SECURESTOP_MESSAGE    oMessage;
+    DRM_DWORD                 cidLicenses;
+    DRM_LID                  *pidLicenses;
+    DRM_SECURESTOP_DECRYPTOR *pDecryptors;
+} DRM_SECURESTOP_SESSION;
+
+#define DRM_SECURESTOP_SESSION_EMPTY { DRM_SECURESTOP_MESSAGE_EMPTY, 0, NULL, NULL }
+
+typedef struct __tag_DRM_SECURESTOP_TRANSACTION
+{
+    DRM_ID   idTransaction;
+    DRM_ID   idPublisher;
+    DRM_BYTE rgbKey[DRM_AES_KEYSIZE_128];
+} DRM_SECURESTOP_TRANSACTION;
+
+#define DRM_SECURESTOP_TRANSACTION_EMPTY { DRM_ID_EMPTY, DRM_ID_EMPTY, {0} }
+
+typedef struct __tag_DRM_SECURESTOP_DATA
+{
+    DRM_ID                     idEnvironment;
+    DRM_DWORD                  dwGenerationID;
+    DRM_DWORD                  cMessages;
+    DRM_SECURESTOP_MESSAGE     rgMessages[DRM_SECURESTOP_MAX_MESSAGES];
+    DRM_DWORD                  cTransactions;
+    DRM_SECURESTOP_TRANSACTION rgTransactions[DRM_SECURESTOP_MAX_TRANSACTIONS];
+} DRM_SECURESTOP_DATA;
+
+typedef struct __tag_DRM_SECURESTOP_DATA2
+{
+    DRM_SECURESTOP_DATA         oData1;
+    DRM_DWORD                   cbSSKB;
+    DRM_BYTE                    rgbSSKB[ DRM_SECURESTOP_MAX_CB_SSKB ];
+} DRM_SECURESTOP_DATA2;
+
+#define DRM_SECURESTOP_DATA_EMPTY { DRM_ID_EMPTY, 0, 0, { DRM_SECURESTOP_MESSAGE_EMPTY }, 0, { DRM_SECURESTOP_TRANSACTION_EMPTY } }
+#define DRM_SECURESTOP_DATA2_EMPTY { DRM_SECURESTOP_DATA_EMPTY, 0, { 0 } }
+
+typedef struct __tag_DRM_SECURESTOP_CONTEXT
+{
+    DRM_DWORD              cSessions;
+    DRM_SECURESTOP_SESSION rgSessions[DRM_SECURESTOP_MAX_MESSAGES];
+} DRM_SECURESTOP_CONTEXT;
+
+#define DRM_SECURESTOP_CONTEXT_EMPTY { 0, { DRM_SECURESTOP_SESSION_EMPTY } }
+
+EXIT_PK_NAMESPACE;
+
+#endif /* _DRMSECURESTOPTYPES_H_ */
+
diff --git a/prebuilt-v4.4/noarch/include/drmsecurestore.h b/prebuilt-v4.4/noarch/include/drmsecurestore.h
new file mode 100644
index 0000000..c38c207
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmsecurestore.h
@@ -0,0 +1,177 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __DRMSECURESTORE_H__
+#define __DRMSECURESTORE_H__
+
+#include <drmsecurestoretypes.h>
+#include <drmcallbacks.h>
+
+ENTER_PK_NAMESPACE;
+
+typedef enum _tag_EnumModeSST
+{
+    eSSTEnumNone = 0,     /* no secure store entries found */
+    eSSTEnumFiltered,     /* enum for secure store entries matching given ID */
+    eSSTEnumNatural       /* enum all secure store entries */
+} _EnumModeSST;
+
+typedef struct _tag_DRM_SECSTOREENUM_CONTEXT
+{
+    DRM_DST_ENUM_CONTEXT      oDstEnumContext;
+    DRM_DST_NAMESPACE_CONTEXT oNsContext;
+    DRM_DST_SLOT_CONTEXT      oSlotContext;
+    DRM_BOOL                  fInited;
+    _EnumModeSST              eMode;
+    eDRM_SECURE_STORE_TYPE    eType;
+    DRM_BOOL                  fCurrIsValid;
+    DRM_KID                   oCurrKID;
+    DRM_LID                   oCurrLID;
+    DRM_DST                  *pDatastore;
+} DRM_SECSTOREENUM_CONTEXT;
+
+
+/* Flags for DRM_SST_OpenKeyTokens */
+#define DRM_SECURE_STORE_CREATE_NEW             0x1
+#define DRM_SECURE_STORE_OPEN_ALWAYS            0x2
+#define DRM_SECURE_STORE_OPEN_EXISTING          0x4
+
+#define DRM_SECURE_STORE_VALID_FLAGS    (DRM_SECURE_STORE_CREATE_NEW | DRM_SECURE_STORE_OPEN_ALWAYS | DRM_SECURE_STORE_OPEN_EXISTING)
+
+DRM_API DRM_RESULT DRM_CALL DRM_SST_LoadKeyTokens(
+    __inout    DRM_SECSTORE_CONTEXT   *pcontextSST,
+    __in       DRM_DWORD               dwFlags,
+    __in       DRM_DST                *pDatastore );
+
+DRM_API DRM_RESULT DRM_CALL DRM_SST_OpenKeyTokens(
+    __inout                                      DRM_SECSTORE_CONTEXT   *pcontextSST,
+    __in                                   const DRM_ID                 *pKey1,
+    __in_opt                               const DRM_ID                 *pKey2,
+    __in_bcount_opt( OEM_SHA1_DIGEST_LEN ) const DRM_BYTE                rgbPassword [ OEM_SHA1_DIGEST_LEN ],
+    __in                                         DRM_DWORD               dwFlags,
+    __in                                         eDRM_SECURE_STORE_TYPE  eType,
+    __in                                         DRM_DST                *pDatastore );
+
+DRM_API DRM_RESULT DRM_CALL DRM_SST_GetTokenValue(
+    __in       DRM_SECSTORE_CONTEXT *pcontextSST,
+    __in const DRM_CONST_STRING     *pdstrAttribute,
+    __out      TOKEN                *pToken );
+
+DRM_API DRM_RESULT DRM_CALL DRM_SST_SetTokenValue(
+    __in       DRM_SECSTORE_CONTEXT *pcontextSST,
+    __in const DRM_CONST_STRING     *pdstrAttribute,
+    __in const TOKEN                *pToken );
+
+DRM_API DRM_RESULT DRM_CALL DRM_SST_SetExplicitResolutionTokenValue(
+    __in       DRM_SECSTORE_CONTEXT *pcontextSST,
+    __in const DRM_CONST_STRING     *pdstrAttribute,
+    __in const TOKEN                *pToken,
+    __in       DRM_DWORD             dwFlags );
+
+DRM_API DRM_RESULT DRM_CALL DRM_SST_CloseKey(
+    __in           DRM_SECSTORE_CONTEXT *pcontextSST,
+    __in           DRM_DST              *pDatastore,
+    __in_opt       DRMPFNPOLICYCALLBACK  pfnMergeCallback,
+    __in_opt const DRM_VOID             *pvCallbackData );
+
+DRM_API DRM_RESULT DRM_CALL DRM_SST_OpenAndLockSlot(
+    __in                                     DRM_DST                *f_pDatastore,
+    __in                                     eDRM_SECURE_STORE_TYPE  f_eType,
+    __in                               const DRM_ID                 *f_pKey1,
+    __in_opt                           const DRM_ID                 *f_pKey2,
+    __in_bcount( OEM_SHA1_DIGEST_LEN ) const DRM_BYTE                f_rgbPassword[ OEM_SHA1_DIGEST_LEN ],
+    __in                                     DRM_DWORD               f_dwFlags,
+    __out                                    DRM_SECSTORE_CONTEXT   *f_pcontextSST,
+    __inout_opt                              DRM_DWORD              *f_pcbData );
+
+DRM_API DRM_RESULT DRM_CALL DRM_SST_GetLockedData(
+    __in                           DRM_SECSTORE_CONTEXT   *f_pcontextSST,
+    __out_bcount_opt( *f_pcbData ) DRM_BYTE               *f_pbData,
+    __inout                        DRM_DWORD              *f_pcbData );
+
+DRM_API DRM_RESULT DRM_CALL DRM_SST_SetLockedData(
+    __in                          DRM_SECSTORE_CONTEXT   *f_pcontextSST,
+    __in                          DRM_DWORD               f_cbData,
+    __in_bcount( f_cbData ) const DRM_BYTE               *f_pbData );
+
+DRM_API DRM_RESULT DRM_CALL DRM_SST_CloseLockedSlot(
+    __in  DRM_SECSTORE_CONTEXT *f_pcontextSST );
+
+DRM_API DRM_RESULT DRM_CALL DRM_SST_GetData(
+    __in                                     DRM_SECSTORE_CONTEXT   *f_pcontextSST,
+    __in                               const DRM_ID                 *f_pKey1,
+    __in_opt                           const DRM_ID                 *f_pKey2,
+    __in_bcount( OEM_SHA1_DIGEST_LEN ) const DRM_BYTE                f_rgbPassword[ OEM_SHA1_DIGEST_LEN ],
+    __in                                     eDRM_SECURE_STORE_TYPE  f_eType,
+    __in                                     DRM_DST                *f_pDatastore,
+    __out_bcount_opt( *f_pcbData )           DRM_BYTE               *f_pbData,
+    __inout                                  DRM_DWORD              *f_pcbData );
+
+DRM_API DRM_RESULT DRM_CALL DRM_SST_SetData(
+    __in                                     DRM_SECSTORE_CONTEXT   *f_pcontextSST,
+    __in                               const DRM_ID                 *f_pKey1,
+    __in_opt                           const DRM_ID                 *f_pKey2,
+    __in_bcount( OEM_SHA1_DIGEST_LEN ) const DRM_BYTE                f_rgbPassword[ OEM_SHA1_DIGEST_LEN ],
+    __in                                     eDRM_SECURE_STORE_TYPE  f_eType,
+    __in                                     DRM_DST                *f_pDatastore,
+    __in_bcount( f_cbData )            const DRM_BYTE               *f_pbData,
+    __in                                     DRM_DWORD               f_cbData );
+
+
+/*
+** Delete an entry from the secure store.  Be careful when this happens -- it could open up the system for
+** replay attacks
+*/
+DRM_API DRM_RESULT DRM_CALL DRM_SST_DeleteKey(
+    __in           DRM_SECSTORE_CONTEXT   *f_pcontextSST,
+    __in           eDRM_SECURE_STORE_TYPE  f_typeSST,
+    __in     const DRM_ID                 *f_pid1,
+    __in_opt const DRM_ID                 *f_pid2,
+    __in           DRM_DST                *f_pDatastore );
+
+DRM_API DRM_RESULT DRM_CALL DRM_SST_GetAllData(
+    __in                                                        DRM_SECSTORE_CONTEXT *pcontextSST,
+    __out_bcount_opt( *pcbData )                                DRM_BYTE             *pbData,
+    __inout _Post_satisfies_( *pcbData <= _Old_( *pcbData ) )   DRM_DWORD            *pcbData );
+
+/*
+** The enumeration APIs work on 2 keys or IDs.  When opening an enumerator the caller should pass in key1 (the first key used
+** calls to DRM_SST_SetData and DRM_SST_OpenKeyTokens).  All entries with this value as the first key will be listed in the
+** enumeration.  On calls to DRM_SST_EnumNext the value of key2 will be returned so that the caller can use the combination of
+** key1 and key2 to open a unique SST entry.
+** If the caller does not specify key1, then all values are returned and both key1 and key2 can be obtained from DRM_SST_EnumNext.
+*/
+
+DRM_API DRM_RESULT DRM_CALL DRM_SST_OpenEnumerator(
+    __in           eDRM_SECURE_STORE_TYPE    eType,
+    __in_opt const DRM_ID                   *pKey1,
+    __out          DRM_SECSTOREENUM_CONTEXT *pcontextSSTEnum,
+    __in           DRM_DST                  *pDatastore,
+    __in           DRM_BOOL                  fExclusiveLock );
+
+DRM_API DRM_RESULT DRM_CALL DRM_SST_EnumNext(
+    __in                DRM_SECSTOREENUM_CONTEXT *pcontextSSTEnum,
+    __out_ecount_opt(1) DRM_ID                   *pKey1,
+    __out_ecount_opt(1) DRM_ID                   *pKey2,
+    __out_ecount(1)     DRM_DWORD                *pcbData );
+
+DRM_API DRM_RESULT DRM_CALL DRM_SST_EnumLoadCurrent(
+    __in                                     DRM_SECSTOREENUM_CONTEXT *pcontextSSTEnum,
+    __inout                                  DRM_SECSTORE_CONTEXT     *pcontextSST,
+    __in_bcount( OEM_SHA1_DIGEST_LEN ) const DRM_BYTE                  rgbPassword[ OEM_SHA1_DIGEST_LEN ],
+    __out                                    DRM_ID                   *pKey1,
+    __out_opt                                DRM_ID                   *pKey2,
+    __out                                    DRM_DWORD                *pcbData );
+
+DRM_API DRM_RESULT DRM_CALL DRM_SST_EnumDeleteCurrent(
+    __in       DRM_SECSTOREENUM_CONTEXT *pcontextSSTEnum,
+    __inout    DRM_SECSTORE_CONTEXT     *pcontextSST );
+
+EXIT_PK_NAMESPACE;
+
+#endif /* __DRMSECURESTORE_H__ */
diff --git a/prebuilt-v4.4/noarch/include/drmsecurestoretypes.h b/prebuilt-v4.4/noarch/include/drmsecurestoretypes.h
new file mode 100644
index 0000000..ea42d9b
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmsecurestoretypes.h
@@ -0,0 +1,140 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __DRMSECURESTORETYPES_H__
+#define __DRMSECURESTORETYPES_H__
+
+#include <drmtoken.h>
+#include <drmdatastoretypes.h>
+#include <drmpragmas.h>
+#include <oemsha1.h>
+
+ENTER_PK_NAMESPACE;
+
+#define DRM_SEC_STORE_MAX_SLOT_SIZE       (DRM_DWORD)( 1024 + 2 * sizeof(DRM_DWORD) + OEM_SHA1_DIGEST_LEN )
+#define DRM_MAX_ATTRIBUTES_PER_SST_KEY    25
+#define DRM_MAX_ATTRIBUTE_STRING_LENGTH   25
+
+/*
+    Secure store API users.  Please note that there are 3 modes these APIs open the secure store in.
+    The standard DRM_SST_OpenKeyTokens API will open and cache a secure store entry.  This data will
+    be flushed to disk on a call to DRM_SST_CloseKey.  No file I/O is done in the calls to
+    DRM_SST_GetTokenValue and DRM_SST_SetTokenValue in between.
+
+    Using the enumerator APIs requries that the DST context the enum is given be kept open the whole
+    time.
+
+    And finally the DRM_SST_GetData & DRM_SST_SetData are direct read/write tunnels to the secure data in
+    the secure store.  The secure store opens and closes the DST during this call so no caching in on.
+    If the Token APIs are too restrictive going directly to these raw read/write may be the best option; but these
+    should be used with caution.
+*/
+
+
+typedef enum
+{
+    SECURE_STORE_UNDEFINED_DATA           = 0x0,    /* Added for a PC client */
+    SECURE_STORE_LICENSE_DATA             = 0x1,
+    SECURE_STORE_GLOBAL_DATA              = 0x2,
+    SECURE_STORE_REVOCATION_DATA          = 0x3,
+    SECURE_STORE_METERING_DATA            = 0x4,
+    SECURE_STORE_RESERVED_5               = 0x5,    /* Reserved - Not Supported. */
+    SECURE_STORE_DEVICE_REGISTRATION_DATA = 0x6,
+    SECURE_STORE_CACHED_BLOB_DATA         = 0x7,
+    SECURE_STORE_TRANSIENT_DATA           = 0x8,
+    SECURE_STORE_SECURE_STOP_DATA         = 0x9,
+} eDRM_SECURE_STORE_TYPE;
+
+#define DRM_SECURE_STORE_NUM_CHILD_NODES 0x10
+
+/* In the slot meta data if the high bit is set it is raw data.  Otherwise it is TOKEN data */
+#define DRM_SST_RAW_DATA                ((DRM_DWORD)(0x80000000))
+#define DRM_SST_SLOT_SIZE_MASK          ((DRM_DWORD)(0x3FFF0000))
+#define DRM_SST_SLOT_SIZE_VALID_MASK    ((DRM_DWORD)(0x40000000))
+#define DRM_SST_DEVREG_PREALLOCATE_SIZE ((DRM_DWORD)30000)
+#define DRM_SST_PREALLOCATE_SIZE        ((DRM_DWORD)500)
+#define DRM_SST_SLOT_DATA_MASK          ((DRM_DWORD)(0x7FFFFF00))
+#define DRM_SST_SLOT_VERSION_MASK       ((DRM_DWORD)(0x0000FF00))
+#define DRM_SST_SLOT_VERSION            ((DRM_DWORD)(0x00000100))
+
+#define DRM_SST_SLOT_V0_HASH_OFFSET  sizeof(DRM_DWORD)
+#define DRM_SST_SLOT_V0_DATA_OFFSET (DRM_SST_SLOT_V0_HASH_OFFSET + OEM_SHA1_DIGEST_LEN)
+#define DRM_SST_SLOT_V0_HEADER_SIZE  DRM_SST_SLOT_V0_DATA_OFFSET
+
+#define DRM_SST_SLOT_METADATA_SIZE     sizeof(DRM_DWORD)
+#define DRM_SST_SLOT_SIZEDATA_SIZE     sizeof(DRM_DWORD)
+#define DRM_SST_SLOT_HASH_OFFSET  DRM_SST_SLOT_METADATA_SIZE + DRM_SST_SLOT_SIZEDATA_SIZE
+#define DRM_SST_SLOT_DATA_OFFSET (DRM_SST_SLOT_HASH_OFFSET + OEM_SHA1_DIGEST_LEN)
+#define DRM_SST_SLOT_HEADER_SIZE  DRM_SST_SLOT_DATA_OFFSET
+
+#define DRM_SST_SET_SLOT_METADATA( dwMetaData ) DRM_DO {                \
+    dwMetaData &= ~DRM_SST_SLOT_DATA_MASK;                              \
+    dwMetaData |= DRM_SST_SLOT_VERSION | DRM_SST_SLOT_SIZE_VALID_MASK;  \
+} DRM_WHILE_FALSE
+
+#define DRM_SST_GET_SLOT_SIZE_FROM_METADATA( cbSlotData, dwMetaData ) cbSlotData = (dwMetaData & DRM_SST_SLOT_SIZE_MASK) >> 16;
+
+/* These are methods to resolve conflicts when data is written to the secure store but some other
+** instance already wrote their changes to the secure store.
+*/
+#define DRM_TOKEN_RESOLVE_BITMASK    7
+#define DRM_TOKEN_RESOLVE_CALLBACK   0 /* The supplied callback function will resolve the conflict */
+#define DRM_TOKEN_RESOLVE_FIRST_WINS 1 /* The first data to be Committed will be persisted */
+#define DRM_TOKEN_RESOLVE_LAST_WINS  2 /* The last data to be Commited will be persisted */
+#define DRM_TOKEN_RESOLVE_DELTA      3 /* Available for TOKEN_LONG datatype or other numeric types only */
+
+#define DRM_TOKEN_FLAG_DIRTY         16 /* The token has been changed since being loaded */
+
+typedef struct __tagCachedAttribute
+{
+    PERSISTEDTOKEN    TokenDelta;
+    DRM_CONST_STRING  dstrAttribute;
+
+    /*
+    ** First 2 bits of dwFlags is for DRM_TOKEN_RESOLVE_*
+    */
+    DRM_DWORD         dwFlags;
+
+    DRM_BYTE         *pTokenValue;  /* Never assume this is aligned before accessing it!!*/
+} CachedAttribute;
+
+typedef struct __tagSEC_STORE_CONTEXT
+{
+    DRM_DST_NAMESPACE_CONTEXT oNsContext;
+    DRM_DST_SLOT_CONTEXT      oSlotContext;
+
+    CachedAttribute rgAttributes [DRM_MAX_ATTRIBUTES_PER_SST_KEY];
+    DRM_BYTE        rgbSlotData  [DRM_SEC_STORE_MAX_SLOT_SIZE];
+    DRM_BYTE        rgbPassword  [OEM_SHA1_DIGEST_LEN];
+
+    DRM_DST_KEY     rgbKey1;
+    DRM_DST_KEY     rgbKey2;
+
+    const DRM_DST_NAMESPACE *pNamespaceId;
+    eDRM_SECURE_STORE_TYPE   eType;
+
+    DRM_WORD wNumAttributes;
+    DRM_WORD wNumOriginalAttributes;
+    DRM_DWORD cbSlotData;
+    DRM_DWORD cbSlot;
+    DRM_BOOL fInited;
+    DRM_DST  *pDatastore;
+    DRM_BOOL fOpened;
+    DRM_BOOL fLocked;
+    DRM_BOOL fDirty;
+    DRM_DWORD dwSlotVersion;
+    DRM_BOOL  fNoPassword;
+    DRM_DST_SLOT_HINT slotHint;
+} DRM_SECSTORE_CONTEXT;
+
+#define DRM_SECSTORE_CONTEXT_EMPTY { {0}, {0}, {0}, {0}, {0}, DRM_ID_EMPTY, DRM_ID_EMPTY, NULL, SECURE_STORE_UNDEFINED_DATA, 0, 0, 0, 0, FALSE, NULL, FALSE, FALSE, FALSE, 0, FALSE, {0} }
+
+EXIT_PK_NAMESPACE;
+
+#endif /* __DRMSECURESTORETYPES_H__ */
+
diff --git a/prebuilt-v4.4/noarch/include/drmsecuretime.h b/prebuilt-v4.4/noarch/include/drmsecuretime.h
new file mode 100644
index 0000000..16269b6
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmsecuretime.h
@@ -0,0 +1,42 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __DRMSECURETIME_H__
+#define __DRMSECURETIME_H__
+
+#include <drmsecuretimetypes.h>
+#include <drmmanagertypes.h>
+#include <drmmodulesupport.h>
+
+ENTER_PK_NAMESPACE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_SECURETIME_GenerateChallenge(
+    __inout                                         DRM_SECURECORE_CONTEXT      *f_pSecureCoreCtx,
+    __out                                           DRM_DWORD                   *f_pcbChallenge,
+    __deref_out_bcount( *f_pcbChallenge )           DRM_BYTE                   **f_ppbChallenge );
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_SECURETIME_ProcessResponse(
+    __inout                                         DRM_SECURECORE_CONTEXT      *f_pSecureCoreCtx,
+    __in                                            DRM_DWORD                    f_cbRevocationBuffer,
+    __inout_bcount_opt( f_cbRevocationBuffer )      DRM_BYTE                    *f_pbRevocationBuffer,
+    __inout                                         DRM_REVOCATIONSTORE_CONTEXT *f_pRevContext,
+    __inout_opt                                     DRM_SECSTORE_CONTEXT        *f_pSecStoreGlobalContext,
+    __inout_opt                                     DRM_DST                     *f_pDatastoreHDS,
+    __inout                                         DRM_BOOL                    *f_pfClockSet,
+    __inout                                         DRM_LICEVAL_CONTEXT         *f_pLicEvalContext,
+    __in                                            DRM_DWORD                    f_cbResponse,
+    __in_bcount( f_cbResponse )               const DRM_BYTE                    *f_pbResponse );
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_SECURETIME_GetValue(
+    __inout                                         DRM_SECURECORE_CONTEXT      *f_pSecureCoreCtx,
+    __out                                           DRMFILETIME                 *f_pftSystemTime,
+    __out                                           DRM_SECURETIME_CLOCK_TYPE   *f_peClockType );
+
+EXIT_PK_NAMESPACE;
+
+#endif /*__DRMSECURETIME_H__ */
diff --git a/prebuilt-v4.4/noarch/include/drmsecuretimeconstants.h b/prebuilt-v4.4/noarch/include/drmsecuretimeconstants.h
new file mode 100644
index 0000000..8319ec3
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmsecuretimeconstants.h
@@ -0,0 +1,30 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __DRMSECURETIMECONSTANTS_H__
+#define __DRMSECURETIMECONSTANTS_H__
+
+#include <drmtypes.h>
+
+ENTER_PK_NAMESPACE;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dstrSECURETIME;
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dstrTYPE;
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dstrDATA;
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dstrCHALLENGE;
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dstrRESPONSE;
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dstrSIGNATURE;
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dstrVALUE;
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dstrCERTIFICATECHAIN;
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dstrERROR;
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dstrHttpSecureTimeServerUrl;
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dstrHttpsSecureTimeServerUrl;
+
+EXIT_PK_NAMESPACE;
+
+#endif /* __DRMSECURETIMECONSTANTS_H__ */
diff --git a/prebuilt-v4.4/noarch/include/drmsecuretimetypes.h b/prebuilt-v4.4/noarch/include/drmsecuretimetypes.h
new file mode 100644
index 0000000..18b91df
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmsecuretimetypes.h
@@ -0,0 +1,23 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __DRMSECURETIMETYPES_H__
+#define __DRMSECURETIMETYPES_H__
+
+ENTER_PK_NAMESPACE;
+
+typedef enum _DRM_SECURETIME_CLOCK_TYPE
+{
+    DRM_SECURETIME_CLOCK_TYPE_INVALID = 0,
+    DRM_SECURETIME_CLOCK_TYPE_TEE     = 1,    /* SecureTime - TEE clock           */
+    DRM_SECURETIME_CLOCK_TYPE_UM      = 2,    /* SecureTime - User-mode clock     */
+} DRM_SECURETIME_CLOCK_TYPE;
+
+EXIT_PK_NAMESPACE;
+
+#endif /*__DRMSECURETIMETYPES_H__ */
diff --git a/prebuilt-v4.4/noarch/include/drmsoapxmlconstants.h b/prebuilt-v4.4/noarch/include/drmsoapxmlconstants.h
new file mode 100644
index 0000000..88b85ef
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmsoapxmlconstants.h
@@ -0,0 +1,71 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __DRM_SOAP_XML_CONSTANTS_H
+#define __DRM_SOAP_XML_CONSTANTS_H
+
+ENTER_PK_NAMESPACE;
+
+/*
+** -------------------------------------------------------------------
+** XML strings used in the parsing of status code from server response
+** -------------------------------------------------------------------
+*/
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrSOAPExceptionRootPath;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrSOAPExceptionSignaturePath;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrSOAPExceptionCustomDataPath;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrSOAPStatusCodePath;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrSOAPGARDCustomDataPath;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrSOAPGARDRedirectUrlPath;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrSOAPGARDServiceIdPath;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrSOAPGARDAccountIdPath;
+
+
+/*
+** -----------------------------------------------------
+** XML strings used in the construction of SOAP envelope
+** -----------------------------------------------------
+*/
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrXMLRootTag;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrSOAPEnvelopeTag;
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrSOAPEnvelopeAbbrevTag;
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrSOAPBodyTag;
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrSOAPBodyAbbrevTag;
+
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrSOAPEnvelopeAttrib1Name;
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrSOAPEnvelopeAttrib1Value;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrSOAPEnvelopeAttrib2Name;
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrSOAPEnvelopeAttrib2Value;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrSOAPEnvelopeAttrib3Name;
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrSOAPEnvelopeAttrib3Value;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrSOAPPreserveSpaceAttribName;
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrSOAPPreserveSpaceAttribValue;
+
+/*
+** -------------------------------------------------------
+** XML strings used in the construction of ClientInfo node
+** -------------------------------------------------------
+*/
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrReqTagClientInfo;
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrReqTagClientVersion;
+
+EXIT_PK_NAMESPACE;
+
+#endif /* __DRM_SOAP_XML_CONSTANTS_H */
diff --git a/prebuilt-v4.4/noarch/include/drmsoapxmlutility.h b/prebuilt-v4.4/noarch/include/drmsoapxmlutility.h
new file mode 100644
index 0000000..b35b575
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmsoapxmlutility.h
@@ -0,0 +1,158 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __DRM_SOAP_XML_UTILITY_H
+#define __DRM_SOAP_XML_UTILITY_H
+
+#include <drmxmlbuildera.h>
+#include <drmxmlsig.h>
+#include <drmmanager.h>
+#include <drmsecurecoretypes.h>
+
+ENTER_PK_NAMESPACE;
+
+/*
+** Type of data element to be retrieved from the server response.
+** GARD stands for Get Additional Response Data.
+*/
+enum
+{
+    /* Data type code for custom data. */
+    DRM_GARD_CUSTOM_DATA  = 1,
+
+    /* Data type code for redirected URL. */
+    DRM_GARD_REDIRECT_URL = 2,
+
+    /* Data type code for service ID. */
+    DRM_GARD_SERVICE_ID   = 3,
+
+    /* Data type code for account ID. */
+    DRM_GARD_ACCOUNT_ID   = 4
+};
+
+/*
+** ---------------------------------------
+** SOAP XML utility API functions
+** ---------------------------------------
+*/
+DRM_API DRM_RESULT DRM_CALL DRM_SOAPXML_EncodeData(
+    __in_ecount( f_cchData )         const DRM_CHAR   *f_pchData,
+    __in                                   DRM_DWORD   f_cchData,
+    __out_ecount_opt( *f_pcchEncodedData ) DRM_CHAR   *f_pchEncodedData,
+    __out                                  DRM_DWORD  *f_pcchEncodedData );
+
+DRM_API DRM_RESULT DRM_CALL DRM_SOAPXML_DecodeData(
+    __in_ecount( f_cchData )               const DRM_CHAR   *f_pchData,
+    __in                                         DRM_DWORD   f_cchData,
+    __out_ecount_opt( *f_pcchDecodedData )       DRM_CHAR   *f_pchDecodedData,
+    __out                                        DRM_DWORD  *f_pcchDecodedData );
+
+DRM_API DRM_RESULT DRM_CALL DRM_SOAPXML_PadANSIString(
+    __inout DRM_ANSI_STRING  *f_pdastrIn,
+    __in    DRM_DWORD         f_cchPad );
+
+DRM_API DRM_BOOL DRM_CALL DRM_SOAPXML_IsBlankGUID(
+    __in const DRM_GUID *f_poGUID );
+
+DRM_API DRM_DWORD DRM_CALL DRM_SOAPXML_CalcDWORDCharCount(
+    __in DRM_DWORD f_dwNumber );
+
+DRM_API DRM_DWORD DRM_CALL DRM_SOAPXML_CalcSOAPHeaderCharCount( DRM_VOID );
+
+DRM_API DRM_RESULT DRM_CALL DRM_SOAPXML_SkipSOAPHeaders(
+    __in_ecount( f_pdasstrResponse->m_ich + f_pdasstrResponse->m_cch ) const DRM_CHAR         *f_pszResponse,
+    __inout                                                                  DRM_SUBSTRING    *f_pdasstrResponse );
+
+DRM_API DRM_RESULT DRM_CALL DRM_SOAPXML_PrependXMLRoot(
+    __inout DRM_ANSI_STRING *f_pdastrXML );
+
+DRM_API DRM_RESULT DRM_CALL DRM_SOAPXML_BuildSOAPHeaderXML(
+    __inout  _XMBContextA *f_poXMLContext,
+    __in     DRM_DWORD     f_cbXMLContext );
+
+DRM_API DRM_RESULT DRM_CALL DRM_SOAPXML_InitXMLKey(
+    __in_opt DRM_VOID             *f_poOEMContext,
+    __out    DRM_XML_KEY          *f_poXMLKey,
+    __inout  DRM_CRYPTO_CONTEXT   *f_pCryptoCtx );
+
+DRM_API DRM_RESULT DRM_CALL DRM_SOAPXML_EncryptDataWithXMLKey(
+    __inout     DRM_XML_KEY             *f_poXMLKey,
+    __inout     DRM_ANSI_CONST_STRING   *f_pdastrData,
+    __inout     DRM_CRYPTO_CONTEXT      *f_pCryptoCtx );
+
+DRM_API DRM_RESULT DRM_CALL DRM_SOAPXML_GetDeviceCert(
+    __inout                               DRM_SECURECORE_CONTEXT    *f_pSecureCore,
+    __in                                  DRM_BOOL                   f_fB64Encoded,
+    __out_ecount_opt( *f_pcchDeviceCert ) DRM_CHAR                  *f_pchDeviceCert,
+    __inout_opt                           DRM_DWORD                 *f_pcchDeviceCert,
+    __out_ecount_opt( 1 )                 PUBKEY_P256               *f_poECC256SignPubKey );
+
+DRM_API DRM_RESULT DRM_CALL DRM_SOAPXML_PrepareXMLContext(
+    __in_bcount( f_cbXMLContext )          DRM_BYTE        *f_pbXMLContext,
+    __in                                   DRM_DWORD        f_cbXMLContext,
+    __deref_out_bcount( *f_pcbXMLContext ) _XMBContextA   **f_ppoXMLContext,
+    __out                                  DRM_DWORD       *f_pcbXMLContext );
+
+DRM_API DRM_RESULT DRM_CALL DRM_SOAPXML_ParseCustomDataForProtocol(
+    __in_bcount( f_cbResponse )     const DRM_BYTE  *f_pbResponse,
+    __in                                  DRM_DWORD  f_cbResponse,
+    __in                                  DRM_DWORD  f_dwProtocolType,
+    __out_ecount_opt( *f_pcchCustomData ) DRM_CHAR  *f_pchCustomData,
+    __inout_opt                           DRM_DWORD *f_pcchCustomData );
+
+DRM_API DRM_RESULT DRM_CALL DRM_SOAPXML_ValidateProtocolSignature(
+    __in_bcount( f_cbResponse )   const DRM_BYTE            *f_pbResponse,
+    __in                                DRM_DWORD            f_cbResponse,
+    __inout_bcount_opt( f_cbScratchBCertBuffer )
+                                        DRM_BYTE            *f_pbScratchBCertBuffer,
+    __in                          const DRM_DWORD            f_cbScratchBCertBuffer,
+    __in                                DRM_CRYPTO_CONTEXT  *f_pCryptoCtx,
+    __inout                             DRM_DWORD           *f_pdwProtocolType );
+
+DRM_API DRM_RESULT DRM_CALL DRM_SOAPXML_ParseStatusCodeAndChooseBest(
+    __in_bcount( f_cbResponse ) const DRM_BYTE    *f_pbResponse,
+    __in                              DRM_DWORD    f_cbResponse,
+    __in                              DRM_RESULT   f_drOriginal,
+    __out_opt                         DRM_RESULT  *f_pResult );
+
+DRM_API DRM_RESULT DRM_CALL DRM_SOAPXML_ParseStatusCode(
+    __in_bcount( f_cbResponse ) const DRM_BYTE   *f_pbResponse,
+    __in                              DRM_DWORD   f_cbResponse,
+    __out                             DRM_RESULT *f_pResult );
+
+DRM_API DRM_RESULT DRM_CALL DRM_SOAPXML_GetAdditionalResponseData(
+    __in_bcount( f_cbResponse )      const DRM_BYTE   *f_pbResponse,
+    __in                                   DRM_DWORD   f_cbResponse,
+    __in                                   DRM_DWORD   f_dwDataType,
+    __out_ecount_opt( *f_pcchDataString )  DRM_CHAR   *f_pchDataString,
+    __inout                                DRM_DWORD  *f_pcchDataString );
+
+DRM_API DRM_RESULT DRM_CALL DRM_SOAPXML_BuildClientInfo(
+    __inout                   _XMBContextA     *f_poXMLContext,
+    __in_opt                  DRM_CLIENT_INFO  *f_poClientInfo );
+
+DRM_API DRM_DWORD DRM_CALL DRM_SOAPXML_CalcClientInfo(
+    __in_opt           const DRM_CLIENT_INFO  *f_poClientInfo );
+
+enum DRM_SOAPXML_PROTOCOL_TYPE
+{
+    DRM_SOAPXML_PROTOCOL_UNKNOWN                   = 0x00,
+    DRM_SOAPXML_PROTOCOL_EXCEPTION                 = 0x01,
+    DRM_SOAPXML_PROTOCOL_DOMAIN_JOIN_RESPONSE      = 0x02,
+    DRM_SOAPXML_PROTOCOL_DOMAIN_LEAVE_RESPONSE     = 0x03,
+    DRM_SOAPXML_PROTOCOL_METERING_CERT_RESPONSE    = 0x04,
+    DRM_SOAPXML_PROTOCOL_METERING_DATA_RESPONSE    = 0x05,
+    DRM_SOAPXML_PROTOCOL_LIC_ACQ_RESPONSE          = 0x06,
+    DRM_SOAPXML_PROTOCOL_LIC_ACQ_ACK_RESPONSE      = 0x07,
+    DRM_SOAPXML_PROTOCOL_SECURE_STOP_RESPONSE      = 0x08,
+    DRM_SOAPXML_PROTOCOL_MAXIMUM_DEFINED           = 0x08
+};
+
+EXIT_PK_NAMESPACE;
+
+#endif /* __DRM_SOAP_XML_UTILITY_H */
diff --git a/prebuilt-v4.4/noarch/include/drmsstconstants.h b/prebuilt-v4.4/noarch/include/drmsstconstants.h
new file mode 100644
index 0000000..0805b2b
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmsstconstants.h
@@ -0,0 +1,23 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+
+#ifndef __DRMSSTCONSTANTS_H__
+#define __DRMSSTCONSTANTS_H__
+
+#include <drmtypes.h>
+#include <oemsha1.h>
+
+ENTER_PK_NAMESPACE;
+
+extern DRM_GLOBAL_CONST DRM_BYTE g_rgbSecStorePassword[ OEM_SHA1_DIGEST_LEN ];
+
+EXIT_PK_NAMESPACE;
+
+#endif      /* __DRMSSTCONSTANTS_H__ */
+
diff --git a/prebuilt-v4.4/noarch/include/drmstkalloc.h b/prebuilt-v4.4/noarch/include/drmstkalloc.h
new file mode 100644
index 0000000..ddef13a
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmstkalloc.h
@@ -0,0 +1,93 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __DRM_STACK_ALLOCATOR__
+#define __DRM_STACK_ALLOCATOR__
+
+#include <drmstkalloctypes.h>
+
+ENTER_PK_NAMESPACE;
+
+/*********************************************************************
+**
+**  Function:  DRM_STK_Free
+**
+**  Synopsis:  Free a buffer that was allocated using DRM_STK_Alloc.
+**
+**  Arguments:
+**     [pContext] -- Stack allcator context that was used to allocate the pbBuffer parameter
+**     [pbBuffer] -- Pointer returned from a call to DRM_STK_Alloc
+**
+**  Notes:  Pointers must be freed in LIFO order ( just like a stack ).
+**
+*********************************************************************/
+PREFAST_PUSH_DISABLE_EXPLAINED(__WARNING_COUNT_REQUIRED_FOR_VOIDPTR_BUFFER, "pbBuffer points into internal the internal buffer and its size is defined by *(pbBuffer-sizeof(DWORD))" )
+DRM_API DRM_RESULT DRM_CALL DRM_STK_Free(
+    __in DRM_STACK_ALLOCATOR_CONTEXT *pContext,
+    __in DRM_VOID                    *pbBuffer );
+PREFAST_POP
+
+#define SAFE_STK_FREE(pdsac,pv)              \
+    if (pv != NULL)                          \
+    {                                        \
+        (DRM_VOID)DRM_STK_Free (pdsac, pv);  \
+        pv = NULL;                           \
+    }
+
+DRM_API DRM_RESULT DRM_CALL DRM_STK_PreAlloc(
+    __in                           DRM_STACK_ALLOCATOR_CONTEXT   *pContext,
+    __out                          DRM_DWORD                     *pcbSize,
+    __deref_out_bcount( *pcbSize ) DRM_VOID                     **ppbBuffer );
+
+/*********************************************************************
+**
+**  Function:  DRM_STK_Alloc
+**
+**  Synopsis:  Allocates a buffer from a give stack context
+**
+**  Arguments:
+**     [pContext] -- Stack allocator context to allocate from
+**     [cbSize] -- Size of the buffer needed
+**     [ppbBuffer] -- Pointer to pointer to hold the new memory offset.
+**
+**  Notes:  Pointers must be freed in LIFO order ( just like a stack ).
+**
+*********************************************************************/
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_STK_Alloc(
+    __inout                      DRM_STACK_ALLOCATOR_CONTEXT *pContext,
+    __in                         DRM_DWORD                    cbSize,
+    __deref_out_bcount( cbSize ) DRM_VOID                   **ppbBuffer );
+
+/*********************************************************************
+**
+**  Function:  DRM_STK_Init
+**
+**  Synopsis:  Initializes stack with supplied buffer and size.
+**             It is kind of trivial, but frees user from
+**             knowledge about stack structure.
+**             Unless fForceInit is set, does not overwrite initialized
+**             stack.
+**  Arguments:
+**     [pContext] -- Stack allocator context to allocate from
+**     [pbBuffer] -- Pointer for the buffer for the stack
+**     [cbSize] --  Size of the buffer supplied
+**     [fForceInit] -- Ignores values in stack, always initializes.
+**
+**  Notes:  Pointers must be freed in LIFO order ( just like a stack ).
+**
+*********************************************************************/
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_STK_Init(
+    __inout                 DRM_STACK_ALLOCATOR_CONTEXT *pContext,
+    __in_bcount( cbSize)    DRM_BYTE                    *pbBuffer,
+    __in                    DRM_DWORD                    cbSize,
+    __in                    DRM_BOOL                     fForceInit );
+
+EXIT_PK_NAMESPACE;
+
+#endif /* __DRM_STACK_ALLOCATOR__ */
+
diff --git a/prebuilt-v4.4/noarch/include/drmstkalloctypes.h b/prebuilt-v4.4/noarch/include/drmstkalloctypes.h
new file mode 100644
index 0000000..dc29ef5
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmstkalloctypes.h
@@ -0,0 +1,30 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __DRM_STACK_ALLOCATORTYPES__
+#define __DRM_STACK_ALLOCATORTYPES__
+
+#include <drmtypes.h>
+
+ENTER_PK_NAMESPACE;
+
+typedef DRM_OBFUS_FIXED_ALIGN struct __tagDRM_STACK_ALLOCATOR_CONTEXT
+{
+    DRM_DWORD nStackTop;    /* position of stack top */
+    DRM_DWORD cbStack;      /* size of stack */
+DRM_OBFUS_PTR_TOP
+    DRM_DWORD *pdwStack; /* stack buffer in DRM_DWORDs */
+DRM_OBFUS_PTR_BTM
+    DRM_BOOL  fWasPreAlloc; /* used to signal that we PreAlloc, and Alloc shouldn't fill mem with 0xaa */
+DRM_OBFUS_FILL_BYTES(4)
+} DRM_STACK_ALLOCATOR_CONTEXT;
+
+EXIT_PK_NAMESPACE;
+
+#endif /* __DRM_STACK_ALLOCATORTYPES__ */
+
diff --git a/prebuilt-v4.4/noarch/include/drmstrsafe.h b/prebuilt-v4.4/noarch/include/drmstrsafe.h
new file mode 100644
index 0000000..24716f1
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmstrsafe.h
@@ -0,0 +1,106 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __DRMSTRSAFE_H__
+#define __DRMSTRSAFE_H__
+
+#include <drmtypes.h>
+
+ENTER_PK_NAMESPACE;
+
+#define DRM_STRSAFE_MAX_CCH 2147483647
+
+
+#define DRM_MAX_CCH_BASE2_DWORD_STRING      32
+#define DRM_MAX_CCH_BASE2_WORD_STRING       16
+#define DRM_MAX_CCH_BASE2_BYTE_STRING       8
+
+#define DRM_MAX_CCH_BASE10_DWORD_STRING     10
+#define DRM_MAX_CCH_BASE10_WORD_STRING      5
+#define DRM_MAX_CCH_BASE10_BYTE_STRING      3
+
+#define DRM_MAX_CCH_BASE16_DWORD_STRING     8
+#define DRM_MAX_CCH_BASE16_WORD_STRING      4
+#define DRM_MAX_CCH_BASE16_BYTE_STRING      2
+
+
+DRM_API DRM_RESULT DRM_CALL DRM_STR_StringCchLengthW(
+    _In_reads_or_z_( f_cchMax ) const DRM_WCHAR *f_pwsz,
+    __in                              DRM_DWORD  f_cchMax,
+    __out_opt                         DRM_DWORD *f_pcchLength );
+
+DRM_API DRM_RESULT DRM_CALL DRM_STR_StringCchLengthA(
+    __in_z              const DRM_CHAR  *f_psz,
+    __in                      DRM_DWORD  f_cchMax,
+    __out_opt                 DRM_DWORD *f_pcchLength);
+
+
+DRM_API DRM_RESULT DRM_CALL DRM_STR_StringCchCopyNW(
+    __out_ecount_z( f_cchDest )       DRM_WCHAR  *f_pwszDest,
+    __in                              DRM_DWORD   f_cchDest,
+    _In_reads_or_z_( f_cchSrc ) const DRM_WCHAR  *f_pwszSrc,
+    __in                              DRM_DWORD   f_cchSrc );
+
+DRM_API DRM_RESULT DRM_CALL DRM_STR_StringCchCopyNA(
+    __out_ecount_z( f_cchDest )          DRM_CHAR  *f_pszDest,
+    __in                                 DRM_DWORD  f_cchDest,
+    _In_reads_or_z_( f_cchToCopy ) const DRM_CHAR  *f_pszSrc,
+    __in                                 DRM_DWORD  f_cchToCopy );
+
+DRM_API DRM_RESULT DRM_CALL DRM_STR_StringCchCopyW(
+    __out_ecount_z( f_cchDest )        DRM_WCHAR  *f_pwszDest,
+    __in                               DRM_DWORD   f_cchDest,
+    _In_reads_or_z_( f_cchDest ) const DRM_WCHAR  *f_pwszSrc );
+
+DRM_API DRM_RESULT DRM_CALL DRM_STR_StringCchCopyA(
+    __out_ecount_z( f_cchDest )        DRM_CHAR *f_pszDest,
+    __in                               DRM_DWORD f_cchDest,
+    _In_reads_or_z_( f_cchDest ) const DRM_CHAR *f_pszSrc );
+
+DRM_API DRM_RESULT DRM_CALL DRM_STR_StringCchCatW(
+    __inout_ecount_z( f_cchDest ) DRM_WCHAR *f_pwszDest,
+    __in                          DRM_DWORD  f_cchDest,
+    __in_z                  const DRM_WCHAR *f_pwszSrc );
+
+DRM_API DRM_RESULT DRM_CALL DRM_STR_StringCchCatA(
+    __inout_ecount_z( f_cchDest ) DRM_CHAR  *f_pszDest,
+    __in                          DRM_DWORD  f_cchDest,
+    __in_z                  const DRM_CHAR  *f_pszSrc );
+
+DRM_API DRM_RESULT DRM_CALL DRM_STR_StringCchCatNW(
+    __inout_ecount_z( f_cchDest )        DRM_WCHAR *f_pwszDest,
+    __in                                 DRM_DWORD  f_cchDest,
+    __in_ecount( f_cchToAppend )   const DRM_WCHAR *f_pwszSrc,
+    __in                                 DRM_DWORD  f_cchToAppend );
+
+DRM_API DRM_RESULT DRM_CALL DRM_STR_StringCchCatNA(
+    __inout_ecount_z( f_cchDest )      DRM_CHAR  *f_pszDest,
+    __in                               DRM_DWORD  f_cchDest,
+    __in_ecount( f_cchToAppend ) const DRM_CHAR  *f_pszSrc,
+    __in                               DRM_DWORD  f_cchToAppend );
+
+DRM_API DRM_RESULT DRM_CALL DRM_STR_StringCchPrintfExW_1(
+    __out_ecount_z(f_cchDest)                DRM_WCHAR *f_pwszDest,
+    __in                                     DRM_DWORD  f_cchDest,
+    __deref_opt_out_ecount(*f_pcchRemaining) DRM_WCHAR**f_ppwszDestEnd,
+    __out_opt                                DRM_DWORD *f_pcchRemaining,
+    __in                                     DRM_DWORD  f_dwFlags,
+    __in_z __format_string             const DRM_WCHAR *f_pwszFormat,
+    __in                                     DRM_DWORD  f_dwValue );
+
+DRM_API DRM_RESULT DRM_CALL DRM_STR_StringCchToLower(
+    __inout_ecount_nz(f_cchToLower) DRM_WCHAR *f_prgwchToLower,
+    __in                            DRM_DWORD  f_cchToLower );
+
+DRM_API DRM_RESULT DRM_CALL DRM_STR_DstrToLower(
+    __inout    DRM_STRING       *f_pdstrToLower );
+
+EXIT_PK_NAMESPACE;
+
+#endif /* __DRMSTRSAFE_H__ */
+
diff --git a/prebuilt-v4.4/noarch/include/drmtee.h b/prebuilt-v4.4/noarch/include/drmtee.h
new file mode 100644
index 0000000..05fa3f0
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmtee.h
@@ -0,0 +1,266 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef _DRMTEE_H_
+#define _DRMTEE_H_ 1
+
+#include <drmteetypes.h>
+#include <oemteetypes.h>
+
+ENTER_PK_NAMESPACE;
+
+PREFAST_PUSH_DISABLE_EXPLAINED(__WARNING_NONCONST_PARAM_25004, "Out params can't be const")
+PREFAST_PUSH_DISABLE_EXPLAINED(__WARNING_NONCONST_BUFFER_PARAM_25033, "Out params can't be const")
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_TEE_BASE_AllocTEEContext(
+    __inout                     DRM_TEE_CONTEXT             **f_ppContext,
+    __in_opt              const DRM_TEE_BYTE_BLOB            *f_pApplicationInfo,
+    __out_opt                   DRM_TEE_BYTE_BLOB            *f_pSystemInfo ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API_VOID DRM_VOID DRM_CALL DRM_TEE_BASE_FreeTEEContext(
+    __inout                     DRM_TEE_CONTEXT             **f_ppContext ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_TEE_BASE_SignDataWithSecureStoreKey(
+    __inout                     DRM_TEE_CONTEXT              *f_pContext,
+    __in                  const DRM_TEE_BYTE_BLOB            *f_pPPKB,
+    __in                  const DRM_TEE_BYTE_BLOB            *f_pDataToSign,
+    __out                       DRM_TEE_BYTE_BLOB            *f_pSignature ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_TEE_BASE_CheckDeviceKeys(
+    __inout                     DRM_TEE_CONTEXT              *f_pContext,
+    __in                  const DRM_TEE_BYTE_BLOB            *f_pPPKB ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_TEE_BASE_GetDebugInformation(
+    __inout                     DRM_TEE_CONTEXT              *f_pContext,
+    __out                       DRM_DWORD                    *f_pdwLastHR,
+    __out                       DRM_TEE_BYTE_BLOB            *f_pLog ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_TEE_BASE_GenerateNonce(
+    __inout                     DRM_TEE_CONTEXT              *f_pContext,
+    __out                       DRM_TEE_BYTE_BLOB            *f_pNKB,
+    __out                       DRM_ID                       *f_pNonce ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_TEE_BASE_GetSystemTime(
+    __inout                     DRM_TEE_CONTEXT              *f_pContext,
+    __out                       DRM_UINT64                   *f_pui64SystemTime ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_TEE_BASE_GetFeatureInformation(
+    __inout               DRM_TEE_CONTEXT              *f_pContext,
+    __in            const DRM_TEE_BYTE_BLOB            *f_pPPKB,
+    __out                 DRM_TEE_BYTE_BLOB            *f_pTEExml ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_TEE_LPROV_GenerateDeviceKeys(
+    __inout                     DRM_TEE_CONTEXT              *f_pContext,
+    __in_tee_opt          const DRM_TEE_BYTE_BLOB            *f_pPrevPPKB,
+    __in_tee_opt          const DRM_TEE_BYTE_BLOB            *f_pCertificate,
+    __in_tee_opt          const DRM_TEE_BYTE_BLOB            *f_pOEMProtectedCertificatePrivateKeys,
+    __in                  const DRM_ID                       *f_pidApplication,
+    __out                       DRM_TEE_BYTE_BLOB            *f_pPPKB,
+    __out                       DRM_TEE_BYTE_BLOB            *f_pNewCertificate ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_TEE_RPROV_GenerateBootstrapChallenge(
+    __inout                     DRM_TEE_CONTEXT              *f_pContext,
+    __inout_tee_opt             DRM_TEE_BYTE_BLOB            *f_pRProvContext,
+    __out                       DRM_DWORD                    *f_pdwType,
+    __out                       DRM_DWORD                    *f_pdwStep,
+    __out                       DRM_DWORD                    *f_pdwAdditionalInfoNeeded,
+    __out                       DRM_TEE_BYTE_BLOB            *f_pChallenge ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_TEE_RPROV_ProcessBootstrapResponse(
+    __inout                     DRM_TEE_CONTEXT              *f_pContext,
+    __inout_tee_opt             DRM_TEE_BYTE_BLOB            *f_pRProvContext,
+    __in_tee_opt          const DRM_TEE_BYTE_BLOB            *f_pResponse,
+    __out                       DRM_TEE_BYTE_BLOB            *f_pTPKBOut ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_TEE_RPROV_GenerateProvisioningRequest(
+    __inout                     DRM_TEE_CONTEXT              *f_pContext,
+    __in                  const DRM_TEE_BYTE_BLOB            *f_pTPKB,
+    __in                  const DRM_ID                       *f_pidApplicationID,
+    __out                       DRM_TEE_BYTE_BLOB            *f_pProvRequest ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_TEE_RPROV_ProcessProvisioningResponse(
+    __inout                     DRM_TEE_CONTEXT              *f_pContext,
+    __in_tee_opt          const DRM_TEE_BYTE_BLOB            *f_pPrevPPKB,
+    __in                  const DRM_TEE_BYTE_BLOB            *f_pResponse,
+    __in                  const DRM_TEE_BYTE_BLOB            *f_pTPKB,
+    __out                       DRM_TEE_BYTE_BLOB            *f_pPPKB,
+    __out                       DRM_TEE_BYTE_BLOB            *f_pCert ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_TEE_LICPREP_PackageKey(
+    __inout                     DRM_TEE_CONTEXT              *f_pContext,
+    __in_tee_opt          const DRM_TEE_BYTE_BLOB            *f_pPPKB,
+    __in                  const DRM_TEE_BYTE_BLOB            *f_pLicense,
+    __in_tee_opt          const DRM_TEE_BYTE_BLOB            *f_pDKB,
+    __in_tee_opt          const DRM_TEE_BYTE_BLOB            *f_pNKB,
+    __out                       DRM_TEE_BYTE_BLOB            *f_pLKB ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_TEE_SAMPLEPROT_PrepareSampleProtectionKey(
+    __inout                     DRM_TEE_CONTEXT              *f_pContext,
+    __in                  const DRM_TEE_BYTE_BLOB            *f_pCertificate,
+    __in                  const DRM_TEE_BYTE_BLOB            *f_pRKB,
+    __out                       DRM_TEE_BYTE_BLOB            *f_pSPKB,
+    __out                       DRM_TEE_BYTE_BLOB            *f_pEncryptedKey ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_TEE_SECURESTOP_GetGenerationID(
+    __inout                     DRM_TEE_CONTEXT              *f_pContext,
+    __in                  const DRM_ID                       *f_pidEnvironment,
+    __out                       DRM_DWORD                    *f_pdwGenerationID ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_TEE_SECURESTOP2_GetSigningKeyBlob(
+    __inout                     DRM_TEE_CONTEXT              *f_pContext,
+    __in                  const DRM_TEE_BYTE_BLOB            *f_pCDKB,
+    __out                       DRM_TEE_BYTE_BLOB            *f_pSSKB ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_TEE_SECURESTOP2_SignChallenge(
+    __inout                     DRM_TEE_CONTEXT              *f_pContext,
+    __in                  const DRM_TEE_BYTE_BLOB            *f_pPPKB,
+    __in                  const DRM_TEE_BYTE_BLOB            *f_pSSKB,
+    __in                  const DRM_TEE_BYTE_BLOB            *f_pUnsignedChallenge,
+    __out                       DRM_TEE_BYTE_BLOB            *f_pBasicSignature,
+    __out                       DRM_TEE_BYTE_BLOB            *f_pAdditionalSignature,
+    __out                       DRM_ID                       *f_pidSecureStopSession,
+    __out                       DRM_ID                       *f_pKID ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_TEE_SECURETIME_GenerateChallengeData(
+    __inout                     DRM_TEE_CONTEXT              *f_pContext,
+    __out                       DRM_TEE_BYTE_BLOB            *f_pChallengeData ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_TEE_SECURETIME_ProcessResponseData(
+    __inout                     DRM_TEE_CONTEXT              *f_pContext,
+    __in                  const DRM_TEE_BYTE_BLOB            *f_pResponseData,
+    __in                  const DRM_TEE_BYTE_BLOB            *f_pSign,
+    __in                  const DRM_TEE_BYTE_BLOB            *f_pServerCert,
+    __in_tee_opt          const DRM_TEE_BYTE_BLOB            *f_pRKB ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_TEE_DECRYPT_PreparePolicyInfo(
+    __inout                     DRM_TEE_CONTEXT              *f_pContext,
+    __in                  const DRM_TEE_BYTE_BLOB            *f_pLicenses,
+    __in                        DRM_DWORD                     f_dwDecryptionMode,
+    __out                       DRM_TEE_BYTE_BLOB            *f_pOEMPolicyInfo ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_TEE_DECRYPT_PrepareToDecrypt(
+    __inout                     DRM_TEE_CONTEXT              *f_pContext,
+    __in                  const DRM_TEE_BYTE_BLOB            *f_pLKB,
+    __in                  const DRM_TEE_BYTE_BLOB            *f_pLicenses,
+    __in_tee_opt          const DRM_TEE_BYTE_BLOB            *f_pRKB,
+    __in_tee_opt          const DRM_TEE_BYTE_BLOB            *f_pSPKB,
+    __in_tee_opt          const DRM_TEE_BYTE_BLOB            *f_pChecksum,
+    __inout                     DRM_DWORD                    *f_pdwDecryptionMode,
+    __out                       DRM_TEE_BYTE_BLOB            *f_pCDKB ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_TEE_DECRYPT_CreateOEMBlobFromCDKB(
+    __inout                     DRM_TEE_CONTEXT              *f_pContext,
+    __in                  const DRM_TEE_BYTE_BLOB            *f_pCDKB,
+    __in_tee_opt          const DRM_TEE_BYTE_BLOB            *f_pOEMInitData,
+    __out                       DRM_TEE_BYTE_BLOB            *f_pOEMKeyInfo ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_TEE_AES128CTR_DecryptContent(
+    __inout_opt                 DRM_TEE_CONTEXT              *f_pContext,
+    __in                  const DRM_TEE_BYTE_BLOB            *f_pCDKB,
+    __in_tee_opt          const DRM_TEE_BYTE_BLOB            *f_pOEMKeyInfo,
+    __in                  const DRM_TEE_DWORDLIST            *f_pEncryptedRegionMapping,
+    __in                        DRM_UINT64                    f_ui64InitializationVector,
+    __in                  const DRM_TEE_BYTE_BLOB            *f_pEncrypted,
+    __out                       DRM_TEE_BYTE_BLOB            *f_pCCD ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_TEE_AES128CTR_DecryptAudioContentMultiple(
+    __inout_opt                 DRM_TEE_CONTEXT              *f_pContext,
+    __in                  const DRM_TEE_BYTE_BLOB            *f_pCDKB,
+    __in_tee_opt          const DRM_TEE_BYTE_BLOB            *f_pOEMKeyInfo,
+    __in                  const DRM_TEE_QWORDLIST            *f_pInitializationVectors,
+    __in                  const DRM_TEE_DWORDLIST            *f_pInitializationVectorSizes,
+    __in                  const DRM_TEE_BYTE_BLOB            *f_pEncrypted,
+    __out                       DRM_TEE_BYTE_BLOB            *f_pCCD ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_TEE_AES128CTR_DecryptContentMultiple(
+    __inout_opt                 DRM_TEE_CONTEXT              *f_pContext,
+    __in                  const DRM_TEE_BYTE_BLOB            *f_pCDKB,
+    __in_tee_opt          const DRM_TEE_BYTE_BLOB            *f_pOEMKeyInfo,
+    __in                  const DRM_TEE_QWORDLIST            *f_pEncryptedRegionInitializationVectorsHigh,
+    __in_tee_opt          const DRM_TEE_QWORDLIST            *f_pEncryptedRegionInitializationVectorsLow,
+    __in                  const DRM_TEE_DWORDLIST            *f_pEncryptedRegionCounts,
+    __in                  const DRM_TEE_DWORDLIST            *f_pEncryptedRegionMappings,
+    __in_tee_opt          const DRM_TEE_DWORDLIST            *f_pEncryptedRegionSkip,
+    __in                  const DRM_TEE_BYTE_BLOB            *f_pEncrypted,
+    __out                       DRM_TEE_BYTE_BLOB            *f_pCCD ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_TEE_AES128CBC_DecryptContentMultiple(
+    __inout_opt                 DRM_TEE_CONTEXT              *f_pContext,
+    __in                  const DRM_TEE_BYTE_BLOB            *f_pCDKB,
+    __in_tee_opt          const DRM_TEE_BYTE_BLOB            *f_pOEMKeyInfo,
+    __in                  const DRM_TEE_QWORDLIST            *f_pEncryptedRegionInitializationVectorsHigh,
+    __in_tee_opt          const DRM_TEE_QWORDLIST            *f_pEncryptedRegionInitializationVectorsLow,
+    __in                  const DRM_TEE_DWORDLIST            *f_pEncryptedRegionCounts,
+    __in                  const DRM_TEE_DWORDLIST            *f_pEncryptedRegionMappings,
+    __in_tee_opt          const DRM_TEE_DWORDLIST            *f_pEncryptedRegionSkip,
+    __in                  const DRM_TEE_BYTE_BLOB            *f_pEncrypted,
+    __out                       DRM_TEE_BYTE_BLOB            *f_pCCD ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_TEE_SIGN_SignHash(
+    __inout                     DRM_TEE_CONTEXT              *f_pContext,
+    __in                  const DRM_TEE_BYTE_BLOB            *f_pPPKB,
+    __in                  const DRM_TEE_BYTE_BLOB            *f_pDataToSign,
+    __out                       DRM_TEE_BYTE_BLOB            *f_pSignature ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_TEE_DOM_PackageKeys(
+    __inout                     DRM_TEE_CONTEXT              *f_pContext,
+    __in                  const DRM_TEE_BYTE_BLOB            *f_pPPKB,
+    __in                        DRM_DWORD                     f_dwProtocolVersion,
+    __in                  const DRM_TEE_BYTE_BLOB            *f_pDomainSessionKey,
+    __in                  const DRM_TEE_BYTE_BLOB            *f_pDomainPrivateKeys,
+    __out                       DRM_TEE_DWORDLIST            *f_pRevisions,
+    __out                       DRM_TEE_BYTE_BLOB            *f_pDKBs ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_TEE_REVOCATION_IngestRevocationInfo(
+    __inout                     DRM_TEE_CONTEXT              *f_pContext,
+    __in_tee_opt          const DRM_TEE_BYTE_BLOB            *f_pRuntimeCRL,
+    __in_tee_opt          const DRM_TEE_BYTE_BLOB            *f_pRevInfo,
+    __out                       DRM_TEE_BYTE_BLOB            *f_pRKB ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_TEE_LICGEN_CompleteLicense(
+    __inout                     DRM_TEE_CONTEXT              *f_pContext,
+    __in                  const DRM_TEE_BYTE_BLOB            *f_pRKB,
+    __in                        DRM_TEE_LICGEN_OP             f_eOp,
+    __in                        DRM_DWORD                     f_dwEncryptionMode,
+    __in                  const DRM_TEE_BYTE_BLOB            *f_pLicense,
+    __in_tee_opt          const DRM_TEE_BYTE_BLOB            *f_pCertificate,
+    __in_tee_opt          const DRM_TEE_BYTE_BLOB            *f_pRootLicense,
+    __in_tee_opt          const DRM_TEE_BYTE_BLOB            *f_pRootCEKB,
+    __out                       DRM_TEE_BYTE_BLOB            *f_pLKB,
+    __out                       DRM_TEE_BYTE_BLOB            *f_pCEKB,
+    __out                       DRM_TEE_BYTE_BLOB            *f_pCompletedLicense ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_TEE_LICGEN_AES128CTR_EncryptContent(
+    __inout                     DRM_TEE_CONTEXT              *f_pContext,
+    __in                  const DRM_TEE_BYTE_BLOB            *f_pCEKB,
+    __in                  const DRM_TEE_BYTE_BLOB            *f_pCCD,
+    __in                  const DRM_TEE_DWORDLIST            *f_pEncryptedRegionMapping,
+    __out                       DRM_UINT64                   *f_pui64InitializationVector,
+    __out                       DRM_TEE_BYTE_BLOB            *f_pEncrypted ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_TEE_H264_PreProcessEncryptedData(
+    __inout                     DRM_TEE_CONTEXT              *f_pContext,
+    __in                  const DRM_TEE_BYTE_BLOB            *f_pCDKB,
+    __in_tee_opt          const DRM_TEE_BYTE_BLOB            *f_pOEMKeyInfo,
+    __inout_ecount( 1 )         DRM_UINT64                   *f_pui64InitializationVector,
+    __in                  const DRM_TEE_DWORDLIST            *f_pEncryptedRegionMapping,
+    __in                  const DRM_TEE_BYTE_BLOB            *f_pEncryptedPartialFrame,
+    __in_tee_opt          const DRM_TEE_DWORDLIST            *f_pOpaqueSliceHeaderOffsetData,
+    __in_tee_opt          const DRM_TEE_BYTE_BLOB            *f_pOpaqueSliceHeaderState,
+    __out                       DRM_TEE_BYTE_BLOB            *f_pOpaqueSliceHeaderStateUpdated,
+    __out                       DRM_TEE_BYTE_BLOB            *f_pSliceHeaders,
+    __out                       DRM_TEE_BYTE_BLOB            *f_pOpaqueFrameData,
+    __inout_tee_opt             DRM_TEE_BYTE_BLOB            *f_pEncryptedTranscryptedFullFrame ) DRM_NO_INLINE_ATTRIBUTE;
+
+PREFAST_POP /* __WARNING_NONCONST_BUFFER_PARAM_25033 */
+PREFAST_POP /* __WARNING_NONCONST_PARAM_25004 */
+
+EXIT_PK_NAMESPACE;
+
+#endif /* _DRMTEE_H_ */
+
diff --git a/prebuilt-v4.4/noarch/include/drmteebase.h b/prebuilt-v4.4/noarch/include/drmteebase.h
new file mode 100644
index 0000000..61f093d
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmteebase.h
@@ -0,0 +1,245 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef _DRMTEEBASE_H_
+#define _DRMTEEBASE_H_ 1
+
+#include <drmteetypes.h>
+#include <oemteetypes.h>
+#include <drmxmrformatparser.h>
+#include <drmxmrconstants.h>
+#include <oemeccp256.h>
+#include <drmbcertformatparser.h>
+
+ENTER_PK_NAMESPACE;
+
+extern DRM_GLOBAL_CONST PUBKEY_P256 g_ECC256MSPlayReadyRootIssuerPubKeyTEE;
+extern DRM_GLOBAL_CONST DRM_ANSI_CONST_STRING g_rgdstrDrmTeeProperties[DRM_TEE_PROPERTY_MAX + 1];
+extern DRM_GLOBAL_CONST DRM_ANSI_CONST_STRING g_rgstrDrmTeeAPIs[DRM_TEE_METHOD_FUNCTION_MAP_COUNT];
+extern DRM_GLOBAL_CONST DRM_ANSI_CONST_STRING g_dstrTeeOpenTag;
+extern DRM_GLOBAL_CONST DRM_ANSI_CONST_STRING g_dstrTeeCloseTag;
+extern DRM_GLOBAL_CONST DRM_ANSI_CONST_STRING g_dstrPropertyOpenTag;
+extern DRM_GLOBAL_CONST DRM_ANSI_CONST_STRING g_dstrPropertyCloseTag;
+extern DRM_GLOBAL_CONST DRM_ANSI_CONST_STRING g_dstrAPIOpenTag;
+extern DRM_GLOBAL_CONST DRM_ANSI_CONST_STRING g_dstrAPICloseTag;
+extern DRM_GLOBAL_CONST DRM_ANSI_CONST_STRING g_dstrHardCodedAPIValue;
+extern DRM_GLOBAL_CONST DRM_ANSI_CONST_STRING g_dstrSignatureOpenTag;
+extern DRM_GLOBAL_CONST DRM_ANSI_CONST_STRING g_dstrSignatureCloseBrace;
+extern DRM_GLOBAL_CONST DRM_ANSI_CONST_STRING g_dstrSignatureCloseTag;
+
+
+typedef enum
+{
+    DRM_TEE_KEY_TYPE_INVALID                            = 0,
+    DRM_TEE_KEY_TYPE_TK                                 = 1,
+    DRM_TEE_KEY_TYPE_TKD                                = 2,
+    DRM_TEE_KEY_TYPE_PR_SST                             = 3,
+    DRM_TEE_KEY_TYPE_PR_CI                              = 4,
+    DRM_TEE_KEY_TYPE_PR_CK                              = 5,
+    DRM_TEE_KEY_TYPE_PR_MI                              = 6,
+    DRM_TEE_KEY_TYPE_PR_MK                              = 7,
+    DRM_TEE_KEY_TYPE_PR_ECC_PRIVKEY_SIGN                = 8,
+    DRM_TEE_KEY_TYPE_PR_ECC_PRIVKEY_ENCRYPT             = 9,
+    DRM_TEE_KEY_TYPE_PR_ECC_PRIVKEY_PRND_DEPRECATED     = 10,
+    DRM_TEE_KEY_TYPE_RPROV_SESSION_KEY                  = 11,
+    DRM_TEE_KEY_TYPE_RPROV_SESSION_KEY_CONF             = 12,
+    DRM_TEE_KEY_TYPE_RPROV_SESSION_KEY_WRAP             = 13,
+    DRM_TEE_KEY_TYPE_RPROV_SESSION_KEY_SIGN             = 14,
+    DRM_TEE_KEY_TYPE_SAMPLEPROT                         = 15,
+    DRM_TEE_KEY_TYPE_DOMAIN_SESSION                     = 16,
+    DRM_TEE_KEY_TYPE_AES128_DERIVATION                  = 17,
+    DRM_TEE_KEY_TYPE_AES128_SECURESTOP2                 = 18,
+} DRM_TEE_KEY_TYPE;
+
+typedef enum
+{
+    DRM_TEE_XB_KB_OPERATION_SIGN    = 0x1,
+    DRM_TEE_XB_KB_OPERATION_ENCRYPT = 0x2,
+} DRM_TEE_XB_KB_OPERATION;
+
+typedef struct __tagDRM_TEE_KEY
+{
+    DRM_TEE_KEY_TYPE     eType;
+    DRM_DWORD            dwidTK;    /* Only set if eType == DRM_TEE_KEY_TYPE_TK */
+    OEM_TEE_KEY          oKey;
+} DRM_TEE_KEY;
+
+PREFAST_PUSH_DISABLE_EXPLAINED( __WARNING_POOR_DATA_ALIGNMENT_25021, "Since PlayReady ships as source code, it is more important for types to be human-readable for member sequencing than minimum sized." )
+typedef struct __tagDRM_TEE_XMR_LICENSE
+{
+    DRM_BOOL                     fValid;
+    DRM_XMRFORMAT                oLicense;
+    DRM_DWORD                    cbStack;
+    DRM_BYTE                    *pbStack;
+    DRM_STACK_ALLOCATOR_CONTEXT  oStack;
+} DRM_TEE_XMR_LICENSE;
+PREFAST_POP /* __WARNING_POOR_DATA_ALIGNMENT_25021 */
+
+#define DRM_TEE_KEY_EMPTY            { DRM_TEE_KEY_TYPE_INVALID, 0, OEM_TEE_KEY_EMPTY }
+#define TEE_SIGNATURE_VERSION        "1"
+#define TEE_SIGNATURE_VERSION_LENGTH 1
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_TEE_IMPL_BASE_MemAlloc(
+    __inout_opt                   DRM_TEE_CONTEXT              *f_pContext,
+    __in                          DRM_DWORD                     f_cb,
+    __deref_out_bcount( f_cb )    DRM_VOID                    **f_ppv ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API_VOID DRM_VOID DRM_CALL DRM_TEE_IMPL_BASE_MemFree(
+    __inout_opt                   DRM_TEE_CONTEXT              *f_pContext,
+    __inout                       DRM_VOID                    **f_ppv ) DRM_NO_INLINE_ATTRIBUTE;
+
+PREFAST_PUSH_DISABLE_EXPLAINED( __WARNING_NONCONST_PARAM_25004, "f_pContext Parameter is modified in some implementations." )
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_TEE_IMPL_BASE_AllocBlob(
+    __inout_opt                   DRM_TEE_CONTEXT              *f_pContext,
+    __in                          DRM_TEE_BLOB_ALLOC_BEHAVIOR   f_eBehavior,
+    __in                          DRM_DWORD                     f_cb,
+    __in_bcount_opt( f_cb ) const DRM_BYTE                     *f_pb,
+    __inout                       DRM_TEE_BYTE_BLOB            *f_pBlob ) DRM_NO_INLINE_ATTRIBUTE;
+PREFAST_POP     /* __WARNING_NONCONST_PARAM_25004 */
+
+DRM_NO_INLINE DRM_API_VOID DRM_VOID DRM_CALL DRM_TEE_IMPL_BASE_FreeBlob(
+    __inout_opt                   DRM_TEE_CONTEXT              *f_pContext,
+    __inout                       DRM_TEE_BYTE_BLOB            *f_pBlob ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API_VOID DRM_VOID DRM_CALL DRM_TEE_IMPL_BASE_TransferBlobOwnership(
+    __inout                       DRM_TEE_BYTE_BLOB            *f_pDest,
+    __inout                       DRM_TEE_BYTE_BLOB            *f_pSource ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_TEE_IMPL_BASE_ValidateLicenseExpiration(
+    __inout               DRM_TEE_CONTEXT              *f_pContext,
+    __in            const DRM_XMRFORMAT                *f_pLicense,
+    __in                  DRM_BOOL                      f_fValidateBeginDate,
+    __in                  DRM_BOOL                      f_fValidateEndDate ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_TEE_IMPL_BASE_CheckLicenseSignature(
+    __inout                DRM_TEE_CONTEXT              *f_pContext,
+    __in             const DRM_XMRFORMAT                *f_pXMRLicense,
+    __in_ecount( 2 ) const DRM_TEE_KEY                  *f_pKeys ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_TEE_IMPL_BASE_AllocateKeyArray(
+    __inout                                               DRM_TEE_CONTEXT            *f_pContext,
+    __in                                                  DRM_DWORD                   f_cKeys,
+    __deref_out                                           DRM_TEE_KEY               **f_ppKeys ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API_VOID DRM_VOID DRM_CALL DRM_TEE_IMPL_BASE_FreeKeyArray(
+    __inout                                               DRM_TEE_CONTEXT            *f_pContext,
+    __in                                                  DRM_DWORD                   f_cKeys,
+    __deref_inout_ecount( f_cKeys )                       DRM_TEE_KEY               **f_ppKeys ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_ID DRM_CALL DRM_TEE_IMPL_BASE_GetKeyDerivationIDSign(
+    __in                                                  DRM_TEE_XB_KB_TYPE          f_eKBType ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_ID DRM_CALL DRM_TEE_IMPL_BASE_GetKeyDerivationIDEncrypt(
+    __in                                                  DRM_TEE_XB_KB_TYPE          f_eKBType ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_BOOL DRM_CALL DRM_TEE_IMPL_BASE_IsKBTypePersistedToDisk(
+    __in                                                  DRM_TEE_XB_KB_TYPE          f_eKBType ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_TEE_IMPL_BASE_DeriveTKDFromTK(
+    __inout                                               DRM_TEE_CONTEXT            *f_pContext,
+    __in_opt                                        const DRM_TEE_KEY                *f_pTK,
+    __in                                                  DRM_TEE_XB_KB_TYPE          f_eType,
+    __in                                                  DRM_TEE_XB_KB_OPERATION     f_eOperation,
+    __in_opt                                        const DRM_BOOL                   *f_pfPersist,
+    __out                                                 DRM_TEE_KEY                *f_pTKD ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_TEE_IMPL_BASE_AllocBlobAndTakeOwnership(
+    __inout_opt                                           DRM_TEE_CONTEXT            *f_pContext,
+    __in                                                  DRM_DWORD                   f_cb,
+    __deref_inout_bcount(f_cb)                            DRM_BYTE                  **f_ppb,
+    __inout                                               DRM_TEE_BYTE_BLOB          *f_pBlob ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_TEE_KEY* DRM_CALL DRM_TEE_IMPL_BASE_LocateKeyInPPKBWeakRef(
+    __in_opt                 const DRM_TEE_KEY_TYPE    *f_peType,
+    __in                           DRM_DWORD            f_cPPKBKeys,
+    __in_ecount( f_cPPKBKeys )     DRM_TEE_KEY         *f_pPPKBKeys ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_TEE_IMPL_BASE_GetPKVersion(
+    __out   DRM_DWORD    *f_pdwPKMajorVersion,
+    __out   DRM_DWORD    *f_pdwPKMinorVersion,
+    __out   DRM_DWORD    *f_pdwPKBuildVersion,
+    __out   DRM_DWORD    *f_pdwPKQFEVersion ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_TEE_IMPL_BASE_CopyDwordPairsToAlignedBufferAndSwapEndianness(
+    __inout    DRM_TEE_CONTEXT      *f_pContext,
+    __out      DRM_TEE_BYTE_BLOB    *f_pDest,
+    __in const DRM_TEE_BYTE_BLOB    *f_pSource ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_TEE_IMPL_BASE_AllocKeyAES128(
+    __inout_opt                                     OEM_TEE_CONTEXT            *f_pContextAllowNULL,
+    __in                                            DRM_TEE_KEY_TYPE            f_eType,
+    __out                                           DRM_TEE_KEY                *f_pKey ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_TEE_IMPL_BASE_AllocKeyECC256(
+    __inout                                         OEM_TEE_CONTEXT            *f_pContext,
+    __in                                            DRM_TEE_KEY_TYPE            f_eType,
+    __out                                           DRM_TEE_KEY                *f_pKey ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_BOOL DRM_CALL DRM_TEE_IMPL_SAMPLEPROT_IsDecryptionModeSupported(
+    __inout                     OEM_TEE_CONTEXT              *f_pOemTeeCtx,
+    __in                        DRM_DWORD                     f_dwMode ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_TEE_IMPL_SAMPLEPROT_ApplySampleProtection(
+    __inout                                         OEM_TEE_CONTEXT        *f_pContext,
+    __in                                      const OEM_TEE_KEY            *f_pSPK,
+    __in                                            DRM_UINT64              f_ui64InitializationVector,
+    __in                                            DRM_DWORD               f_cbClearToSampleProtected,
+    __inout_bcount( f_cbClearToSampleProtected )    DRM_BYTE               *f_pbClearToSampleProtected ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_TEE_IMPL_BASE_GetAppSpecificHWID(
+    __inout                                         OEM_TEE_CONTEXT            *f_pOemTeeCtx,
+    __in                                      const DRM_ID                     *f_pidApplication,
+    __out                                           DRM_ID                     *f_pidHWID ) DRM_NO_INLINE_ATTRIBUTE;
+
+/* Unsafe for potential math overflow unless input is pre-verified */
+#define DRM_AESCBC_ENCRYPTED_SIZE_W_IV_NOT_OVERFLOW_SAFE(cb) ( cb + 2 * DRM_AES_BLOCKLEN - cb % DRM_AES_BLOCKLEN )
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_TEE_IMPL_BASE_AES128CBC(
+    __inout                                                                      DRM_TEE_CONTEXT            *f_pContext,
+    __in                                                                         DRM_DWORD                   f_cbBlob,
+    __in_bcount( f_cbBlob )                                                const DRM_BYTE                   *f_pbBlob,
+    __in                                                                   const DRM_TEE_KEY                *f_poKey,
+    __inout                                                                      DRM_DWORD                  *f_pcbEncryptedBlob,
+    __out_bcount( DRM_AESCBC_ENCRYPTED_SIZE_W_IV_NOT_OVERFLOW_SAFE( f_cbBlob ) ) DRM_BYTE                   *f_pbEncryptedBlob ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_TEE_IMPL_BASE_ParseCertificateChain(
+    __inout_opt                           OEM_TEE_CONTEXT                       *f_pOemTeeContext,
+    __in_ecount_opt( 1 )            const DRMFILETIME                           *f_pftCurrentTime,
+    __in                                  DRM_DWORD                              f_dwExpectedLeafCertType,
+    __in                                  DRM_DWORD                              f_cbCertData,
+    __in_bcount( f_cbCertData )     const DRM_BYTE                              *f_pbCertData,
+    __out                                 DRM_BCERTFORMAT_PARSER_CHAIN_DATA     *f_pChainData ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_TEE_IMPL_BASE_ParseLicenseAlloc(
+    __inout                           DRM_TEE_CONTEXT              *f_pContext,
+    __in                              DRM_DWORD                     f_cbLicense,
+    __in_ecount( f_cbLicense )  const DRM_BYTE                     *f_pbLicense,
+    __inout                           DRM_TEE_XMR_LICENSE          *f_poLicense ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_TEE_BASE_IMPL_GetVersionInformation(
+    __inout                                               OEM_TEE_CONTEXT          *f_pContext,
+    __out                                                 DRM_DWORD                *f_pchManufacturerName,
+    __deref_out_ecount( *f_pchManufacturerName )          DRM_WCHAR               **f_ppwszManufacturerName,
+    __out                                                 DRM_DWORD                *f_pchModelName,
+    __deref_out_ecount( *f_pchModelName )                 DRM_WCHAR               **f_ppwszModelName,
+    __out                                                 DRM_DWORD                *f_pchModelNumber,
+    __deref_out_ecount( *f_pchModelNumber )               DRM_WCHAR               **f_ppwszModelNumber,
+    __out_ecount_opt( DRM_TEE_METHOD_FUNCTION_MAP_COUNT ) DRM_DWORD                *f_pdwFunctionMap,
+    __out_opt                                             DRM_DWORD                *f_pcbProperties,
+    __deref_opt_out_bcount( *f_pcbProperties )            DRM_BYTE                **f_ppbProperties ) DRM_NO_INLINE_ATTRIBUTE;
+
+#define DRM_TEE_IMPL_BASE_ParsedLicenseFree( __pOemTeeCtx, __poLicense ) DRM_DO {                       \
+    if( (__poLicense) != NULL )                                                                         \
+    {                                                                                                   \
+        ChkVOID( OEM_TEE_BASE_SecureMemFree( (__pOemTeeCtx), (DRM_VOID**)&(__poLicense)->pbStack ) );   \
+    }                                                                                                   \
+} DRM_WHILE_FALSE
+
+EXIT_PK_NAMESPACE;
+
+#endif /* _DRMTEEBASE_H_ */
+
diff --git a/prebuilt-v4.4/noarch/include/drmteeproxy.h b/prebuilt-v4.4/noarch/include/drmteeproxy.h
new file mode 100644
index 0000000..ee2bc7d
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmteeproxy.h
@@ -0,0 +1,286 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef _DRMTEEPROXY_H_
+#define _DRMTEEPROXY_H_ 1
+
+#include <drmteetypes.h>
+#include <oemteetypes.h>
+
+ENTER_PK_NAMESPACE;
+
+/* Normal world TEE proxy API */
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_TEE_PROXY_BASE_AllocTEEContext(
+    __in_opt                    DRM_VOID                     *f_pOEMContext,
+    __in_opt              const DRM_ID                       *f_pidApplication,
+    __inout                     DRM_TEE_PROXY_CONTEXT       **f_ppContext ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API_VOID DRM_VOID   DRM_CALL DRM_TEE_PROXY_BASE_FreeTEEContext(
+    __inout                     DRM_TEE_PROXY_CONTEXT       **f_ppContext ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_TEE_NW_BASE_MemAlloc(
+    __inout_opt                 DRM_TEE_PROXY_CONTEXT        *f_pContext,
+    __in                        DRM_DWORD                     f_cb,
+    __deref_out_bcount(f_cb)    DRM_VOID                    **f_ppv ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API_VOID DRM_VOID   DRM_CALL DRM_TEE_NW_BASE_MemFree(
+     __inout_opt                DRM_TEE_PROXY_CONTEXT        *f_pContext,
+     __inout                    DRM_VOID                    **f_ppv ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_TEE_NW_BASE_AllocBlob(
+    __inout_opt                 DRM_TEE_PROXY_CONTEXT        *f_pContext,
+    __in                        DRM_TEE_BLOB_ALLOC_BEHAVIOR   f_eBehavior,
+    __in                        DRM_DWORD                     f_cb,
+    __in_bcount_opt(f_cb) const DRM_BYTE                     *f_pb,
+    __inout                     DRM_TEE_BYTE_BLOB            *f_pBlob ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API_VOID DRM_VOID   DRM_CALL DRM_TEE_NW_BASE_FreeBlob(
+    __inout_opt                 DRM_TEE_PROXY_CONTEXT        *f_pContext,
+    __inout                     DRM_TEE_BYTE_BLOB            *f_pBlob ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API_VOID DRM_VOID DRM_CALL DRM_TEE_NW_BASE_TransferBlobOwnership(
+    __inout                     DRM_TEE_BYTE_BLOB            *f_pDest,
+    __inout                     DRM_TEE_BYTE_BLOB            *f_pSource ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_TEE_PROXY_BASE_SignDataWithSecureStoreKey(
+    __inout                     DRM_TEE_PROXY_CONTEXT        *f_pContext,
+    __in                  const DRM_TEE_BYTE_BLOB            *f_pPPKB,
+    __in                  const DRM_TEE_BYTE_BLOB            *f_pDataToSign,
+    __out                       DRM_TEE_BYTE_BLOB            *f_pSignature ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_TEE_PROXY_BASE_CheckDeviceKeys(
+    __inout                     DRM_TEE_PROXY_CONTEXT        *f_pContext,
+    __in                  const DRM_TEE_BYTE_BLOB            *f_pPPKB ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_TEE_PROXY_BASE_GetDebugInformation(
+    __inout                     DRM_TEE_PROXY_CONTEXT        *f_pContext,
+    __out                       DRM_DWORD                    *f_pdwLastHR,
+    __out                       DRM_TEE_BYTE_BLOB            *f_pLog ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_TEE_PROXY_BASE_GenerateNonce(
+    __inout                     DRM_TEE_PROXY_CONTEXT        *f_pContext,
+    __out                       DRM_TEE_BYTE_BLOB            *f_pNKB,
+    __out                       DRM_ID                       *f_pNonce ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_TEE_PROXY_BASE_GetSystemTime(
+    __inout                     DRM_TEE_PROXY_CONTEXT        *f_pContext,
+    __out                       DRM_UINT64                   *f_pui64SystemTime ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_TEE_PROXY_BASE_GetFeatureInformation(
+    __inout                     DRM_TEE_PROXY_CONTEXT        *f_pContext,
+    __in                  const DRM_TEE_BYTE_BLOB            *f_pPPKB,
+    __out                       DRM_TEE_BYTE_BLOB            *f_pTEExml ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_TEE_PROXY_LPROV_GenerateDeviceKeys(
+    __inout                     DRM_TEE_PROXY_CONTEXT        *f_pContext,
+    __in_tee_opt          const DRM_TEE_BYTE_BLOB            *f_pPrevPPKB,
+    __in_tee_opt          const DRM_TEE_BYTE_BLOB            *f_pCertificate,
+    __in_tee_opt          const DRM_TEE_BYTE_BLOB            *f_pOEMProtectedCertificatePrivateKeys,
+    __in                  const DRM_ID                       *f_pidApplication,
+    __out                       DRM_TEE_BYTE_BLOB            *f_pPPKB,
+    __out                       DRM_TEE_BYTE_BLOB            *f_pNewCertificate ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_TEE_PROXY_RPROV_GenerateBootstrapChallenge(
+    __inout                     DRM_TEE_PROXY_CONTEXT        *f_pContext,
+    __inout_tee_opt             DRM_TEE_BYTE_BLOB            *f_pRProvContext,
+    __out                       DRM_DWORD                    *f_pdwType,
+    __out                       DRM_DWORD                    *f_pdwStep,
+    __out                       DRM_DWORD                    *f_pdwAdditionalInfoNeeded,
+    __out                       DRM_TEE_BYTE_BLOB            *f_pChallenge ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_TEE_PROXY_RPROV_ProcessBootstrapResponse(
+    __inout                     DRM_TEE_PROXY_CONTEXT        *f_pContext,
+    __inout                     DRM_TEE_BYTE_BLOB            *f_pRProvContext,
+    __in                  const DRM_TEE_BYTE_BLOB            *f_pResponse,
+    __out                       DRM_TEE_BYTE_BLOB            *f_pTPKBOut ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_TEE_PROXY_RPROV_GenerateProvisioningRequest(
+    __inout                     DRM_TEE_PROXY_CONTEXT        *f_pContext,
+    __in                  const DRM_TEE_BYTE_BLOB            *f_pTPKB,
+    __in                  const DRM_ID                       *f_pidApplicationID,
+    __out                       DRM_TEE_BYTE_BLOB            *f_pProvRequest ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_TEE_PROXY_RPROV_ProcessProvisioningResponse(
+    __inout                     DRM_TEE_PROXY_CONTEXT        *f_pContext,
+    __in_tee_opt          const DRM_TEE_BYTE_BLOB            *f_pPrevPPKB,
+    __in                  const DRM_TEE_BYTE_BLOB            *f_pResponse,
+    __in                  const DRM_TEE_BYTE_BLOB            *f_pTPKB,
+    __out                       DRM_TEE_BYTE_BLOB            *f_pPPKB,
+    __out                       DRM_TEE_BYTE_BLOB            *f_pCert ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_TEE_PROXY_LICPREP_PackageKey(
+    __inout                     DRM_TEE_PROXY_CONTEXT        *f_pContext,
+    __in_tee_opt          const DRM_TEE_BYTE_BLOB            *f_pPPKB,
+    __in                  const DRM_TEE_BYTE_BLOB            *f_pLicense,
+    __in_tee_opt          const DRM_TEE_BYTE_BLOB            *f_pDKB,
+    __in_tee_opt          const DRM_TEE_BYTE_BLOB            *f_pNKB,
+    __out                       DRM_TEE_BYTE_BLOB            *f_pLKB ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_TEE_PROXY_SAMPLEPROT_PrepareSampleProtectionKey(
+    __inout                     DRM_TEE_PROXY_CONTEXT        *f_pContext,
+    __in                  const DRM_TEE_BYTE_BLOB            *f_pCertificate,
+    __in                  const DRM_TEE_BYTE_BLOB            *f_pRKB,
+    __out                       DRM_TEE_BYTE_BLOB            *f_pSPKB,
+    __out                       DRM_TEE_BYTE_BLOB            *f_pEncryptedKey ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_TEE_PROXY_SECURESTOP_GetGenerationID(
+    __inout                     DRM_TEE_PROXY_CONTEXT        *f_pContext,
+    __in                  const DRM_ID                       *f_pidEnvironment,
+    __out                       DRM_DWORD                    *f_pdwGenerationID ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_TEE_PROXY_SECURESTOP2_GetSigningKeyBlob(
+    __inout                     DRM_TEE_PROXY_CONTEXT        *f_pContext,
+    __in                  const DRM_TEE_BYTE_BLOB            *f_pCDKB,
+    __out                       DRM_TEE_BYTE_BLOB            *f_pSSKB ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_TEE_PROXY_SECURESTOP2_SignChallenge(
+    __inout                     DRM_TEE_PROXY_CONTEXT        *f_pContext,
+    __in                  const DRM_TEE_BYTE_BLOB            *f_pPPKB,
+    __in                  const DRM_TEE_BYTE_BLOB            *f_pSSKB,
+    __in                  const DRM_TEE_BYTE_BLOB            *f_pUnsignedChallenge,
+    __out                       DRM_TEE_BYTE_BLOB            *f_pBasicSignature,
+    __out                       DRM_TEE_BYTE_BLOB            *f_pAdditionalSignature,
+    __out                       DRM_ID                       *f_pidSecureStopSession,
+    __out                       DRM_ID                       *f_pKID ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_TEE_PROXY_DECRYPT_PreparePolicyInfo(
+    __inout                     DRM_TEE_PROXY_CONTEXT        *f_pContext,
+    __in                  const DRM_TEE_BYTE_BLOB            *f_pLicenses,
+    __in                        DRM_DWORD                     f_dwDecryptionMode,
+    __out                       DRM_TEE_BYTE_BLOB            *f_pOEMPolicyInfo ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_TEE_PROXY_DECRYPT_PrepareToDecrypt(
+    __inout                     DRM_TEE_PROXY_CONTEXT        *f_pContext,
+    __in                  const DRM_TEE_BYTE_BLOB            *f_pLKB,
+    __in                  const DRM_TEE_BYTE_BLOB            *f_pLicenses,
+    __in_tee_opt          const DRM_TEE_BYTE_BLOB            *f_pRKB,
+    __in_tee_opt          const DRM_TEE_BYTE_BLOB            *f_pSPKB,
+    __in_tee_opt          const DRM_TEE_BYTE_BLOB            *f_pChecksum,
+    __inout                     DRM_DWORD                    *f_pdwDecryptionMode,
+    __out                       DRM_TEE_BYTE_BLOB            *f_pCDKB ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_TEE_PROXY_DECRYPT_CreateOEMBlobFromCDKB(
+    __inout                     DRM_TEE_PROXY_CONTEXT        *f_pContext,
+    __in                  const DRM_TEE_BYTE_BLOB            *f_pCDKB,
+    __in_tee_opt          const DRM_TEE_BYTE_BLOB            *f_pOEMInitData,
+    __out                       DRM_TEE_BYTE_BLOB            *f_pOEMKeyInfo ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_TEE_PROXY_AES128CTR_DecryptContent(
+    __inout                     DRM_TEE_PROXY_CONTEXT        *f_pContext,
+    __in                  const DRM_TEE_BYTE_BLOB            *f_pCDKB,
+    __in_tee_opt          const DRM_TEE_BYTE_BLOB            *f_pOEMKeyInfo,
+    __in                  const DRM_TEE_DWORDLIST            *f_pEncryptedRegionMapping,
+    __in                        DRM_UINT64                    f_ui64InitializationVector,
+    __in                  const DRM_TEE_BYTE_BLOB            *f_pEncrypted,
+    __out                       DRM_TEE_BYTE_BLOB            *f_pCCD ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_TEE_PROXY_AES128CTR_DecryptAudioContentMultiple(
+    __inout                     DRM_TEE_PROXY_CONTEXT        *f_pContext,
+    __in                  const DRM_TEE_BYTE_BLOB            *f_pCDKB,
+    __in_tee_opt          const DRM_TEE_BYTE_BLOB            *f_pOEMKeyInfo,
+    __in                  const DRM_TEE_QWORDLIST            *f_pInitializationVectors,
+    __in                  const DRM_TEE_DWORDLIST            *f_pInitializationVectorSizes,
+    __in                  const DRM_TEE_BYTE_BLOB            *f_pEncrypted,
+    __out                       DRM_TEE_BYTE_BLOB            *f_pCCD ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_TEE_PROXY_AES128CTR_DecryptContentMultiple(
+    __inout                     DRM_TEE_PROXY_CONTEXT        *f_pContext,
+    __in                  const DRM_TEE_BYTE_BLOB            *f_pCDKB,
+    __in_tee_opt          const DRM_TEE_BYTE_BLOB            *f_pOEMKeyInfo,
+    __in                  const DRM_TEE_QWORDLIST            *f_pEncryptedRegionInitializationVectorsHigh,
+    __in_tee_opt          const DRM_TEE_QWORDLIST            *f_pEncryptedRegionInitializationVectorsLow,
+    __in                  const DRM_TEE_DWORDLIST            *f_pEncryptedRegionCounts,
+    __in                  const DRM_TEE_DWORDLIST            *f_pEncryptedRegionMappings,
+    __in_tee_opt          const DRM_TEE_DWORDLIST            *f_pEncryptedRegionSkip,
+    __in                  const DRM_TEE_BYTE_BLOB            *f_pEncrypted,
+    __out                       DRM_TEE_BYTE_BLOB            *f_pCCD ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_TEE_PROXY_AES128CBC_DecryptContentMultiple(
+    __inout                     DRM_TEE_PROXY_CONTEXT        *f_pContext,
+    __in                  const DRM_TEE_BYTE_BLOB            *f_pCDKB,
+    __in_tee_opt          const DRM_TEE_BYTE_BLOB            *f_pOEMKeyInfo,
+    __in                  const DRM_TEE_QWORDLIST            *f_pEncryptedRegionInitializationVectorsHigh,
+    __in_tee_opt          const DRM_TEE_QWORDLIST            *f_pEncryptedRegionInitializationVectorsLow,
+    __in                  const DRM_TEE_DWORDLIST            *f_pEncryptedRegionCounts,
+    __in                  const DRM_TEE_DWORDLIST            *f_pEncryptedRegionMappings,
+    __in_tee_opt          const DRM_TEE_DWORDLIST            *f_pEncryptedRegionSkip,
+    __in                  const DRM_TEE_BYTE_BLOB            *f_pEncrypted,
+    __out                       DRM_TEE_BYTE_BLOB            *f_pCCD ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_TEE_PROXY_SIGN_SignHash(
+    __inout                     DRM_TEE_PROXY_CONTEXT        *f_pContext,
+    __in                  const DRM_TEE_BYTE_BLOB            *f_pPPKB,
+    __in                  const DRM_TEE_BYTE_BLOB            *f_pDataToSign,
+    __out                       DRM_TEE_BYTE_BLOB            *f_pSignature ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_TEE_PROXY_DOM_PackageKeys(
+    __inout                     DRM_TEE_PROXY_CONTEXT        *f_pContext,
+    __in                  const DRM_TEE_BYTE_BLOB            *f_pPPKB,
+    __in                        DRM_DWORD                     f_dwProtocolVersion,
+    __in                  const DRM_TEE_BYTE_BLOB            *f_pDomainSessionKey,
+    __in                  const DRM_TEE_BYTE_BLOB            *f_pDomainPrivateKeys,
+    __out                       DRM_TEE_DWORDLIST            *f_pRevisions,
+    __out                       DRM_TEE_BYTE_BLOB            *f_pDKBs ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_TEE_PROXY_REVOCATION_IngestRevocationInfo(
+    __inout                     DRM_TEE_PROXY_CONTEXT        *f_pContext,
+    __in_tee_opt          const DRM_TEE_BYTE_BLOB            *f_pRuntimeCRL,
+    __in_tee_opt          const DRM_TEE_BYTE_BLOB            *f_pRevInfo,
+    __out                       DRM_TEE_BYTE_BLOB            *f_pRKB ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_TEE_PROXY_LICGEN_CompleteLicense(
+    __inout                     DRM_TEE_PROXY_CONTEXT        *f_pContext,
+    __in                  const DRM_TEE_BYTE_BLOB            *f_pRKB,
+    __in                        DRM_TEE_LICGEN_OP             f_eOp,
+    __in                        DRM_DWORD                     f_dwEncryptionMode,
+    __in                  const DRM_TEE_BYTE_BLOB            *f_pLicense,
+    __in_tee_opt          const DRM_TEE_BYTE_BLOB            *f_pCertificate,
+    __in_tee_opt          const DRM_TEE_BYTE_BLOB            *f_pRootLicense,
+    __in_tee_opt          const DRM_TEE_BYTE_BLOB            *f_pRootCEKB,
+    __out                       DRM_TEE_BYTE_BLOB            *f_pLKB,
+    __out                       DRM_TEE_BYTE_BLOB            *f_pCEKB,
+    __out                       DRM_TEE_BYTE_BLOB            *f_pCompletedLicense ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_TEE_PROXY_LICGEN_AES128CTR_EncryptContent(
+    __inout                     DRM_TEE_PROXY_CONTEXT        *f_pContext,
+    __in                  const DRM_TEE_BYTE_BLOB            *f_pCEKB,
+    __in                  const DRM_TEE_BYTE_BLOB            *f_pCCD,
+    __in                  const DRM_TEE_DWORDLIST            *f_pEncryptedRegionMapping,
+    __out                       DRM_UINT64                   *f_pui64InitializationVector,
+    __out                       DRM_TEE_BYTE_BLOB            *f_pEncrypted ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_TEE_PROXY_H264_PreProcessEncryptedData(
+    __inout                     DRM_TEE_PROXY_CONTEXT        *f_pContext,
+    __in                  const DRM_TEE_BYTE_BLOB            *f_pCDKB,
+    __in_tee_opt          const DRM_TEE_BYTE_BLOB            *f_pOEMKeyInfo,
+    __inout_ecount( 1 )         DRM_UINT64                   *f_pui64InitializationVector,
+    __in                  const DRM_TEE_DWORDLIST            *f_pEncryptedRegionMapping,
+    __in                  const DRM_TEE_BYTE_BLOB            *f_pEncryptedPartialFrame,
+    __in_tee_opt          const DRM_TEE_DWORDLIST            *f_pOpaqueSliceHeaderOffsetData,
+    __in_tee_opt          const DRM_TEE_BYTE_BLOB            *f_pOpaqueSliceHeaderState,
+    __out                       DRM_TEE_BYTE_BLOB            *f_pOpaqueSliceHeaderStateUpdated,
+    __out                       DRM_TEE_BYTE_BLOB            *f_pSliceHeaders,
+    __out                       DRM_TEE_BYTE_BLOB            *f_pOpaqueFrameData,
+    __inout_tee_opt             DRM_TEE_BYTE_BLOB            *f_pEncryptedTranscryptedFullFrame ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_TEE_PROXY_SECURETIME_GenerateChallengeData(
+    __inout                    DRM_TEE_PROXY_CONTEXT          *f_pContext,
+    __out                      DRM_TEE_BYTE_BLOB              *f_pChallengeData ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_TEE_PROXY_SECURETIME_ProcessResponseData(
+    __inout                    DRM_TEE_PROXY_CONTEXT          *f_pContext,
+    __in                 const DRM_TEE_BYTE_BLOB              *f_pResponseData,
+    __in                 const DRM_TEE_BYTE_BLOB              *f_pSign,
+    __in                 const DRM_TEE_BYTE_BLOB              *f_pServerCert,
+    __in_tee_opt         const DRM_TEE_BYTE_BLOB              *f_pRKB ) DRM_NO_INLINE_ATTRIBUTE;
+
+EXIT_PK_NAMESPACE;
+
+#endif /* _DRMTEEPROXY_H_ */
+
diff --git a/prebuilt-v4.4/noarch/include/drmteeproxyformat_generated.h b/prebuilt-v4.4/noarch/include/drmteeproxyformat_generated.h
new file mode 100644
index 0000000..7884bf0
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmteeproxyformat_generated.h
@@ -0,0 +1,204 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+/* This source was autogenerated by xbgen.
+** DO NOT EDIT THIS SOURCE MANUALLY.
+** If changes need to be applied update the XML and regenerate this source.
+*/
+/*
+** This file defines the following generated formats
+** XB_DRM_TEE_PROXY_METHOD_REQ
+** XB_DRM_TEE_PROXY_APPINFO
+** XB_DRM_TEE_PROXY_SYSINFO
+*/
+#ifndef __DRMTEEPROXYFORMATS_H__
+#define __DRMTEEPROXYFORMATS_H__ 1
+
+ENTER_PK_NAMESPACE;
+
+PREFAST_PUSH_DISABLE_EXPLAINED( __WARNING_POOR_DATA_ALIGNMENT_25021, "Ignore poor alignment of XBinary data structures" );
+
+#define DRM_TEE_PROXY_CURRENT_VERSION 1
+#define DRM_TEE_XB_PROXY_STACK_SIZE 1024
+#define DRM_TEE_STUB_STACK_SIZE_FOR_SYSINFO 168
+#define DRM_TEE_PROXY_MIN_STACK_SIZE_FOR_SYSINFO 1024
+#define DRM_TEE_PROXY_MAX_STACK_SIZE_FOR_SYSINFO 16384
+
+typedef enum __tagXB_DRM_TEE_PROXY_METHOD_REQ_TYPES 
+{
+    XB_DRM_TEE_REQ_METHOD_INFO_ENTRY_TYPE   = 0x1,
+    XB_DRM_TEE_CONTEXT_ENTRY_TYPE           = 0x2,
+    XB_DRM_DWORD_PARAMS_ENTRY_TYPE          = 0x3,
+    XB_DRM_ID_PARAMS_ENTRY_TYPE             = 0x4,
+    XB_DRM_QWORD_PARAMS_ENTRY_TYPE          = 0x5,
+    XB_DRM_TEE_BYTE_BLOB_PARAMS_ENTRY_TYPE  = 0x6,
+    XB_DRM_DWORDLIST_PARAMS_ENTRY_TYPE      = 0x7,
+    XB_DRM_QWORDLIST_PARAMS_ENTRY_TYPE      = 0x8,
+} XB_DRM_TEE_PROXY_METHOD_REQ_TYPES;
+/* Count Includes XB_OBJECT_GLOBAL_HEADER */
+#define XB_DRM_TEE_PROXY_METHOD_REQ_TYPE_COUNT       9
+#define XB_DRM_TEE_PROXY_METHOD_REQ_FORMAT_ID        XB_DEFINE_QWORD_FORMAT_ID( 'T', 'E', 'E', '_', 'M', 'R', 'E', 'Q' )
+
+typedef struct __tagXB_DRM_TEE_REQ_METHOD_INFO
+{
+    DRM_BOOL      fValid;
+    DRM_DWORD     dwMethodID;
+    DRM_DWORD     dwResult;
+} XB_DRM_TEE_REQ_METHOD_INFO;
+
+typedef struct __tagXB_DRM_TEE_CONTEXT
+{
+    DRM_BOOL             fValid;
+    DRM_XB_BYTEARRAY     xbbaContext;
+} XB_DRM_TEE_CONTEXT;
+
+typedef struct __tagXB_DRM_DWORD_PARAMS
+{
+    DRM_BOOL                         fValid;
+    struct __tagXB_DRM_DWORD_PARAMS *pNext;
+
+    DRM_DWORD                        dwParamIndex;
+    DRM_DWORD                        dwParamValue;
+} XB_DRM_DWORD_PARAMS;
+
+typedef struct __tagXB_DRM_ID_PARAMS
+{
+    DRM_BOOL                      fValid;
+    struct __tagXB_DRM_ID_PARAMS *pNext;
+
+    DRM_DWORD                     dwParamIndex;
+    DRM_ID                        idParamValue;
+} XB_DRM_ID_PARAMS;
+
+typedef struct __tagXB_DRM_QWORD_PARAMS
+{
+    DRM_BOOL                         fValid;
+    struct __tagXB_DRM_QWORD_PARAMS *pNext;
+
+    DRM_DWORD                        dwParamIndex;
+    DRM_UINT64                       qwParamValue;
+} XB_DRM_QWORD_PARAMS;
+
+typedef struct __tagXB_DRM_TEE_BYTE_BLOB_PARAMS
+{
+    DRM_BOOL                                 fValid;
+    struct __tagXB_DRM_TEE_BYTE_BLOB_PARAMS *pNext;
+
+    DRM_DWORD                                dwParamIndex;
+    DRM_DWORD                                eType;
+    DRM_DWORD                                dwSubType;
+    DRM_XB_BYTEARRAY                         xbbaData;
+} XB_DRM_TEE_BYTE_BLOB_PARAMS;
+
+typedef struct __tagXB_DRM_DWORDLIST_PARAMS
+{
+    DRM_BOOL                             fValid;
+    struct __tagXB_DRM_DWORDLIST_PARAMS *pNext;
+
+    DRM_DWORD                            dwParamIndex;
+    DRM_XB_DWORDLIST                     dwlParamValue;
+} XB_DRM_DWORDLIST_PARAMS;
+
+typedef struct __tagXB_DRM_QWORDLIST_PARAMS
+{
+    DRM_BOOL                             fValid;
+    struct __tagXB_DRM_QWORDLIST_PARAMS *pNext;
+
+    DRM_DWORD                            dwParamIndex;
+    DRM_XB_QWORDLIST                     qwlParamValue;
+} XB_DRM_QWORDLIST_PARAMS;
+
+typedef struct __tagXB_DRM_TEE_PROXY_METHOD_REQ
+{
+    DRM_BOOL                        fValid;
+    XB_DRM_TEE_REQ_METHOD_INFO      MethodInfo;
+    XB_DRM_TEE_CONTEXT              MethodContext;
+    XB_DRM_DWORD_PARAMS            *DwordParams;
+    XB_DRM_ID_PARAMS               *IdParams;
+    XB_DRM_QWORD_PARAMS            *QwordParams;
+    XB_DRM_TEE_BYTE_BLOB_PARAMS    *BlobParams;
+    XB_DRM_DWORDLIST_PARAMS        *DwordListParams;
+    XB_DRM_QWORDLIST_PARAMS        *QwordListParams;
+} XB_DRM_TEE_PROXY_METHOD_REQ;
+
+DRM_EXPORT_VAR extern DRM_GLOBAL_CONST DRM_XB_FORMAT_DESCRIPTION s_XB_DRM_TEE_PROXY_METHOD_REQ_FormatDescription[1];
+
+typedef enum __tagXB_DRM_TEE_PROXY_APPINFO_TYPES 
+{
+    XB_DRM_TEE_PROXY_APPINFO_BASE_INFO_ENTRY_TYPE  = 0x1,
+} XB_DRM_TEE_PROXY_APPINFO_TYPES;
+/* Count Includes XB_OBJECT_GLOBAL_HEADER */
+#define XB_DRM_TEE_PROXY_APPINFO_TYPE_COUNT       2
+#define XB_DRM_TEE_PROXY_APPINFO_FORMAT_ID        XB_DEFINE_QWORD_FORMAT_ID( 'T', 'E', 'E', '_', 'A', 'P', 'P', 'I' )
+
+typedef struct __tagXB_DRM_TEE_PROXY_APPINFO_BASE_INFO
+{
+    DRM_BOOL     fValid;
+    DRM_ID       idApplication;
+} XB_DRM_TEE_PROXY_APPINFO_BASE_INFO;
+
+typedef struct __tagXB_DRM_TEE_PROXY_APPINFO
+{
+    DRM_BOOL                               fValid;
+    XB_DRM_TEE_PROXY_APPINFO_BASE_INFO     BaseInfo;
+} XB_DRM_TEE_PROXY_APPINFO;
+
+DRM_EXPORT_VAR extern DRM_GLOBAL_CONST DRM_XB_FORMAT_DESCRIPTION s_XB_DRM_TEE_PROXY_APPINFO_FormatDescription[1];
+
+typedef enum __tagXB_DRM_TEE_PROXY_SYSINFO_TYPES 
+{
+    XB_DRM_TEE_PROXY_SYSINFO_BASE_INFO_ENTRY_TYPE  = 0x1,
+    XB_DRM_TEE_PROXY_SYSINFO_OEM_INFO_ENTRY_TYPE   = 0x2,
+    XB_DRM_TEE_PROXY_SYSINFO_OEM_INFO2_ENTRY_TYPE  = 0x3,
+} XB_DRM_TEE_PROXY_SYSINFO_TYPES;
+/* Count Includes XB_OBJECT_GLOBAL_HEADER */
+#define XB_DRM_TEE_PROXY_SYSINFO_TYPE_COUNT       4
+#define XB_DRM_TEE_PROXY_SYSINFO_FORMAT_ID        XB_DEFINE_QWORD_FORMAT_ID( 'T', 'E', 'E', '_', 'S', 'Y', 'S', 'I' )
+
+typedef struct __tagXB_DRM_TEE_PROXY_SYSINFO_BASE_INFO
+{
+    DRM_BOOL      fValid;
+    DRM_ID        idUnique;
+    DRM_DWORD     dwPKMajorVersion;
+    DRM_DWORD     dwPKMinorVersion;
+    DRM_DWORD     dwPKBuildVersion;
+    DRM_DWORD     dwPKQFEVersion;
+} XB_DRM_TEE_PROXY_SYSINFO_BASE_INFO;
+
+typedef struct __tagXB_DRM_TEE_PROXY_SYSINFO_OEM_INFO
+{
+    DRM_BOOL             fValid;
+    DRM_DWORD            dwVersion;
+    DRM_XB_BYTEARRAY     xbbaManufacturerName;
+    DRM_XB_BYTEARRAY     xbbaModelName;
+    DRM_XB_BYTEARRAY     xbbaModelNumber;
+    DRM_XB_DWORDLIST     dwlFunctionMap;
+    DRM_XB_BYTEARRAY     xbbaSystemProperties;
+} XB_DRM_TEE_PROXY_SYSINFO_OEM_INFO;
+
+typedef struct __tagXB_DRM_TEE_PROXY_SYSINFO_OEM_INFO2
+{
+    DRM_BOOL             fValid;
+    DRM_XB_BYTEARRAY     xbbaVersion2;
+} XB_DRM_TEE_PROXY_SYSINFO_OEM_INFO2;
+
+typedef struct __tagXB_DRM_TEE_PROXY_SYSINFO
+{
+    DRM_BOOL                               fValid;
+    XB_DRM_TEE_PROXY_SYSINFO_BASE_INFO     BaseInfo;
+    XB_DRM_TEE_PROXY_SYSINFO_OEM_INFO      OEMInfo;
+    XB_DRM_TEE_PROXY_SYSINFO_OEM_INFO2     OEMInfo2;
+} XB_DRM_TEE_PROXY_SYSINFO;
+
+DRM_EXPORT_VAR extern DRM_GLOBAL_CONST DRM_XB_FORMAT_DESCRIPTION s_XB_DRM_TEE_PROXY_SYSINFO_FormatDescription[1];
+
+PREFAST_POP;
+
+EXIT_PK_NAMESPACE;
+
+#endif /* __DRMTEEPROXYFORMATS_H__ */
diff --git a/prebuilt-v4.4/noarch/include/drmteeproxystructured.h b/prebuilt-v4.4/noarch/include/drmteeproxystructured.h
new file mode 100644
index 0000000..7c8fecc
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmteeproxystructured.h
@@ -0,0 +1,50 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#include <drmteetypes.h>
+#include <oemteetypes.h>
+
+#ifndef __DRMTEEPROXYSTRUCTURED_H__
+#define __DRMTEEPROXYSTRUCTURED_H__ 1
+
+PREFAST_PUSH_DISABLE_EXPLAINED( __WARNING_NONCONST_BUFFER_PARAM_25033, "Out params can't be const" )
+PREFAST_PUSH_DISABLE_EXPLAINED( __WARNING_NONCONST_PARAM_25004, "Out params can't be const" )
+
+ENTER_PK_NAMESPACE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_TEE_PROXY_StructuredMethodPreInvoke(
+    __in_opt                          const DRM_TEE_PROXY_SERIALIZATION_REQUIREMENTS    *f_pSerializationRequirements,
+    __in                                    DRM_DWORD                                    f_dwFunctionMapOEMValue,
+    __in_ecount( 1 )                        XB_DRM_TEE_PROXY_METHOD_REQ                 *f_pMethodRequest,
+    __inout_ecount( 1 )                     XB_DRM_TEE_PROXY_METHOD_REQ                 *f_pMethodResponse,
+    __in                                    DRM_DWORD                                    f_cbMethodResponse,
+    __out_bcount( f_cbMethodResponse )      DRM_BYTE                                    *f_pbMethodResponse,
+    __out                                   DRM_TEE_BYTE_BLOB                           *f_pReqMsg ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_TEE_PROXY_StructuredMethodPostInvoke(
+    __in_opt                          const DRM_TEE_PROXY_SERIALIZATION_REQUIREMENTS    *f_pSerializationRequirements,
+    __in                                    DRM_DWORD                                    f_dwFunctionMapOEMValue,
+    __inout_ecount( 1 )                     XB_DRM_TEE_PROXY_METHOD_REQ                 *f_pMethodResponse,
+    __in                                    DRM_DWORD                                    f_cbMethodResponse,
+    __out_bcount( f_cbMethodResponse )      DRM_BYTE                                    *f_pbMethodResponse,
+    __out_opt                               DRM_RESULT                                  *f_pdrResp ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_TEE_PROXY_StructuredMethodInvoke(
+    __in                                    DRM_TEE_PROXY_CONTEXT       *f_pTeeContext,
+    __in                                    DRM_DWORD                    f_dwFunctionMapOEMValue,
+    __in_ecount( 1 )                        XB_DRM_TEE_PROXY_METHOD_REQ *f_pMethodRequest,
+    __inout_ecount( 1 )                     XB_DRM_TEE_PROXY_METHOD_REQ *f_pMethodResponse,
+    __in                                    DRM_DWORD                    f_cbMethodResponse,
+    __out_bcount( f_cbMethodResponse )      DRM_BYTE                    *f_pbMethodResponse ) DRM_NO_INLINE_ATTRIBUTE;
+
+EXIT_PK_NAMESPACE;
+
+PREFAST_POP /* __WARNING_NONCONST_PARAM_25004 */
+PREFAST_POP /* __WARNING_NONCONST_BUFFER_PARAM_25033 */
+
+#endif /* __DRMTEEPROXYSTRUCTURED_H__ */
diff --git a/prebuilt-v4.4/noarch/include/drmteeproxystructuredcommon.h b/prebuilt-v4.4/noarch/include/drmteeproxystructuredcommon.h
new file mode 100644
index 0000000..e175e98
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmteeproxystructuredcommon.h
@@ -0,0 +1,181 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#include <drmteetypes.h>
+#include <oemteetypes.h>
+#include <drmteeproxystructureddefines.h>
+
+#ifndef __DRMTEEPROXYSTRUCTUREDCOMMON_H__
+#define __DRMTEEPROXYSTRUCTUREDCOMMON_H__ 1
+
+ENTER_PK_NAMESPACE;
+
+#define DRM_TEE_PROXY_ROUND_TO_XBYTE_BOUNDARY(align,ib) DRM_DO {    \
+    DRM_DWORD     _ib   = (ib);                                     \
+    DRM_DWORD     _mask = (align) - 1;                              \
+    DRMASSERT( DRM_IS_INTEGER_POWER_OF_TW0( align ) );              \
+    ChkDR( DRM_DWordAddSame( &_ib, _mask ) );                       \
+    (ib) = ( _ib & ( ~_mask ) );                                    \
+} DRM_WHILE_FALSE
+
+#define DRM_TEE_PROXY_ROUND_TO_8BYTE_BOUNDARY(ib) DRM_TEE_PROXY_ROUND_TO_XBYTE_BOUNDARY(8,ib)
+#define DRM_TEE_PROXY_ROUND_TO_4BYTE_BOUNDARY(ib) DRM_TEE_PROXY_ROUND_TO_XBYTE_BOUNDARY(4,ib)
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_TEE_PROXY_StartResponseSerialization(
+    __in                                                DRM_DWORD                    f_cbResponse,
+    __inout_bcount( f_cbResponse )                      DRM_BYTE                    *f_pbResponse,
+    __in                                                DRM_DWORD                    f_cOutputParams,
+    __in                                                DRM_DWORD                    f_dwOEMFunctionMapID ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_TEE_PROXY_FinishResponseSerialization(
+    __in                                                DRM_DWORD                    f_cbResponse,
+    __inout_bcount( f_cbResponse )                      DRM_BYTE                    *f_pbResponse,
+    __in                                                DRM_RESULT                   f_drResult ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_TEE_PROXY_GetMethodID(
+    __in                                                DRM_DWORD                    f_cbRequest,
+    __in_bcount( f_cbRequest )                    const DRM_BYTE                    *f_pbRequest,
+    __out_ecount( 1 )                                   DRM_DWORD                   *f_pdwOemMethodID ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_TEE_PROXY_AllocateResponseData(
+    __in                                                DRM_DWORD                    f_cbResponse,
+    __inout_bcount_part( f_cbResponse, f_cbResponse)    DRM_BYTE                    *f_pbResponse,
+    __in                                                DRM_DWORD                    f_cbData,
+    __deref_out_bcount_opt( f_cbData )                  DRM_BYTE                   **f_ppbData ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_TEE_PROXY_GetTeeContextArgByIndex(
+    __in                                                DRM_DWORD                    f_dwArgIndex,
+    __in                                                DRM_DWORD                    f_cbRequest,
+    __in_bcount( f_cbRequest )                    const DRM_BYTE                    *f_pbRequest,
+    __out                                               DRM_DWORD                   *f_pcbTeeCtx,
+    __deref_out_bcount( *f_pcbTeeCtx )                  DRM_BYTE                   **f_ppbTeeCtx ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_TEE_PROXY_AllocateTeeContextArgByIndex(
+    __in                                                DRM_DWORD                    f_dwArgIndex,
+    __in                                                DRM_DWORD                    f_cbResponse,
+    __inout_bcount_part( f_cbResponse, f_cbResponse)    DRM_BYTE                    *f_pbResponse,
+    __in                                                DRM_DWORD                    f_cbTeeCtx,
+    __deref_out_bcount_opt( f_cbTeeCtx )                DRM_BYTE                   **f_ppbTeeCtx ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_TEE_PROXY_SetTeeContextArgByIndex(
+    __in                                                DRM_DWORD                    f_dwArgIndex,
+    __in                                                DRM_DWORD                    f_cbResponse,
+    __inout_bcount( f_cbResponse )                      DRM_BYTE                    *f_pbResponse,
+    __in                                                DRM_DWORD                    f_cbTeeCtx,
+    __in_bcount_opt( f_cbTeeCtx )                 const DRM_BYTE                    *f_pbTeeCtx ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_TEE_PROXY_GetBlobArgByIndex(
+    __in                                                DRM_DWORD                    f_dwArgIndex,
+    __in                                                DRM_DWORD                    f_cbRequest,
+    __in_bcount( f_cbRequest )                    const DRM_BYTE                    *f_pbRequest,
+    __out_opt                                           DRM_DWORD                   *f_pdwType,
+    __out_opt                                           DRM_DWORD                   *f_pdwSubType,
+    __out                                               DRM_DWORD                   *f_pcbBlob,
+    __deref_out_bcount_opt( *f_pcbBlob )                DRM_BYTE                   **f_ppbBlob ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_TEE_PROXY_AllocateBlobArgByIndex(
+    __in                                                DRM_DWORD                    f_dwArgIndex,
+    __in                                                DRM_DWORD                    f_cbResponse,
+    __inout_bcount_part( f_cbResponse, f_cbResponse)    DRM_BYTE                    *f_pbResponse,
+    __in                                                DRM_DWORD                    f_dwType,
+    __in                                                DRM_DWORD                    f_dwSubType,
+    __in                                                DRM_DWORD                    f_cbBlob,
+    __deref_out_bcount_opt( f_cbBlob )                  DRM_BYTE                   **f_ppbBlob ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_TEE_PROXY_SetBlobArgByIndex(
+    __in                                                DRM_DWORD                    f_dwArgIndex,
+    __in                                                DRM_DWORD                    f_cbResponse,
+    __inout_bcount( f_cbResponse )                      DRM_BYTE                    *f_pbResponse,
+    __in                                                DRM_DWORD                    f_dwType,
+    __in                                                DRM_DWORD                    f_dwSubType,
+    __in                                                DRM_DWORD                    f_cbBlob,
+    __in_bcount_opt( f_cbBlob )                   const DRM_BYTE                    *f_pbBlob ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_TEE_PROXY_GetIDArgByIndex(
+    __in                                                DRM_DWORD                    f_dwArgIndex,
+    __in                                                DRM_DWORD                    f_cbRequest,
+    __in_bcount( f_cbRequest )                    const DRM_BYTE                    *f_pbRequest,
+    __out_ecount( 1 )                                   DRM_ID                      *f_pidArgValue ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_TEE_PROXY_SetIDArgByIndex(
+    __in                                                DRM_DWORD                    f_dwArgIndex,
+    __in                                                DRM_DWORD                    f_cbResponse,
+    __inout_bcount( f_cbResponse )                      DRM_BYTE                    *f_pbResponse,
+    __in                                                DRM_ID                       f_idArgValue ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_TEE_PROXY_GetDwordArgByIndex(
+    __in                                                DRM_DWORD                    f_dwArgIndex,
+    __in                                                DRM_DWORD                    f_cbRequest,
+    __in_bcount( f_cbRequest )                    const DRM_BYTE                    *f_pbRequest,
+    __out_ecount( 1 )                                   DRM_DWORD                   *f_pdwArgValue ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_TEE_PROXY_SetDwordArgByIndex(
+    __in                                                DRM_DWORD                    f_dwArgIndex,
+    __in                                                DRM_DWORD                    f_cbResponse,
+    __inout_bcount( f_cbResponse )                      DRM_BYTE                    *f_pbResponse,
+    __in                                                DRM_DWORD                    f_dwArgValue ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_TEE_PROXY_GetQwordArgByIndex(
+    __in                                                DRM_DWORD                    f_dwArgIndex,
+    __in                                                DRM_DWORD                    f_cbRequest,
+    __in_bcount( f_cbRequest )                    const DRM_BYTE                    *f_pbRequest,
+    __out_ecount( 1 )                                   DRM_UINT64                  *f_pqwArgValue ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_TEE_PROXY_SetQwordArgByIndex(
+    __in                                                DRM_DWORD                    f_dwArgIndex,
+    __in                                                DRM_DWORD                    f_cbResponse,
+    __inout_bcount( f_cbResponse )                      DRM_BYTE                    *f_pbResponse,
+    __in                                                DRM_UINT64                   f_qwArgValue ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_TEE_PROXY_GetDwordListArgByIndex(
+    __in                                                DRM_DWORD                    f_dwArgIndex,
+    __in                                                DRM_DWORD                    f_cbRequest,
+    __in_bcount( f_cbRequest )                    const DRM_BYTE                    *f_pbRequest,
+    __out                                               DRM_DWORD                   *f_pcdwDWL,
+    __deref_out_ecount( *f_pcdwDWL )                    DRM_DWORD                  **f_ppdwDWL ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_TEE_PROXY_AllocateDwordListArgByIndex(
+    __in                                                DRM_DWORD                    f_dwArgIndex,
+    __in                                                DRM_DWORD                    f_cbResponse,
+    __inout_bcount_part( f_cbResponse, f_cbResponse)    DRM_BYTE                    *f_pbResponse,
+    __out_opt                                           DRM_DWORD                   *f_pibParam,
+    __in                                                DRM_DWORD                    f_cdwDWL,
+    __deref_out_ecount_opt( f_cdwDWL )                  DRM_DWORD                  **f_ppdwDWL ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_TEE_PROXY_SetDwordListArgByIndex(
+    __in                                                DRM_DWORD                    f_dwArgIndex,
+    __in                                                DRM_DWORD                    f_cbResponse,
+    __inout_bcount( f_cbResponse )                      DRM_BYTE                    *f_pbResponse,
+    __in                                                DRM_DWORD                    f_cdwDWL,
+    __in_ecount_opt( f_cdwDWL )                   const DRM_DWORD                   *f_pdwDWL ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_TEE_PROXY_GetQwordListArgByIndex(
+    __in                                                DRM_DWORD                    f_dwArgIndex,
+    __in                                                DRM_DWORD                    f_cbRequest,
+    __in_bcount( f_cbRequest )                    const DRM_BYTE                    *f_pbRequest,
+    __out                                               DRM_DWORD                   *f_pcqwQWL,
+    __deref_out_ecount( *f_pcqwQWL )                    DRM_UINT64                 **f_ppqwQWL ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_TEE_PROXY_AllocateQwordListArgByIndex(
+    __in                                                DRM_DWORD                    f_dwArgIndex,
+    __in                                                DRM_DWORD                    f_cbResponse,
+    __inout_bcount_part( f_cbResponse, f_cbResponse )   DRM_BYTE                    *f_pbResponse,
+    __out_opt                                           DRM_DWORD                   *f_pibParam,
+    __in                                                DRM_DWORD                    f_cqwQWL,
+    __deref_out_ecount_opt( f_cqwQWL )                  DRM_UINT64                 **f_ppqwQWL ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_TEE_PROXY_SetQwordListArgByIndex(
+    __in                                                DRM_DWORD                    f_dwArgIndex,
+    __in                                                DRM_DWORD                    f_cbResponse,
+    __inout_bcount( f_cbResponse )                      DRM_BYTE                    *f_pbResponse,
+    __in                                                DRM_DWORD                    f_cqwQWL,
+    __in_ecount_opt( f_cqwQWL )                   const DRM_UINT64                  *f_pqwQWL ) DRM_NO_INLINE_ATTRIBUTE;
+
+EXIT_PK_NAMESPACE;
+
+#endif /* __DRMTEEPROXYSTRUCTUREDCOMMON_H__ */
diff --git a/prebuilt-v4.4/noarch/include/drmteeproxystructureddefines.h b/prebuilt-v4.4/noarch/include/drmteeproxystructureddefines.h
new file mode 100644
index 0000000..1d9a0a3
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmteeproxystructureddefines.h
@@ -0,0 +1,137 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#include <drmteetypes.h>
+#include <oemteetypes.h>
+
+#ifndef __DRMTEEPROXYSTRUCTUREDDEFINES_H__
+#define __DRMTEEPROXYSTRUCTUREDDEFINES_H__ 1
+
+ENTER_PK_NAMESPACE;
+
+#define DRM_TEE_PROXY_STRUCTURED_SERIALIZER_VERSION 1
+
+#define DRM_TEE_PROXY_STRUCTURED_MARKER() XB_DEFINE_FOUR_BYTE_FORMAT_ID('P','R','X','Y')
+
+typedef enum __tagDRM_TEE_PROXY_PARAM_TYPE
+{
+    DRM_TEE_PROXY_TYPE_CONTEXT     = 1,
+    DRM_TEE_PROXY_TYPE_DWORD       = 2,
+    DRM_TEE_PROXY_TYPE_QWORD       = 3,
+    DRM_TEE_PROXY_TYPE_ID          = 4,
+    DRM_TEE_PROXY_TYPE_BLOB        = 5,
+    DRM_TEE_PROXY_TYPE_DWORDLIST   = 6,
+    DRM_TEE_PROXY_TYPE_QWORDLIST   = 7,
+} DRM_TEE_PROXY_PARAM_TYPE;
+
+/*
+** The serialized message has a header with the following data
+**      DRM_DWORD dwMarker;     // This is a marker used to indicate this buffer is a valid serialized buffer.
+**      DRM_DWORD dwVersion;    // The version of the serializer that created the message buffer.
+**      DRM_DWORD dwMethodID;   // The OEM defined method ID of the PRITEE method invocation.
+**      DRM_DWORD dwResult;     // This will hold the result of the PRITEE method invocation.
+**      DRM_DWORD cParamters;   // This is the count of parameters included in the response/request message.
+**      DRM_DWORD dwReserved;   // This is used for internal use.
+*/
+#define DRM_TEE_PROXY_METHOD_REQUEST_HEADER_SIZE       (sizeof(DRM_DWORD) * 6)
+#define DRM_TEE_PROXY_METHOD_REQUEST__MARKER_OFFSET    (sizeof(DRM_DWORD) * 0)
+#define DRM_TEE_PROXY_METHOD_REQUEST__VERSION_OFFSET   (sizeof(DRM_DWORD) * 1)
+#define DRM_TEE_PROXY_METHOD_REQUEST__METHOD_ID_OFFSET (sizeof(DRM_DWORD) * 2)
+#define DRM_TEE_PROXY_METHOD_REQUEST__RESULT_OFFSET    (sizeof(DRM_DWORD) * 3)
+#define DRM_TEE_PROXY_METHOD_REQUEST__CPARAMS_OFFSET   (sizeof(DRM_DWORD) * 4)
+#define DRM_TEE_PROXY_METHOD_REQUEST__RESERVED_OFFSET  (sizeof(DRM_DWORD) * 5)
+
+/*
+** All serialized parameter types have the following structure.  The TEE Context and Blob parameters will have
+** additional data at the end of the message.  This data is referenced by the ibData/cbData fields.
+**
+**   struct
+**   {
+**      DRM_DWORD  dwParamType;    // The type of paramter used.
+**      DRM_DWORD  dwParamIdx;     // The index of the parameter in the PRITE method call.
+**
+**      union
+**      {
+**          DRM_DWORD dwValue;
+**          DRM_QWORD qwValue;
+**          DRM_ID    idValue;
+**
+**          struct
+**          {
+**              DRM_DWORD cbData;
+**              DRM_DWORD ibData;
+**          } oTeeCtx;
+**
+**          struct
+**          {
+**              DRM_DWORD dwType;
+**              DRM_DWORD dwSubType;
+**              DRM_DWORD cbData;
+**              DRM_DWORD ibData;
+**          } oBlob;
+**
+**          struct
+**          {
+**              DRM_DWORD cdwData;
+**              DRM_DWORD ibData;
+**              DRM_DWORD dwFlags;
+**          } oDwordList;
+**
+**          struct
+**          {
+**              DRM_DWORD cqwData;
+**              DRM_DWORD ibData;
+**              DRM_DWORD dwFlags;
+**          } oQwordList;
+**      } oData;
+**   } DRM_TEE_PROXY_STRUCTURE_PARAMETER;
+*/
+#define DRM_TEE_PROXY_PARAMETER_TYPE_SIZE                    (sizeof(DRM_DWORD) * 6)
+#define DRM_TEE_PROXY_PARAMETER_TYPE__TYPE_OFFSET            (sizeof(DRM_DWORD) * 0)
+#define DRM_TEE_PROXY_PARAMETER_TYPE__PARAMINDEX_OFFSET      (sizeof(DRM_DWORD) * 1)
+#define DRM_TEE_PROXY_PARAMETER_TYPE__DWVALUE_OFFSET         (sizeof(DRM_DWORD) * 2)
+#define DRM_TEE_PROXY_PARAMETER_TYPE__QWVALUE_OFFSET         (sizeof(DRM_DWORD) * 2)
+#define DRM_TEE_PROXY_PARAMETER_TYPE__IDVALUE_OFFSET         (sizeof(DRM_DWORD) * 2)
+#define DRM_TEE_PROXY_PARAMETER_TYPE__TEECTX_CB_OFFSET       (sizeof(DRM_DWORD) * 2)
+#define DRM_TEE_PROXY_PARAMETER_TYPE__TEECTX_IB_OFFSET       (sizeof(DRM_DWORD) * 3)
+#define DRM_TEE_PROXY_PARAMETER_TYPE__BLOB_TYPE_OFFSET       (sizeof(DRM_DWORD) * 2)
+#define DRM_TEE_PROXY_PARAMETER_TYPE__BLOB_SUBTYPE_OFFSET    (sizeof(DRM_DWORD) * 3)
+#define DRM_TEE_PROXY_PARAMETER_TYPE__BLOB_CB_OFFSET         (sizeof(DRM_DWORD) * 4)
+#define DRM_TEE_PROXY_PARAMETER_TYPE__BLOB_IB_OFFSET         (sizeof(DRM_DWORD) * 5)
+#define DRM_TEE_PROXY_PARAMETER_TYPE__DWORDLIST_CDW_OFFSET   (sizeof(DRM_DWORD) * 2)
+#define DRM_TEE_PROXY_PARAMETER_TYPE__DWORDLIST_IB_OFFSET    (sizeof(DRM_DWORD) * 3)
+#define DRM_TEE_PROXY_PARAMETER_TYPE__DWORDLIST_FLAG_OFFSET  (sizeof(DRM_DWORD) * 4)
+#define DRM_TEE_PROXY_PARAMETER_TYPE__QWORDLIST_CQW_OFFSET   (sizeof(DRM_DWORD) * 2)
+#define DRM_TEE_PROXY_PARAMETER_TYPE__QWORDLIST_IB_OFFSET    (sizeof(DRM_DWORD) * 3)
+#define DRM_TEE_PROXY_PARAMETER_TYPE__QWORDLIST_FLAG_OFFSET  (sizeof(DRM_DWORD) * 4)
+
+typedef enum __tagDRM_TEE_PROXY_DWORDLIST_FLAG
+{
+    DRM_TEE_PROXY_DWORDLIST_FLAG_NONE      = 0,
+    DRM_TEE_PROXY_DWORDLIST_FLAG_BIGENDIAN = 1,
+} DRM_TEE_PROXY_DWORDLIST_FLAG;
+
+typedef enum __tagDRM_TEE_PROXY_QWORDLIST_FLAG
+{
+    DRM_TEE_PROXY_QWORDLIST_FLAG_NONE      = 0,
+    DRM_TEE_PROXY_QWORDLIST_FLAG_BIGENDIAN = 1,
+} DRM_TEE_PROXY_QWORDLIST_FLAG;
+
+#define DRM_TEE_PROXY_IS_VALID_MESSAGE( cb, pb ) DRM_DO {                                                            \
+    DRM_DWORD _dwTmp = 0;                                                                                            \
+    ChkBOOL( (pb) != NULL, DRM_E_TEE_PROXY_INVALID_SERIALIZATION_MESSAGE );                                          \
+    ChkBOOL( (cb) > DRM_TEE_PROXY_METHOD_REQUEST_HEADER_SIZE, DRM_E_TEE_PROXY_INVALID_SERIALIZATION_MESSAGE );       \
+    NETWORKBYTES_TO_DWORD( _dwTmp, (pb), DRM_TEE_PROXY_METHOD_REQUEST__MARKER_OFFSET);                               \
+    ChkBOOL( _dwTmp == DRM_TEE_PROXY_STRUCTURED_MARKER(), DRM_E_TEE_PROXY_INVALID_SERIALIZATION_MESSAGE );           \
+    NETWORKBYTES_TO_DWORD( _dwTmp, (pb), DRM_TEE_PROXY_METHOD_REQUEST__VERSION_OFFSET);                              \
+    ChkBOOL( _dwTmp == DRM_TEE_PROXY_STRUCTURED_SERIALIZER_VERSION, DRM_E_TEE_PROXY_INVALID_SERIALIZATION_MESSAGE ); \
+} DRM_WHILE_FALSE
+
+EXIT_PK_NAMESPACE;
+
+#endif /* __DRMTEEPROXYSTRUCTUREDDEFINES_H__ */
diff --git a/prebuilt-v4.4/noarch/include/drmteeproxystubcommon.h b/prebuilt-v4.4/noarch/include/drmteeproxystubcommon.h
new file mode 100644
index 0000000..7e4a1e3
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmteeproxystubcommon.h
@@ -0,0 +1,198 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef _DRMTEEPROXYSTUBCOMMON_H_
+#define _DRMTEEPROXYSTUBCOMMON_H_ 1
+
+#include <drmtypes.h>
+
+ENTER_PK_NAMESPACE;
+
+#define DRM_TEE_PROXY_MESSAGE_RESPONSE_OVERHEAD 1024
+#define DRM_TEE_PROXY_MESSAGE_OVERHEAD_MIN      128
+#define DRM_TEE_PROXY_MAX_MESSAGE_SIZE_DEFAULT  (12 * 1024)
+
+/*
+** IMPORTANT IMPORTANT IMPORTANT IMPORTANT IMPORTANT IMPORTANT IMPORTANT IMPORTANT
+**
+** All values in this enum MUST be referenced by OEM_TEE_BASE_GetVersionInformation.
+** When this enum changes, the following MUST be updated:
+**  DRM_METHOD_ID_DRM_TEE_Count
+**  OEM_TEE_BASE_GetVersionInformation
+**  Any test cases that do verification of this data.
+** This enum MUST not be changed without a firmware update to match.
+**
+** IMPORTANT IMPORTANT IMPORTANT IMPORTANT IMPORTANT IMPORTANT IMPORTANT IMPORTANT
+*/
+typedef enum _tagDRM_METHOD_ID_DRM_TEE
+{
+    /*
+    ** The following enum value DRM_METHOD_ID_DRM_TEE_BASE_AllocTEEContext
+    ** is a fixed value and must not change.
+    */
+    DRM_METHOD_ID_DRM_TEE_BASE_AllocTEEContext                                  = 0,
+
+    /* Value to indicate the start of the IDs with OEM function map values */
+    DRM_METHOD_ID_START_OF_OEM_FUNCTION_MAPPED_IDS                              = 1,
+
+    DRM_METHOD_ID_DRM_TEE_BASE_FreeTEEContext                                   = 1,
+    DRM_METHOD_ID_DRM_TEE_BASE_SignDataWithSecureStoreKey                       = 2,
+    DRM_METHOD_ID_DRM_TEE_BASE_CheckDeviceKeys                                  = 3,
+    DRM_METHOD_ID_DRM_TEE_BASE_GetDebugInformation                              = 4,
+    DRM_METHOD_ID_DRM_TEE_BASE_GenerateNonce                                    = 5,
+    DRM_METHOD_ID_DRM_TEE_BASE_GetSystemTime                                    = 6,
+    DRM_METHOD_ID_DRM_TEE_LPROV_GenerateDeviceKeys                              = 7,
+    DRM_METHOD_ID_DRM_TEE_RPROV_GenerateBootstrapChallenge                      = 8,
+    DRM_METHOD_ID_DRM_TEE_RPROV_ProcessBootstrapResponse                        = 9,
+    DRM_METHOD_ID_DRM_TEE_RPROV_GenerateProvisioningRequest                     = 10,
+    DRM_METHOD_ID_DRM_TEE_RPROV_ProcessProvisioningResponse                     = 11,
+    DRM_METHOD_ID_DRM_TEE_LICPREP_PackageKey                                    = 12,
+    DRM_METHOD_ID_DRM_TEE_SAMPLEPROT_PrepareSampleProtectionKey                 = 13,
+    DRM_METHOD_ID_DRM_TEE_DECRYPT_PreparePolicyInfo                             = 14,   /* Formerly DRM_METHOD_ID_DRM_TEE_AES128CTR_PreparePolicyInfo     */
+    DRM_METHOD_ID_DRM_TEE_DECRYPT_PrepareToDecrypt                              = 15,   /* Formerly DRM_METHOD_ID_DRM_TEE_AES128CTR_PrepareToDecrypt      */
+    DRM_METHOD_ID_DRM_TEE_DECRYPT_CreateOEMBlobFromCDKB                         = 16,   /* Formerly DRM_METHOD_ID_DRM_TEE_AES128CTR_CreateOEMBlobFromCDKB */
+    DRM_METHOD_ID_DRM_TEE_AES128CTR_DecryptContent                              = 17,
+    DRM_METHOD_ID_DRM_TEE_SIGN_SignHash                                         = 18,
+    DRM_METHOD_ID_DRM_TEE_DOM_PackageKeys                                       = 19,
+    DRM_METHOD_ID_DRM_TEE_RESERVED_20                                           = 20,   /* No longer supported.  Was DRM_METHOD_ID_DRM_TEE_PRNDRX_ProcessRegistrationResponseMessage */
+    DRM_METHOD_ID_DRM_TEE_RESERVED_21                                           = 21,   /* No longer supported.  Was DRM_METHOD_ID_DRM_TEE_PRNDRX_GenerateProximityResponseNonce     */
+    DRM_METHOD_ID_DRM_TEE_RESERVED_22                                           = 22,   /* No longer supported.  Was DRM_METHOD_ID_DRM_TEE_PRNDRX_CompleteLicenseRequestMessage      */
+    DRM_METHOD_ID_DRM_TEE_RESERVED_23                                           = 23,   /* No longer supported.  Was DRM_METHOD_ID_DRM_TEE_PRNDRX_ProcessLicenseTransmitMessage      */
+    DRM_METHOD_ID_DRM_TEE_REVOCATION_IngestRevocationInfo                       = 24,
+    DRM_METHOD_ID_DRM_TEE_LICGEN_CompleteLicense                                = 25,
+    DRM_METHOD_ID_DRM_TEE_LICGEN_AES128CTR_EncryptContent                       = 26,
+    DRM_METHOD_ID_DRM_TEE_RESERVED_27                                           = 27,   /* No longer supported.  Was DRM_METHOD_ID_DRM_TEE_PRNDTX_ProcessRegistrationRequestMessage        */
+    DRM_METHOD_ID_DRM_TEE_RESERVED_28                                           = 28,   /* No longer supported.  Was DRM_METHOD_ID_DRM_TEE_PRNDTX_CompleteRegistrationResponseMessage      */
+    DRM_METHOD_ID_DRM_TEE_RESERVED_29                                           = 29,   /* No longer supported.  Was DRM_METHOD_ID_DRM_TEE_PRNDTX_GenerateProximityDetectionChallengeNonce */
+    DRM_METHOD_ID_DRM_TEE_RESERVED_30                                           = 30,   /* No longer supported.  Was DRM_METHOD_ID_DRM_TEE_PRNDTX_VerifyProximityDetectionResponseNonce    */
+    DRM_METHOD_ID_DRM_TEE_RESERVED_31                                           = 31,   /* No longer supported.  Was DRM_METHOD_ID_DRM_TEE_PRNDTX_ProcessLicenseRequestMessage             */
+    DRM_METHOD_ID_DRM_TEE_RESERVED_32                                           = 32,   /* No longer supported.  Was DRM_METHOD_ID_DRM_TEE_PRNDTX_CompleteLicenseTransmitMessage           */
+    DRM_METHOD_ID_DRM_TEE_RESERVED_33                                           = 33,   /* No longer supported.  Was DRM_METHOD_ID_DRM_TEE_PRNDTX_RebindLicenseToReceiver                  */
+    DRM_METHOD_ID_DRM_TEE_H264_PreProcessEncryptedData                          = 34,
+    DRM_METHOD_ID_DRM_TEE_SECURESTOP_GetGenerationID                            = 35,
+    DRM_METHOD_ID_DRM_TEE_AES128CTR_DecryptAudioContentMultiple                 = 36,
+    DRM_METHOD_ID_DRM_TEE_SECURETIME_GenerateChallengeData                      = 37,
+    DRM_METHOD_ID_DRM_TEE_SECURETIME_ProcessResponseData                        = 38,
+    DRM_METHOD_ID_DRM_TEE_AES128CTR_DecryptContentMultiple                      = 39,
+    DRM_METHOD_ID_DRM_TEE_AES128CBC_DecryptContentMultiple                      = 40,
+    DRM_METHOD_ID_DRM_TEE_SECURESTOP2_GetSigningKeyBlob                         = 41,
+    DRM_METHOD_ID_DRM_TEE_SECURESTOP2_SignChallenge                             = 42,
+    DRM_METHOD_ID_DRM_TEE_BASE_GetFeatureInformation                            = 43,
+    DRM_METHOD_ID_DRM_TEE_Count                                                 = 44,
+
+    DRM_METHOD_ID_RESERVED0                                                     = 0x000F0000,
+    DRM_METHOD_ID_RESERVED1                                                     = 0x000F0001,
+    DRM_METHOD_ID_RESERVED2                                                     = 0x000F0002,
+    DRM_METHOD_ID_RESERVED3                                                     = 0x000F0003,
+    DRM_METHOD_ID_RESERVED4                                                     = 0x000F0004,
+    DRM_METHOD_ID_RESERVED5                                                     = 0x000F0005,
+
+} DRM_METHOD_ID_DRM_TEE;
+
+#define DRM_TEE_PROXY_METHOD_ID(m) DRM_METHOD_ID_##m
+
+/* Only certain methods support structured serialization. */
+#define DRM_METHOD_ID_DRM_TEE_SUPPORTS_STRUCTURE_SERIALIZATION( eID )               \
+    ( ( ( eID ) == DRM_METHOD_ID_DRM_TEE_H264_PreProcessEncryptedData          )    \
+   || ( ( eID ) == DRM_METHOD_ID_DRM_TEE_AES128CTR_DecryptAudioContentMultiple )    \
+   || ( ( eID ) == DRM_METHOD_ID_DRM_TEE_AES128CTR_DecryptContent              )    \
+   || ( ( eID ) == DRM_METHOD_ID_DRM_TEE_AES128CTR_DecryptContentMultiple      )    \
+   || ( ( eID ) == DRM_METHOD_ID_DRM_TEE_AES128CBC_DecryptContentMultiple      ) )
+
+/*
+** All TEE APIs should generate a request/response message with a size no bigger than
+** OEM_TEE_PROXY_MAX_PRITEE_MESSAGE_SIZE (defined in oemteeproxy.h).  The only exceptions
+** are the methods below until either TEE shared memory support is added
+** or structured serialization is only allowed for these functions.
+*/
+#define DRM_TEE_PROXY_METHOD_IS_MESSAGE_SIZE_EXCEPTIONS(eMethodID)                      \
+     ( ( (eMethodID) == DRM_METHOD_ID_DRM_TEE_H264_PreProcessEncryptedData          )   \
+    || ( (eMethodID) == DRM_METHOD_ID_DRM_TEE_AES128CTR_DecryptContent              )   \
+    || ( (eMethodID) == DRM_METHOD_ID_DRM_TEE_AES128CTR_DecryptAudioContentMultiple )   \
+    || ( (eMethodID) == DRM_METHOD_ID_DRM_TEE_AES128CTR_DecryptContentMultiple      )   \
+    || ( (eMethodID) == DRM_METHOD_ID_DRM_TEE_AES128CBC_DecryptContentMultiple      )   \
+    || ( (eMethodID) == DRM_METHOD_ID_DRM_TEE_LICGEN_AES128CTR_EncryptContent       ) )
+
+#define DRM_TEE_PROXY_PARAMETER_TYPE__INVALID               ( ( DRM_DWORD ) -1 )
+#define DRM_TEE_PROXY_PARAMETER_TYPE__DRM_DWORD             ( ( DRM_DWORD ) 0  )
+#define DRM_TEE_PROXY_PARAMETER_TYPE__DRM_QWORD             ( ( DRM_DWORD ) 1  )
+#define DRM_TEE_PROXY_PARAMETER_TYPE__DRM_ID                ( ( DRM_DWORD ) 2  )
+#define DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_BYTE_BLOB     ( ( DRM_DWORD ) 3  )
+#define DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_DWORDLIST     ( ( DRM_DWORD ) 4  )
+#define DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_QWORDLIST     ( ( DRM_DWORD ) 5  )
+
+typedef DRM_DWORD DRM_TEE_PROXY_PARAMETER_TYPE;
+
+/*
+** The function map does not include the fixed method ID value for DRM_TEE_BASE_AllocTEEContext.
+*/
+#define DRM_TEE_METHOD_FUNCTION_MAP_COUNT ((DRM_DWORD)((DRM_METHOD_ID_DRM_TEE_Count - DRM_METHOD_ID_START_OF_OEM_FUNCTION_MAPPED_IDS) * 2 ))
+
+
+#define DRM_TEE_PROXY_BIT_USE_STRUCT_PARAMS     ((DRM_DWORD)0x80000000)
+#define DRM_TEE_PROXY_BIT_RESERVED_7            ((DRM_DWORD)0x40000000)
+#define DRM_TEE_PROXY_BIT_API_UNSUPPORTED       ((DRM_DWORD)0x20000000)
+#define DRM_TEE_PROXY_BIT_RESERVED_5            ((DRM_DWORD)0x10000000)
+#define DRM_TEE_PROXY_BIT_RESERVED_4            ((DRM_DWORD)0x08000000)
+#define DRM_TEE_PROXY_BIT_RESERVED_FOR_MF_1     ((DRM_DWORD)0x04000000)
+#define DRM_TEE_PROXY_BIT_RESERVED_2            ((DRM_DWORD)0x02000000)
+#define DRM_TEE_PROXY_BIT_RESERVED_1            ((DRM_DWORD)0x01000000)
+
+/*
+** The OEM is only allowed to set certain bits.
+*/
+#define DRM_TEE_PROXY_BITS_OEM_MASK             ((DRM_DWORD)( 0x00FFFFFF ))
+#define DRM_TEE_PROXY_BITS_OEM_ALLOWED          ((DRM_DWORD)( DRM_TEE_PROXY_BITS_OEM_MASK | DRM_TEE_PROXY_BIT_USE_STRUCT_PARAMS | DRM_TEE_PROXY_BIT_API_UNSUPPORTED ))
+
+#define DRM_TEE_PROXY_SHOULD_USE_STRUCT_PARAMS( dwFunctionMapOEMValue )     ( ( (DRM_DWORD)( (dwFunctionMapOEMValue) & DRM_TEE_PROXY_BIT_USE_STRUCT_PARAMS ) != 0 ) )
+#define DRM_TEE_PROXY_RESERVED_FOR_MF_1( dwFunctionMapOEMValue )            ( ( (DRM_DWORD)( (dwFunctionMapOEMValue) & DRM_TEE_PROXY_BIT_RESERVED_FOR_MF_1 ) != 0 ) )
+
+/*
+** An API is supported if (and only if) it is supported in both user mode AND it is available inside TEE.
+** Non-OEM mapped IDs are ALWAYS supported.
+*/
+#define DRM_TEE_PROXY_IS_FUNCTION_SUPPORTED_VIA_MAP( _rgdwFunctionMap, _eMethodID, _pIsSupported ) DRM_DO {                             \
+    DRM_BOOL                *_pSupported  = ( _pIsSupported );                                                                          \
+    DRM_METHOD_ID_DRM_TEE    _id          = ( _eMethodID );                                                                             \
+    *_pSupported = FALSE;                                                                                                               \
+    if( _id < DRM_METHOD_ID_START_OF_OEM_FUNCTION_MAPPED_IDS )                                                                          \
+    {                                                                                                                                   \
+        *_pSupported = TRUE;                                                                                                            \
+    }                                                                                                                                   \
+    else                                                                                                                                \
+    {                                                                                                                                   \
+        const DRM_DWORD *_macroMap = ( _rgdwFunctionMap );                                                                              \
+        DRM_DWORD  _macroIdx;                                                                                                           \
+        for( _macroIdx = 0; _macroIdx < DRM_METHOD_ID_DRM_TEE_Count - DRM_METHOD_ID_START_OF_OEM_FUNCTION_MAPPED_IDS; _macroIdx++ )     \
+        {                                                                                                                               \
+            if( _macroMap[ _macroIdx * 2 ] == ((DRM_DWORD)_id) )                                                                        \
+            {                                                                                                                           \
+                if( ( _macroMap[ _macroIdx * 2 + 1 ] & DRM_TEE_PROXY_BIT_API_UNSUPPORTED ) == 0 )                                       \
+                {                                                                                                                       \
+                    *_pSupported = TRUE;                                                                                                \
+                }                                                                                                                       \
+                break;                                                                                                                  \
+            }                                                                                                                           \
+        }                                                                                                                               \
+    }                                                                                                                                   \
+} DRM_WHILE_FALSE
+
+#define DRM_TEE_PROXY_IS_FUNCTION_SUPPORTED( _pTeeCtx, _dwFunctionMapPKValue, _pIsSupported )      DRM_TEE_PROXY_IS_FUNCTION_SUPPORTED_VIA_MAP( ( _pTeeCtx )->oOEMVersionInfo.rgdwFunctionMap, ( _dwFunctionMapPKValue ), ( _pIsSupported ) )
+
+#define DRM_TEE_PROXY_GET_STRUCT_PARAMS_METHOD_ID( dwFunctionMapOEMValue ) ( (DRM_DWORD)( (dwFunctionMapOEMValue) & DRM_TEE_PROXY_BITS_OEM_MASK ) )
+
+#define DRM_TEE_IS_8_BYTE_ALIGNED(x) (0 == ( (DRM_SIZE_T)(x) & (DRM_SIZE_T)7))
+#define DRM_TEE_IS_4_BYTE_ALIGNED(x) (0 == ( (DRM_SIZE_T)(x) & (DRM_SIZE_T)3))
+
+#define Chk8ByteAligned(expr) ChkBOOL( DRM_TEE_IS_8_BYTE_ALIGNED(expr), DRM_E_TEE_PROXY_INVALID_ALIGNMENT )
+#define Chk4ByteAligned(expr) ChkBOOL( DRM_TEE_IS_4_BYTE_ALIGNED(expr), DRM_E_TEE_PROXY_INVALID_ALIGNMENT )
+
+EXIT_PK_NAMESPACE;
+
+#endif /* _DRMTEEPROXYSTUBCOMMON_H_ */
+
diff --git a/prebuilt-v4.4/noarch/include/drmteestub.h b/prebuilt-v4.4/noarch/include/drmteestub.h
new file mode 100644
index 0000000..86e0b2a
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmteestub.h
@@ -0,0 +1,38 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef _DRMTEESTUB_H_
+#define _DRMTEESTUB_H_ 1
+
+#include <drmteetypes.h>
+#include <oemteetypes.h>
+
+ENTER_PK_NAMESPACE;
+
+/* Secure world TEE stub API */
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_TEE_STUB_HandleMethodRequest(
+    __in                                                                                          DRM_DWORD           f_cbRequestMessage,
+    __in_bcount( f_cbRequestMessage )                                                       const DRM_BYTE           *f_pbRequestMessage,
+    __inout_opt                                                                                   DRM_DWORD          *f_pcbResponseMessage,
+    _Out_writes_bytes_opt_( *f_pcbResponseMessage )                                               DRM_BYTE           *f_pbResponseMessage ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_TEE_STUB_XB_TEECtxToBytes(
+    __inout                                             DRM_TEE_CONTEXT    *f_pTEEContext,
+    __out                                               DRM_DWORD          *f_pcbTEECtx,
+    __deref_out_bcount( *f_pcbTEECtx )                  DRM_BYTE          **f_ppbTEECtx ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_TEE_STUB_XB_TEECtxFromBytes(
+    __in                                                DRM_DWORD           f_cbTEECtx,
+    __in_bcount( f_cbTEECtx )                     const DRM_BYTE           *f_pbTEECtx,
+    __inout                                             DRM_TEE_CONTEXT    *f_pTEEContext ) DRM_NO_INLINE_ATTRIBUTE;
+
+EXIT_PK_NAMESPACE;
+
+#endif /* _DRMTEESTUB_H_ */
+
diff --git a/prebuilt-v4.4/noarch/include/drmteetypes.h b/prebuilt-v4.4/noarch/include/drmteetypes.h
new file mode 100644
index 0000000..6b96428
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmteetypes.h
@@ -0,0 +1,634 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef _DRMTEETYPES_H_
+#define _DRMTEETYPES_H_ 1
+
+#include <oemteetypes.h>
+#include <drmteeproxystubcommon.h>
+#include <drmxmrconstants.h>
+
+ENTER_PK_NAMESPACE;
+
+/*
+** The possible blob allocation behaviors for
+** DRM_TEE_NW_BASE_AllocBlob / DRM_TEE_IMPL_BASE_AllocBlob.
+**
+** DRM_TEE_BLOB_ALLOC_BEHAVIOR_INVALID: Invalid behavior.
+** DRM_TEE_BLOB_ALLOC_BEHAVIOR_NEW:     Allocate a new blob.
+**                                      It will NOT be zero-freed.
+** DRM_TEE_BLOB_ALLOC_BEHAVIOR_COPY:    Allocate a new blob and
+**                                      copy the given data into it.
+**                                      The pointer to the data being
+**                                      copied must point to a buffer
+**                                      at least as large as the requested
+**                                      size.
+** DRM_TEE_BLOB_ALLOC_BEHAVIOR_WEAKREF: Take a weak reference to memory
+**                                      allocated by the caller.
+**                                      DRM_TEE_NW_BASE_FreeBlob /
+**                                      DRM_TEE_IMPL_BASE_FreeBlob will
+**                                      NOT free this memory.
+*/
+typedef enum
+{
+    DRM_TEE_BLOB_ALLOC_BEHAVIOR_INVALID = 0,
+    DRM_TEE_BLOB_ALLOC_BEHAVIOR_NEW     = 1,
+    DRM_TEE_BLOB_ALLOC_BEHAVIOR_COPY    = 2,
+    DRM_TEE_BLOB_ALLOC_BEHAVIOR_WEAKREF = 3,
+} DRM_TEE_BLOB_ALLOC_BEHAVIOR;
+
+/*
+** The possible types of TEE byte blobs.
+**
+** DRM_TEE_BYTE_BLOB_TYPE_INVALID:      Invalid blob type.
+** DRM_TEE_BYTE_BLOB_TYPE_WEAK_REF:     Memory allocated by calling code
+**                                      outside any TEE function.
+**                                      Note: This type may be returned by
+**                                      DRM_TEE_NW_BASE_AllocBlob / DRM_TEE_IMPL_BASE_AllocBlob
+**                                      depending on parameters passed to that function.
+** DRM_TEE_BYTE_BLOB_TYPE_USER_MODE:    Memory allocated in user mode.
+**                                      There are no associated TEE resources.
+**                                      Note: Encrypted data which is not
+**                                      of a different type uses this value.
+**                                      Note: This type may be returned by
+**                                      DRM_TEE_NW_BASE_AllocBlob / DRM_TEE_IMPL_BASE_AllocBlob
+**                                      depending on parameters passed to that function.
+** DRM_TEE_BYTE_BLOB_TYPE_CCD:          Memory that represents a CCD and may
+**                                      or may not have associated TEE resources.
+** DRM_TEE_BYTE_BLOB_TYPE_SECURED_MODE: Memory allocated inside the TEE for its
+**                                      own purposes.  This blob type never
+**                                      leaves the TEE (and this is verified by
+**                                      DRM_TEE_PROXYSTUB_XB_AddEntryByteBlob).
+*/
+typedef enum
+{
+    DRM_TEE_BYTE_BLOB_TYPE_INVALID      = 0,
+    DRM_TEE_BYTE_BLOB_TYPE_WEAK_REF     = 1,
+    DRM_TEE_BYTE_BLOB_TYPE_USER_MODE    = 2,
+    DRM_TEE_BYTE_BLOB_TYPE_CCD          = 3,
+    DRM_TEE_BYTE_BLOB_TYPE_SECURED_MODE = 4,
+} DRM_TEE_BYTE_BLOB_TYPE;
+
+/*
+** eType:       The blob type.  Should be DRM_TEE_BYTE_BLOB_TYPE_USER_MODE when caller-allocated.
+**              When callee-allocated, will be set by the callee and
+**              should only be used by DRM_TEE_NW_BASE_FreeBlob / DRM_TEE_IMPL_BASE_FreeBlob.
+** dwSubType:   The blob sub-type.  Should be 0 when caller-allocated.
+**              When callee-allocated, will be set by the callee and
+**              should only be used by DRM_TEE_NW_BASE_FreeBlob / DRM_TEE_IMPL_BASE_FreeBlob
+**              by other code inside the PlayReady PK itself.
+**              (For example, will be set to be equal to the mode
+**              in DRM_TEE_DECRYPT_PrepareToDecrypt.)
+** cb:          Number of bytes.
+** pb:          The bytes.
+*/
+typedef struct __tagDRM_TEE_BYTE_BLOB
+{
+    DRM_TEE_BYTE_BLOB_TYPE   eType;
+    DRM_DWORD                dwSubType;
+    DRM_DWORD                cb;
+    _Field_size_bytes_full_opt_( cb )  const DRM_BYTE                *pb;
+} DRM_TEE_BYTE_BLOB;
+
+/* Note: This MUST be equivalent to:  memset( &blob, 0, sizeof(blob) ); */
+#define DRM_TEE_BYTE_BLOB_EMPTY {DRM_TEE_BYTE_BLOB_TYPE_INVALID,0,0,NULL}
+
+#define IsBlobAssigned(pblob)   ( ( (pblob)->pb != NULL ) && ( (pblob)->cb != 0 ) )
+#define IsBlobConsistent(pblob) ( ( (pblob) == NULL ) || ( ( (pblob)->pb == NULL ) == ( (pblob)->cb == 0 ) ) )
+#define IsBlobEmpty(pblob)      ( ( (pblob)->pb == NULL ) && ( (pblob)->cb == 0 ) )
+
+
+/*
+** The struct DRM_TEE_PROXY_SERIALIZATION_REQUIREMENTS is used to determine the
+** serialization options for an OEM TEE implementation.  This structure defines
+** the maximum TEE message size and header/footer sizes for request/response
+** messages.
+**
+** cbMaxSerializedMessage:  Defines the maximum length (in bytes) of a PRITEE
+**                          serialized function call request/response message.
+** cbInputHeaderSize:       The size in bytes to prepend to the PRITEE method
+**                          invocation request (input) messages.  This data
+**                          will be uninitialized and will be used only by the
+**                          OEM to add header data to the serialized TEE
+**                          messages.
+**                          Note, this value MUST be a multiple of 8 bytes to
+**                          avoid alignment issues.
+** cbInputFooterSize:       The size in bytes to append to the PRITEE method
+**                          invocation request (input) message.  This data
+**                          will be uninitialized and will be used only by the
+**                          OEM to add footer data to the serialized TEE
+**                          messages.
+**                          Note, this value MUST be a multiple of 8 bytes to
+**                          avoid alignment issues.
+** cbOutputHeaderSize:      The size in bytes to prepend to the PRITEE method
+**                          invocation response (output) message.  This data
+**                          will be uninitialized and will be used only by the
+**                          OEM to add header data to the serialized TEE
+**                          messages.
+**                          Note, this value MUST be a multiple of 8 bytes to
+**                          avoid alignment issues.
+** cbOutputFooterSize:      The size in bytes to append to the PRITEE method
+**                          invocation response output message.  This data
+**                          will be uninitialized and will be used only by the
+**                          OEM to add footer data to the serialized TEE
+**                          messages.
+**                          Note, this value MUST be a multiple of 8 bytes to
+**                          avoid alignment issues.
+*/
+typedef struct __tagDRM_TEE_PROXY_SERIALIZATION_REQUIREMENTS
+{
+    DRM_DWORD cbMaxSerializationMessage;
+    DRM_DWORD cbInputHeaderSize;
+    DRM_DWORD cbInputFooterSize;
+    DRM_DWORD cbOutputHeaderSize;
+    DRM_DWORD cbOutputFooterSize;
+} DRM_TEE_PROXY_SERIALIZATION_REQUIREMENTS;
+
+#define DRM_TEE_PROXY_SERIALIZATION_REQUIREMENTS_EMPTY {0,0,0,0,0}
+
+/*
+** The struct DRM_TEE_PROXY_CONTEXT_OEM_VERSION_INFO contains some of the data about the
+** secure-world necessary for normal-world code to execute properly
+** (so that the TEE does not need to be invoked repeatedly to re-gather this information)
+** and to enable calls across the normal/secure-world boundary to occur (into the TEE).
+** All values in this structure are returned from OEM_TEE_BASE_GetVersion and OEM_TEE_BASE_GetVersionInformation.
+**
+** dwOEMVersion:              Returned from OEM_TEE_BASE_GetVersion: Equal to *f_pdwVersion.
+** pwszOEMManufacturerName:   Returned from OEM_TEE_BASE_GetVersionInformation: Equal to *f_ppwszManufacturerName.
+** cchOEMManufacturerName:    Returned from OEM_TEE_BASE_GetVersionInformation: Equal to *f_pchManufacturerName.
+** pwszOEMModelName:          Returned from OEM_TEE_BASE_GetVersionInformation: Equal to *f_ppwszModelName.
+** cchOEMModelName:           Returned from OEM_TEE_BASE_GetVersionInformation: Equal to *f_pchModelName.
+** pwszOEMModelNumber:        Returned from OEM_TEE_BASE_GetVersionInformation: Equal to *f_ppwszModelNumber.
+** cchOEMModelNumber:         Returned from OEM_TEE_BASE_GetVersionInformation: Equal to *f_pchModelNumber.
+** rgdwFunctionMap:           Returned from OEM_TEE_BASE_GetVersionInformation: Equal to f_pdwFunctionMap[].
+**                            Any bits or bytes which are unset by OEM_TEE_BASE_GetVersionInformation default to zero.
+** oSystemProperties:         Returned from OEM_TEE_BASE_GetVersionInformation: Equal to *f_ppbProperties and *f_pcbProperties.
+*/
+typedef struct __tagDRM_TEE_PROXY_CONTEXT_OEM_VERSION_INFO
+{
+    DRM_DWORD                                    dwOEMVersion;
+    DRM_WCHAR                                   *pwszOEMManufacturerName;
+    DRM_DWORD                                    cchOEMManufacturerName;
+    DRM_WCHAR                                   *pwszOEMModelName;
+    DRM_DWORD                                    cchOEMModelName;
+    DRM_WCHAR                                   *pwszOEMModelNumber;
+    DRM_DWORD                                    cchOEMModelNumber;
+    DRM_DWORD                                    rgdwFunctionMap[ DRM_TEE_METHOD_FUNCTION_MAP_COUNT ];
+    DRM_TEE_BYTE_BLOB                            oSystemProperties;
+    DRM_DWORD                                    cbOEMVersion2;
+    DRM_BYTE                                    *pbOEMVersion2;
+} DRM_TEE_PROXY_CONTEXT_OEM_VERSION_INFO;
+
+#define DRM_TEE_PROXY_CONTEXT_OEM_VERSION_INFO_EMPTY { 0, NULL, 0, NULL, 0, NULL, 0, {0}, DRM_TEE_BYTE_BLOB_EMPTY }
+
+/*
+** The struct DRM_TEE_PROXY_CONTEXT contains all the data about the
+** secure-world necessary for normal-world code to execute properly
+** (so that the TEE does not need to be invoked repeatedly to re-gather this information)
+** and to enable calls across the normal/secure-world boundary to occur (into the TEE).
+**
+** pvUserCtx:                     Equal to the OEM context (f_pOEMContext) passed to Drm_Initialize.
+** pbTeeCtx:                      Opaque context data from inside secure world (TEE).
+** cbTeeCtx:                      Opaque context data size from inside secure world (TEE).
+** idUnique:                      Unique identifier for the underlying TEE, ends up as part.
+**                                of PlayReady leaf certificate during local or remote provisioning.
+** dwPKMajorVersion:              PK Major version that the TEE was built against.
+** dwPKMinorVersion:              PK Minor version that the TEE was built against.
+** dwPKQFEVersion:                PK QFE version that the TEE was built against.
+** dwPKBuildVersion:              PK Build version that the TEE was built against.
+** oOEMVersionInfo:               Refer to structure definition for DRM_TEE_PROXY_CONTEXT_OEM_VERSION_INFO.
+** oSerializationRequirements:    Refer to structure definition for DRM_TEE_PROXY_SERIALIZATION_REQUIREMENTS.
+*/
+typedef struct __tagDRM_TEE_PROXY_CONTEXT
+{
+    DRM_VOID                                    *pvUserCtx;
+    DRM_BYTE                                    *pbTeeCtx;
+    DRM_DWORD                                    cbTeeCtx;
+    DRM_ID                                       idUnique;
+    DRM_DWORD                                    dwPKMajorVersion;
+    DRM_DWORD                                    dwPKMinorVersion;
+    DRM_DWORD                                    dwPKQFEVersion;
+    DRM_DWORD                                    dwPKBuildVersion;
+    DRM_TEE_PROXY_CONTEXT_OEM_VERSION_INFO       oOEMVersionInfo;
+    DRM_TEE_PROXY_SERIALIZATION_REQUIREMENTS     oSerializationRequirements;
+} DRM_TEE_PROXY_CONTEXT;
+
+#define DRM_TEE_PROXY_CONTEXT_EMPTY { NULL, NULL, 0, DRM_ID_EMPTY, 0, 0, 0, 0, DRM_TEE_PROXY_CONTEXT_OEM_VERSION_INFO_EMPTY, DRM_TEE_PROXY_SERIALIZATION_REQUIREMENTS_EMPTY }
+
+#define DRM_TEE_PROXY_CONTEXT_TEE_HAS_MINIMUM_PK_VERSION( _pctx, _major, _minor, _build, _qfe )     \
+     ( ( ( ( _ctx )->dwPKMajorVersion >  ( _major ) ) )                                             \
+    || ( ( ( _ctx )->dwPKMajorVersion == ( _major ) )                                               \
+      && ( ( _ctx )->dwPKMinorVersion >  ( _minor ) ) )                                             \
+    || ( ( ( _ctx )->dwPKMajorVersion == ( _major ) )                                               \
+      && ( ( _ctx )->dwPKMinorVersion == ( _minor ) )                                               \
+      && ( ( _ctx )->dwPKQFEVersion    > ( _qfe   ) ) )                                             \
+    || ( ( ( _ctx )->dwPKMajorVersion == ( _major ) )                                               \
+      && ( ( _ctx )->dwPKMinorVersion == ( _minor ) )                                               \
+      && ( ( _ctx )->dwPKQFEVersion   == ( _qfe   ) )                                               \
+      && ( ( _ctx )->dwPKBuildVersion  > ( _build ) ) ) )
+
+typedef struct __tagDRM_TEE_CONTEXT
+{
+    DRM_ID                                  idSession;
+    OEM_TEE_CONTEXT                         oContext;
+} DRM_TEE_CONTEXT;
+
+#define DRM_TEE_CONTEXT_EMPTY {DRM_ID_EMPTY, OEM_TEE_CONTEXT_EMPTY}
+
+/*
+** The possible types of XBinary key blobs. Note that these types are part
+** of the XBinary format itself so they cannot be changed otherwise existing
+** key blobs will be invalidated.
+**
+** DRM_TEE_XB_KB_TYPE_PPKB:             Public/Private (auxiliary) key blob
+** DRM_TEE_XB_KB_TYPE_LKB:              License (auxiliary) key blob
+** DRM_TEE_XB_KB_TYPE_CDKB:             Content decryption key blob
+** DRM_TEE_XB_KB_TYPE_DKB:              Domain key blob
+** DRM_TEE_XB_KB_TYPE_MRKB_DEPRECATED:  (no longer supported) Message receiver key blob
+** DRM_TEE_XB_KB_TYPE_MTKB_DEPRECATED:  (no longer supported) Message transmitter key blob
+** DRM_TEE_XB_KB_TYPE_RKB:              Revocation key blob
+** DRM_TEE_XB_KB_TYPE_CEKB:             Content encryption key blob
+** DRM_TEE_XB_KB_TYPE_TPKB:             Temporary provisioning key blob
+** DRM_TEE_XB_KB_TYPE_SPKB:             Sample protection key blob
+** DRM_TEE_XB_KB_TYPE_NKB:              Nonce key blob
+** DRM_TEE_XB_KB_TYPE_RPCKB:            Remote provisioning context key blob
+** DRM_TEE_XB_KB_TYPE_LPKB:             Local provisioning key blob (when device certificate is pre-generated)
+** DRM_TEE_XB_KB_TYPE_NTKB:             Nonce with time key blob
+** DRM_TEE_XB_KB_TYPE_SSKB:             Secure Stop (2) key blob
+*/
+typedef enum
+{
+    DRM_TEE_XB_KB_TYPE_PPKB             = 0x1,
+    DRM_TEE_XB_KB_TYPE_LKB              = 0x2,
+    DRM_TEE_XB_KB_TYPE_CDKB             = 0x3,
+    DRM_TEE_XB_KB_TYPE_DKB              = 0x4,
+    DRM_TEE_XB_KB_TYPE_MRKB_DEPRECATED  = 0x5,
+    DRM_TEE_XB_KB_TYPE_MTKB_DEPRECATED  = 0x6,
+    DRM_TEE_XB_KB_TYPE_RKB              = 0x7,
+    DRM_TEE_XB_KB_TYPE_CEKB             = 0x8,
+    DRM_TEE_XB_KB_TYPE_TPKB             = 0x9,
+    DRM_TEE_XB_KB_TYPE_SPKB             = 0xa,
+    DRM_TEE_XB_KB_TYPE_NKB              = 0xb,
+    DRM_TEE_XB_KB_TYPE_RPCKB            = 0xc,
+    DRM_TEE_XB_KB_TYPE_LPKB             = 0xd,
+    DRM_TEE_XB_KB_TYPE_NTKB             = 0xe,
+    DRM_TEE_XB_KB_TYPE_SSKB             = 0xf,
+} DRM_TEE_XB_KB_TYPE;
+
+/*
+** cdwData: Number of DWORD values in pdwData
+** pdwData: An array of DWORD values.
+*/
+typedef struct __tagDRM_TEE_DWORDLIST
+{
+                                           DRM_DWORD  cdwData;
+    _Field_size_full_opt_(cdwData)   const DRM_DWORD *pdwData;
+} DRM_TEE_DWORDLIST;
+
+/* Note: This MUST be equivalent to:  memset( &blob, 0, sizeof(blob) ); */
+#define DRM_TEE_DWORDLIST_EMPTY {0,NULL}
+
+#define DRM_TEE_DWORDLIST_TRANSFER_OWNERSHIP_TO_PTR(pcdwTarget, ppdwTarget, pdwlSource) DRM_DO {                                                                                \
+    PRAGMA_DIAG_OFF(address, "Turning gcc warnings for address off in order to compile with -Werror. For some cases, pdwlTarget and pdwlSource will certainly not be NULL")     \
+    DRMASSERT( (pcdwTarget) != NULL );                                                                                                                                          \
+    DRMASSERT( (ppdwTarget) != NULL );                                                                                                                                          \
+    DRMASSERT( (pdwlSource) != NULL );                                                                                                                                          \
+    PRAGMA_DIAG_ON(address)                                                                                                                                                     \
+    *(pcdwTarget) = (pdwlSource)->cdwData;                                                                                                                                      \
+    *(ppdwTarget) = ( DRM_DWORD * )(pdwlSource)->pdwData;                                                                                                                       \
+    *(( DRM_DWORD ** )&(pdwlSource)->pdwData) = NULL;                                                                                                                           \
+    (pdwlSource)->cdwData = 0;                                                                                                                                                  \
+} DRM_WHILE_FALSE
+
+#define DRM_TEE_DWORDLIST_TRANSFER_OWNERSHIP(pdwlTarget, pdwlSource) DRM_DO {                                                                                                   \
+    PRAGMA_DIAG_OFF(address, "Turning gcc warnings for address off in order to compile with -Werror. For some cases, pdwlTarget and pdwlSource will certainly not be NULL")     \
+    DRMASSERT( (pdwlTarget) != NULL );                                                                                                                                          \
+    DRMASSERT( (pdwlSource) != NULL );                                                                                                                                          \
+    PRAGMA_DIAG_ON(address)                                                                                                                                                     \
+    DRM_TEE_DWORDLIST_TRANSFER_OWNERSHIP_TO_PTR(&(pdwlTarget)->cdwData, ( DRM_DWORD ** )&(pdwlTarget)->pdwData, pdwlSource);                                                    \
+} DRM_WHILE_FALSE
+
+#define IsDwordListAssigned(pdwl)   ( ( (pdwl)->pdwData != NULL ) && ( (pdwl)->cdwData != 0 ) )
+#define IsDwordListConsistent(pdwl) ( ( (pdwl)          == NULL ) || ( ( (pdwl)->pdwData == NULL ) == ( (pdwl)->cdwData == 0 ) ) )
+#define IsDwordListEmpty(pdwl)      ( ( (pdwl)->pdwData == NULL ) && ( (pdwl)->cdwData == 0 ) )
+
+/*
+** cqwData: Number of QWORD values in pqwData
+** pqwData: An array of QWORD values.
+*/
+typedef struct __tagDRM_TEE_QWORDLIST
+{
+                                           DRM_DWORD   cqwData;
+    _Field_size_full_opt_(cqwData)   const DRM_UINT64 *pqwData;
+} DRM_TEE_QWORDLIST;
+
+/* Note: This MUST be equivalent to:  memset( &blob, 0, sizeof(blob) ); */
+#define DRM_TEE_QWORDLIST_EMPTY {0,NULL}
+
+#define DRM_TEE_QWORDLIST_TRANSFER_OWNERSHIP_TO_PTR(pcqwTarget, ppqwTarget, pqwlSource) DRM_DO {                                                                            \
+    PRAGMA_DIAG_OFF(address, "Turning gcc warnings for address off in order to compile with -Werror. For some cases, pqwlTarget and pqwlSource will certainly not be NULL") \
+    DRMASSERT( (pcqwTarget) != NULL );                                                                                                                                      \
+    DRMASSERT( (ppqwTarget) != NULL );                                                                                                                                      \
+    DRMASSERT( (pqwlSource) != NULL );                                                                                                                                      \
+    PRAGMA_DIAG_ON(address)                                                                                                                                                 \
+    *(pcqwTarget) = (pqwlSource)->cqwData;                                                                                                                                  \
+    *(ppqwTarget) = ( DRM_UINT64 * )(pqwlSource)->pqwData;                                                                                                                  \
+    *(( DRM_UINT64 ** )&(pqwlSource)->pqwData) = NULL;                                                                                                                      \
+    (pqwlSource)->cqwData = 0;                                                                                                                                              \
+} DRM_WHILE_FALSE
+
+#define DRM_TEE_QWORDLIST_TRANSFER_OWNERSHIP(pqwlTarget, pqwlSource) DRM_DO {                                                                                               \
+    PRAGMA_DIAG_OFF(address, "Turning gcc warnings for address off in order to compile with -Werror. For some cases, pqwlTarget and pqwlSource will certainly not be NULL") \
+    DRMASSERT( (pqwlTarget) != NULL );                                                                                                                                      \
+    DRMASSERT( (pqwlSource) != NULL );                                                                                                                                      \
+    PRAGMA_DIAG_ON(address)                                                                                                                                                 \
+    DRM_TEE_QWORDLIST_TRANSFER_OWNERSHIP_TO_PTR(&(pqwlTarget)->cqwData, ( DRM_UINT64 ** )&(pqwlTarget)->pqwData, pqwlSource);                                               \
+} DRM_WHILE_FALSE
+
+#define IsQwordListAssigned(pqwl)   ( ( (pqwl)->pqwData != NULL ) && ( (pqwl)->cqwData != 0 ) )
+#define IsQwordListConsistent(pqwl) ( ( (pqwl)          == NULL ) || ( ( (pqwl)->pqwData == NULL ) == ( (pqwl)->cqwData == 0 ) ) )
+#define IsQwordListEmpty(pqwl)      ( ( (pqwl)->pqwData == NULL ) && ( (pqwl)->cqwData == 0 ) )
+
+/*
+** The set of operations that DRM_TEE_LICGEN_CompleteLicense can perform.
+**
+** DRM_TEE_LICGEN_OP_INVALID:                      Invalid operation.
+** DRM_TEE_LICGEN_OP_GEN_REMOTE_SIMPLE_DEPRECATED: This operation is no longer supported.
+** DRM_TEE_LICGEN_OP_GEN_REMOTE_ROOT_DEPRECATED:   This operation is no longer supported.
+**
+** DRM_TEE_LICGEN_OP_GEN_LOCAL_SIMPLE:             Given an unsigned simple license with empty
+**                                                 key material, generate new license keys,
+**                                                 create a new LKB containing new license keys.
+**                                                 (this LKB can be used to write license into disk)
+**
+** DRM_TEE_LICGEN_OP_GEN_LOCAL_ROOT:               Given an unsigned simple license with empty
+**                                                 key material, generate new license keys,
+**                                                 create a new LKB containing new license keys.
+**                                                 (this LKB can be used to write license into disk)
+**
+** DRM_TEE_LICGEN_OP_GEN_LEAF:                     Given an unsigned leaf license with empty
+**                                                 key material, generate new license keys,
+**                                                 encrypt them with a given root license's
+**                                                 content key (i.e. bind them to that license),
+**                                                 and complete and sign the license.
+*/
+typedef enum
+{
+    DRM_TEE_LICGEN_OP_INVALID                       = 0,
+    DRM_TEE_LICGEN_OP_GEN_REMOTE_SIMPLE_DEPRECATED  = 1,
+    DRM_TEE_LICGEN_OP_GEN_REMOTE_ROOT_DEPRECATED    = 2,
+    DRM_TEE_LICGEN_OP_GEN_LOCAL_SIMPLE              = 3,
+    DRM_TEE_LICGEN_OP_GEN_LOCAL_ROOT                = 4,
+    DRM_TEE_LICGEN_OP_GEN_LEAF                      = 5,
+} DRM_TEE_LICGEN_OP;
+
+/*
+** The possible types of play enablers. These values form a bit field
+** to enumerate all of the play enablers present in a license.
+**
+** DRM_TEE_PLAY_ENABLER_TYPE_UNKNOWN_OUTPUT:             Permit passing uncompressed decrypted video to
+**                                                       an unknown output
+** DRM_TEE_PLAY_ENABLER_TYPE_UNKNOWN_OUTPUT_CONSTRAINED: Permit passing constrained resolution video to
+**                                                       an unknown output
+** DRM_TEE_PLAY_ENABLER_TYPE_DTCP:                       Permit passing decrypted content to DTCP
+** DRM_TEE_PLAY_ENABLER_TYPE_HELIX:                      Permit passing decrypted content to Helix
+** DRM_TEE_PLAY_ENABLER_TYPE_HDCP_MIRACAST:              Permit passing decrypted compressed content to
+**                                                       a licensed implementation of HDCP over Miracast
+** DRM_TEE_PLAY_ENABLER_TYPE_HDCP_WIVU:                  Permit passing decrypted compressed content to
+**                                                       a licensed implementation of HDCP over WiVu
+** DRM_TEE_PLAY_ENABLER_TYPE_AIRPLAY:                    Permit passing decrypted compressed content to
+**                                                       a licensed implementation of AirPlay
+** DRM_TEE_PLAY_ENABLER_TYPE_FRAME_SERVER:               Permit passing decrypted uncompressed content to
+**                                                       a frame server
+**
+*/
+typedef enum
+{
+    DRM_TEE_PLAY_ENABLER_TYPE_UNKNOWN_OUTPUT             = 0x01,
+    DRM_TEE_PLAY_ENABLER_TYPE_UNKNOWN_OUTPUT_CONSTRAINED = 0x02,
+    DRM_TEE_PLAY_ENABLER_TYPE_DTCP                       = 0x04,
+    DRM_TEE_PLAY_ENABLER_TYPE_HELIX                      = 0x08,
+    DRM_TEE_PLAY_ENABLER_TYPE_HDCP_MIRACAST              = 0x10,
+    DRM_TEE_PLAY_ENABLER_TYPE_HDCP_WIVU                  = 0x20,
+    DRM_TEE_PLAY_ENABLER_TYPE_AIRPLAY                    = 0x40,
+    DRM_TEE_PLAY_ENABLER_TYPE_FRAME_SERVER               = 0x80,
+} DRM_TEE_PLAY_ENABLER_TYPE;
+
+/*
+** The possible properties returned as part of the System Properties from DRM_TEE_BASE_AllocTEEContext.
+** Refer to that function for more information.  These values form a bit field.
+**
+** DRM_TEE_PROPERTY_SUPPORTS_HEVC_HW_DECODING:
+**     This TEE supports HEVC HW Decoding.
+**
+** DRM_TEE_PROPERTY_SUPPORTS_REMOTE_PROVISIONING:
+**     This TEE supports remove provisioning.
+**
+** DRM_TEE_PROPERTY_SUPPORTS_PRE_PROCESS_ENCRYPTED_DATA:
+**     This TEE supports calling DRM_TEE_H264_PreProcessEncryptedData.
+**
+** DRM_TEE_PROPERTY_REQUIRES_PRE_PROCESS_ENCRYPTED_DATA_WITH_FULL_FRAMES:
+**     This TEE requires a call to DRM_TEE_H264_PreProcessEncryptedData with complete frames.
+**     This property REQUIRES that DRM_TEE_PROPERTY_SUPPORTS_PRE_PROCESS_ENCRYPTED_DATA is also set.
+**
+** DRM_TEE_PROPERTY_REQUIRES_SAMPLE_PROTECTION:
+**     This TEE requires sample protection for decrypting SL2000 and below audio content.
+**
+** DRM_TEE_PROPERTY_SUPPORTS_SECURE_CLOCK:
+**     This TEE supports enforcement of time-based restrictions in licenses using a secure clock.
+**
+** DRM_TEE_PROPERTY_SUPPORTS_SECURE_STOP:
+**     This TEE supports enforcement of the secure stop license restriction.
+**
+** DRM_TEE_PROPERTY_SUPPORTS_SECURE_HDCP_TYPE_1:
+**     This TEE supports enforcement of HDCP Type 1.
+**
+** DRM_TEE_PROPERTY_REQUIRES_PREPARE_POLICY_INFO:
+**     This TEE requires a call to prepare policy info.
+**
+** DRM_TEE_PROPERTY_REQUIRES_MINIMAL_REVOCATION_DATA:
+**     This TEE both supports and requires less revocation information to be passed to
+**     the DRM_TEE_PROXY_REVOCATION_IngestRevocationInfo function.
+**
+** DRM_TEE_PROPERTY_SUPPORTS_OPTIMIZED_CONTENT_KEY2:
+**     This TEE supports optimized content key2 XMR objects.
+**     There is no need to set this property explicitly.
+**     It is implicitly set if (and only if) OEM_TEE_OPTIMIZED_CONTENT_KEY2_CACHE_SIZE > 0.
+*/
+typedef enum _tagDRM_TEE_PROPERTY
+{
+    DRM_TEE_PROPERTY_SUPPORTS_HEVC_HW_DECODING                              = 0,
+    DRM_TEE_PROPERTY_SUPPORTS_REMOTE_PROVISIONING                           = 1,
+    DRM_TEE_PROPERTY_SUPPORTS_PRE_PROCESS_ENCRYPTED_DATA                    = 2,
+    DRM_TEE_PROPERTY_REQUIRES_PRE_PROCESS_ENCRYPTED_DATA_WITH_FULL_FRAMES   = 3,
+    DRM_TEE_PROPERTY_REQUIRES_SAMPLE_PROTECTION                             = 4,
+    DRM_TEE_PROPERTY_SUPPORTS_SECURE_CLOCK                                  = 5,
+    DRM_TEE_PROPERTY_SUPPORTS_SECURE_STOP                                   = 6,
+    DRM_TEE_PROPERTY_SUPPORTS_SECURE_HDCP_TYPE_1                            = 7,
+    DRM_TEE_PROPERTY_REQUIRES_PREPARE_POLICY_INFO                           = 8,
+    DRM_TEE_PROPERTY_SUPPORTS_DEBUG_TRACING                                 = 9,
+    DRM_TEE_PROPERTY_REQUIRES_MINIMAL_REVOCATION_DATA                       = 10,
+    DRM_TEE_PROPERTY_SUPPORTS_OPTIMIZED_CONTENT_KEY2                        = 11,
+
+    /*
+    ** Note: when adding entries to this enum, this value MUST be updated.
+    ** In addition, older TEEs are assumed to NOT have new properties set.
+    ** So if an older TEE supports FOO and a newer TEE does not,
+    ** then the new property MUST be named something like
+    ** DRM_TEE_PROPERTY_DOES_NOT_SUPPORT_FOO (i.e. as a negative)
+    ** so that only newer TEEs will ever have the property set.
+    ** The property array is always initialized to zero for all extra bits
+    ** in the last byte inside the TEE, so this makes behavior consistent
+    ** regardless of whether a new bit is added into an existing byte or
+    ** causes another byte to be required.
+    */
+    DRM_TEE_PROPERTY_MAX                                                    = 11,
+} DRM_TEE_PROPERTY;
+
+#define DRM_TEE_PROPERTY_ARRAY_SIZE     ( (DRM_DWORD)( ( DRM_TEE_PROPERTY_MAX >> 3 ) + 1 ) )
+
+#define DRM_TEE_PROPERTY_BIT_HELPER( _bit )     ( 1 << ( ( ( ~( (DRM_DWORD)( _bit ) ) ) & 7 ) ) )
+
+/*
+** If the TEE is older than the insecure world and had fewer enum values defined,
+** the property array may not have enough entries and we don't want a read-buffer-overrun.
+** As mentioned in comments for DRM_TEE_PROPERTY_MAX, we assume that a property
+** from an older TEE is NOT set by treating this case as FALSE (i.e. not set).
+*/
+#define DRM_TEE_PROPERTY_IS_SET( _cb, _pb, _e )             \
+    ( ( ( _cb ) > ( ( (DRM_DWORD)( _e ) ) >> 3 ) )          \
+   && ( ( _pb )[ ( ( (DRM_DWORD)( _e ) ) >> 3 ) ] & DRM_TEE_PROPERTY_BIT_HELPER( _e ) ) )
+
+#define DRM_TEE_PROPERTY_IS_SET_IN_TEE_PROXY_CONTEXT( _pctx, _e )     \
+    DRM_TEE_PROPERTY_IS_SET( (_pctx)->oOEMVersionInfo.oSystemProperties.cb, (_pctx)->oOEMVersionInfo.oSystemProperties.pb, (_e) )
+
+#if DRM_DBG
+#define DRM_TEE_PROPERTY_SET_VALUE( _cb, _pb, _e ) DRM_DO {     \
+    DRM_DWORD    __cb = ( _cb );                                \
+    DRM_BYTE    *__pb = ( _pb );                                \
+    DRM_DWORD    __ib = (DRM_DWORD)( _e );                      \
+    DRMASSERT( __cb > __ib >> 3 );                              \
+    __pb[ __ib >> 3 ] |= DRM_TEE_PROPERTY_BIT_HELPER( __ib );   \
+} DRM_WHILE_FALSE
+#else   /* DRM_DBG */
+#define DRM_TEE_PROPERTY_SET_VALUE( _cb, _pb, _e ) DRM_DO {     \
+    DRM_BYTE    *__pb = ( _pb );                                \
+    DRM_DWORD    __ib = (DRM_DWORD)( _e );                      \
+    __pb[ __ib >> 3 ] |= DRM_TEE_PROPERTY_BIT_HELPER( __ib );   \
+} DRM_WHILE_FALSE
+#endif  /* DRM_DBG */
+
+#if DRM_DBG
+#define DRM_TEE_PROPERTY_UNSET_VALUE( _cb, _pb, _e ) DRM_DO {   \
+    DRM_DWORD    __cb = ( _cb );                                \
+    DRM_BYTE    *__pb = ( _pb );                                \
+    DRM_DWORD    __ib = (DRM_DWORD)( _e );                      \
+    DRMASSERT( __cb > __ib >> 3 );                              \
+    __pb[ __ib >> 3 ] &= ~DRM_TEE_PROPERTY_BIT_HELPER( __ib );  \
+} DRM_WHILE_FALSE
+#else   /* DRM_DBG */
+#define DRM_TEE_PROPERTY_UNSET_VALUE( _cb, _pb, _e ) DRM_DO {   \
+    DRM_BYTE    *__pb = ( _pb );                                \
+    DRM_DWORD    __ib = (DRM_DWORD)( _e );                      \
+    __pb[ __ib >> 3 ] &= ~DRM_TEE_PROPERTY_BIT_HELPER( __ib );  \
+} DRM_WHILE_FALSE
+#endif  /* DRM_DBG */
+
+/*
+** Note: This structure is not used in persistent storage.
+** There is no need to address backward compatibility when modifying it.
+*/
+typedef struct __tagDRM_TEE_POLICY_RESTRICTION
+{
+    /* Size of this structure, equals sizeof(DRM_TEE_POLICY_RESTRICTION) + cbRestrictionConfiguration */
+    DRM_DWORD  cbThis;
+
+    /*
+    ** Takes one of the following values:
+    ** DRM_XMRFORMAT_ID_EXPLICIT_ANALOG_VIDEO_OUTPUT_PROTECTION_CONTAINER
+    ** DRM_XMRFORMAT_ID_EXPLICIT_DIGITAL_AUDIO_OUTPUT_PROTECTION_CONTAINER
+    ** DRM_XMRFORMAT_ID_EXPLICIT_DIGITAL_VIDEO_OUTPUT_PROTECTION_CONTAINER
+    */
+    DRM_WORD   wRestrictionCategory;
+
+    /* Output Restriction ID */
+    DRM_ID     idRestrictionType;
+
+    /*
+    ** This structure is followed by the raw bytes of the Binary Configuration Data.
+    ** This value (cbRestrictionConfiguration) contains the number of bytes.
+    ** Note that the Binary Configuration Data is often in BIG ENDIAN and must be converted (see XMR spec for details).
+    */
+    DRM_DWORD  cbRestrictionConfiguration;
+
+} DRM_TEE_POLICY_RESTRICTION;
+
+/*
+** Note: This enum is not used in persistent storage.
+** There is no need to address backward compatibility when modifying it.
+*/
+typedef enum __tagDRM_TEE_POLICY_OUTPUT_PROTECTION_LEVEL_INDEX
+{
+    OUTPUT_PROTECTION__COMPRESSED_DIGITAL_VIDEO_INDEX    = 0,
+    OUTPUT_PROTECTION__UNCOMPRESSED_DIGITAL_VIDEO_INDEX  = 1,
+    OUTPUT_PROTECTION__ANALOG_VIDEO_INDEX                = 2,
+    OUTPUT_PROTECTION__COMPRESSED_DIGITAL_AUDIO_INDEX    = 3,
+    OUTPUT_PROTECTION__UNCOMPRESSED_DIGITAL_AUDIO_INDEX  = 4,
+    OUTPUT_PROTECTION__COUNT                             = 5,
+} DRM_TEE_POLICY_OUTPUT_PROTECTION_LEVEL_INDEX;
+
+/*
+** Note: This structure is not used in persistent storage.
+** There is no need to address backward compatibility when modifying it.
+*/
+typedef struct __tagDRM_TEE_POLICY_INFO
+{
+    DRM_DWORD                       cbThis;                                                 /* Size of this structure including all restrictions, equals sizeof(DRM_TEE_POLICY_INFO) + sum-of-all( DRM_TEE_POLICY_RESTRICTION.cbThis ) */
+    DRM_KID                         oKID;                                                   /* From leaf-most license. */
+    DRM_LID                         oLID;                                                   /* From leaf-most license. */
+    DRM_BOOL                        fSecureStop2;                                           /* TRUE iff XMRFORMAT_IS_SECURESTOP2_VALID( leaf-most license ) */
+    DRM_DWORD                       dwDecryptionMode;                                       /* One of the values from the OEM_TEE_DECRYPTION_MODE enum */
+    DRM_WORD                        wSecurityLevel;                                         /* Minimum of root/leaf. */
+    DRM_DWORD                       dwBeginDate;                                            /* XMR: Unsigned number of seconds elapsed since January 1, 1970, represented in Universal Time Coordinate (UTC) format.  Minimum of root/leaf. */
+    DRM_DWORD                       dwEndDate;                                              /* XMR: Unsigned number of seconds elapsed since January 1, 1970, represented in Universal Time Coordinate (UTC) format.  Minimum of root/leaf. */
+    DRM_BOOL                        fRealTimeExpirationPresent;                             /* TRUE if policy set in either root or leaf. */
+    DRM_WORD                        rgwOutputProtectionLevels[OUTPUT_PROTECTION__COUNT];    /* Index into this using one of the DRM_TEE_POLICY_OUTPUT_PROTECTION_LEVEL_INDEX enum values.  From root-most license. */
+    DRM_DWORD                       dwPlayEnablers;                                         /* Bitmask of values from the DRM_TEE_PLAY_ENABLER_TYPE enum.  From leaf-most license. */
+    XMR_SYMMETRIC_ENCRYPTION_TYPE   eSymmetricEncryptionType;                               /* From leaf-most license. */
+
+    /*
+    ** This structure is followed by zero or more variable-sized DRM_TEE_POLICY_RESTRICTION structures.
+    ** This value (cRestrictions) contains the count.
+    ** Each one has size DRM_TEE_POLICY_RESTRICTION.cbThis.
+    */
+    DRM_DWORD                       cRestrictions;
+} DRM_TEE_POLICY_INFO;
+
+#define DRM_MAX_DOMAIN_JOIN_KEYS ((DRM_DWORD)(100))
+
+#define DRM_TEE_OLDEST_TK_ID ((DRM_DWORD)(0))
+
+typedef enum
+{
+    DRM_TEE_POLICY_INFO_CALLING_API_DECRYPT_PREPARETODECRYPT                = 1,
+    DRM_TEE_POLICY_INFO_CALLING_API_AES128CTR_DECRYPTCONTENT                = 2,
+    DRM_TEE_POLICY_INFO_CALLING_API_AES128CTR_DECRYPTAUDIOCONTENTMULTIPLE   = 3,
+    DRM_TEE_POLICY_INFO_CALLING_API_H264_PREPROCESSENCRYPTEDDATA            = 4,
+    DRM_TEE_POLICY_INFO_CALLING_API_AES128CTR_DECRYPTCONTENTMULTIPLE        = 5,
+    DRM_TEE_POLICY_INFO_CALLING_API_AES128CBC_DECRYPTCONTENTMULTIPLE        = 6,
+} DRM_TEE_POLICY_INFO_CALLING_API;
+
+#define DRM_SECURETIME_MAX_RESPONSE_WAIT_IN_MINUTES     ((DRM_DWORD)(1))
+#define DRM_SECURETIME_SERVER_CERT_MIN_SECURITYLEVEL    ((DRM_DWORD)(3000))
+#define ONE_MIN_IN_FILETIME                             ((DRM_DWORD)(600000000)) /* (10000000 x 60) */
+#define DRM_SECURETIME_MAX_REQUEST_WAIT_IN_FILETIME     ((DRM_DWORD)(600000000)) /* DRM_SECURETIME_MAX_RESPONSE_WAIT_IN_MINUTES * ONE_MIN_IN_FILETIME */
+
+EXIT_PK_NAMESPACE;
+
+#endif /* _DRMTEETYPES_H_ */
+
diff --git a/prebuilt-v4.4/noarch/include/drmtesturlhelper.h b/prebuilt-v4.4/noarch/include/drmtesturlhelper.h
new file mode 100644
index 0000000..f84ebe3
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmtesturlhelper.h
@@ -0,0 +1,252 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __DRMTESTURLHELPER_H__
+#define __DRMTESTURLHELPER_H__
+
+#include <drmtypes.h>
+#include <drmsal.h>
+
+PREFAST_PUSH_DISABLE_EXPLAINED( __WARNING_URL_NEEDS_REVIEW_25085, "Test URLs do not need review." )
+PREFAST_PUSH_DISABLE_EXPLAINED( __WARNING_USE_SELECT_ANY_25046, "Static variables cannot be __declspec(selectany)" )
+
+/*
+** Note: set DRMTESTURLHELPER_DEBUG_JSON to 1 to have the test server
+** ONLY return the converted JSon which can easily be viewed in fiddler
+*/
+#define DRMTESTURLHELPER_DEBUG_JSON                        0
+
+/*
+** Note: Set one (but not more than one) of these values to force all tests to use the provided server.
+*/
+#define DRMTESTURLHELPER_DEBUG_USING_PR_CORE_SERVER     0
+#define DRMTESTURLHELPER_DEBUG_USING_PR_EDGE_SERVER     0
+
+/*
+** If you want to use your own server (e.g. localhost), then define
+** DDRMTESTURLHELPER_INITIALIZE_URL_FORCE_OVERRIDE_URL yourself as shown in the following example.
+** #define DRMTESTURLHELPER_INITIALIZE_URL_FORCE_OVERRIDE_URL "localhost/playready_3_3_4450/rightsmanager.asmx"
+*/
+
+/*
+** Set this to TRUE if the server being hit uses the legacy XMR builder.
+** Set this to FALSE if the server being hit uses the xbinary XMR builder.
+*/
+#define DRMTESTURLHELPER_SERVER_IS_USING_LEGACY_XMR_BUILDER  FALSE
+
+static DRM_CHAR  s_szLicAcqUrl[ 1024 ] = { 0 };     /* 1 kb is enough for any URL */
+static DRM_DWORD s_idxUrl = 0;
+
+#define DRMTESTURLHELPER_USING_LICENSE_SERVER ( s_idxUrl != 0 )
+
+#ifdef DRMTESTURLHELPER_INITIALIZE_URL_FORCE_OVERRIDE_URL
+#define DRMTESTURLHELPER_INITIALIZE_URL_FORCE_OVERRIDE( __pszUrl ) __pszUrl = DRMTESTURLHELPER_INITIALIZE_URL_FORCE_OVERRIDE_URL
+#else
+#if DRMTESTURLHELPER_DEBUG_USING_PR_CORE_SERVER && DRMTESTURLHELPER_DEBUG_USING_PR_EDGE_SERVER
+#error Cannot set both  DRMTESTURLHELPER_DEBUG_USING_PR_CORE_SERVER  and  DRMTESTURLHELPER_DEBUG_USING_PR_EDGE_SERVER
+#elif DRMTESTURLHELPER_DEBUG_USING_PR_CORE_SERVER
+#define DRMTESTURLHELPER_INITIALIZE_URL_FORCE_OVERRIDE( __pszUrl ) __pszUrl = "test.playready.microsoft.com/core/rightsmanager.asmx"
+#elif DRMTESTURLHELPER_DEBUG_USING_PR_EDGE_SERVER
+#define DRMTESTURLHELPER_INITIALIZE_URL_FORCE_OVERRIDE( __pszUrl ) __pszUrl = "test.playready.microsoft.com/edge/rightsmanager.asmx"
+#else
+#define DRMTESTURLHELPER_INITIALIZE_URL_FORCE_OVERRIDE( __pszUrl )
+#endif
+#endif  /* DRMTESTURLHELPER_INITIALIZE_URL_FORCE_OVERRIDE_URL */
+
+#if DRMTESTURLHELPER_DEBUG_JSON
+#define DRMTESTURLHELPER_INITIALIZE_URL_QUERY_STRING   "?debug=json&cfg="
+#else
+#define DRMTESTURLHELPER_INITIALIZE_URL_QUERY_STRING   "?cfg="
+#endif
+
+#define DRMTESTURLHELPER_CLEAR_LACQ_URL() DRM_DO {                  \
+    ChkVOID( ZEROMEM( s_szLicAcqUrl, sizeof( s_szLicAcqUrl ) ) );   \
+    s_idxUrl = 0;                                                   \
+} DRM_WHILE_FALSE
+
+#define DRMTESTURLHELPER_INITIALIZE_LACQ_URL( __pszUrl ) DRM_DO {                                      \
+    DRMTESTURLHELPER_APPENDURLINTERNAL_ALWAYS( "http://" );                                            \
+    DRMTESTURLHELPER_INITIALIZE_URL_FORCE_OVERRIDE( __pszUrl );                                        \
+    DRMTESTURLHELPER_APPENDURLINTERNAL_ALWAYS( __pszUrl );                                             \
+    DRMTESTURLHELPER_APPENDURLINTERNAL_ALWAYS( DRMTESTURLHELPER_INITIALIZE_URL_QUERY_STRING );         \
+} DRM_WHILE_FALSE
+
+#define DRMTESTURLHELPER_APPENDURLINTERNAL_ALWAYS( __str ) DRM_DO {                 \
+    if( __str[ 0 ] != '\0' )                                                        \
+    {                                                                               \
+        DRM_DWORD __cch = 0;                                                        \
+        ChkDR( DRM_SizeTToDWord( DRMCRT_strlen( __str ), &__cch ) );                \
+        AssertChkBOOL( s_idxUrl + __cch + 1 < sizeof( s_szLicAcqUrl ) );            \
+        ChkVOID( MEMCPY( &s_szLicAcqUrl[ s_idxUrl ], __str, __cch ) );              \
+        s_idxUrl += __cch;                                                          \
+    }                                                                               \
+} DRM_WHILE_FALSE
+
+#define DRMTESTURLHELPER_APPENDURLINTERNAL_STRING( __str ) DRM_DO {                 \
+    if( DRMTESTURLHELPER_USING_LICENSE_SERVER )                                     \
+    {                                                                               \
+        DRMTESTURLHELPER_APPENDURLINTERNAL_ALWAYS( __str );                         \
+    }                                                                               \
+} DRM_WHILE_FALSE
+
+/* Base-10, no padding */
+#define DRMTESTURLHELPER_APPENDURLINTERNAL_DWORD( __value ) DRM_DO {                \
+    if( DRMTESTURLHELPER_USING_LICENSE_SERVER )                                     \
+    {                                                                               \
+        DRM_CHAR __rgch[ DRM_MAX_CCH_BASE10_DWORD_STRING + 1 ] = { 0 };             \
+        ChkDR( DRM_UTL_NumberToStringA(                                             \
+            __value, __rgch, DRM_NO_OF( __rgch ), 0, 10, NULL ) );                  \
+        DRMTESTURLHELPER_APPENDURLINTERNAL_STRING( __rgch );                        \
+    }                                                                               \
+} DRM_WHILE_FALSE
+
+/* Base-16, pad to two character, i.e. 00 to FF */
+#define DRMTESTURLHELPER_APPENDURLINTERNAL_BYTE( __value ) DRM_DO {                 \
+    if( DRMTESTURLHELPER_USING_LICENSE_SERVER )                                     \
+    {                                                                               \
+        DRM_CHAR __rgch[ DRM_MAX_CCH_BASE10_DWORD_STRING + 1 ] = { 0 };             \
+        DRMASSERT( __value <= 0xFF );                                               \
+        ChkDR( DRM_UTL_NumberToStringA(                                             \
+            __value, __rgch, DRM_NO_OF( __rgch ), 2, 16, NULL ) );                  \
+        DRMTESTURLHELPER_APPENDURLINTERNAL_STRING( __rgch );                        \
+    }                                                                               \
+} DRM_WHILE_FALSE
+
+#define DRMTESTURLHELPER_APPENDURLINTERNAL_CHAR( __char ) DRM_DO {                  \
+    if( DRMTESTURLHELPER_USING_LICENSE_SERVER )                                     \
+    {                                                                               \
+        AssertChkBOOL( s_idxUrl + 1 < sizeof( s_szLicAcqUrl ) );                    \
+        s_szLicAcqUrl[ s_idxUrl++ ] = ( __char );                                   \
+    }                                                                               \
+} DRM_WHILE_FALSE
+
+/* Removes the {} created by DRM_UTL_GuidToString during the call to DRM_UTL_DemoteUNICODEtoASCII */
+#define DRMTESTURLHELPER_APPENDURLINTERNAL_GUID( __pguid ) DRM_DO {                 \
+    if( DRMTESTURLHELPER_USING_LICENSE_SERVER )                                     \
+    {                                                                               \
+        DRM_WCHAR __rgwch[ DRM_GUID_STRING_LEN + 1 ] = { 0 };                       \
+        DRM_CHAR  __rgch[ DRM_GUID_STRING_LEN - 1 ]  = { 0 };                       \
+        ChkDR( DRM_UTL_GuidToString(                                                \
+            DRM_REINTERPRET_CAST( const DRM_GUID, __pguid ), __rgwch ) );           \
+        ChkVOID( DRM_UTL_DemoteUNICODEtoASCII(                                      \
+            &__rgwch[ 1 ], __rgch, DRM_GUID_STRING_LEN - 2 ) );                     \
+        DRMTESTURLHELPER_APPENDURLINTERNAL_STRING( __rgch );                        \
+    }                                                                               \
+} DRM_WHILE_FALSE
+
+#define DRMTESTURLHELPER_APPENDURLINTERNAL_STARTPOLICY( __str ) DRM_DO {            \
+    if( DRMTESTURLHELPER_USING_LICENSE_SERVER )                                     \
+    {                                                                               \
+        AssertChkBOOL( s_idxUrl > 0 );                                              \
+        DRMTESTURLHELPER_APPENDURLPOLICY_CONTINUEARRAY_FRIENDLY_NAMED( "..." );     \
+        DRMTESTURLHELPER_APPENDURLINTERNAL_STRING( __str );                         \
+    }                                                                               \
+} DRM_WHILE_FALSE
+
+#define DRMTESTURLHELPER_APPENDURLPOLICY_STRING( __param, __value ) DRM_DO {        \
+    if( DRMTESTURLHELPER_USING_LICENSE_SERVER )                                     \
+    {                                                                               \
+        DRMTESTURLHELPER_APPENDURLINTERNAL_STARTPOLICY( __param );                  \
+        DRMTESTURLHELPER_APPENDURLINTERNAL_CHAR( ':' );                             \
+        DRMTESTURLHELPER_APPENDURLINTERNAL_STRING( __value );                       \
+    }                                                                               \
+} DRM_WHILE_FALSE
+
+/* Examples:  0  ,  1  ,  17  ,  326  ,  4000000001 */
+#define DRMTESTURLHELPER_APPENDURLPOLICY_DWORD( __param, __value ) DRM_DO {         \
+    if( DRMTESTURLHELPER_USING_LICENSE_SERVER )                                     \
+    {                                                                               \
+        DRMTESTURLHELPER_APPENDURLINTERNAL_STARTPOLICY( __param );                  \
+        DRMTESTURLHELPER_APPENDURLINTERNAL_CHAR( ':' );                             \
+        DRMTESTURLHELPER_APPENDURLINTERNAL_DWORD( __value );                        \
+    }                                                                               \
+} DRM_WHILE_FALSE
+
+#define DRMTESTURLHELPER_APPENDURLPOLICY_BOOL( __param, __value ) DRM_DO {          \
+    if( DRMTESTURLHELPER_USING_LICENSE_SERVER )                                     \
+    {                                                                               \
+        DRMTESTURLHELPER_APPENDURLINTERNAL_STARTPOLICY( __param );                  \
+        DRMTESTURLHELPER_APPENDURLINTERNAL_CHAR( ':' );                             \
+        if ( __value  )                                                             \
+        {                                                                           \
+            DRMTESTURLHELPER_APPENDURLINTERNAL_STRING( "true" );                    \
+        }                                                                           \
+        else                                                                        \
+        {                                                                           \
+            DRMTESTURLHELPER_APPENDURLINTERNAL_STRING( "false" );                   \
+        }                                                                           \
+    }                                                                               \
+} DRM_WHILE_FALSE
+
+/* Example:  E296B58E-1866-6EF6-FECF-8DB44AD5FC24 */
+#define DRMTESTURLHELPER_APPENDURLPOLICY_GUID( __param, __value ) DRM_DO {          \
+    if( DRMTESTURLHELPER_USING_LICENSE_SERVER )                                     \
+    {                                                                               \
+        DRMTESTURLHELPER_APPENDURLINTERNAL_STARTPOLICY( __param );                  \
+        DRMTESTURLHELPER_APPENDURLINTERNAL_CHAR( ':' );                             \
+        DRMTESTURLHELPER_APPENDURLINTERNAL_GUID( __value );                         \
+    }                                                                               \
+} DRM_WHILE_FALSE
+
+/* Example 16 bytes:  04_CC_EC_12_41_42_45_16_47_34_A0_B3_A2_D0_00_36 */
+#define DRMTESTURLHELPER_APPENDURLPOLICY_BYTES( __param, __value, __size ) DRM_DO { \
+    if( DRMTESTURLHELPER_USING_LICENSE_SERVER )                                     \
+    {                                                                               \
+        DRM_DWORD __idx;                                                            \
+        DRMTESTURLHELPER_APPENDURLINTERNAL_STARTPOLICY( __param );                  \
+        DRMTESTURLHELPER_APPENDURLINTERNAL_CHAR( ':' );                             \
+        for( __idx = 0; __idx < ( __size ) - 1; __idx++ )                           \
+        {                                                                           \
+            DRMTESTURLHELPER_APPENDURLINTERNAL_BYTE( ( __value )[ __idx ] );        \
+            DRMTESTURLHELPER_APPENDURLINTERNAL_CHAR( '_' );                         \
+        }                                                                           \
+        DRMTESTURLHELPER_APPENDURLINTERNAL_BYTE( ( __value )[ __idx ] );            \
+    }                                                                               \
+} DRM_WHILE_FALSE
+
+/* Example Jan 5th, 2017: 20170105 */
+#define DRMTESTURLHELPER_APPENDURLPOLICY_SYSTEMTIME( __param, __value ) DRM_DO {    \
+    if( DRMTESTURLHELPER_USING_LICENSE_SERVER )                                     \
+    {                                                                               \
+        DRMTESTURLHELPER_APPENDURLPOLICY_DWORD( __param, __value.wYear );           \
+        if( __value.wMonth < 10 )                                                   \
+        {                                                                           \
+            DRMTESTURLHELPER_APPENDURLINTERNAL_DWORD( 0 );                          \
+        }                                                                           \
+        DRMTESTURLHELPER_APPENDURLINTERNAL_DWORD( __value.wMonth );                 \
+        if( __value.wDay < 10 )                                                     \
+        {                                                                           \
+            DRMTESTURLHELPER_APPENDURLINTERNAL_DWORD( 0 );                          \
+        }                                                                           \
+        DRMTESTURLHELPER_APPENDURLINTERNAL_DWORD( __value.wDay );                   \
+    }                                                                               \
+} DRM_WHILE_FALSE
+
+#define DRMTESTURLHELPER_APPENDURLPOLICY_OPENARRAY_FRIENDLY_NAMED( __param, __friendlyname ) DRM_DO {   \
+    if( __param[ 0 ] != '\0' )                                                                          \
+    {                                                                                                   \
+        DRMTESTURLHELPER_APPENDURLPOLICY_STRING( __param, "" );                                         \
+    }                                                                                                   \
+    DRMTESTURLHELPER_APPENDURLINTERNAL_CHAR( '(' );                                                     \
+} DRM_WHILE_FALSE
+
+#define DRMTESTURLHELPER_APPENDURLPOLICY_CONTINUEARRAY_FRIENDLY_NAMED( __friendlyname ) DRM_DO {        \
+    AssertChkBOOL( s_idxUrl > 0 );                                                                      \
+    if( s_szLicAcqUrl[ s_idxUrl - 1 ] != '(' )                                                          \
+    {                                                                                                   \
+        DRMTESTURLHELPER_APPENDURLINTERNAL_CHAR( ',' );                                                 \
+    }                                                                                                   \
+} DRM_WHILE_FALSE
+
+#define DRMTESTURLHELPER_APPENDURLPOLICY_CLOSEARRAY_FRIENDLY_NAMED( __friendlyname ) DRMTESTURLHELPER_APPENDURLINTERNAL_CHAR( ')' )
+
+PREFAST_POP  /* __WARNING_USE_SELECT_ANY_25046 */
+PREFAST_POP  /* __WARNING_URL_NEEDS_REVIEW_25085 */
+
+#endif  /* __DRMTESTURLHELPER_H__ */
+
diff --git a/prebuilt-v4.4/noarch/include/drmtoken.h b/prebuilt-v4.4/noarch/include/drmtoken.h
new file mode 100644
index 0000000..aa092b0
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmtoken.h
@@ -0,0 +1,139 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __DRM_TOKEN_H__
+#define __DRM_TOKEN_H__
+
+#include <drmtypes.h>
+#include <drmpragmas.h>
+
+ENTER_PK_NAMESPACE;
+
+typedef enum
+{
+    /* Tokens expected from the expression */
+    TOKEN_VARIABLE=0,
+    TOKEN_FUNCTION,
+
+    TOKEN_LONG,
+    TOKEN_DATETIME,
+    TOKEN_BYTEBLOB, /* Indicates that the data is variable length raw binary */
+    TOKEN_STRING,
+
+    TOKEN_PLUS,
+    TOKEN_MINUS,
+    TOKEN_ADD,
+    TOKEN_SUB,
+    TOKEN_MUL,
+    TOKEN_DIV,
+    TOKEN_MOD,
+    TOKEN_PREINCR,
+    TOKEN_POSTINCR,
+    TOKEN_PREDECR,
+    TOKEN_POSTDECR,
+    TOKEN_ASSIGN,
+    TOKEN_LESS,
+    TOKEN_LESSEQ,
+    TOKEN_GREAT,
+    TOKEN_GREATEQ,
+    TOKEN_NOTEQ,
+    TOKEN_EQ,
+    TOKEN_NOT,
+    TOKEN_AND,
+    TOKEN_OR,
+    TOKEN_IF,
+    TOKEN_COLON,
+    TOKEN_SEMICOLON,
+    TOKEN_OPEN,
+    TOKEN_CLOSE,
+    TOKEN_COMMA,
+    TOKEN_UNKNOWN,
+
+    /* For internal Use of the processing algorithm */
+    TOKEN_IFSKIP,
+    TOKEN_COLONSKIP,
+    TOKEN_ANDSKIP,
+    TOKEN_ORSKIP,
+    TOKEN_UNARYSYNC, /* indicates that the pre unary operator just pushed into operator stack needs  right operand. */
+    TOKEN_FUNCTIONSYNC, /* indicates that the fucntion sysmbol just pushed need right arguments. Popping of arguments should stop at this token. */
+} DRM_EXPR_TOKEN_TYPE;
+
+typedef enum
+{
+    FN_DATEADD,
+    FN_DATEDIFF,
+    FN_MIN,
+    FN_MAX,
+    FN_INDEX,
+    FN_DATEPART,
+    FN_VERSIONCOMPARE,
+    FN_DELETELICENSE,
+    FN_EXISTS,
+    FN_LENGTH
+} DRM_EXPR_FUNCTION_TYPE;
+
+/*
+   In the context of the expression evaluator any token can be placed in here.  When one of these tokens
+   is given to the secure store the only valid token types are
+       TOKEN_LONG and  TOKEN_DATETIME
+*/
+
+PRAGMA_WARNING_PUSH_WARN(4103)
+PRAGMA_PACK_PUSH_VALUE(1)
+
+typedef struct tagTOKEN
+{
+    DRM_DWORD TokenType;
+    union _tagTokenValue
+    {
+        DRM_UINT64 u64DateTime;
+        DRM_LONG lValue;
+        DRM_CONST_STRING stringValue;
+        DRM_DWORD fnValue;
+        DRM_BYTEBLOB byteValue;
+    } val;
+}TOKEN;
+
+/*
+** NOTE:  This structure should be 12 bytes long to allow for binary compatability of the secure store.
+**        Using MS Visual C++ we have to use #pragma pack to achieve this
+*/
+struct tagPERSISTEDTOKEN
+{
+    DRM_DWORD TokenType;
+    union _tagPersistedTokenValue
+    {
+        DRM_UINT64 u64DateTime;
+        DRM_LONG   lValue;
+        DRM_WORD   wValue;
+    } val;
+} DRM_PACKED;
+
+typedef struct tagPERSISTEDTOKEN PERSISTEDTOKEN;
+
+/* Calculates the number of bytes the token takes up when persisted */
+#define CALC_PERSISTEDTOKEN_FILE_LENGTH(pToken) (pToken->TokenType == TOKEN_BYTEBLOB ? DRM_MAX( sizeof( PERSISTEDTOKEN ), sizeof( PERSISTEDTOKEN ) + pToken->val.byteValue.cbBlob + (pToken->val.byteValue.cbBlob % 2)) : sizeof( PERSISTEDTOKEN ) )
+
+#define DRM_VERIFY_PERSISTEDTOKEN_FILE_LENGTH_MAX( __pToken ) DRM_DO {                                                      \
+    if( (__pToken)->TokenType == TOKEN_BYTEBLOB )                                                                           \
+    {                                                                                                                       \
+        DRM_DWORD __cbMath;                                                                                                 \
+        DRMCASSERT( DRM_SEC_STORE_MAX_SLOT_SIZE < DRM_MAX_UNSIGNED_TYPE( DRM_WORD ) );                                      \
+        ChkDR( DRM_DWordAdd( ( __pToken )->val.byteValue.cbBlob, ( __pToken )->val.byteValue.cbBlob % 2, &__cbMath ) );     \
+        ChkDR( DRM_DWordAddSame( &__cbMath, sizeof( PERSISTEDTOKEN ) ) );                                                   \
+        ChkBOOL( __cbMath < DRM_SEC_STORE_MAX_SLOT_SIZE, DRM_E_SECURESTORE_FULL );                                          \
+    }                                                                                                                       \
+} DRM_WHILE_FALSE
+
+PRAGMA_PACK_POP
+PRAGMA_WARNING_POP
+
+EXIT_PK_NAMESPACE;
+
+#endif /* __DRM_TOKEN_H__ */
+
diff --git a/prebuilt-v4.4/noarch/include/drmtoolsconstants.h b/prebuilt-v4.4/noarch/include/drmtoolsconstants.h
new file mode 100644
index 0000000..f6d9d12
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmtoolsconstants.h
@@ -0,0 +1,303 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __DRMTOOLSCONSTANTS_H__
+#define __DRMTOOLSCONSTANTS_H__
+
+#include <drmtypes.h>
+#include <drmprofiletypes.h>
+
+ENTER_PK_NAMESPACE;
+
+extern DRM_GLOBAL_CONST  DRM_BYTE          g_rgbFFFE[ 2 ];
+
+/*
+** cert tools
+*/
+
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrTagRequestDAC;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrTagDAC_PlayReady;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrTagManufName;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrTagOEMPrivateKeys;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrTagKeyValue;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrTagRSAKeyValue;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrTagSecurityLevel;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrModel;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrUnsignedtemplate;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrTagDataSecVerNumber;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrTagLicense;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrTagName;
+
+/*
+** Xpaths
+*/
+
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrXPathPlayReady_MDPubKey;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrXPathPlayReadyPrivKey;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrXPathPlayReadyPubKey;
+
+/*
+** generateDAC
+*/
+
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrTagDataSecurityVersionValue;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrAuthorizationIDDAC;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrTagSecurityLevelValue;
+
+/*
+** XML utils
+*/
+
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrTestTemplate;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrXMLTree1;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrXMLTree2;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrXMLTree3;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrXMLTree4;
+
+/*
+** package tools
+*/
+
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrTagRoot;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrTagKeySeed;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrTagLicAcqInfo;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrTagCustomData;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrEncBlkSize;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrCID;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrTagPrivkey;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrTagKeypair;
+
+/*
+** PlayReady Certificate Generator
+*/
+
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrVersion;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrCertType;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrDevice;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrPC;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrExtendedData;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrExtendedDataSigningKey;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrExtendedDataSigningKeyPublicKey;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrExtendedDataSigningKeyPrivateKey;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrExtendedDataRecord;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrDomain;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrSilverLight;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrApplication;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrMeteringCertType;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrServerCertType;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrIssuer;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrService;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrCRLSigner;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrKeyFileSigner;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrLicenseSigner;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrBasicInfo;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrSecurityLevel;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrClientID;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrExpiration;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrWarningDays;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrServiceID;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrAccountID;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrRevision;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrDomainUrl;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrSecurityVersion;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrSecurityVersionSeperator;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrExtendedDataSigningKeyType;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrExtendedDataSigningKeyPublicKeyValue;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrExtendedDataSigningKeyPrivateKeyValue;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrExtendedDataRecordType;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrExtendedDataRecordFlags;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrExtendedDataRecordMaxLength;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrExtendedDataRecordValue;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrTransmitter;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrReceiver;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrSharedCertificate;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrSecureClock;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrSecureTimeServer;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrRProvModelAuth;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrSampleProtectionRC4;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrSampleProtectionAES128CTR;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrRollbackClock;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrMetering;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrSymmOpt;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrSupportCRL;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrSupportPlayReady3Features;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrServerBasicEdition;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrServerStandardEdition;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrServerPremiumEdition;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrCertFeatures;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrCertManufacturer;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrManufacturerName;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrMake;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrModelName;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrModelNumber;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrLimits;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrCertKey;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrCertKeyType;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrCertKeys;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrCertECC256;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrCertKeyUsages;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrKeyUsageSign;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrKeyUsageEncryptKey;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrKeyUsageSignCRL;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrKeyUsageIssuerAll;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrKeyUsageIssuerIndiv;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrKeyUsageIssuerDevice;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrKeyUsageIssuerLink;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrKeyUsageIssuerDomain;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrKeyUsageIssuerSilverLight;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrKeyUsageIssuerApplication;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrKeyUsageIssuerCRLSigner;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrKeyUsageIssuerMetering;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrKeyUsageIssuerKeyFileSigner;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrKeyUsageIssuerLicenseSigner;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrKeyUsageIssuerServer;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrKeyUsageIssuerSecureTimeServer;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrKeyUsageIssuerRProvModelAuth;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrKeyUsageIssuerIndivWindows;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrKeyUsageIssuerIndivOsx;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrKeyUsageSignKeyFile;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrKeyUsageSignLicense;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrKeyUsageSignResponse;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrCertSigningKey;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrCertSigningKeyValue;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrPlatformIdentifier;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrMeteringID;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrMeteringUrl;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrOne;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrSigningKeyPrivKeyXPath;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrSigningKeyPubKeyXPath;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrSecurityVersionObject;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrSecurityVersionObjectPlatformId;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING  g_dstrSecurityVersionObjectNumber;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrDefaultSecurityLevel;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING g_dstrMSBinCert256KeyPUBKEY;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING g_dstrMSRSA1024CertKeyPUBKEYModulus;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING g_dstrMSRSA1024CertKeyPUBKEYExponent;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING g_dstrMSBinCert256KeyPRIVKEY;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING g_dstrMSRSA1024CertKeyPRIVKEYPrime0;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING g_dstrMSRSA1024CertKeyPRIVKEYPrime1;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING g_dstrMSRSA1024CertKeyPRIVKEYCRTExponent0;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING g_dstrMSRSA1024CertKeyPRIVKEYCRTExponent1;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING g_dstrMSRSA1024CertKeyPRIVKEYIQMP;
+
+/*********************************
+** DRM-related ASF Header GUIDs
+*********************************/
+extern DRM_GLOBAL_CONST  DRM_GUID g_guidASFHeaderObject;
+extern DRM_GLOBAL_CONST  DRM_GUID g_guidASFDataObject;
+extern DRM_GLOBAL_CONST  DRM_GUID g_guidASFContentEncryptionObject;
+extern DRM_GLOBAL_CONST  DRM_GUID g_guidASFExtendedContentEncryptionObject;
+extern DRM_GLOBAL_CONST  DRM_GUID g_guidASFHeaderExtensionObject;
+extern DRM_GLOBAL_CONST  DRM_GUID g_guidASFAdvancedContentEncryptionObject;
+extern DRM_GLOBAL_CONST  DRM_GUID g_guidASFFilePropertiesObject;
+extern DRM_GLOBAL_CONST  DRM_GUID g_guidASFDigitalSignatureObject;
+extern DRM_GLOBAL_CONST  DRM_GUID g_guidSystemIDPlayReady;
+extern DRM_GLOBAL_CONST  DRM_GUID g_guidASFReserved1;
+extern DRM_GLOBAL_CONST  DRM_GUID g_guidASFStreamPropertiesObject;
+extern DRM_GLOBAL_CONST  DRM_GUID g_guidASFStreamPropertiesObjectEx;
+extern DRM_GLOBAL_CONST  DRM_GUID g_guidASFXStreamTypeAcmAudio;
+extern DRM_GLOBAL_CONST  DRM_GUID g_guidASFXStreamTypeIcmVideo;
+
+/*
+** ASF Parsing Constants
+*/
+
+/*
+** ASF Header Object Minimum Sizes
+*/
+
+/*
+**   sizeof( DRM_GUID )         ObjectID
+** + sizeof( DRM_QWORD )        Object Size
+*/
+#define ASF_OBJ_MIN_SIZE        DRM_UI64LITERAL( 0, 24 )
+
+/*
+**   sizeof( DRM_GUID )         ObjectID
+** + sizeof( DRM_QWORD )        Object Size
+** + sizeof( DRM_DWORD )        Number of Sub Objects
+** + sizeof( DRM_BYTE )         Alignment
+** + sizeof( DRM_BYTE )         Architecture
+*/
+#define ASF_HDR_MIN_SIZE        DRM_UI64LITERAL( 0, 30 )
+
+/*
+**   sizeof( DRM_GUID )         ObjectID
+** + sizeof( DRM_QWORD )        Object Size
+** + sizeof( DRM_GUID )         id of header extension (clock) object
+** + sizeof( DRM_WORD )         clock size/type
+** + sizeof( DRM_DWORD )        clock data size
+*/
+#define ASF_HDREXT_MIN_SIZE     DRM_UI64LITERAL( 0, 46 )
+#define ASF_V1_MIN_SIZE         DRM_UI64LITERAL( 0, 40 )
+#define ASF_FILEPROP_MIN_SIZE   DRM_UI64LITERAL( 0, 104 )
+
+/*
+**   sizeof( DRM_GUID )         error correction type
+** + sizeof( DRM_QWORD )        time offset
+*/
+#define ASF_STREAM_PROPERTIES_SKIP_SIZE  DRM_UI64LITERAL( 0, 24 )
+
+/*
+**   sizeof( DRM_GUID )         ObjectID
+** + sizeof( DRM_QWORD )        Object Size
+** + sizeof( DRM_GUID )         Stream Type
+** + ASF_STREAM_PROPERTIES_SKIP_SIZE
+** + sizeof( DRM_DWORD )        type-specific data length
+** + sizeof( DRM_DWORD )        error correction data length
+** + sizeof( DRM_WORD )         Flags
+** + sizeof( DRM_DWORD )        Reserved
+*/
+#define ASF_STREAM_PROPERTIES_MIN_SIZE  DRM_UI64LITERAL( 0, 86 )
+
+/*********************************
+** ASF Audio Format Tags
+*********************************/
+#define DRMTOOLS_ASF_AUDIO_TYPE_WMA           0x0161 /* Windows Media Audio */
+#define DRMTOOLS_ASF_AUDIO_TYPE_GSM_AMR_FIXED 0x7A21 /* GSM-AMR (fixed bitrate, no SID) */
+#define DRMTOOLS_ASF_AUDIO_TYPE_GSM_AMR_VBR   0x7A22 /* GSM-AMR (variable bitrate, including SID) */
+
+/*
+** Constants for header evaluation
+*/
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING      g_dstrTagV24LAURL;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING      g_dstrTagV24LUIURL;
+
+typedef struct
+{
+    const DRM_CHAR * m_pszScopeName;
+    DRM_DWORD m_dwScopeID;
+
+
+    /*
+    ** The following are constants used only by the
+    ** autobench tool for automated perf testing
+    */
+    DRM_DWORD m_dwABRPMCounter;
+    DRM_DWORD m_dwABCPMCounter;
+} DRM_SCOPE;
+
+extern DRM_SCOPE g_Scopes[];
+
+#ifndef PERF_SCOPE_ID
+#define PERF_SCOPE_ID(ModuleID, FuncID, BlockID)    ((((ModuleID) & 0x0fff) << 19) + (((FuncID) & 0x0fff) << 7) + ((BlockID) & 0x007f))
+#endif
+
+    extern DRM_GLOBAL_CONST  DRM_CONST_STRING       g_dstrVersion_1_0;
+    extern DRM_GLOBAL_CONST  DRM_CONST_STRING       g_dstrTagFallback;
+    extern DRM_GLOBAL_CONST  DRM_CONST_STRING       g_dstrTagDNIUniqueID;
+    extern DRM_GLOBAL_CONST  DRM_CONST_STRING       g_dstrDeviceRevocationList;
+    extern DRM_GLOBAL_CONST  DRM_CONST_STRING       g_dstrPFRootTag;
+    extern DRM_GLOBAL_CONST  DRM_CONST_STRING       g_dstrTagDataId;
+    extern DRM_GLOBAL_CONST  DRM_CONST_STRING       g_dstrManufacturer;
+
+EXIT_PK_NAMESPACE;
+
+#endif /* __DRMTOOLSCONSTANTS_H__ */
+
diff --git a/prebuilt-v4.4/noarch/include/drmtrace.h b/prebuilt-v4.4/noarch/include/drmtrace.h
new file mode 100644
index 0000000..7feb0d2
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmtrace.h
@@ -0,0 +1,248 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __DRMTRACE_H__
+#define __DRMTRACE_H__
+
+#include <drmtypes.h>
+#include <drmpragmas.h>
+
+ENTER_PK_NAMESPACE;
+
+/*
+** Maximum number of components that can be defined.
+** DRM_TRACE_COMPONENT_ID macro is used to assign a component
+** ID (DWORD) to a scope.
+*/
+#define MAX_TRACE_COMPONENT     256
+
+/* Enumeration of the various trace level. */
+typedef enum __tag_eTraceLevel
+{
+    TRACE_NONE     = 0,
+    TRACE_FATAL    = 1,
+    TRACE_CRITICAL = 2,
+    TRACE_WARNING  = 3,
+    TRACE_INFO     = 4,
+    TRACE_VERBOSE  = 5
+} eTraceLevel;
+
+/* Enumeration of the various robustness level. */
+typedef enum __tag_eTraceRobustLevel
+{
+    TRACE_NON_ROBUST  = 0,
+    TRACE_ROBUST      = 1,
+    TRACE_MOST_ROBUST = 2
+} eTraceRobustLevel;
+
+#define TRACE_DEFAULT_ROBUST    TRACE_NON_ROBUST
+
+/*
+** Predefined event type for scope.
+*/
+typedef enum __tag_eTraceScopeEventType
+{
+    TRACE_DEFAULT_EVENT = 0,
+    TRACE_ENTER_SCOPE   = 1,
+    TRACE_LEAVE_SCOPE   = 2
+    /* OEM may define customized events starting with value 4. */
+} eTraceScopeEventType;
+
+/* Enumeration of the various trace channels. */
+typedef enum __tag_eTraceChannelType
+{
+    TRACE_CONSOLE_CHANNEL = 0x01,
+    TRACE_FILE_CHANNEL    = 0x02,
+    /* OEM may define customized channels starting with mask 0x04. */
+} eTraceChannelType;
+
+#if DRM_SUPPORT_TRACING
+
+/* Global trace context data structure. */
+typedef struct __tagTRACE_GLOBAL_CONTEXT
+{
+    /* Current global trace level. */
+    eTraceLevel m_eTraceLevel;
+
+    /* Default component trace levels. */
+    eTraceLevel m_rgeComponentTraceLevels[ MAX_TRACE_COMPONENT ];
+
+    /*
+    ** Init flag to indicate whether the
+    ** data structure has been initialized.
+    */
+    DRM_BOOL m_fInit;
+
+    /*
+    ** OEM data field to allow OEM to store its
+    ** specific information (such as a trace log
+    ** file pointer).
+    */
+    DRM_VOID *m_pvOEMData;
+
+    /*
+    ** Flag indicating whether is currently in
+    ** Oem_Trace_Enter/LeaveScope() API. This flag
+    ** is used to prevent recursive entering
+    ** of Oem_Trace_Enter/LeaveScope().
+    */
+    DRM_BOOL m_fEnterScope;
+
+    /*
+    ** Flag indicating whether is currently in
+    ** Oem_Trace_Start API. This flag
+    ** is used to prevent recursive entering
+    ** of Oem_Trace_Start.
+    */
+    DRM_BOOL m_fStartTrace;
+
+    /* Bit mask of trace channel. */
+    DRM_DWORD m_dwChannelMask;
+
+} DRM_TRACE_GLOBAL_CONTEXT;
+
+EXIT_PK_NAMESPACE;
+
+#include <oemtrace.h>
+
+ENTER_PK_NAMESPACE;
+
+DRM_API DRM_TRACE_GLOBAL_CONTEXT * DRM_CALL Oem_Trace_GetGlobalContext( DRM_VOID );
+
+/** OEM MUST provide its own mapping of the following DRM_TRACE macros in oemtrace.h. */
+
+/*
+** #define DRM_TRACE_ID( trace_id )
+** Note: DRM_TRACE_ID macro is used to handle all trace_id's in a single location e.g if
+**       the OEM layer would like to ignore (and hence not define) the trace ID's then
+**       this macro can be used to define all such trace_id's to say 0.  If OEM layer is
+**       going to use the trace_id's, then it must define the values for the trace_ids.
+**
+** #define DRM_TRACE( szFormat )
+** Note: DRM_TRACE macro is used to trace an arbitrary format string with arbitrary number
+**       of parameters. The length of the result string is only limited by OEM's specific
+**       implementation. All information must be enclosed by a pair of parenthesis. For example,
+**       DRM_TRACE( ( "%s %d.", "Hello World", 123 ) ).
+**       DRM_TRACE must be used within a scope that has already been defined by the
+**       the DRM_PROFILING_ENTER_SCOPE and DRM_PROFILING_LEAVE_SCOPE macros.
+**
+** #define DRM_TRACE_NO_SCOPE( szFormat )
+** Note: DRM_TRACE_NO_SCOPE is almost identical to DRM_TRACE, with the only difference that
+**       DRM_TRACE_NO_SCOPE can be used anywhere whether a scope has been defined or not.
+**       Traces originated from DRM_TRACE_NO_SCOPE cannot be filtered since they are not
+**       associated with either a specific scope or a specific component.
+**       The DRM_DBG_TRACE macro is translated into DRM_TRACE_NO_SCOPE.
+**
+** #define DRM_TRACE_ID0( eRobust, dwID, dwParam0 )
+** #define DRM_TRACE_ID1( eRobust, dwID, dwParam0, dwParam1 )
+** #define DRM_TRACE_ID2( eRobust, dwID, dwParam0, dwParam1, dwParam2 )
+** #define DRM_TRACE_ID3( eRobust, dwID, dwParam0, dwParam1, dwParam2, dwParam3 )
+** Note: DRM_TRACE_IDX macros are used to trace a predefined format string specified by a
+**       format string ID. The format string takes zero or more DWORD parameters.
+**       If OEM wants to use format strings with more than three parameters, it can add more
+**       macro definitions to the DRM_TRACE_IDX macro group.
+**
+** #define DRM_TRACE_ENTER_SCOPE( eRobust, dwScopeID )
+** #define DRM_TRACE_LEAVE_SCOPE( eRobust, dwScopeID, dr )
+** Note: The enter/leave scope trace maros are implicitly called by DRM_PROFILING_ENTER_SCOPE
+**       and DRM_PROFILING_LEAVE_SCOPE macros. Generally user should not deal with these two
+**       macros directly. It is recommended to set the filter level of enter/leave scope trace
+**       at a higher trace level (e.g. equal to or above TRACE_INFO ) to avoid unnecessary
+**       details.
+**
+** #define DRM_TRACE_STATUS_CODE( eRobust, dwEventID, dr )
+** Note: The status trace macro is used to trace a status code associated with a specific
+**       event ID. The exact meaning of an event ID is defined by the user.
+**
+** #define DRM_TRACE_START( pOEMContext, pdstrFilename )
+** #define DRM_TRACE_STOP()
+** Note: The start/stop trace macros are defined by OEM to start/stop the tracing machanism.
+**       For example, OEM can open a trace log file when DRM_TRACE_START is called, and close
+**       the trace log file when DRM_TRACE_STOP is called.
+*/
+
+/* The following macros are shared by all OEM tracing implementations. */
+
+/*
+** Set the global trace level to a certain level will filter out all traces from
+** scopes that have scope tracel level higher than the global trace level.
+*/
+#define DRM_GLOBAL_TRACE_LEVEL( Level ) \
+                                    Oem_Trace_GetGlobalContext()->m_eTraceLevel = ( Level );
+
+/*
+** Set the global component trace level to a certain level will filter out all traces from
+** components that have component trace level higher than the global component trace level.
+*/
+#define DRM_GLOBAL_COMPONENT_TRACE_LEVEL( ID, Level ) \
+                                    if ( ID >=0 && ID < MAX_TRACE_COMPONENT ) \
+                                    { \
+                                        Oem_Trace_GetGlobalContext()->m_rgeComponentTraceLevels[ ID ] = ( Level ); \
+                                    }
+
+/*
+** Define the current scope trace level. The current scope must have already been defined
+** by the DRM_PROFILING_ENTER_SCOPE and DRM_PROFILING_LEAVE_SCOPE macros.
+*/
+#define DRM_TRACE_LEVEL( Level )    ScopeContext.m_eTraceLevel = ( Level );
+
+/*
+** Associate the current scope with a component ID. By default all scopes belongs to component 0.
+** Each scope can only be associated with one component at one time. The current scope must have
+** already been defined by the DRM_PROFILING_ENTER_SCOPE and DRM_PROFILING_LEAVE_SCOPE macros.
+*/
+#define DRM_TRACE_COMPONENT_ID( ID ) \
+                                    ScopeContext.m_dwComponent = ( ID );
+
+/*
+** Internal macro that is used to determine whether the trace from the current scope should be filtered.
+** The trace from the current scope should be filtered if both of the following conditions are met:
+** 1. The current scope has a scope tracel level that is higher than the global trace level.
+** 2. The current scope has a component trace level that is higher than the global component trace level.
+*/
+#define _DRM_TRACE_IF_NOT_FILTERED   if ( Oem_Trace_GetGlobalContext()->m_eTraceLevel >= ScopeContext.m_eTraceLevel || \
+                                          Oem_Trace_GetGlobalContext()->m_rgeComponentTraceLevels[ ScopeContext.m_dwComponent ] >= ScopeContext.m_eTraceLevel )
+
+/* Turn on a specific trace channel. By default only console channel ( TRACE_CONSOLE_CHANNEL ) is turned on. */
+#define DRM_TRACE_CHANNEL_ON( Channel ) \
+                                    Oem_Trace_GetGlobalContext()->m_dwChannelMask |= ( ( Channel ) );
+
+/* Turn off a specific trace channel. */
+#define DRM_TRACE_CHANNEL_OFF( Channel ) \
+                                    Oem_Trace_GetGlobalContext()->m_dwChannelMask &= ( ~( Channel ) );
+
+#else
+
+/* Define all trace macros to nothing is DRM_SUPPORT_TRACING is 0. */
+#define DRM_TRACE_ID( trace_id )
+#define DRM_TRACE( szFormat )
+#define DRM_TRACE_NO_SCOPE( szFormat )
+#define DRM_TRACE_ID0( eRobust, dwID, dwParam0 )
+#define DRM_TRACE_ID1( eRobust, dwID, dwParam0, dwParam1 )
+#define DRM_TRACE_ID2( eRobust, dwID, dwParam0, dwParam1, dwParam2 )
+#define DRM_TRACE_ID3( eRobust, dwID, dwParam0, dwParam1, dwParam2, dwParam3 )
+#define DRM_TRACE_ENTER_SCOPE( eRobust, dwScopeID )
+#define DRM_TRACE_LEAVE_SCOPE( eRobust, dwScopeID, dr )
+#define DRM_TRACE_STATUS_CODE( eRobust, dwEventID, dr )
+#define DRM_TRACE_START( pOEMContext, pdstrFilename )
+#define DRM_TRACE_STOP()
+
+#define DRM_GLOBAL_TRACE_LEVEL( Level )
+#define DRM_GLOBAL_COMPONENT_TRACE_LEVEL( ID, Level )
+#define DRM_TRACE_LEVEL( Level )
+#define DRM_TRACE_COMPONENT_ID( ID )
+#define DRM_TRACE_IF_NOT_FILTERED
+#define DRM_TRACE_CHANNEL_ON( Channel )
+#define DRM_TRACE_CHANNEL_OFF( Channel )
+
+#endif  /* DRM_SUPPORT_TRACING */
+
+EXIT_PK_NAMESPACE;
+
+#endif  /* __DRMTRACE_H__ */
+
diff --git a/prebuilt-v4.4/noarch/include/drmtypes.h b/prebuilt-v4.4/noarch/include/drmtypes.h
new file mode 100644
index 0000000..048474e
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmtypes.h
@@ -0,0 +1,558 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __DRMTYPES_H__
+#define __DRMTYPES_H__
+
+#include <drmnamespace.h>   /* defining proper namespace (if used) */
+#include <drmcompiler.h>
+#include <drmint64.h>
+#include <drmsal.h>
+#include <drmpragmas.h>
+
+ENTER_PK_NAMESPACE;
+
+#ifndef DRM_RESULT_DEFINED
+#define DRM_RESULT_DEFINED
+typedef __success(return>=0) DRM_LONG  DRM_RESULT;
+#endif /*DRM_RESULT_DEFINED*/
+
+#ifndef DRM_CHAR_BIT
+#define DRM_CHAR_BIT      8                /* number of bits in a char    */
+#endif
+
+#ifndef DRM_ISODD
+#define DRM_ISODD(x) ((x)&1)
+#endif
+
+/*
+** Using sizeof(DRM_UINT64) can return different values on different platforms
+** because it could be implemented as a built in type or as a struct with
+** possibly varying packing.  Some places need to use a value for a serialized
+** QWORD size so just define it here.
+*/
+#define DRM_SIZEOFQWORD 8
+
+#ifndef DRM_BITS_PER_BYTE
+#define DRM_BITS_PER_BYTE (8)
+#endif
+
+#if DRM_64BIT_TARGET
+typedef DRM_UINT64 DRM_SIZE_T;
+#else  /* DRM_64BIT_TARGET */
+typedef DRM_DWORD DRM_SIZE_T;
+#endif /* DRM_64BIT_TARGET */
+
+#ifndef DRM_NO_OF
+#if defined(__cplusplus) && !defined(_PREFAST_) && ( DRM_MSC_VER >= 1400 )
+/*
+** Use a template to ensure that DRM_NO_OF is never called with a pointer.
+** Templates cannot be declared to have 'C' linkage, so extern "C++".
+*/
+extern "C++" template <typename T, DRM_SIZE_T N> char (*DRM_NUMBER_OF_FUNCTION(T(&)[N]))[N];
+#define DRM_NO_OF( x )  ( sizeof(*DRM_NUMBER_OF_FUNCTION(x)) )
+#else
+#define DRM_NO_OF( x )  ( sizeof( (x) ) / sizeof( (x)[0] ) )
+#endif
+#endif /* #ifndef DRM_NO_OF */
+
+#define DRM_IS_DWORD_ALIGNED( x ) ( ( DRM_SIZE_T )( x ) % sizeof( DRM_SIZE_T ) == 0 )
+#define DRM_DWORD_ALIGNED_SIZE( x ) ( ( (x) % sizeof( DRM_SIZE_T ) == 0 ) ? (x) : (x) + ( sizeof( DRM_SIZE_T ) - ( (x) % sizeof( DRM_SIZE_T ) ) ) )
+
+typedef struct __tagDRM_GUID {
+    DRM_DWORD Data1;
+    DRM_WORD  Data2;
+    DRM_WORD  Data3;
+    DRM_BYTE  Data4 [ 8 ];
+} DRM_GUID;
+
+#define DRM_EMPTY_DRM_GUID  { 0, 0, 0, { 0, 0, 0, 0, 0, 0, 0, 0 } }
+
+#define DRM_IDENTICAL_GUIDS(p0,p1) \
+    (OEM_SECURE_ARE_EQUAL((p0), (p1), sizeof(DRM_GUID)))
+
+
+#if TARGET_LITTLE_ENDIAN
+
+/*
+** The following macro should be used to define GUIDs that are local to a single code file.
+*/
+#define DRM_DEFINE_LOCAL_GUID( name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8 )    \
+        static DRM_GLOBAL_CONST DRM_GUID name                                       \
+                = { l, w1, w2, { b1, b2, b3, b4, b5, b6, b7, b8 } }
+
+/*
+** The following two macros should be used to declare and define GUIDs that are
+** shared among multiple code files.
+*/
+#define DRM_DEFINE_GUID( name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8 )          \
+        const DRM_EXPORT_VAR DRM_GUID name                                          \
+                = { l, w1, w2, { b1, b2, b3, b4, b5, b6, b7, b8 } }
+#else
+
+/*
+** The following macro should be used to define GUIDs that are local to a single code file.
+*/
+#define DRM_DEFINE_LOCAL_GUID( name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8 )    \
+        static DRM_GLOBAL_CONST DRM_GUID name                                       \
+                = { FLIP_DWORD_BYTES(l), FLIP_WORD_BYTES(w1), FLIP_WORD_BYTES(w2),  \
+                  { b1, b2, b3, b4, b5, b6, b7, b8 } }
+
+/*
+** The following two macros should be used to declare and define GUIDs that are
+** shared among multiple code files.
+*/
+#define DRM_DEFINE_GUID( name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8 )          \
+        const DRM_EXPORT_VAR DRM_GUID name                                          \
+                = { FLIP_DWORD_BYTES(l), FLIP_WORD_BYTES(w1), FLIP_WORD_BYTES(w2),  \
+                  { b1, b2, b3, b4, b5, b6, b7, b8 } }
+
+#endif
+
+#define DRM_DECLARE_GUID( name )    \
+        extern const DRM_EXPORT_VAR DRM_GUID name
+
+/*
+** This macro will calculate the maximum value of an unsigned data type
+** where the type is passed in as x.
+** For example DRM_MAX_UNSIGNED_TYPE( DRM_BYTE  ) will evaluate to 0xFF
+**             DRM_MAX_UNSIGNED_TYPE( DRM_DWORD ) will evaluate to 0xFFFFFFFF
+*/
+#define DRM_MAX_UNSIGNED_TYPE(x) ( (x)~((x)0) )
+
+/*
+** This macro will calculate the maximum value of an signed data type
+** where the type is passed in as x.
+** For example DRM_MAX_SIGNED_TYPE( DRM_CHAR) will evaluate to 0x7F
+**             DRM_MAX_SIGNED_TYPE( DRM_LONG ) will evaluate to 0x7FFFFFFF
+*/
+#define DRM_MAX_SIGNED_TYPE(x) ( (x)~((x)1 << (sizeof(x)*8 - 1)) )
+
+/*
+** This macro will calculate the minimum value of an signed data type
+** where the type is passed in as x.
+** For example DRM_MIN_SIGNED_TYPE( DRM_CHAR  ) will evaluate to 0x80
+**             DRM_MIN_SIGNED_TYPE( DRM_LONG ) will evaluate to 0x80000000
+*/
+#define DRM_MIN_SIGNED_TYPE(x) ( (x)((x)1 << (sizeof(x)*8 - 1)) )
+
+typedef struct tagDRM_CONST_STRING
+{
+DRM_OBFUS_PTR_TOP
+    const DRM_WCHAR *pwszString;
+DRM_OBFUS_PTR_BTM
+    DRM_DWORD        cchString;
+DRM_OBFUS_FILL_BYTES(4)
+} DRM_CONST_STRING;
+
+typedef struct tagDRM_STRING
+{
+DRM_OBFUS_PTR_TOP
+    DRM_WCHAR *pwszString;
+DRM_OBFUS_PTR_BTM
+    DRM_DWORD  cchString;
+DRM_OBFUS_FILL_BYTES(4)
+} DRM_STRING;
+
+typedef struct tagDRM_ANSI_CONST_STRING
+{
+DRM_OBFUS_PTR_TOP
+    const DRM_CHAR *pszString;
+DRM_OBFUS_PTR_BTM
+    DRM_DWORD       cchString;
+DRM_OBFUS_FILL_BYTES(4)
+} DRM_ANSI_CONST_STRING;
+
+typedef struct tagDRM_ANSI_STRING
+{
+DRM_OBFUS_PTR_TOP
+    DRM_CHAR  *pszString;
+DRM_OBFUS_PTR_BTM
+    DRM_DWORD  cchString;
+DRM_OBFUS_FILL_BYTES(4)
+} DRM_ANSI_STRING;
+
+typedef struct __tagSubString
+{
+    DRM_DWORD m_ich;
+    DRM_DWORD m_cch;
+} DRM_SUBSTRING;
+
+typedef struct tagDRM_STRING_WINDOW
+{
+    DRM_DWORD m_ichMin; /* inclusive */
+    DRM_DWORD m_ichMaxExclusive; /* exclusive */
+} DRM_STRING_WINDOW;
+
+#define DRM_ASSIGN_DRM_ANSI_STRING(x,y) DRM_DO {    \
+    (x).pszString = (y);                            \
+    (x).cchString = DRM_NO_OF(y)-1;                 \
+} DRM_WHILE_FALSE
+
+#define DRM_ASSIGN_DRM_STRING(x,y) DRM_DO {         \
+    (x).pwszString = (y).pwszString;                \
+    (x).cchString  = (y).cchString;                 \
+} DRM_WHILE_FALSE
+
+#define DRM_INIT_DRM_STRING(x) DRM_DO {             \
+    (x).pwszString = NULL;                          \
+    (x).cchString  = 0;                             \
+} DRM_WHILE_FALSE
+
+#define DRM_INIT_DRM_ANSI_STRING(x) DRM_DO {        \
+    (x).pszString = NULL;                           \
+    (x).cchString = 0;                              \
+} DRM_WHILE_FALSE
+
+/*
+** This macro can only be used at the declaration of DRM_STRING.
+** It initailizes DRM string from DRM_WCHAR array.
+** Wide strings should always be declared using the DRM_ONE_WCHAR macro
+** or the DRM_WCHAR_CAST macro, not the L"" syntax.
+** Using the L"" syntax will generate strings like "S\0t\0r\0i\0n\0g\0"
+** (i.e. Big-Endian UTF16), but this porting kit assumes ALL wide strings
+** are Little-Endian UTF16.  It will also fail to compile on ARM64
+** where the wchar_t type (which is what L"" translates to) is UTF32.
+**
+** e.g. the empty string L"" becomes:
+static DRM_GLOBAL_CONST DRM_WCHAR s_rgwch[] = { DRM_WCHAR_CAST( '\0' ) };
+**
+** e.g. the string L"Fa" becomes:
+static DRM_GLOBAL_CONST DRM_WCHAR s_rgwchFa[] = { DRM_WCHAR_CAST( 'F' ), DRM_WCHAR_CAST( 'a' ), DRM_WCHAR_CAST( '\0' ) };
+**
+** Locating offending strings:
+findstr /rnsp /c:"[^A-Za-z]L\"" *.c *.h
+**
+** The following regular expression used in visual studio can make conversion easier:
+** First, remove the opening/closing " chars.  Second, remove \ chars used as escapes.
+** Third, use Find/Replace with regex on, selection only, while highlighting the string excluding " chars.
+** Replace this (i.e. any character)...
+.
+** ...with this...
+DRM_WCHAR_CAST( '$0' ),
+**
+** That will fix everything but:
+**  The opening curly:        {
+**  The null terminator:      DRM_WCHAR_CAST( '\0' )
+**  The closing curly/semi:   };
+*/
+#define DRM_CREATE_DRM_STRING(x) { DRM_OBFUS_INIT_PTR_TOP ((const DRM_WCHAR *) (x)), DRM_OBFUS_INIT_PTR_BTM (DRM_NO_OF(x)) - 1 }
+
+#if TARGET_LITTLE_ENDIAN
+#define DRM_WCHAR_CAST(x)   ((DRM_WCHAR)(x))
+#define DRM_NATIVE_WCHAR(x) (x)
+#define DRM_MAKE_MACHINE_WCHAR(ch0,ch1)  ( ((ch1)<<8) | ((ch0) & 0x00FF) )
+#else
+#define DRM_WCHAR_CAST(x)   ((DRM_WCHAR)((x)<<8))
+#define DRM_NATIVE_WCHAR(x) ((DRM_WCHAR)((x)>>8))
+#define DRM_MAKE_MACHINE_WCHAR(ch0,ch1)  ( ((ch0)<<8) | ((ch1) & 0x00FF) )
+#endif
+
+#define DRM_ONE_WCHAR(ch0,ch1)           ((DRM_WCHAR)(DRM_MAKE_MACHINE_WCHAR(ch0,ch1)))
+
+/*
+** In case these have been already defined, don't redefine.
+** If you use these macros for string declarations, you have to
+** add those strings to drmallstrings.c
+*/
+#ifndef DRM_INIT_CHAR_OBFUS
+#define DRM_INIT_CHAR_OBFUS(x) x
+#endif
+#ifndef DRM_INIT_WCHAR_OBFUS
+#define DRM_INIT_WCHAR_OBFUS(x) DRM_WCHAR_CAST(x)
+#endif
+#ifndef DRM_STR_CONST
+#define DRM_STR_CONST const
+#endif
+#ifndef DRM_INIT_ALL_STRINGS
+#define DRM_INIT_ALL_STRINGS DRM_DO {} DRM_WHILE_FALSE
+#endif
+
+/*
+** Note: in drmconstants.c DRM_CREATE_DRM_ANSI_STRING should be used
+** with caution. When we create a const ansi string from const char[] arrays
+** an array may have one or two trailing zero chars for alignment reasons,
+** but this macro just always sets ansi string's char size into a size of array - 1.
+*/
+#define DRM_CREATE_DRM_ANSI_STRING(x) { DRM_OBFUS_INIT_PTR_TOP (x), DRM_OBFUS_INIT_PTR_BTM ((DRM_NO_OF(x))-1)}
+#define DRM_CREATE_DRM_ANSI_STRING_EX(x,s) { DRM_OBFUS_INIT_PTR_TOP (x), DRM_OBFUS_INIT_PTR_BTM (s) }
+
+#define DRM_EMPTY_DRM_STRING        { DRM_OBFUS_INIT_PTR_TOP NULL, DRM_OBFUS_INIT_PTR_BTM 0 }
+#define DRM_EMPTY_DRM_SUBSTRING     { 0, 0 }
+#define DRM_EMPTY_DRM_STRING_WINDOW { 0, 0 }
+
+/*
+**  Assert if the pointer is not DRM_WCHAR aligned
+*/
+
+#define DRM_DSTR_FROM_PB(pdstr,pb,cb) DRM_DO {                                                                                  \
+    (pdstr)->cchString=(cb)/sizeof(DRM_WCHAR);                                                                                  \
+PREFAST_PUSH_DISABLE_EXPLAINED( __WARNING_SUPERFLUOUS_CAST_25059, "Macro is used when pb is already DRM_WCHAR*" )               \
+    (pdstr)->pwszString=(DRM_WCHAR*)(pb);                                                                                       \
+    DRMASSERT( (DRM_SIZE_T)(pb) % sizeof( DRM_WCHAR ) == 0 );                                                                   \
+PREFAST_POP                                                                                                                     \
+} DRM_WHILE_FALSE
+
+#define DRM_CONST_DSTR_FROM_PB(pdstr,pb,cb) DRM_DO {                                                                            \
+    (pdstr)->cchString=(cb)/sizeof(DRM_WCHAR);                                                                                  \
+PREFAST_PUSH_DISABLE_EXPLAINED( __WARNING_SUPERFLUOUS_CAST_25059, "Macro is used when pb is already const DRM_WCHAR*" )         \
+    (pdstr)->pwszString=(const DRM_WCHAR*)(pb);                                                                                 \
+    DRMASSERT( (DRM_SIZE_T)(pb) % sizeof( DRM_WCHAR ) == 0 );                                                                   \
+PREFAST_POP                                                                                                                     \
+} DRM_WHILE_FALSE
+
+#define DRM_DASTR_FROM_PB(pdastr,pb,cb) DRM_DO {                                                                                \
+    (pdastr)->cchString=(cb)/( sizeof( DRM_CHAR ) );                                                                            \
+PREFAST_PUSH_DISABLE_EXPLAINED( __WARNING_SUPERFLUOUS_CAST_25059, "Macro is used when pb is already DRM_CHAR*" )                \
+    (pdastr)->pszString=(DRM_CHAR*)(pb);                                                                                        \
+PREFAST_POP                                                                                                                     \
+} DRM_WHILE_FALSE
+
+#define DRM_CONST_DASTR_FROM_PB(pdastr,pb,cb) DRM_DO {                                                                          \
+    (pdastr)->cchString=(cb)/( sizeof( DRM_CHAR ) );                                                                            \
+PREFAST_PUSH_DISABLE_EXPLAINED( __WARNING_SUPERFLUOUS_CAST_25059, "Macro is used when pb is already const DRM_CHAR*" )          \
+    (pdastr)->pszString=(const DRM_CHAR*)(pb);                                                                                  \
+PREFAST_POP                                                                                                                     \
+} DRM_WHILE_FALSE
+
+/*
+** for frequent uses of DRM_CONST_STRINGs' char counts and
+** wide-char buffers as byte counts and byte buffers
+*/
+
+#define DRM_PB_DSTR(pdstr) (DRM_BYTE*)((pdstr)->pwszString)
+#define DRM_CB_DSTR(pdstr) ((pdstr)->cchString*sizeof(DRM_WCHAR))
+#define DRM_CONST_PB_DSTR(pdstr) (const DRM_BYTE*)((pdstr)->pwszString)
+
+#define DRM_PB_DASTR(pdstr) (DRM_BYTE*)((pdstr)->pszString)
+#define DRM_CB_DASTR(pdstr) ((pdstr)->cchString)
+#define DRM_CONST_PB_DASTR(pdstr) (const DRM_BYTE*)((pdstr)->pszString)
+
+
+/*
+** PLEASE NOTE: If DRM_C_TICS_PER_SECOND is changed, make sure
+** the following are updated accordingly:
+**
+** 1. DRM_H264_ERROR_WINDOW_IN_TICS
+** 2. MAX_ALLOWED_TIME_BEFORE_CLOCK_RESYNC
+** 3. MAX_REVOCATION_EXPIRE_TICS
+*/
+#define DRM_C_TICS_PER_SECOND 10000000
+
+#define DRM_C_SECONDS_FROM_1601_TO_1970 ( DRM_UI64HL( 0x2, 0xB6109100 ) )
+
+/*
+** Converts from:
+**  DWORD time in seconds since January 1, 1970 (i.e. XMR license)
+**  to
+**  DRMFILETIME in 100-nanosecond intervals since January 1, 1601 (i.e. Microsoft FILETIME structure)
+**
+** Note that UI64_TO_FILETIME does not change the value - just changes types.
+*/
+#define DRM_CREATE_FILE_TIME(dw, ft) DRM_DO {                                               \
+    DRM_UINT64 ui64Tics = DRM_UI64Add( DRM_UI64( dw ), DRM_C_SECONDS_FROM_1601_TO_1970 );   \
+    ui64Tics = DRM_UI64Mul( ui64Tics, DRM_UI64( DRM_C_TICS_PER_SECOND ) );                  \
+    UI64_TO_FILETIME( ui64Tics, ft );                                                       \
+} DRM_WHILE_FALSE
+
+/*
+** Converts from:
+**  DRMFILETIME in 100-nanosecond intervals since January 1, 1601 (i.e. Microsoft FILETIME structure)
+**  to
+**  DWORD time in seconds since January 1, 1970 (i.e. XMR license)
+**
+** Note that FILETIME_TO_UI64 does not change the value - just changes types.
+*/
+#define DRM_FILE_TIME_TO_DWORD(ft, dw) DRM_DO {                                         \
+    DRM_UINT64 ui64Tics;                                                                \
+    FILETIME_TO_UI64( ft, ui64Tics );                                                   \
+    ui64Tics = DRM_UI64Div( ui64Tics, DRM_UI64( DRM_C_TICS_PER_SECOND ) );              \
+    dw = DRM_UI64Low32( DRM_UI64Sub( ui64Tics, DRM_C_SECONDS_FROM_1601_TO_1970 ) );     \
+} DRM_WHILE_FALSE
+
+typedef struct _tagDRMSYSTEMTIME
+{
+    DRM_WORD wYear;
+    DRM_WORD wMonth;
+    DRM_WORD wDayOfWeek;
+    DRM_WORD wDay;
+    DRM_WORD wHour;
+    DRM_WORD wMinute;
+    DRM_WORD wSecond;
+    DRM_WORD wMilliseconds;
+} DRMSYSTEMTIME;
+
+/* Contains a 64-bit value representing the number of 100-nanosecond intervals since January 1, 1601 (UTC). */
+#if TARGET_LITTLE_ENDIAN
+typedef struct _tagDRMFILETIME
+{
+    DRM_DWORD dwLowDateTime;
+    DRM_DWORD dwHighDateTime;
+} DRMFILETIME;
+#else
+typedef struct _tagDRMFILETIME
+{
+    DRM_DWORD dwHighDateTime;
+    DRM_DWORD dwLowDateTime;
+} DRMFILETIME;
+#endif
+
+/* generic ID type, currently all the same size */
+#define DRM_ID_SIZE  16
+
+typedef struct _tagDRM_ID
+{
+    DRM_BYTE rgb[ DRM_ID_SIZE ];
+} DRM_ID;
+
+typedef DRM_ID DRM_MID;
+typedef DRM_ID DRM_KID;
+typedef DRM_ID DRM_LID;
+typedef DRM_ID DRM_TID;
+
+#define DRM_ID_EMPTY {0}
+
+/* Structure that contains the definition of a domain ID. */
+typedef struct
+{
+    /* Service ID. */
+    DRM_GUID    m_oServiceID;
+
+    /* Account ID. */
+    DRM_GUID    m_oAccountID;
+
+    /* Revision. */
+    DRM_DWORD   m_dwRevision;
+} DRM_DOMAIN_ID;
+
+#define DRM_EMPTY_DRM_DOMAIN_ID { DRM_EMPTY_DRM_GUID, DRM_EMPTY_DRM_GUID, 0 }
+
+/*
+** Structure that encapsulates the information returned by
+** domain cert enumeration APIs.
+*/
+typedef struct __tagDRM_DOMAINCERT_INFO
+{
+    /* Domain ID. */
+    DRM_DOMAIN_ID    m_oDomainID;
+
+    /* Point to a URL in the domain cert. (not used at the moment) */
+    DRM_ANSI_STRING  m_dastrURL;
+
+} DRM_DOMAINCERT_INFO;
+
+typedef struct _tagDRM_BYTEBLOB
+{
+    DRM_BYTE *pbBlob;
+    DRM_DWORD cbBlob;
+} DRM_BYTEBLOB;
+
+#ifdef __cplusplus
+#define DRM_REINTERPRET_CAST( type, ptr ) (reinterpret_cast<type*>(reinterpret_cast<DRM_VOID*>(ptr)))
+#define DRM_REINTERPRET_CONST_CAST( type, ptr ) (reinterpret_cast<type*>(reinterpret_cast<const DRM_VOID*>(ptr)))
+#else   /* __cplusplus */
+#define DRM_REINTERPRET_CAST( type, ptr ) ((type*)((DRM_VOID*)(ptr)))
+#define DRM_REINTERPRET_CONST_CAST DRM_REINTERPRET_CAST
+#endif  /* __cplusplus */
+
+EXIT_PK_NAMESPACE;
+
+/*
+** Multiple-precision data is normally represented
+** in radix 2^DRM_RADIX_BITS, with DRM_RADIX_BITS bits per word.
+** Here ``word'' means type digit_t.  DRM_RADIX_BITS
+** should be 32 for all supported architectures
+*/
+#define DRM_RADIX_BITS      32
+#define DRM_RADIX_BYTES     4
+
+/* Datatypes used by bignum */
+typedef DRM_DWORD       digit_t;
+typedef DRM_LONG        sdigit_t;
+struct bigctx_t;
+
+#define DRM_DIGIT_ZERO ((digit_t)0)
+#define DRM_DIGIT_ONE  ((digit_t)1)
+
+#define DRM_RADIX_HALF (DRM_DIGIT_ONE << (DRM_RADIX_BITS - 1))
+#define DRM_RADIXM1 (DRM_DIGIT_ZERO - DRM_DIGIT_ONE)
+
+/*
+** Since DRM_DWORD is required to be 32 bits
+** and digit_t is required to be 32 bits, this
+** should be 1 for all supported architectures.
+*/
+#define DRM_DWORDS_PER_DIGIT 1
+
+/*
+** DWORDS_TO_DIGITS(lng_dwords) computes the number of digit_t
+** elements required to store an array with -lng_dwords- DWORDs.
+** DRM_DIGITS_TO_DWORDS converts in the opposite direction.
+*/
+#define DRM_DWORDS_TO_DIGITS(lng_dwords) \
+                ( ((lng_dwords) + DRM_DWORDS_PER_DIGIT - 1)/DRM_DWORDS_PER_DIGIT)
+#define DRM_DIGITS_TO_DWORDS(lng_digits) ((lng_digits) * DRM_DWORDS_PER_DIGIT)
+#define DRM_BITS_TO_DIGITS(nb) (((nb) + DRM_RADIX_BITS - 1)/DRM_RADIX_BITS)
+#define DRM_digit_getbit(iword, ibit) (((iword) >> (ibit)) & 1)
+
+/*
+** Test whether a (possibly negative) number is odd or even.
+*/
+#define DRM_IS_EVEN(n) (~(DRM_DWORD)(n) & 1)
+#define DRM_IS_ODD(n) ((DRM_DWORD)(n) & 1)
+
+/*
+** Maximum and minimum of two arguments
+** (no side effects in arguments)
+*/
+#define DRM_MAX(x, y) ((x) > (y) ? (x) : (y))
+#define DRM_MIN(x, y) ((x) > (y) ? (y) : (x))
+
+#ifndef TRUE
+    #define TRUE  1
+#endif
+
+#ifndef FALSE
+    #define FALSE 0
+#endif
+
+#ifndef NULL
+    #define NULL  0
+#endif
+
+#if defined(DRM_MSC_VER) && (DRM_MSC_VER >= 1900) && defined(__cplusplus) && !DRM_TYPES_NO_NULLPTR
+#undef NULL
+#define NULL nullptr
+#endif
+
+#define DRM_VERSION_LEN          4
+#define DRM_VER_STRING_MAX_LEN   20
+#define DRM_MAX_PATH             256
+
+/*
+** This is the root-most public key for all PlayReady binary certificates.
+**
+** DO NOT change this value unless you are absolutely certain it is required
+** Verify with both your lead and your skip-level before you change this value.
+**
+** Changing this value for any reason will cause an enormous number of compatibily issues.
+**
+** Here is the base-64 encoded value for this public key:
+** hk1hz/IlbkIsVos8KAAc+z4VJ2WFhLoFIbebGCjZNt4dgmqPw+bn+nqQ1copRvH2Si77n13P/n5DTrRCk/rFqw==
+*/
+#define DRM_ECC256_MS_PLAYREADY_ROOT_ISSUER_PUBKEY                                                         \
+    {                                                                                                      \
+        0x86, 0x4D, 0x61, 0xCF, 0xF2, 0x25, 0x6E, 0x42, 0x2C, 0x56, 0x8B, 0x3C, 0x28, 0x00, 0x1C, 0xFB,    \
+        0x3E, 0x15, 0x27, 0x65, 0x85, 0x84, 0xBA, 0x05, 0x21, 0xB7, 0x9B, 0x18, 0x28, 0xD9, 0x36, 0xDE,    \
+        0x1D, 0x82, 0x6A, 0x8F, 0xC3, 0xE6, 0xE7, 0xFA, 0x7A, 0x90, 0xD5, 0xCA, 0x29, 0x46, 0xF1, 0xF6,    \
+        0x4A, 0x2E, 0xFB, 0x9F, 0x5D, 0xCF, 0xFE, 0x7E, 0x43, 0x4E, 0xB4, 0x42, 0x93, 0xFA, 0xC5, 0xAB     \
+    }
+
+
+#endif  /* __DRMTYPES_H__ */
+
diff --git a/prebuilt-v4.4/noarch/include/drmutf.h b/prebuilt-v4.4/noarch/include/drmutf.h
new file mode 100644
index 0000000..7200d86
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmutf.h
@@ -0,0 +1,113 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __DRM_UTF_H
+#define __DRM_UTF_H
+
+#include <drmtypes.h>
+#include <drmutftypes.h>
+
+ENTER_PK_NAMESPACE;
+
+/* Test for little endian UTF-16 BOM (byte order mask) */
+#define IS_LITTLE_ENDIAN_UTF16_BOM(_pbData_) ( ((DRM_BYTE*)_pbData_)[ 0 ] == 0xFFUL && ((DRM_BYTE*)_pbData_)[ 1 ] == 0xFEUL )
+
+/* Test for big endian UTF-16 BOM (byte order mask) */
+#define IS_BIG_ENDIAN_UTF16_BOM(_pbData_) ( ((DRM_BYTE*)_pbData_)[ 0 ] == 0xFEUL && ((DRM_BYTE*)_pbData_)[ 1 ] == 0xFFUL )
+
+DRM_API DRM_RESULT DRM_CALL DRM_STR_UTF32toUTF16(
+    __in_ecount( f_cchSource )          const DRM_WCHAR32 *f_pw32szSource,
+    __in                                const DRM_DWORD    f_cchSource,
+    __out_ecount_z_opt( *f_pcchTarget )       DRM_WCHAR   *f_pwszTarget,
+    __inout                                   DRM_DWORD   *f_pcchTarget );
+
+DRM_API DRM_RESULT DRM_CALL DRM_STR_UTF32toDSTR(
+    __in_ecount( f_cchSource ) const DRM_WCHAR32 *f_pw32szSource,
+    __in                       const DRM_DWORD    f_cchSource,
+    __inout                          DRM_STRING  *f_pdstrTarget );
+
+DRM_API DRM_RESULT DRM_CALL DRM_STR_UTF16toUTF32(
+    __in_ecount( f_cchSource )          const DRM_WCHAR   *f_pwszSource,
+    __in                                const DRM_DWORD    f_cchSource,
+    __out_ecount_z_opt( *f_pcchTarget )       DRM_WCHAR32 *f_pw32szTarget,
+    __inout                                   DRM_DWORD   *f_pcchTarget );
+
+DRM_API DRM_RESULT DRM_CALL DRM_STR_DSTRtoUTF32(
+    __in                              const DRM_CONST_STRING    *f_pdstrSource,
+    __out_ecount_opt( *f_pcchTarget )       DRM_WCHAR32         *f_pw32szTarget,
+    __inout                                 DRM_DWORD           *f_pcchTarget );
+
+DRM_API DRM_RESULT DRM_CALL DRM_STR_UTF16toUTF8(
+    __in_ecount( f_cchSource )          const DRM_WCHAR *f_pwszSource,
+    __in                                const DRM_DWORD  f_cchSource,
+    __out_ecount_z_opt( *f_pcchTarget )       DRM_CHAR  *f_pchTarget,
+    __in                                const DRM_DWORD  f_ichTarget,
+    __inout                                   DRM_DWORD *f_pcchTarget );
+
+DRM_API DRM_RESULT DRM_CALL DRM_STR_DSTRtoUTF8_ByWindow(
+    __in                                                  const DRM_CONST_STRING  *f_pdstrSource,
+    __out_ecount_opt( f_pdstrwTarget->m_ichMaxExclusive )       DRM_CHAR          *f_pchTarget,
+    __inout                                                     DRM_STRING_WINDOW *f_pdstrwTarget );
+
+DRM_API DRM_RESULT DRM_CALL DRM_STR_DSTRtoUTF8(
+    __in                              const DRM_CONST_STRING    *f_pdstrSource,
+    __out_ecount_opt( *f_pcchTarget )       DRM_CHAR            *f_pchTarget,
+    __inout                                 DRM_DWORD           *f_pcchTarget );
+
+DRM_API DRM_RESULT DRM_CALL DRM_STR_UTF8toUTF16(
+    __in_ecount( f_ichSource + f_cchSource ) const DRM_CHAR  *f_pchSource,
+    __in                                     const DRM_DWORD  f_ichSource,
+    __in                                     const DRM_DWORD  f_cchSource,
+    __out_ecount_z_opt( *f_pcchTarget )            DRM_WCHAR *f_pchTarget,
+    __inout                                        DRM_DWORD *f_pcchTarget );
+
+DRM_API DRM_RESULT DRM_CALL DRM_STR_UTF8toDSTR_ByWindow(
+    __in_ecount( f_pdstrwSource->m_ichMaxExclusive ) const DRM_CHAR          *f_pchSource,
+    __in                                             const DRM_STRING_WINDOW *f_pdstrwSource,
+    __inout                                                DRM_STRING        *f_pdstrTarget );
+
+DRM_API DRM_RESULT DRM_CALL DRM_STR_UTF8toDSTR(
+    __in_ecount( f_cchSource ) const DRM_CHAR   *f_pchSource,
+    __in                       const DRM_DWORD   f_cchSource,
+    __inout                          DRM_STRING *f_pdstrTarget );
+
+DRM_API DRM_RESULT DRM_CALL DRM_STR_ASCII_SUBSTRtoDSTR(
+    __in_ecount( f_pdasstr->m_ich + f_pdasstr->m_cch ) const DRM_CHAR      *f_pchSource,
+    __in                                               const DRM_SUBSTRING *f_pdasstr,
+    __inout                                                  DRM_STRING    *f_pdstrTarget );
+
+DRM_API DRM_RESULT DRM_CALL DRM_STR_ASCIItoDSTR(
+    __in_ecount( f_cchSource ) const DRM_CHAR   *f_pchSource,
+    __in                       const DRM_DWORD   f_cchSource,
+    __inout                          DRM_STRING *f_pdstrTarget );
+
+DRM_API DRM_RESULT DRM_CALL DRM_STR_UTF16toASCII(
+    __in_ecount(f_cchSource)    const DRM_WCHAR *f_pwszSource,
+    __in                        const DRM_DWORD  f_cchSource,
+    __inout_ecount(f_cchTarget)       DRM_CHAR  *f_pszTarget,
+    __in                        const DRM_DWORD  f_cchTarget );
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_STR_UTF8_ReadCodePoint8(
+    __in_ecount(f_pdstrwSource->m_ichMaxExclusive) const DRM_CHAR          *f_pchSource,
+    __inout                                              DRM_STRING_WINDOW *f_pdstrwSource,
+    __out                                                DRM_CODE_POINT    *f_pcp );
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_STR_UTF8_VerifyBytes(
+    __in_bcount( f_cbData ) const DRM_BYTE  *f_pbData,
+    __in                    const DRM_DWORD  f_cbData,
+    __in                    const DRM_DWORD  f_iMin,
+    __in                    const DRM_DWORD  f_iMax );
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_STR_UTF8_IsUTF8NullTerminatedData(
+    __in_bcount( f_cbData ) const DRM_BYTE   *f_pbData,
+    __in                          DRM_DWORD   f_cbData );
+
+EXIT_PK_NAMESPACE;
+
+#endif /* __DRM_UTF_H */
+
diff --git a/prebuilt-v4.4/noarch/include/drmutftypes.h b/prebuilt-v4.4/noarch/include/drmutftypes.h
new file mode 100644
index 0000000..66e7a42
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmutftypes.h
@@ -0,0 +1,323 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __DRM_UTFTYPES_H
+#define __DRM_UTFTYPES_H
+
+#include <drmtypes.h>
+
+ENTER_PK_NAMESPACE;
+
+/******************************************************************************
+**  This information is from unicode.org specification.
+**
+**  Terminology:
+**  1. "Code Point" - that which is displayed on the screen. Also called a
+**                    linguistic character in Windows documentation.
+**  2. "Code Unit" - that which is iterated through via index, each of size
+**                   size 1, 2, or 4 8bit bytes. Also called a storage
+**                   character in Windows documenation. cch always refers to
+**                   these.
+**
+**  The maximum Code Point in unicode is U+10FFFF.
+**  The Code Points in the range U+D800..U+DFFF are illegal and reserved for
+**  encodings.
+**
+**
+**  UTF-8 Encoding's Bit Distribution:
+**  ==================================
+**
+**  unicode                     bytes   bits   UTF-8 representation
+**  --------------------------  -----   ----   -----------------------------------
+**  00000000 0xxxxxxx           1       7      0xxxxxxx
+**  00000yyy yyxxxxxx           2       11     110yyyyy 10xxxxxx
+**  zzzzyyyy yyxxxxxx           3       16     1110zzzz 10yyyyyy 10xxxxxx
+**  000uuuuu zzzzyyyy yyxxxxxx  4       21     11110uuu 10uuzzzz 10yyyyyy 10xxxxxx
+**  --------------------------  -----   ----   -----------------------------------
+**
+**  Well-Formed UTF-8 Byte Sequences:
+**
+**  Unicode ranges      1st Byte  2nd Byte  3rd Byte  4th Byte
+**  ------------------  --------  --------  --------  --------
+**  U+0000..U+007F      00..7F
+**  U+0080..U+07FF      C2..DF    80..BF
+**  U+0800..U+0FFF      E0        A0..BF    80..BF
+**  U+1000..U+CFFF      E1..EC    80..BF    80..BF
+**  U+D000..U+D7FF      ED        80..9F    80..BF
+**  U+E000..U+FFFF      EE..EF    80..BF    80..BF
+**  U+10000..U+3FFFF    F0        90..BF    80..BF    80..BF
+**  U+40000..U+FFFFF    F1..F3    80..BF    80..BF    80..BF
+**  U+100000..U+10FFFF  F4        80..8F    80..BF    80..BF
+**
+**  Notes:
+**  1. The special cases for 3 bytes characters are due to the illegality of
+**     the range U+D800..U+DFFF.
+**  2. UTF-8 rules do not allow using a larger format to represent a unicode
+**     value encode-able with fewer bytes.
+**
+**
+**  UTF-16 Encoding Rules:
+**  ======================
+**  1. Code points in the range U+0000..U+FFFF are encoded using one UTF-16
+**     value.
+**  2. Code points in the range U+10000..U+10FFFF are encoded first by
+**     subtracting 0x10000 to get a 20bit number, then by storing them in two
+**     UTF-16 values, each containing 10bits:
+**       1. The first "surrogate" is in the range 0xD800-0xDBFF.
+**       2. The second "surrogate" is in the range 0xDC00-0xDFFF.
+**
+**  Notes:
+**  1. There is no confusion between surrogates and U+D800..U+DFFF as the
+**     latter is an illegal range.
+**  2. UTF-16 *is* endian-specific, and both little endian (UTF-16LE), big
+**     endian (UTF-16BE), and auto-detection (via BOM) are defined. This file
+**     only supports characters in little endian format.
+**     It neither supports characters in big endian
+**     nor supports auto-detection.
+**
+**
+**`    (UTF-16LE is used in this file regardless of native architecture)
+**     UTF-16LE encoding scheme:
+**     The Unicode encoding scheme that serializes a UTF-16
+**     code unit sequence as a byte sequence in little-endian format.
+**
+**     In UTF-16LE, the UTF-16 code unit sequence <004D 0430 4E8C D800 DF02> is
+**     serialized as <4D 00 30 04 8C 4E 00 D8 02 DF>.
+**
+**     In UTF-16LE, an initial byte sequence <FF FE> is interpreted as
+**     U+FEFF zero width no-break space.
+**
+**
+**     (UTF-16BE is never used in this file - description for information only)
+**     UTF-16BE encoding scheme:
+**     The Unicode encoding scheme that serializes a UTF-16
+**     code unit sequence as a byte sequence in big-endian format.
+**
+**     In UTF-16BE, the UTF-16 code unit sequence <004D 0430 4E8C D800 DF02>
+**     is serialized as <00 4D 04 30 4E 8C D8 00 DF 02>.
+**
+**     In UTF-16BE, an initial byte sequence <FE FF> is interpreted as U+FEFF zero
+**     width no-break space.
+**
+**
+**
+**  UTF-32 Encoding Rules:
+**  ======================
+**  A 32bit code unit has all the space and more necessary to hold the max
+**  code point. As such, no conversion is necessary.
+**
+**  Notes:
+**     UTF-32 *is* endian-specific, and both little endian (UTF-32LE), big
+**     endian (UTF-32BE), and auto-detection (via BOM) are defined. This file
+**     only supports characters in little endian format.
+**     It neither supports characters in big endian
+**     nor supports auto-detection.
+**
+**
+**`    (UTF-32LE is used in this file regardless of native architecture)
+**     UTF-32LE encoding scheme:
+**     The Unicode encoding scheme that serializes a UTF-32
+**     code unit sequence as a byte sequence in little-endian format.
+**
+**     In UTF-32LE, the UTF-32 code unit sequence
+**     <0000004D 00000430 00004E8C 00010302> is serialized as
+**     <4D 00 00 00 30 04 00 00 8C 4E 00 00 02 03 01 00>.
+**
+**     In UTF-32LE, an initial byte sequence <FF FE 00 00> is interpreted as
+**     U+FEFF zero width no-break space.
+**
+**
+**`    (UTF-32BE is never used in this file - description for information only)
+**     UTF-32BE encoding scheme:
+**     The Unicode encoding scheme that serializes a UTF-32
+**     code unit sequence as a byte sequence in big-endian format.
+**
+**     In UTF-32BE, the UTF-32 code unit sequence
+**     <0000004D 00000430 00004E8C 00010302> is serialized as
+**     <00 00 00 4D 00 00 04 30 00 00 4E 8C 00 01 03 02>.
+**
+**     In UTF-32BE, an initial byte sequence <00 00 FE FF> is interpreted as U+FEFF
+**     zero width no-break space.
+**
+******************************************************************************/
+
+/*
+** This file internally deals in code points, which use native endian-ness.
+** When converting the DRM_WCHAR32, an endian conversion may be necessary.
+*/
+typedef DRM_DWORD DRM_CODE_POINT;
+
+/*
+** Any code point greater than 0x10FFFF is ill-formed.
+*/
+#define UTF_MAX_CODE_POINT (DRM_WCHAR32)0x0010FFFFUL
+
+/*
+** Unicode has 17 "planes", each with 2^16 code points. The exception is the
+** "Base Multilingual Plane" (#0) which lacks the values U+D800..U+DFFF.
+*/
+#define UTF_PLANE0_MAX     (DRM_WCHAR32)0x0000FFFFUL
+#define UTF_PLANE1_MIN     (DRM_WCHAR32)0x00010000UL
+
+/* ---------------------- UTF-8 constants and macros ---------------------- */
+
+#define UTF8_MIN_TWO_BYTE_CP    0x80UL
+#define UTF8_MIN_THREE_BYTE_CP  0x800UL
+#define UTF8_MIN_FOUR_BYTE_CP   UTF_PLANE1_MIN
+
+/*
+** Test that this byte looks like 10vvvvvv
+** so that its value is in 80..BF range
+*/
+#define IS_UTF8_TRAILING_CH(b) (((b) & 0xC0) == 0x80)
+
+/*
+** 110yyyyy 10xxxxxx -> 00000000 00000000 00000yyy yyxxxxxx
+*/
+#define UTF_CP_FROM_TWO_CH(b1,b2) \
+    ( ( ( ( (b1) & 0x1FUL ) << 0x6 ) | ( (b2) & 0x3FUL ) ) & 0x7FF )
+/*
+** 1110zzzz 10yyyyyy 10xxxxxx -> 00000000 00000000 zzzzyyyy yyxxxxxx
+*/
+#define UTF_CP_FROM_THREE_CH(b1,b2,b3) \
+    ( ( ( ( (b1) & 0xFUL ) << 0xC ) | ( ( (b2) & 0x3FUL ) << 0x6 ) | ( (b3) & 0x3FUL ) ) & 0xFFFFUL )
+
+/*
+** 11110uuu 10uuzzzz 10yyyyyy 10xxxxxx -> 00000000 000uuuuu zzzzyyyy yyxxxxxx
+*/
+#define UTF_CP_FROM_FOUR_CH(b1,b2,b3,b4) \
+    ( ( ( ( (b1) & 0x7UL ) << 0x12 ) | ( ( (b2) & 0x3FUL ) << 0xC ) | ( ( (b3) & 0x3FUL ) << 0x6 ) | ( (b4) & 0x3FUL ) ) & 0x1FFFFFUL )
+
+/*
+** Takes a 6 bit value and converts to a trailing UTF-8 code unit.
+*/
+#define UTF8_MAKE_TRAILING_CH(_b_) ( (_b_) | 0x80 )
+
+/*
+** Creates a lead ch for UTF8 given
+** a) The number of code units /top bits (n = 2-4), and
+** b) The value bits in the lead byte (max bits is 7-n, i.e. going from 5 to 3).
+*/
+#define UTF8_MAKE_LEAD_CH(_n_, _b_) \
+    ( ( ( 0xF0 << ( 4 - (_n_) ) ) | (_b_) ) & 0xFF )
+
+
+/* ---------------------- UTF-16 constants and macros --------------------- */
+
+/*
+** High-surrogate code unit: A 16-bit code unit in the range 0xD800 to 0xDBFF,
+** used in UTF-16 as the leading code unit of a surrogate pair.
+**
+** Low-surrogate code unit: A 16-bit code unit in the range 0xDC00 to 0xDFFF,
+** used in UTF-16 as the trailing code unit of a surrogate pair.
+*/
+#define UTF16_HIGH_SURROGATE_MIN_CP  (DRM_CODE_POINT)0xD800UL
+#define UTF16_HIGH_SURROGATE_MAX_CP  (DRM_CODE_POINT)0xDBFFUL
+#define UTF16_LOW_SURROGATE_MIN_CP   (DRM_CODE_POINT)0xDC00UL
+#define UTF16_LOW_SURROGATE_MAX_CP   (DRM_CODE_POINT)0xDFFFUL
+
+
+#if TARGET_LITTLE_ENDIAN
+
+#define IS_UTF16_HIGH_SURROGATE_WCH(_wch16_) \
+    ( (_wch16_) >= UTF16_HIGH_SURROGATE_MIN_CP && \
+      (_wch16_) <= UTF16_HIGH_SURROGATE_MAX_CP )
+
+#define IS_UTF16_LOW_SURROGATE_WCH(_wch16_) \
+    ( (_wch16_) >= UTF16_LOW_SURROGATE_MIN_CP && \
+      (_wch16_) <= UTF16_LOW_SURROGATE_MAX_CP )
+
+/* Each half has 10 bits of the 20 bit whole */
+#define UTF32_FROM_SURROGATES_WCH(_wch16High_, _wch16Low_) \
+    ( ( ( (_wch16High_) - UTF16_HIGH_SURROGATE_MIN_CP ) << 10UL ) + \
+      ( (_wch16Low_) - UTF16_LOW_SURROGATE_MIN_CP ) + \
+      UTF_PLANE1_MIN )
+
+/* Rebase plane1 to zero (yielding a 20bit number instead of a 20bit + 16bit
+** number), then take the top ten bits */
+#define UTF16_HIGH_SURROGATE_FROM_CP(_cp_) \
+    ( ( ( (_cp_) - UTF_PLANE1_MIN ) >> 10 ) + UTF16_HIGH_SURROGATE_MIN_CP )
+
+/* Same as above, but take the bottom ten bits */
+#define UTF16_LOW_SURROGATE_FROM_CP(_cp_) \
+    ( ( ( (_cp_) - UTF_PLANE1_MIN ) & 0x3FFUL ) + UTF16_LOW_SURROGATE_MIN_CP )
+
+#define UTF_CP_FROM_UTF32(_wch32_) (_wch32_)
+#define UTF_CP_FROM_UTF16(_wch16_) (_wch16_)
+#define UTF32_FROM_CP(_cp_) (_cp_)
+#define UTF16_FROM_CP(_cp_) (_cp_)
+
+#else
+
+/*
+** UTF-16BE encoding scheme:
+** The Unicode encoding scheme that serializes a UTF-16
+** code unit sequence as a byte sequence in big-endian format.
+**
+** In UTF-16BE, the UTF-16 code unit sequence <004D 0430 4E8C D800 DF02> is
+** serialized as <00 4D 04 30 4E 8C D8 00 DF 02>.
+**
+** In UTF-16BE, an initial byte sequence <FE FF> is interpreted as
+** U+FEFF zero width no-break space
+**
+**
+** UTF-32BE encoding scheme:
+** The Unicode encoding scheme that serializes a UTF-32
+** code unit sequence as a byte sequence in big-endian format.
+**
+** In UTF-32BE, the UTF-32 code unit sequence
+** <0000004D 00000430 00004E8C 00010302> is serialized as
+** <00 00 00 4D 00 00 04 30 00 00 4E 8C 00 01 03 02>.
+**
+** In UTF-32BE, an initial byte sequence <00 00 FE FF> is interpreted as
+** U+FEFF zero width no-break space
+**
+*/
+
+#define IS_UTF16_HIGH_SURROGATE_WCH(_wch16_) \
+    ( ( FLIP_WORD_BYTES( _wch16_ ) ) >= UTF16_HIGH_SURROGATE_MIN_CP && \
+      ( FLIP_WORD_BYTES( _wch16_ ) ) <= UTF16_HIGH_SURROGATE_MAX_CP )
+
+#define IS_UTF16_LOW_SURROGATE_WCH(_wch16_) \
+    ( ( FLIP_WORD_BYTES( _wch16_ ) ) >= UTF16_LOW_SURROGATE_MIN_CP && \
+      ( FLIP_WORD_BYTES( _wch16_ ) ) <= UTF16_LOW_SURROGATE_MAX_CP )
+
+/* Each half has 10 bits of the 20 bit whole */
+#define UTF32_FROM_SURROGATES_WCH(_wch16High_, _wch16Low_) \
+    FLIP_DWORD_BYTES( ( ( ( ( FLIP_WORD_BYTES( _wch16High_ ) ) - UTF16_HIGH_SURROGATE_MIN_CP ) << 10UL ) + \
+                      ( ( FLIP_WORD_BYTES( _wch16Low_ ) ) - UTF16_LOW_SURROGATE_MIN_CP ) + \
+                      UTF_PLANE1_MIN ) \
+                    )
+
+/* Rebase plane1 to zero (yielding a 20bit number instead of a 20bit + 16bit
+** number), then take the top ten bits */
+#define UTF16_HIGH_SURROGATE_FROM_CP(_cp_) \
+    FLIP_WORD_BYTES( ( ( (_cp_) - UTF_PLANE1_MIN ) >> 10 ) + UTF16_HIGH_SURROGATE_MIN_CP )
+
+/* Same as above, but take the bottom ten bits */
+#define UTF16_LOW_SURROGATE_FROM_CP(_cp_) \
+    FLIP_WORD_BYTES( ( ( (_cp_) - UTF_PLANE1_MIN ) & 0x3FFUL ) + UTF16_LOW_SURROGATE_MIN_CP )
+
+#define UTF_CP_FROM_UTF32(_wch32_) FLIP_DWORD_BYTES(_wch32_)
+#define UTF_CP_FROM_UTF16(_wch16_) FLIP_WORD_BYTES(_wch16_)
+#define UTF32_FROM_CP(_cp_) FLIP_DWORD_BYTES(_cp_)
+#define UTF16_FROM_CP(_cp_) FLIP_WORD_BYTES(_cp_)
+
+#endif
+
+/* Create a macro that tests for _both_ high and low surrogates.
+** Note: high surrogates are always numerically less than low surrogates
+*/
+#define IS_UTF16_SURROGATE_CP(_cp_) \
+    ( ( _cp_ ) >= UTF16_HIGH_SURROGATE_MIN_CP && \
+      ( _cp_ ) <= UTF16_LOW_SURROGATE_MAX_CP )
+
+EXIT_PK_NAMESPACE;
+
+#endif /* __DRM_UTFTYPES_H */
+
diff --git a/prebuilt-v4.4/noarch/include/drmutilitiesgeneralconstants.h b/prebuilt-v4.4/noarch/include/drmutilitiesgeneralconstants.h
new file mode 100644
index 0000000..94ab030
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmutilitiesgeneralconstants.h
@@ -0,0 +1,38 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __DRM_ACTIVATION_CONSTANTS_H__
+#define __DRM_ACTIVATION_CONSTANTS_H__
+
+ENTER_PK_NAMESPACE;
+
+/*
+**  Utilities strings.
+*/
+
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING g_dstrEncodedAmpersand;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING g_dstrEncodedQuote;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING g_dstrEncodedLesserThan;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING g_dstrEncodedGreaterThan;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING g_dstrEncodedCarriageReturnNewLine;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING g_dstrDecodedCarriageReturnNewLine;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING g_dstrEncodedCarriageReturn;
+extern DRM_GLOBAL_CONST  DRM_CONST_STRING g_dstrDecodedCarriageReturn;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrEncodedAmpersand;
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrEncodedQuote;
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrEncodedLesserThan;
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrEncodedGreaterThan;
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrEncodedCarriageReturnNewLine;
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrDecodedCarriageReturnNewLine;
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrEncodedCarriageReturn;
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrDecodedCarriageReturn;
+
+EXIT_PK_NAMESPACE;
+
+#endif /* __DRM_ACTIVATION_CONSTANTS_H__ */
diff --git a/prebuilt-v4.4/noarch/include/drmutilitieslite.h b/prebuilt-v4.4/noarch/include/drmutilitieslite.h
new file mode 100644
index 0000000..b1874b3
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmutilitieslite.h
@@ -0,0 +1,218 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __DRM_UTILITIESLITE_H__
+#define __DRM_UTILITIESLITE_H__
+
+#include <drmtypes.h>
+#include <oembyteorder.h>
+
+ENTER_PK_NAMESPACE;
+
+DRM_API DRM_BOOL DRM_CALL DRM_UTL_IsTimeoutExceeded(
+    __in_opt    DRM_VOID    *f_pOEMContext,
+    __in  const DRMFILETIME *f_pftStartTime,
+    __in  const DRM_DWORD    f_dwTimeoutSeconds );
+
+DRM_API DRM_RESULT DRM_CALL DRM_UTL_GetVersionAsString(
+    __in_bcount( DRM_VERSION_LEN )     const DRM_BYTE  f_rgbVersion   [ DRM_VERSION_LEN ],
+    __out_ecount( DRM_VER_STRING_MAX_LEN )   DRM_WCHAR f_wszVerString [DRM_VER_STRING_MAX_LEN] );
+
+DRM_API DRM_RESULT DRM_CALL DRM_UTL_GetVersionFromString(
+   __in_ecount( cchVersion )   const DRM_WCHAR  *pwszVersion,
+   __in                              DRM_DWORD   cchVersion,
+   __out_ecount( DRM_VERSION_LEN )   DRM_WORD    rgwVersion[DRM_VERSION_LEN] );
+
+DRM_API DRM_RESULT DRM_CALL DRM_UTL_StringToLittleEndianGuid(
+    __in const DRM_CONST_STRING *pdstrString,
+    __out      DRM_GUID         *pGuid );
+
+/* {12345678-1234-1234-1234-123456789012} */
+/* 01234567890123456789012345678901234567 (Note: this length does not include null terminator) */
+#define DRM_GUID_STRING_LEN 38
+/*Does NOT null-terminate result*/
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_UTL_GuidToString(
+    __in                                    const  DRM_GUID  *pGuid,
+    __out_ecount(DRM_GUID_STRING_LEN)              DRM_WCHAR *pwString );
+
+DRM_API DRM_RESULT DRM_CALL DRM_UTL_StringToNumber(
+    __in      const DRM_CONST_STRING *pdstrString,
+    __out           DRM_LONG         *plValue,
+    __out_opt       DRM_DWORD        *pcchValue );
+
+/* can be used where itoa, snprintf, vsprintf_s and similar are needed */
+DRM_API DRM_RESULT DRM_CALL DRM_UTL_NumberToString(
+    __in                          DRM_DWORD  f_dwValue,
+    __out_ecount( f_cchBuffer )   DRM_WCHAR *f_pwszBuffer,
+    __in                          DRM_DWORD  f_cchBuffer,
+    __in                          DRM_DWORD  f_dwPadZeros,
+    __in                          DRM_DWORD  f_dwRadix,
+    __out_opt                     DRM_DWORD *f_pcchRLength );
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_UTL_NumberToStringA(
+    __in                          DRM_DWORD  f_dwValue,
+    __out_ecount_z( f_cchBuffer ) DRM_CHAR  *f_pszBuffer,
+    __in                          DRM_DWORD  f_cchBuffer,
+    __in                          DRM_DWORD  f_dwPadZeros,
+    __in                          DRM_DWORD  f_dwRadix,
+    __out_opt                     DRM_DWORD *f_pcchRLength );
+
+DRM_API DRM_RESULT DRM_CALL DRM_UTL_GetVersionFromStringAsDWORD(
+   __in_ecount( f_cchVersion ) const DRM_WCHAR  *f_pwszVersion,
+   __in                              DRM_DWORD   f_cchVersion,
+   __inout                           DRM_DWORD  *f_pdwVersion );
+
+DRM_API DRM_RESULT DRM_CALL DRM_UTL_GetVersionFromStringAsDWORDA(
+   __in_ecount( f_cchVersion ) const DRM_CHAR   *f_pszVersion,
+   __in                              DRM_DWORD   f_cchVersion,
+   __inout                           DRM_DWORD  *f_pdwVersion );
+
+DRM_API DRM_RESULT DRM_CALL DRM_UTL_GetZuluTimeFromStringAsUI64(
+    __inout DRM_CONST_STRING *f_pdstrZuluTime,
+    __out   DRM_UINT64       *f_pui64DateTime );
+
+DRM_API DRM_RESULT DRM_CALL DRM_UTL_StringInsertBlankSubString(
+    __inout DRM_STRING *f_pdstrTarget,
+    __in    DRM_DWORD   f_ichInsertion,
+    __in    DRM_DWORD   f_cch );
+
+DRM_API DRM_RESULT DRM_CALL DRM_UTL_StringInsertBlankSubStringA(
+    __inout DRM_ANSI_STRING *f_pdastrTarget,
+    __in    DRM_DWORD        f_ichInsertion,
+    __in    DRM_DWORD        f_cch );
+
+DRM_API DRM_BOOL DRM_CALL DRM_UTL_DSTRStringsEqual(
+    __in const DRM_CONST_STRING *pdstr1,
+    __in const DRM_CONST_STRING *pdstr2);
+
+DRM_API DRM_BOOL DRM_CALL DRM_UTL_DASTRStringsEqual(
+    __in const DRM_ANSI_CONST_STRING *f_pdastr1,
+    __in const DRM_ANSI_CONST_STRING *f_pdastr2 );
+
+DRM_API DRM_BOOL DRM_CALL DRM_UTL_DASSTRStringsEqual(
+    __in_ecount( f_pdasstr->m_ich + f_pdasstr->m_cch ) const DRM_CHAR              *f_pszBase,
+    __in                                               const DRM_SUBSTRING         *f_pdasstr,
+    __in                                               const DRM_ANSI_CONST_STRING *f_pdastr );
+
+DRM_API DRM_BOOL DRM_CALL DRM_UTL_DASSSTRStringsEqual(
+    __in_ecount( f_pdasstr0->m_ich + f_pdasstr0->m_cch ) const DRM_CHAR       *f_pszBase0,
+    __in                                                 const DRM_SUBSTRING  *f_pdasstr0,
+    __in_ecount( f_pdasstr1->m_ich + f_pdasstr1->m_cch ) const DRM_CHAR       *f_pszBase1,
+    __in                                                 const DRM_SUBSTRING  *f_pdasstr1 );
+
+DRM_API DRM_RESULT DRM_CALL DRM_UTL_EnsureDataAlignment(
+    __in_bcount( f_cbOriginal )                                    const DRM_BYTE   *f_pbOriginal,
+    __in                                                           const DRM_DWORD   f_cbOriginal,
+    __deref_out_bcount( *f_pcbAligned )                                  DRM_BYTE  **f_ppbAligned,
+    __out _Post_satisfies_( *f_pcbAligned <= f_cbOriginal )              DRM_DWORD  *f_pcbAligned,
+    __in                                                           const DRM_DWORD   f_cbDataType,
+    __out_opt _Post_satisfies_( *f_pcbAdjustment <= f_cbDataType )       DRM_DWORD  *f_pcbAdjustment );
+
+DRM_API DRM_RESULT DRM_CALL DRM_UTL_DecodeKID(
+    __in  const DRM_CONST_STRING *f_pdstrKID,
+    __out       DRM_KID          *f_pkid );
+
+DRM_API_VOID DRM_VOID DRM_CALL DRM_UTL_PromoteASCIItoUNICODE(
+    __in_ecount( f_pdasstr->m_ich + f_pdasstr->m_cch ) const DRM_CHAR      *f_pszBase,
+    __in                                               const DRM_SUBSTRING *f_pdasstr,
+    __out                                                    DRM_STRING    *f_pdstrOut );
+
+DRM_API_VOID DRM_VOID DRM_CALL DRM_UTL_DemoteUNICODEtoASCII(
+    _In_reads_or_z_( cchMax ) const DRM_WCHAR *pwszStr,
+    __out_ecount( cchMax )          DRM_CHAR  *pszStrOut,
+    __in                            DRM_DWORD  cchMax );
+
+DRM_API DRM_RESULT DRM_CALL DRM_UTL_XMLDecode(
+    __in_ecount( f_cchEncoded )      const DRM_WCHAR *f_pwszEncoded,
+    __in                                  DRM_DWORD    f_cchEncoded,
+    __out_ecount_opt(*f_pcchDecoded)      DRM_WCHAR   *f_pwszDecoded,
+    __inout                               DRM_DWORD   *f_pcchDecoded );
+
+DRM_API DRM_RESULT DRM_CALL DRM_UTL_XMLDecodeUA(
+    __in_ecount( f_cchEncoded )      const DRM_WCHAR *f_pwchEncoded,
+    __in                                   DRM_DWORD  f_cchEncoded,
+    __out_ecount_opt(*f_pcchDecoded)       DRM_CHAR  *f_pchDecoded,
+    __inout                                DRM_DWORD *f_pcchDecoded );
+
+DRM_API DRM_RESULT DRM_CALL DRM_UTL_XMLDecodeA(
+    __in_ecount( f_cchEncoded )      const DRM_CHAR *f_pchEncoded,
+    __in                                  DRM_DWORD  f_cchEncoded,
+    __out_ecount_opt(*f_pcchDecoded)      DRM_CHAR  *f_pchDecoded,
+    __inout                               DRM_DWORD *f_pcchDecoded );
+
+DRM_API DRM_RESULT DRM_CALL DRM_UTL_XMLEncodeA(
+    __in_ecount( f_cchDecoded ) const DRM_CHAR *f_pchDecoded,
+    __in DRM_DWORD f_cchDecoded,
+    __in DRM_BOOL f_fAttributeText,
+    __out_ecount_opt(*f_pcchEncoded) DRM_CHAR *f_pchEncoded,
+    __inout DRM_DWORD *f_pcchEncoded );
+
+DRM_API DRM_RESULT DRM_CALL DRM_UTL_XMLEncode(
+    __in  const   DRM_CONST_STRING    *f_pdstrToEncode,
+    __in          DRM_BOOL             f_fAttributeText,
+    __out         DRM_STRING          *f_pdstrEncoded );
+
+#define DRM_GUID_LEN 16
+
+DRM_API DRM_RESULT DRM_CALL DRM_UTL_ReadLittleEndianBytesToNativeGUID(
+   __in_bcount( cbData ) const DRM_BYTE  *pbData,
+   __in                  const DRM_DWORD  cbData,
+   __in                        DRM_DWORD  ibGuidOffset,
+   __out                       DRM_GUID  *pDrmGuid );
+
+DRM_API DRM_RESULT DRM_CALL DRM_UTL_ReadNetworkBytesToNativeGUID(
+   __in_bcount( cbData ) const DRM_BYTE  *pbData,
+   __in                  const DRM_DWORD  cbData,
+   __in                        DRM_DWORD  ibGuidOffset,
+   __out                       DRM_GUID  *pDrmGuid );
+
+DRM_API DRM_BOOL DRM_CALL DRM_UTL_AreGUIDEqual(
+    __in_opt const DRM_GUID *pDrmGuid1,
+    __in_opt const DRM_GUID *pDrmGuid2 );
+
+
+DRM_API DRM_BOOL DRM_CALL DRM_UTL_IsZeros(
+    __in_bcount( cbBuff ) const DRM_BYTE *pbBuff,
+    __in                        DRM_DWORD cbBuff );
+
+
+DRM_API DRM_RESULT DRM_CALL DRM_UTL_LShift(
+    __in_bcount( f_cb )  const DRM_BYTE  *f_pbIn,
+    __out_ecount( f_cb )       DRM_BYTE  *f_pbOut,
+    __in                       DRM_DWORD  f_cb );
+
+
+DRM_API DRM_RESULT DRM_CALL DRM_UTL_RShift(
+    __in_bcount( f_cb )  const DRM_BYTE  *f_pbIn,
+    __out_ecount( f_cb )       DRM_BYTE  *f_pbOut,
+    __in                       DRM_DWORD  f_cb );
+
+DRM_NO_INLINE DRM_API_VOID DRM_VOID DRM_CALL DRM_UTL_IncrementID(
+    __inout_ecount( 1 ) DRM_ID      *f_pid,
+    __in                DRM_BOOL     f_fWrapToOne );
+
+DRM_API DRM_RESULT DRM_CALL DRM_UTL_URLEncode(
+    __in_bcount( f_cchData )          const DRM_CHAR         *f_pchData,
+    __in                                    DRM_DWORD         f_cchData,
+    __out_bcount( *f_cchUrlEncodedString )  DRM_CHAR         *f_pchUrlEncodedString,
+    __out                                   DRM_DWORD        *f_cchUrlEncodedString );
+
+DRM_API DRM_RESULT DRM_CALL DRM_UTL_URLDecode(
+     __in_bcount( f_cchbData )          const DRM_CHAR         *f_pchData,
+     __in                                     DRM_DWORD         f_cchbData,
+     __out_bcount( *f_cchUrlDecodedString )   DRM_CHAR         *f_pchUrlDecodedString,
+     __out                                    DRM_DWORD        *f_cchUrlDecodedString );
+
+DRM_API DRM_BOOL DRM_CALL DRM_UTL_IsTextUnicode(
+    __in_bcount( f_cbData )            const DRM_BYTE           *f_pbData,
+    __in                                     DRM_DWORD           f_cbData );
+
+EXIT_PK_NAMESPACE;
+
+#endif /* __DRM_UTILITIESLITE_H__ */
+
diff --git a/prebuilt-v4.4/noarch/include/drmversionconstants.h b/prebuilt-v4.4/noarch/include/drmversionconstants.h
new file mode 100644
index 0000000..558a1ec
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmversionconstants.h
@@ -0,0 +1,22 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __DRMVERSIONCONSTANTS_H__
+#define __DRMVERSIONCONSTANTS_H__
+
+#include <drmtypes.h>
+
+ENTER_PK_NAMESPACE;
+
+extern DRM_GLOBAL_CONST DRM_CONST_STRING       g_dstrReqTagPlayReadyClientVersionData;
+extern DRM_GLOBAL_CONST DRM_DWORD              g_dwReqTagPlayReadyClientVersionData[DRM_VERSION_LEN];
+
+EXIT_PK_NAMESPACE;
+
+#endif /* __DRMVERSIONCONSTANTS_H__ */
+
diff --git a/prebuilt-v4.4/noarch/include/drmwindowsenv.h b/prebuilt-v4.4/noarch/include/drmwindowsenv.h
new file mode 100644
index 0000000..697eb2d
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmwindowsenv.h
@@ -0,0 +1,51 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __DRM_WINDOWS_ENV_H__
+#define __DRM_WINDOWS_ENV_H__
+
+#include <drmcompiler.h>
+#include <drmsal.h>
+
+/*
+# Abstract:
+#
+# This file contains compiler directives for disabling certain Windows CE
+# compiler-time warnings and allow the PK environment to be compiled under
+# elevated warning level
+#
+*/
+
+#if defined (DRM_MSC_VER)
+
+PREFAST_PUSH_IGNORE_WARNINGS_IN_NON_PLAYREADY_HEADERS
+#include <windows.h>
+#include <mfapi.h>
+PREFAST_POP_IGNORE_WARNINGS_IN_NON_PLAYREADY_HEADERS
+
+#ifndef ChkWR
+#define ChkWR(expr) {                                           \
+            if (!(expr))                                        \
+            {                                                   \
+                dr = (HRESULT)GetLastError();                   \
+                dr = HRESULT_FROM_WIN32((unsigned long)dr);     \
+                ExamineDRValue(dr, __FILE__, __LINE__, #expr);  \
+                goto ErrorExit;                                 \
+            }                                                   \
+        }
+#endif
+
+#define PRLoadLibraryA(dllpath,h) DRM_DO { h = LoadLibraryA(dllpath); } DRM_WHILE_FALSE
+
+#endif /* DRM_MSC_VER */
+
+#endif /* __DRM_WINDOWS_ENV_H__ */
+
+
+
+
diff --git a/prebuilt-v4.4/noarch/include/drmxb.h b/prebuilt-v4.4/noarch/include/drmxb.h
new file mode 100644
index 0000000..406a9b5
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmxb.h
@@ -0,0 +1,398 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __DRM_XB_H__
+#define __DRM_XB_H__
+
+#include <drmtypes.h>
+#include <drmpragmas.h>
+
+ENTER_PK_NAMESPACE;
+
+typedef enum
+{
+    XB_FORMAT_ID_LENGTH_DWORD = sizeof( DRM_DWORD ),
+    XB_FORMAT_ID_LENGTH_QWORD = sizeof(DRM_UINT64),
+} XB_FORMAT_ID_LENGTH;
+
+#define XB_HEADER_LENGTH( formatIdLength )      ( ( formatIdLength ) + sizeof( DRM_DWORD ) * 2 )    /* XB headers are 1 DWORD/QWORD long plus 2 DWORDs long (id, version, length) */
+#define XB_BASE_OBJECT_LENGTH                   ( sizeof( DRM_WORD ) * 2  + sizeof( DRM_DWORD ) )   /* Each object/container always has type (WORD), flags (WORD), and length (DWORD) */
+#define XB_MAXIMUM_OBJECT_DEPTH 6
+#define DRM_XB_PARSER_MAX_UNKNOWN_CONTAINER_DEPTH 16
+
+/*
+** valid flags for containers and objects
+*/
+enum XB_OBJECT_FLAGS
+{
+    XB_FLAGS_NONE                         = 0x0000,
+    XB_FLAGS_MUST_UNDERSTAND              = 0x0001,
+    XB_FLAGS_CONTAINER                    = 0x0002,
+    XB_FLAGS_ALLOW_EXTERNAL_PARSE         = 0x0004,
+    XB_FLAGS_DO_NOT_SERIALIZE             = 0x0008,
+    XB_FLAGS_CONTAINER_HAS_RESERVE_BUFFER = 0x0010, /*
+                                                    ** This indicates the container may have reserved memory after the last object with a known byte fill pattern.
+                                                    ** This behavior is used for certificate parsing when a data buffer is reserved for adding extended data at a
+                                                    ** later time.
+                                                    */
+};
+
+enum XB_OBJECT_TYPE
+{
+    XB_OBJECT_TYPE_EXTENDED_HEADER                                  = DRM_MAX_UNSIGNED_TYPE(DRM_WORD)-4, /* 0xFFFB = Extended header information */
+    XB_OBJECT_TYPE_ROOT                                             = DRM_MAX_UNSIGNED_TYPE(DRM_WORD)-3, /* 0xFFFC = Format root object - this value is used to enable a RawData weak reference object to be generated during parsing */
+    XB_OBJECT_TYPE_UNKNOWN                                          = DRM_MAX_UNSIGNED_TYPE(DRM_WORD)-2, /* 0xFFFD = Unknown object type */
+    XB_OBJECT_TYPE_UNKNOWN_CONTAINER                                = DRM_MAX_UNSIGNED_TYPE(DRM_WORD)-1, /* 0xFFFE = Unknown container type */
+    XB_OBJECT_TYPE_INVALID                                          = DRM_MAX_UNSIGNED_TYPE(DRM_WORD)  , /* 0xFFFF = Invalid */
+    XB_OBJECT_GLOBAL_HEADER                                         = 0                                  /* All formats based on the XB system should start their objects from XB_OBJECT_GLOBAL_HEADER+1 */
+};
+
+/* Base struct that all XB structs can be cast to */
+typedef struct __tagDRM_XB_EMPTY
+{
+    DRM_BOOL  fValid;
+} DRM_XB_EMPTY;
+
+typedef struct __tagDRM_XB_FORMAT_VERSION
+{
+    DRM_BOOL  fValid;
+    DRM_DWORD dwVersion;
+} DRM_XB_FORMAT_VERSION;
+
+/* Base struct for all types that allow duplicates as they are parsed into a linked list */
+typedef struct __tagDRM_XB_BASELIST
+{
+    DRM_BOOL fValid;
+DRM_OBFUS_PTR_TOP
+    struct __tagDRM_XB_BASELIST *pNext;
+DRM_OBFUS_PTR_BTM
+
+} DRM_XB_BASELIST;
+
+/*
+** A flat array of GUIDs.  When represented in the binary format it is serialized as
+** a DWORD followed by cGUIDs consecutive 16 byte GUID values.
+*/
+typedef struct __tagDRM_XB_GUIDLIST
+{
+    DRM_BOOL   fValid;
+    DRM_DWORD  cGUIDs;
+DRM_OBFUS_PTR_TOP
+    DRM_BYTE  *pguidBuffer;
+DRM_OBFUS_PTR_BTM
+    DRM_DWORD  iGuids;
+} DRM_XB_GUIDLIST;
+
+
+/*
+** A flat array of WORDs.  When represented in the binary format it is serialized as
+** a DWORD followed by cWORDs consecutive WORD values.
+*/
+typedef struct __tagDRM_XB_WORDLIST
+{
+    DRM_BOOL   fValid;
+    DRM_DWORD  cWORDs;
+DRM_OBFUS_PTR_TOP
+    DRM_BYTE  *pwordBuffer;
+DRM_OBFUS_PTR_BTM
+    DRM_DWORD  iWords;
+DRM_OBFUS_FILL_BYTES(4)
+} DRM_XB_WORDLIST;
+
+/*
+** A flat array of DWORDs.  When represented in the binary format it is serialized as
+** a DWORD followed by cDWORDs consecutive DWORD values.
+*/
+typedef struct __tagDRM_XB_DWORDLIST
+{
+    DRM_BOOL   fValid;
+    DRM_DWORD  cDWORDs;
+DRM_OBFUS_PTR_TOP
+    DRM_BYTE  *pdwordBuffer;
+DRM_OBFUS_PTR_BTM
+    DRM_DWORD  iDwords;
+DRM_OBFUS_FILL_BYTES(4)
+} DRM_XB_DWORDLIST;
+
+#define XB_DWORD_LIST_TO_PDWORD( dwordlist ) ( ( (dwordlist).cDWORDs != 0) ? ( (DRM_DWORD*)( (dwordlist).pdwordBuffer + (dwordlist).iDwords) ) : NULL )
+
+/*
+** A flat array of QWORDs.  When represented in the binary format it is serialized as
+** a DWORD followed by cQWORDs consecutive QWORD values.
+*/
+typedef struct __tagDRM_XB_QWORDLIST
+{
+    DRM_BOOL   fValid;
+    DRM_DWORD  cQWORDs;
+DRM_OBFUS_PTR_TOP
+    DRM_BYTE  *pqwordBuffer;
+DRM_OBFUS_PTR_BTM
+    DRM_DWORD  iQwords;
+DRM_OBFUS_FILL_BYTES(4)
+} DRM_XB_QWORDLIST;
+
+#define XB_QWORD_LIST_TO_PQWORD( qwordlist ) ( ( (qwordlist).cQWORDs != 0) ? ( (DRM_UINT64*)( (qwordlist).pqwordBuffer + (qwordlist).iQwords) ) : NULL )
+
+/*
+**  An array of byte.  When serialized it may be serialized as
+**  a DWORD followed by cbData consecutive bytes or just cbData bytes if the
+**  defining format specifies the data as a fixed size.
+*/
+typedef struct __tagDRM_XB_BYTEARRAY
+{
+    DRM_BOOL   fValid;
+    DRM_DWORD  cbData;
+DRM_OBFUS_PTR_TOP
+    DRM_BYTE  *pbDataBuffer;
+DRM_OBFUS_PTR_BTM
+    DRM_DWORD  iData;
+DRM_OBFUS_FILL_BYTES(4)
+} DRM_XB_BYTEARRAY;
+
+#define XBBA_TO_PB( xbba ) ( ( (xbba).cbData != 0 ) ? ( (xbba).pbDataBuffer + (xbba).iData ) : NULL )
+#define XBBA_TO_CB( xbba ) ( (xbba).cbData )
+#define XBBA_HAS_DATA( xbba ) ( (xbba).fValid && XBBA_TO_PB( (xbba) ) != NULL )
+
+typedef struct __tagDRM_XB_OBJECT
+{
+    DRM_BOOL                            fValid;
+    DRM_WORD                            wType;
+    DRM_WORD                            wFlags;
+DRM_OBFUS_PTR_TOP
+    DRM_BYTE                           *pbBuffer;
+DRM_OBFUS_PTR_BTM
+    DRM_DWORD                           ibData;
+    DRM_DWORD                           cbData;
+    struct __tagDRM_XB_OBJECT *pNext; /* Linked list */
+} DRM_XB_OBJECT;
+
+typedef struct __tagDRM_XB_UNKNOWN_OBJECT
+{
+    DRM_BOOL                            fValid;
+    DRM_WORD                            wType;
+    DRM_WORD                            wFlags;
+DRM_OBFUS_PTR_TOP
+    DRM_BYTE                           *pbBuffer;
+DRM_OBFUS_PTR_BTM
+    DRM_DWORD                           ibData;
+    DRM_DWORD                           cbData;
+DRM_OBFUS_PTR_TOP
+    struct __tagDRM_XB_UNKNOWN_OBJECT  *pNext; /* Linked list */
+DRM_OBFUS_PTR_BTM
+} DRM_XB_UNKNOWN_OBJECT;
+
+typedef struct __tagDRM_XB_UNKNOWN_CONTAINER
+{
+    DRM_BOOL                             fValid;
+    DRM_WORD                             wType;
+    DRM_WORD                             wFlags;
+DRM_OBFUS_PTR_TOP
+    DRM_XB_UNKNOWN_OBJECT                *pObject;
+DRM_OBFUS_PTR_BTM
+DRM_OBFUS_PTR_TOP
+    struct __tagDRM_XB_UNKNOWN_CONTAINER *pNext; /* Linked list */
+DRM_OBFUS_PTR_BTM
+DRM_OBFUS_PTR_TOP
+    struct __tagDRM_XB_UNKNOWN_CONTAINER *pUnkChildcontainer; /* Linked list */
+DRM_OBFUS_PTR_BTM
+} DRM_XB_UNKNOWN_CONTAINER;
+
+/*
+**  Each element in an object can be one of these base types
+*/
+typedef enum
+{
+    XB_ELEMENT_TYPE_INVALID,
+    XB_ELEMENT_TYPE_WORD,
+    XB_ELEMENT_TYPE_DWORD,
+    XB_ELEMENT_TYPE_QWORD,
+    XB_ELEMENT_TYPE_GUID,
+    XB_ELEMENT_TYPE_GUIDLIST,
+    XB_ELEMENT_TYPE_WORDLIST,
+    XB_ELEMENT_TYPE_DWORDLIST,
+    XB_ELEMENT_TYPE_STRUCTLIST,
+    XB_ELEMENT_TYPE_BYTEARRAY,
+    XB_ELEMENT_TYPE_QWORDLIST,
+    XB_ELEMENT_TYPE_EMPTY,
+    XB_ELEMENT_TYPE_UNKNOWN_OBJECT,
+    XB_ELEMENT_TYPE_UNKNOWN_CONTAINER,
+    XB_ELEMENT_TYPE_ELEMENT_COUNT,
+} XB_ELEMENT_BASE_TYPE;
+
+typedef enum _XB_SIZE_TYPE
+{
+    XB_SIZE_IS_ABSOLUTE,                            /* Absolute means that the size value is an exact value as specified by the accompanying DWORD; absolute == fixed size */
+    XB_SIZE_IS_RELATIVE_WORD,                       /* Relative means that there is an adjoining WORD in the binary format that specifies the size; relative == dynamic size */
+    XB_SIZE_IS_RELATIVE_DWORD,                      /* Relative means that there is an adjoining DWORD in the binary format that specifies the size */
+    XB_SIZE_IS_RELATIVE_DWORD_IN_BITS,              /* Relative means that there is an adjoining DWORD in the binary format that specifies the size (in BITS not BYTES)*/
+    XB_SIZE_IS_WORD_IN_BITS_ANOTHER_STRUCT_MEMBER,  /* Relative means that there is an adjoining WORD in the binary format that specifies the size (in BITS not BYTES)*/
+    XB_SIZE_IS_REMAINING_DATA_IN_OBJECT,            /* Remaining in data object means that size of the byte array is the remaining bytes in the object. WARNING!!!! THIS MUST BE THE LAST ELEMENT IN THE OBJECT! */
+    XB_SIZE_IS_DATA_IN_OBJECT_FOR_WEAKREF,          /* The entire size of the data object.  The XBinary byte array will be weak reference to the raw bytes for this object.
+                                                     * The serialization data index should not change when parsing this object. */
+    XB_SIZE_IS_WORD_IN_ANOTHER_STRUCT_MEMBER,       /* Means that there is an adjoining WORD in the binary format that specifies the size (in BYTES).  For this type the DRM_XB_SIZE.wOffset element is used
+                                                     * as the offset for the previous value and the wMinSize field contains the sturcture size.  For DWORD lists, the wMinSize and wMaxSize are used to determine
+                                                     * the min/max expected element count.  The parser/builder will fail if the count falls outside this range.  A range of {0,0} will be ignored. */
+    XB_SIZE_IS_DWORD_IN_ANOTHER_STRUCT_MEMBER,      /* Means that there is an adjoining DWORD in the binary format that specifies the size (in BYTES).  For this type the DRM_XB_SIZE.wOffset element is used
+                                                     * as the offset for the previous value and the wMinSize field contains the sturcture size. */
+    XB_SIZE_IS_ELEMENT_COUNT,                       /* This is NOT used in reference to a XBinary byte array.  This value is used by a container to indicate that the cEntries object in the container should
+                                                     * contain a count of specific elements.  The element type is indicated by the DRM_XB_SIZE.wMinSize member. */
+    XB_SIZE_IS_CONTAINER_FILL_PATTERN,              /* Means that the variable is not parsed and is only used on containers to indicate the byte fill pattern that may complete the end of the container length */
+    XB_SIZE_IS_MAX_MIN_VALUES,                      /* Means the XBSize parameter contains the maximum and minimum values for the associated XBinary element. */
+    XB_SIZE_IS_IGNORED = 0xBAAD                     /* Relative means that there is an adjoining DWORD in the binary format that specifies the size */
+} XB_SIZE_TYPE;
+
+typedef struct __tagDRM_XB_SIZE
+{
+    XB_SIZE_TYPE eSizeType;
+    DRM_WORD     wMinSize;
+    DRM_WORD     wMaxSize;  /* Max size is ignored if wMaxSize is zero */
+    DRM_WORD     wOffset;   /* Offset into the parent structure where the size/count field is located */
+    DRM_WORD     wPadding;
+} DRM_XB_SIZE;
+
+/* Unless you are using a BYTEARRAY use XB_SIZE_IGNORED for the xbSize field  */
+#define XB_SIZE_IGNORED                   { XB_SIZE_IS_IGNORED       , 0        , 0        , 0, 0xBAAD          }
+#define XB_SIZE_MAX_MIN(minSize, maxSize) { XB_SIZE_IS_MAX_MIN_VALUES, (minSize), (maxSize), 0, XB_PADDING_NONE }
+
+#define XB_PADDING_NONE 0
+
+#define XB_SIZE_ABSOLUTE(x)                             XB_SIZE_ABSOLUTE_WITH_PADDING(x, XB_PADDING_NONE)
+#define XB_SIZE_RELATIVE_DWORD(minSize,maxSize)         XB_SIZE_RELATIVE_DWORD_WITH_PADDING(minSize, maxSize, XB_PADDING_NONE)
+#define XB_SIZE_RELATIVE_WORD(minSize,maxSize)          XB_SIZE_RELATIVE_WORD_WITH_PADDING(minSize, maxSize, XB_PADDING_NONE)
+/*
+** For STRUCTLIST objects we use the DRM_XB_SIZE object to represent the size of the struct and the offset of the element count value in a previous structure.
+** The struct size is stored in the DRM_XB_SIZE.wSize member and the offset to the element count (in a previous structure) is in the DRM_XB_SIZE.dwPadding
+** member.
+*/
+#define XB_COUNT_WORD_FROM_STRUCT_MEMBER(minCount, maxCount, struc, member) { XB_SIZE_IS_WORD_IN_ANOTHER_STRUCT_MEMBER     , (minCount), (maxCount), DRM_OFFSET_OF(struc,member), XB_PADDING_NONE }
+#define XB_COUNT_DWORD_FROM_STRUCT_MEMBER(minCount, maxCount, struc, member){ XB_SIZE_IS_DWORD_IN_ANOTHER_STRUCT_MEMBER    , (minCount), (maxCount), DRM_OFFSET_OF(struc,member), XB_PADDING_NONE }
+#define XB_SIZE_IS_COUNT_OF_ELEMENTS(reftype)                               { XB_SIZE_IS_ELEMENT_COUNT                     , (reftype) , (reftype) , 0                          , XB_PADDING_NONE }
+#define XB_SIZE_IN_OBJECT_FOR_WEAKREF                                       { XB_SIZE_IS_DATA_IN_OBJECT_FOR_WEAKREF        , 0         , 0         , 0                          , XB_PADDING_NONE }
+#define XB_SIZE_REMAINING_DATA_IN_OBJECT(minSize,maxSize)                   { XB_SIZE_IS_REMAINING_DATA_IN_OBJECT          , (minSize) , (maxSize) , 0                          , XB_PADDING_NONE }
+#define XB_SIZE_FROM_STRUCT_MEMBER_IN_BITS(struc, member, minSize, maxSize) { XB_SIZE_IS_WORD_IN_BITS_ANOTHER_STRUCT_MEMBER, (minSize) , (maxSize) , DRM_OFFSET_OF(struc,member), XB_PADDING_NONE }
+#define XB_SIZE_CONTAINER_FILL_PATTERN(x)                                   { XB_SIZE_IS_CONTAINER_FILL_PATTERN            , 0         , 0         , (x)                        , XB_PADDING_NONE }
+
+#define XB_SIZE_ABSOLUTE_WITH_PADDING(x, padding)                                                { XB_SIZE_IS_ABSOLUTE                          , (x)      , (x)      , 0                          , (padding) }
+#define XB_SIZE_RELATIVE_DWORD_IN_BITS_WITH_PADDING(minSize, maxSize, padding)                   { XB_SIZE_IS_RELATIVE_DWORD_IN_BITS            , (minSize), (maxSize), 0                          , (padding) }
+#define XB_SIZE_RELATIVE_DWORD_WITH_PADDING(minSize, maxSize, padding)                           { XB_SIZE_IS_RELATIVE_DWORD                    , (minSize), (maxSize), 0                          , (padding) }
+#define XB_SIZE_RELATIVE_WORD_WITH_PADDING(minSize, maxSize, padding)                            { XB_SIZE_IS_RELATIVE_WORD                     , (minSize), (maxSize), 0                          , (padding) }
+#define XB_SIZE_REMAINING_DATA_IN_OBJECT_WITH_PADDING(member, minSize, maxSize, padding)         { XB_SIZE_IS_REMAINING_DATA_IN_OBJECT          , (minSize), (maxSize), 0                          , (padding) }
+#define XB_SIZE_IN_OBJECT_FOR_WEAKREF_WITH_PADDING(member, minSize, maxSize, padding)            { XB_SIZE_IS_DATA_IN_OBJECT_FOR_WEAKREF        , (minSize), (maxSize), 0                          , (padding) }
+#define XB_SIZE_FROM_STRUCT_MEMBER_IN_BITS_WITH_PADDING(struc, member, minSize, maxSize, padding){ XB_SIZE_IS_WORD_IN_BITS_ANOTHER_STRUCT_MEMBER, (minSize), (maxSize), DRM_OFFSET_OF(struc,member), (padding) }
+
+/*
+** Each element in an object is described be the following structure.
+** Constructing an array of such objects will describe an entire object
+*/
+typedef struct __tagDRM_XB_ELEMENT_DESCRIPTION
+{
+    XB_ELEMENT_BASE_TYPE eElementType;              /* Type of element */
+    DRM_WORD             wOffsetInCurrentStruct;    /* Where in the containing struct the element should be serialized to/from */
+    DRM_XB_SIZE          xbSize;                    /* If the object is a BYTEARRAY this is the size relative or absolute */
+                                                    /* If the object is a STRUCTLIST this is the size of the C-struct to allocate for each entry in the list */
+    const DRM_VOID  *pElementDescription; /* Only used if the object is a STRUCTLIST */
+    DRM_DWORD        cElementDescription; /* Only used if the object is a STRUCTLIST */
+} DRM_XB_ELEMENT_DESCRIPTION;
+
+typedef enum __tagDRM_XB_ALIGNMENT
+{
+    XB_ALIGN_1_BYTE  =  1,
+    XB_ALIGN_8_BYTE  =  8,
+    XB_ALIGN_16_BYTE = 16,
+} DRM_XB_ALIGNMENT;
+
+/*
+**  Each entry(container or object) is represented by the following structure.
+*/
+PREFAST_PUSH_DISABLE_EXPLAINED(__WARNING_POOR_DATAALIGNMENT, "Structure sequence maintained to avoid manually modifying large structure arrays.")
+typedef struct __tagDRM_XB_ENTRY_DESCRIPTION
+{
+    DRM_WORD  wType;                                /* Type identifier -- should be the same value as the entries order in the entry array in the format description */
+    DRM_WORD  wFlags;                               /* Flags for this type */
+    DRM_WORD  wParent;                              /* The container that can hold this object/container */
+    DRM_BOOL  fDuplicateAllowed;                    /* Are multiple objects allowed */
+    DRM_BOOL  fOptional;                            /* Is this a required object for the binary format to be valid? */
+    DRM_WORD  wOffsetInCurrentStruct;               /* Where in the containing structure should the data be serialized from/to */
+    DRM_DWORD dwStructureSize;                      /* Size of the containing structure.  This is necessary when duplicates are allocated in a linked list */
+    DRM_WORD  wBuilderSortOrder;                    /* Order in which elements should be serialized during building.  Has no affect during parsing */
+    const DRM_VOID *pContainerOrObjectDescriptions; /* This pointer is either an array of DRM_XB_ELEMENT_DESCRIPTION if the entry is an object or NULL if this is a container . */
+    DRM_WORD  cContainerOrObjectDescriptions;
+} DRM_XB_ENTRY_DESCRIPTION;
+PREFAST_POP
+
+/*
+** Indicates the size element is not in the extended header
+*/
+#define DRM_XB_EXTENDED_HEADER_SIZE_OFFSET_INVALID ((DRM_WORD)0xFFFF)
+
+typedef struct __tagDRM_XB_HEADER_DESCRIPTION
+{
+    XB_FORMAT_ID_LENGTH             eFormatIdLength;
+    DRM_UINT64                      qwFormatIdentifier;             /* 4 or 8 byte string identifier.  Use XB_DEFINE_DWORD_FORMAT_ID or XB_DEFINE_QWORD_FORMAT_ID to create this value */
+    DRM_DWORD                       dwFormatVersion;                /* Version supported by this description */
+    DRM_XB_ALIGNMENT                eAlign;                         /* Byte alignment identifier.  Must be a non-zero, 4^x value (e.g. 1, 4, 8, 16, etc). */
+    DRM_WORD                        wOffsetOfSizeInHeaderStruct;    /* Where in the containing structure should the data be serialized from/to */
+    const DRM_XB_ENTRY_DESCRIPTION *pEntryDescription;              /* The header can have optional extra data -- but only 1 */
+} DRM_XB_HEADER_DESCRIPTION;
+
+/*
+**  Single descrption point for a format.  This format is composed of arrays of other objects as noted below.
+*/
+typedef struct __tagDRM_XB_FORMAT_DESCRIPTION
+{
+    const DRM_XB_HEADER_DESCRIPTION *pHeaderDescription;
+    const DRM_XB_ENTRY_DESCRIPTION  *pEntryDescriptions; /* An array of entry descriptions.  Each entry description is either a container or an object */
+    DRM_WORD                         cEntryDescriptions;
+    DRM_WORD                         cContainerDepth;
+} DRM_XB_FORMAT_DESCRIPTION;
+
+
+#define XB_DEFINE_FOUR_BYTE_FORMAT_ID( ch0, ch1, ch2, ch3 )                             \
+        ( (DRM_DWORD)(DRM_BYTE)(ch3)         | ( (DRM_DWORD)(DRM_BYTE)(ch2) << 8 ) |    \
+        ( (DRM_DWORD)(DRM_BYTE)(ch1) << 16 ) | ( (DRM_DWORD)(DRM_BYTE)(ch0) << 24 ) )
+
+#define XB_DEFINE_DWORD_FORMAT_ID( ch0, ch1, ch2, ch3 )                                 \
+        DRM_UI64LITERAL( 0, XB_DEFINE_FOUR_BYTE_FORMAT_ID( ch0, ch1, ch2, ch3 ) )
+
+#define XB_DEFINE_QWORD_FORMAT_ID( ch0, ch1, ch2, ch3, ch4, ch5, ch6, ch7 )             \
+        DRM_UI64LITERAL( XB_DEFINE_FOUR_BYTE_FORMAT_ID( ch0, ch1, ch2, ch3 ), XB_DEFINE_FOUR_BYTE_FORMAT_ID( ch4, ch5, ch6, ch7 ) )
+
+#define XB_NULL_DESCRIPTOR NULL, 0
+#define XB_USE_DESCRIPTOR( descriptor ) (DRM_VOID*)(descriptor), DRM_NO_OF( (descriptor) )
+
+#define XB_DECLARE_OFFSET_AND_SIZE_DEREF(struc, member) DRM_OFFSET_OF(struc,member), DRM_SIZEOF_MEMBER_DEREF(struc,member)
+#define XB_DECLARE_OFFSET_AND_SIZE( struc, member ) DRM_OFFSET_OF(struc,member), DRM_SIZEOF_MEMBER(struc,member)
+
+/*
+** Internal helper functions
+*/
+DRM_NO_INLINE DRM_WORD DRM_CALL _XB_MapObjectTypeToEntryDescriptionIndex(
+    __in                      const DRM_XB_FORMAT_DESCRIPTION  *f_pFormat,
+    __in                            DRM_WORD                    f_wType ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_BOOL DRM_CALL _XB_IsKnownObjectType(
+    __in                      const DRM_XB_FORMAT_DESCRIPTION  *f_pFormat,
+    __in                            DRM_WORD                    f_wType ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_BOOL DRM_CALL _XB_IsObjectTypeAChildOf(
+    __in                      const DRM_XB_FORMAT_DESCRIPTION  *f_pFormat,
+    __in                            DRM_WORD                    f_wChildType,
+    __in                            DRM_WORD                    f_wParentType,
+    __out_opt                       DRM_XB_ENTRY_DESCRIPTION  **f_ppEntry ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_RESULT DRM_CALL _DRM_XB_AlignData(
+    __in                                                                                                        DRM_XB_ALIGNMENT    f_eAlign,
+    __in                                                                                                        DRM_DWORD           f_cbBuffer,
+    __inout_ecount( 1 ) _Post_satisfies_( *f_piBuffer >= _Old_( *f_piBuffer ) )                                 DRM_DWORD          *f_piBuffer,
+    __out_opt _Post_satisfies_( f_pcbPadding == NULL || *f_pcbPadding == *f_piBuffer - _Old_( *f_piBuffer ) )   DRM_DWORD          *f_pcbPadding ) DRM_NO_INLINE_ATTRIBUTE;
+
+
+EXIT_PK_NAMESPACE;
+
+#endif  /* __DRM_XB_H__ */
+
diff --git a/prebuilt-v4.4/noarch/include/drmxbbuilder.h b/prebuilt-v4.4/noarch/include/drmxbbuilder.h
new file mode 100644
index 0000000..43f5d6a
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmxbbuilder.h
@@ -0,0 +1,117 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __DRM_XB_BUILDER_H__
+#define __DRM_XB_BUILDER_H__ 1
+
+#include <drmxb.h>
+#include <drmstkalloctypes.h>
+
+ENTER_PK_NAMESPACE;
+
+typedef struct __tagDRM_XB_BUILDER_NODE
+{
+    DRM_WORD     wType;
+    DRM_DWORD    cbLength;
+    /*
+    ** This can either be an object or a linked list of
+    ** builder nodes depending on whether this is a
+    ** leaf node or not
+    */
+    const DRM_VOID *pvObject;
+} DRM_XB_BUILDER_NODE;
+
+typedef struct __tagDRM_XB_BUILDER_LISTNODE
+{
+    DRM_XB_BUILDER_NODE                  Node;
+    struct __tagDRM_XB_BUILDER_LISTNODE *pNext;
+} DRM_XB_BUILDER_LISTNODE;
+
+typedef struct __tagDRM_XB_BUILDER_UNKNOWNOBJECT_LISTNODE
+{
+    DRM_XB_BUILDER_LISTNODE                            listNode;
+    DRM_BOOL                                           fDuplicateAllowed;
+    DRM_WORD                                           wFlags;
+    DRM_WORD                                           wParent;
+    struct __tagDRM_XB_BUILDER_UNKNOWNOBJECT_LISTNODE *pNext;
+} DRM_XB_BUILDER_UNKNOWNOBJECT_LISTNODE;
+
+typedef struct __tagDRM_XB_BUILDER_CONTEXT_INTERNAL
+{
+    DRM_DWORD                                 dwVersion;
+
+    /*  In case of nodes which can have duplicates, the array below will hold the
+    **  pointer to the last node of that type. In those cases, it is just used
+    **  to keep track of the types of nodes added
+    */
+    DRM_XB_BUILDER_NODE                    **rgpObjectNodes;
+    DRM_XB_BUILDER_UNKNOWNOBJECT_LISTNODE   *pUnknownObjects;
+    DRM_STACK_ALLOCATOR_CONTEXT              oStack;
+    DRM_STACK_ALLOCATOR_CONTEXT             *pcontextStack;
+    const DRM_XB_FORMAT_DESCRIPTION         *pformat;
+
+#if DRM_OBFUS_NEED_PADDING
+    DRM_VOID *m_rgpvWM7Padding[4];
+#endif /* DRM_OBFUS_NEED_PADDING */
+} DRM_XB_BUILDER_CONTEXT_INTERNAL;
+
+#define DRM_XB_BUILDER_CONTEXT_BUFFER_SIZE sizeof( DRM_XB_BUILDER_CONTEXT_INTERNAL )
+
+typedef struct __tagDRM_XB_BUILDER_CONTEXT
+{
+    /*
+    ** This data is Opaque.  Do not set any value in it.
+    */
+    DRM_BYTE rgbOpaqueBuffer[ DRM_XB_BUILDER_CONTEXT_BUFFER_SIZE ];
+} DRM_XB_BUILDER_CONTEXT;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_XB_StartFormatFromStack(
+    __inout                                     DRM_STACK_ALLOCATOR_CONTEXT *f_pStack,
+    __in                                        DRM_DWORD                    f_dwVersion,
+    __inout_ecount( 1 )                         DRM_XB_BUILDER_CONTEXT      *f_pcontextBuilder,
+    __in                                  const DRM_XB_FORMAT_DESCRIPTION   *f_pformat ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_XB_StartFormat(
+    __inout_bcount( f_cbStack )                 DRM_BYTE                    *f_pbStack,
+    __in                                        DRM_DWORD                    f_cbStack,
+    __in                                        DRM_DWORD                    f_dwVersion,
+    __inout_ecount( 1 )                         DRM_XB_BUILDER_CONTEXT      *f_pcontextBuilder,
+    __in                                  const DRM_XB_FORMAT_DESCRIPTION   *f_pformat ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_XB_FinishFormat(
+    __in_ecount( 1 )                                                              const DRM_XB_BUILDER_CONTEXT *f_pcontextBuilder,
+    __inout_bcount_opt( *f_pcbFormat )                                                  DRM_BYTE               *f_pbFormat,
+    __inout_ecount( 1 ) _Post_satisfies_( *f_pcbFormat <= _Old_( *f_pcbFormat ) )       DRM_DWORD              *f_pcbFormat ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_XB_SetExtendedHeader(
+    __inout_ecount( 1 )                         DRM_XB_BUILDER_CONTEXT    *f_pcontextBuilder,
+    __in_ecount( 1 )                      const DRM_VOID                  *f_pvObject ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_XB_AddEntry(
+    __inout_ecount( 1 )                         DRM_XB_BUILDER_CONTEXT    *f_contextBuilder,
+    __in                                        DRM_WORD                   f_wObjectType,
+    __in_ecount( 1 )                      const DRM_VOID                  *f_pvObject ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL  DRM_XB_AddUnknownHierarchy(
+    __inout_ecount( 1 )                         DRM_XB_BUILDER_CONTEXT_INTERNAL
+                                                                          *f_pcontextBuilder,
+    __inout_ecount( 1 )                         DRM_XB_BUILDER_UNKNOWNOBJECT_LISTNODE
+                                                                          *f_plistnode ) DRM_NO_INLINE_ATTRIBUTE;
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_XB_AddUnknownObject(
+    __inout_ecount( 1 )                         DRM_XB_BUILDER_CONTEXT    *f_pcontextBuilder,
+    __in                                        DRM_WORD                   f_wObjectType,
+    __in                                        DRM_BOOL                   f_fDuplicateAllowed,
+    __in                                        DRM_WORD                   f_wParent,
+    __in                                        DRM_WORD                   f_wFlags,
+    __in                                        DRM_DWORD                  f_cbObject,
+    __in_bcount_opt( f_cbObject )         const DRM_BYTE                  *f_pbObject ) DRM_NO_INLINE_ATTRIBUTE;
+
+EXIT_PK_NAMESPACE;
+
+#endif  /* __DRM_XB_BUILDER_H__ */
+
diff --git a/prebuilt-v4.4/noarch/include/drmxbparser.h b/prebuilt-v4.4/noarch/include/drmxbparser.h
new file mode 100644
index 0000000..449e932
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmxbparser.h
@@ -0,0 +1,52 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __DRM_XB_PARSER_H__
+#define __DRM_XB_PARSER_H__
+
+#include <drmxb.h>
+#include <drmstkalloctypes.h>
+
+ENTER_PK_NAMESPACE;
+
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_XB_UnpackBinary(
+    __in_bcount( f_cb )       const DRM_BYTE                    *f_pb,
+    __in                            DRM_DWORD                    f_cb,
+    __inout                         DRM_STACK_ALLOCATOR_CONTEXT *f_pStack,
+    __in_ecount( f_cformat )  const DRM_XB_FORMAT_DESCRIPTION   *f_pformat,
+    __in                            DRM_DWORD                    f_cformat,
+    __out_opt                       DRM_DWORD                   *f_pdwVersionFound,
+    __out_opt                       DRM_DWORD                   *f_pcbParsed,
+    __inout                         DRM_VOID                    *f_pStruct ) DRM_NO_INLINE_ATTRIBUTE;
+
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_XB_FindObject(
+    __in                            DRM_WORD                     f_wObjectType,
+    __in_ecount( 1 )          const DRM_XB_FORMAT_DESCRIPTION   *f_pformat,
+    __in_bcount( f_cb )       const DRM_BYTE                    *f_pb,
+    __in                            DRM_DWORD                    f_cb,
+    __out                           DRM_DWORD                   *f_piObject,
+    __out                           DRM_DWORD                   *f_pcbObject ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_XB_UnpackHeader(
+    __in_bcount( f_cb )       const DRM_BYTE                    *f_pb,
+    __in                            DRM_DWORD                    f_cb,
+    __inout                         DRM_STACK_ALLOCATOR_CONTEXT *f_pStack,
+    __in_ecount( f_cformat )  const DRM_XB_FORMAT_DESCRIPTION   *f_pformat,
+    __in                            DRM_DWORD                    f_cformat,
+    __out_opt                       DRM_DWORD                   *f_pdwVersionFound,
+    __out_opt                       DRM_DWORD                   *f_pcbParsed,
+    __out_opt                       DRM_DWORD                   *f_pcbContainer,
+    __out_opt                       DRM_DWORD                   *f_piFormat,
+    __inout                         DRM_VOID                    *f_pStruct ) DRM_NO_INLINE_ATTRIBUTE;
+
+EXIT_PK_NAMESPACE;
+
+#endif  /* __DRM_XB_PARSER_H__ */
+
diff --git a/prebuilt-v4.4/noarch/include/drmxmlbuilder.h b/prebuilt-v4.4/noarch/include/drmxmlbuilder.h
new file mode 100644
index 0000000..060fd3e
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmxmlbuilder.h
@@ -0,0 +1,254 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+
+#ifndef __DRMXMLBUILDER_H__
+#define __DRMXMLBUILDER_H__
+
+#include <drmtypes.h>
+#include <drmbase64.h>
+#include <oemcryptoctx.h>
+#include <oemsha1.h>
+
+ENTER_PK_NAMESPACE;
+
+#define CB_XMB_EXTRA              100
+#define DRM_XMB_OVERHEAD          (sizeof(_XMBContext) + CB_XMB_EXTRA)
+
+extern const DRM_DWORD g_cbXMLBuilderMinimum;
+
+typedef struct _tagXMBContext
+{
+    /*
+    ** Usage of buffer:
+    ** This context buffer is allocated by user at CreateDocument(). Its size  can be reallocated
+    ** via ReallocDocument(). The XML string is built on the way when each of the API calls are
+    ** made. The XML string grow from top to bottom. On the way, all opened node's open tag
+    ** position is kept and saved on the buffer from bottom to top. So when wNextStringPos
+    ** and wNextOpenNodePos collides, NO_MEM is returned and user should reallocate more
+    ** memory to finish the operation.
+    ** Note: The open nodes positions will be saved as DWORDs, so it aligns perfectly with the
+    ** growing XML string within the WCHAR buffer.
+    */
+
+    /* !!! Caller is ensuring only 2 byte alignment. Never add any member variable greater than 2 bytes*/
+
+    DRM_BOOL fInited;
+    DRM_BOOL fIsSimMode;        /* TRUE to create a faked doc to calculate the length needed */
+    DRM_DWORD wMaxStackUsed;    /* Max stack space used for nested nodes */
+    DRM_DWORD wSize;            /* size of context */
+    DRM_DWORD wNextOpenNodePos;
+    DRM_DWORD wNextStringPos;   /* next insertion point */
+    DRM_DWORD wBuffSize;        /* size of buffer in WCHARs*/
+    DRM_WCHAR XmlString [1];
+} _XMBContext;
+
+
+
+
+/* state to be used for save/restore XML context during API calls */
+typedef struct _tagXMBState
+{
+    DRM_DWORD cwchMaxStackUsed;    /* Max stack space used for nested nodes */
+    DRM_DWORD iwchNextOpenNodePos;
+    DRM_DWORD iwchNextStringPos;   /* next insertion point */
+} XMBState;
+
+
+/*
+*******************************************************************************
+** API methods
+*******************************************************************************
+*/
+
+DRM_API DRM_RESULT DRM_CALL DRM_XMB_SimulateCreateDocument(
+    __in    const DRM_DWORD         cbXmlContext,
+    __inout       _XMBContext      *pbXmlContext,
+    __in    const DRM_CONST_STRING *pdstrRootNodeName);
+
+DRM_API DRM_RESULT DRM_CALL DRM_XMB_CreateDocument(
+    __in                            const DRM_DWORD         cbXmlContext,
+    __inout_bcount(cbXmlContext)          _XMBContext      *pbXmlContext,
+    __in                            const DRM_CONST_STRING *pdstrRootNodeName);
+
+DRM_API DRM_RESULT DRM_CALL DRM_XMB_ReallocDocument(
+    __in                                  _XMBContext *pbOldXmlContext,
+    __in                            const DRM_DWORD    cbNewXmlContext,
+    __inout_bcount(cbNewXmlContext)       _XMBContext *pbNewXmlContext );
+
+/**********************************************************************
+** Function:    DRM_XMB_CloseDocument
+** Synopsis:    Pop the opened nodes and close the document, if space allowed.
+** Arguments:
+** Returns:     DRM_SUCCESS on success
+** Notes:
+***********************************************************************/
+DRM_API DRM_RESULT DRM_CALL DRM_XMB_CloseDocument(
+    __inout _XMBContext *pbXmlContext,
+    __out   DRM_STRING  *pdstrXML   /* if opened with DRM_XMB_SimulateCreateDocument, this contains the counts of WCHAR's needed for the real string */
+    );
+
+DRM_API DRM_RESULT DRM_CALL DRM_XMB_OpenNode(
+    __inout       _XMBContext      *pbXmlContext,
+    __in    const DRM_CONST_STRING *pdstrNodeName);
+
+DRM_API DRM_RESULT DRM_CALL DRM_XMB_SaveState(
+    __inout const _XMBContext *pbXmlContext,
+    __out         XMBState    *pState );
+
+DRM_API DRM_RESULT DRM_CALL DRM_XMB_RestoreState(
+    __inout       _XMBContext *pbXmlContext,
+    __in    const XMBState    *pState );
+
+
+DRM_API DRM_RESULT DRM_CALL DRM_XMB_CloseCurrNode(
+    __inout   _XMBContext *pbXmlContext,
+    __out_opt DRM_STRING  *pdstrXMLFragment );
+
+DRM_API DRM_RESULT DRM_CALL DRM_XMB_GetCurrNodeName(
+    __in  _XMBContext *pbXmlContext,
+    __out DRM_STRING  *pdstrNodeName);
+
+DRM_API DRM_RESULT DRM_CALL DRM_XMB_GetContextSize(
+    __in  const _XMBContext *pbXmlContext,
+    __out       DRM_DWORD   *pcbXmlContext );
+
+DRM_API DRM_RESULT DRM_CALL DRM_XMB_AddAttribute(
+    __inout       _XMBContext      *pXmlContext,
+    __in    const DRM_CONST_STRING *pdstrAttrName,
+    __in    const DRM_CONST_STRING *pdstrAttrValue );
+
+DRM_API DRM_RESULT DRM_CALL DRM_XMB_AddData(
+    __inout       _XMBContext      *pXmlContext,
+    __in    const DRM_CONST_STRING *pdstrData );
+
+DRM_API DRM_RESULT DRM_CALL DRM_XMB_ReserveSpace(
+    __inout                           _XMBContext *f_poXMBContext,
+    __in                              DRM_DWORD    f_cchData,
+    __deref_out_ecount_opt(f_cchData) DRM_WCHAR  **f_ppwchData );
+
+DRM_API DRM_RESULT DRM_CALL DRM_XMB_AddCData(
+    __inout       _XMBContext      *pXmlContext,
+    __in    const DRM_CONST_STRING *pdstrCData );
+
+/**********************************************************************
+** Function:    DRM_XMB_AppendNode
+** Synopsis:    Appends a caller provided node nested from current opened node
+** Arguments:   [pdwStamp] --
+** Returns:     DRM_SUCCESS on success
+** Notes:       The caller is responsible for the validity of the appending node
+***********************************************************************/
+DRM_API DRM_RESULT DRM_CALL DRM_XMB_AppendNode(
+    __inout       _XMBContext      *pXmlContext,
+    __in    const DRM_CONST_STRING *pdstrXmlString);
+
+/**********************************************************************
+** Function:    DRM_XMB_AddXMLNode
+** Synopsis:    Appends a caller provided node nested from current opened node
+** Arguments:   [dstrName]  -- Name for node tag
+**              [dstrValue] -- Context of the node for node tag
+** Returns:     DRM_SUCCESS on success
+** Notes:       The caller is responsible for the validity of the appending node
+***********************************************************************/
+
+
+DRM_API DRM_RESULT DRM_CALL DRM_XMB_AddXMLNode(
+    __inout       _XMBContext        *pbXMLContext,
+    __in    const DRM_CONST_STRING   *dstrName,
+    __in    const DRM_CONST_STRING   *dstrValue );
+
+/*******************************************************************
+**          PUBLIC MACRO DRM_XMB_RequiredCharsForTag
+**
+** purpose: calculates the number of XML characters required for
+**          the indicated tag, optional text, and optional
+**          attribute label and text.
+** note: <TAG></TAG> + attribute, optionally 2 quotes, space and equal sign
+*******************************************************************/
+
+#define DRM_XMB_RequiredCharsForTag( cchTag, cchData, cchAttrLabel, cchAttrText) \
+     ((cchTag)*2+5 \
+     +(cchData) \
+     +((cchAttrLabel)!=0?(cchAttrLabel)+4+(cchAttrText):0))
+
+/*******************************************************************
+**          PUBLIC MACRO DRM_XMB_RequiredCharsForTagNoClose
+**
+** purpose: calculates the number of XML characters required for
+**          the indicated tag, optional text, and optional
+**          attribute label and text, without considering the closing
+**          tag.
+** note: <TAG> + optionally attribute, 2 quotes, space and equal sign
+*******************************************************************/
+#define DRM_XMB_RequiredCharsForTagNoClose( cchTag, cchData, cchAttrLabel, cchAttrText) \
+    ((cchTag)+2 \
+    +(cchData) \
+    +((cchAttrLabel)!=0?(cchAttrLabel)+4+(cchAttrText):0))
+
+/*******************************************************************
+**          PUBLIC MACRO DRM_XMB_RequiredCharsForAttribute
+**
+** purpose: calculates the number of XML characters required for
+**          the an optional attribute label and text.
+** note: optionally attribute, 2 quotes, space and equal sign
+*******************************************************************/
+#define DRM_XMB_RequiredCharsForAttribute( cchAttrLabel, cchAttrText) \
+    ((cchAttrLabel)!=0?(cchAttrLabel)+4+(cchAttrText):0)
+
+typedef enum _WriteTagType
+{
+    wttOpen,
+    wttClosed
+} WriteTagType;
+
+/*********************************************************************
+**                 PUBLIC FUNCTION DRM_XMB_WriteTag
+**
+**      function: write one or both tags of an XML pair
+**                  and optionally the enclosed data and/or
+**                  a single attribute
+**
+**      if parameter wtt is wttClosed, the tag is closed and the
+**      XML builder insertion point remains at the same scope as
+**      when the function was called
+**
+**        <TAG[ attrlabel="attrtext"]>[data][</TAG>]
+**
+*********************************************************************/
+
+DRM_API DRM_RESULT DRM_CALL DRM_XMB_WriteTag(
+    __inout        _XMBContext      *pbDataOut,
+    __in     const DRM_CONST_STRING *pdstrTag,
+    __in_opt const DRM_CONST_STRING *pdstrData,
+    __in_opt const DRM_CONST_STRING *pdstrAttrLabel,
+    __in_opt const DRM_CONST_STRING *pdstrAttrText,
+    __in           WriteTagType      wtt);
+
+/*********************************************************************
+**             PUBLIC FUNCTION DRM_XMB_WriteCDATATag
+**
+** as above but writes a CDATA tag
+*********************************************************************/
+
+DRM_API DRM_RESULT DRM_CALL DRM_XMB_WriteCDATATag(
+    __inout        _XMBContext      *pbDataOut,
+    __in     const DRM_CONST_STRING *pdstrTag,
+    __in_opt const DRM_CONST_STRING *pdstrCDATA,
+    __in_opt const DRM_CONST_STRING *pdstrAttrLabel,
+    __in_opt const DRM_CONST_STRING *pdstrAttrText,
+    __in           WriteTagType      wtt);
+
+DRM_API DRM_RESULT DRM_CALL DRM_XMB_RemainingBuffer(
+    __in  const _XMBContext *f_pbXMB,
+    __out       DRM_DWORD   *f_pcbRemaining );
+
+EXIT_PK_NAMESPACE;
+
+#endif      /* __DRMXMLBUILDER_H__ */
+
+
diff --git a/prebuilt-v4.4/noarch/include/drmxmlbuildera.h b/prebuilt-v4.4/noarch/include/drmxmlbuildera.h
new file mode 100644
index 0000000..00d5ba9
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmxmlbuildera.h
@@ -0,0 +1,162 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+
+#ifndef __DRMXMLBUILDERA_H__
+#define __DRMXMLBUILDERA_H__
+
+#include <drmresults.h>
+#include <drmtypes.h>
+#include <oemaes.h>
+#include <drmxmlbuilder.h>
+
+ENTER_PK_NAMESPACE;
+
+#define DRM_XMB_RequiredCharsForTagA        DRM_XMB_RequiredCharsForTag
+#define DRM_XMB_RequiredCharsForTagNoCloseA DRM_XMB_RequiredCharsForTagNoClose
+#define DRM_XMB_RequiredCharsForAttributeA DRM_XMB_RequiredCharsForAttribute
+
+extern const DRM_EXPORT_VAR DRM_DWORD g_cbXMLBuilderMinimumA;
+
+/* XML builder context. */
+typedef struct _tagXMBContextA
+{
+    /*
+    ** Usage of buffer:
+    **
+    ** This context buffer is allocated by user at DRM_XMB_CreateDocumentA().
+    ** The XML string is built on the way when each of the API calls are made.
+    **
+    ** The XML output string being generated grows from lower address to higher address. The end
+    ** of the XML output string is indicated by ichNextString. All opened nodes' location at the
+    ** buffer and the length of the tag name string are saved on a stack that grows from from higher
+    ** address to lower address. The top of the stack is indicated by ichNextOpenNode.
+    **
+    ** When ichNextString and ichNextOpenNode collides, there is not enough memory available.
+    */
+
+    /* !!! Caller is ensuring only 2 byte alignment. Never add any member variable greater than 2 bytes. */
+
+    /* Flag indicating whether the XML builder context has been initialized. */
+    DRM_BOOL fInited;
+
+    /* Max stack space used for nested nodes */
+    DRM_DWORD cbMaxStackUsed;
+
+    /* Size (number of bytes) of the XML builder context. */
+    DRM_DWORD cbContext;
+
+    /* The current pointer to the top of the stack to keep the open nodes. */
+    DRM_DWORD ichNextOpenNode;
+
+    /* The current pointer to the output buffer for the XML output. */
+    DRM_DWORD ichNextString;
+
+    /* Size (number of CHARs) of internal buffer. */
+    DRM_DWORD cchBuffer;
+
+    /* The internal buffer. */
+    DRM_CHAR  rgchXML [1];
+} _XMBContextA;
+
+
+/*
+*******************************************************************************
+** API methods
+*******************************************************************************
+*/
+DRM_API DRM_RESULT DRM_CALL DRM_XMB_CalcNodeSizeA(
+    __in  const _XMBContextA  *f_pbContextXMLA,
+    __out       DRM_DWORD     *f_pcchContent,  /* ch count of node content */
+    __out       DRM_DWORD     *f_pcchTagName); /* ch count of node tag */
+
+DRM_API DRM_RESULT DRM_CALL DRM_XMB_CreateDocumentA(
+    __in                      const DRM_DWORD              f_cbXMBContextA,
+    __inout_bcount(f_cbXMBContextA) DRM_BYTE              *f_pbXMBContextA,
+    __in                      const DRM_ANSI_CONST_STRING *f_pdastrRootNode );
+
+DRM_API DRM_RESULT DRM_CALL DRM_XMB_CloseDocumentA(
+    __inout _XMBContextA  *f_poXMBContextA,
+    __out   DRM_SUBSTRING *f_pdasstrXML );
+
+DRM_API DRM_RESULT DRM_CALL DRM_XMB_OpenNodeA(
+    __inout       _XMBContextA          *f_poXMBContextA,
+    __in    const DRM_ANSI_CONST_STRING *f_pdastrNodeName );
+
+DRM_API DRM_RESULT DRM_CALL DRM_XMB_CloseCurrNodeA(
+    __inout   _XMBContextA  *f_pbXMBContextA,
+    __out_opt DRM_SUBSTRING *f_pdasstrXMLFragment );
+
+DRM_API DRM_RESULT DRM_CALL DRM_XMB_AESEncryptAndCloseCurrNodeA(
+    __inout       _XMBContextA  *f_pbContextXMLA,
+    __in    const DRM_AES_KEY   *f_pkeyAES,
+    __in          DRM_DWORD      f_dwNonce,
+    __out         DRM_SUBSTRING *f_pdasstrXMLFragment );
+
+DRM_API DRM_RESULT DRM_CALL DRM_XMB_AddAttributeA(
+    __inout       _XMBContextA          *f_poXMBContextA,
+    __in    const DRM_ANSI_CONST_STRING *f_pdastrAttrLabel,
+    __in    const DRM_ANSI_CONST_STRING *f_pdastrAttrValue );
+
+DRM_API DRM_RESULT DRM_CALL DRM_XMB_AddDataA(
+    __inout       _XMBContextA          *f_poXMBContextA,
+    __in    const DRM_ANSI_CONST_STRING *f_pdastrData );
+
+DRM_API DRM_RESULT DRM_CALL DRM_XMB_WriteTagA(
+    __inout        _XMBContextA *f_poXMBContextA,
+    __in     const DRM_ANSI_CONST_STRING *f_pdastrTag,
+    __in_opt const DRM_ANSI_CONST_STRING *f_pdastrData,
+    __in_opt const DRM_ANSI_CONST_STRING *f_pdastrAttrLabel,
+    __in_opt const DRM_ANSI_CONST_STRING *f_pdastrAttrValue,
+    __in           WriteTagType f_wtt );
+
+DRM_API DRM_RESULT DRM_CALL DRM_XMB_GetXMLBaseA(
+    __inout _XMBContextA *f_poXMBContextA,
+    __deref_out_z   DRM_CHAR    **f_ppchBase );
+
+DRM_API DRM_RESULT DRM_CALL DRM_XMB_AddCDataA(
+    __inout       _XMBContextA          *f_poXMBContextA,
+    __in    const DRM_ANSI_CONST_STRING *f_pdastrCData );
+
+DRM_API DRM_RESULT DRM_CALL DRM_XMB_WriteCDATATagA(
+    __inout       _XMBContextA *f_poXMBContextA,
+    __in    const DRM_ANSI_CONST_STRING *f_pdastrTag,
+    __in    const DRM_ANSI_CONST_STRING *f_pdastrCData,
+    __in    const DRM_ANSI_CONST_STRING *f_pdastrAttrLabel,
+    __in    const DRM_ANSI_CONST_STRING *f_pdastrAttrValue,
+    __in          WriteTagType f_wtt );
+
+DRM_API DRM_RESULT DRM_CALL DRM_XMB_ReserveSpaceA(
+    __inout       _XMBContextA  *f_poXMBContextA,
+    __in          DRM_DWORD      f_cchAlignment,
+    __in    const DRM_DWORD      f_cchData,
+    __out         DRM_SUBSTRING *f_pdasstrData );
+
+DRM_API DRM_RESULT DRM_CALL DRM_XMB_ShiftDataFromCurrentPositionA(
+    __inout       _XMBContextA *f_poXMBContextA,
+    __in    const DRM_DWORD     f_cchShift,
+    __in    const DRM_DWORD     f_cchData );
+
+DRM_API DRM_RESULT DRM_CALL DRM_XMB_ShiftCurrentPointerA(
+    __inout       _XMBContextA *f_poXMBContextA,
+    __in    const DRM_DWORD     f_cchShift );
+
+DRM_API DRM_RESULT DRM_CALL DRM_XMB_GetCurrentBufferPointerA(
+    __inout                                     _XMBContextA *f_poXMBContextA,
+    __in                                        DRM_BOOL      f_fAligned,
+    __deref_out_ecount(*f_pcchBufferPointer)    DRM_CHAR    **f_ppchBufferPointer,
+    __out                                       DRM_DWORD    *f_pcchBufferPointer );
+
+DRM_API DRM_RESULT DRM_CALL DRM_XMB_AppendNodeA(
+    __inout       _XMBContextA          *f_poXMBContextA,
+    __in    const DRM_ANSI_CONST_STRING *f_pdastrXmlString );
+
+EXIT_PK_NAMESPACE;
+
+#endif /* __DRMXMLBUILDERA_H__ */
+
diff --git a/prebuilt-v4.4/noarch/include/drmxmlbuilderconstants.h b/prebuilt-v4.4/noarch/include/drmxmlbuilderconstants.h
new file mode 100644
index 0000000..16bfc11
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmxmlbuilderconstants.h
@@ -0,0 +1,32 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __DRMXMLBUILDERCONSTANTS_H__
+#define __DRMXMLBUILDERCONSTANTS_H__
+
+#include <drmtypes.h>
+
+ENTER_PK_NAMESPACE;
+
+    extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING  g_dastrOpenEndTag;
+    extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING  g_dastrOpenCDATATag;
+    extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING  g_dastrCloseCDATATag;
+
+    extern DRM_GLOBAL_CONST  DRM_CONST_STRING       g_dstrOpenTag;
+    extern DRM_GLOBAL_CONST  DRM_CONST_STRING       g_dstrSpace;
+    extern DRM_GLOBAL_CONST  DRM_CONST_STRING       g_dstrOpenEndTag;
+    extern DRM_GLOBAL_CONST  DRM_CONST_STRING       g_dstrCloseTag;
+    extern DRM_GLOBAL_CONST  DRM_CONST_STRING       g_dstrEqualQuote;
+    extern DRM_GLOBAL_CONST  DRM_CONST_STRING       g_dstrQuote;
+    extern DRM_GLOBAL_CONST  DRM_CONST_STRING       g_dstrOpenCDATATag;
+    extern DRM_GLOBAL_CONST  DRM_CONST_STRING       g_dstrCloseCDATATag;
+
+EXIT_PK_NAMESPACE;
+
+#endif /* __DRMXMLBUILDERCONSTANTS_H__ */
+
diff --git a/prebuilt-v4.4/noarch/include/drmxmlhash.h b/prebuilt-v4.4/noarch/include/drmxmlhash.h
new file mode 100644
index 0000000..3f0cb96
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmxmlhash.h
@@ -0,0 +1,55 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __DRM_XMLHASH__
+#define __DRM_XMLHASH__
+
+#include <oemxmlhash.h>
+
+ENTER_PK_NAMESPACE;
+
+DRM_API DRM_RESULT DRM_CALL DRM_XMLHASH_Update(
+    __in DRM_XML_HASH_CONTEXT *f_poContext,
+    __in const DRM_XML_HASH_SIG *f_poSig,
+    __in const DRM_CONST_STRING *f_pdstrXML,
+    __in const DRM_CONST_STRING *f_pdstrNode,
+    __in const DRM_CONST_STRING *f_pdstrNodeData );
+
+DRM_API DRM_RESULT DRM_CALL DRM_XMLHASH_Lookup(
+    __in DRM_XML_HASH_CONTEXT *f_poContext,
+    __in const DRM_XML_HASH_SIG *f_poSig,
+    __in const DRM_CONST_STRING *f_pdstrXML,
+    __in const DRM_CONST_STRING *f_pdstrTag,
+    __out DRM_CONST_STRING *f_pdstrNodeOut,
+    __out DRM_CONST_STRING *f_pdstrNodeDataOut );
+
+DRM_API DRM_RESULT DRM_CALL DRM_XMLHASH_CalcParamSig(
+    __in const DRM_XML_HASH_CONTEXT *f_poContext,
+    __in const DRM_CONST_STRING *f_pdstrXML,
+    __in const DRM_CONST_STRING *f_pdstrTag,
+    __in const DRM_DWORD f_iNode,
+    __in const DRM_DWORD f_iLayer,
+    __out DRM_XML_HASH_SIG *f_poSig );
+
+DRM_API DRM_RESULT DRM_CALL DRM_XMLHASH_GetContext(
+    __out DRM_XML_HASH_CONTEXT **f_ppoContext );
+
+DRM_API DRM_RESULT DRM_CALL DRM_XMLHASH_Start( DRM_VOID );
+
+DRM_API DRM_RESULT DRM_CALL DRM_XMLHASH_Stop( DRM_VOID );
+
+DRM_API DRM_RESULT DRM_CALL DRM_XMLHASH_Init( DRM_VOID );
+
+DRM_API DRM_RESULT DRM_CALL DRM_XMLHASH_UnInit( DRM_VOID );
+
+DRM_API DRM_RESULT DRM_CALL DRM_XMLHASH_Cleanup( DRM_VOID );
+
+EXIT_PK_NAMESPACE;
+
+#endif /* __DRM_XMLHASH__ */
+
diff --git a/prebuilt-v4.4/noarch/include/drmxmlparser.h b/prebuilt-v4.4/noarch/include/drmxmlparser.h
new file mode 100644
index 0000000..ea40c2b
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmxmlparser.h
@@ -0,0 +1,179 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+
+#ifndef __DRMXMLPARSER_H__
+#define __DRMXMLPARSER_H__
+
+#include <drmtypes.h>
+#include <oemcryptoctx.h>
+#include <oemsha1.h>
+
+ENTER_PK_NAMESPACE;
+
+/*
+** UNICODE
+*/
+
+DRM_API DRM_RESULT DRM_CALL DRM_XML_GetNode(
+    __in      const DRM_CONST_STRING *f_pdstrXML,
+    __in      const DRM_CONST_STRING *f_pdstrTag,
+    __in_opt  const DRM_CONST_STRING *f_pdstrAttrName,
+    __in_opt  const DRM_CONST_STRING *f_pdstrAttrValue,
+    __in      const DRM_DWORD         f_iNode,
+    __out_opt       DRM_CONST_STRING *f_pdstrXMLNode,
+    __out_opt       DRM_CONST_STRING *f_pdstrXMLNodeData );
+
+#define DRM_XML_HASH_INCLUDE_TAGS   TRUE
+#define DRM_XML_HASH_EXCLUDE_TAGS   FALSE
+
+DRM_API DRM_RESULT DRM_CALL DRM_XML_GetNodeAttribute(
+    __in  const DRM_CONST_STRING *f_pdstrXMLNode,
+    __in  const DRM_CONST_STRING *f_pdstrAttrName,
+    __inout     DRM_CONST_STRING *f_pdstrAttrValue );
+
+DRM_API DRM_RESULT DRM_CALL DRM_XML_GetNodeCData(
+    __in  const DRM_CONST_STRING *f_pdstrXMLNode,
+    __out       DRM_CONST_STRING *f_pdstrCData );
+
+DRM_API DRM_RESULT DRM_CALL DRM_XML_GetSubNode(
+    __in      const DRM_CONST_STRING *f_pdstrXML,
+    __in      const DRM_CONST_STRING *f_pdstrTag,
+    __in_opt  const DRM_CONST_STRING *f_pdstrAttrName,
+    __in_opt  const DRM_CONST_STRING *f_pdstrAttrValue,
+    __in      const DRM_DWORD         f_iNode,
+    __inout_opt     DRM_CONST_STRING *f_pdstrXMLNode,
+    __inout_opt     DRM_CONST_STRING *f_pdstrXMLNodeData,
+    __in            DRM_DWORD         f_iLayer );
+
+DRM_API DRM_RESULT DRM_CALL DRM_XML_GetAndVerifyKeyedHashSubNode(
+    __in                     const DRM_CONST_STRING         *f_pdstrXML,
+    __in                     const DRM_CONST_STRING         *f_pdstrTag,
+    __in                     const DRM_CONST_STRING         *f_pdstrAttrName,
+    __in                     const DRM_CONST_STRING         *f_pdstrAttrValue,
+    __in                     const DRM_DWORD                 f_iNode,
+    __in                           OEM_SHA1_HMAC_CONTEXT    *f_pcontextHMAC,
+    __in_ecount(f_cbKeyHash) const DRM_BYTE                 *f_pbKeyHash,
+    __in                           DRM_DWORD                 f_cbKeyHash,
+    __in                           DRM_BOOL                  f_fIncludeTag,
+    __in                     const DRM_CONST_STRING         *f_pdstrB64Signature,
+    __out                          DRM_CONST_STRING         *f_pdstrNode,
+    __out                          DRM_CONST_STRING         *f_pdstrNodeData,
+    __in                           DRM_DWORD                 f_iLayer );
+
+DRM_API DRM_RESULT DRM_CALL DRM_XML_GetSubNodeByPath(
+    __in      const DRM_CONST_STRING *f_pdstrXML,
+    __in      const DRM_CONST_STRING *f_pdstrXMLNode,
+    __in_opt  const DRM_CONST_STRING *f_pdstrAttrName,
+    __in_opt  const DRM_CONST_STRING *f_pdstrAttrValue,
+    __out_opt       DRM_CONST_STRING *f_pdstrXMLNodeOut,
+    __out_opt       DRM_CONST_STRING *f_pdstrXMLDataOut,
+    __in            DRM_WCHAR         f_chSeparator );
+
+
+DRM_API DRM_RESULT DRM_CALL DRM_XML_EnumNextNode(
+    __in  const DRM_CONST_STRING *f_pdstrXML,
+    __inout     DRM_CONST_STRING *f_pdstrTag,
+    __out_opt   DRM_CONST_STRING *f_pdstrXMLNode,
+    __out_opt   DRM_CONST_STRING *f_pdstrXMLNodeData,
+    __out_opt   DRM_CONST_STRING *f_pdstr1stAttrName,
+    __out_opt   DRM_CONST_STRING *f_pdstr1stAttrValue,
+    __out       DRM_BOOL         *f_pfIsLeafNode );
+
+DRM_API DRM_RESULT DRM_CALL DRM_XML_EnumNextSubNode(
+    __in    const DRM_CONST_STRING *f_pdstrXML,
+    __inout       DRM_CONST_STRING *f_pdstrTag,
+    __inout_opt   DRM_CONST_STRING *f_pdstrXMLNode,
+    __inout_opt   DRM_CONST_STRING *f_pdstrXMLNodeData,
+    __inout_opt   DRM_CONST_STRING *f_pdstr1stAttrName,
+    __inout_opt   DRM_CONST_STRING *f_pdstr1stAttrValue,
+    __inout       DRM_BOOL         *f_pfIsLeafNode,
+    __in          DRM_DWORD         f_iLayer );
+
+/*
+** ANSI
+*/
+
+DRM_API DRM_RESULT DRM_CALL DRM_XML_GetNodeA(
+    __in_ecount( f_padstrXML->m_ich + f_padstrXML->m_cch ) const DRM_CHAR              *f_pszBase,
+    __in                                                   const DRM_SUBSTRING         *f_padstrXML,
+    __in                                                   const DRM_ANSI_CONST_STRING *f_padstrTag,
+    __in_opt                                               const DRM_ANSI_CONST_STRING *f_padstrAttrName,
+    __in_opt                                               const DRM_ANSI_CONST_STRING *f_padstrAttrValue,
+    __in                                                   const DRM_DWORD              f_iNode,
+    __out_opt                                                    DRM_SUBSTRING         *f_psubstrXMLNode,
+    __out_opt                                                    DRM_SUBSTRING         *f_psubstrXMLNodeData );
+
+DRM_API DRM_RESULT DRM_CALL DRM_XML_GetSubNodeA(
+    __in_ecount( f_padstrXML->m_ich + f_padstrXML->m_cch ) const DRM_CHAR              *f_pszBase,
+    __in                                                   const DRM_SUBSTRING         *f_padstrXML,
+    __in                                                   const DRM_ANSI_CONST_STRING *f_padstrTag,
+    __in_opt                                               const DRM_ANSI_CONST_STRING *f_padstrAttrName,
+    __in_opt                                               const DRM_ANSI_CONST_STRING *f_padstrAttrValue,
+    __in                                                   const DRM_DWORD              f_iNode,
+    __out_opt                                                    DRM_SUBSTRING         *f_psubstrXMLNode,
+    __out_opt                                                    DRM_SUBSTRING         *f_psubstrXMLNodeData,
+    __in                                                         DRM_DWORD              f_iLayer );
+
+DRM_API DRM_RESULT DRM_CALL DRM_XML_GetNodeAttributeA(
+    __in_ecount( f_padstrXML->m_ich + f_padstrXML->m_cch ) const DRM_CHAR              *f_pszBase,
+    __in                                                   const DRM_SUBSTRING         *f_padstrXML,
+    __in                                                   const DRM_ANSI_CONST_STRING *f_padstrAttrName,
+    __inout                                                      DRM_SUBSTRING         *f_psubstrAttrValue );
+
+DRM_API DRM_RESULT DRM_CALL DRM_XML_GetNodeCDataA(
+    __in_ecount( f_pdasstrXML->m_ich + f_pdasstrXML->m_cch ) const DRM_CHAR      *f_pszXMLBase,
+    __in                                                     const DRM_SUBSTRING *f_pdasstrXML,
+    __out                                                          DRM_SUBSTRING *f_pdasstrCData );
+
+DRM_API DRM_RESULT DRM_CALL DRM_XML_GetSubNodeByPathA(
+    __in_ecount( f_pdasstrXML->m_ich + f_pdasstrXML->m_cch ) const DRM_CHAR              *f_pszBase,
+    __in                                                     const DRM_SUBSTRING         *f_pdasstrXML,
+    __in                                                     const DRM_ANSI_CONST_STRING *f_pdastrNodePath,
+    __in_opt                                                 const DRM_ANSI_CONST_STRING *f_pdastrAttrName,
+    __in_opt                                                 const DRM_ANSI_CONST_STRING *f_pdastrAttrValue,
+    __out_opt                                                      DRM_SUBSTRING         *f_pdasstrXMLNodeOut,
+    __out_opt                                                      DRM_SUBSTRING         *f_pdasstrXMLDataOut,
+    __in                                                           DRM_CHAR               f_chSeparator );
+
+DRM_API DRM_RESULT DRM_CALL DRM_XML_EnumNextNodeA(
+    __in_ecount( f_pdasstrXML->m_ich + f_pdasstrXML->m_cch ) const DRM_CHAR      *f_pszBase,
+    __in                                                     const DRM_SUBSTRING *f_pdasstrXML,
+    __in                                                     const DRM_DWORD      f_iNode,
+    __out                                                          DRM_SUBSTRING *f_pdasstrTag,
+    __inout_opt                                                    DRM_SUBSTRING *f_pdasstrNode,
+    __inout_opt                                                    DRM_SUBSTRING *f_pdasstrNodeData,
+    __inout_opt                                                    DRM_SUBSTRING *f_pdasstr1stAttrName,
+    __inout_opt                                                    DRM_SUBSTRING *f_pdasstr1stAttrValue );
+
+DRM_API DRM_RESULT DRM_CALL DRM_XML_CountMatchingNodesA(
+    __in_ecount( f_pdasstrXML->m_ich + f_pdasstrXML->m_cch ) const DRM_CHAR              *f_pszBase,
+    __in                                                     const DRM_SUBSTRING         *f_pdasstrXML,
+    __in_opt                                                 const DRM_ANSI_CONST_STRING *f_pdasstrTag,
+    __in_opt                                                 const DRM_ANSI_CONST_STRING *f_pdasstr1stAttrName,
+    __in_opt                                                 const DRM_ANSI_CONST_STRING *f_pdasstr1stAttrValue,
+    __out                                                          DRM_DWORD             *f_cMatchingNodes );
+
+DRM_API DRM_BOOL DRM_CALL DRM_XML_Validate(
+    __in const DRM_CONST_STRING *f_pdstrXML );
+
+DRM_API DRM_RESULT DRM_CALL DRM_XML_TranslateXMLError(
+    __in DRM_RESULT f_drXML );
+
+DRM_API DRM_RESULT DRM_CALL DRM_XMU_MatchNodeFromTemplate(
+    __in  const   DRM_CONST_STRING    *f_pdstrXmlNodeList,
+    __in  const   DRM_CONST_STRING    *f_pdstrXmlTemplate,
+    __in          DRM_BOOL             f_fAttributeMatch,
+    __out         DRM_BOOL            *f_pfMatch );
+
+EXIT_PK_NAMESPACE;
+
+#endif      /* __DRMXMLPARSER_H__ */
+
+
+
diff --git a/prebuilt-v4.4/noarch/include/drmxmlparserconstants.h b/prebuilt-v4.4/noarch/include/drmxmlparserconstants.h
new file mode 100644
index 0000000..ef0f9f7
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmxmlparserconstants.h
@@ -0,0 +1,24 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __DRMXMLPARSERCONSTANTS_H__
+#define __DRMXMLPARSERCONSTANTS_H__
+
+#include <drmtypes.h>
+
+ENTER_PK_NAMESPACE;
+
+    extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING  g_dastrTagCDATA;
+    extern DRM_GLOBAL_CONST  DRM_CONST_STRING       g_dstrTagCDATA;
+    extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING  g_dastrTagCDATAOpenBracket;
+    extern DRM_GLOBAL_CONST  DRM_CONST_STRING       g_dstrTagCDATAOpenBracket;
+
+EXIT_PK_NAMESPACE;
+
+#endif /* __DRMXMLPARSERCONSTANTS_H__ */
+
diff --git a/prebuilt-v4.4/noarch/include/drmxmlsig.h b/prebuilt-v4.4/noarch/include/drmxmlsig.h
new file mode 100644
index 0000000..834a337
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmxmlsig.h
@@ -0,0 +1,235 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __DRM_XML_SIG_H
+#define __DRM_XML_SIG_H
+
+#include <drmxmlbuildera.h>
+#include <oemeccp256.h>
+#include <drmsecurecoretypes.h>
+
+ENTER_PK_NAMESPACE;
+
+/*
+** An AES key combo. The first 16 bytes forms an 128 bits initialization vector.
+** The second 16 bytes forms a random 128 bits AES key.
+*/
+#define DRM_XML_AES_KEY_SIZE  ( DRM_AES_KEYSIZE_128 * 2 )
+
+/*
+***************************************************************************
+**                        XML Key info
+***************************************************************************
+*/
+
+/*
+** The enumeration define type of RSA public key to be used.
+*/
+typedef enum __tag_DRM_XML_KEYINFO_TYPE
+{
+    /*
+    ** Invalid Key info: not initialized or not consistent
+    */
+    DRM_XML_KEYINFO_INVALID,
+
+    /*
+    ** Key info that contains a public key only
+    */
+    DRM_XML_KEYINFO_SIMPLE,
+
+    /*
+    ** Key info that contains symmetric key
+    ** encrypted with a public key;
+    ** XML presentation will have <EncryptedKey> tag
+    */
+    DRM_XML_KEYINFO_ENCRYPTED
+
+} DRM_XML_KEYINFO_TYPE;
+
+/*
+** The enumeration define type of RSA public key to be used.
+*/
+typedef enum __tag_DRM_XML_ECC256_KEY_FORMAT
+{
+    /* Invalid key.  */
+    DRM_XML_ECC256_INVALID_KEY,
+
+    /*
+    ** Full ECC-256 public key.
+    */
+    DRM_XML_ECC256_PUBLIC_KEY_DATA,
+
+    /*
+    ** ID of a pre-shared ECC-256 Public key:
+    ** It means the ECC-256 public key in the <KeyInfo> segment
+    ** only contains a key ID. Parties that see the key ID
+    ** should understand the actual ECC-256 public key represented
+    ** by the key ID.
+    */
+    DRM_XML_ECC256_SERVER_PUBLIC_KEY_ID,
+
+    DRM_XML_ECC256_CLIENT_PUBLIC_KEY_ID,
+
+    DRM_XML_ECC256_METERING_PUBLIC_KEY_ID,
+
+    DRM_XML_ECC256_SECURESTOP_PUBLIC_KEY_ID
+} DRM_XML_ECC256_KEY_FORMAT;
+
+/*
+** Union used to store either a clear or an ECC-256 encrypted AES key.
+** Assumes the size of the ciphered version is equal or bigger
+** than the size clear version (plus the IV). In other words, the size of
+** the ciphered version determines the size of the union.
+*/
+typedef union
+{
+    /* A clear AES key combo. */
+    struct
+    {
+        /* Randomly generated IV */
+        DRM_BYTE m_rgbIV[ DRM_AES_KEYSIZE_128 ];
+
+        /* AES key, padded with random bytes */
+        DRM_BYTE m_rgbPaddedAESKey[ DRM_XML_AES_KEY_SIZE ];
+    } m_oClearAESKey;
+
+    /* An ECC-256 encrypted AES key BLOB */
+    DRM_BYTE m_rgbCipherAESKey[ ECC_P256_CIPHERTEXT_SIZE_IN_BYTES ];
+} _AES_KEY;
+
+/*
+** Structure to contain information of a key in the <KeyInfo> XML segment.
+*/
+typedef struct
+{
+    /*
+    ** KeyInfo type, can be simple or complex
+    ** i.e. with another key encrypted inside
+    */
+    DRM_XML_KEYINFO_TYPE m_eKeyInfoType;
+
+    /* AES key */
+    _AES_KEY m_oAESKey;
+
+    /*
+    ** The format of the ECC-256 public key that is used to encrypt the AES key.
+    ** If the values is DRM_XML_ECC256_PUBLIC_KEY_ID, a pre-shared ECC-256 public key
+    ** will be used to decrypte the AES key.
+    ** If the valus is DRM_XML_ECC-256_PUBLIC_KEY_DATA, a full ECC-256 public key
+    ** stored in m_oECC256PubKey will be used to decrypt the AES key.
+    */
+    DRM_XML_ECC256_KEY_FORMAT m_eKeyFormat;
+
+    /*
+    ** If m_eKeyFormat is DRM_XML_ECC256_PUBLIC_KEY_DATA, m_oECC256PubKey
+    ** contains a full ECC-256 public key used to decrypt the AES key, otherwise
+    ** this field is not used.
+    */
+    PUBKEY_P256 m_oECC256PubKey;
+} DRM_XML_KEY;
+
+#define EMPTY_XML_KEY { DRM_XML_KEYINFO_INVALID, { 0 }, DRM_XML_ECC256_INVALID_KEY, { 0 } }
+
+typedef enum __tagDRM_XMLSIG_ADDITIONAL_SIGNATURE
+{
+    DRM_XMLSIG_ADDITIONAL_SIGNATURE_NONE,
+    DRM_XMLSIG_ADDITIONAL_SIGNATURE_SECURESTOP2,
+} DRM_XMLSIG_ADDITIONAL_SIGNATURE;
+
+#define DRM_XMLSIG_ADDITIONAL_SIGNATURE_IS_VALID( __bitmask )  ( ( ( __bitmask ) & ( ~DRM_XMLSIG_ADDITIONAL_SIGNATURE_ALL ) ) == 0 )
+
+/*
+***************************************************************************
+**                        KeyInfo
+***************************************************************************
+*/
+DRM_API DRM_RESULT DRM_CALL DRM_XMLSIG_GetSimpleECC256KeyInfoNodeCharCount(
+    __in  const DRM_XML_ECC256_KEY_FORMAT f_eECC256KeyFormat,
+    __out       DRM_DWORD                *f_pcchSize );
+
+DRM_API DRM_RESULT DRM_CALL DRM_XMLSIG_BuildSimpleECC256KeyInfoNode(
+    __inout       _XMBContextA             *f_poXMLContextA,
+    __in    const PUBKEY_P256              *f_poECC256PubKey,
+    __in    const DRM_XML_ECC256_KEY_FORMAT f_eECC256KeyFormat );
+
+DRM_API DRM_RESULT DRM_CALL DRM_XMLSIG_ExtractSimpleECC256Key(
+    __in_ecount( f_pdasstrXML->m_ich + f_pdasstrXML->m_cch ) const DRM_CHAR      *f_pszBase,
+    __in                                                     const DRM_SUBSTRING *f_pdasstrXML,
+    __out                                                          PUBKEY_P256   *f_poECC256PubKey );
+
+DRM_API DRM_RESULT DRM_CALL DRM_XMLSIG_GetEncryptedKeyInfoNodeCharCount(
+    __in    const DRM_XML_KEY *f_poXMLKey,
+    __inout       DRM_DWORD   *f_pcchSize );
+
+DRM_API DRM_RESULT DRM_CALL DRM_XMLSIG_BuildEncryptedKeyInfoNode(
+    __inout       _XMBContextA *f_poXMLContextA,
+    __in    const DRM_XML_KEY  *f_poXMLKey );
+
+/*
+***************************************************************************
+**                        XML Signature
+***************************************************************************
+*/
+DRM_API DRM_RESULT DRM_CALL DRM_XMLSIG_GetSignatureNodeCharCount(
+    __in    DRM_XMLSIG_ADDITIONAL_SIGNATURE  f_eAdditionalSignature,
+    __inout DRM_DWORD                       *f_pcchSize );
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_XMLSIG_BuildECC256PublicKeyInfoNode(
+    __inout       _XMBContextA *f_poXMLContextA,
+    __in    const PUBKEY_P256  *f_poECC256PubKey );
+
+DRM_API DRM_RESULT DRM_CALL DRM_XMLSIG_BuildSignatureNode(
+    __in                                                              DRM_XMLSIG_ADDITIONAL_SIGNATURE    f_eAdditionalSignature,
+    __in                                                              DRM_DWORD                          f_cbAdditionalSignatureData,
+    __in_bcount_opt( f_cbAdditionalSignatureData )              const DRM_BYTE                          *f_pbAdditionalSignatureData,
+    __inout                                                           _XMBContextA                      *f_poXMLContextA,
+    __inout                                                           DRM_SECURECORE_CONTEXT            *f_pSecureCoreCtx,
+    __in_ecount( f_pdasstrData->m_ich + f_pdasstrData->m_cch )  const DRM_CHAR                          *f_pszBase,
+    __in                                                        const DRM_SUBSTRING                     *f_pdasstrData,
+    __in_ecount( 1 )                                            const PUBKEY_P256                       *f_poECC256SignPubKey );
+
+DRM_API DRM_RESULT DRM_CALL DRM_XMLSIG_VerifySignature(
+    __in_ecount(f_pdasstrData->m_ich+f_pdasstrData->m_cch)           const DRM_CHAR             *f_pszDataBase,
+    __in                                                             const DRM_SUBSTRING        *f_pdasstrData,
+    __in_ecount(f_pdasstrSignature->m_ich+f_pdasstrSignature->m_cch) const DRM_CHAR             *f_pszSignatureBase,
+    __in                                                             const DRM_SUBSTRING        *f_pdasstrSignature,
+    __in                                                             const PUBKEY_P256          *f_poECC256PubKey,
+    __inout                                                                DRM_CRYPTO_CONTEXT   *f_pCryptoCtx ) DRM_NO_INLINE_ATTRIBUTE;
+
+/*
+***************************************************************************
+**                        XML Encryption
+***************************************************************************
+*/
+DRM_API DRM_RESULT DRM_CALL DRM_XMLSIG_GetEncryptedDataNodeCharCount(
+    __in    const DRM_XML_KEY *f_poXMLKey,
+    __in    const DRM_DWORD    f_cbData,
+    __out         DRM_DWORD   *f_pcchSize );
+
+DRM_API DRM_RESULT DRM_CALL DRM_XMLSIG_BuildEncryptedDataNode(
+    __inout       _XMBContextA  *f_poXMLContextA,
+    __in    const DRM_XML_KEY   *f_poXMLKey,
+    __in    const DRM_DWORD      f_cbData,
+    __out         DRM_SUBSTRING *f_pdasstrEncryptedData );
+
+DRM_API DRM_RESULT DRM_CALL DRM_XMLSIG_BuildEncryptedDataNode2(
+    __inout       _XMBContextA              *f_poXMLContextA,
+    __in    const DRM_XML_KEY               *f_poXMLKey,
+    __in    const DRM_ANSI_STRING           *f_pdastrData,
+    __out         DRM_SUBSTRING             *f_pdasstrEncryptedData );
+
+DRM_API DRM_RESULT DRM_CALL DRM_XMLSIG_ExtractCipherData(
+    __inout_ecount(f_pdasstrXML->m_ich+f_pdasstrXML->m_cch)       DRM_CHAR       *f_pszBase,
+    __in                                                    const DRM_SUBSTRING  *f_pdasstrXML,
+    __deref_out_bcount( *f_pcbCipherData )                        DRM_BYTE      **f_ppbCipherData,
+    __out                                                         DRM_DWORD      *f_pcbCipherData,
+    __out_opt                                                     DRM_SUBSTRING  *f_pdasstrCipherData );
+
+EXIT_PK_NAMESPACE;
+
+#endif /* __DRM_XML_SIG_H */
diff --git a/prebuilt-v4.4/noarch/include/drmxmlsigconstants.h b/prebuilt-v4.4/noarch/include/drmxmlsigconstants.h
new file mode 100644
index 0000000..8ace70e
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmxmlsigconstants.h
@@ -0,0 +1,168 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __DRM_XML_SIG_CONSTANTS_H
+#define __DRM_XML_SIG_CONSTANTS_H
+
+#include <oemeccp256.h>
+
+ENTER_PK_NAMESPACE;
+
+/* Well known WMRM ECC-256 public key */
+extern DRM_GLOBAL_CONST  PUBKEY_P256 g_oWMRMECC256PubKey;
+
+/*
+** -------------------------------------------------------------
+** XML strings used in the construction of signature XML segment
+** -------------------------------------------------------------
+*/
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrSigRootTag;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrSigSignedInfoTag;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrSigCanonicalizationMethodTag;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrSigSignatureMethodTag;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrSigReferenceTag;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrSigDigestMethodTag;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrSigDigestValueTag;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrSigSignatureValueTag;
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrSigSignatureValueSecureStop2Tag;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrSigKeyInfoTag;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrSigKeyValueTag;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrSigECCKeyValueTag;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrSigPublicKeyTag;
+
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrSigRootAttribName;
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrSigRootAttribValue;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrSigSignedInfoAttribName;
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrSigSignedInfoAttribValue;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrSigCanonicalizationMethodAttribName;
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrSigCanonicalizationMethodAttribValue;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrSigSignatureMethodAttribName;
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrSigSignatureMethodAttribValue;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrSigDigestMethodAttribName;
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrSigDigestMethodAttribValue;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrSigKeyInfoAttribName;
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrSigKeyInfoAttribValue;
+
+
+
+/*
+** -----------------------------------------------------------------------
+** XML strings used in the construction of XML encrypted data segment
+** -----------------------------------------------------------------------
+*/
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrSigEncryptedDataTag;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrSigEncryptionMethodTag;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrSigEncryptedKeyTag;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrSigCipherDataTag;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrSigCipherValueTag;
+
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrSigEncryptedDataAttrib1Name;
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrSigEncryptedDataAttrib1Value;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrSigEncryptedDataAttrib2Name;
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrSigEncryptedDataAttrib2Value;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrSigEncryptedDataAttrib3Name;
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrSigEncryptedDataAttrib3Value;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrSigEncryptionMethodAttrib1Name;
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrSigEncryptionMethodAttrib1Value;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrSigEncryptionMethodAttrib2Name;
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrSigEncryptionMethodAttrib2Value;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrSigKeyInfoAttrib1Name;
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrSigKeyInfoAttrib1Value;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrSigKeyNameTag;
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrSigKeyInfoKeyName1;
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrSigKeyInfoKeyName2;
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrSigKeyInfoKeyName3;
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrSigKeyInfoKeyName4;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrKeyInfoKeyNamePath;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrSigReferenceAttribName;
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrSigReferenceAttribValue;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrSigEncryptedKeyAttribName;
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrSigEncryptedKeyAttribValue;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrRSAPrefixMSLP;
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrRSAURIMSLP;
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrTagRSAKeyPair;
+
+/*
+** --------------------------------------------------------
+** XML strings used in the parsing of signature XML segment
+** --------------------------------------------------------
+*/
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrSigSignedInfoPath;
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrSigSignatureValuePath;
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrSigHashPath;
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrSigPublicKeyPath;
+extern DRM_GLOBAL_CONST  DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrMeteringMeterCertTag;
+extern DRM_GLOBAL_CONST  DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrMeterDataSignaturePath;
+extern DRM_GLOBAL_CONST  DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrMeterDataMeteringResponsePath;
+extern DRM_GLOBAL_CONST  DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrMeterDataCustomDataPath;
+extern DRM_GLOBAL_CONST  DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrMeterCertSignaturePath;
+extern DRM_GLOBAL_CONST  DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrMeterCertMeteringCertificateResponsePath;
+extern DRM_GLOBAL_CONST  DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrMeterCertCustomDataPath;
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrDomJoinCustomDataPath;
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrDomJoinDomainPath;
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrDomJoinSignaturePath;
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrDomJoinSigningCertTag;
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrDomLeaveCustomDataPath;
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrDomLeaveDomainPath;
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrDomLeaveSignaturePath;
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrLicAcqCustomDataPath;
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrLicLicenseResponsePath;
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrLicSignaturePath;
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrLicAcqSigningCertTag;
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrLicAckCustomDataPath;
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrLicAcqLAckPath;
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrLicAckSignaturePath;
+
+
+/*
+** -------------------------------------------------------------
+** XML strings used in the parsing of XML encrypted data segment
+** -------------------------------------------------------------
+*/
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrSigKeyInfoPath;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrSigEncryptedKeyPath;
+
+extern DRM_GLOBAL_CONST  DRM_ANSI_CONST_STRING g_dastrSigCipherValuePath;
+
+EXIT_PK_NAMESPACE;
+
+#endif /* __DRM_XML_SIG_CONSTANTS_H */
+
diff --git a/prebuilt-v4.4/noarch/include/drmxmrconstants.h b/prebuilt-v4.4/noarch/include/drmxmrconstants.h
new file mode 100644
index 0000000..ac33f04
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmxmrconstants.h
@@ -0,0 +1,214 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __DRM_XMR_CONSTANTS_H__
+#define __DRM_XMR_CONSTANTS_H__
+
+ENTER_PK_NAMESPACE;
+
+/*
+** constants, enums and data types
+*/
+#define XMR_UNLIMITED             DRM_MAX_UNSIGNED_TYPE( DRM_DWORD )
+
+#define XMR_AES_OMAC_SIGNATURE_LENGTH     16
+
+#define XMR_SOURCEID_MAXCOUNT   100
+
+#define XMR_RID_OFFSET           ( sizeof( DRM_DWORD ) * 2 )
+#define XMR_HEADER_LENGTH        ( XMR_RID_OFFSET + sizeof( DRM_ID ) )
+#define XMR_BASE_OBJECT_LENGTH   ( sizeof( DRM_WORD ) * 2  + sizeof( DRM_DWORD ) )
+
+typedef enum __tagXMR_SOURCEID
+{
+    XMR_SOURCEID_NONE          = 0,
+    XMR_SOURCEID_MACROVISION   = 1,
+    XMR_SOURCEID_CGMSA         = 2,
+    XMR_SOURCEID_WSS           = 3,
+    XMR_SOURCEID_DIGITAL_CABLE = 4,
+    XMR_SOURCEID_ATSC          = 5,
+    XMR_SOURCEID_PDRM          = 260,
+    XMR_SOURCEID_LEGACY_DVR    = 261,
+    XMR_SOURCEID_V1            = 262,
+} XMR_SOURCEID;
+
+typedef enum __tagXMR_VERSION
+{
+    XMR_VERSION_INVALID  = 0x0000,
+    XMR_VERSION_1        = 0x0001,
+    XMR_VERSION_2        = 0x0002,
+    XMR_VERSION_3        = 0x0003,
+
+    XMR_VERSION_MAX      = XMR_VERSION_3,
+} XMR_VERSION;
+
+typedef enum __tagXMR_OBJECT_FLAGS
+{
+    XMR_FLAGS_NONE                  = 0x0000,
+    XMR_FLAGS_MUST_UNDERSTAND       = 0x0001,
+    XMR_FLAGS_CONTAINER             = 0x0002,
+    XMR_FLAGS_ALLOW_EXTERNAL_PARSE  = 0x0004,
+    XMR_FLAGS_BEST_EFFORT           = 0x0008,
+    XMR_FLAGS_HAS_SECURE_STATE      = 0x0010
+} XMR_OBJECT_FLAGS;
+
+typedef enum __tagXMR_SETTINGS_FLAGS
+{
+    XMR_SETTINGS_FLAG_CANNOT_PERSIST    = 0x0001
+} XMR_SETTINGS_FLAGS;
+
+/*
+** Symmetric encryption types used for content encryption
+*/
+typedef enum __tagXMR_SYMMETRIC_ENCRYPTION_TYPE
+{
+    XMR_SYMMETRIC_ENCRYPTION_TYPE_INVALID      = 0x0000,
+    XMR_SYMMETRIC_ENCRYPTION_TYPE_AES_128_CTR  = 0x0001,
+    XMR_SYMMETRIC_ENCRYPTION_TYPE_RC4_CIPHER   = 0x0002,
+    XMR_SYMMETRIC_ENCRYPTION_TYPE_AES_128_ECB  = 0x0003,
+    XMR_SYMMETRIC_ENCRYPTION_TYPE_COCKTAIL     = 0x0004,
+    XMR_SYMMETRIC_ENCRYPTION_TYPE_AES_128_CBC  = 0x0005,
+} XMR_SYMMETRIC_ENCRYPTION_TYPE;
+
+/*
+** Asymmetric encryption types used for encrypting the content key
+*/
+typedef enum __tagXMR_ASYMMETRIC_ENCRYPTION_TYPE
+{
+    XMR_ASYMMETRIC_ENCRYPTION_TYPE_INVALID                     = 0x0000,
+    XMR_ASYMMETRIC_ENCRYPTION_TYPE_RSA_1024                    = 0x0001,
+    XMR_ASYMMETRIC_ENCRYPTION_TYPE_CHAINED_LICENSE             = 0x0002,
+    XMR_ASYMMETRIC_ENCRYPTION_TYPE_ECC_256                     = 0x0003,
+    XMR_ASYMMETRIC_ENCRYPTION_TYPE_ECC_256_WITH_KZ             = 0x0004,
+    XMR_ASYMMETRIC_ENCRYPTION_TYPE_TEE_TRANSIENT               = 0x0005,
+    XMR_ASYMMETRIC_ENCRYPTION_TYPE_ECC_256_VIA_SYMMETRIC       = 0x0006
+} XMR_ASYMMETRIC_ENCRYPTION_TYPE;
+
+/*
+** Symmetric encryption types used for encrypting the content key (optimized)
+*/
+typedef enum __tagXMR_SYMMETRIC_KEY_ENCRYPTION_TYPE
+{
+    XMR_SYMMETRIC_KEY_ENCRYPTION_TYPE_INVALID          = 0x0000,
+    XMR_SYMMETRIC_KEY_ENCRYPTION_TYPE_AES_128_ECB      = 0x0001,
+    XMR_SYMMETRIC_KEY_ENCRYPTION_TYPE_AES_128_ECB_SLK  = 0x0002
+} XMR_SYMMETRIC_KEY_ENCRYPTION_TYPE;
+
+typedef enum __tagXMR_ECC_CURVE_TYPE
+{
+    XMR_ECC_CURVE_TYPE_INVALID                = 0x0000,
+    XMR_ECC_CURVE_TYPE_P256                   = 0x0001
+} XMR_ECC_CURVE_TYPE;
+
+typedef enum __tagXMR_SIGNATURE_TYPE
+{
+    XMR_SIGNATURE_TYPE_INVALID                = 0x0000,
+    XMR_SIGNATURE_TYPE_AES_128_OMAC           = 0x0001,
+    XMR_SIGNATURE_TYPE_SHA_256_HMAC           = 0x0002
+} XMR_SIGNATURE_TYPE;
+
+typedef enum __tagXMR_GLOBAL_RIGHTS_SETTINGS
+{
+    XMR_RIGHTS_CANNOT_PERSIST                 = 0x001,
+    XMR_RIGHTS_ALLOW_BACKUP_RESTORE           = 0x004,
+    XMR_RIGHTS_COLLABORATIVE_PLAY             = 0x008,
+    XMR_RIGHTS_BASE_LICENSE                   = 0x010,
+                                             /* 0x020 was previously used by THUMBNAIL right in Vista/Polaris and shouldn't be used */
+    XMR_RIGHTS_CANNOT_BIND_LICENSE            = 0x040,
+    XMR_RIGHTS_TEMP_STORE_ONLY                = 0x080,
+} XMR_GLOBAL_RIGHTS_SETTINGS;
+
+typedef enum __tagXMR_EXTENSIBLE_RESTRICTON_STATE
+{
+    XMR_EXTENSIBLE_RESTRICTON_STATE_COUNT      = 0x02,
+    XMR_EXTENSIBLE_RESTRICTON_STATE_DATE       = 0x03,
+    XMR_EXTENSIBLE_RESTRICTON_STATE_BYTEARRAY  = 0x04,
+} XMR_EXTENSIBLE_RESTRICTON_STATE;
+
+typedef enum __tagXMR_EMBEDDING_BEHAVIOR
+{
+    XMR_EMBEDDING_BEHAVIOR_INVALID = 0x00,
+    XMR_EMBEDDING_BEHAVIOR_IGNORE  = 0x01,
+    XMR_EMBEDDING_BEHAVIOR_COPY    = 0x02,
+    XMR_EMBEDDING_BEHAVIOR_MOVE    = 0x03
+} XMR_EMBEDDING_BEHAVIOR;
+
+typedef enum __tagXMR_UPLINK_CHECKSUM_TYPE
+{
+    XMR_UPLINK_CHECKSUM_TYPE_XMRV1      = 0x00,
+    XMR_UPLINK_CHECKSUM_TYPE_AESOMAC1   = 0x01,
+} XMR_UPLINK_CHECKSUM_TYPE;
+
+typedef enum __tagXMR_SECURE_STOP_2_SIGNATURE_ALGORITHM
+{
+    XMR_SECURE_STOP_2_SIGNATURE_ALGORITHM_INVALID                                              = 0x00,
+
+    /*
+    ** Algorithm:
+    ** ECC256_Sign(
+    **      SigningKey = [Client Cert ECC256 Private Signing Key],
+    **      DataToSign = SHA256(
+    **          DataToHash = AESCBC_Encrypt(
+    **              EncryptionKey = xbbaEncryptedKey,
+    **              IV = KID ^ [Secure Stop Session ID],
+    **              DataToEncrypt = [Challenge's Original ECC256 Signature]
+    **          )
+    **      )
+    **  )
+    */
+    XMR_SECURE_STOP_2_SIGNATURE_ALGORITHM_ECC256_SHA256_AES128CBC_IVKIDSESSIONID_PLAINOLDSIG   = 0x01,
+} XMR_SECURE_STOP_2_SIGNATURE_ALGORITHM;
+
+/*
+** OptimizedContentKey2.wCacheKeyEncryptionAlgorithm
+*/
+typedef enum __tagXMR_OPTIMIZED_CONTENT_KEY2_CACHE_KEY_ENCRYPTION_ALGORITHM
+{
+    XMR_OPTIMIZED_CONTENT_KEY2_CACHE_KEY_ENCRYPTION_ALGORITHM_INVALID                   = 0x00,
+
+    /*
+    ** CacheKey =
+    **      XOR(
+    **          AESOMAC1(
+    **              HashingKey = First Half of ECC256_Decrypt(
+    **                  DecryptionKey = [Client Cert ECC256 Private Content Encryption Key],
+    **                  DataToDecrypt = xbbaCacheKey
+    **                  ),
+    **              DataToHash = 16 bytes all zeroes
+    **          ),
+    **          AESOMAC1(
+    **              HashingKey = Second Half of same ECC256_Decrypt
+    **              DataToHash = 16 bytes all 0xFF
+    **          )
+    **      )
+    */
+    XMR_OPTIMIZED_CONTENT_KEY2_CACHE_KEY_ENCRYPTION_ALGORITHM_ECC256_XOR_OMAC1          = 0x01,
+} XMR_OPTIMIZED_CONTENT_KEY2_CACHE_KEY_ENCRYPTION_ALGORITHM;
+
+/*
+** OptimizedContentKey2.wOriginalEccOutputEncryptionAlgorithm
+*/
+typedef enum __tagXMR_OPTIMIZED_CONTENT_KEY2_ORIGINAL_ECC_OUTPUT_ENCRYPTION_ALGORITHM
+{
+    XMR_OPTIMIZED_CONTENT_KEY2_ORIGINAL_ECC_OUTPUT_ENCRYPTION_ALGORITHM_INVALID         = 0x00,
+
+    /*
+    ** OriginalEccOutput =
+    **      AESECB_Decrypt(
+    **          DecryptionKey = CacheKey,
+    **          DataToDecrypt = xbbaOriginalEccOutput
+    **      )
+    */
+    XMR_OPTIMIZED_CONTENT_KEY2_ORIGINAL_ECC_OUTPUT_ENCRYPTION_ALGORITHM_ECB             = 0x01,
+} XMR_OPTIMIZED_CONTENT_KEY2_ORIGINAL_ECC_OUTPUT_ENCRYPTION_ALGORITHM;
+
+
+EXIT_PK_NAMESPACE;
+
+#endif  /* __DRM_XMR_CONSTANTS_H__ */
+
diff --git a/prebuilt-v4.4/noarch/include/drmxmrformat_generated.h b/prebuilt-v4.4/noarch/include/drmxmrformat_generated.h
new file mode 100644
index 0000000..96c518e
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmxmrformat_generated.h
@@ -0,0 +1,447 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+/* This source was autogenerated by xbgen.
+** DO NOT EDIT THIS SOURCE MANUALLY.
+** If changes need to be applied update the XML and regenerate this source.
+*/
+/*
+** This file defines the following generated formats
+** DRM_XMRFORMAT
+*/
+#ifndef __XMRFORMAT_H__
+#define __XMRFORMAT_H__ 1
+
+ENTER_PK_NAMESPACE;
+
+PREFAST_PUSH_DISABLE_EXPLAINED( __WARNING_POOR_DATA_ALIGNMENT_25021, "Ignore poor alignment of XBinary data structures" );
+
+#define DRM_XMRFORMAT_LEGACY_VERSION 1
+#define DRM_XMRFORMAT_CURRENT_VERSION 3
+#define DRM_XMRFORMAT_STACK_SIZE 2048
+#define DRM_XMRFORMAT_MIN_UNPACK_DIVISOR 4
+#define DRM_XMRFORMAT_MAX_UNPACK_FACTOR 4
+#define DRM_XMRFORMAT_ID_OUTER_CONTAINER 0x0001
+#define DRM_XMRFORMAT_ID_GLOBAL_POLICY_CONTAINER 0x0002
+#define DRM_XMRFORMAT_ID_INVALID_RESERVED_03 0x0003
+#define DRM_XMRFORMAT_ID_PLAYBACK_POLICY_CONTAINER 0x0004
+#define DRM_XMRFORMAT_ID_OUTPUT_PROTECTION_OBJECT 0x0005
+#define DRM_XMRFORMAT_ID_INVALID_RESERVED_06 0x0006
+#define DRM_XMRFORMAT_ID_EXPLICIT_ANALOG_VIDEO_OUTPUT_PROTECTION_CONTAINER 0x0007
+#define DRM_XMRFORMAT_ID_ANALOG_VIDEO_OUTPUT_CONFIGURATION_OBJECT 0x0008
+#define DRM_XMRFORMAT_ID_KEY_MATERIAL_CONTAINER 0x0009
+#define DRM_XMRFORMAT_ID_CONTENT_KEY_OBJECT 0x000A
+#define DRM_XMRFORMAT_ID_SIGNATURE_OBJECT 0x000B
+#define DRM_XMRFORMAT_ID_SERIAL_NUMBER_OBJECT 0x000C
+#define DRM_XMRFORMAT_ID_RIGHTS_OBJECT 0x000D
+#define DRM_XMRFORMAT_ID_INVALID_RESERVED_0E 0x000E
+#define DRM_XMRFORMAT_ID_INVALID_RESERVED_0F 0x000F
+#define DRM_XMRFORMAT_ID_INVALID_RESERVED_10 0x0010
+#define DRM_XMRFORMAT_ID_INVALID_RESERVED_11 0x0011
+#define DRM_XMRFORMAT_ID_EXPIRATION_OBJECT 0x0012
+#define DRM_XMRFORMAT_ID_ISSUEDATE_OBJECT 0x0013
+#define DRM_XMRFORMAT_ID_INVALID_RESERVED_14 0x0014
+#define DRM_XMRFORMAT_ID_INVALID_RESERVED_15 0x0015
+#define DRM_XMRFORMAT_ID_METERING_OBJECT 0x0016
+#define DRM_XMRFORMAT_ID_INVALID_RESERVED_17 0x0017
+#define DRM_XMRFORMAT_ID_INVALID_RESERVED_18 0x0018
+#define DRM_XMRFORMAT_ID_INVALID_RESERVED_19 0x0019
+#define DRM_XMRFORMAT_ID_GRACE_PERIOD_OBJECT 0x001A
+#define DRM_XMRFORMAT_ID_INVALID_RESERVED_1B 0x001B
+#define DRM_XMRFORMAT_ID_INVALID_RESERVED_1C 0x001C
+#define DRM_XMRFORMAT_ID_INVALID_RESERVED_1D 0x001D
+#define DRM_XMRFORMAT_ID_INVALID_RESERVED_1E 0x001E
+#define DRM_XMRFORMAT_ID_INVALID_RESERVED_1F 0x001F
+#define DRM_XMRFORMAT_ID_INVALID_RESERVED_20 0x0020
+#define DRM_XMRFORMAT_ID_INVALID_RESERVED_21 0x0021
+#define DRM_XMRFORMAT_ID_SOURCEID_OBJECT 0x0022
+#define DRM_XMRFORMAT_ID_INVALID_RESERVED_23 0x0023
+#define DRM_XMRFORMAT_ID_INVALID_RESERVED_24 0x0024
+#define DRM_XMRFORMAT_ID_INVALID_RESERVED_25 0x0025
+#define DRM_XMRFORMAT_ID_INVALID_RESERVED_26 0x0026
+#define DRM_XMRFORMAT_ID_INVALID_RESERVED_27 0x0027
+#define DRM_XMRFORMAT_ID_RESTRICTED_SOURCEID_OBJECT 0x0028
+#define DRM_XMRFORMAT_ID_DOMAIN_ID_OBJECT 0x0029
+#define DRM_XMRFORMAT_ID_ECC_DEVICE_KEY_OBJECT 0x002A
+#define DRM_XMRFORMAT_ID_INVALID_RESERVED_2B 0x002B
+#define DRM_XMRFORMAT_ID_POLICY_METADATA_OBJECT 0x002C
+#define DRM_XMRFORMAT_ID_OPTIMIZED_CONTENT_KEY_OBJECT 0x002D
+#define DRM_XMRFORMAT_ID_EXPLICIT_DIGITAL_AUDIO_OUTPUT_PROTECTION_CONTAINER 0x002E
+#define DRM_XMRFORMAT_ID_INVALID_RESERVED_2F 0x002F
+#define DRM_XMRFORMAT_ID_EXPIRATION_AFTER_FIRSTPLAY_OBJECT 0x0030
+#define DRM_XMRFORMAT_ID_DIGITAL_AUDIO_OUTPUT_CONFIGURATION_OBJECT 0x0031
+#define DRM_XMRFORMAT_ID_REVOCATION_INFORMATION_VERSION_2_OBJECT 0x0032
+#define DRM_XMRFORMAT_ID_EMBEDDING_BEHAVIOR_OBJECT 0x0033
+#define DRM_XMRFORMAT_ID_SECURITY_LEVEL_OBJECT 0x0034
+#define DRM_XMRFORMAT_ID_INVALID_RESERVED_35 0x0035
+#define DRM_XMRFORMAT_ID_PLAY_ENABLER_CONTAINER 0x0036
+#define DRM_XMRFORMAT_ID_MOVE_ENABLER_OBJECT 0x0037
+#define DRM_XMRFORMAT_ID_COPY_ENABLER_CONTAINER 0x0038
+#define DRM_XMRFORMAT_ID_PLAY_ENABLER_OBJECT 0x0039
+#define DRM_XMRFORMAT_ID_COPY_ENABLER_OBJECT 0x003A
+#define DRM_XMRFORMAT_ID_UPLINK_KID_2_OBJECT 0x003B
+#define DRM_XMRFORMAT_ID_COPY_POLICY_2_CONTAINER 0x003C
+#define DRM_XMRFORMAT_ID_COPYCOUNT_2_OBJECT 0x003D
+#define DRM_XMRFORMAT_ID_INVALID_RESERVED_3E 0x003E
+#define DRM_XMRFORMAT_ID_EXECUTE_POLICY_CONTAINER 0x003F
+#define DRM_XMRFORMAT_ID_INVALID_RESERVED_40 0x0040
+#define DRM_XMRFORMAT_ID_INVALID_RESERVED_41 0x0041
+#define DRM_XMRFORMAT_ID_INVALID_RESERVED_42 0x0042
+#define DRM_XMRFORMAT_ID_INVALID_RESERVED_43 0x0043
+#define DRM_XMRFORMAT_ID_INVALID_RESERVED_44 0x0044
+#define DRM_XMRFORMAT_ID_INVALID_RESERVED_45 0x0045
+#define DRM_XMRFORMAT_ID_INVALID_RESERVED_46 0x0046
+#define DRM_XMRFORMAT_ID_INVALID_RESERVED_47 0x0047
+#define DRM_XMRFORMAT_ID_INVALID_RESERVED_48 0x0048
+#define DRM_XMRFORMAT_ID_INVALID_RESERVED_49 0x0049
+#define DRM_XMRFORMAT_ID_INVALID_RESERVED_4A 0x004A
+#define DRM_XMRFORMAT_ID_INVALID_RESERVED_4B 0x004B
+#define DRM_XMRFORMAT_ID_INVALID_RESERVED_4C 0x004C
+#define DRM_XMRFORMAT_ID_INVALID_RESERVED_4D 0x004D
+#define DRM_XMRFORMAT_ID_INVALID_RESERVED_4E 0x004E
+#define DRM_XMRFORMAT_ID_INVALID_RESERVED_4F 0x004F
+#define DRM_XMRFORMAT_ID_REMOVAL_DATE_OBJECT 0x0050
+#define DRM_XMRFORMAT_ID_AUX_KEY_OBJECT 0x0051
+#define DRM_XMRFORMAT_ID_UPLINKX_OBJECT 0x0052
+#define DRM_XMRFORMAT_ID_INVALID_RESERVED_53 0x0053
+#define DRM_XMRFORMAT_ID_INVALID_RESERVED_54 0x0054
+#define DRM_XMRFORMAT_ID_REAL_TIME_EXPIRATION_OBJECT 0x0055
+#define DRM_XMRFORMAT_ID_INVALID_RESERVED_56 0x0056
+#define DRM_XMRFORMAT_ID_INVALID_RESERVED_57 0x0057
+#define DRM_XMRFORMAT_ID_EXPLICIT_DIGITAL_VIDEO_OUTPUT_PROTECTION_CONTAINER 0x0058
+#define DRM_XMRFORMAT_ID_DIGITAL_VIDEO_OUTPUT_CONFIGURATION_OBJECT 0x0059
+#define DRM_XMRFORMAT_ID_SECURESTOP_OBJECT 0x005A
+#define DRM_XMRFORMAT_ID_LSRD_OBJECT 0x005B
+#define DRM_XMRFORMAT_ID_SECURESTOP2_OBJECT 0x005C
+#define DRM_XMRFORMAT_ID_OPTIMIZED_CONTENT_KEY2_OBJECT 0x005D
+#define DRM_XMRFORMAT_ID_MAXIMUM 0x005D
+#define DRM_XMRFORMAT_ID_UNKNOWN_OBJECT 0xFFFD
+#define DRM_XMRFORMAT_ID_UNKNOWN_CONTAINER 0xFFFE
+
+typedef struct __tagDRM_XMRFORMAT_EXTENDED_HEADER
+{
+    DRM_BOOL      fValid;
+    DRM_DWORD     dwVersion;
+    DRM_ID        LID;
+} DRM_XMRFORMAT_EXTENDED_HEADER;
+
+typedef struct __tagDRM_XMRFORMAT_DWORD
+{
+    DRM_BOOL      fValid;
+    DRM_DWORD     dwValue;
+} DRM_XMRFORMAT_DWORD;
+
+typedef struct __tagDRM_XMRFORMAT_WORD
+{
+    DRM_BOOL     fValid;
+    DRM_WORD     wValue;
+} DRM_XMRFORMAT_WORD;
+
+typedef struct __tagDRM_XMRFORMAT_GUID
+{
+    DRM_BOOL     fValid;
+    DRM_ID       idValue;
+} DRM_XMRFORMAT_GUID;
+
+typedef struct __tagDRM_XMRFORMAT_EXPLICIT_OUTPUT_PROTECTION
+{
+    DRM_BOOL                                              fValid;
+    struct __tagDRM_XMRFORMAT_EXPLICIT_OUTPUT_PROTECTION *pNext;
+
+    DRM_ID                                                idOPL;
+    DRM_XB_BYTEARRAY                                      xbbaConfig;
+} DRM_XMRFORMAT_EXPLICIT_OUTPUT_PROTECTION;
+
+typedef enum __tagDRM_XMRFORMAT_TYPES 
+{
+    DRM_XMRFORMAT_OUTER_CONTAINER_ENTRY_TYPE                    = 0x1,
+    DRM_XMRFORMAT_GLOBAL_POLICY_CONTAINER_ENTRY_TYPE            = 0x2,
+    DRM_XMRFORMAT_PLAYBACK_POLICY_CONTAINER_ENTRY_TYPE          = 0x4,
+    DRM_XMRFORMAT_MINIMUM_OUTPUT_PROTECTION_LEVELS_ENTRY_TYPE   = 0x5,
+    DRM_XMRFORMAT_EXPLICIT_ANALOG_VIDEO_PROTECTION_ENTRY_TYPE   = 0x7,
+    DRM_XMRFORMAT_ANALOG_VIDEO_OPL_ENTRY_TYPE                   = 0x8,
+    DRM_XMRFORMAT_KEY_MATERIAL_CONTAINER_ENTRY_TYPE             = 0x9,
+    DRM_XMRFORMAT_CONTENT_KEY_ENTRY_TYPE                        = 0xA,
+    DRM_XMRFORMAT_SIGNATURE_ENTRY_TYPE                          = 0xB,
+    DRM_XMRFORMAT_SERIAL_NUMBER_ENTRY_TYPE                      = 0xC,
+    DRM_XMRFORMAT_RIGHTS_ENTRY_TYPE                             = 0xD,
+    DRM_XMRFORMAT_EXPIRATION_ENTRY_TYPE                         = 0x12,
+    DRM_XMRFORMAT_ISSUEDATE_ENTRY_TYPE                          = 0x13,
+    DRM_XMRFORMAT_METERING_ENTRY_TYPE                           = 0x16,
+    DRM_XMRFORMAT_GRACEPERIOD_ENTRY_TYPE                        = 0x1A,
+    DRM_XMRFORMAT_SOURCEID_ENTRY_TYPE                           = 0x22,
+    DRM_XMRFORMAT_RESTRICTED_SOURCEID_ENTRY_TYPE                = 0x28,
+    DRM_XMRFORMAT_DOMAIN_ID_ENTRY_TYPE                          = 0x29,
+    DRM_XMRFORMAT_DEVICE_KEY_ENTRY_TYPE                         = 0x2A,
+    DRM_XMRFORMAT_POLICY_METADATA_ENTRY_TYPE                    = 0x2C,
+    DRM_XMRFORMAT_OPTIMIZED_CONTENT_KEY_ENTRY_TYPE              = 0x2D,
+    DRM_XMRFORMAT_EXPLICIT_DIGITAL_AUDIO_PROTECTION_ENTRY_TYPE  = 0x2E,
+    DRM_XMRFORMAT_EXPIRE_AFTER_FIRST_USE_ENTRY_TYPE             = 0x30,
+    DRM_XMRFORMAT_DIGITAL_AUDIO_OPL_ENTRY_TYPE                  = 0x31,
+    DRM_XMRFORMAT_REVOCATION_INFO_VERSION_ENTRY_TYPE            = 0x32,
+    DRM_XMRFORMAT_EMBEDDING_BEHAVIOR_ENTRY_TYPE                 = 0x33,
+    DRM_XMRFORMAT_SECURITY_LEVEL_ENTRY_TYPE                     = 0x34,
+    DRM_XMRFORMAT_MOVE_ENABLER_ENTRY_TYPE                       = 0x37,
+    DRM_XMRFORMAT_UPLINK_KID_ENTRY_TYPE                         = 0x3B,
+    DRM_XMRFORMAT_COPY_POLICIES_CONTAINER_ENTRY_TYPE            = 0x3C,
+    DRM_XMRFORMAT_COPY_COUNT_ENTRY_TYPE                         = 0x3D,
+    DRM_XMRFORMAT_REMOVAL_DATE_ENTRY_TYPE                       = 0x50,
+    DRM_XMRFORMAT_AUX_KEY_ENTRY_TYPE                            = 0x51,
+    DRM_XMRFORMAT_UPLINKX_ENTRY_TYPE                            = 0x52,
+    DRM_XMRFORMAT_REAL_TIME_EXPIRATION_ENTRY_TYPE               = 0x55,
+    DRM_XMRFORMAT_EXPLICIT_DIGITAL_VIDEO_PROTECTION_ENTRY_TYPE  = 0x58,
+    DRM_XMRFORMAT_DIGITAL_VIDEO_OPL_ENTRY_TYPE                  = 0x59,
+    DRM_XMRFORMAT_SECURESTOP_ENTRY_TYPE                         = 0x5A,
+    DRM_XMRFORMAT_SECURESTOP2_ENTRY_TYPE                        = 0x5C,
+    DRM_XMRFORMAT_OPTIMIZED_CONTENT_KEY2_ENTRY_TYPE             = 0x5D,
+    DRM_XMRFORMAT_COPY_UNKNOWN_OBJECT_ENTRY_TYPE                = 0xFFFD,
+    DRM_XMRFORMAT_PLAYBACK_UNKNOWN_OBJECT_ENTRY_TYPE            = 0xFFFD,
+    DRM_XMRFORMAT_GLOBAL_POLICY_UNKNOWN_OBJECT_ENTRY_TYPE       = 0xFFFD,
+    DRM_XMRFORMAT_COPY_UNKNOWN_CONTAINER_ENTRY_TYPE             = 0xFFFE,
+    DRM_XMRFORMAT_PLAYBACK_UNKNOWN_CONTAINER_ENTRY_TYPE         = 0xFFFE,
+    DRM_XMRFORMAT_UNKNOWN_CONTAINERS_ENTRY_TYPE                 = 0xFFFE,
+} DRM_XMRFORMAT_TYPES;
+/* Count Includes XB_OBJECT_GLOBAL_HEADER */
+#define DRM_XMRFORMAT_TYPE_COUNT       47
+#define DRM_XMRFORMAT_FORMAT_ID        XB_DEFINE_DWORD_FORMAT_ID( 'X', 'M', 'R', 0 )
+
+typedef struct __tagDRM_XMRFORMAT_SERIAL_NUMBER
+{
+    DRM_BOOL             fValid;
+    DRM_XB_BYTEARRAY     xbbaSerialNumber;
+} DRM_XMRFORMAT_SERIAL_NUMBER;
+
+typedef struct __tagDRM_XMRFORMAT_RESTRICTED_SOURCEID
+{
+    DRM_BOOL         fValid;
+    DRM_XB_EMPTY     EMPTY;
+} DRM_XMRFORMAT_RESTRICTED_SOURCEID;
+
+typedef struct __tagDRM_XMRFORMAT_EXPIRATION
+{
+    DRM_BOOL      fValid;
+    DRM_DWORD     dwBeginDate;
+    DRM_DWORD     dwEndDate;
+} DRM_XMRFORMAT_EXPIRATION;
+
+typedef struct __tagDRM_XMRFORMAT_REAL_TIME_EXPIRATION
+{
+    DRM_BOOL         fValid;
+    DRM_XB_EMPTY     EMPTY;
+} DRM_XMRFORMAT_REAL_TIME_EXPIRATION;
+
+typedef struct __tagDRM_XMRFORMAT_DOMAIN_ID
+{
+    DRM_BOOL      fValid;
+    DRM_ID        idAccount;
+    DRM_DWORD     dwRevision;
+} DRM_XMRFORMAT_DOMAIN_ID;
+
+typedef struct __tagDRM_XMRFORMAT_POLICY_METADATA
+{
+    DRM_BOOL                                   fValid;
+    struct __tagDRM_XMRFORMAT_POLICY_METADATA *pNext;
+
+    DRM_ID                                     idMetadataType;
+    DRM_XB_BYTEARRAY                           xbbaMetadata;
+} DRM_XMRFORMAT_POLICY_METADATA;
+
+typedef struct __tagDRM_XMRFORMAT_SECURITY_LEVEL
+{
+    DRM_BOOL     fValid;
+    DRM_WORD     wMinimumSecurityLevel;
+} DRM_XMRFORMAT_SECURITY_LEVEL;
+
+typedef struct __tagDRM_XMRFORMAT_GLOBAL_POLICY_CONTAINER
+{
+    DRM_BOOL                               fValid;
+    DRM_XMRFORMAT_SERIAL_NUMBER            SerialNumber;
+    DRM_XMRFORMAT_WORD                     Rights;
+    DRM_XMRFORMAT_DWORD                    SourceID;
+    DRM_XMRFORMAT_RESTRICTED_SOURCEID      RestrictedSourceID;
+    DRM_XMRFORMAT_EXPIRATION               Expiration;
+    DRM_XMRFORMAT_REAL_TIME_EXPIRATION     RealTimeExpiration;
+    DRM_XMRFORMAT_DWORD                    ExpirationAfterUse;
+    DRM_XMRFORMAT_DWORD                    IssueDate;
+    DRM_XMRFORMAT_DWORD                    GracePeriod;
+    DRM_XMRFORMAT_GUID                     Metering;
+    DRM_XMRFORMAT_GUID                     SecureStop;
+    DRM_XMRFORMAT_DOMAIN_ID                DomainID;
+    DRM_XMRFORMAT_WORD                     EmbeddingBehavior;
+    DRM_XB_UNKNOWN_OBJECT                 *pUnknownObjects;
+    DRM_XMRFORMAT_POLICY_METADATA         *pPolicyMetadata;
+    DRM_XMRFORMAT_DWORD                    RevocationInfoVersion;
+    DRM_XMRFORMAT_SECURITY_LEVEL           SecurityLevel;
+    DRM_XMRFORMAT_DWORD                    RemovalDate;
+} DRM_XMRFORMAT_GLOBAL_POLICY_CONTAINER;
+
+typedef struct __tagDRM_XMRFORMAT_MINIMUM_OUTPUT_PROTECTION_LEVELS
+{
+    DRM_BOOL     fValid;
+    DRM_WORD     wCompressedDigitalVideo;
+    DRM_WORD     wUncompressedDigitalVideo;
+    DRM_WORD     wAnalogVideo;
+    DRM_WORD     wCompressedDigitalAudio;
+    DRM_WORD     wUncompressedDigitalAudio;
+    DRM_XB_BYTEARRAY  xbbaRawData;
+} DRM_XMRFORMAT_MINIMUM_OUTPUT_PROTECTION_LEVELS;
+
+typedef struct __tagDRM_XMRFORMAT_EXPLICIT_ANALOG_VIDEO_PROTECTION
+{
+    DRM_BOOL                                     fValid;
+    DRM_XMRFORMAT_EXPLICIT_OUTPUT_PROTECTION    *pOPL;
+    DRM_WORD                                     cEntries;
+} DRM_XMRFORMAT_EXPLICIT_ANALOG_VIDEO_PROTECTION;
+
+typedef struct __tagDRM_XMRFORMAT_EXPLICIT_DIGITAL_AUDIO_PROTECTION
+{
+    DRM_BOOL                                     fValid;
+    DRM_XMRFORMAT_EXPLICIT_OUTPUT_PROTECTION    *pOPL;
+    DRM_WORD                                     cEntries;
+} DRM_XMRFORMAT_EXPLICIT_DIGITAL_AUDIO_PROTECTION;
+
+typedef struct __tagDRM_XMRFORMAT_EXPLICIT_DIGITAL_VIDEO_PROTECTION
+{
+    DRM_BOOL                                     fValid;
+    DRM_XMRFORMAT_EXPLICIT_OUTPUT_PROTECTION    *pOPL;
+    DRM_WORD                                     cEntries;
+} DRM_XMRFORMAT_EXPLICIT_DIGITAL_VIDEO_PROTECTION;
+
+typedef struct __tagDRM_XMRFORMAT_PLAYBACK_POLICY_CONTAINER
+{
+    DRM_BOOL                                            fValid;
+    DRM_XMRFORMAT_MINIMUM_OUTPUT_PROTECTION_LEVELS      MinimumOutputProtectionLevel;
+    DRM_XMRFORMAT_EXPLICIT_ANALOG_VIDEO_PROTECTION      ExplicitAnalogVideoProtection;
+    DRM_XMRFORMAT_EXPLICIT_DIGITAL_AUDIO_PROTECTION     ExplicitDigitalAudioProtection;
+    DRM_XMRFORMAT_EXPLICIT_DIGITAL_VIDEO_PROTECTION     ExplicitDigitalVideoProtection;
+    DRM_XB_UNKNOWN_OBJECT                              *pUnknownObjects;
+    DRM_XB_UNKNOWN_CONTAINER                            UnknownContainer;
+} DRM_XMRFORMAT_PLAYBACK_POLICY_CONTAINER;
+
+typedef struct __tagDRM_XMRFORMAT_COPY_POLICIES_CONTAINER
+{
+    DRM_BOOL                     fValid;
+    DRM_XMRFORMAT_DWORD          CopyCount;
+    DRM_XMRFORMAT_DWORD          MoveEnabler;
+    DRM_XB_UNKNOWN_OBJECT       *pUnknownObjects;
+    DRM_XB_UNKNOWN_CONTAINER     UnknownContainer;
+} DRM_XMRFORMAT_COPY_POLICIES_CONTAINER;
+
+typedef struct __tagDRM_XMRFORMAT_CONTENT_KEY
+{
+    DRM_BOOL             fValid;
+    DRM_ID               guidKeyID;
+    DRM_WORD             wSymmetricCipherType;
+    DRM_WORD             wKeyEncryptionCipherType;
+    DRM_XB_BYTEARRAY     xbbaEncryptedKey;
+} DRM_XMRFORMAT_CONTENT_KEY;
+
+typedef struct __tagDRM_XMRFORMAT_OPTIMIZED_CONTENT_KEY
+{
+    DRM_BOOL             fValid;
+    DRM_WORD             wKeyEncryptionCipherType;
+    DRM_XB_BYTEARRAY     xbbaKeyData;
+} DRM_XMRFORMAT_OPTIMIZED_CONTENT_KEY;
+
+typedef struct __tagDRM_XMRFORMAT_DEVICE_KEY
+{
+    DRM_BOOL             fValid;
+    DRM_WORD             wEccCurveType;
+    DRM_XB_BYTEARRAY     xbbaKeyData;
+} DRM_XMRFORMAT_DEVICE_KEY;
+
+typedef struct __tagDRM_XMRFORMAT_UPLINK_KID
+{
+    DRM_BOOL             fValid;
+    DRM_ID               idUplinkKID;
+    DRM_WORD             wChecksumType;
+    DRM_XB_BYTEARRAY     xbbaChainedChecksum;
+} DRM_XMRFORMAT_UPLINK_KID;
+
+typedef struct __tagDRM_XMRFORMAT_AUX_KEY
+{
+    DRM_BOOL             fValid;
+    DRM_WORD             cAuxKeys;
+    DRM_XB_BYTEARRAY     xbbaAuxKeys;
+} DRM_XMRFORMAT_AUX_KEY;
+
+typedef struct __tagDRM_XMRFORMAT_UPLINKX
+{
+    DRM_BOOL             fValid;
+    DRM_ID               idUplinkKID;
+    DRM_XB_BYTEARRAY     xbbaChecksum;
+    DRM_WORD             cEntries;
+    DRM_XB_DWORDLIST     dwlLocations;
+    DRM_XB_BYTEARRAY     xbbaKey;
+} DRM_XMRFORMAT_UPLINKX;
+
+typedef struct __tagDRM_XMRFORMAT_SECURESTOP2
+{
+    DRM_BOOL             fValid;
+    DRM_WORD             wSymmetricKeyEncryptionType;
+    DRM_XB_BYTEARRAY     xbbaEncryptedKey;
+    DRM_WORD             wSignatureAlgorithm;
+} DRM_XMRFORMAT_SECURESTOP2;
+
+typedef struct __tagDRM_XMRFORMAT_OPTIMIZED_CONTENT_KEY2
+{
+    DRM_BOOL             fValid;
+    DRM_ID               idCacheKey;
+    DRM_WORD             wCacheKeyEncryptionAlgorithm;
+    DRM_XB_BYTEARRAY     xbbaCacheKey;
+    DRM_WORD             wOriginalEccOutputEncryptionAlgorithm;
+    DRM_XB_BYTEARRAY     xbbaOriginalEccOutput;
+} DRM_XMRFORMAT_OPTIMIZED_CONTENT_KEY2;
+
+typedef struct __tagDRM_XMRFORMAT_KEY_MATERIAL_CONTAINER
+{
+    DRM_BOOL                                 fValid;
+    DRM_XMRFORMAT_CONTENT_KEY                ContentKey;
+    DRM_XMRFORMAT_OPTIMIZED_CONTENT_KEY      OptimizedContentKey;
+    DRM_XMRFORMAT_DEVICE_KEY                 DeviceKey;
+    DRM_XMRFORMAT_UPLINK_KID                 UplinkKID;
+    DRM_XMRFORMAT_AUX_KEY                    AuxKeys;
+    DRM_XMRFORMAT_UPLINKX                    UplinkX;
+    DRM_XMRFORMAT_SECURESTOP2                SecureStop2;
+    DRM_XMRFORMAT_OPTIMIZED_CONTENT_KEY2     OptimizedContentKey2;
+} DRM_XMRFORMAT_KEY_MATERIAL_CONTAINER;
+
+typedef struct __tagDRM_XMRFORMAT_SIGNATURE
+{
+    DRM_BOOL             fValid;
+    DRM_WORD             wType;
+    DRM_XB_BYTEARRAY     xbbaSignature;
+} DRM_XMRFORMAT_SIGNATURE;
+
+typedef struct __tagDRM_XMRFORMAT_OUTER_CONTAINER
+{
+    DRM_BOOL                                    fValid;
+    DRM_XMRFORMAT_GLOBAL_POLICY_CONTAINER       GlobalPolicyContainer;
+    DRM_XMRFORMAT_PLAYBACK_POLICY_CONTAINER     PlaybackPolicyContainer;
+    DRM_XMRFORMAT_COPY_POLICIES_CONTAINER       CopyPolicyContainer;
+    DRM_XB_UNKNOWN_CONTAINER                    UnknownContainer;
+    DRM_XMRFORMAT_KEY_MATERIAL_CONTAINER        KeyMaterialContainer;
+    DRM_XMRFORMAT_SIGNATURE                     Signature;
+} DRM_XMRFORMAT_OUTER_CONTAINER;
+
+typedef struct __tagDRM_XMRFORMAT
+{
+    DRM_BOOL                          fValid;
+    DRM_XMRFORMAT_EXTENDED_HEADER     HeaderData;
+    DRM_XMRFORMAT_EXTENDED_HEADER     HeaderDataLegacy;
+    DRM_XMRFORMAT_OUTER_CONTAINER     OuterContainer;
+    DRM_XB_BYTEARRAY                  xbbaRawData;
+} DRM_XMRFORMAT;
+
+DRM_EXPORT_VAR extern DRM_GLOBAL_CONST DRM_XB_FORMAT_DESCRIPTION s_DRM_XMRFORMAT_FormatDescription[2];
+
+PREFAST_POP;
+
+EXIT_PK_NAMESPACE;
+
+#endif /* __XMRFORMAT_H__ */
diff --git a/prebuilt-v4.4/noarch/include/drmxmrformatbuilder.h b/prebuilt-v4.4/noarch/include/drmxmrformatbuilder.h
new file mode 100644
index 0000000..df01936
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmxmrformatbuilder.h
@@ -0,0 +1,260 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __DRM_XMRFORMAT_BUILDER_H__
+#define __DRM_XMRFORMAT_BUILDER_H__
+
+#include <drmxmrformattypes.h>
+#include <drmxbbuilder.h>
+#include <drmxmrformat_generated.h>
+
+ENTER_PK_NAMESPACE;
+
+typedef struct __tagDRM_XMRFORMAT_BUILDER_CONTEXT_INTERNAL
+{
+    DRM_BOOL               fConvertAuxKeyLocations;
+    DRM_XMRFORMAT          oLicense;
+    DRM_XB_BUILDER_CONTEXT oBuilderCtx;
+} DRM_XMRFORMAT_BUILDER_CONTEXT_INTERNAL;
+
+#define DRM_XMRFORMAT_BUILDER_CONTEXT_BUFFER_SIZE sizeof( DRM_XMRFORMAT_BUILDER_CONTEXT_INTERNAL )
+
+typedef struct __tagDRM_XMRFORMAT_BUILDER_CONTEXT
+{
+    /*
+    ** This data is Opaque.  Do not set any value in it.
+    */
+    DRM_BYTE rgbOpaqueBuffer[ DRM_XMRFORMAT_BUILDER_CONTEXT_BUFFER_SIZE ];
+} DRM_XMRFORMAT_BUILDER_CONTEXT;
+
+/******************************************************************************
+**
+** Function :   DRM_XMRFORMAT_CB_SIGNATURE
+**
+** Synopsis :   Callback function provided by caller of XMR Builder APIs to
+**              create a signature using the integrity key. Integrity key is not
+**              passed to the builder APIs for security reasons. In the client,
+**              the clear integrity key should stay within the blackbox.
+**
+** Arguments :  f_pvSignatureContext  - Context needed by caller to retrieve
+**                                      appropriate integrity key
+**              f_pbData              - Data to be signed
+**              f_cbData              - Length of pbData
+**              f_pbSignatureBuffer   - Buffer in which to put the signature
+**              f_cbSignatureBuffer   - Length of signature buffer
+**              f_ibSignatureBuffer   - Index in buffer at which signature should
+**                                      be put
+**
+** Returns :
+**
+** Notes :
+**
+******************************************************************************/
+typedef DRM_RESULT ( DRM_CALL *DRM_XMRFORMAT_CB_SIGNATURE )(
+    __in_opt                              const DRM_VOID                       *f_pvSignatureContext,
+    __in_bcount( f_cbData )               const DRM_BYTE                       *f_pbData,
+    __in                                  const DRM_DWORD                       f_cbData,
+    __out_bcount( f_cbSignatureBuffer )         DRM_BYTE                       *f_pbSignatureBuffer,
+    __in                                  const DRM_DWORD                       f_cbSignatureBuffer,
+    __in                                  const DRM_DWORD                       f_ibSignatureBuffer );
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_XMRFORMAT_StartLicense(
+    __inout                                     DRM_STACK_ALLOCATOR_CONTEXT    *f_pStack,
+    __in_ecount( 1 )                      const DRM_ID                         *f_pidRights,
+    __in                                        DRM_DWORD                       f_dwVersion,
+    __in_ecount_opt( 1 )                  const DRM_XMRFORMAT                  *f_pRebindLicense,
+    __inout_ecount( 1 )                         DRM_XMRFORMAT_BUILDER_CONTEXT  *f_pcontextBuilder ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_XMRFORMAT_FinishLicense (
+    __in_ecount( 1 ) const                      DRM_XMRFORMAT_BUILDER_CONTEXT  *f_pcontextBuilder,
+    __in_ecount_opt( 1 ) const                  DRM_VOID                       *f_pvSignatureContext,
+    __in_opt                                    DRM_XMRFORMAT_CB_SIGNATURE      f_pfnSignature,
+    __in                                        DRM_DWORD                       f_cbSignature,
+    __in                                        DRM_WORD                        f_wSignatureType,
+    __inout_ecount( 1 )                         DRM_DWORD                      *f_pcbLicense,
+    __inout_bcount_part_opt( *f_pcbLicense, *f_pcbLicense )
+                                                DRM_BYTE                       *f_pbLicense ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_XMRFORMAT_AllowPlaybackRights(
+    __inout_ecount( 1 )                         DRM_XMRFORMAT_BUILDER_CONTEXT  *f_pcontextBuilder ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_XMRFORMAT_AllowCopyRights(
+    __inout_ecount( 1 )                         DRM_XMRFORMAT_BUILDER_CONTEXT  *f_pcontextBuilder ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_XMRFORMAT_AddUnknownObject(
+    __inout_ecount( 1 )                         DRM_XMRFORMAT_BUILDER_CONTEXT  *f_pcontextBuilder,
+    __in                                        DRM_WORD                        f_wObjectType,
+    __in                                        DRM_BOOL                        f_fDuplicatesAllowed,
+    __in                                        DRM_WORD                        f_wParent,
+    __in                                        DRM_WORD                        f_wFlags,
+    __in                                        DRM_DWORD                       f_cbObject,
+    __in_bcount_opt( f_cbObject )         const DRM_BYTE                       *f_pbObject ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_XMRFORMAT_SetSerialNumber(
+    __inout                                     DRM_XMRFORMAT_BUILDER_CONTEXT  *f_pxmrBuilder,
+    __in                                        DRM_DWORD                       f_cbSerialNumber,
+    __in_bcount( f_cbSerialNumber )       const DRM_BYTE                       *f_pbSerialNumber ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_XMRFORMAT_SetSecurityLevel(
+    __inout                                     DRM_XMRFORMAT_BUILDER_CONTEXT  *f_pxmrBuilder,
+    __in                                        DRM_WORD                        f_wSecurityLevel ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_XMRFORMAT_SetGlobalRights(
+    __inout                                     DRM_XMRFORMAT_BUILDER_CONTEXT  *f_pxmrBuilder,
+    __in                                        DRM_WORD                        f_wRights ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_XMRFORMAT_SetExpirationDate(
+    __inout                                     DRM_XMRFORMAT_BUILDER_CONTEXT  *f_pxmrBuilder,
+    __in                                        DRM_DWORD                       f_dwBeginDate,
+    __in                                        DRM_DWORD                       f_dwEndDate,
+    __in                                        DRM_DWORD                       f_dwSubtractFromBeginDate,
+    __in                                        DRM_DWORD                       f_dwAddToEndDate ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_XMRFORMAT_SetExpirationAfterFirstPlay(
+    __inout                                     DRM_XMRFORMAT_BUILDER_CONTEXT  *f_pxmrBuilder,
+    __in                                        DRM_DWORD                       f_dwExpirationAfterFirstPlay ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_XMRFORMAT_SetRealTimeExpiration(
+    __inout                                     DRM_XMRFORMAT_BUILDER_CONTEXT  *f_pxmrBuilder,
+    __in                                        DRM_BOOL                        f_fRealTimeExpiration ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_XMRFORMAT_SetRestrictedSourceID(
+    __inout                                     DRM_XMRFORMAT_BUILDER_CONTEXT  *f_pxmrBuilder,
+    __in                                        DRM_BOOL                        f_fRestrictedSourceID ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_XMRFORMAT_SetSourceID(
+    __inout                                     DRM_XMRFORMAT_BUILDER_CONTEXT  *f_pxmrBuilder,
+    __in                                        DRM_DWORD                       f_dwSourceID ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_XMRFORMAT_SetGracePeriod(
+    __inout                                     DRM_XMRFORMAT_BUILDER_CONTEXT  *f_pxmrBuilder,
+    __in                                        DRM_DWORD                       f_dwGracePeriod ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_XMRFORMAT_SetOutputProtectionLevels(
+    __inout                                     DRM_XMRFORMAT_BUILDER_CONTEXT  *f_pxmrBuilder,
+    __in                                        DRM_WORD                        f_wCompressedDigitalVideo,
+    __in                                        DRM_WORD                        f_wUncompressedDigitalVideo,
+    __in                                        DRM_WORD                        f_wAnalogVideo,
+    __in                                        DRM_WORD                        f_wCompressedDigitalAudio,
+    __in                                        DRM_WORD                        f_wUncompressedDigitalAudio ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_XMRFORMAT_AddExplicitOutputProtection(
+    __inout                                     DRM_XMRFORMAT_BUILDER_CONTEXT  *f_pxmrBuilder,
+    __in                                        DRM_WORD                        f_wXmrObjectType,
+    __in_ecount( 1 )                      const DRM_GUID                       *f_pOutputProtectionID,
+    __in                                        DRM_DWORD                       f_cbConfigData,
+    __in_bcount_opt( f_cbConfigData )     const DRM_BYTE                       *f_pbConfigData ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_XMRFORMAT_AddPlayEnablers(
+    __inout                                     DRM_XMRFORMAT_BUILDER_CONTEXT  *f_pxmrBuilder,
+    __in                                        DRM_DWORD                       f_cPlayEnablers,
+    __in_ecount( f_cPlayEnablers )        const DRM_GUID                       *f_pguidPlayEnablers ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_XMRFORMAT_AddCopyEnablers(
+    __inout                                     DRM_XMRFORMAT_BUILDER_CONTEXT  *f_pxmrBuilder,
+    __in                                        DRM_DWORD                       f_cCopyEnablers,
+    __in_ecount( f_cCopyEnablers )        const DRM_GUID                       *f_pguidCopyEnablers ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_XMRFORMAT_SetDeviceKey(
+    __inout                                     DRM_XMRFORMAT_BUILDER_CONTEXT  *f_pxmrBuilder,
+    __in                                        DRM_WORD                        f_wEccCurveType,
+    __in                                        DRM_DWORD                       f_cbPublicKey,
+    __in_bcount( f_cbPublicKey )          const DRM_BYTE                       *f_pbPublicKey ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_XMRFORMAT_SetIssueDate(
+    __inout                                     DRM_XMRFORMAT_BUILDER_CONTEXT  *f_pxmrBuilder,
+    __in                                        DRM_DWORD                       f_dwIssueDate ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_XMRFORMAT_SetRevocationVersion(
+    __inout                                     DRM_XMRFORMAT_BUILDER_CONTEXT  *f_pxmrBuilder,
+    __in                                        DRM_DWORD                       f_dwVersion ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_XMRFORMAT_SetEmbeddedBehavior(
+    __inout                                     DRM_XMRFORMAT_BUILDER_CONTEXT  *f_pxmrBuilder,
+    __in                                        DRM_WORD                        f_wEmbeddedBehavior ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_XMRFORMAT_SetContentKey(
+    __inout                                     DRM_XMRFORMAT_BUILDER_CONTEXT  *f_pxmrBuilder,
+    __in                                        DRM_WORD                        f_wSymmetricCipherType,
+    __in                                        DRM_WORD                        f_wEncryptionCipherType,
+    __in_ecount( 1 )                      const DRM_ID                         *f_pKeyID,
+    __in                                        DRM_DWORD                       f_cbEncryptedKey,
+    __in_bcount( f_cbEncryptedKey )       const DRM_BYTE                       *f_pbEncryptedKey ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_XMRFORMAT_SetUplinkKID(
+    __inout                                     DRM_XMRFORMAT_BUILDER_CONTEXT  *f_pxmrBuilder,
+    __in_ecount( 1 )                      const DRM_ID                         *f_pKeyID,
+    __in                                        DRM_DWORD                       f_cbCheckSum,
+    __in_bcount( f_cbCheckSum )           const DRM_BYTE                       *f_pbCheckSum ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_XMRFORMAT_SetUplinkX(
+    __inout                                     DRM_XMRFORMAT_BUILDER_CONTEXT  *f_pxmrBuilder,
+    __in_ecount( 1 )                      const DRM_ID                         *f_pUplinkXID,
+    __in                                        DRM_DWORD                       f_cbChecksum,
+    __in_bcount( f_cbChecksum )           const DRM_BYTE                       *f_pbChecksum,
+    __in                                        DRM_WORD                        f_cLocations,
+    __in_ecount( f_cLocations )           const DRM_DWORD                      *f_pdwLocations ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_XMRFORMAT_SetAuxKeyEntries(
+    __inout                                     DRM_XMRFORMAT_BUILDER_CONTEXT  *f_pxmrBuilder,
+    __in                                        DRM_WORD                        f_cAuxEntries,
+    __in_ecount( f_cAuxEntries )          const DRM_XMRFORMAT_AUX_KEY_ENTRY    *f_pAuxEntries ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_XMRFORMAT_SetMeteringID(
+    __inout                                     DRM_XMRFORMAT_BUILDER_CONTEXT  *f_pxmrBuilder,
+    __in_ecount( 1 )                      const DRM_ID                         *f_pMeteringID ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_XMRFORMAT_SetSecureStopID(
+    __inout                                     DRM_XMRFORMAT_BUILDER_CONTEXT  *f_pxmrBuilder,
+    __in_ecount( 1 )                      const DRM_ID                         *f_pSecureStopID ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_XMRFORMAT_SetSecureStop2(
+    __inout                                     DRM_XMRFORMAT_BUILDER_CONTEXT  *f_pxmrBuilder,
+    __in                                        DRM_WORD                        f_wSymmetricKeyEncryptionType,
+    __in                                        DRM_DWORD                       f_cbEncryptedKey,
+    __in_bcount( f_cbEncryptedKey )       const DRM_BYTE                       *f_pbEncryptedKey,
+    __in                                        DRM_WORD                        f_wSignatureAlgorithm ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_XMRFORMAT_SetOptimizedContentKey2(
+    __inout                                     DRM_XMRFORMAT_BUILDER_CONTEXT  *f_pxmrBuilder,
+    __in_ecount( 1 )                      const DRM_ID                         *f_pidCacheKey,
+    __in                                        DRM_WORD                        f_wCacheKeyEncryptionAlgorithm,
+    __in                                        DRM_DWORD                       f_cbCacheKey,
+    __in_bcount( f_cbCacheKey )           const DRM_BYTE                       *f_pbCacheKey,
+    __in                                        DRM_WORD                        f_wOriginalEccOutputEncryptionAlgorithm,
+    __in                                        DRM_DWORD                       f_cbOriginalEccOutput,
+    __in_bcount( f_cbOriginalEccOutput )  const DRM_BYTE                       *f_pbOriginalEccOutput ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_XMRFORMAT_SetRemovalDate(
+    __inout                                     DRM_XMRFORMAT_BUILDER_CONTEXT  *f_pxmrBuilder,
+    __in                                        DRM_DWORD                       f_dwRemovalDate ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_XMRFORMAT_SetCopyCount(
+    __inout                                     DRM_XMRFORMAT_BUILDER_CONTEXT  *f_pxmrBuilder,
+    __in                                        DRM_DWORD                       f_dwCopyCount ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_XMRFORMAT_SetDomain(
+    __inout                                     DRM_XMRFORMAT_BUILDER_CONTEXT  *f_pxmrBuilder,
+    __in_ecount( 1 )                      const DRM_ID                         *f_pDomainID,
+    __in                                        DRM_DWORD                       f_dwRevision ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_XMRFORMAT_CreateExtensibleRestriction(
+    __in_ecount( 1 )                      const DRM_XMRFORMAT_BUILDER_CONTEXT  *f_pcontextBuilder,
+    __in                                        DRM_WORD                        f_wPolicyLen,
+    __in_bcount( f_wPolicyLen )           const DRM_BYTE                       *f_pbPolicy,
+    __in                                        DRM_DWORD                       f_dwSecureDataSize,
+    __in                                        DRM_BYTE                        f_bStateType,
+    __in                                        DRM_WORD                        f_wStateLen,
+    __in_bcount( f_wStateLen )                  DRM_VOID                       *f_pvState,
+    __inout_ecount( 1 )                         DRM_DWORD                      *f_cbRestriction,
+    __deref_inout_bcount( *f_cbRestriction )    DRM_BYTE                      **f_ppbRestriction ) DRM_NO_INLINE_ATTRIBUTE;
+
+
+EXIT_PK_NAMESPACE;
+
+#endif  /* __DRM_XMRFORMAT_BUILDER_H__ */
diff --git a/prebuilt-v4.4/noarch/include/drmxmrformatparser.h b/prebuilt-v4.4/noarch/include/drmxmrformatparser.h
new file mode 100644
index 0000000..fbda25e
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmxmrformatparser.h
@@ -0,0 +1,32 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __DRM_XMRFORMAT_PARSER_H__
+#define __DRM_XMRFORMAT_PARSER_H__
+
+#include <drmstkalloc.h>
+#include <drmxmrformattypes.h>
+#include <drmxmrformat_generated.h>
+
+ENTER_PK_NAMESPACE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_XMRFORMAT_Parse(
+    __in                              DRM_DWORD                    f_cbXMR,
+    __in_bcount( f_cbXMR )      const DRM_BYTE                    *f_pbXMR,
+    __inout                           DRM_STACK_ALLOCATOR_CONTEXT *f_pStack,
+    __out_opt                         DRM_DWORD                   *f_pcbParsed,
+    __out                             DRM_XMRFORMAT               *f_pXmrLicense ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_API DRM_RESULT DRM_CALL DRM_XMRFORMAT_RequiresSST(
+    __in  const DRM_XMRFORMAT *f_pXmrLicense,
+    __out       DRM_BOOL      *f_pfRequiresSST );
+
+
+EXIT_PK_NAMESPACE;
+
+#endif  /* __DRM_XMRFORMAT_PARSER_H__ */
diff --git a/prebuilt-v4.4/noarch/include/drmxmrformattypes.h b/prebuilt-v4.4/noarch/include/drmxmrformattypes.h
new file mode 100644
index 0000000..251caf6
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/drmxmrformattypes.h
@@ -0,0 +1,265 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __DRM_XMR_FORMAT_TYPES_H__
+#define __DRM_XMR_FORMAT_TYPES_H__
+
+#include <drmxb.h>
+#include <drmxmrconstants.h>
+#include <drmxmrformat_generated.h>
+#include <oemaescommon.h>
+
+ENTER_PK_NAMESPACE;
+
+#define DRM_XMRFORMAT_MAX_UNPACK_ALLOC_FACTOR  7
+#define DRM_XMRFORAT_EXPIRATION_MIN_BEGIN_DATE 0
+
+typedef struct __tagDRM_XMRFORMAT_AUX_KEY_ENTRY
+{
+    DRM_DWORD dwLocation;
+    DRM_BYTE  rgbAuxKey[DRM_AES_KEYSIZE_128];
+} DRM_XMRFORMAT_AUX_KEY_ENTRY;
+
+typedef struct __tagDRM_XMRFORMAT_EXPLICIT_OUTPUT_PROTECTION_BASE
+{
+    DRM_BOOL                                     fValid;
+    DRM_XMRFORMAT_EXPLICIT_OUTPUT_PROTECTION    *pOPL;
+    DRM_WORD                                     cEntries;
+} DRM_XMRFORMAT_EXPLICIT_OUTPUT_PROTECTION_BASE;
+
+typedef DRM_XMRFORMAT_WORD  DRM_XMRFORMAT_RIGHTS;
+typedef DRM_XMRFORMAT_DWORD DRM_XMRFORMAT_EXPIRATION_AFTER_FIRSTUSE;
+typedef DRM_XMRFORMAT_DWORD DRM_XMRFORMAT_SOURCEID;
+typedef DRM_XMRFORMAT_DWORD DRM_XMRFORMAT_ISSUEDATE;
+typedef DRM_XMRFORMAT_DWORD DRM_XMRFORMAT_REVOCATION_INFORMATION_VERSION;
+typedef DRM_XMRFORMAT_WORD  DRM_XMRFORMAT_EMBEDDING_BEHAVIOR;
+
+/*
+** License evaluation macros
+*/
+#define XMRFORMAT_BASE_OBJECT_LENGTH   ( sizeof( DRM_WORD ) * 2  + sizeof( DRM_DWORD ) )
+
+#define XMRFORMAT_GET_LICENSE_LENGTH_WITHOUT_SIGNATURE( plicenseXMR )                  \
+    ( XBBA_TO_CB( ( plicenseXMR )->xbbaRawData )                                       \
+      - XMRFORMAT_BASE_OBJECT_LENGTH                                                   \
+      - sizeof( DRM_WORD ) * 2                                                         \
+      - XBBA_TO_CB( ( plicenseXMR )->OuterContainer.Signature.xbbaSignature ) )        \
+
+#define XMRFORMAT_IS_RID_VALID( plicenseXMR )                                          \
+    (  ( plicenseXMR )->HeaderData.fValid )                                            \
+
+#define XMRFORMAT_IS_METERING_VALID( plicenseXMRFORMAT )                               \
+    ( ( plicenseXMRFORMAT )->OuterContainer.fValid                                     \
+   && ( plicenseXMRFORMAT )->OuterContainer.GlobalPolicyContainer.fValid               \
+   && ( plicenseXMRFORMAT )->OuterContainer.GlobalPolicyContainer.Metering.fValid )
+
+#define XMRFORMAT_IS_SECURESTOP_VALID( plicenseXMRFORMAT )                             \
+    ( ( plicenseXMRFORMAT )->OuterContainer.fValid                                     \
+   && ( plicenseXMRFORMAT )->OuterContainer.GlobalPolicyContainer.fValid               \
+   && ( plicenseXMRFORMAT )->OuterContainer.GlobalPolicyContainer.SecureStop.fValid )
+
+#define XMRFORMAT_IS_KEY_MATERIAL_VALID( plicenseXMRFORMAT )                           \
+    ( ( plicenseXMRFORMAT )->OuterContainer.fValid                                     \
+   && ( plicenseXMRFORMAT )->OuterContainer.KeyMaterialContainer.fValid )
+
+#define XMRFORMAT_IS_UPLINK_KID_VALID( plicenseXMRFORMAT )                             \
+    ( ( plicenseXMRFORMAT )->OuterContainer.fValid                                     \
+   && ( plicenseXMRFORMAT )->OuterContainer.KeyMaterialContainer.fValid                \
+   && ( plicenseXMRFORMAT )->OuterContainer.KeyMaterialContainer.UplinkKID.fValid )    \
+
+#define XMRFORMAT_IS_SOURCEID_VALID( plicenseXMRFORMAT )                               \
+    ( ( plicenseXMRFORMAT )->OuterContainer.fValid                                     \
+   && ( plicenseXMRFORMAT )->OuterContainer.GlobalPolicyContainer.fValid               \
+   && ( plicenseXMRFORMAT )->OuterContainer.GlobalPolicyContainer.SourceID.fValid )
+
+#define XMRFORMAT_IS_EXPIRATION_AFTER_FIRST_USE_VALID( plicenseXMR )                   \
+    ( ( plicenseXMR )->OuterContainer.fValid                                           \
+   && ( plicenseXMR )->OuterContainer.GlobalPolicyContainer.fValid                     \
+   && ( plicenseXMR )->OuterContainer.GlobalPolicyContainer.ExpirationAfterUse.fValid )
+
+#define XMRFORMAT_IS_RESTRICTED_SOURCEID_VALID( plicenseXMRFORMAT )                    \
+    ( ( plicenseXMRFORMAT )->OuterContainer.fValid                                     \
+    && ( plicenseXMRFORMAT )->OuterContainer.GlobalPolicyContainer.fValid              \
+    && ( plicenseXMRFORMAT )->OuterContainer.GlobalPolicyContainer.RestrictedSourceID.fValid )
+
+#define XMRFORMAT_IS_REVOCATION_INFORMATION_VERSION_VALID( plicenseXMRFORMAT )         \
+    ( ( plicenseXMRFORMAT )->OuterContainer.fValid                                     \
+   && ( plicenseXMRFORMAT )->OuterContainer.GlobalPolicyContainer.fValid               \
+   && ( plicenseXMRFORMAT )->OuterContainer.GlobalPolicyContainer.RevocationInfoVersion.fValid )
+
+#define XMRFORMAT_IS_GLOBAL_POLICIES_VALID( plicenseXMRFORMAT )                        \
+    ( ( plicenseXMRFORMAT )->OuterContainer.fValid                                     \
+   && ( plicenseXMRFORMAT )->OuterContainer.GlobalPolicyContainer.fValid )
+
+#define XMRFORMAT_IS_EXPIRATION_VALID( plicenseXMRFORMAT )                             \
+    ( ( plicenseXMRFORMAT )->OuterContainer.fValid                                     \
+   && ( plicenseXMRFORMAT )->OuterContainer.GlobalPolicyContainer.fValid               \
+   && ( plicenseXMRFORMAT )->OuterContainer.GlobalPolicyContainer.Expiration.fValid )
+
+#define XMRFORMAT_IS_ISSUEDATE_VALID( plicenseXMRFORMAT )                              \
+    ( ( plicenseXMRFORMAT )->OuterContainer.fValid                                     \
+   && ( plicenseXMRFORMAT )->OuterContainer.GlobalPolicyContainer.fValid               \
+   && ( plicenseXMRFORMAT )->OuterContainer.GlobalPolicyContainer.IssueDate.fValid )
+
+#define XMRFORMAT_IS_GRACE_PERIOD_VALID( plicenseXMRFORMAT )                           \
+    ( ( plicenseXMRFORMAT )->OuterContainer.fValid                                     \
+   && ( plicenseXMRFORMAT )->OuterContainer.GlobalPolicyContainer.fValid               \
+   && ( plicenseXMRFORMAT )->OuterContainer.GlobalPolicyContainer.GracePeriod.fValid )
+
+#define XMRFORMAT_IS_SECURITY_LEVEL_VALID( plicenseXMRFORMAT )                         \
+    ( ( plicenseXMRFORMAT )->OuterContainer.fValid                                     \
+   && ( plicenseXMRFORMAT )->OuterContainer.GlobalPolicyContainer.fValid               \
+   && ( plicenseXMRFORMAT )->OuterContainer.GlobalPolicyContainer.SecurityLevel.fValid )
+
+#define XMRFORMAT_IS_OPL_VALID( plicenseXMRFORMAT )                                    \
+    ( (plicenseXMRFORMAT)->OuterContainer.fValid                                       \
+   && (plicenseXMRFORMAT)->OuterContainer.PlaybackPolicyContainer.fValid               \
+   && (plicenseXMRFORMAT)->OuterContainer.PlaybackPolicyContainer.MinimumOutputProtectionLevel.fValid )
+
+#define XMRFORMAT_IS_EXPLICITANALOGVIDEOPROTECTION_VALID( plicenseXMRFORMAT )          \
+    ( (plicenseXMRFORMAT)->OuterContainer.fValid                                       \
+   && (plicenseXMRFORMAT)->OuterContainer.PlaybackPolicyContainer.fValid               \
+   && (plicenseXMRFORMAT)->OuterContainer.PlaybackPolicyContainer.ExplicitAnalogVideoProtection.fValid )
+
+#define XMRFORMAT_IS_EXPLICITDIGITALAUDIOPROTECTION_VALID( plicenseXMRFORMAT )         \
+    ( (plicenseXMRFORMAT)->OuterContainer.fValid                                       \
+   && (plicenseXMRFORMAT)->OuterContainer.PlaybackPolicyContainer.fValid               \
+   && (plicenseXMRFORMAT)->OuterContainer.PlaybackPolicyContainer.ExplicitDigitalAudioProtection.fValid )
+
+#define XMRFORMAT_IS_EXPLICITDIGITALVIDEOPROTECTION_VALID( plicenseXMRFORMAT )         \
+    ( (plicenseXMRFORMAT)->OuterContainer.fValid                                       \
+   && (plicenseXMRFORMAT)->OuterContainer.PlaybackPolicyContainer.fValid               \
+   && (plicenseXMRFORMAT)->OuterContainer.PlaybackPolicyContainer.ExplicitDigitalVideoProtection.fValid )
+
+#define XMRFORMAT_IS_POLICYMETADATA_VALID( plicenseXMRFORMAT )                         \
+    ( ( plicenseXMRFORMAT )->OuterContainer.fValid                                     \
+   && ( plicenseXMRFORMAT )->OuterContainer.GlobalPolicyContainer.fValid               \
+   && ( plicenseXMRFORMAT )->OuterContainer.GlobalPolicyContainer.PolicyMetadata.fValid )
+
+#define XMRFORMAT_IS_PLAY_VALID( plicenseXMRFORMAT )                                   \
+    ( ( plicenseXMRFORMAT )->OuterContainer.fValid                                     \
+   && ( plicenseXMRFORMAT )->OuterContainer.PlaybackPolicyContainer.fValid )
+
+#define XMRFORMAT_IS_COPY_VALID( plicenseXMRFORMAT )                                   \
+    ( ( plicenseXMRFORMAT )->OuterContainer.fValid                                     \
+   && ( plicenseXMRFORMAT )->OuterContainer.CopyPolicyContainer.fValid )
+
+#define XMRFORMAT_IS_COPYCOUNT_VALID( plicenseXMRFORMAT )                              \
+    ( ( plicenseXMRFORMAT )->OuterContainer.fValid                                     \
+   && ( plicenseXMRFORMAT )->OuterContainer.CopyPolicyContainer.fValid                 \
+   && ( plicenseXMRFORMAT )->OuterContainer.CopyPolicyContainer.CopyCount.fValid )
+
+#define XMRFORMAT_IS_SIGNATURE_VALID( plicenseXMRFORMAT )                              \
+    ( ( plicenseXMRFORMAT )->OuterContainer.fValid                                     \
+   && ( plicenseXMRFORMAT )->OuterContainer.Signature.fValid )
+
+#define XMRFORMAT_IS_CONTENT_KEY_VALID( plicenseXMRFORMAT )                            \
+    ( ( plicenseXMRFORMAT )->OuterContainer.fValid                                     \
+   && ( plicenseXMRFORMAT )->OuterContainer.KeyMaterialContainer.fValid                \
+   && ( plicenseXMRFORMAT )->OuterContainer.KeyMaterialContainer.ContentKey.fValid )
+
+#define XMRFORMAT_IS_SECURESTOP2_VALID( plicenseXMRFORMAT )                            \
+    ( ( plicenseXMRFORMAT )->OuterContainer.fValid                                     \
+   && ( plicenseXMRFORMAT )->OuterContainer.KeyMaterialContainer.fValid                \
+   && ( plicenseXMRFORMAT )->OuterContainer.KeyMaterialContainer.SecureStop2.fValid )
+
+#define XMRFORMAT_IS_OPTIMIZED_CONTENT_KEY_VALID( plicenseXMRFORMAT )                  \
+    ( ( plicenseXMRFORMAT )->OuterContainer.fValid                                     \
+   && ( plicenseXMRFORMAT )->OuterContainer.KeyMaterialContainer.fValid                \
+   && ( plicenseXMRFORMAT )->OuterContainer.KeyMaterialContainer.OptimizedContentKey.fValid )
+
+#define XMRFORMAT_IS_OPTIMIZED_CONTENT_KEY2_VALID( plicenseXMRFORMAT )                 \
+    ( ( plicenseXMRFORMAT )->OuterContainer.fValid                                     \
+   && ( plicenseXMRFORMAT )->OuterContainer.KeyMaterialContainer.fValid                \
+   && ( plicenseXMRFORMAT )->OuterContainer.KeyMaterialContainer.OptimizedContentKey2.fValid )
+
+#define XMRFORMAT_IS_DEVICE_KEY_VALID( plicenseXMRFORMAT )                             \
+    ( (plicenseXMRFORMAT)->OuterContainer.fValid                                       \
+   && (plicenseXMRFORMAT)->OuterContainer.KeyMaterialContainer.fValid                  \
+   && (plicenseXMRFORMAT)->OuterContainer.KeyMaterialContainer.DeviceKey.fValid )
+
+#define XMRFORMAT_IS_RIGHTS_VALID( plicenseXMRFORMAT )                                 \
+    ( ( plicenseXMRFORMAT )->OuterContainer.fValid                                     \
+   && ( plicenseXMRFORMAT )->OuterContainer.GlobalPolicyContainer.fValid               \
+   && ( plicenseXMRFORMAT )->OuterContainer.GlobalPolicyContainer.Rights.fValid )
+
+#define XMRFORMAT_IS_CANNOT_PERSIST_LICENSE( plicenseXMRFORMAT )                       \
+    ( XMRFORMAT_IS_RIGHTS_VALID( ( plicenseXMRFORMAT ) )                              \
+   && ( XMR_RIGHTS_CANNOT_PERSIST == ( ( plicenseXMRFORMAT )->OuterContainer.GlobalPolicyContainer.Rights.wValue & XMR_RIGHTS_CANNOT_PERSIST ) ) )
+
+#define XMRFORMAT_IS_CANNOT_BIND_LICENSE( plicenseXMRFORMAT )                          \
+    ( XMRFORMAT_IS_RIGHTS_VALID( ( plicenseXMRFORMAT ) )                              \
+   && ( XMR_RIGHTS_CANNOT_BIND_LICENSE == ( ( plicenseXMRFORMAT )->OuterContainer.GlobalPolicyContainer.Rights.wValue & XMR_RIGHTS_CANNOT_BIND_LICENSE ) ) )
+
+#define XMRFORMAT_IS_TEMP_STORE_ONLY( plicenseXMRFORMAT )                              \
+    ( XMRFORMAT_IS_RIGHTS_VALID( ( plicenseXMRFORMAT ) )                              \
+   && ( XMR_RIGHTS_TEMP_STORE_ONLY == ( ( plicenseXMRFORMAT )->OuterContainer.GlobalPolicyContainer.Rights.wValue & XMR_RIGHTS_TEMP_STORE_ONLY ) ) )
+
+#define XMRFORMAT_IS_COLLABORATIVE_PLAY( plicenseXMRFORMAT )                           \
+    ( XMRFORMAT_IS_RIGHTS_VALID( ( plicenseXMRFORMAT ) )                              \
+   && ( XMR_RIGHTS_COLLABORATIVE_PLAY == ( ( plicenseXMRFORMAT )->OuterContainer.GlobalPolicyContainer.Rights.wValue & XMR_RIGHTS_COLLABORATIVE_PLAY ) ) )
+
+#define XMRFORMAT_IS_DOMAIN_ID_VALID( plicenseXMRFORMAT )                              \
+    ( (plicenseXMRFORMAT)->OuterContainer.fValid                                       \
+   && (plicenseXMRFORMAT)->OuterContainer.GlobalPolicyContainer.fValid                 \
+   && (plicenseXMRFORMAT)->OuterContainer.GlobalPolicyContainer.DomainID.fValid )
+
+#define XMRFORMAT_IS_SERIAL_NUMBER_RESTRICTION_VALID( plicenseXMRFORMAT )              \
+    ( (plicenseXMRFORMAT)->OuterContainer.fValid                                       \
+   && (plicenseXMRFORMAT)->OuterContainer.GlobalPolicyContainer.fValid                 \
+   && (plicenseXMRFORMAT)->OuterContainer.GlobalPolicyContainer.SerialNumber.fValid )
+
+#define XMRFORMAT_IS_EMBEDDING_BEHAVIOR_VALID( plicenseXMRFORMAT )                     \
+    ( (plicenseXMRFORMAT)->OuterContainer.fValid                                       \
+   && (plicenseXMRFORMAT)->OuterContainer.GlobalPolicyContainer.fValid                 \
+   && (plicenseXMRFORMAT)->OuterContainer.GlobalPolicyContainer.EmbeddingBehavior.fValid )
+
+#define XMRFORMAT_IS_UNKNOWN_CONTAINER_VALID( plicenseXMRFORMAT )                      \
+    ( (plicenseXMRFORMAT)->OuterContainer.fValid                                       \
+   && (plicenseXMRFORMAT)->OuterContainer.UnknownContainer.fValid )
+
+#define XMRFORMAT_IS_REMOVAL_DATE_VALID( plicenseXMRFORMAT )                           \
+    ( ( plicenseXMRFORMAT )->OuterContainer.fValid                                     \
+   && ( plicenseXMRFORMAT )->OuterContainer.GlobalPolicyContainer.fValid               \
+   && ( plicenseXMRFORMAT )->OuterContainer.GlobalPolicyContainer.RemovalDate.fValid )
+
+/*
+** Check if license should be disabled on clock rollback
+*/
+#define XMRFORMAT_HAS_TIME_BASED_RESTRICTIONS( plicenseXMRFORMAT )                                                  \
+    ( ( plicenseXMRFORMAT )->OuterContainer.fValid                                                                  \
+   && ( plicenseXMRFORMAT )->OuterContainer.GlobalPolicyContainer.fValid                                            \
+   && ( ( plicenseXMRFORMAT )->OuterContainer.GlobalPolicyContainer.Expiration.fValid                               \
+     || ( plicenseXMRFORMAT )->OuterContainer.GlobalPolicyContainer.ExpirationAfterUse.fValid ) )                   \
+
+#define XMRFORMAT_IS_EXPIRATION_DATE_VALID( plicenseXMRFORMAT )                                                     \
+    ( ( plicenseXMRFORMAT )->OuterContainer.GlobalPolicyContainer.Expiration.dwBeginDate != 0                       \
+   || ( plicenseXMRFORMAT )->OuterContainer.GlobalPolicyContainer.Expiration.dwEndDate   != XMR_UNLIMITED )         \
+
+#define XMRFORMAT_IS_AUX_KEY_VALID( plicenseXMRFORMAT )                                                             \
+    ( ( plicenseXMRFORMAT )->OuterContainer.fValid                                                                  \
+   && ( plicenseXMRFORMAT )->OuterContainer.KeyMaterialContainer.fValid                                             \
+   && ( plicenseXMRFORMAT )->OuterContainer.KeyMaterialContainer.AuxKeys.fValid )                                   \
+
+#define XMRFORMAT_IS_UPLINKX_VALID( plicenseXMRFORMAT )                                                             \
+    ( ( plicenseXMRFORMAT )->OuterContainer.fValid                                                                  \
+   && ( plicenseXMRFORMAT )->OuterContainer.KeyMaterialContainer.fValid                                             \
+   && ( plicenseXMRFORMAT )->OuterContainer.KeyMaterialContainer.UplinkX.fValid )                                   \
+
+#define XMRFORMAT_IS_LEAF_LICENSE( plicenseXMRFORMAT )                                                              \
+    ( XMRFORMAT_IS_UPLINK_KID_VALID( plicenseXMRFORMAT )                                                            \
+   || XMRFORMAT_IS_UPLINKX_VALID( plicenseXMRFORMAT ) )
+
+#define XMRFORMAT_IS_REAL_TIME_EXPIRATION_VALID( plicenseXMRFORMAT )                                                \
+    ( ( plicenseXMRFORMAT )->OuterContainer.fValid                                                                  \
+   && ( plicenseXMRFORMAT )->OuterContainer.GlobalPolicyContainer.fValid                                            \
+   && ( plicenseXMRFORMAT )->OuterContainer.GlobalPolicyContainer.RealTimeExpiration.fValid )
+
+EXIT_PK_NAMESPACE;
+
+#endif  /* __DRM_XMR_FORMAT_TYPES_H__ */
diff --git a/prebuilt-v4.4/noarch/include/etc/playready/bgroupcert.dat b/prebuilt-v4.4/noarch/include/etc/playready/bgroupcert.dat
new file mode 100644
index 0000000..e69de29
diff --git a/prebuilt-v4.4/noarch/include/etc/playready/zgpriv_protected.dat b/prebuilt-v4.4/noarch/include/etc/playready/zgpriv_protected.dat
new file mode 100644
index 0000000..e69de29
diff --git a/prebuilt-v4.4/noarch/include/oem/ansi/inc/oem.h b/prebuilt-v4.4/noarch/include/oem/ansi/inc/oem.h
new file mode 100644
index 0000000..4fce986
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/oem/ansi/inc/oem.h
@@ -0,0 +1,16 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __OEM_H__
+#define __OEM_H__
+
+#include <oemcommon.h>
+
+#include <oemplatform.h>
+
+#endif  /* __OEM_H__ */
diff --git a/prebuilt-v4.4/noarch/include/oem/ansi/inc/oemplatform.h b/prebuilt-v4.4/noarch/include/oem/ansi/inc/oemplatform.h
new file mode 100644
index 0000000..8ba2788
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/oem/ansi/inc/oemplatform.h
@@ -0,0 +1,71 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __OEMPLATFORM_H__
+#define __OEMPLATFORM_H__
+
+ENTER_PK_NAMESPACE;
+
+/* OEM critical sectiion function. */
+#if __MACINTOSH__
+#if DRM_64BIT_TARGET
+#define OEM_CRITICAL_SECTION_SIZE     8
+#else
+#define OEM_CRITICAL_SECTION_SIZE     4
+#endif
+#else
+#define OEM_CRITICAL_SECTION_SIZE     24
+#endif
+
+typedef struct __tagOEM_CRITICAL_SECTION
+{
+    DRM_BYTE rgb[ OEM_CRITICAL_SECTION_SIZE ];
+} OEM_CRITICAL_SECTION;
+
+/**********************************************************************
+** Function:    Oem_CritSec_Initialize
+** Synopsis:    Initializes critical section.
+** Arguments:   [f_pCS]--Pointer to OEM_CRITICAL_SECTION structure to be
+**              initialized.
+***********************************************************************/
+DRM_API DRM_RESULT DRM_CALL Oem_CritSec_Initialize(
+    __inout OEM_CRITICAL_SECTION *f_pCS );
+
+/**********************************************************************
+** Function:    Oem_CritSec_Delete
+** Synopsis:    Deletes existing critical section.
+** Arguments:   [f_pCS]--Pointer to OEM_CRITICAL_SECTION structure to be
+**              deleted.
+***********************************************************************/
+DRM_API DRM_RESULT DRM_CALL Oem_CritSec_Delete(
+    __inout OEM_CRITICAL_SECTION *f_pCS );
+
+/**********************************************************************
+** Function:    Oem_CritSec_Enter
+** Synopsis:    Enters critical section.
+** Arguments:   [f_pCS]--Pointer to OEM_CRITICAL_SECTION structure to be
+**              entered.
+***********************************************************************/
+DRM_API DRM_RESULT DRM_CALL Oem_CritSec_Enter(
+    __inout OEM_CRITICAL_SECTION *f_pCS );
+
+/**********************************************************************
+** Function:    Oem_CritSec_Leave
+** Synopsis:    Leaves critical section.
+** Arguments:   [f_pCS]--Pointer to OEM_CRITICAL_SECTION structure to be
+**              left.
+***********************************************************************/
+DRM_API DRM_RESULT DRM_CALL Oem_CritSec_Leave(
+    __inout OEM_CRITICAL_SECTION *f_pCS );
+
+DRM_API_VOID DRM_VOID DRM_CALL Oem_Test_Mem_Alloc_Check_Leakscan( DRM_VOID );
+DRM_API_VOID DRM_VOID DRM_CALL Oem_Test_Mem_Alloc_Clear_Leakscan( DRM_VOID );
+
+EXIT_PK_NAMESPACE;
+
+#endif  /* __OEMPLATFORM_H__ */
diff --git a/prebuilt-v4.4/noarch/include/oem/common/inc/bigdecls.h b/prebuilt-v4.4/noarch/include/oem/common/inc/bigdecls.h
new file mode 100644
index 0000000..9802472
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/oem/common/inc/bigdecls.h
@@ -0,0 +1,59 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+#ifndef BIGDECLS_H
+#define BIGDECLS_H 1
+
+ENTER_PK_NAMESPACE;
+
+/*
+** The assembly versions of these calls were hardcoded to use stdcall calling
+** DRM_API convention. For the C implementation we will use DRM_CALL as it is standard
+** throughout the porting kits.
+*/
+#if defined(_M_IX86) && DRM_SUPPORT_ASSEMBLY
+
+extern DRM_BOOL __stdcall mp_mul22s(const digit_t[4], digit_t *, digit_t *,
+                             const DRM_DWORD, sdigit_t[2]);
+
+extern DRM_BOOL __stdcall mp_mul22u(const digit_t[4], digit_t *, digit_t *,
+                             const DRM_DWORD,  digit_t[2] );
+
+extern DRM_VOID __stdcall multiply_low(
+    __in_ecount( lng )  const digit_t  *a,
+    __in_ecount( lng )  const digit_t  *b,
+    __out_ecount( lng )       digit_t  *c,
+    __in                const DRM_DWORD lng );
+
+#else
+
+DRM_API DRM_BOOL DRM_CALL mp_mul22s(
+ __in_ecount(4)        const digit_t    mat[4],       /* IN  (2 x 2 matrix of scalars) */
+ __inout_ecount(lvec)        digit_t   *vec1,         /* INOUT */
+ __inout_ecount(lvec)        digit_t   *vec2,         /* INOUT */
+ __in                  const DRM_DWORD  lvec,         /* IN */
+ __out_ecount(2)             sdigit_t   carrys[2] );  /* OUT  (array of 2 scalars) */
+
+DRM_API DRM_BOOL DRM_CALL mp_mul22u(
+   __in_ecount(4)       const digit_t   mat[4],       /* IN  (2 x 2 matrix of scalars) */
+   __inout_ecount(lvec)       digit_t  *vec1,         /* INOUT */
+   __inout_ecount(lvec)       digit_t  *vec2,         /* INOUT */
+   __in                 const DRM_DWORD lvec,         /* IN */
+   __out_ecount(2)            digit_t   carrys[2] );  /* OUT  (array of 2 scalars) */
+
+DRM_API_VOID DRM_VOID DRM_CALL multiply_low(
+    __in_ecount( lng )  const digit_t  *a,
+    __in_ecount( lng )  const digit_t  *b,
+    __out_ecount( lng )       digit_t  *c,
+    __in                const DRM_DWORD lng );
+
+#endif
+
+EXIT_PK_NAMESPACE;
+
+#endif /* BIGDECLS_H */
+
diff --git a/prebuilt-v4.4/noarch/include/oem/common/inc/bigdefs.h b/prebuilt-v4.4/noarch/include/oem/common/inc/bigdefs.h
new file mode 100644
index 0000000..4d48477
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/oem/common/inc/bigdefs.h
@@ -0,0 +1,341 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef BIGDEFS_H              /* If not previously #included */
+#define BIGDEFS_H 1
+
+/*
+**       File bigdefs.h     Version 10 February 2004
+**
+**       This file declared the fundamental types and constants used
+**       within the bignum code.
+**
+**           digit_t
+**           sdigit_t
+**
+**        used within the bignum code and headers.
+**        We also declare the most fundamental routines for operating on these.
+**
+**        If you need to perform arithmetic, not just copy data, see bignum.h .
+*/
+
+#include <drmerr.h>
+#include <oemcommonmem.h>
+
+ENTER_PK_NAMESPACE;
+
+/*
+** Occasionally a struct name is used before the struct itself is
+** declared.  The Future_Struct macro avoids a warning message
+** with Visual C .NET (2002).
+*/
+#define Future_Struct(strname) struct strname
+
+#define MP_SIGNIFICANT_BIT_COUNT_DRMBIGNUM_IMPL() DRM_DO {          \
+    DRM_DWORD lng_sig = 0;                                          \
+    lng_sig = significant_digit_count( a, lnga );                   \
+    if( lng_sig == 0 )                                              \
+    {                                                               \
+        return 0;                                                   \
+    }                                                               \
+    else                                                            \
+    {                                                               \
+        return ( (lng_sig - 1) * DRM_RADIX_BITS )                   \
+             + significant_bit_count(a[lng_sig-1]);                 \
+    }                                                               \
+} DRM_WHILE_FALSE
+
+
+#define SIGNIFICANT_BIT_COUNT_DRMBIGNUM_IMPL() DRM_DO {                                         \
+    digit_t dadj = d | 1;                                                                       \
+    DRM_DWORD width = DRM_RADIX_BITS;                                                           \
+    DRM_DWORD width_adj;                                                                        \
+    while( dadj < ( DRM_DIGIT_ONE << ( DRM_RADIX_BITS - 5 ) ) )                                 \
+    {                                                                                           \
+        width -= 5;                                                                             \
+        dadj <<= 5;                                                                             \
+    }                                                                                           \
+    dadj >>= ( DRM_RADIX_BITS - 4 );     /* From 0 to 15 */                                     \
+    /* Shift by 3*dadj, to index into array of octal digits */                                  \
+    width_adj = ((DRM_DWORD)0000000011112234 >> dadj) >> (2*dadj);                              \
+    return width - (width_adj & 7);   /* Subtract 5 - significant_bit_count(2*dadj + 1) */      \
+} DRM_WHILE_FALSE
+
+
+#define MP_EXTEND_DRMBIGNUM_IMPL() DRM_DO {                                                     \
+    if( lngb >= lnga )                                                                          \
+    {                                                                                           \
+        OEM_SECURE_DIGITTCPY( b, a, ( lnga ) );                                                 \
+        OEM_SECURE_ZERO_MEMORY( b + lnga, ( lngb - lnga ) * sizeof( digit_t ) );                \
+    }                                                                                           \
+    else                                                                                        \
+    {                                                                                           \
+        OEM_SECURE_DIGITTCPY( b, a, ( lngb ) );                                                 \
+    }                                                                                           \
+} DRM_WHILE_FALSE
+
+
+#define MP_GETBIT_DRMBIGNUM_IMPL() DRM_DO {                                                     \
+    return DRM_digit_getbit( a[ibit/DRM_RADIX_BITS], ibit % DRM_RADIX_BITS );                   \
+} DRM_WHILE_FALSE
+
+#define MP_SETBIT_DRMBIGNUM_IMPL() DRM_DO {                                                     \
+    const DRM_DWORD j       = ibit / DRM_RADIX_BITS;                                            \
+    const DRM_DWORD ishift  = ibit % DRM_RADIX_BITS;                                            \
+    const digit_t mask1 = (DRM_DIGIT_ONE &  new_value) << ishift;                               \
+    const digit_t mask2 = (DRM_DIGIT_ONE & ~new_value) << ishift;                               \
+    if( j < lnga )                                                                              \
+    {                                                                                           \
+        a[j] = (a[j] & ~mask2) | mask1;                                                         \
+    }                                                                                           \
+} DRM_WHILE_FALSE
+
+
+#define SIGNIFICANT_DIGIT_COUNT_DRMBIGNUM_IMPL() DRM_DO {   \
+    DRM_DWORD i = lng;                                      \
+    while( i != 0 && a[i-1] == 0 ) { i--; }                 \
+    return i;                                               \
+} DRM_WHILE_FALSE
+
+
+#if DRM_DWORDS_PER_DIGIT == 1
+#define DIGITS_TO_DWORDS_DRMBIGNUM_IMPL() DRM_DO { OEM_SECURE_DIGITTCPY( pbyte, pdigit, lng_dwords ); return TRUE; } DRM_WHILE_FALSE
+#define DWORDS_TO_DIGITS_DRMBIGNUM_IMPL() DRM_DO { OEM_SECURE_DIGITTCPY( pdigit, (digit_t*)pdword, lng_dwords ); return TRUE; } DRM_WHILE_FALSE
+#elif DRM_DWORDS_PER_DIGIT == 2
+#define DIGITS_TO_DWORDS_DRMBIGNUM_IMPL() DRM_DO {                                              \
+    const DRM_DWORD lng_half = lng_dwords >> 1;                                                 \
+    DRM_DWORD i;                                                                                \
+                                                                                                \
+    if (DRM_IS_ODD(lng_dwords))                                                                 \
+    {                                                                                           \
+        OEM_SECURE_DIGITTCPY(pbyte+(lng_dwords-1)*sizeof(DRM_DWORD), pdigit[lng_half], 1);      \
+    }                                                                                           \
+    for (i = 0; i != lng_half; i++)                                                             \
+    {                                                                                           \
+        const digit_t dig = pdigit[i];                                                          \
+        DRM_DWORD dwTmp = (DRM_DWORD)(dig >> DRM_RADIX_BITS);                                   \
+                                                                                                \
+        OEM_SECURE_DIGITTCPY(pbyte+2*i*sizeof(DRM_DWORD), &dig, 1);                             \
+        OEM_SECURE_DIGITTCPY(pbyte+(2*i+1)*sizeof(DRM_DWORD), &dwTmp, 1);                       \
+    }                                                                                           \
+    return TRUE;                                                                                \
+} DRM_WHILE_FALSE
+
+
+#define DWORDS_TO_DIGITS_DRMBIGNUM_IMPL() DRM_DO {                                              \
+    const DRM_DWORD lng_half = lng_dwords >> 1;                                                 \
+    DRM_DWORD i;                                                                                \
+                                                                                                \
+    if (DRM_IS_ODD(lng_dwords))                                                                 \
+    {                                                                                           \
+        pdigit[lng_half] = (digit_t)pdword[lng_dwords - 1];  /* Zero fill */                    \
+    }                                                                                           \
+    for (i = 0; i != lng_half; i++)                                                             \
+    {                                                                                           \
+        pdigit[i] = ((digit_t)pdword[2*i+1] << DRM_RADIX_BITS)                                  \
+                  |  (digit_t)pdword[2*i];                                                      \
+    }                                                                                           \
+    return TRUE;                                                                                \
+} DRM_WHILE_FALSE
+
+
+#else /* DRM_DWORDS_PER_DIGIT */
+#error "Unexpected DRM_DWORDS_PER_DIGIT"
+#endif /* DRM_DWORDS_PER_DIGIT */
+
+
+#if !DRM_INLINING_SUPPORTED
+
+DRM_API DRM_DWORD DRM_CALL significant_bit_count( __in const digit_t d );
+
+DRM_API DRM_DWORD DRM_CALL mp_significant_bit_count(
+    __in_ecount( lnga ) const digit_t   *a,
+    __in                const DRM_DWORD  lnga );
+
+DRM_API DRM_BOOL DRM_CALL digits_to_dwords(
+    __in_ecount( lng_dwords )                                                    const digit_t  *pdigit,
+    __inout_ecount_full( lng_dwords * sizeof( digit_t ) / DRM_DWORDS_PER_DIGIT )       DRM_BYTE *pbyte,
+    __in                                                                         const DRM_DWORD lng_dwords );
+
+DRM_API DRM_BOOL DRM_CALL dwords_to_digits(
+    __in_ecount( lng_dwords )    const DRM_DWORD  *pdword,
+    __inout_ecount( lng_dwords )       digit_t    *pdigit,
+    __in                         const DRM_DWORD   lng_dwords );
+
+DRM_API_VOID DRM_VOID DRM_CALL mp_extend(
+    __in_ecount( lnga )    const digit_t  *a,
+    __in                   const DRM_DWORD lnga,
+    __inout_ecount( lngb )       digit_t  *b,
+    __in                   const DRM_DWORD lngb );
+
+DRM_API digit_t DRM_CALL mp_getbit(
+    __in_ecount( ( ibit / DRM_RADIX_BITS ) + 1 ) const digit_t      *a,
+    __in                                         const DRM_DWORD     ibit );
+
+DRM_API_VOID DRM_VOID DRM_CALL mp_setbit(
+    __inout_ecount( lnga )       digit_t     *a,
+    __in                   const DRM_DWORD    lnga,
+    __in                   const DRM_DWORD    ibit,
+    __in                   const digit_t      new_value );
+
+_Post_satisfies_( return <= lng ) DRM_API DRM_DWORD DRM_CALL significant_digit_count(
+    __in_ecount( lng ) const digit_t  *a,
+    __in               const DRM_DWORD lng );
+
+#else  /* !DRM_INLINING_SUPPORTED */
+
+/*
+** Copy a to b, while changing its length from
+** lnga to lngb (zero fill).  Require lngb >= lnga.
+*/
+DRM_ALWAYS_INLINE DRM_VOID DRM_CALL mp_extend(
+    __in_ecount( lnga )    const digit_t  *a,
+    __in                   const DRM_DWORD lnga,
+    __inout_ecount( lngb )       digit_t  *b,
+    __in                   const DRM_DWORD lngb )
+{
+    MP_EXTEND_DRMBIGNUM_IMPL();
+}  /* mp_extend */
+/****************************************************************************/
+
+/* Extract bit of multiple precision number */
+DRM_ALWAYS_INLINE digit_t DRM_CALL mp_getbit(
+    __in_ecount( ( ibit / DRM_RADIX_BITS ) + 1 ) const digit_t      *a,
+    __in                                         const DRM_DWORD     ibit )
+{
+    MP_GETBIT_DRMBIGNUM_IMPL();
+}
+/****************************************************************************/
+/*
+** Set a bit to 0 or 1,
+** when the number is viewed as a bit array.
+*/
+DRM_ALWAYS_INLINE DRM_VOID DRM_CALL mp_setbit(
+    __inout_ecount(lnga)       digit_t     *a,
+                         const DRM_DWORD    lnga,
+                         const DRM_DWORD    ibit,
+                         const digit_t      new_value )
+{
+    MP_SETBIT_DRMBIGNUM_IMPL();
+} /* end mp_setbit */
+/****************************************************************************/
+/*
+** Return the number of significant digits in a.
+** Function value is zero precisely when a == 0.
+*/
+_Post_satisfies_( return <= lng ) DRM_ALWAYS_INLINE DRM_DWORD DRM_CALL significant_digit_count(
+    __in_ecount(lng) const digit_t   *a,
+    __in             const DRM_DWORD  lng )
+#if defined(_M_IX86) && DRM_SUPPORT_ASSEMBLY
+PRAGMA_WARNING_PUSH_WARN(4035)   /* No return value */
+{
+                /*
+                ** We could use REPE SCASD,
+                ** but the REPE overhead is
+                ** four cycles/compare on early Pentiums.
+                ** We would also need sld and cld.
+                ** It is shorter to use RISC instructions.
+                ** We anticipate that the leading term a[lng-1]
+                ** will usually be nonzero.
+                */
+
+    _asm {
+        mov  eax,lng
+        mov  edx,a
+     label1:
+        test eax,eax
+        jz   label2             ; If nothing left in number, return 0
+
+        mov  ecx,[edx+4*eax-4]
+        dec  eax
+
+        test ecx,ecx            ; Test leading digit
+        jz   label1
+
+        inc  eax                ; Nonzero element found; return old eax
+     label2:
+    }
+}
+PRAGMA_WARNING_POP
+#else /* defined(_M_IX86) && DRM_SUPPORT_ASSEMBLY */
+{
+    SIGNIFICANT_DIGIT_COUNT_DRMBIGNUM_IMPL();
+}  /* significant_digit_count */
+#endif  /* defined(_M_IX86) && DRM_SUPPORT_ASSEMBLY */
+/****************************************************************************/
+PREFAST_PUSH_DISABLE_EXPLAINED(__WARNING_COUNT_REQUIRED_FOR_WRITABLE_BUFFER, "pbyte length defined by lng_dwords")
+DRM_ALWAYS_INLINE DRM_BOOL DRM_CALL digits_to_dwords(
+    __in_ecount( lng_dwords )                                                    const digit_t  *pdigit,
+    __inout_ecount_full( lng_dwords * sizeof( digit_t ) / DRM_DWORDS_PER_DIGIT )       DRM_BYTE *pbyte,
+    __in                                                                         const DRM_DWORD lng_dwords )
+{
+    DIGITS_TO_DWORDS_DRMBIGNUM_IMPL();
+}  /* digits_to_dwords */
+PREFAST_POP
+/****************************************************************************/
+DRM_ALWAYS_INLINE DRM_BOOL DRM_CALL dwords_to_digits(
+    __in_ecount( lng_dwords )    const DRM_DWORD  *pdword,
+    __inout_ecount( lng_dwords )       digit_t    *pdigit,
+    __in                         const DRM_DWORD   lng_dwords )
+{
+    DWORDS_TO_DIGITS_DRMBIGNUM_IMPL();
+}  /* dwords_to_digits */
+
+#undef significant_bit_count    /* In case a macro version existed */
+/*
+**      Compute the number of significant bits in d.
+**      This is one more than the truncated base 2 logarithm of d.
+**      significant_bit_count(0)  is undefined.
+**
+**      For example, significant_bit_count(d) = 8 for 128 <= d <= 255.
+**
+**      On platforms which have a Count Leading Zeroes or
+**      similar instruction, UNIFORM_SIGNIFICANT_BIT_COUNT
+**      should be 1, with special code used.
+**      For other platforms, use this algorithm.
+**      The algorithm performs best when the argument is large,
+**      a feature used by the GCD routines.
+*/
+DRM_ALWAYS_INLINE DRM_DWORD DRM_CALL significant_bit_count( __in const digit_t d )
+{
+    SIGNIFICANT_BIT_COUNT_DRMBIGNUM_IMPL();
+} /* significant_bit_count */
+
+/*
+**      Return the number of significant bits in a, which
+**      is one more than the truncated base 2 logarithm of a.
+**      Return 0 if a == 0.
+*/
+DRM_ALWAYS_INLINE DRM_DWORD DRM_CALL mp_significant_bit_count(
+    __in_ecount( lnga ) const digit_t   *a,
+    __in                const DRM_DWORD  lnga )
+{
+    MP_SIGNIFICANT_BIT_COUNT_DRMBIGNUM_IMPL();
+}
+
+
+/****************************************************************************/
+#endif /* !DRM_INLINING_SUPPORTED */
+
+/*
+**      The application should define the
+**      following three malloc-like functions.
+**      Sample definitions appear in bigalloc.h.
+*/
+
+DRM_API_VOID DRM_VOID* DRM_CALL bignum_alloc(__in const DRM_DWORD cblen, __in struct bigctx_t *f_pBigCtx);
+DRM_API_VOID DRM_VOID  DRM_CALL bignum_free( __in DRM_VOID *pvMem, __inout struct bigctx_t *f_pBigCtx );
+DRM_API_VOID DRM_VOID* DRM_CALL bignum_alloc_align(__in const DRM_DWORD cblen,
+                                              __in const DRM_DWORD cbAlign,
+                                              __in struct bigctx_t *f_pBigCtx,
+                                              __out DRM_VOID **ppbBufferRaw);
+
+EXIT_PK_NAMESPACE;
+
+#endif /* BIGDEFS_H */
+
diff --git a/prebuilt-v4.4/noarch/include/oem/common/inc/bignum.h b/prebuilt-v4.4/noarch/include/oem/common/inc/bignum.h
new file mode 100644
index 0000000..31ac353
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/oem/common/inc/bignum.h
@@ -0,0 +1,684 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+#ifndef BIGNUM_H              /* If not previously #included */
+#define BIGNUM_H 1
+
+#include "bigdefs.h"
+
+/*
+** Expensive debugging adds some additional parameter checks,
+** such as whether a point is on the curve as expected
+** Note: This is currently unused in the PK
+*/
+#ifndef BIGNUM_EXPENSIVE_DEBUGGING
+#define BIGNUM_EXPENSIVE_DEBUGGING 0
+#endif
+
+#define MP_LONGEST_BITS 4096
+
+/*
+** Multiple precision moduli can have up to
+** MP_LONGEST_BITS bits, which is
+** MP_LONGEST words.  Some routines allow
+** longer operands.
+** 
+** Older codes have used this (and MP_LONGEST, below)
+** to dimension arrays.  New code should avoid
+** referencing MP_LONGEST and MP_LONGEST_BITS.
+*/
+
+#define MP_LONGEST  ( MP_LONGEST_BITS / DRM_RADIX_BITS )
+
+/*
+** DOUBLE_SHIFT_LEFT(n1, n0, amt) returns
+** n1 shifted left by amt bits,
+** with new bits coming in from the top of n0.
+**
+** DOUBLE_SHIFT_RIGHT(n1, n0, amt) returns n0 shifted right
+** by amt bits, with new bits coming from the bottom of n1.
+**
+** The shift counts must satisfy 0 <= amt <= DRM_RADIX_BITS - 1.
+** The shift by    DRM_RADIX_BITS - amt   is done in two stages
+** (first by 1, then by DRM_RADIX_BITS - 1 - amt),
+** to avoid an illegal shift count of DRM_RADIX_BITS when amt = 0.
+*/
+
+#define DOUBLE_SHIFT_LEFT(n1, n0, amt)      ( ( ( n1 ) << ( amt ) ) | ( ( ( n0 ) >> 1 ) >> ( DRM_RADIX_BITS - 1 - ( amt ) ) ) )
+#define DOUBLE_SHIFT_RIGHT(n1, n0, amt)     ( ( ( n0 ) >> ( amt ) ) | ( ( ( n1 ) << 1 ) << ( DRM_RADIX_BITS - 1 - ( amt ) ) ) )
+#define MP_GCDEX_NTEMPS( lnga, lngb )       ( 8 * DRM_MAX( ( lnga ), ( lngb ) ) + 6 )
+#define MP_INVERT_NTEMPS( lng )             ( ( lng ) + MP_GCDEX_NTEMPS( ( lng ), ( lng ) ) )
+
+#include "dblint.h"
+
+ENTER_PK_NAMESPACE;
+
+/*
+** Some struct names are referenced in #include files before they are
+** defined.  For example, there might be two struct definitions each
+** containing a pointer to the other struct type.
+** We list some struct names in advance here, to avoid warnings.
+*/
+Future_Struct(mp_modulus_t);      /* See this file */
+Future_Struct(digit_tempinfo_t);  /* See bigpriv.h */
+
+
+/*
+** The reciprocal_1_t type is used when div21
+** or divide or divide_immediate would otherwise
+** divide by the same number repeatedly.  See file divide.c.
+*/
+
+typedef struct {
+    digit_t    multiplier;
+    DRM_DWORD  shiftamt;
+} reciprocal_1_t;
+
+/*
+**     mp_modulus_t struct has modulus-dependent constants
+**     used for fast reduction (typically for a fixed modulus,
+**     which will be used several times, as in modular exponentiation).
+**     These constants are initialized by function create_modulus:
+**
+**     modulus : Modulus used for computations.  Must be nonzero.
+**
+**     length  : Length (>= 1) of the modulus, without leading zeros.
+**                Operands to mod_add, mod_mul, mod_sub, ...
+**                are assumed to have this length.
+**
+**     reddir  : Equal to FROM_LEFT if reductions of
+**                products are done from the left (traditional
+**                division), and to FROM_RIGHT if reductions of
+**                products are done from the right (Montgomery reduction).
+**
+**                When using FROM_RIGHT, the modulus must be odd.
+**                Arguments to mod_mul should be pre-scaled by
+**                2^scaling_power2 (mod modulus).
+**                The product will be similarly scaled.
+**
+**     scaling_power2 :  Equal to length*DRM_RADIX_BITS when reddir = FROM_RIGHT.
+**                Zero if reddir = FROM_LEFT.
+**
+**     one :     Constant 1 (muldiplicative identity), length length.
+**                Nmerical value is 2^scaling_power2 (mod modulus).
+** Denote
+**
+**           length = pmodulo->length
+**           modulus = pmodulo->modulus
+**           shiftamt = pmodulo->left_reciprocal_1.shiftamt.
+**
+**       Then
+**
+**           0 <= shiftamt < DRM_RADIX_BITS
+**           RADIX^length/2 <= modulus * 2^shiftamt < RADIX^length
+**           modulus < RADIX^length / 2^shiftamt <= 2*modulus
+**
+**       Some variants of modmul_algorithm use additional constants
+**       lngred2, multiplier_first, multiplier_second.
+**
+**       FROM_LEFT arithmetic, these constants satisfy
+**
+**           modulus * (multiplier_second + RADIX^lngred2)
+**         = RADIX^(length + lngred2) / 2^shiftamt + multiplier_first
+**
+**           0 <= multiplier_first < modulus
+**           0 <= multiplier_second < RADIX^lngred2
+**           lngred2 = CEIL(length/2)
+**
+**      For FROM_RIGHT arithmetic, these constants satisfy
+**
+**           multiplier_second * modulus
+**         = 1 + multiplier_first * RADIX^lngred2
+**
+**           0 <= multipler_first < modulus
+**           0 <= multiplier_second < RADIX^lngred2
+**           lngred2 = CEIL(length/2)
+**
+**     one :     Constant 1 (multiplicative identity).
+**                For FROM_LEFT arithmetic, pmodulo->one = 1.
+**                For FROM_RIGHT arithmetic,
+**                    pmodulo->one = (RADIX^length) % pmodulus;
+**
+**     left_reciprocal_1 : Reciprocal of the divisor starting at the
+**                leftmost digit (i.e., modulus[length-1]);
+**
+**                See file divide.c for an explanation
+**                about how this constant is used to get accurate
+**                quotients when dividing from the left.
+**
+**     right_reciprocal_1 : If modulus is odd, this holds
+**                1/modulus (mod RADIX), for use in mod_shift.
+**                Otherwise the field is zero.
+**
+**       Denote
+**
+**           length = pmodulo->length
+**           modulus = pmodulo->modulus
+**           shiftamt = pmodulo->left_reciprocal_1.shiftamt.
+**
+**       Then
+**
+**           0 <= shiftamt < DRM_RADIX_BITS
+**           RADIX^length/2 <= modulus * 2^shiftamt < RADIX^length
+**           modulus < RADIX^length / 2^shiftamt <= 2*modulus
+**
+**     modmul_algorithm :
+**           This library has a variety of codes for modular multiplication.
+**           The mp_modulus_t struct has a pointer to the precise code
+**           being used for a particular number and architecture.  A call
+**
+**                 (*modmul_algorithm)(a, b, c, pmodulo, temps)
+**
+**           is supposed to set
+**
+**                  c = a*b/3^(pmodulo->scaling_power2)  (mod pmodulo->modulus)
+**
+**           where 0 <= a, b, < pmodulo->modulus.
+**           The output c may overlap a or b.
+**
+**           The temps array will have at least pmodulo->modmul_algorithm_temps
+**           elements of type digit_t, aligned on a digit_t boundary.
+**
+**           The simplest modmul_algoriuthm procedures,
+**           modmul_from_left_default and modmul_from_right_default,
+**           work on all architectures.
+**
+**           In some implementations of this library, create_modulus may
+**           examine the precise modulus and the precise hardware
+**           we are running on, substituting another algorithm
+**           or an assembly language code.
+**
+**           Some variants of modmul_algorithm use additional constants
+**           lngred2, multiplier_first, multiplier_second.
+**           In FROM_LEFT arithmetic, these constants satisfy
+**
+**               modulus * (multiplier_second + RADIX^lngred2 + 1))
+**             = RADIX^(length + lngred2) / 2^shiftamt + multiplier_first
+**
+**               0 <= multiplier_first < modulus
+**               0 <= multiplier_second < RADIX^lngred2
+**               lngred2 = CEIL(length/2)
+**
+**          For FROM_RIGHT arithmetic, these constants satisfy
+**
+**               multiplier_second * modulus
+**             = 1 + multiplier_first * RADIX^lngred2
+**
+**               0 <= multipler_first < modulus
+**               0 <= multiplier_second < RADIX^lngred2
+**               lngred2 = CEIL(length/2)
+*/
+
+typedef DRM_BOOL DRM_CALL modmul_algorithm_t(
+    __in_ecount( pmodulo->length )        const digit_t             *a,
+    __in_ecount( pmodulo->length )        const digit_t             *b,
+    __out_ecount( pmodulo->length )             digit_t             *c,
+    __in_ecount( 1 )                      const struct mp_modulus_t *pmodulo,   /* note: ansi build requires using 'struct mp_modulus_t', not just 'mp_modulus_t' */
+    __inout_ecount( pmodulo->length * 2 )       digit_t             *temps );
+
+typedef enum {FROM_LEFT, FROM_RIGHT} reddir_t;
+
+typedef struct mp_modulus_t {
+                  DRM_DWORD  length;         /* Length passed to create_modulus*/
+                  DRM_DWORD  lngred2;        /* CEIL(length/2) */
+                  DRM_DWORD  modmul_algorithm_temps; /* Number of digit_t temps used by modmul_algorithm */
+                  DRM_LONG   scaling_power2; /* DRM_RADIX_BITS*length for FROM_RIGHT, 0 for FROM_LEFT */
+                  reddir_t  reddir;         /* FROM_LEFT or FROM_RIGHT */
+                  reciprocal_1_t  left_reciprocal_1;
+                  digit_t   right_reciprocal_1;  /* 1/modulus[0] mod RADIX, if modulus is odd */
+                  digit_t   *modulus;
+                  /* interesting fact: we do not use these two multiplier variables. */
+                  /* removing them, however, is very painful, */
+                  /* if someone is calling something from a stublib */
+                  /* with mp_modulus_t type, then removal will cause a bad break. */
+                  digit_t   *multiplier_first;  /* See text */
+                  digit_t   *multiplier_second; /* See text */
+                  digit_t   *one;               /* Multiplicative constant 1 */
+                  modmul_algorithm_t *modmul_algorithm;
+                                  /* Function pointer for multiplication */
+                } mp_modulus_t;
+
+
+/*
+** When an error is detected, the SetMpErrno_clue macro gets
+** an error code (below) and an English-language string
+** with more information.
+** This macro will normally call an application-supplied routine.
+** The application routine might print a message or set a global variable.
+** 
+** The library routine detecting the error will exit with return value
+** FALSE, notifying its caller that something abnormal occurred.
+** 
+** Except for MP_ERRNO_NO_ERROR, the error codes are
+** in alphabetical order.
+*/
+
+typedef enum
+{
+    MP_ERRNO_NO_ERROR = 0,          /* Success */
+    MP_ERRNO_DEGREE_OVERFLOW,       /* Polynomial degree too high for allocated memory */
+    MP_ERRNO_DIVIDE_ZERO,           /* Divide by zero (or by number with leading zero) */
+    MP_ERRNO_ELSEWHERE,             /* Error indicator returned by some routine which may not have called SetMpErrno_clue (e.g., CRYPTAPI library, assembly codes) */
+    MP_ERRNO_INTERNAL_ERROR,        /* Internal error found : please report */
+    MP_ERRNO_INVALID_DATA,          /* Invalid arguments */
+    MP_ERRNO_MODULAR_TOO_BIG,       /* Modular operand >= modulus */
+    MP_ERRNO_NO_MEMORY,             /* malloc failure */
+    MP_ERRNO_NOT_IMPLEMENTED,       /* Case not implemented */
+    MP_ERRNO_NOT_INVERTIBLE,        /* Perhaps trying to invert pmodulo non-prime */
+    MP_ERRNO_NOT_ON_CURVE,          /* Point is not on elliptic curve */
+    MP_ERRNO_NULL_POINTER,          /* NULL argument where valid argument expected */
+    MP_ERRNO_OVERFLOW,              /* Integer overflow (or unexpectedly negative) */
+    MP_ERRNO_OVERLAPPING_ARGS,      /* Overlapping (i.e., duplicate) arguments where they are disallowed */
+    MP_ERRNO_TOO_MANY_ITERATIONS,   /* e.g., unable to find large prime */
+    MP_ERRNO_ZERO_OPERAND,          /* Zero operand(s) where nonzero expected */
+    MP_ERRNO_COUNT                  /* Number of entries above */
+} mp_errno_t;
+
+#define SetMpErrno_clue(errcode, debug_info) DRM_DO { DRMCASSERT( errcode != 0 ); DRM_DBG_TRACE(( "Bignum Error %u  Clue \"%s\"", errcode, debug_info )); } DRM_WHILE_FALSE
+
+DRM_API digit_t DRM_CALL accumulate(
+    __in_ecount( lng )    const digit_t   *a,
+    __in                  const digit_t    mult,
+    __inout_ecount( lng )       digit_t   *b,
+    __in                  const DRM_DWORD  lng );
+
+DRM_API DRM_BOOL DRM_CALL add_diff(
+    __in_ecount( lnga ) const digit_t   *a,
+    __in                const DRM_DWORD  lnga,
+    __in_ecount( lngb ) const digit_t   *b,
+    __in                const DRM_DWORD  lngb,
+    __out_ecount( lnga )      digit_t   *c,
+    __out_ecount_opt( 1 )     digit_t   *pcarry );
+
+DRM_API DRM_BOOL DRM_CALL add_full(
+    __in_ecount( lnga )                         const digit_t   *a,
+    __in                                        const DRM_DWORD  lnga,
+    __in_ecount( lngb )                         const digit_t   *b,
+    __in                                        const DRM_DWORD  lngb,
+    __out_ecount( 1 + DRM_MAX( lnga, lngb ) )         digit_t   *c,
+    __out_ecount( 1 )                                 DRM_DWORD *plngc );
+
+DRM_API digit_t DRM_CALL add_immediate(
+    __in_ecount( lng ) const digit_t   *a,
+    __in               const digit_t    iadd,
+    __out_ecount( lng )      digit_t   *b,
+    __in               const DRM_DWORD  lng );
+
+DRM_API DRM_BOOL DRM_CALL add_mod(
+    __in_ecount( lng )   const digit_t   *a,
+    __in_ecount( lng )   const digit_t   *b,
+    __inout_ecount( lng )      digit_t   *c,
+    __in_ecount( lng )   const digit_t   *modulus,
+    __in                 const DRM_DWORD  lng );
+
+DRM_API_VOID digit_t DRM_CALL add_same(
+    __in_ecount( lng ) const digit_t   *a,
+    __in_ecount( lng ) const digit_t   *b,
+    __out_ecount( lng )      digit_t   *c,
+    __in               const DRM_DWORD  lng );
+
+DRM_API_VOID sdigit_t DRM_CALL add_sub_same(
+    __in_ecount( lng ) const digit_t   *a,
+    __in_ecount( lng ) const digit_t   *b,
+    __in_ecount( lng ) const digit_t   *c,
+    __out_ecount( lng )      digit_t   *d,
+    __in               const DRM_DWORD  lng );
+
+DRM_API DRM_LONG DRM_CALL compare_diff(
+    __in_ecount( lnga ) const digit_t   *a,
+    __in                const DRM_DWORD  lnga,
+    __in_ecount( lngb ) const digit_t   *b,
+    __in                const DRM_DWORD  lngb );
+
+DRM_API DRM_LONG DRM_CALL compare_same(
+    __in_ecount( lng ) const digit_t   *a,
+    __in_ecount( lng ) const digit_t   *b,
+    __in               const DRM_DWORD  lng );
+
+DRM_API DRM_LONG DRM_CALL compare_sum_diff(
+    __in_ecount( lnga ) const digit_t   *a,
+    __in                const DRM_DWORD  lnga,
+    __in_ecount( lngb ) const digit_t   *b,
+    __in                const DRM_DWORD  lngb,
+    __in_ecount( lngc ) const digit_t   *c,
+    __in                const DRM_DWORD  lngc );
+
+DRM_API DRM_LONG DRM_CALL compare_sum_same(
+    __in_ecount( lng ) const digit_t   *a,
+    __in_ecount( lng ) const digit_t   *b,
+    __in_ecount( lng ) const digit_t   *c,
+    __in               const DRM_DWORD  lng );
+
+DRM_API DRM_BOOL DRM_CALL create_modulus(
+    __in_ecount( lnga ) const digit_t           *a,
+    __in                const DRM_DWORD          lnga,
+    __in                const reddir_t           reddir,
+    __out_ecount( 1 )         mp_modulus_t      *pmodulo,
+    __inout                   struct bigctx_t   *f_pBigCtx,
+    __inout                   struct bigctx_t   *pbigctxGlobal );
+
+DRM_API digit_t DRM_CALL decumulate(
+    __in_ecount( lng )    const digit_t  *a,
+    __in                  const digit_t   mult,
+    __inout_ecount( lng )       digit_t  *b,
+    __in                  const DRM_DWORD lng );
+
+DRM_API digit_t* DRM_CALL digit_allocate(
+    __in           const DRM_DWORD   nelmt,
+    __inout struct bigctx_t         *f_pBigCtx );
+
+DRM_API DRM_BOOL DRM_CALL digit_ogcd(
+    __in              const digit_t  d1,
+    __in              const digit_t  d2,
+    __out_ecount( 1 )       digit_t *pgcd );
+
+DRM_API DRM_BOOL DRM_CALL div21(
+    __in              const DRM_UINT64   db,
+    __in              const digit_t      d,
+    __out_ecount( 1 )       digit_t     *quot,
+    __out_ecount( 1 )       digit_t     *rem );
+
+DRM_EXTERN_INLINE DRM_BOOL DRM_CALL div21_fast(
+    __in                const DRM_UINT64         db,
+    __in                const digit_t            d,
+    __in_ecount( 1 )    const reciprocal_1_t    *recip,
+    __out_ecount( 1 )         digit_t           *quot,
+    __out_ecount( 1 )         digit_t           *rem );
+
+
+DRM_NO_INLINE DRM_API DRM_BOOL DRM_CALL divide(
+    __in_ecount( lnum )                                                         const digit_t         *numer,
+    __in                                                                        const DRM_DWORD        lnum,
+    __in_ecount( lden )                                                         const digit_t         *denom,
+    __in                                                                        const DRM_DWORD        lden,
+    __in_ecount_opt( 1 )                                                        const reciprocal_1_t  *supplied_reciprocal,
+    __out_ecount_opt( DRM_MAX( ( (DRM_LONG)lnum - (DRM_LONG)lden ) + 1, 0 ) )         digit_t         *quot,
+    __out_ecount( lden )                                                              digit_t         *rem );
+
+DRM_NO_INLINE DRM_API DRM_BOOL DRM_CALL divide_precondition_1(
+    __in_ecount( lden ) const digit_t         *denom,
+    __in                const DRM_DWORD        lden,
+    __inout_ecount( 1 )       reciprocal_1_t  *recip );
+
+DRM_NO_INLINE DRM_API DRM_BOOL DRM_CALL divide_immediate(
+    __in_ecount( lng )       const digit_t         *numer,
+    __in                     const digit_t          den,
+    __in_ecount_opt( 1 )     const reciprocal_1_t  *supplied_reciprocal,
+    __out_ecount_opt( lng )        digit_t         *quot,
+    __in                     const DRM_DWORD        lng,
+    __out_ecount( 1 )              digit_t         *prem );
+
+DRM_EXTERN_INLINE digit_t DRM_CALL estimated_quotient_1(
+    __in             const digit_t         n2,
+    __in             const digit_t         n1,
+    __in             const digit_t         n0,
+    __in_ecount( 1 ) const reciprocal_1_t *recip );
+
+DRM_NO_INLINE DRM_API DRM_BOOL DRM_CALL from_modular(
+    __in_ecount( pmodulo->length )  const digit_t       *a,
+    __out_ecount( pmodulo->length )       digit_t       *b,
+    __in_ecount( 1 )                const mp_modulus_t  *pmodulo );
+
+DRM_API digit_t* DRM_CALL low_prime_prod_construction(
+    __inout           struct bigctx_t   *f_pBigCtx,
+    __out_ecount( 1 ) DRM_DWORD         *pclowprods );
+
+DRM_API_VOID DRM_VOID DRM_CALL low_prime_prod_destruction(
+    __in    digit_t         *lowprods,
+    __inout struct bigctx_t *f_pBigCtx );
+
+DRM_API DRM_BOOL DRM_CALL low_prime_divisibility(
+    __in_ecount( lng )          const digit_t           *array,
+    __in                        const DRM_DWORD          lng,
+    __in_ecount( clowprods )    const digit_t           *lowprods,
+    __in                        const DRM_DWORD          clowprods,
+    __out_ecount( 1 )                 digit_t           *pdivisor,
+    __inout                           struct bigctx_t   *f_pBigCtx );
+
+DRM_NO_INLINE DRM_API DRM_BOOL DRM_CALL mod_exp(
+    __in_ecount( modulo->length )   const digit_t           *base,
+    __in_ecount( modulo->length )   const digit_t           *exponent,
+    __in                            const DRM_DWORD          lngexpon,
+    __out_ecount( modulo->length )        digit_t           *answer,
+    __in_ecount( 1 )                const mp_modulus_t      *modulo,
+    __inout                               struct bigctx_t   *f_pBigCtx );
+
+DRM_API DRM_BOOL DRM_CALL mod_mul(
+    __in_ecount( pmodulo->length )                           const digit_t           *a,
+    __in_ecount( pmodulo->length )                           const digit_t           *b,
+    __out_ecount( pmodulo->length )                                digit_t           *c,
+    __in_ecount( 1 )                                         const mp_modulus_t      *pmodulo,
+    __inout_ecount_opt( pmodulo->modmul_algorithm_temps )          digit_t           *supplied_temps,
+    __inout                                                        struct bigctx_t   *f_pBigCtx );
+
+DRM_API DRM_BOOL DRM_CALL mod_shift(
+    __in_ecount( pmodulo->length )  const digit_t       *a,
+    __in                            const DRM_LONG       shiftamt,
+    __out_ecount( pmodulo->length )       digit_t       *b,
+    __in_ecount( 1 )                const mp_modulus_t  *pmodulo );
+
+DRM_API DRM_BOOL DRM_CALL mod_sqrt(
+    __in_ecount( modulo->length )    const digit_t           *base,
+    __inout_ecount( modulo->length )       digit_t           *answer,
+    __in_ecount( 1 )                 const mp_modulus_t      *modulo,
+    __out_ecount( 1 )                      DRM_BOOL          *pperfect_square,
+    __inout                                struct bigctx_t   *f_pBigCtx );
+
+#define Allocate_Temporaries(typename, ptr, ctx) \
+        Allocate_Temporaries_Multiple(1, typename, ptr, ctx)
+
+#define Allocate_Temporaries_Multiple(nelmt, typename, ptr, ctx) \
+               ptr = (typename*)bignum_alloc((nelmt)*sizeof(typename), f_pBigCtx)
+
+#define Free_Temporaries( ptr, ctx ) bignum_free( ptr, ctx )
+
+DRM_API DRM_BOOL DRM_CALL mp_gcdex(
+    __in_ecount( lnga )                             const digit_t           *a,
+    __in                                            const DRM_DWORD          lnga,
+    __in_ecount( lngb )                             const digit_t           *b,
+    __in                                            const DRM_DWORD          lngb,
+    __out_ecount( lngb )                                  digit_t           *ainvmodb,
+    __out_ecount_opt( lnga )                              digit_t           *binvmoda,
+    __out_ecount( DRM_MIN( lnga, lngb ) )                 digit_t           *gcd,
+    __out_ecount_opt( lnga + lngb )                       digit_t           *lcm,
+    __out_ecount( 1 )                                     DRM_DWORD         *plgcd,
+    __inout_ecount_opt( MP_GCDEX_NTEMPS( lnga, lngb ) )   digit_t           *supplied_temps,
+    __inout                                               struct bigctx_t   *f_pBigCtx );
+
+DRM_EXTERN_INLINE DRM_DWORD DRM_CALL mp_gcdex_ntemps(
+    __in const DRM_DWORD lnga,
+    __in const DRM_DWORD lngb );
+           /* Temporary count required by last argument to mp_gcdex */
+
+DRM_API DRM_BOOL DRM_CALL mp_initialization(
+    __inout struct bigctx_t    *f_pBigCtx );
+
+DRM_EXTERN_INLINE DRM_DWORD DRM_CALL mp_invert_ntemps( __in const DRM_DWORD );
+           /* Temporary count required by last argument to mp_invert */
+
+DRM_API DRM_BOOL DRM_CALL mp_invert(
+    __in_ecount( lng )                            const digit_t            *denom,
+    __in_ecount( lng )                            const digit_t            *modulus,
+    __in                                          const DRM_DWORD           lng,
+    __out_ecount( lng )                                 digit_t            *result,
+    __in_z_opt                                    const DRM_CHAR           *caller,
+    __inout_ecount_opt( MP_INVERT_NTEMPS( lng ) )       digit_t            *supplied_temps,
+    __inout                                             struct bigctx_t    *f_pBigCtx );
+
+DRM_API DRM_BOOL DRM_CALL mp_shift(
+    __in_ecount( lng )    const digit_t  *a,
+    __in                  const DRM_LONG  ishift,
+    __inout_ecount( lng )       digit_t  *b,
+    __in                  const DRM_DWORD lng );
+
+DRM_API DRM_BOOL DRM_CALL mp_shift_lost(
+    __in_ecount( lng )  const digit_t   *a,
+    __in                const DRM_LONG   shift_amt,
+    __out_ecount( lng )       digit_t   *b,
+    __in                const DRM_DWORD  lng,
+    __out_ecount( 1 )         digit_t   *plost );
+
+DRM_API digit_t DRM_CALL multiply_immediate(
+    __in_ecount( lng )  const digit_t    *a,
+    __in                const digit_t     mult,
+    __out_ecount( lng )       digit_t    *b,
+    __in                const DRM_DWORD   lng );
+
+DRM_API DRM_BOOL DRM_CALL neg_mod(
+    __in_ecount( lng ) const digit_t   *a,
+    __out_ecount( lng )      digit_t   *b,
+    __in_ecount( lng ) const digit_t   *modulus,
+    __in               const DRM_DWORD  lng );
+
+DRM_NO_INLINE DRM_API DRM_BOOL DRM_CALL set_immediate(
+    __out_ecount( lnga )       digit_t            *a,
+    __in                 const digit_t             ivalue,
+    __in                 const DRM_DWORD           lnga,
+    __inout                    struct bigctx_t    *f_pBigCtx );
+
+DRM_API DRM_BOOL DRM_CALL validate_modular_data(
+    __in_ecount( lng ) const digit_t   *data,
+    __in_ecount( lng ) const digit_t   *modulus,
+    __in               const DRM_DWORD  lng );
+
+#define MULTIPLY_DRMBIGNUM_IMPL() DRM_DO {                          \
+    DRM_BOOL OK = TRUE;                                             \
+    const digit_t *p1, *p2;                                         \
+    DRM_DWORD i, lng1, lng2;                                        \
+                                                                    \
+    if (lnga > lngb) /* Put longer operand in p1 */                 \
+    {                                                               \
+        p1 = a; p2 = b; lng1 = lnga; lng2 = lngb;                   \
+    }                                                               \
+    else                                                            \
+    {                                                               \
+        p2 = a; p1 = b; lng2 = lnga; lng1 = lngb;                   \
+    }                                                               \
+                                                                    \
+    if (!OK)                                                        \
+    {                                                               \
+        /* no-op */                                                 \
+    }                                                               \
+    else if (a == c || b == c)                                      \
+    {                                                               \
+        OK = FALSE;                                                 \
+    }                                                               \
+    else if (lng2 == 0)                                             \
+    {       /* If an operand has length zero */                     \
+        OEM_SECURE_ZERO_MEMORY( c, (lng1)*sizeof( digit_t ) );      \
+    }                                                               \
+    else                                                            \
+    {                                                               \
+        c[lng1] = multiply_immediate( p1, p2[0], c, lng1 );         \
+        for( i = 1; i != lng2; i++ )                                \
+        {                                                           \
+            c[i + lng1] = accumulate( p1, p2[i], &c[i], lng1 );     \
+        }                                                           \
+    }                                                               \
+    return OK;                                                      \
+} DRM_WHILE_FALSE
+
+#if !DRM_INLINING_SUPPORTED
+
+DRM_API DRM_BOOL DRM_CALL multiply(
+    __in_ecount( lnga )             const digit_t   *a,
+    __in                            const DRM_DWORD  lnga,
+    __in_ecount( lngb )             const digit_t   *b,
+    __in                            const DRM_DWORD  lngb,
+    __inout_ecount( lnga + lngb )         digit_t   *c );
+
+#else  /* !DRM_INLINING_SUPPORTED */
+
+/****************************************************************************/
+
+/*
+** Multiply a (length lnga) times b (length lngb),
+** getting a product c (length lnga + lngb).
+** The output should not overlap the inputs.
+*/
+DRM_ALWAYS_INLINE DRM_BOOL DRM_CALL multiply(
+    __in_ecount( lnga )             const digit_t   *a,
+    __in                            const DRM_DWORD  lnga,
+    __in_ecount( lngb )             const digit_t   *b,
+    __in                            const DRM_DWORD  lngb,
+    __inout_ecount( lnga + lngb )         digit_t   *c )
+{
+    MULTIPLY_DRMBIGNUM_IMPL();
+} /* multiply */
+
+#endif  /* !DRM_INLINING_SUPPORTED */
+
+#if DRM_INLINING_SUPPORTED && defined(_M_IX86) && DRM_SUPPORT_ASSEMBLY
+    #define significant_bit_count significant_bit_count_ix86
+    #define UNIFORM_SIGNIFICANT_BIT_COUNT 1
+    PRAGMA_WARNING_PUSH_WARN( 4035 )   /* No return value */
+    static DRM_ALWAYS_INLINE DRM_DWORD significant_bit_count(const digit_t pattern)
+    {
+    _asm {
+            mov  eax,pattern        ; Nonzero pattern
+            bsr  eax,eax            ; eax = index of leftmost nonzero bit
+            inc  eax                ; Add one to get significant bit count
+         }
+    }
+    PRAGMA_WARNING_POP
+#else /* DRM_INLINING_SUPPORTED && defined(_M_IX86) && DRM_SUPPORT_ASSEMBLY */
+    #define UNIFORM_SIGNIFICANT_BIT_COUNT 0
+           /* Algorithm faster for larger inputs.  See mpmisc.c */
+#endif /* DRM_INLINING_SUPPORTED && defined(_M_IX86) && DRM_SUPPORT_ASSEMBLY */
+
+DRM_API DRM_BOOL DRM_CALL sub_diff(
+    __in_ecount( lnga ) const digit_t   *a,
+    __in                const DRM_DWORD  lnga,
+    __in_ecount( lngb ) const digit_t   *b,
+    __in                const DRM_DWORD  lngb,
+    __out_ecount( lnga )      digit_t   *c,
+    __out_ecount_opt( 1 )     digit_t   *pborrow );
+
+DRM_API digit_t DRM_CALL sub_immediate(
+    __in_ecount( lng ) const digit_t   *a,
+    __in               const digit_t    isub,
+    __out_ecount( lng )      digit_t   *b,
+    __in               const DRM_DWORD  lng );
+
+DRM_API DRM_BOOL DRM_CALL sub_mod(
+    __in_ecount( lng ) const digit_t   *a,
+    __in_ecount( lng ) const digit_t   *b,
+    __out_ecount( lng )      digit_t   *c,
+    __in_ecount( lng ) const digit_t   *modulus,
+    __in               const DRM_DWORD  lng );
+
+DRM_API digit_t DRM_CALL sub_same(
+    __in_ecount( lng ) const digit_t   *a,
+    __in_ecount( lng ) const digit_t   *b,
+    __out_ecount( lng )      digit_t   *c,
+    __in               const DRM_DWORD  lng );
+
+DRM_NO_INLINE DRM_API DRM_BOOL DRM_CALL to_modular(
+    __in_ecount( lnga )             const digit_t            *a,
+    __in                            const DRM_DWORD           lnga,
+    __out_ecount( pmodulo->length )       digit_t            *b,
+    __in_ecount( 1 )                const mp_modulus_t       *pmodulo,
+    __inout_opt                           struct bigctx_t    *f_pBigCtx );
+
+DRM_API DRM_BOOL DRM_CALL two_adic_inverse(
+    __in                const digit_t  d,
+    __out_ecount( 1 )         digit_t *pdinv );
+
+DRM_API_VOID DRM_VOID DRM_CALL uncreate_modulus(
+    __inout mp_modulus_t    *pmodulo,
+    __inout struct bigctx_t *f_pBigCtx );
+
+DRM_API DRM_LONG DRM_CALL compare_immediate(
+    __in_ecount( lng ) const digit_t     *a,
+    __in               const digit_t      ivalue,
+    __in               const DRM_DWORD    lng );
+
+EXIT_PK_NAMESPACE;
+
+#include <bigdecls.h>
+
+#endif /* BIGNUM_H */
diff --git a/prebuilt-v4.4/noarch/include/oem/common/inc/bigpriv.h b/prebuilt-v4.4/noarch/include/oem/common/inc/bigpriv.h
new file mode 100644
index 0000000..9f08055
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/oem/common/inc/bigpriv.h
@@ -0,0 +1,72 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+#ifndef __BIGPRIV_H
+#define __BIGPRIV_H 1
+/*
+      File bigpriv.h.   Version 20 September, 2002
+
+      Declarations accessible to bignum library but invisible to application.
+      Also see fieldpriv.h
+*/
+
+#include "bignum.h"
+
+
+ENTER_PK_NAMESPACE;
+
+
+/*
+     Some routines allow the caller to supply temps, but
+     accept a NULL argument to say "Allocate them yourself!".
+     possible_digit_allocate assists in doing the allocate
+     if the caller passed NULL.
+*/
+
+typedef struct digit_tempinfo_t {
+    digit_t *address;       /* Address supplied by user. */
+                            /* Updated to specify address */
+                            /* to use for temporaries. */
+    DRM_DWORD nelmt;         /* Number of digit_t elements needed */
+    DRM_BOOL  need_to_free;  /* Should be set FALSE by application. */
+                            /* Changed to TRUE if a free is required. */
+} digit_tempinfo_t;
+
+DRM_API DRM_BOOL DRM_CALL possible_digit_allocate(
+    __inout_ecount( 1 ) digit_tempinfo_t        *tempinfo,
+    __inout             struct bigctx_t         *f_pBigCtx );
+
+DRM_API DRM_BOOL DRM_CALL modmul_choices1(
+    __inout_ecount( 1 )     mp_modulus_t *pmodulo,
+    __inout_ecount( 1 )     DRM_LONG     *pindex );
+
+DRM_API DRM_BOOL DRM_CALL modmul_from_right_default(
+    __in_ecount( pmodulo->length )        const digit_t       *a,
+    __in_ecount( pmodulo->length )        const digit_t       *b,
+    __out_ecount( pmodulo->length )             digit_t       *c,
+    __in_ecount( 1 )                      const mp_modulus_t  *pmodulo,
+    __inout_ecount( pmodulo->length * 2 )       digit_t       *temps );
+
+DRM_API DRM_BOOL DRM_CALL modmul_from_right_default_modulo8(
+    __in_ecount( pmodulo->length )        const digit_t       *a,
+    __in_ecount( pmodulo->length )        const digit_t       *b,
+    __out_ecount( pmodulo->length )             digit_t       *c,
+    __in_ecount( 1 )                      const mp_modulus_t  *pmodulo,
+    __inout_ecount( pmodulo->length * 2 )       digit_t       *temps );
+
+#define LNGQ_MODULO_8  8
+DRM_NO_INLINE DRM_API DRM_BOOL DRM_CALL modmul_from_right_default_modulo8_P256(
+    __in_ecount( pmodulo->length )        const digit_t       *a,
+    __in_ecount( pmodulo->length )        const digit_t       *b,
+    __out_ecount( pmodulo->length )             digit_t       *c,
+    __in_ecount( 1 )                      const mp_modulus_t  *pmodulo,
+    __inout_ecount( pmodulo->length * 2 )       digit_t       *temps );
+
+EXIT_PK_NAMESPACE;
+
+
+#endif  /*  __BIGPRIV_H */
diff --git a/prebuilt-v4.4/noarch/include/oem/common/inc/dblint.h b/prebuilt-v4.4/noarch/include/oem/common/inc/dblint.h
new file mode 100644
index 0000000..a59f67f
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/oem/common/inc/dblint.h
@@ -0,0 +1,184 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef DBLINT_H
+#define DBLINT_H 1
+
+#include <drmtypes.h>
+
+#if defined(_M_IX86) || defined(_M_AMD64)
+
+#ifdef __cplusplus
+extern "C"
+#endif
+unsigned __int64 __emulu(
+   unsigned int a,
+   unsigned int b
+);
+
+PRAGMA_INTRINSIC(__emulu)
+
+#endif  /* defined(_M_IX86) || defined(_M_AMD64) */
+
+ENTER_PK_NAMESPACE;
+
+/*
+**      File: dblint.h.  Supplement to bignum.h.  Version 10 December, 2002.
+**
+**      This file has declarations related to double-precision integers,
+**      such as typedefs, constants, and primitive operations.
+**
+**      The DRM_UINT64 type is unsigned and holds twice as many bits
+**      as a digit_t datum.  If (DRM_SUPPORT_NATIVE_64BIT_TYPES = 1), then use the type
+**      already in the language.  Otherwise (DRM_SUPPORT_NATIVE_64BIT_TYPES = 0)
+**      construct one of our own, using a struct with two digit_t fields.
+**
+**      Let u, u1, u2 have type digit_t and
+**      d, d1, d2 have type DRM_UINT64.
+**      The following primitives are defined,
+**      whether we use the built-in type or our own type:
+**
+**              DPRODUU(u1, u2) -- Product of u1 and u2, as a DRM_UINT64.
+**              HPRODUU(u1, u2) -- Most significant half of product
+**                                 of u1 and u2, as a digit_t.
+*/
+
+#if DRM_SUPPORT_NATIVE_64BIT_TYPES
+
+#if defined (DRM_MSC_VER)
+
+/*
+** Note: it seems that for Arm platform this should be moved to just (DWORD)u1*(DWORD)u2.
+** DRM_UI64(u1) * DRM_UI64(u2) on x86&x64 produces a [slow]  __allmul call.
+** which can be very miserable for mod_exp and other functions which use lots of this.
+*/
+
+#if defined(_M_IX86) || defined(_M_AMD64)
+#define DPRODUU(u1, u2) __emulu((u1), (u2))
+#else
+#define DPRODUU(u1, u2) (DRM_UI64(u1) * DRM_UI64(u2))
+#endif
+
+#else /* DRM_MSC_VER */
+
+#define DPRODUU(u1, u2) (DRM_UI64(u1) * DRM_UI64(u2))
+
+#endif /* DRM_MSC_VER */
+
+#define MULTIPLY_ADD1(d1, d2, d3) \
+        DRM_UI64Add(DRM_UI64(d3), DPRODUU(d1, d2))
+           /* d1*d2 + d3 */
+
+#define MULTIPLY_ADD2(d1, d2, d3, d4) \
+        DRM_UI64Add(DPRODUU(d1, d2), DRM_UI64Add(DRM_UI64(d4), DRM_UI64(d3)))
+          /* d1*d2 + d3 + d4 */
+
+#define HPRODUU(u1, u2) DRM_UI64High32(DRM_UI64Mul(DRM_UI64((u1)), DRM_UI64((u2))))
+
+#else  /* DRM_SUPPORT_NATIVE_64BIT_TYPES */
+
+/* No native support for 64-bit types */
+
+#if defined( _M_AMD64_ )
+    PRAGMA_INTRINSIC(__umulh)
+    #define HPRODUU(u1, u2) __umulh(u1, u2)
+#else
+    #define HPRODUU(u1, u2) DRM_UI64High32(DRM_UI64Mul(DRM_UI64((u1)), DRM_UI64((u2))))
+#endif
+
+#if !DRM_INLINING_SUPPORTED
+
+DRM_API DRM_UINT64 DRM_CALL DPRODUU(const digit_t, const digit_t);
+DRM_API DRM_UINT64 DRM_CALL MULTIPLY_ADD1(const digit_t, const digit_t, const digit_t);
+DRM_API DRM_UINT64 DRM_CALL MULTIPLY_ADD2(const digit_t, const digit_t,
+                                            const digit_t, const digit_t);
+
+
+#else /* !DRM_INLINING_SUPPORTED */
+
+#if DRM_SUPPORT_NATIVE_64BIT_TYPES
+#define ADDSame64_32( p64, v32 ) \
+    *p64 += v32;
+
+#else
+#define ADDSame64_32( p64, v32 )    \
+    (p64)->val[0] += v32;            \
+    (p64)->val[1] += (p64)->val[0] < v32;
+
+#endif
+
+/*
+**      Multiply two single-precision operands,
+**      return double precision product.
+**      This will normally be replaced by an assembly language routine.
+**      unless the top half of the product (HPRODUU) is available in C.
+*/
+DRM_ALWAYS_INLINE DRM_UINT64 DRM_CALL DPRODUU(const digit_t u1, const digit_t u2) DRM_ALWAYS_INLINE_ATTRIBUTE;
+DRM_ALWAYS_INLINE DRM_UINT64 DRM_CALL DPRODUU(const digit_t u1, const digit_t u2)
+{
+    DRM_UINT64 t;
+    DRM_WORD u1h = (DRM_WORD)( u1 >> 16 );
+    DRM_WORD u2h = (DRM_WORD)( u2 >> 16 );
+    DRM_WORD u1l = (DRM_WORD)u1;
+    DRM_WORD u2l = (DRM_WORD)u2;
+    digit_t t2 = (digit_t)u1h * u2l;
+    digit_t t3 = (digit_t)u1l * u2h;
+    digit_t t23l = ( t2 & 0xffff ) + ( t3 & 0xffff );
+    digit_t t23h = ( t2 >> 16 ) + ( t3 >> 16 );
+    digit_t a = t23l << 16;
+    digit_t u12l = (digit_t) u1l * u2l + a;
+
+#if DRM_SUPPORT_NATIVE_64BIT_TYPES
+    t = DRM_UI64HL(
+          (digit_t)u1h * u2h
+        + t23h
+        + (t23l>>16)
+        + (a > u12l), u12l);
+#else
+    t.val[0] = u12l;
+    t.val[1] =
+          (digit_t)u1h * u2h
+        + t23h
+        + ( t23l >> 16 )
+        + ( a > u12l );
+#endif
+    return t;
+}   /* end DPRODUU */
+
+/*
+**  The MULTIPLY_ADD1. MULTIPLY_ADD2
+**  functions take single-length (digit_t) operands and
+**  return double-length (DRM_UINT64) results.
+**  Overflow is impossible.
+*/
+DRM_ALWAYS_INLINE DRM_UINT64 DRM_CALL MULTIPLY_ADD1(const digit_t d1, const digit_t d2, const digit_t d3) DRM_ALWAYS_INLINE_ATTRIBUTE;
+DRM_ALWAYS_INLINE DRM_UINT64 DRM_CALL MULTIPLY_ADD1(const digit_t d1, const digit_t d2, const digit_t d3)
+{
+    DRM_UINT64 t = DPRODUU(d1,d2);
+    ADDSame64_32(&t, d3);
+    return t;
+} /* MULTIPLY_ADD1 */
+
+
+DRM_ALWAYS_INLINE DRM_UINT64 DRM_CALL MULTIPLY_ADD2(const digit_t d1, const digit_t d2, const digit_t d3, const digit_t d4) DRM_ALWAYS_INLINE_ATTRIBUTE;
+DRM_ALWAYS_INLINE DRM_UINT64 DRM_CALL MULTIPLY_ADD2(const digit_t d1, const digit_t d2, const digit_t d3, const digit_t d4)
+{
+    DRM_UINT64 t = DPRODUU(d1,d2);
+    ADDSame64_32(&t, d3);
+    ADDSame64_32(&t, d4);
+    return t;
+} /* MULTIPLY_ADD2 */
+
+#endif /* !DRM_INLINING_SUPPORTED */
+
+#endif /* DRM_SUPPORT_NATIVE_64BIT_TYPES */
+
+EXIT_PK_NAMESPACE;
+
+#endif /* DBLINT_H */
+
diff --git a/prebuilt-v4.4/noarch/include/oem/common/inc/ecurve.h b/prebuilt-v4.4/noarch/include/oem/common/inc/ecurve.h
new file mode 100644
index 0000000..85e262d
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/oem/common/inc/ecurve.h
@@ -0,0 +1,196 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+#ifndef ECURVE_H
+#define ECURVE_H 1
+#include <bignum.h>
+#include <bigpriv.h>
+#include <field.h>
+
+ENTER_PK_NAMESPACE;
+
+Future_Struct(ecurve_t);
+
+#define DRM_ECURVE_TABLE_SPACING_MAX 7
+
+typedef struct ecurve_t {
+             const field_desc_t     *fdesc;
+             digit_t           *a;
+             digit_t           *b;
+             digit_t        *generator;  /* Generator of cyclic group */
+                                            /* (affine form, x and y) */
+             digit_t           *gorder;     /* Order of cyclic group */
+             digit_t           *deallocate;
+             DRM_BOOL               free_field; /* Flag telling ec_free to call */
+                                            /* Kfree.  For system use only. */
+             DRM_BOOL               biszero;    /* Is b == 0? */
+             DRM_DWORD           ndigtemps;  /* Number of digit_t temporaries */
+                                            /* needed by EC */
+                                            /* addition/subtraction routines: */
+                                            /* */
+                                            /*     ecaffine_addition */
+                                            /*     ecaffine_addition_subtraction */
+                                            /*     ecaffine_on_curve */
+                                            /*     ecaffine_PPQ */
+                                            /*     ecaffine_random */
+                                            /* */
+                                            /* Includes enough for a */
+                                            /* multiplication or inversion */
+                                            /* (or Kmuladd, etc.) */
+                                            /* in the base field. */
+} ecurve_t;
+
+#define ECPROJ5_TEMPS_COUNT 10
+
+/*
+** This number (MAX_ECTEMPS) was 5, but has been increased to 8
+** because we have gone from 160bit to 256 bit encryption
+** and this assumes that the minimum size of digit_t/digit_t
+** types is a 32 bit type
+**
+** Maximum number of field temporaries needed
+** by any EC addition/subtraction/doubling routine,
+** including
+**
+**     ecaffine_addition,
+**     ecaffine_addition_subtraction
+**     ecaffine_on_curve
+**     ecaffine_PPQ
+**     ecaffine_random
+*/
+#define MAX_ECTEMPS 8
+
+DRM_API DRM_BOOL DRM_CALL ecaffine_addition(
+    __in_ecount( 2 * E->fdesc->elng )                                    const digit_t           *p1,
+    __in_ecount( 2 * E->fdesc->elng )                                    const digit_t           *p2,
+    __out_ecount( 2 * E->fdesc->elng )                                         digit_t           *p3,
+    __in                                                                 const DRM_LONG           addsub,
+    __in_ecount( 1 )                                                     const ecurve_t          *E,
+    __inout_ecount_opt( 3 * E->fdesc->elng
+                        + DRM_MAX( E->fdesc->ndigtemps_invert1,
+                                   E->fdesc->ndigtemps_mul ) )                 digit_t           *supplied_temps,
+    __inout                                                                    struct bigctx_t   *f_pBigCtx );
+
+DRM_API DRM_BOOL DRM_CALL ecaffine_addition_subtraction(
+    __in_ecount( 2 * E->fdesc->elng )                              const digit_t           *p1,
+    __in_ecount( 2 * E->fdesc->elng )                              const digit_t           *p2,
+    __out_ecount( 2 * E->fdesc->elng )                                   digit_t           *psum,
+    __out_ecount( 2 * E->fdesc->elng )                                   digit_t           *pdif,
+    __in_ecount( 1 )                                               const ecurve_t          *E,
+    __inout_ecount( 5 * E->fdesc->elng
+                  + DRM_MAX( DRM_MAX( E->fdesc->ndigtemps_invert1,
+                                      E->fdesc->ndigtemps_mul ),
+                             E->ndigtemps ) )                            digit_t           *supplied_temps,
+    __inout                                                              struct bigctx_t   *f_pBigCtx );
+
+DRM_NO_INLINE DRM_API DRM_BOOL DRM_CALL ecaffine_exponentiation(
+    __in_ecount( 2 * E->fdesc->elng )       const digit_t           *P0,
+    __in_ecount( lng_exponent )             const digit_t           *exponent,
+    __in                                    const DRM_DWORD          lng_exponent,
+    __out_ecount( 2 * E->fdesc->elng )            digit_t           *Presult,
+    __in_ecount( 1 )                        const ecurve_t          *E,
+    __inout                                       struct bigctx_t   *f_pBigCtx );
+
+DRM_API DRM_BOOL DRM_CALL ecaffine_is_infinite(
+    __in_ecount( 2 * E->fdesc->elng ) const digit_t           *p1,
+    __in_ecount( 1 )                  const ecurve_t          *E,
+    __inout_opt                             struct bigctx_t   *f_pBigCtx );
+
+DRM_API DRM_BOOL DRM_CALL ecaffine_multiply_pm1(
+    __in_ecount( 2 * E->fdesc->elng )  const digit_t           *p1,
+    __out_ecount( 2 * E->fdesc->elng )       digit_t           *p2,
+    __in                               const DRM_LONG           negate_flag,
+    __in_ecount( 1 )                   const ecurve_t          *E,
+    __inout                                  struct bigctx_t   *f_pBigCtx );
+
+DRM_API DRM_BOOL DRM_CALL ecaffine_negate(
+    __in_ecount( 2 * E->fdesc->elng )  const digit_t           *p1,
+    __out_ecount( 2 * E->fdesc->elng )       digit_t           *p2,
+    __in_ecount( 1 )                   const ecurve_t          *E,
+    __inout                                  struct bigctx_t   *f_pBigCtx );
+
+DRM_API DRM_BOOL DRM_CALL ecaffine_on_curve(
+    __in_ecount( 2 * E->fdesc->elng )  const digit_t           *p1,
+    __in_ecount( 1 )                   const ecurve_t          *E,
+    __in_z_opt                         const DRM_CHAR          *pdebug_info,
+    __inout_ecount_opt( E->ndigtemps )       digit_t           *supplied_temps,
+    __inout                                  struct bigctx_t   *f_pBigCtx );
+
+DRM_API DRM_BOOL DRM_CALL ecaffine_PPQ(
+    __in_ecount( 2 * E->fdesc->elng )                                                   const digit_t           *P,
+    __in_ecount( 2 * E->fdesc->elng )                                                   const digit_t           *Q,
+    __out_ecount( 2 * E->fdesc->elng )                                                        digit_t           *PPQ,
+    __in                                                                                const DRM_LONG           pm1,     /* +- 1 */
+    __in_ecount( 1 )                                                                    const ecurve_t          *E,
+    __inout_ecount( DRM_MAX( 3 * E->fdesc->elng + E->ndigtemps,
+                             4 * E->fdesc->elng + DRM_MAX( E->fdesc->ndigtemps_invert1,
+                                                           E->fdesc->ndigtemps_mul ) ) )      digit_t           *supplied_temps,
+    __inout                                                                                   struct bigctx_t   *f_pBigCtx );
+
+DRM_API DRM_BOOL DRM_CALL ecaffine_set_infinite(
+    __out_ecount( 2 * E->fdesc->elng )        digit_t           *p1,
+    __in_ecount( 1 )                    const ecurve_t          *E,
+    __inout                                   struct bigctx_t   *f_pBigCtx );
+
+DRM_API DRM_BOOL DRM_CALL ec_initialize(
+    __in_ecount( fdesc->elng )  const digit_t       *a,
+    __in_ecount( fdesc->elng )  const digit_t       *b,
+    __in_ecount( 1 )            const field_desc_t  *fdesc,
+    __out_ecount( 1 )                 ecurve_t      *E,
+    __inout                    struct bigctx_t      *f_pBigCtx,
+    __inout                    struct bigctx_t      *pbigctxGlobal );
+
+DRM_API DRM_BOOL DRM_CALL ec_free(
+    __inout ecurve_t        *E,
+    __inout struct bigctx_t *f_pBigCtx );
+
+DRM_NO_INLINE DRM_API DRM_BOOL DRM_CALL ecaffine_exponentiation_tabular(
+    __in_ecount( lexpon * DRM_RADIX_BITS )  const digit_t           *Pbase_powers,
+    __in                                    const DRM_DWORD          table_spacing,
+    __in                                    const DRM_DWORD          table_last,
+    __in_ecount( lexpon )                   const digit_t           *exponent,
+    __in                                    const DRM_DWORD          lexpon,
+    __out_ecount( 2 * ecurve->fdesc->elng )       digit_t           *result,
+    __in_ecount( 1 )                        const ecurve_t          *ecurve,
+    __inout                                       struct bigctx_t   *f_pBigCtx );
+
+DRM_NO_INLINE DRM_API DRM_BOOL DRM_CALL ecaffine_table_construction(
+    __in_ecount( 2 * ecurve->fdesc->elng )                          const digit_t           *p0,
+    __in                                                            const DRM_DWORD          table_spacing,
+    __in                                                            const DRM_DWORD          table_last,
+    __out_ecount( 2 * ecurve->fdesc->elng * ( table_last + 1 ) )          digit_t           *table,
+    __in_ecount( 1 )                                                const ecurve_t          *ecurve,
+    __inout                                                               struct bigctx_t   *f_pBigCtx );
+
+DRM_BOOL DRM_CALL ecaffine_to_ecproj5(
+    __in_ecount( 2 * ecurve->fdesc->elng )  const digit_t           *p1,
+    __out_ecount( 5 * ecurve->fdesc->elng )       digit_t           *p2,
+    __in_ecount( 1 )                        const ecurve_t          *ecurve,
+    __inout                                       digit_t           *p5temps,
+    __inout                                       struct bigctx_t   *f_pBigCtx );
+
+DRM_BOOL DRM_CALL ecproj5_add_ecproj5(
+    __in_ecount( 5 * ecurve->fdesc->elng )                      const digit_t           *p1,
+    __in_ecount( 5 * ecurve->fdesc->elng )                      const digit_t           *p2,
+    __out_ecount( 5 * ecurve->fdesc->elng )                           digit_t           *psum,
+    __in_ecount( 1 )                                            const ecurve_t          *ecurve,
+    __inout_ecount( ECPROJ5_TEMPS_COUNT * ecurve->fdesc->elng
+                  + ecurve->fdesc->ndigtemps_mul )                    digit_t           *p5temps,
+    __inout                                                           struct bigctx_t   *f_pBigCtx );
+
+DRM_BOOL DRM_CALL ecproj5_to_ecaffine(
+    __in_ecount( 5 * ecurve->fdesc->elng )                      const digit_t           *p1,
+    __out_ecount( 2 * ecurve->fdesc->elng )                           digit_t           *p2,
+    __in_ecount( 1 )                                            const ecurve_t          *ecurve,
+    __inout_ecount( ECPROJ5_TEMPS_COUNT * ecurve->fdesc->elng
+                  + DRM_MAX( ecurve->fdesc->ndigtemps_invert1,
+                             ecurve->fdesc->ndigtemps_mul ) )         digit_t           *p5temps,
+    __inout                                                           struct bigctx_t   *f_pBigCtx );
+
+EXIT_PK_NAMESPACE;
+
+#endif /* ECURVE_H */
diff --git a/prebuilt-v4.4/noarch/include/oem/common/inc/field.h b/prebuilt-v4.4/noarch/include/oem/common/inc/field.h
new file mode 100644
index 0000000..c59eeb9
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/oem/common/inc/field.h
@@ -0,0 +1,293 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+#ifndef __FIELD_H
+#define __FIELD_H 1
+#include <bignum.h>
+
+ENTER_PK_NAMESPACE;
+
+/*
+**      This file defines field_desc_t, a struct representing a field.
+**      The data structures allow
+**      GF(2^m) or GF(q) (with multiple precision q).
+**      finite-degree extensions.
+**
+**      The letter `K' is often used in mathematics
+**      to denote a field.  We use names like Kadd
+**      for field addition, since the name `Fadd'
+**      suggests a floating point addition routine.
+**
+**      A field element is an array of type digit_t.
+**      The elng element of the field_sesc_t struct tells its length
+**
+**  Arithmetic routines:
+**
+**      Kadd(f1, f2, f3, &fdesc) :: f3 = f1 + f2
+**      Kdiv(f1, f2, f3, &fdesc, ftemps) :: f3 = f1 / f2
+**                          Array of fdesc->ndigtemps_arith temps supplied
+**      Kequal (f1, f2,  &fdesc) :: Is f1 == f2?
+**      Kimmediate(scalar, f1, &fdesc) :: f1 = scalar (a signed digit_t)
+**      Kinvert(f1, f2,  &fdesc, ftemps) :: f2 = 1/f1
+**                          Array of fdesc->ndigtemps_invert1 supplied
+**      Kiszero(f1,      &fdesc) :: Is f1 == 0?
+**      Kmulpower2(f1, ishift, f3, fdesc) :: f3 = f1 * 2^ishift
+**      Kmul(f1, f2, f3, &fdesc) :: f3 = f1 * f2
+**      Kmul(f1, f2, f3, &fdesc, ftemps) :: f3 = f1*f2,
+**                      Array of fdesc->ndigtemps_mul temps supplied
+**      Kmuladd(f1, f2, f3, f4, &fdesc, ftemps) :: f4 = f1 * f2 + f3
+**                          Array of fdesc->ndigtemps_arith temps supplied
+**      Knegate(f1, f2,  &fdesc) :: f2 = -f1
+**      Ksqrt(f1, f2,    &fdesc) :: f2 = sqrt(f1) (either root)
+**      Ksub(f1, f2, f3, &fdesc) :: f3 = f1 - f2
+**
+**  Miscellaneous routines:
+**
+**      Kclear_many(f1, nelmt,    &fdesc)   :: Set nelmt elements to zero.
+**      Kfree  (&fdesc)                     :: Free any memory malloc-ed when field was initialized.
+**      Kinitalize_normal2(m, T, &fdesc)    :: Initialize for normal basis.
+**
+**      Kinitialize_prime(&modulus, &fdesc) :: Initialize field with prime modulus.
+*/
+
+typedef enum {FIELD_TYPE_INVALID = 0,
+              FIELD_Q_MP,          /* Field mod multiple-precision prime q */
+              FIELD_2_NORMAL,      /* Field GF(2^m) with normal basis over GF(2) */
+              FIELD_2_POLYNOMIAL}  /* Field GF(2^m) with polynomial basis over GF(2) */
+           field_type_t;
+
+#define CHARACTERISTIC_2(fdesc) ((fdesc)->ftype >= FIELD_2_NORMAL)      /* Test for characteristic 2 field. */
+
+typedef digit_t flongest_t[MP_LONGEST];
+
+/* Special GF(2^m) fields defined by sparse polynomials. */
+
+Future_Struct(field_desc_t);
+
+#define Kadd_many(f1, f2, f3, nelmt, fdesc, ctx) \
+        (Kprime_adder ((f1), (f2), (f3), (nelmt), (fdesc), ctx))
+#define Kclear_many(      f3, nelmt, fdesc, ctx) \
+        (Kzeroizer_default  ((f3), (nelmt), (fdesc), ctx))
+#define Kequal_many(f1, f2,   nelmt, fdesc, ctx) \
+        (Kequaler_default   ((f1), (f2), (nelmt), (fdesc), ctx))
+#define Kimmediate_many(sarray, f3, nelmt, fdesc, ctx) \
+        (Kprime_immediater((sarray), (f3), (nelmt), (fdesc), ctx))
+#define Kiszero_many(f1,      nelmt, fdesc, ctx) \
+        (Kiszeroer_default  ((f1), (nelmt), (fdesc), ctx))
+#define Kmulpower2_many(f1, ishift, f3, nelmt, fdesc, ctx) \
+        (Kprime_mulpower2er ( (f1), (ishift), (f3), (nelmt), (fdesc), ctx))
+#define Knegate_many(f1,  f3, nelmt, fdesc, ctx) \
+        (Kprime_negater   ((f1), (f3), (nelmt), (fdesc), ctx))
+#define Ksqrt_many(f1,    f3, nelmt, fdesc, are_squares, ctx) \
+        (Kprime_sqrter((f1), (f3), (nelmt), (fdesc), (are_squares), ctx))
+#define Ksub_many(f1, f2, f3, nelmt, fdesc, ctx) \
+        (Kprime_subtracter ((f1), (f2), (f3), (nelmt), (fdesc), ctx))
+
+
+#define Kadd(f1, f2, f3, fdesc, ctx)   \
+        Kadd_many(   (f1), (f2), (f3), 1, (fdesc), ctx)
+#define Kequal(f1, f2,   fdesc, ctx)   \
+        Kequal_many( (f1), (f2),       1, (fdesc), ctx)
+
+#define Kiszero(f1,      fdesc, ctx)   \
+        Kiszero_many((f1),             1, (fdesc), ctx)
+#define Kmulpower2(f1, ishift, f3, fdesc, ctx)\
+        Kmulpower2_many((f1), (ishift), (f3), 1, (fdesc), ctx)
+#define Knegate(f1,  f3, fdesc, ctx)   \
+        Knegate_many((f1),       (f3), 1, (fdesc), ctx)
+#define Ksqrt(f1,    f3, fdesc, is_square, ctx)  \
+        Ksqrt_many(  (f1),       (f3), 1, (fdesc), (is_square), ctx)
+#define Ksub(f1, f2, f3, fdesc, ctx)   \
+        Ksub_many(   (f1), (f2), (f3), 1, (fdesc), ctx)
+
+
+typedef struct field_desc_t {
+          DRM_DWORD     elng;   /* Length of each field element, in digit_t's*/
+          DRM_DWORD     degree; /* Extension degree m if GF(2^m)*/
+                               /* Also used for extension fields*/
+          DRM_DWORD     ndigtemps_arith;  /* Number of digit_t temporaries*/
+                                         /* adequate for any of the following:*/
+
+                                         /*   (use subfield->ndigtemps_arith)*/
+                                         /* Kdiv*/
+                                         /* Kinvert*/
+                                         /* Kinvert_many*/
+                                         /* Kmul*/
+                                         /* Kmuladd*/
+          DRM_DWORD     ndigtemps_mul;
+                               /* Number of digit_t temporaries*/
+                               /* needed for a multiplication.*/
+          DRM_DWORD     ndigtemps_invert1;
+                               /* Number of digit_t temporaries*/
+                               /* needed for an inversion.*/
+          field_type_t ftype;  /* Type of base field*/
+          DRM_BOOL         free_modulus;   /* If TRUE, Kfree frees*/
+                                       /* the modulo field.*/
+                                       /* Can be set by application.*/
+          digit_t      *one;   /* Constant 1*/
+          digit_t      *deallocate;
+
+/* Next items apply only if ftype = FIELD_Q_MP*/
+          const mp_modulus_t *modulo;      /* Information about q*/
+          digit_t *inverse_adjustment;
+                                      /* Multiplier to adjust reciprocal*/
+                                      /* for FROM_RIGHT arithmetic*/
+
+} field_desc_t;
+
+
+DRM_API DRM_BOOL DRM_CALL Kdiv(
+    __in_ecount( fdesc->elng )               const digit_t          *f1,
+    __in_ecount( fdesc->elng )               const digit_t          *f2,
+    __out_ecount( fdesc->elng )                    digit_t          *f3,
+    __in_ecount( 1 )                         const field_desc_t     *fdesc,
+    __inout_ecount( fdesc->ndigtemps_arith )       digit_t          *supplied_temps,
+    __inout                                        struct bigctx_t  *f_pBigCtx );
+
+DRM_API DRM_BOOL DRM_CALL Kfree(
+    __inout_ecount( 1 ) field_desc_t    *fdesc,
+    __inout             struct bigctx_t *f_pBigCtx );
+
+DRM_API DRM_BOOL DRM_CALL Kimmediate(
+    __in                        const sdigit_t           scalar,
+    __out_ecount( fdesc->elng )       digit_t           *f3,
+    __in_ecount( 1 )            const field_desc_t      *fdesc,
+    __inout                           struct bigctx_t   *f_pBigCtx );
+
+DRM_API DRM_BOOL DRM_CALL Kinitialize_prime(
+    __in_ecount( 1 )  const mp_modulus_t    *modulo,
+    __out_ecount( 1 )       field_desc_t    *fdesc,
+    __inout                 struct bigctx_t *pbigctxTemp,
+    __inout                 struct bigctx_t *f_pBigCtx );
+
+DRM_API DRM_BOOL DRM_CALL Kinvert(
+    __in_ecount( fdesc->elng )                  const digit_t           *f1,
+    __out_ecount( fdesc->elng )                       digit_t           *f3,
+    __in_ecount( 1 )                            const field_desc_t      *fdesc,
+    __inout_ecount( fdesc->ndigtemps_invert1 )        digit_t           *supplied_temps,
+    __inout                                           struct bigctx_t   *f_pBigCtx );
+
+DRM_API DRM_BOOL DRM_CALL Kinvert_many(
+    __in_ecount( nelmt * fdesc->elng )       const digit_t          *f1,
+    __out_ecount( nelmt * fdesc->elng )            digit_t          *f3,
+    __in                                     const DRM_DWORD         nelmt,
+    __in_ecount( 1 )                         const field_desc_t     *fdesc,
+    __inout_ecount( fdesc->ndigtemps_arith )       digit_t          *supplied_temps,
+    __inout                                        struct bigctx_t  *f_pBigCtx );
+
+#define Kmul(f1, f2, f3, fdesc, temps, ctx) Kmul_many((f1), (f2), (f3), 1, (fdesc), (temps), ctx)
+
+DRM_API DRM_BOOL DRM_CALL Kmul_many(
+    __in_ecount( nelmt * fdesc->elng )                          const digit_t           *f1,
+    __in_ecount( nelmt * fdesc->elng )                          const digit_t           *f2,
+    __out_ecount( nelmt * fdesc->elng )                               digit_t           *f3,
+    __in                                                        const DRM_DWORD          nelmt,
+    __in_ecount( 1 )                                            const field_desc_t      *fdesc,
+    __inout_ecount_opt( fdesc->ndigtemps_mul )                        digit_t           *supplied_temps,
+    __inout                                                           struct bigctx_t   *f_pBigCtx );
+
+DRM_API DRM_BOOL DRM_CALL Kmuladd(
+    __in_ecount( fdesc->elng )                               const digit_t          *f1,
+    __in_ecount( fdesc->elng )                               const digit_t          *f2,
+    __in_ecount( fdesc->elng )                               const digit_t          *f3,
+    __out_ecount( fdesc->elng )                                    digit_t          *f4,
+    __in_ecount( 1 )                                         const field_desc_t     *fdesc,
+    __inout_ecount_opt( fdesc->elng + fdesc->ndigtemps_mul )       digit_t          *supplied_temps,
+    __inout                                                        struct bigctx_t  *f_pBigCtx );
+
+DRM_API DRM_BOOL DRM_CALL Kprime_sqrter(
+    __in_ecount( nelmt * fdesc->elng )  const digit_t           *f1,
+    __out_ecount( nelmt * fdesc->elng )       digit_t           *f3,
+    __in                                const DRM_DWORD          nelmt,
+    __in_ecount( 1 )                    const field_desc_t      *fdesc,
+    __out_ecount( 1 )                         DRM_BOOL          *psquares,
+    __inout                                   struct bigctx_t   *f_pBigCtx );
+
+DRM_NO_INLINE DRM_API DRM_BOOL DRM_CALL Kprime_adder(
+    __in_ecount( nelmt * fdesc->elng )  const digit_t           *f1,
+    __in_ecount( nelmt * fdesc->elng )  const digit_t           *f2,
+    __out_ecount( nelmt * fdesc->elng )       digit_t           *f3,
+    __in                                const DRM_DWORD          nelmt,
+    __in_ecount( 1 )                    const field_desc_t      *fdesc,
+    __inout                                   struct bigctx_t   *f_pBigCtx );
+
+DRM_NO_INLINE DRM_API DRM_BOOL DRM_CALL Kprime_freer(
+    __inout_ecount( 1 ) field_desc_t    *fdesc,
+    __inout             struct bigctx_t *f_pBigCtx );
+
+DRM_NO_INLINE DRM_API DRM_BOOL DRM_CALL Kprime_immediater(
+    __in_ecount( nelmt )                const sdigit_t          *scalars,
+    __out_ecount( nelmt * fdesc->elng )       digit_t           *f3,
+    __in                                const DRM_DWORD          nelmt,
+    __in_ecount( 1 )                    const field_desc_t      *fdesc,
+    __inout                                   struct bigctx_t   *f_pBigCtx );
+
+DRM_NO_INLINE DRM_API DRM_BOOL DRM_CALL Kprime_inverter1(
+    __in_ecount( fdesc->elng )  const digit_t           *f1,
+    __out_ecount( fdesc->elng )       digit_t           *f3,
+    __in_ecount( 1 )            const field_desc_t      *fdesc,
+    __in_ecount( 1 )            const digit_tempinfo_t  *tempinfo,
+    __inout                           struct bigctx_t   *f_pBigCtx );
+
+DRM_NO_INLINE DRM_API DRM_BOOL DRM_CALL Kprime_mulpower2er(
+    __in_ecount( nelmt * fdesc->elng )  const digit_t           *f1,
+    __in                                const DRM_LONG           ishift,
+    __out_ecount( nelmt * fdesc->elng )       digit_t           *f3,
+    __in                                const DRM_DWORD          nelmt,
+    __in_ecount( 1 )                    const field_desc_t      *fdesc,
+    __inout                                   struct bigctx_t   *f_pBigCtx );
+
+DRM_NO_INLINE DRM_API DRM_BOOL DRM_CALL Kprime_multiplier1(
+    __in_ecount( fdesc->modulo->length )                        const digit_t           *f1,
+    __in_ecount( fdesc->modulo->length )                        const digit_t           *f2,
+    __out_ecount( fdesc->modulo->length )                             digit_t           *f3,
+    __in_ecount( 1 )                                            const field_desc_t      *fdesc,
+    __inout_ecount_opt( fdesc->modulo->modmul_algorithm_temps )       digit_t           *temps,
+    __inout                                                           struct bigctx_t   *f_pBigCtx );
+
+DRM_NO_INLINE DRM_API DRM_BOOL DRM_CALL Kprime_negater(
+    __in_ecount( nelmt * fdesc->elng )  const digit_t           *f1,
+    __out_ecount( nelmt * fdesc->elng )       digit_t           *f3,
+    __in                                const DRM_DWORD          nelmt,
+    __in_ecount( 1 )                    const field_desc_t      *fdesc,
+    __inout                                   struct bigctx_t   *f_pBigCtx );
+
+DRM_NO_INLINE DRM_API DRM_BOOL DRM_CALL Kprime_sizer(
+    __out_ecount( fdesc->elng + 1 )           digit_t           *size,
+    __in_ecount( 1 )                    const field_desc_t      *fdesc,
+    __inout                                   struct bigctx_t   *f_pBigCtx );
+
+DRM_NO_INLINE DRM_API DRM_BOOL DRM_CALL Kprime_subtracter(
+    __in_ecount( nelmt * fdesc->elng )  const digit_t           *f1,
+    __in_ecount( nelmt * fdesc->elng )  const digit_t           *f2,
+    __out_ecount( nelmt * fdesc->elng )       digit_t           *f3,
+    __in                                const DRM_DWORD          nelmt,
+    __in_ecount( 1 )                    const field_desc_t      *fdesc,
+    __inout                                   struct bigctx_t   *f_pBigCtx );
+
+DRM_API DRM_BOOL DRM_CALL Kequaler_default(
+    __in_ecount( nelmt * fdesc->elng )  const digit_t           *f1,
+    __in_ecount( nelmt * fdesc->elng )  const digit_t           *f2,
+    __in                                const DRM_DWORD          nelmt,
+    __in_ecount( 1 )                    const field_desc_t      *fdesc,
+    __inout_opt                               struct bigctx_t   *f_pBigCtx );
+
+DRM_API DRM_BOOL DRM_CALL Kiszeroer_default(
+    __in_ecount( nelmt * fdesc->elng )  const digit_t           *f1,
+    __in                                const DRM_DWORD          nelmt,
+    __in_ecount( 1 )                    const field_desc_t      *fdesc,
+    __inout_opt                               struct bigctx_t   *f_pBigCtx );
+
+DRM_API DRM_BOOL DRM_CALL Kzeroizer_default(
+    __out_ecount( nelmt * fdesc->elng )       digit_t           *f3,
+    __in                                const DRM_DWORD          nelmt,
+    __in_ecount( 1 )                    const field_desc_t      *fdesc,
+    __inout_opt                               struct bigctx_t   *f_pBigCtx );
+
+EXIT_PK_NAMESPACE;
+
+#endif /* __FIELD_H */
diff --git a/prebuilt-v4.4/noarch/include/oem/common/inc/fieldpriv.h b/prebuilt-v4.4/noarch/include/oem/common/inc/fieldpriv.h
new file mode 100644
index 0000000..cf7fcc9
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/oem/common/inc/fieldpriv.h
@@ -0,0 +1,29 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+/*
+      File fieldpriv.h.   Version 20 September 2002
+
+      Declarations for field routines which the application program
+      doesn't need to know about.
+*/
+
+#ifndef __FIELDPRIV_H
+#define __FIELDPRIV_H 1
+#include "bigpriv.h"
+#include "field.h"
+
+ENTER_PK_NAMESPACE;
+
+DRM_API DRM_BOOL DRM_CALL Kfdesc_initialize(
+    __inout_ecount( 1 )       field_desc_t      *fdesc,
+    __in                const DRM_DWORD          nalloc,
+    __inout                   struct bigctx_t   *f_pBigCtx );
+
+EXIT_PK_NAMESPACE;
+
+#endif /* __FIELDPRIV_H */
diff --git a/prebuilt-v4.4/noarch/include/oem/common/inc/mprand.h b/prebuilt-v4.4/noarch/include/oem/common/inc/mprand.h
new file mode 100644
index 0000000..bc53310
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/oem/common/inc/mprand.h
@@ -0,0 +1,61 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+/*      File mprand.h */
+
+#ifndef _MPRAND_H
+#define _MPRAND_H
+
+#include "bignum.h"
+
+ENTER_PK_NAMESPACE;
+
+DRM_NO_INLINE DRM_API DRM_BOOL DRM_CALL random_bytes(
+    __out_bcount( nbyte )         DRM_BYTE          *byte_array,
+    __in                    const DRM_DWORD          nbyte,
+    __inout                       struct bigctx_t   *f_pBigCtx );
+         /* Procedure to be supplied by application. */
+
+
+DRM_API DRM_BOOL DRM_CALL random_digits(
+    __out_ecount( lng )       digit_t           *dtArray,
+    __in                const DRM_DWORD          lng,
+    __inout                   struct bigctx_t   *f_pBigCtx );
+
+
+/* Following are extern on all platforms */
+
+DRM_NO_INLINE DRM_API DRM_BOOL DRM_CALL random_digit_interval(
+    __in                 const digit_t   dlow,
+    __in                 const digit_t   dhigh,
+    __out_ecount( 1 )          digit_t  *pdout,
+    __out               struct bigctx_t *f_pBigCtx );
+          /* Generate random digit_t or DRM_DWORD in specified closed interval. */
+
+DRM_API DRM_BOOL DRM_CALL random_mod(
+    __in_ecount( lng )  const digit_t           *n,
+    __out_ecount( lng )       digit_t           *arr,
+    __in                const DRM_DWORD          lng,
+    __inout                   struct bigctx_t   *f_pBigCtx );
+
+/*
+** Checked stublib expects the function name to be new_random_mod_nonzero
+** Temporary fix.
+*/
+#define random_mod_nonzero new_random_mod_nonzero
+DRM_API DRM_BOOL DRM_CALL random_mod_nonzero(
+    __in_ecount( lng )  const digit_t           *n,
+    __out_ecount( lng )       digit_t           *arr,
+    __in                const DRM_DWORD          lng,
+    __inout                   struct bigctx_t   *f_pBigCtx );
+                        /* Generate random value modulo another value.
+                           random_mod_nonzero generates a nonzero value. */
+
+EXIT_PK_NAMESPACE;
+
+#endif   /* _MPRAND_H */
diff --git a/prebuilt-v4.4/noarch/include/oem/common/inc/oemaes.h b/prebuilt-v4.4/noarch/include/oem/common/inc/oemaes.h
new file mode 100644
index 0000000..f04964d
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/oem/common/inc/oemaes.h
@@ -0,0 +1,43 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+/*
+**  oemaes.h
+**
+**  Contains structures and function definitions implemented in oemaes.c
+**
+*/
+
+#ifndef __OEMAES_H__
+#define __OEMAES_H__
+
+#include <oemaeskey.h>
+#include <oemaesimpl.h>
+#include <oemaescommon.h>
+#include <oemaesmulti.h>
+
+ENTER_PK_NAMESPACE;
+
+DRM_API DRM_RESULT DRM_CALL Oem_Aes_ZeroKey(
+    __inout_ecount( 1 )                      DRM_AES_KEY  *f_pKey );
+
+DRM_API DRM_RESULT DRM_CALL Oem_Aes_SetKey(
+    __in_bcount( DRM_AES_KEYSIZE_128 ) const DRM_BYTE      f_rgbKey[ DRM_AES_KEYSIZE_128 ],
+    __out_ecount( 1 )                        DRM_AES_KEY  *f_pAesKey ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_API DRM_RESULT DRM_CALL Oem_Aes_EncryptOne(
+    __in_ecount( 1 )                   const DRM_AES_KEY  *f_pKey,
+    __inout_bcount( DRM_AES_BLOCKLEN )       DRM_BYTE      f_rgbData[ DRM_AES_BLOCKLEN ] ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_API DRM_RESULT DRM_CALL Oem_Aes_DecryptOne(
+    __in_ecount( 1 )                   const DRM_AES_KEY  *f_pKey,
+    __inout_bcount( DRM_AES_BLOCKLEN )       DRM_BYTE      f_rgbData[ DRM_AES_BLOCKLEN ] ) DRM_NO_INLINE_ATTRIBUTE;
+
+EXIT_PK_NAMESPACE;
+
+#endif /* __OEMAES_H__ */
diff --git a/prebuilt-v4.4/noarch/include/oem/common/inc/oemaescommon.h b/prebuilt-v4.4/noarch/include/oem/common/inc/oemaescommon.h
new file mode 100644
index 0000000..1b0a8d3
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/oem/common/inc/oemaescommon.h
@@ -0,0 +1,67 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+/*
+**  oemaescommon.h
+**
+**  Contains common definitions used by OEM AES implementations as well as
+**  AES API functions.
+**
+*/
+
+
+#ifndef __OEMAESCOMMON_H__
+#define __OEMAESCOMMON_H__
+
+#include <drmtypes.h>
+#include <drmpragmas.h>
+
+ENTER_PK_NAMESPACE;
+
+/*
+** AES Key Sizes
+*/
+#define DRM_AES_KEYSIZE_128    16   /* Size ( in bytes ) of a 128 bit key */
+#define DRM_AES_KEYSIZE_192    24   /* Size ( in bytes ) of a 192 bit key */
+#define DRM_AES_KEYSIZE_256    32   /* Size ( in bytes ) of a 256 bit key */
+#define DRM_AES_KEYSIZE_128_X2 ( DRM_AES_KEYSIZE_128 * 2 )
+#define DRM_AES_MAXKEYSIZE     DRM_AES_KEYSIZE_256
+
+/*
+** Round counts corresponding to key sizes
+*/
+#define DRM_AES_ROUNDS_128    10
+#define DRM_AES_ROUNDS_192    12
+#define DRM_AES_ROUNDS_256    14
+#define DRM_AES_MAXROUNDS     DRM_AES_ROUNDS_256
+
+#define DRM_AES_BLOCKLEN                 DRM_AES_KEYSIZE_128    /* Size ( in bytes ) of a single encrypted/decrypted block */
+#define DRM_AES_ROUNDS                   DRM_AES_ROUNDS_128
+#define DRM_AES128OMAC1_SIZE_IN_BYTES    DRM_AES_BLOCKLEN
+
+/*
+** Supported cipher modes for AES encryption/decryption
+*/
+typedef enum
+{
+    eDRM_AES_CTR_MODE  = 1,
+    eDRM_AES_ECB_MODE  = 2,
+    eDRM_AES_CBC_MODE  = 3
+} DRM_AES_SUPPORTED_MODES;
+
+typedef struct
+{
+    DRM_UINT64  qwInitializationVector;
+    DRM_UINT64  qwBlockOffset;
+    DRM_BYTE    bByteOffset;  /* Byte offset within the current block */
+} DRM_AES_COUNTER_MODE_CONTEXT;
+
+EXIT_PK_NAMESPACE;
+
+#endif /* __OEMAESCOMMON_H__ */
+
diff --git a/prebuilt-v4.4/noarch/include/oem/common/inc/oemaesimpl.h b/prebuilt-v4.4/noarch/include/oem/common/inc/oemaesimpl.h
new file mode 100644
index 0000000..75f2b1a
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/oem/common/inc/oemaesimpl.h
@@ -0,0 +1,51 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+/*
+**  oemaesimpl.h
+**
+**  Contains AES secret key and key table definitions used in the oem aes implementation, and
+**  to create an opaque aes key structure in oemaes.h
+**
+*/
+
+#ifndef __OEMAESIMPL_H__
+#define __OEMAESIMPL_H__
+
+#include <drmerr.h>
+#include <oemaescommon.h>
+
+ENTER_PK_NAMESPACE;
+
+/*
+** AES Key Table structures
+*/
+typedef struct
+{
+    DRM_DWORD   keytabenc[DRM_AES_ROUNDS_128+1][4];
+    DRM_DWORD   keytabdec[DRM_AES_ROUNDS_128+1][4];
+} DRM_AESTable_128;
+
+#define DRM_AESTable          DRM_AESTable_128
+#define DRM_AES_TABLESIZE     sizeof( DRM_AESTable )
+
+/*
+** Internal AES secret key
+*/
+typedef struct
+{
+    DRM_AESTable   AESTable;
+    DRM_BYTE   rgbKey[ DRM_AES_KEYSIZE_128 ];
+} INTERNAL_DRM_AES_KEY;
+
+#define DRM_AES_KEYSTRUCTSIZE  sizeof( INTERNAL_DRM_AES_KEY )
+
+
+EXIT_PK_NAMESPACE;
+
+#endif /* __OEMAESIMPL_H__ */
diff --git a/prebuilt-v4.4/noarch/include/oem/common/inc/oemaeskey.h b/prebuilt-v4.4/noarch/include/oem/common/inc/oemaeskey.h
new file mode 100644
index 0000000..e9f9e2e
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/oem/common/inc/oemaeskey.h
@@ -0,0 +1,39 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+/*
+**  oemaes.h
+**
+**  Contains the key structure for AES
+**
+*/
+
+#ifndef __OEMAESKEY_H__
+#define __OEMAESKEY_H__
+
+#include <oemaesimpl.h>
+
+ENTER_PK_NAMESPACE;
+
+/*
+** AES secret key
+**
+** The actual contents of the structure are opaque.
+**
+** The opaque data is represented as a byte array below.
+** Do not access the array directly.
+*/
+typedef struct __tagDRM_AES_KEY
+{
+    DRM_BYTE rgbOpaque[ DRM_AES_KEYSTRUCTSIZE ];
+} DRM_AES_KEY;
+
+EXIT_PK_NAMESPACE;
+
+#endif /* __OEMAESKEY_H__ */
+
diff --git a/prebuilt-v4.4/noarch/include/oem/common/inc/oemaeskeywrap.h b/prebuilt-v4.4/noarch/include/oem/common/inc/oemaeskeywrap.h
new file mode 100644
index 0000000..62bf9b9
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/oem/common/inc/oemaeskeywrap.h
@@ -0,0 +1,54 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __DRMAESKEYWRAP_H__
+#define __DRMAESKEYWRAP_H__
+
+#include <oemaeskeywraptypes.h>
+#include <oembroker.h>
+
+ENTER_PK_NAMESPACE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL Oem_AesKeyWrap_WrapKeyAES128(
+    __in                         const OEM_AES_KEY_CONTEXT       *f_pKey,
+    __in_ecount( 1 )             const OEM_UNWRAPPED_KEY_AES_128 *f_pPlaintext,
+    __out_ecount( 1 )                  OEM_WRAPPED_KEY_AES_128   *f_pCiphertext ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL Oem_AesKeyWrap_WrapKeyECC256(
+    __in                         const OEM_AES_KEY_CONTEXT       *f_pKey,
+    __in_ecount( 1 )             const OEM_UNWRAPPED_KEY_ECC_256 *f_pPlaintext,
+    __out_ecount( 1 )                  OEM_WRAPPED_KEY_ECC_256   *f_pCiphertext ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL Oem_AesKeyWrap_UnwrapKeyAES128(
+    __in                          const OEM_AES_KEY_CONTEXT       *f_pKey,
+    __in_ecount( 1 )              const OEM_WRAPPED_KEY_AES_128   *f_pCiphertext,
+    __out_ecount( 1 )                   OEM_UNWRAPPED_KEY_AES_128 *f_pPlaintext ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL Oem_AesKeyWrap_UnwrapKeyECC256(
+    __in                          const OEM_AES_KEY_CONTEXT       *f_pKey,
+    __in_ecount( 1 )              const OEM_WRAPPED_KEY_ECC_256   *f_pCiphertext,
+    __out_ecount( 1 )                   OEM_UNWRAPPED_KEY_ECC_256 *f_pPlaintext ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL Oem_AesKeyWrap_WrapKeyAES128_Only(
+    __in                         const OEM_AES_KEY_CONTEXT            *f_pKey,
+    __in_ecount( 1 )             const OEM_UNWRAPPED_KEY_AES_128_ONLY *f_pPlaintext,
+    __out_ecount( 1 )                  OEM_WRAPPED_KEY_AES_128_ONLY   *f_pCiphertext ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL Oem_AesKeyWrap_UnwrapKeyAES128_Only(
+    __in                          const OEM_AES_KEY_CONTEXT            *f_pKey,
+    __in_ecount( 1 )              const OEM_WRAPPED_KEY_AES_128_ONLY   *f_pCiphertext,
+    __out_ecount( 1 )                   OEM_UNWRAPPED_KEY_AES_128_ONLY *f_pPlaintext ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL Oem_AesKeyWrap_UnwrapKeyECC256_Only(
+    __in                          const OEM_AES_KEY_CONTEXT            *f_pKey,
+    __in_ecount( 1 )              const OEM_WRAPPED_KEY_ECC_256_ONLY   *f_pCiphertext,
+    __out_ecount( 1 )                   OEM_UNWRAPPED_KEY_ECC_256_ONLY *f_pPlaintext ) DRM_NO_INLINE_ATTRIBUTE;
+
+EXIT_PK_NAMESPACE;
+
+#endif /* __DRMAESKEYWRAP_H__ */
diff --git a/prebuilt-v4.4/noarch/include/oem/common/inc/oemaeskeywraptypes.h b/prebuilt-v4.4/noarch/include/oem/common/inc/oemaeskeywraptypes.h
new file mode 100644
index 0000000..2f4e511
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/oem/common/inc/oemaeskeywraptypes.h
@@ -0,0 +1,75 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __DRMAESKEYWRAPTYPES_H__
+#define __DRMAESKEYWRAPTYPES_H__
+
+#include <oemaeskey.h>
+#include <oemeccp256.h>
+
+ENTER_PK_NAMESPACE;
+
+#define OEM_AESKEYWRAP_BLOCKLEN_IN_BYTES 8
+
+/* to introduce randomness in wrapping output */
+#define OEM_AESKEYWRAP_RANDOMLEN_IN_BYTES OEM_AESKEYWRAP_BLOCKLEN_IN_BYTES
+
+/* we accomodate 8 bytes of randomness in the unwrapped keys: this is to make two encryptions of the same value nondeterministic */
+#define OEM_AESKEYWRAP_UNWRAPPED_KEY_AES_128_SIZE_IN_DWORDS ( ( DRM_AES_KEYSIZE_128                                               + OEM_AESKEYWRAP_RANDOMLEN_IN_BYTES ) / sizeof(DRM_DWORD) )
+#define OEM_AESKEYWRAP_WRAPPED_KEY_AES_128_SIZE_IN_DWORDS   ( ( DRM_AES_KEYSIZE_128            + OEM_AESKEYWRAP_BLOCKLEN_IN_BYTES + OEM_AESKEYWRAP_RANDOMLEN_IN_BYTES ) / sizeof(DRM_DWORD) )
+#define OEM_AESKEYWRAP_UNWRAPPED_KEY_ECC_256_SIZE_IN_DWORDS ( ( ECC_P256_PRIVKEY_SIZE_IN_BYTES                                    + OEM_AESKEYWRAP_RANDOMLEN_IN_BYTES ) / sizeof(DRM_DWORD) )
+#define OEM_AESKEYWRAP_WRAPPED_KEY_ECC_256_SIZE_IN_DWORDS   ( ( ECC_P256_PRIVKEY_SIZE_IN_BYTES + OEM_AESKEYWRAP_BLOCKLEN_IN_BYTES + OEM_AESKEYWRAP_RANDOMLEN_IN_BYTES ) / sizeof(DRM_DWORD) )
+
+typedef struct __tagOEM_UNWRAPPED_KEY_AES_128
+{
+    DRM_DWORD m_rgdw[OEM_AESKEYWRAP_UNWRAPPED_KEY_AES_128_SIZE_IN_DWORDS];
+} OEM_UNWRAPPED_KEY_AES_128;
+
+typedef struct __tagOEM_WRAPPED_KEY_AES_128
+{
+    DRM_DWORD m_rgdw[OEM_AESKEYWRAP_WRAPPED_KEY_AES_128_SIZE_IN_DWORDS];
+} OEM_WRAPPED_KEY_AES_128;
+
+typedef struct __tagOEM_UNWRAPPED_KEY_ECC_256
+{
+    DRM_DWORD m_rgdw[OEM_AESKEYWRAP_UNWRAPPED_KEY_ECC_256_SIZE_IN_DWORDS];
+} OEM_UNWRAPPED_KEY_ECC_256;
+
+typedef struct __tagOEM_WRAPPED_KEY_ECC_256
+{
+    DRM_DWORD m_rgdw[OEM_AESKEYWRAP_WRAPPED_KEY_ECC_256_SIZE_IN_DWORDS];
+} OEM_WRAPPED_KEY_ECC_256;
+
+#define OEM_AESKEYWRAP_UNWRAPPED_KEY_AES_128_ONLY_SIZE_IN_DWORDS ( ( DRM_AES_KEYSIZE_128                                               ) / sizeof(DRM_DWORD) )
+#define OEM_AESKEYWRAP_WRAPPED_KEY_AES_128_ONLY_SIZE_IN_DWORDS   ( ( DRM_AES_KEYSIZE_128            + OEM_AESKEYWRAP_BLOCKLEN_IN_BYTES ) / sizeof(DRM_DWORD) )
+#define OEM_AESKEYWRAP_UNWRAPPED_KEY_ECC_256_ONLY_SIZE_IN_DWORDS ( ( ECC_P256_PRIVKEY_SIZE_IN_BYTES                                    ) / sizeof(DRM_DWORD) )
+#define OEM_AESKEYWRAP_WRAPPED_KEY_ECC_256_ONLY_SIZE_IN_DWORDS   ( ( ECC_P256_PRIVKEY_SIZE_IN_BYTES + OEM_AESKEYWRAP_BLOCKLEN_IN_BYTES ) / sizeof(DRM_DWORD) )
+
+typedef struct __tagOEM_UNWRAPPED_KEY_AES_128_ONLY
+{
+    DRM_DWORD m_rgdw[OEM_AESKEYWRAP_UNWRAPPED_KEY_AES_128_ONLY_SIZE_IN_DWORDS];
+} OEM_UNWRAPPED_KEY_AES_128_ONLY;
+
+typedef struct __tagOEM_WRAPPED_KEY_AES_128_ONLY
+{
+    DRM_DWORD m_rgdw[OEM_AESKEYWRAP_WRAPPED_KEY_AES_128_ONLY_SIZE_IN_DWORDS];
+} OEM_WRAPPED_KEY_AES_128_ONLY;
+
+typedef struct __tagOEM_UNWRAPPED_KEY_ECC_256_ONLY
+{
+    DRM_DWORD m_rgdw[OEM_AESKEYWRAP_UNWRAPPED_KEY_ECC_256_ONLY_SIZE_IN_DWORDS];
+} OEM_UNWRAPPED_KEY_ECC_256_ONLY;
+
+typedef struct __tagOEM_WRAPPED_KEY_ECC_256_ONLY
+{
+    DRM_DWORD m_rgdw[OEM_AESKEYWRAP_WRAPPED_KEY_ECC_256_ONLY_SIZE_IN_DWORDS];
+} OEM_WRAPPED_KEY_ECC_256_ONLY;
+
+EXIT_PK_NAMESPACE;
+
+#endif /* __DRMAESKEYWRAPTYPES_H__ */
diff --git a/prebuilt-v4.4/noarch/include/oem/common/inc/oemaesmulti.h b/prebuilt-v4.4/noarch/include/oem/common/inc/oemaesmulti.h
new file mode 100644
index 0000000..9c6c96f
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/oem/common/inc/oemaesmulti.h
@@ -0,0 +1,70 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+
+#ifndef __OEMAESMULTI_H__
+#define __OEMAESMULTI_H__
+
+#include <oemaeskey.h>
+#include <oembroker.h>
+
+ENTER_PK_NAMESPACE;
+
+DRM_API DRM_RESULT DRM_CALL Oem_Aes_CtrProcessData(
+    __in_ecount( 1 )            const OEM_AES_KEY_CONTEXT          *f_pKey,
+    __inout_bcount( f_cbData )        DRM_BYTE                     *f_pbData,
+    __in                              DRM_DWORD                     f_cbData,
+    __inout_ecount( 1 )               DRM_AES_COUNTER_MODE_CONTEXT *f_pCtrContext );
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL Oem_Aes_CbcEncryptData(
+    __in_ecount( 1 )                const OEM_AES_KEY_CONTEXT   *f_pKey,
+    __inout_bcount( f_cbData )            DRM_BYTE              *f_pbData,
+    __in                                  DRM_DWORD              f_cbData,
+    __in_bcount( DRM_AES_BLOCKLEN ) const DRM_BYTE               f_rgbIV[ DRM_AES_BLOCKLEN ] ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL Oem_Aes_CbcDecryptData(
+    __in_ecount( 1 )                const OEM_AES_KEY_CONTEXT   *f_pKey,
+    __inout_bcount( f_cbData )            DRM_BYTE              *f_pbData,
+    __in                                  DRM_DWORD              f_cbData,
+    __in_bcount( DRM_AES_BLOCKLEN ) const DRM_BYTE               f_rgbIV[ DRM_AES_BLOCKLEN ] ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL Oem_Aes_EcbEncryptData(
+    __in_ecount( 1 )                const OEM_AES_KEY_CONTEXT   *f_pKey,
+    __inout_bcount( f_cbData )            DRM_BYTE              *f_pbData,
+    __in                                  DRM_DWORD              f_cbData ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL Oem_Aes_EcbDecryptData(
+    __in_ecount( 1 )                const OEM_AES_KEY_CONTEXT   *f_pKey,
+    __inout_bcount( f_cbData )            DRM_BYTE              *f_pbData,
+    __in                                  DRM_DWORD              f_cbData ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL Oem_Omac1_Sign(
+    __in_ecount( 1 )                       const OEM_AES_KEY_CONTEXT    *f_pKey,
+    __in_bcount( f_ibData + f_cbData )     const DRM_BYTE               *f_pbData,
+    __in                                         DRM_DWORD               f_ibData,
+    __in                                         DRM_DWORD               f_cbData,
+    __out_bcount( DRM_AES_BLOCKLEN )             DRM_BYTE                f_rgbTag[ DRM_AES_BLOCKLEN ] ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL Oem_Omac1_Verify(
+    __in_ecount( 1 )                const OEM_AES_KEY_CONTEXT    *f_pKey,
+    __in_bcount(f_ibData+f_cbData)  const DRM_BYTE               *f_pbData,
+    __in                                  DRM_DWORD               f_ibData,
+    __in                                  DRM_DWORD               f_cbData,
+    __in_bcount(f_ibSignature+DRM_AES_BLOCKLEN) const DRM_BYTE   *f_pbSignature,
+    __in                                  DRM_DWORD    f_ibSignature ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL Oem_Aes_AES128KDFCTR_r8_L128(
+    __in_ecount( 1 )                                const OEM_AES_KEY_CONTEXT   *f_pDeriverKey,
+    __in_ecount( 1 )                                const DRM_ID                *f_pidLabel,
+    __in_ecount_opt( 1 )                            const DRM_ID                *f_pidContext,
+    __out_ecount( DRM_AES_KEYSIZE_128 )                   DRM_BYTE              *f_pbDerivedKey ) DRM_NO_INLINE_ATTRIBUTE;
+
+EXIT_PK_NAMESPACE;
+
+#endif /* __OEMAESMULTI_H__ */
+
diff --git a/prebuilt-v4.4/noarch/include/oem/common/inc/oembroker.h b/prebuilt-v4.4/noarch/include/oem/common/inc/oembroker.h
new file mode 100644
index 0000000..a4a6c39
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/oem/common/inc/oembroker.h
@@ -0,0 +1,88 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __OEMBROKER_H__
+#define __OEMBROKER_H__
+
+#include <oemcryptoctx.h>
+#include <oemeccp256.h>
+#include <oemsha256types.h>
+#include <oemaeskey.h>
+
+ENTER_PK_NAMESPACE;
+
+/*
+** There exist two types of OemBrokers.
+** For the OemBroker that runs in the normal world, calls to OEM APIs will pass over the OEM_AES_KEY_CONTEXT as a pointer to DRM_AES_KEY
+** while calls to OEM APIs of the TEE OemBroker will pass the OEM_AES_KEY_CONTEXT as an OEM_TEE_KEY.
+** Respective implementation of the OemBroker shall cast the OEM_AES_KEY_CONTEXT as appropriate.
+*/
+typedef DRM_VOID OEM_AES_KEY_CONTEXT;
+
+PREFAST_PUSH_DISABLE_EXPLAINED( __WARNING_NONCONST_PARAM_25004, "Ignore Nonconst Param - f_pOemTeeContext and f_pBigContext are mutually exclusive and used separately in different implementations of the broker functions." );
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL Oem_Broker_ECDSA_P256_Sign(
+    __inout_opt                                DRM_VOID               *f_pOemTeeContext,
+    __inout_opt                                struct bigctx_t        *f_pBigContext,
+    __in_bcount( f_cbMessageLen )        const DRM_BYTE                f_rgbMessage[],
+    __in                                       DRM_DWORD               f_cbMessageLen,
+    __in                                 const PRIVKEY_P256           *f_pPrivateKey,
+    __out                                      SIGNATURE_P256         *f_pbSignature ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_API DRM_RESULT DRM_CALL Oem_Broker_ECDSA_P256_Verify(
+    __inout_opt                                DRM_VOID               *f_pOemTeeContext,
+    __inout_opt                                struct bigctx_t        *f_pBigContext,
+    __in_ecount( f_cbMessageLen )       const  DRM_BYTE                f_rgbMessage[],
+    __in                                const  DRM_DWORD               f_cbMessageLen,
+    __in                                const  PUBKEY_P256            *f_pPubkey,
+    __in                                const  SIGNATURE_P256         *f_pSignature ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_API DRM_RESULT DRM_CALL Oem_Broker_Random_GetBytes(
+    __inout_opt                                DRM_VOID               *f_pOemTeeContext,
+    __in_opt                                   DRM_VOID               *f_pOemContext,
+    __out_bcount(f_cbData)                     DRM_BYTE               *f_pbData,
+    __in                                       DRM_DWORD               f_cbData );
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL Oem_Broker_Aes_EncryptOneBlock(
+    __in_ecount( 1 )                   const OEM_AES_KEY_CONTEXT      *f_pKey,
+    __inout_bcount( DRM_AES_BLOCKLEN )       DRM_BYTE                  f_rgbData[ DRM_AES_BLOCKLEN ] ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL Oem_Broker_Aes_DecryptOneBlock(
+    __in_ecount( 1 )                   const OEM_AES_KEY_CONTEXT      *f_pKey,
+    __inout_bcount( DRM_AES_BLOCKLEN )       DRM_BYTE                  f_rgbData[ DRM_AES_BLOCKLEN ] ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_BOOL DRM_CALL Oem_Broker_IsTEE( DRM_VOID ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL Oem_Broker_CRITSEC_Initialize( DRM_VOID ) DRM_NO_INLINE_ATTRIBUTE;
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL Oem_Broker_CRITSEC_Uninitialize( DRM_VOID ) DRM_NO_INLINE_ATTRIBUTE;
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL Oem_Broker_CRITSEC_Enter( DRM_VOID ) DRM_NO_INLINE_ATTRIBUTE;
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL Oem_Broker_CRITSEC_Leave( DRM_VOID ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL Oem_Broker_MemAlloc(
+    __in                                     DRM_DWORD                 f_cbSize,
+    __deref_out_bcount( f_cbSize )           DRM_VOID                **f_ppv ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API_VOID DRM_VOID DRM_CALL Oem_Broker_MemFree(
+    __inout                                  DRM_VOID                **f_ppv ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL Oem_Broker_Clock_GetSystemTimeAsFileTime(
+    __inout_opt                                DRM_VOID               *f_pOemTeeContextAllowNULL,
+    __out                                      DRMFILETIME            *f_pFileTime );
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL Oem_Broker_SHA256_CreateDigest(
+    __inout_opt                                     DRM_VOID                   *f_pOemTeeContext,
+    __in                                            DRM_DWORD                   f_cbBuffer,
+    __in_ecount( f_cbBuffer )                 const DRM_BYTE                    f_rgbBuffer[],
+    __out                                           OEM_SHA256_DIGEST          *f_pDigest ) DRM_NO_INLINE_ATTRIBUTE;
+
+
+PREFAST_POP;
+
+EXIT_PK_NAMESPACE;
+
+#endif /* __OEMBROKER_H__ */
diff --git a/prebuilt-v4.4/noarch/include/oem/common/inc/oembyteorder.h b/prebuilt-v4.4/noarch/include/oem/common/inc/oembyteorder.h
new file mode 100644
index 0000000..8a02ac2
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/oem/common/inc/oembyteorder.h
@@ -0,0 +1,371 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __OEMBYTEORDER_H__
+#define __OEMBYTEORDER_H__
+
+#include <drmmathsafe.h>
+#include <drmpragmas.h>
+
+/*
+** Begin: Ideal implementations of DRM_BYTE array conversions.
+** The DRM_BYTE arrays are in big or little endian format.
+** They are converted to/from DRM_WORD / DRM_DWORD / DRM_UINT64
+** in native endian format.
+*/
+
+#define DRM_BIG_ENDIAN_BYTES_TO_NATIVE_WORD( to_native_word, from_big_endian_bytes ) DRM_DO {           \
+    const DRM_BYTE *_pb = (const DRM_BYTE*)(from_big_endian_bytes);                                     \
+    (to_native_word) = (DRM_WORD)                                                                       \
+        ( (DRM_WORD)( ((DRM_WORD)(_pb[0])) << (DRM_WORD)8 )                                             \
+        | (DRM_WORD)( (_pb[1]) ) );                                                                     \
+} DRM_WHILE_FALSE
+
+#define DRM_LITTLE_ENDIAN_BYTES_TO_NATIVE_WORD( to_native_word, from_little_endian_bytes ) DRM_DO {     \
+    const DRM_BYTE *_pb = (const DRM_BYTE*)(from_little_endian_bytes);                                  \
+    (to_native_word) = (DRM_WORD)                                                                       \
+        ( (DRM_WORD)( (_pb[0]) )                                                                        \
+        | (DRM_WORD)( ((DRM_WORD)(_pb[1])) << (DRM_WORD)8 ) );                                          \
+} DRM_WHILE_FALSE
+
+#define DRM_NATIVE_WORD_TO_BIG_ENDIAN_BYTES( to_big_endian_bytes, from_native_word ) DRM_DO {           \
+    DRM_WORD   _w  = (from_native_word);                                                                \
+    DRM_BYTE  *_pb = (DRM_BYTE*)(to_big_endian_bytes);                                                  \
+    _pb[0] = (DRM_BYTE)( _w >> (DRM_WORD)8 );                                                           \
+    _pb[1] = (DRM_BYTE)( _w                );                                                           \
+} DRM_WHILE_FALSE
+
+#define DRM_NATIVE_WORD_TO_LITTLE_ENDIAN_BYTES( to_little_endian_bytes, from_native_word ) DRM_DO {     \
+    DRM_WORD   _w  = (from_native_word);                                                                \
+    DRM_BYTE  *_pb = (DRM_BYTE*)(to_little_endian_bytes);                                               \
+    _pb[0] = (DRM_BYTE)( _w                );                                                           \
+    _pb[1] = (DRM_BYTE)( _w >> (DRM_WORD)8 );                                                           \
+} DRM_WHILE_FALSE
+
+#define DRM_BIG_ENDIAN_BYTES_TO_NATIVE_DWORD( to_native_dword, from_big_endian_bytes ) DRM_DO {         \
+    const DRM_BYTE *_pb = (const DRM_BYTE*)(from_big_endian_bytes);                                     \
+    (to_native_dword) = (DRM_DWORD)                                                                     \
+        ( (DRM_DWORD)( ((DRM_DWORD)(_pb[0])) << (DRM_DWORD)24 )                                         \
+        | (DRM_DWORD)( ((DRM_DWORD)(_pb[1])) << (DRM_DWORD)16 )                                         \
+        | (DRM_DWORD)( ((DRM_DWORD)(_pb[2])) << (DRM_DWORD) 8 )                                         \
+        | (DRM_DWORD)( (_pb[3]) ) );                                                                    \
+} DRM_WHILE_FALSE
+
+#define DRM_LITTLE_ENDIAN_BYTES_TO_NATIVE_DWORD( to_native_dword, from_little_endian_bytes ) DRM_DO {   \
+    const DRM_BYTE *_pb = (const DRM_BYTE*)(from_little_endian_bytes);                                  \
+    (to_native_dword) = (DRM_DWORD)                                                                     \
+        ( (DRM_DWORD)( (_pb[0]) )                                                                       \
+        | (DRM_DWORD)( ((DRM_DWORD)(_pb[1])) << (DRM_DWORD) 8 )                                         \
+        | (DRM_DWORD)( ((DRM_DWORD)(_pb[2])) << (DRM_DWORD)16 )                                         \
+        | (DRM_DWORD)( ((DRM_DWORD)(_pb[3])) << (DRM_DWORD)24 ) );                                      \
+} DRM_WHILE_FALSE
+
+#define DRM_NATIVE_DWORD_TO_BIG_ENDIAN_BYTES( to_big_endian_bytes, from_native_dword ) DRM_DO {         \
+    DRM_DWORD  _dw = (from_native_dword);                                                               \
+    DRM_BYTE  *_pb = (DRM_BYTE*)(to_big_endian_bytes);                                                  \
+    _pb[0] = (DRM_BYTE)( _dw >> (DRM_DWORD)24 );                                                        \
+    _pb[1] = (DRM_BYTE)( _dw >> (DRM_DWORD)16 );                                                        \
+    _pb[2] = (DRM_BYTE)( _dw >> (DRM_DWORD) 8 );                                                        \
+    _pb[3] = (DRM_BYTE)( _dw                  );                                                        \
+} DRM_WHILE_FALSE
+
+#define DRM_NATIVE_DWORD_TO_LITTLE_ENDIAN_BYTES( to_little_endian_bytes, from_native_dword ) DRM_DO {   \
+    DRM_DWORD  _dw = (from_native_dword);                                                               \
+    DRM_BYTE  *_pb = (DRM_BYTE*)(to_little_endian_bytes);                                               \
+    _pb[0] = (DRM_BYTE)( _dw                  );                                                        \
+    _pb[1] = (DRM_BYTE)( _dw >> (DRM_DWORD) 8 );                                                        \
+    _pb[2] = (DRM_BYTE)( _dw >> (DRM_DWORD)16 );                                                        \
+    _pb[3] = (DRM_BYTE)( _dw >> (DRM_DWORD)24 );                                                        \
+} DRM_WHILE_FALSE
+
+#if DRM_SUPPORT_NATIVE_64BIT_TYPES
+
+#define DRM_BIG_ENDIAN_BYTES_TO_NATIVE_QWORD( to_native_qword, from_big_endian_bytes ) DRM_DO {         \
+    const DRM_BYTE *_pb = (const DRM_BYTE*)(from_big_endian_bytes);                                     \
+    (to_native_qword) = (DRM_UINT64)                                                                    \
+        ( (DRM_UINT64)( ((DRM_UINT64)(_pb[0])) << (DRM_UINT64)56 )                                      \
+        | (DRM_UINT64)( ((DRM_UINT64)(_pb[1])) << (DRM_UINT64)48 )                                      \
+        | (DRM_UINT64)( ((DRM_UINT64)(_pb[2])) << (DRM_UINT64)40 )                                      \
+        | (DRM_UINT64)( ((DRM_UINT64)(_pb[3])) << (DRM_UINT64)32 )                                      \
+        | (DRM_UINT64)( ((DRM_UINT64)(_pb[4])) << (DRM_UINT64)24 )                                      \
+        | (DRM_UINT64)( ((DRM_UINT64)(_pb[5])) << (DRM_UINT64)16 )                                      \
+        | (DRM_UINT64)( ((DRM_UINT64)(_pb[6])) << (DRM_UINT64) 8 )                                      \
+        | (DRM_UINT64)( (_pb[7]) ) );                                                                   \
+} DRM_WHILE_FALSE
+
+#define DRM_LITTLE_ENDIAN_BYTES_TO_NATIVE_QWORD( to_native_qword, from_little_endian_bytes ) DRM_DO {   \
+    const DRM_BYTE *_pb = (const DRM_BYTE*)(from_little_endian_bytes);                                  \
+    (to_native_qword) = (DRM_UINT64)                                                                    \
+        ( (DRM_UINT64)( (_pb[0]) )                                                                      \
+        | (DRM_UINT64)( ((DRM_UINT64)(_pb[1])) << (DRM_UINT64) 8 )                                      \
+        | (DRM_UINT64)( ((DRM_UINT64)(_pb[2])) << (DRM_UINT64)16 )                                      \
+        | (DRM_UINT64)( ((DRM_UINT64)(_pb[3])) << (DRM_UINT64)24 )                                      \
+        | (DRM_UINT64)( ((DRM_UINT64)(_pb[4])) << (DRM_UINT64)32 )                                      \
+        | (DRM_UINT64)( ((DRM_UINT64)(_pb[5])) << (DRM_UINT64)40 )                                      \
+        | (DRM_UINT64)( ((DRM_UINT64)(_pb[6])) << (DRM_UINT64)48 )                                      \
+        | (DRM_UINT64)( ((DRM_UINT64)(_pb[7])) << (DRM_UINT64)56 ) );                                   \
+} DRM_WHILE_FALSE
+
+#define DRM_NATIVE_QWORD_TO_BIG_ENDIAN_BYTES( to_big_endian_bytes, from_native_qword ) DRM_DO {         \
+    DRM_UINT64 _qw = (from_native_qword);                                                               \
+    DRM_BYTE  *_pb = (DRM_BYTE*)(to_big_endian_bytes);                                                  \
+    _pb[0] = (DRM_BYTE)( _qw >> (DRM_UINT64)56 );                                                       \
+    _pb[1] = (DRM_BYTE)( _qw >> (DRM_UINT64)48 );                                                       \
+    _pb[2] = (DRM_BYTE)( _qw >> (DRM_UINT64)40 );                                                       \
+    _pb[3] = (DRM_BYTE)( _qw >> (DRM_UINT64)32 );                                                       \
+    _pb[4] = (DRM_BYTE)( _qw >> (DRM_UINT64)24 );                                                       \
+    _pb[5] = (DRM_BYTE)( _qw >> (DRM_UINT64)16 );                                                       \
+    _pb[6] = (DRM_BYTE)( _qw >> (DRM_UINT64) 8 );                                                       \
+    _pb[7] = (DRM_BYTE)( _qw                   );                                                       \
+} DRM_WHILE_FALSE
+
+#define DRM_NATIVE_QWORD_TO_LITTLE_ENDIAN_BYTES( to_little_endian_bytes, from_native_qword ) DRM_DO {   \
+    DRM_UINT64 _qw = (from_native_qword);                                                               \
+    DRM_BYTE  *_pb = (DRM_BYTE*)(to_little_endian_bytes);                                               \
+    _pb[0] = (DRM_BYTE)( _qw                   );                                                       \
+    _pb[1] = (DRM_BYTE)( _qw >> (DRM_UINT64) 8 );                                                       \
+    _pb[2] = (DRM_BYTE)( _qw >> (DRM_UINT64)16 );                                                       \
+    _pb[3] = (DRM_BYTE)( _qw >> (DRM_UINT64)24 );                                                       \
+    _pb[4] = (DRM_BYTE)( _qw >> (DRM_UINT64)32 );                                                       \
+    _pb[5] = (DRM_BYTE)( _qw >> (DRM_UINT64)40 );                                                       \
+    _pb[6] = (DRM_BYTE)( _qw >> (DRM_UINT64)48 );                                                       \
+    _pb[7] = (DRM_BYTE)( _qw >> (DRM_UINT64)56 );                                                       \
+} DRM_WHILE_FALSE
+
+#else   /* DRM_SUPPORT_NATIVE_64BIT_TYPES */
+
+#define DRM_BIG_ENDIAN_BYTES_TO_NATIVE_QWORD( to_native_qword, from_big_endian_bytes ) DRM_DO {         \
+    const DRM_BYTE *_pb2 = (const DRM_BYTE*)(from_big_endian_bytes);                                    \
+    DRM_DWORD _dwhigh;                                                                                  \
+    DRM_DWORD _dwlow;                                                                                   \
+    DRM_BIG_ENDIAN_BYTES_TO_NATIVE_DWORD( _dwhigh, &(_pb2[0]) );                                        \
+    DRM_BIG_ENDIAN_BYTES_TO_NATIVE_DWORD( _dwlow,  &(_pb2[4]) );                                        \
+    (to_native_qword) = DRM_UI64HL( _dwhigh, _dwlow );                                                  \
+} DRM_WHILE_FALSE
+
+#define DRM_LITTLE_ENDIAN_BYTES_TO_NATIVE_QWORD( to_native_qword, from_little_endian_bytes ) DRM_DO {   \
+    const DRM_BYTE *_pb2 = (const DRM_BYTE*)(from_little_endian_bytes);                                 \
+    DRM_DWORD _dwhigh;                                                                                  \
+    DRM_DWORD _dwlow;                                                                                   \
+    DRM_LITTLE_ENDIAN_BYTES_TO_NATIVE_DWORD( _dwlow,  &(_pb2[0]) );                                     \
+    DRM_LITTLE_ENDIAN_BYTES_TO_NATIVE_DWORD( _dwhigh, &(_pb2[4]) );                                     \
+    (to_native_qword) = DRM_UI64HL( _dwhigh, _dwlow );                                                  \
+} DRM_WHILE_FALSE
+
+#define DRM_NATIVE_QWORD_TO_BIG_ENDIAN_BYTES( to_big_endian_bytes, from_native_qword ) DRM_DO {         \
+    DRM_UINT64 _qw = (from_native_qword);                                                               \
+    DRM_BYTE  *_pb2 = (DRM_BYTE*)(to_big_endian_bytes);                                                 \
+    DRM_NATIVE_DWORD_TO_BIG_ENDIAN_BYTES( &_pb2[0], DRM_UI64High32( _qw ) );                            \
+    DRM_NATIVE_DWORD_TO_BIG_ENDIAN_BYTES( &_pb2[4], DRM_UI64Low32 ( _qw ) );                            \
+} DRM_WHILE_FALSE
+
+#define DRM_NATIVE_QWORD_TO_LITTLE_ENDIAN_BYTES( to_little_endian_bytes, from_native_qword ) DRM_DO {   \
+    DRM_UINT64 _qw = (from_native_qword);                                                               \
+    DRM_BYTE  *_pb2 = (DRM_BYTE*)(to_big_endian_bytes);                                                 \
+    DRM_NATIVE_DWORD_TO_LITTLE_ENDIAN_BYTES( &_pb2[0], DRM_UI64Low32 ( _qw ) );                         \
+    DRM_NATIVE_DWORD_TO_LITTLE_ENDIAN_BYTES( &_pb2[4], DRM_UI64High32( _qw ) );                         \
+} DRM_WHILE_FALSE
+
+#endif  /* DRM_SUPPORT_NATIVE_64BIT_TYPES */
+
+/*
+** End: Ideal implementations of byte array conversions.
+*/
+
+/*
+** Legacy macros that convert DRM_BYTE arrays in little endian format to/from
+** DRM_WORD / DRM_DWORD / DRM_UINT64 in native endian format.
+*/
+#define BYTES_TO_WORD(  word,  byte  )   DRM_LITTLE_ENDIAN_BYTES_TO_NATIVE_WORD(  (word ), (byte ) )
+#define WORD_TO_BYTES(  byte,  word  )   DRM_NATIVE_WORD_TO_LITTLE_ENDIAN_BYTES(  (byte ), (word ) )
+#define BYTES_TO_DWORD( dword, byte  )   DRM_LITTLE_ENDIAN_BYTES_TO_NATIVE_DWORD( (dword), (byte ) )
+#define DWORD_TO_BYTES( byte,  dword )   DRM_NATIVE_DWORD_TO_LITTLE_ENDIAN_BYTES( (byte ), (dword) )
+#define BYTES_TO_QWORD( qword, byte  )   DRM_LITTLE_ENDIAN_BYTES_TO_NATIVE_QWORD( (qword), (byte ) )
+#define QWORD_TO_BYTES( byte,  qword )   DRM_NATIVE_QWORD_TO_LITTLE_ENDIAN_BYTES( (byte ), (qword) )
+
+#define BITS_PER_STANDARD_BYTE 8
+
+#define ROTATE_LEFT_WORD(x, n)   ((DRM_WORD)  (((DRM_WORD)  (((x) << (n)) & 0xFFFF)) | ((DRM_WORD)  (x) >> (16-(n)))))
+#define ROTATE_RIGHT_WORD(x, n)  ((DRM_WORD)  (((DRM_WORD)  (x) >> (n)) | ((DRM_WORD)  (((x) << (16-(n))) & 0xFFFF))))
+#define ROTATE_LEFT_DWORD(x, n)  ((DRM_DWORD) (((DRM_DWORD) (((x) << (n)) & 0xFFFFFFFF)) | ((DRM_DWORD) (x) >> (32-(n)))))
+#define ROTATE_RIGHT_DWORD(x, n) ((DRM_DWORD) (((DRM_DWORD) (x) >> (n)) | ((DRM_DWORD) (((x) << (32-(n))) & 0xFFFFFFFF))))
+#if DRM_SUPPORT_NATIVE_64BIT_TYPES
+#define ROTATE_LEFT_QWORD(x, n)  ((DRM_UINT64)(((DRM_UINT64)(x) << (n)) | ((DRM_UINT64)(x) >> (64-(n)))))
+#define ROTATE_RIGHT_QWORD(x, n) ((DRM_UINT64)(((DRM_UINT64)(x) >> (n)) | ((DRM_UINT64)(x) << (64-(n)))))
+#endif /* DRM_SUPPORT_NATIVE_64BIT_TYPES */
+
+#define ROTATE_LEFT(x, n)  (((x) << (n)) | ((x) >> (32-(n))))
+#define ROTATE_RIGHT(x, n) (((x) >> (n)) | ((x) << (32-(n))))
+
+#define FLIP_WORD_BYTES(w) ( ROTATE_LEFT_WORD((DRM_WORD)(w), 8) )
+
+/* for initialization of constant values, we define special macro for flipping bytes in DRM_DWORD */
+#define FLIP_DWORD_BYTES_CONST(dw) ((ROTATE_RIGHT((dw), 24) & 0x00ff00ff) | (ROTATE_RIGHT((dw), 8) & 0xff00ff00))
+
+#if DRM_SUPPORT_NATIVE_64BIT_TYPES
+#if DRM_BUILD_PROFILE == DRM_BUILD_PROFILE_IOS
+#define FLIP_DWORD_BYTES(dw) __builtin_bswap32(dw)
+#define FLIP_QWORD_BYTES(qw) __builtin_bswap64(qw)
+#elif (defined(_M_IX86) || defined(_M_AMD64) || defined(_XBOX)) && !defined(_MANAGED)
+#ifdef __cplusplus
+extern "C"
+{
+#endif /* __cplusplus */
+__checkReturn unsigned long  __cdecl _byteswap_ulong (__in unsigned long _Long);
+__checkReturn unsigned __int64 __cdecl _byteswap_uint64(__in unsigned __int64 _Int64);
+#ifdef __cplusplus
+} /* extern "C"*/
+#endif /* __cplusplus */
+PRAGMA_INTRINSIC(_byteswap_ulong)
+PRAGMA_INTRINSIC(_byteswap_uint64)
+#define FLIP_DWORD_BYTES(dw) ((DRM_DWORD)_byteswap_ulong((unsigned long)(dw)))
+#define FLIP_QWORD_BYTES(qw) ((DRM_UINT64)_byteswap_uint64((unsigned __int64)(qw)))
+#else
+#define FLIP_DWORD_BYTES(dw) FLIP_DWORD_BYTES_CONST(dw)
+#define FLIP_QWORD_BYTES(qw) ( FLIP_DWORD_BYTES(qw>>32) | ( ( (DRM_UINT64) FLIP_DWORD_BYTES((DRM_DWORD)qw) ) << 32 ) )
+#endif
+#else /* DRM_SUPPORT_NATIVE_64BIT_TYPES */
+#define FLIP_DWORD_BYTES(dw) FLIP_DWORD_BYTES_CONST(dw)
+#define FLIP_QWORD_BYTES(qw) DRM_UI64HL(FLIP_DWORD_BYTES(DRM_UI64Low32(qw)),FLIP_DWORD_BYTES(DRM_UI64High32(qw)))
+#endif /* DRM_SUPPORT_NATIVE_64BIT_TYPES */
+
+#define WORDSWAP(d) ROTATE_LEFT(d, 16)
+
+/*
+** Legacy macros that convert DRM_BYTE arrays in little endian format to/from
+** DRM_WORD / DRM_DWORD / DRM_UINT64 in native endian format.
+*/
+#define BYTES2WORD_LE(  word,  byte  )      DRM_LITTLE_ENDIAN_BYTES_TO_NATIVE_WORD(  (word ), (byte ) )
+#define WORD2BYTES_LE(  byte,  word  )      DRM_NATIVE_WORD_TO_LITTLE_ENDIAN_BYTES(  (byte ), (word ) )
+#define BYTES2DWORD_LE( dword, byte  )      DRM_LITTLE_ENDIAN_BYTES_TO_NATIVE_DWORD( (dword), (byte ) )
+#define DWORD2BYTES_LE( byte,  dword )      DRM_NATIVE_DWORD_TO_LITTLE_ENDIAN_BYTES( (byte ), (dword) )
+#define BYTES2QWORD_LE( qword, byte  )      DRM_LITTLE_ENDIAN_BYTES_TO_NATIVE_QWORD( (qword), (byte ) )
+#define QWORD2BYTES_LE( byte,  qword )      DRM_NATIVE_QWORD_TO_LITTLE_ENDIAN_BYTES( (byte ), (qword) )
+
+#define REVERSE_BYTES_WORD(w)               DRM_DO { (w)  = FLIP_WORD_BYTES(w);   } DRM_WHILE_FALSE
+#define REVERSE_BYTES_DWORD(dw)             DRM_DO { (dw) = FLIP_DWORD_BYTES(dw); } DRM_WHILE_FALSE
+#define REVERSE_BYTES_LONG(l)               DRM_DO { (l) = (DRM_LONG)FLIP_DWORD_BYTES((DRM_DWORD)l); } DRM_WHILE_FALSE
+#define REVERSE_BYTES_QWORD(qw)             DRM_DO { (qw) = FLIP_QWORD_BYTES(qw); } DRM_WHILE_FALSE
+
+/*
+** Legacy macros that convert DRM_BYTE arrays in little endian format to
+** DRM_WORD / DRM_DWORD / DRM_UINT64 in native endian format.
+*/
+#define LITTLEENDIAN_BYTES_TO_WORD(  word,  byte, index )   DRM_LITTLE_ENDIAN_BYTES_TO_NATIVE_WORD(  (word) , &((const DRM_BYTE*)(byte))[(index)] )
+#define LITTLEENDIAN_BYTES_TO_DWORD( dword, byte, index )   DRM_LITTLE_ENDIAN_BYTES_TO_NATIVE_DWORD( (dword), &((const DRM_BYTE*)(byte))[(index)] )
+#define LITTLEENDIAN_BYTES_TO_QWORD( qword, byte, index )   DRM_LITTLE_ENDIAN_BYTES_TO_NATIVE_QWORD( (qword), &((const DRM_BYTE*)(byte))[(index)] )
+
+/*
+** Legacy macros that convert DRM_BYTE arrays in big endian format to
+** DRM_WORD / DRM_DWORD / DRM_UINT64 in native endian format.
+*/
+#define NETWORKBYTES_TO_WORD(word, byte, index)     DRM_BIG_ENDIAN_BYTES_TO_NATIVE_WORD(  (word ), &((DRM_BYTE*)(byte))[(index)] )
+#define NETWORKBYTES_TO_DWORD(dword, byte, index)   DRM_BIG_ENDIAN_BYTES_TO_NATIVE_DWORD( (dword), &((DRM_BYTE*)(byte))[(index)] )
+#define NETWORKBYTES_TO_QWORD(qword, byte, index)   DRM_BIG_ENDIAN_BYTES_TO_NATIVE_QWORD( (qword), &((DRM_BYTE*)(byte))[(index)] )
+
+#define NETWORKBYTES_FROMBUFFER_TO_WORD(word, byte, index, buffersize)   DRM_DO {       \
+    DRM_DWORD __dwSpaceRequired=0;                                                      \
+    ChkDR( DRM_DWordAdd( index, sizeof(DRM_WORD), &__dwSpaceRequired ) );               \
+    ChkBOOL( __dwSpaceRequired  <= (buffersize), DRM_E_BUFFERTOOSMALL );                \
+    __analysis_assume( index + sizeof( DRM_WORD ) <= buffersize );                      \
+    NETWORKBYTES_TO_WORD( ( word ), ( byte ), ( index ) );                              \
+    (index) = (__dwSpaceRequired);                                                      \
+} DRM_WHILE_FALSE
+
+#define NETWORKBYTES_FROMBUFFER_TO_DWORD(dword, byte, index, buffersize) DRM_DO {       \
+    DRM_DWORD __dwSpaceRequired=0;                                                      \
+    ChkDR( DRM_DWordAdd( index, sizeof(DRM_DWORD), &__dwSpaceRequired ) );              \
+    ChkBOOL( __dwSpaceRequired <= (buffersize), DRM_E_BUFFERTOOSMALL );                 \
+    __analysis_assume( index + sizeof( DRM_DWORD ) <= buffersize );                     \
+    NETWORKBYTES_TO_DWORD( (dword), (byte), (index) );                                  \
+    (index) = (__dwSpaceRequired);                                                      \
+} DRM_WHILE_FALSE
+
+/*
+** Legacy macros that convert DRM_BYTE arrays in big endian format *from*
+** DRM_WORD / DRM_DWORD / DRM_UINT64 in native endian format.
+*/
+#define WORD_TO_NETWORKBYTES(byte_ptr, index, word)     DRM_NATIVE_WORD_TO_BIG_ENDIAN_BYTES(  &((DRM_BYTE*)(byte_ptr))[(index)], word  )
+#define DWORD_TO_NETWORKBYTES(byte_ptr, index, dword)   DRM_NATIVE_DWORD_TO_BIG_ENDIAN_BYTES( &((DRM_BYTE*)(byte_ptr))[(index)], dword )
+#define QWORD_TO_NETWORKBYTES(byte_ptr, index, qword)   DRM_NATIVE_QWORD_TO_BIG_ENDIAN_BYTES( &((DRM_BYTE*)(byte_ptr))[(index)], qword )
+
+/*
+** Legacy macros that convert DRM_BYTE arrays in little endian format from
+** DRM_WORD / DRM_DWORD / DRM_UINT64 in native endian format.
+*/
+#define WORD_TO_LITTLEENDIAN_BYTES(byte, index, word)   DRM_NATIVE_WORD_TO_LITTLE_ENDIAN_BYTES(  &((DRM_BYTE*)(byte))[(index)], word  )
+#define DWORD_TO_LITTLEENDIAN_BYTES(byte, index, dword) DRM_NATIVE_DWORD_TO_LITTLE_ENDIAN_BYTES( &((DRM_BYTE*)(byte))[(index)], dword )
+
+#if TARGET_LITTLE_ENDIAN
+
+#define MAKE_WORD_BIG_ENDIAN(w)         FLIP_WORD_BYTES(w)
+#define MAKE_DWORD_BIG_ENDIAN(dw)       FLIP_DWORD_BYTES(dw)
+#define MAKE_DWORD_BIG_ENDIAN_CONST(dw) FLIP_DWORD_BYTES_CONST(dw)
+#define MAKE_GUID_BIG_ENDIAN(guid)      DRM_DO {REVERSE_BYTES_DWORD((guid).Data1);REVERSE_BYTES_WORD((guid).Data2);REVERSE_BYTES_WORD((guid).Data3);} DRM_WHILE_FALSE
+
+/*
+** Note: Do *NOT* define MAKE_QWORD_BIG_ENDIAN.
+** Due to non-native 64-bit type support, its semantics are confusing and it should not be defined/used.
+*/
+
+#define FIX_ENDIAN_WORD(w)
+#define FIX_ENDIAN_DWORD(dw)
+#define FIX_ENDIAN_LONG(l)
+#define FIX_ENDIAN_QWORD(qw)
+#define FIX_ENDIAN_GUID(guid)
+
+#else /* TARGET_LITTLE_ENDIAN */
+
+#define MAKE_WORD_BIG_ENDIAN(w)         (w)
+#define MAKE_DWORD_BIG_ENDIAN(dw)       (dw)
+#define MAKE_DWORD_BIG_ENDIAN_CONST(dw) (dw)
+#define MAKE_GUID_BIG_ENDIAN(guid)      (guid)
+
+/*
+** Note: Do *NOT* define MAKE_QWORD_BIG_ENDIAN.  Refer to comments near earlier reference to MAKE_QWORD_BIG_ENDIAN.
+*/
+
+#define FIX_ENDIAN_WORD(w)   REVERSE_BYTES_WORD(w)
+#define FIX_ENDIAN_DWORD(dw) REVERSE_BYTES_DWORD(dw)
+#define FIX_ENDIAN_LONG(l)   REVERSE_BYTES_LONG(l)
+#define FIX_ENDIAN_QWORD(qw) DRM_DO {REVERSE_BYTES_QWORD(qw); NONNATIVE64_TO_NATIVE64((qw));} DRM_WHILE_FALSE
+
+#define FIX_ENDIAN_GUID(guid)                       DRM_DO {FIX_ENDIAN_DWORD((guid).Data1);FIX_ENDIAN_WORD((guid).Data2);FIX_ENDIAN_WORD((guid).Data3);} DRM_WHILE_FALSE
+
+#endif /* TARGET_LITTLE_ENDIAN */
+
+#if TARGET_LITTLE_ENDIAN
+#define DRM_CHANGE_CASTED_DWORD_ENDIANNESS_TO_NATIVE_INPLACE(dw,isSrcLE) DRM_DO { if(!isSrcLE) { REVERSE_BYTES_DWORD(dw); } } DRM_WHILE_FALSE
+#define DRM_CHANGE_CASTED_QWORD_ENDIANNESS_TO_NATIVE_INPLACE(qw,isSrcLE) DRM_DO { if(!isSrcLE) { REVERSE_BYTES_QWORD(qw); } } DRM_WHILE_FALSE
+#define DRM_CHANGE_NATIVE_DWORD_ENDIANNESS_TO_CASTED_BIG_ENDIAN_INPLACE(dw) DRM_DO { REVERSE_BYTES_DWORD(dw); } DRM_WHILE_FALSE
+#define DRM_CHANGE_NATIVE_QWORD_ENDIANNESS_TO_CASTED_BIG_ENDIAN_INPLACE(qw) DRM_DO { REVERSE_BYTES_QWORD(qw); } DRM_WHILE_FALSE
+#else /* TARGET_LITTLE_ENDIAN */
+#define DRM_CHANGE_CASTED_DWORD_ENDIANNESS_TO_NATIVE_INPLACE(dw,isSrcLE) DRM_DO { if(isSrcLE) { REVERSE_BYTES_DWORD(dw); } } DRM_WHILE_FALSE
+#define DRM_CHANGE_CASTED_QWORD_ENDIANNESS_TO_NATIVE_INPLACE(qw,isSrcLE) DRM_DO { if(isSrcLE) { REVERSE_BYTES_QWORD(qw); } NONNATIVE64_TO_NATIVE64(qw); } DRM_WHILE_FALSE
+#define DRM_CHANGE_NATIVE_DWORD_ENDIANNESS_TO_CASTED_BIG_ENDIAN_INPLACE(dw)
+#define DRM_CHANGE_NATIVE_QWORD_ENDIANNESS_TO_CASTED_BIG_ENDIAN_INPLACE(qw) DRM_DO { NATIVE64_TO_NONNATIVE64(qw); } DRM_WHILE_FALSE
+#endif /* TARGET_LITTLE_ENDIAN */
+
+#define DRM_IS_INTEGER_POWER_OF_TW0( x )    (((x)&((x)-1))==0)
+
+#define DRM_XOR( __pbLeft, __pbRight, __cb ) DRM_DO {   \
+    DRM_DWORD __cbxor = (__cb);                         \
+    DRM_BYTE *__pbxorL = ((DRM_BYTE*)(__pbLeft));       \
+    DRM_BYTE *__pbxorR = ((DRM_BYTE*)(__pbRight));      \
+    DRMASSERT( __cbxor > 0 );                           \
+    DRMASSERT( __pbxorL != NULL );                      \
+    DRMASSERT( __pbxorR != NULL );                      \
+    while( __cbxor > 0 )                                \
+    {                                                   \
+        __cbxor--;                                      \
+        __pbxorL[ __cbxor ] ^= __pbxorR[ __cbxor ];     \
+    }                                                   \
+} DRM_WHILE_FALSE
+
+#endif /* __OEMBYTEORDER_H__ */
+
diff --git a/prebuilt-v4.4/noarch/include/oem/common/inc/oemcbctypes.h b/prebuilt-v4.4/noarch/include/oem/common/inc/oemcbctypes.h
new file mode 100644
index 0000000..d9714ba
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/oem/common/inc/oemcbctypes.h
@@ -0,0 +1,31 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __OEMCBCTYPES_H__
+#define __OEMCBCTYPES_H__
+
+#include <drmtypes.h>
+
+ENTER_PK_NAMESPACE;
+
+typedef struct _CBCKey
+{
+    DRM_DWORD a1, b1, c1, d1, e1, f1, a2, b2, c2, d2, e2, f2;
+} DRM_CBCKey;
+
+typedef struct __tagCBCState
+{
+    DRM_DWORD sum,t;
+    DRM_BYTE  buf[ 8 ];
+    DRM_DWORD dwBufLen;
+} DRM_CBCState;
+
+EXIT_PK_NAMESPACE;
+
+#endif /* __OEMCBCTYPES_H__ */
+
diff --git a/prebuilt-v4.4/noarch/include/oem/common/inc/oemciphertypes.h b/prebuilt-v4.4/noarch/include/oem/common/inc/oemciphertypes.h
new file mode 100644
index 0000000..2c2a16e
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/oem/common/inc/oemciphertypes.h
@@ -0,0 +1,85 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+
+#ifndef __OEMCIPHERTYPES_H__
+#define __OEMCIPHERTYPES_H__
+
+#include <oemcocktailtypes.h>
+#include <oemaeskey.h>
+#include <oemcommon.h>
+#include <drmteetypes.h>
+
+ENTER_PK_NAMESPACE;
+
+typedef enum _DRM_SUPPORTED_CIPHERS
+{
+    eDRM_CIPHER_INVALID     = 0,
+    eDRM_RC4_CIPHER         = 1,
+    eDRM_AES_COUNTER_CIPHER = 2,
+    eDRM_AES_CBC_CIPHER     = 3,
+    eDRM_UNSPECIFIED_CIPHER = 4,
+} DRM_SUPPORTED_CIPHERS;
+
+typedef struct __tagDRM_AES_CIPHER_CONTEXT
+{
+    DRM_BYTE          rgbContentKey[DRM_AES_MAXKEYSIZE];
+    DRM_AES_KEY       aesKey;
+DRM_OBFUS_PTR_TOP
+    OEM_CRYPTO_HANDLE hAesKey;
+DRM_OBFUS_PTR_BTM
+} DRM_AES_CIPHER_CONTEXT;
+
+#define DRM_OPAQUE_CIPHER_CONTEXT_SIZE 176
+
+typedef struct __tagDRM_OPAQUE_CIPHER_CONTEXT
+{
+    DRM_BYTE      rgbContentKey[DRM_OPAQUE_CIPHER_CONTEXT_SIZE];
+} DRM_OPAQUE_CIPHER_CONTEXT;
+
+typedef struct __tagDRM_CIPHER_CONTEXT_TEE
+{
+    DRM_TEE_BYTE_BLOB         oCDKB;
+    DRM_TEE_BYTE_BLOB         oSSKB;
+    DRM_TEE_BYTE_BLOB         oOEMKeyInfo;
+} DRM_CIPHER_CONTEXT_TEE;
+
+typedef struct __tagDRM_CIPHER_CONTEXT
+{
+    DRM_SUPPORTED_CIPHERS    eCipherType;
+    DRM_LID                  oLID;
+    DRM_BOOL                 fInited;
+    DRM_DWORD                cbContentKey;
+    DRM_BOOL                 fDisableClone;
+    DRM_UINT64               ui64RealTimeExpiration;
+    DRM_UINT64               ui64RealTimeExpirationTicsAfterFirstPlay;
+    DRM_UINT64               ui64cbProcessed;
+
+    DRM_VOID                *pAppCtxWeakRef;   /* Weak reference to the App context. Never attempt to free it. This is memory owned by the Application. */
+    DRM_BOOL                 fSecureStopBound; /* Indicates that the decryptor is bound to a license that supports secure stop. */
+
+DRM_OBFUS_PTR_TOP
+    DRM_VOID                *pOEMContext;
+DRM_OBFUS_PTR_BTM
+DRM_OBFUS_PTR_TOP
+    DRM_VOID                *pOpaqueBbx;
+DRM_OBFUS_PTR_BTM
+    union _tagcipher
+    {
+        OEM_COCKTAIL_CONTEXT      cipherRC4;
+        DRM_AES_CIPHER_CONTEXT    cipherAES;
+        DRM_OPAQUE_CIPHER_CONTEXT cipherOPAQUE;
+        DRM_CIPHER_CONTEXT_TEE    cipherTEE;
+    } cipher;
+    DRM_VOID                *pFuncTbl;
+} DRM_CIPHER_CONTEXT;
+
+EXIT_PK_NAMESPACE;
+
+#endif /* __OEMCIPHERTYPES_H__ */
+
diff --git a/prebuilt-v4.4/noarch/include/oem/common/inc/oemcocktail.h b/prebuilt-v4.4/noarch/include/oem/common/inc/oemcocktail.h
new file mode 100644
index 0000000..62639bf
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/oem/common/inc/oemcocktail.h
@@ -0,0 +1,52 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+
+#ifndef __OEMCOCKTAIL_H__
+#define __OEMCOCKTAIL_H__
+
+#include <oemcocktailtypes.h>
+#include <oemaescommon.h>
+
+ENTER_PK_NAMESPACE;
+
+DRM_API DRM_RESULT DRM_CALL OEM_Cocktail_Init(
+    __out_ecount( 1 )                OEM_COCKTAIL_CONTEXT *f_pCocktailContext,
+    __in                             DRM_DWORD             f_cbContKey,
+    __in_bcount( f_cbContKey ) const DRM_BYTE             *f_pbContKey );
+
+DRM_API DRM_RESULT DRM_CALL OEM_Cocktail_InitDecrypt(
+    __inout_ecount( 1 )                                                       OEM_COCKTAIL_CONTEXT *f_pCocktailContext,
+    __in_bcount_opt( DRM_MIN( DRM_CPHR_CB_FOR_INITDECRYPT, f_cbData ) ) const DRM_BYTE             *f_pbLast15,
+    __in                                                                      DRM_DWORD             f_cbData );
+
+DRM_API DRM_RESULT DRM_CALL OEM_Cocktail_Decrypt(
+    __inout_ecount( 1 )        OEM_COCKTAIL_CONTEXT *f_pCocktailContext,
+    __in                       DRM_DWORD             f_cbData,
+    __inout_bcount( f_cbData ) DRM_BYTE             *f_pbData );
+
+DRM_API DRM_RESULT DRM_CALL OEM_Cocktail_Encrypt(
+    __inout_ecount( 1 )        OEM_COCKTAIL_CONTEXT *f_pCocktailContext,
+    __in                       DRM_DWORD             f_cbData,
+    __inout_bcount( f_cbData ) DRM_BYTE             *f_pbData );
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_Cocktail_CalculateChecksum(
+    __in_bcount( f_cbContentKey )       const DRM_BYTE                         *f_pbContentKey,
+    __in                                const DRM_DWORD                         f_cbContentKey,
+    __out_bcount_opt( *f_pcbChecksum )        DRM_BYTE                         *f_pbChecksum,
+    __inout                                   DRM_DWORD                        *f_pcbChecksum ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_API DRM_RESULT DRM_CALL Drm_Cocktail_InitDecrypt(
+    __inout_ecount( 1 )                                                       OEM_COCKTAIL_CONTEXT *f_pCocktailContext,
+    __in_bcount_opt( DRM_MIN( DRM_CPHR_CB_FOR_INITDECRYPT, f_cbData ) ) const DRM_BYTE             *f_pbLast15,
+    __in                                                                      DRM_DWORD             f_cbData );
+
+EXIT_PK_NAMESPACE;
+
+#endif /* __OEMCOCKTAIL_H__ */
+
diff --git a/prebuilt-v4.4/noarch/include/oem/common/inc/oemcocktailtypes.h b/prebuilt-v4.4/noarch/include/oem/common/inc/oemcocktailtypes.h
new file mode 100644
index 0000000..a827f9d
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/oem/common/inc/oemcocktailtypes.h
@@ -0,0 +1,60 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __OEMCOCKTAILTYPES_H__
+#define __OEMCOCKTAILTYPES_H__
+
+#include <drmerr.h>
+#include <oemdes.h>
+#include <oemrc4types.h>
+#include <oemcbctypes.h>
+#include <oemsha1.h>
+#include <oemaescommon.h>
+
+ENTER_PK_NAMESPACE;
+
+#define DRMCIPHERKEYLEN_RC4        7
+
+/*
+** Legacy PDRM content acquired through ILA will
+** contain a 6-byte Cocktail content key. This is
+** only valid for XMR licenses.
+*/
+#define DRMCIPHERKEYLEN_RC4_PDRM   6
+
+#define DRM_CPHR_CB_FOR_INITDECRYPT 15
+
+#define DRMCIPHERKEYLEN_MAX DRM_MAX( DRM_AES_MAXKEYSIZE, DRMCIPHERKEYLEN_RC4 )
+
+/* Constant indicating the number of times SHA1 is used to get the hash of key. */
+#define SHA_ITERATIONS      5
+/* CHECKSUM_LENGTH indicates the number of bytes in final hash value to use as CHECKSUM. */
+#define CHECKSUM_LENGTH     7
+
+typedef struct __tagOEM_COCKTAIL_CONTEXT
+{
+    DRM_BOOL      fInited;
+    DRM_BYTE      shaOut [OEM_SHA1_DIGEST_LEN];
+    DRM_DWORD     desS1  [2];
+    DRM_DWORD     desS2  [2];
+    DESTable      destable;
+    DRM_CBCKey    mackey;
+    DRM_CBCKey    invmackey;
+    RC4_KEYSTRUCT rc4ks;
+    DRM_CBCState  cbcstate;
+    DRM_DWORD     rc4key[2];
+    DRM_DWORD     rguiLast8[2];
+    DRM_DWORD     cbPacket;
+    DRM_DWORD     iPacket;
+    DRM_BOOL      fDecryptInited;
+} OEM_COCKTAIL_CONTEXT;
+
+EXIT_PK_NAMESPACE;
+
+#endif /* __OEMCOCKTAILTYPES_H__ */
+
diff --git a/prebuilt-v4.4/noarch/include/oem/common/inc/oemcommon.h b/prebuilt-v4.4/noarch/include/oem/common/inc/oemcommon.h
new file mode 100644
index 0000000..109aec7
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/oem/common/inc/oemcommon.h
@@ -0,0 +1,733 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __OEMCOMMON_H__
+#define __OEMCOMMON_H__
+
+#include <drmcompiler.h>
+#include <oemsha1.h>
+#include <oemsha256.h>
+#include <oemcommonmem.h>
+#include <drmbase64.h>
+#include <drmbytemanip.h>
+
+#if defined(__cplusplus) && USE_CLAW
+
+#include <clawrt/rt.h>
+
+#else /* defined(__cplusplus) && USE_CLAW */
+
+#define CLAW_AUTO_RANDOM_CIPHER
+#define CLAW_ATTRIBUTE_NOINLINE
+
+#endif /* defined(__cplusplus) && USE_CLAW */
+
+PREFAST_PUSH_DISABLE_EXPLAINED( __WARNING_NONCONST_PARAM_25004, "OEM Context should never be const." )
+
+ENTER_PK_NAMESPACE;
+
+extern DRM_EXPORT_VAR DRM_CONST_STRING g_dstrDrmPath;
+extern const DRM_EXPORT_VAR DRM_CHAR   g_chPathSeparator;
+extern const DRM_EXPORT_VAR DRM_WCHAR  g_wchPathSeparator;
+
+extern const DRM_CONST_STRING g_dstrPrivKey;
+
+/* Session Expiration Timeout Config Values */
+#define Oem_Config_SETimeout_Key     "SessionExpirationTimeout"
+/*
+** sizeof(static string) includes null terminating byte
+** which we don't want since we are going to append it with session id
+*/
+#define Oem_Config_SETimeout_Key_LEN ( sizeof( Oem_Config_SETimeout_Key ) - 1 )
+
+/* Skew the clock but a fixed offset */
+#define Oem_Config_Timeoffset_Key     "ClockTimeOffset"
+
+/*
+** sizeof(static string) includes null terminating byte
+** which we don't want since we are going to append it with session id
+*/
+#define Oem_Config_Timeoffset_Key_LEN ( sizeof( Oem_Config_Timeoffset_Key ) - 1 )
+
+/* Revocation List Timeout Config Values */
+#define Oem_Config_RLTimeout_Key     "RevocationListTimeout"
+/*
+** sizeof(static string) includes null terminating byte
+** which we don't want since we are going to append it with session id
+*/
+#define Oem_Config_RLTimeout_Key_LEN ( sizeof( Oem_Config_RLTimeout_Key ) - 1 )
+
+#define Oem_Config_NoTxAuth_Key      "NoTxAuth"
+/*
+** sizeof(static string) includes null terminating byte
+** which we don't want since we are going to append it with session id
+*/
+#define Oem_Config_NoTxAuth_Key_LEN ( sizeof( Oem_Config_NoTxAuth_Key ) - 1 )
+
+/* Proximity Detection RTT Threshold */
+#define Oem_Config_ProximityRTTThreshold_Key "ProximityRTTThreshold"
+/*
+ ** sizeof(static string) includes null terminating byte
+ ** which we don't want since we are going to append it with the DWORD value
+ */
+#define Oem_Config_ProximityRTTThreshold_Key_LEN ( sizeof( Oem_Config_ProximityRTTThreshold_Key ) - 1 )
+
+typedef enum DRMFILESPATH
+{
+    CERTPATH = 0,
+    CERTTEMPLATEPATH,
+    HDSPATH,
+    KEYFILEPATH
+} DRMFILESPATH;
+
+typedef enum _DRM_DEVICE_CERT_TYPE
+{
+    DRM_DCT_PLAYREADY_TEMPLATE = 1,
+    DRM_DCT_PLAYREADY_DEVICE,
+    DRM_DCT_PLAYREADY_LPROV,
+} DRM_DEVICE_CERT_TYPE;
+
+/*
+** OEM_MANDATORY:
+** For all devices, this function MUST be implemented by the OEM.
+*/
+DRM_API DRM_RESULT DRM_CALL Oem_GetDRMFullPathName(
+    __deref_out_z DRM_WCHAR **f_ppwszFullPath,
+    __in_opt const DRM_CONST_STRING *f_pdstrFilename,
+    __in DRMFILESPATH f_eFilesPath );
+
+/*
+** OEM_MANDATORY:
+** If the device supports Device Assets (DRM_SUPPORT_DEVICEASSETS=1), this function MUST be implemented by the OEM.
+*/
+DRM_API DRM_RESULT DRM_CALL Oem_Device_GetCert(
+    __in_opt                                  DRM_VOID              *f_pOEMContext,
+    __in                                      DRM_DEVICE_CERT_TYPE   f_eCertType,
+    __out_opt                                 DRM_DEVICE_CERT_TYPE  *f_peCertTypeReturned,
+    __out_bcount_opt( *f_pcbDevCert )         DRM_BYTE              *f_pbDevCert,
+    __inout                                   DRM_DWORD             *f_pcbDevCert );
+
+/*
+** OEM_MANDATORY:
+** If the device supports Device Assets (DRM_SUPPORT_DEVICEASSETS=1), this function MUST be implemented by the OEM.
+*/
+DRM_API DRM_RESULT DRM_CALL Oem_Device_GetOEMProtectedPrivateKeys(
+    __in_opt                              DRM_VOID              *f_pOEMContext,
+    __in                                  DRM_DEVICE_CERT_TYPE   f_eCertType,
+    __out_opt                             DRM_DEVICE_CERT_TYPE  *f_peCertTypeReturned,
+    __out_bcount_opt( *f_pcbKey )         DRM_BYTE              *f_pbKey,
+    __inout                               DRM_DWORD             *f_pcbKey );
+
+/*
+** OEM_MANDATORY:
+** If the device supports the concept of applications then the application id
+** is used at provisioning time to differentiate between different apps.
+*/
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL Oem_Device_GetApplicationID(
+    __out DRM_ID* f_pidApplicationID ) DRM_NO_INLINE_ATTRIBUTE;
+
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL Oem_Device_GetModelInfo(
+    __in_opt DRM_VOID   *f_pOEMContext,
+    __out_ecount_opt(*f_pcchModelInfo) DRM_WCHAR *f_pwchModelInfo,
+    __inout DRM_DWORD *f_pcchModelInfo ) DRM_NO_INLINE_ATTRIBUTE;
+
+PREFAST_PUSH_DISABLE_EXPLAINED(__WARNING_NONCONST_BUFFER_PARAM_25033, "Out params can't be const.")
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL Oem_Config_Read(
+    __in_opt DRM_VOID *f_pOEMContext,
+    __in_z const DRM_CHAR *f_szKey,
+    __out_bcount_opt( *f_pcbValue ) DRM_BYTE *f_pbValue,
+    __inout DRM_DWORD *f_pcbValue );
+PREFAST_POP /* __WARNING_NONCONST_BUFFER_PARAM_25033 "Out params can't be const." */
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL Oem_Config_Write(
+    __in_opt                       DRM_VOID  *f_pOEMContext,
+    __in_z                   const DRM_CHAR  *f_szKey,
+    __in_bcount( f_cbValue ) const DRM_BYTE  *f_pbValue,
+    __in                           DRM_DWORD  f_cbValue );
+
+/*
+** OEM_MANDATORY_CONDITIONALLY:
+** If the device supports Secure Time (DRM_SUPPORT_SECURETIME=1), this function MUST be implemented by the OEM.
+*/
+DRM_API DRM_RESULT DRM_CALL Oem_Clock_GetResetState(
+    __in_opt DRM_VOID *f_pOEMContext,
+    __out DRM_BOOL *f_pfReset );
+
+/*
+** OEM_MANDATORY_CONDITIONALLY:
+** If the device supports Secure Time (DRM_SUPPORT_SECURETIME=1), this function MUST be implemented by the OEM.
+*/
+DRM_API DRM_RESULT DRM_CALL Oem_Clock_SetResetState(
+    __in_opt DRM_VOID *f_pOEMContext,
+    __in DRM_BOOL f_fReset );
+
+PREFAST_PUSH_DISABLE_EXPLAINED(__WARNING_NONCONST_PARAM_25004, "OEM contexts can't be const." )
+
+/*
+** OEM_MANDATORY:
+** For all devices, this function MUST be implemented by the OEM.
+** Note: The OEM implementation of this function must:
+**  1) Have sufficient resolution, specifically <= 20 ms for this function.
+**  2) Continue to increase in value while the process is not running (e.g. while sleeping)
+*/
+DRM_API DRM_DWORD DRM_CALL Oem_Clock_GetTickCount(
+    __in_opt    DRM_VOID      *f_pOEMContext );
+PREFAST_POP /* __WARNING_NONCONST_BUFFER_PARAM_25033 "OEM contexts can't be const." */
+
+/*
+** OEM_MANDATORY_CONDITIONALLY:
+** If the device supports H.264 slice header parsing (DRM_SUPPORT_H264) or profiling (DRM_SUPPORT_PROFILING), this function MUST be implemented by the OEM.
+** Some test functions and tools will also give useful performance output if this function is implemented.
+** Note: This function (when paired with Oem_Clock_QueryPerformanceFrequency) MUST support an overall resolution of 1 millisecond (ms) or better.
+*/
+DRM_API DRM_UINT64 DRM_CALL Oem_Clock_QueryPerformanceCounter(
+    __in_opt    DRM_VOID      *f_pOEMContext );
+
+/*
+** OEM_MANDATORY_CONDITIONALLY:
+** If the device supports H.264 slice header parsing (DRM_SUPPORT_H264) or profiling (DRM_SUPPORT_PROFILING), this function MUST be implemented by the OEM.
+** Some test functions and tools will also give useful performance output if this function is implemented.
+** Note: This function (when paired with Oem_Clock_QueryPerformanceCounter) MUST support an overall resolution of 1 millisecond (ms) or better.
+*/
+DRM_API DRM_UINT64 DRM_CALL Oem_Clock_QueryPerformanceFrequency(
+    __in_opt    DRM_VOID      *f_pOEMContext );
+
+
+/* OEM file IO functions (oemfileio.c). */
+
+/* File Handle */
+typedef DRM_VOID *OEM_FILEHDL;
+#define OEM_INVALID_HANDLE_VALUE ((OEM_FILEHDL)-1)
+
+/* Oem_File_Open Access modes */
+#define OEM_GENERIC_READ        0x80000000UL
+#define OEM_GENERIC_WRITE       0x40000000UL
+#define OEM_GENERIC_EXECUTE     0x20000000UL
+#define OEM_GENERIC_ALL         0x10000000UL
+
+/* Oem_File_Open Share modes */
+#define OEM_FILE_SHARE_NONE     0x00000000UL
+#define OEM_FILE_SHARE_READ     0x00000001UL
+#define OEM_FILE_SHARE_WRITE    0x00000002UL
+
+/* Oem_File_Open Creation dispositions */
+#define OEM_CREATE_NEW          0x00000001UL
+#define OEM_CREATE_ALWAYS       0x00000002UL
+#define OEM_OPEN_EXISTING       0x00000003UL
+#define OEM_OPEN_ALWAYS         0x00000004UL
+#define OEM_TRUNCATE_EXISTING   0x00000005UL
+
+#define OEM_ATTRIBUTE_HIDDEN    0x00000002UL
+#define OEM_ATTRIBUTE_SYSTEM    0x00000004UL
+#define OEM_ATTRIBUTE_NORMAL    0x00000080UL
+
+#define OEM_FILE_FLAG_WRITE_THROUGH 0x80000000
+
+/* SetFilePointer move methods */
+#define OEM_FILE_BEGIN          0
+#define OEM_FILE_CURRENT        1
+#define OEM_FILE_END            2
+
+/*
+** For information on these functions and parameters see MSDN
+** For Oem_File_Open see CreateFile in MSDN -- not all flags are supported.
+*/
+
+/**********************************************************************
+** Function:    Oem_File_Open
+** Synopsis:    Creates, opens, reopens a file
+** Arguments:   [f_pOEMContext]--Optional pointer to OEM specific context data
+**              [f_pwszFileName]--Pointer to DRM_WCHAR buffer holding File
+**              name.
+**              [f_dwAccessMode]--Type of access to the object.
+**              OEM_GENERIC_READ, OEM_GENERIC_WRITE,
+**              OEM_GENERIC_EXECUTE and OEM_GENERIC_ALL
+**              [f_dwShareMode]--Sharing mode of the object
+**              OEM_FILE_SHARE_NONE, OEM_FILE_SHARE_READ
+**              and OEM_FILE_SHARE_WRITE
+**              [f_dwCreationDisposition]--Action to take on files
+**              that exist, and on files that do not exist.
+**              OEM_CREATE_NEW, OEM_CREATE_ALWAYS, OEM_OPEN_EXISTING
+**              OEM_OPEN_ALWAYS and OEM_TRUNCATE_EXISTING
+**              [f_dwAttributes]--File attributes and flags.
+**              OEM_ATTRIBUTE_HIDDEN, OEM_ATTRIBUTE_SYSTEM and
+**              OEM_ATTRIBUTE_NORMAL
+** Returns:     Valid OEM FILE HANDLE. If fails,
+**              returns OEM_INVALID_HANDLE_VALUE
+**
+** OEM_MANDATORY:
+** For all devices, this function MUST be implemented by the OEM.
+**
+***********************************************************************/
+DRM_API OEM_FILEHDL DRM_CALL Oem_File_Open(
+    __in_opt DRM_VOID *f_pOEMContext,
+    __in_z const DRM_WCHAR *f_pwszFileName,
+    __in DRM_DWORD f_dwAccessMode,
+    __in DRM_DWORD f_dwShareMode,
+    __in DRM_DWORD f_dwCreationDisposition,
+    __in DRM_DWORD f_dwAttributes );
+
+/**********************************************************************
+** Function:    Oem_File_Close
+** Synopsis:    Closes an open handle opened by Oem_File_Open.
+** Arguments:   [f_hFile]--File Handle
+** Returns:     Non zero value if succeeds, zero if failed.
+**
+** OEM_MANDATORY:
+** For all devices, this function MUST be implemented by the OEM.
+**
+***********************************************************************/
+DRM_API DRM_BOOL DRM_CALL Oem_File_Close(
+    __in OEM_FILEHDL f_hFile );
+
+/**********************************************************************
+** Function:    Oem_File_Delete
+** Synopsis:    Deletes a file with the given name
+** Arguments:   [f_pwszFileName]--Path to file to be deleted
+** Returns:     Non zero value if succeeds, zero if failed.
+**
+** OEM_MANDATORY:
+** For all devices, this function MUST be implemented by the OEM.
+**
+***********************************************************************/
+DRM_API DRM_BOOL DRM_CALL Oem_File_Delete(
+    __in_z const DRM_WCHAR *f_pwszFileName );
+
+/**********************************************************************
+** Function:    Oem_File_Read
+** Synopsis:    Reads data from a file.
+** Arguments:   [f_hFile]--File Handle
+**              [f_pvBuffer]--Pointer to the buffer that receives the
+**              data read from the file.
+**              [f_nNumberOfBytesToRead]--Number of bytes to read.
+**              [f_pNumberOfBytesRead]--Total number of bytes read.
+** Returns:     Non zero value if succeeds, zero if failed.
+**
+** OEM_MANDATORY:
+** For all devices, this function MUST be implemented by the OEM.
+**
+***********************************************************************/
+DRM_API DRM_BOOL DRM_CALL Oem_File_Read(
+    __in OEM_FILEHDL f_hFile,
+    __out_ecount_part( f_nNumberOfBytesToRead, *f_pNumberOfBytesRead ) DRM_VOID *f_pvBuffer,
+    __in DRM_DWORD f_nNumberOfBytesToRead,
+    __out DRM_DWORD *f_pNumberOfBytesRead );
+
+/**********************************************************************
+** Function:    Oem_File_Write
+** Synopsis:    Writes data to a file.
+** Arguments:   [f_hFile]--File Handle
+**              [f_pvBuffer]--Pointer to the buffer holding the
+**              data read to the file.
+**              [f_nNumberOfBytesToWrite]--Number of bytes to write.
+**              [f_pNumberOfBytesWritten]--Total number of bytes written.
+** Returns:     Non zero value if succeeds, zero if failed.
+**
+** OEM_MANDATORY:
+** For all devices, this function MUST be implemented by the OEM.
+**
+***********************************************************************/
+DRM_API DRM_BOOL DRM_CALL Oem_File_Write(
+    __in OEM_FILEHDL f_hFile,
+    __in_ecount( f_nNumberOfBytesToWrite ) DRM_VOID *f_pvBuffer,
+    __in DRM_DWORD f_nNumberOfBytesToWrite,
+    __out DRM_DWORD *f_pNumberOfBytesWritten );
+
+/**********************************************************************
+** Function:    Oem_File_SetFilePointer
+** Synopsis:    Sets File pointer.
+** Arguments:   [f_lDistanceToMove]--Number of bytes to move
+**              [f_dwMoveMethod]--Starting point for the file pointer move
+**              OEM_FILE_BEGIN, OEM_FILE_CURRENT and  OEM_FILE_END
+**              [f_pdwNewFilePointer]--New File pointer.
+** Returns:     Non zero value if succeeds, zero if failed.
+**
+** OEM_MANDATORY:
+** For all devices, this function MUST be implemented by the OEM.
+**
+***********************************************************************/
+DRM_API DRM_BOOL DRM_CALL Oem_File_SetFilePointer(
+    __in OEM_FILEHDL f_hFile,
+    __in DRM_LONG f_lDistanceToMove,
+    __in DRM_DWORD f_dwMoveMethod,
+    __out_opt DRM_DWORD *f_pdwNewFilePointer );
+
+/**********************************************************************
+** Function:    Oem_File_Lock
+** Synopsis:    Immidiately locks the portion of specified file.
+** Arguments:   [f_hFile]--File Handle
+**              [f_fExclusive]-- If TRUE, locks file for exclusive access
+**              by the calling process.
+**              [f_dwFileOffset]--Offset from begining of file.
+**              [f_nNumberOfBytesToLock]--Number of bytes to lock.
+**              [f_fWait]--Whether to wait for the lock to complete.
+** Returns:     Non zero value if succeeds, zero if failed.
+**
+** OEM_MANDATORY:
+** If the device supports locking (DRM_SUPPORT_FILE_LOCKING=1), this function MUST be implemented by the OEM.
+**
+***********************************************************************/
+DRM_API DRM_BOOL DRM_CALL Oem_File_Lock(
+    __in OEM_FILEHDL f_hFile,
+    __in DRM_BOOL f_fExclusive,
+    __in DRM_DWORD f_dwFileOffset,
+    __in DRM_DWORD f_nNumberOfBytesToLock,
+    __in DRM_BOOL f_fWait );
+
+/**********************************************************************
+** Function:    Oem_File_Unlock
+** Synopsis:    Unlocks the locked portion of specified file.
+** Arguments:   [f_hFile]--File Handle
+**              [f_dwFileOffset]--Offset from begining of file.
+**              [f_nNumberOfBytesToLock]--Number of bytes to lock.
+** Returns:     Non zero value if succeeds, zero if failed.
+**
+** OEM_MANDATORY:
+** If the device supports locking (DRM_SUPPORT_FILE_LOCKING=1), this function MUST be implemented by the OEM.
+**
+***********************************************************************/
+DRM_API DRM_BOOL DRM_CALL Oem_File_Unlock(
+    __in OEM_FILEHDL f_hFile,
+    __in DRM_DWORD f_dwFileOffset,
+    __in DRM_DWORD f_nNumberOfBytesToUnlock );
+
+/**********************************************************************
+** Function:    Oem_File_SetEndOfFile
+** Synopsis:    Moves the end-of-file (EOF) position for the
+**              specified file to the current position of the file
+**              pointer.
+** Arguments:   [f_hFile]--File Handle
+** Returns:     Non zero value if succeeds, zero if failed.
+**
+** OEM_MANDATORY:
+** For all devices, this function MUST be implemented by the OEM.
+**
+***********************************************************************/
+DRM_NO_INLINE DRM_API DRM_BOOL DRM_CALL Oem_File_SetEndOfFile(
+    __in OEM_FILEHDL f_hFile) DRM_NO_INLINE_ATTRIBUTE;
+
+/**********************************************************************
+** Function:    Oem_File_GetSize
+** Synopsis:    Gets size of the file.
+** Arguments:   [f_hFile]--File Handle
+**              [f_pdwFileSize]--Pointer to DRM_DWORD to get the size.
+** Returns:     Non zero value if succeeds, zero if failed.
+**
+** OEM_MANDATORY:
+** For all devices, this function MUST be implemented by the OEM.
+**
+***********************************************************************/
+DRM_API DRM_BOOL DRM_CALL Oem_File_GetSize(
+    __in OEM_FILEHDL f_hFile,
+    __out DRM_DWORD  *f_pdwFileSize );
+
+/**********************************************************************
+** Function:    Oem_File_FlushBuffers
+** Synopsis:    Flushes the buffers of the specified file and causes
+**              all buffered data to be written to the file.
+** Arguments:   [f_hFile]--File Handle
+** Returns:     Non zero value if succeeds, zero if failed.
+**
+** OEM_MANDATORY:
+** For all devices, this function MUST be implemented by the OEM.
+**
+***********************************************************************/
+DRM_API DRM_BOOL DRM_CALL Oem_File_FlushBuffers(
+    __in OEM_FILEHDL f_hFile );
+
+/* OEM time functions (oemtime.c). */
+
+/**********************************************************************
+** Function:    Oem_Clock_SystemTimeToFileTime
+** Synopsis:    Converts System Time format to File time format.
+** Arguments:   [f_lpSystemTime]--Pointer to DRMSYSTEMTIME structure
+**              containing system time
+**              [f_lpFileTime]--Pointer to DRMFILETIME structure to get
+**              the time.
+** Returns:     Non zero value if succeeds, zero if failed.
+**
+** OEM_MANDATORY:
+** For all devices, this function MUST be implemented by the OEM.
+**
+***********************************************************************/
+DRM_API DRM_BOOL DRM_CALL Oem_Clock_SystemTimeToFileTime(
+    __in const DRMSYSTEMTIME *f_lpSystemTime,
+    __out DRMFILETIME *f_lpFileTime );
+
+/**********************************************************************
+** Function:    Oem_Clock_FileTimeToSystemTime
+** Synopsis:    Converts File time format to System Time format.
+** Arguments:   [f_lpFileTime]--Pointer to DRMFILETIME structure
+**              containing file time
+**              [f_lpSystemTime]--Pointer to DRMSYSTEMTIME structure to
+**              get the time.
+** Returns:     Non zero value if succeeds, zero if failed.
+**
+** OEM_MANDATORY:
+** For all devices, this function MUST be implemented by the OEM.
+**
+***********************************************************************/
+DRM_API DRM_BOOL DRM_CALL Oem_Clock_FileTimeToSystemTime(
+    __in const DRMFILETIME *f_lpFileTime,
+    __out DRMSYSTEMTIME *f_lpSystemTime );
+
+/**********************************************************************
+** Function:    Oem_Clock_GetSystemTime
+** Synopsis:    Gets current System time. It is expressed in UTC.
+** Arguments:   [f_pOEMContext]--OEM specific data
+**              [f_lpSystemTime]--Pointer to DRMSYSTEMTIME structure
+**              to get the time.
+**
+** OEM_MANDATORY:
+** For all devices, this function MUST be implemented by the OEM.
+**
+***********************************************************************/
+DRM_API_VOID DRM_VOID DRM_CALL Oem_Clock_GetSystemTime(
+    __in_opt    DRM_VOID      *f_pOEMContext,
+    __out       DRMSYSTEMTIME *f_psystime );
+
+/**********************************************************************
+** Function:    Oem_Clock_GetSystemTimeOffsetAsInt64
+** Synopsis:    Gets the offset of the SecureClock time from the SystemTime. 
+**              It is computed from UTC time and returned as a signed int64.
+** Arguments:   [f_pOEMContext]--OEM specific data
+**              [f_pfiletime]--Pointer to DRM_INT64 to store the offset.
+**
+** OEM_OPTIONAL:
+** You do not need to replace this function implementation. However, this
+** function MUST have a valid implementation for your PlayReady port.
+**
+***********************************************************************/
+DRM_NO_INLINE DRM_API_VOID DRM_VOID DRM_CALL Oem_Clock_GetSystemTimeOffsetAsInt64(
+    __in_opt    DRM_VOID    *f_pOEMContext,
+    __out       DRM_INT64   *f_pi64SecureClockOffset );
+
+/**********************************************************************
+** Function:    Oem_Clock_GetSystemTimeAsFileTime
+** Synopsis:    Gets current System time. It is expressed in UTC.
+** Arguments:   [f_pOEMContext]--OEM specific data
+**              [f_pfiletime]--Pointer to DRMFILETIME structure
+**              to get the time.
+**
+** OEM_MANDATORY:
+** For all devices, this function MUST be implemented by the OEM.
+**
+***********************************************************************/
+DRM_API_VOID DRM_VOID DRM_CALL Oem_Clock_GetSystemTimeAsFileTime(
+    __in_opt    DRM_VOID    *f_pOEMContext,
+    __out       DRMFILETIME *f_pfiletime );
+
+/**********************************************************************
+** Function:    Oem_Clock_SetSystemTime
+** Synopsis:    Sets the System time. It is expressed in UTC.
+** Arguments:   [f_pOEMContext]--OEM specific data
+**              [f_lpSystemTime]--Pointer to DRMSYSTEMTIME structure
+**              holding the time.
+**
+** OEM_MANDATORY:
+** For all devices, this function MUST be implemented by the OEM.
+**
+***********************************************************************/
+DRM_API_VOID DRM_VOID DRM_CALL Oem_Clock_SetSystemTime(
+    __in_opt       DRM_VOID      *f_pOEMContext,
+    __in     const DRMSYSTEMTIME *f_lpSystemTime );
+
+/**********************************************************************
+** Function:    Oem_Clock_SetSecureClockOffsetValue
+** Synopsis:    Sets the offset between the secure core clock and the
+**              system clock to the provided value.
+** Arguments:   [f_pOEMContext]--OEM specific data
+**              [f_pui64SecureTime]--DRM_UINT64 value to set the offset
+**              equal to.
+**              [f_IsSecureClockOffsetNegative]--DRM_BOOL stating if the
+**              the offset should push the secure time 'forward' or 
+**              'back' in time.
+**
+** OEM_OPTIONAL:
+** You do not need to replace this function implementation. However, this
+** function MUST have a valid implementation for your PlayReady port.
+**
+***********************************************************************/
+DRM_API_VOID DRM_VOID DRM_CALL Oem_Clock_SetSecureClockOffsetValue(
+    __in_opt       DRM_VOID   *f_pOEMContext,
+    __in     const DRM_UINT64  f_ui64SecureTime,
+    __in     const DRM_BOOL    f_IsSecureClockOffsetNegative );
+
+/**********************************************************************
+** Function:    Oem_Clock_SetSecureClockOffset
+** Synopsis:    Sets the offset between the secure core clock and the
+**              system clock to the difference between the System Time
+**              and the provided SecureTime
+** Arguments:   [f_pOEMContext]--OEM specific data
+**              [f_pui64SecureTime]--Pointer to DRM_UINT64 structure
+**              holding the current secure time.
+**
+** OEM_MANDATORY:
+** For all devices, this function MUST be implemented by the OEM.
+**
+***********************************************************************/
+DRM_API_VOID DRM_VOID DRM_CALL Oem_Clock_SetSecureClockOffset(
+    __in_opt       DRM_VOID   *f_pOEMContext,
+    __in     const DRM_UINT64 *f_pui64SecureTime );
+
+
+PREFAST_PUSH_DISABLE_EXPLAINED(__WARNING_NONCONST_PARAM_25004, "Out params can't be const")
+
+/* OEM platform initialization functions (oemimpl.c). */
+/*
+** OEM_MANDATORY:
+** For all devices, this function MUST be implemented by the OEM.
+*/
+DRM_API DRM_RESULT DRM_CALL Oem_Platform_Init( __inout_opt DRM_VOID *f_pvUserCtx );
+
+/*
+** OEM_MANDATORY:
+** For all devices, this function MUST be implemented by the OEM.
+*/
+DRM_API DRM_RESULT DRM_CALL Oem_Platform_UnInit( __inout_opt DRM_VOID *f_pvUserCtx );
+
+PREFAST_POP /* __WARNING_NONCONST_PARAM_25004 */
+
+
+/* OEM memory allocation functions (oemimpl.c). */
+
+/*
+** OEM_MANDATORY:
+** For all devices, this function MUST be implemented by the OEM.
+** All memory allocations must be 8-byte aligned.
+*/
+DRM_API DRM_VOID* DRM_CALL Oem_MemAlloc(
+    __in DRM_DWORD f_cbSize );
+
+/*
+** OEM_MANDATORY:
+** For all devices, this function MUST be implemented by the OEM.
+*/
+DRM_NO_INLINE DRM_API_VOID DRM_VOID DRM_CALL Oem_MemFree(
+    __drv_freesMem( Oem ) __in DRM_VOID *f_pv );
+
+#define SAFE_OEM_FREE( p ) DRM_DO {                                                                                 \
+PREFAST_PUSH_DISABLE_EXPLAINED( __WARNING_REDUNDANT_POINTER_TEST_28922, "Safe macros always check for null" )       \
+    if ( (p) != NULL )                                                                                              \
+    {                                                                                                               \
+        Oem_MemFree( ( DRM_VOID * )(p) );                                                                           \
+        (p) = NULL;                                                                                                 \
+    }                                                                                                               \
+PREFAST_POP  /* __WARNING_REDUNDANT_POINTER_TEST_28922 */                                                           \
+} DRM_WHILE_FALSE
+
+#define SAFE_SECURE_OEM_FREE( p, c ) DRM_DO {                                                                       \
+PREFAST_PUSH_DISABLE_EXPLAINED( __WARNING_REDUNDANT_POINTER_TEST_28922, "Safe macros always check for null" )       \
+    if ((p) != NULL)                                                                                                \
+    {                                                                                                               \
+        OEM_SECURE_ZERO_MEMORY( (DRM_VOID*)(p), (c) );                                                              \
+        Oem_MemFree( (DRM_VOID*)(p) );                                                                              \
+        (p) = NULL;                                                                                                 \
+    }                                                                                                               \
+PREFAST_POP  /* __WARNING_REDUNDANT_POINTER_TEST_28922 */                                                           \
+} DRM_WHILE_FALSE
+
+#define OEM_MEM_REALLOC( __ptrType, __pvToRealloc, __cbNew, __cbOld ) DRM_DO {                                      \
+    __ptrType __pvNew = NULL;                                                                                       \
+    if( ( __cbNew ) > 0 )                                                                                           \
+    {                                                                                                               \
+        ChkMem( __pvNew = (__ptrType)Oem_MemAlloc( __cbNew ) );                                                     \
+        if( ( __pvToRealloc ) != NULL && ( __cbOld ) > 0 )                                                          \
+        {                                                                                                           \
+            MEMCPY( __pvNew, __pvToRealloc, DRM_MIN( ( (DRM_DWORD)( __cbNew ) ), ( (DRM_DWORD)( __cbOld ) ) ) );    \
+        }                                                                                                           \
+    }                                                                                                               \
+    SAFE_OEM_FREE( __pvToRealloc );                                                                                 \
+    ( __pvToRealloc ) = __pvNew;                                                                                    \
+} DRM_WHILE_FALSE
+
+/*
+** OEM_MANDATORY:
+** For all devices, this function MUST be implemented by the OEM.
+*/
+DRM_API_VOID DRM_VOID DRM_CALL Oem_Random_SetSeed(
+    __in_opt DRM_VOID *f_pOEMContext,
+    __in const DRM_UINT64 f_qwNewSeed );
+
+PREFAST_PUSH_DISABLE_EXPLAINED(__WARNING_NONCONST_PARAM_25004, "OEM contexts can't be const" );
+/*
+** OEM_MANDATORY:
+** For all devices, this function MUST be implemented by the OEM.
+*/
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL Oem_Random_GetBytes(
+    __in_opt               DRM_VOID  *f_pOEMContext,
+    __out_bcount(f_cbData) DRM_BYTE  *f_pbData,
+    __in                   DRM_DWORD  f_cbData ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL Oem_Random_GetEntropy(
+    __in_opt                 DRM_VOID  *f_pOEMContext,
+    __out_bcount( f_cbData ) DRM_BYTE  *f_pbData,
+    __in                     DRM_DWORD  f_cbData ) DRM_NO_INLINE_ATTRIBUTE;
+PREFAST_POP
+
+/*
+** OEM_MANDATORY:
+** If the device supports XML hashing (DRM_SUPPORT_XMLHASH=1), this function MUST be implemented by the OEM.
+*/
+DRM_API DRM_DWORD DRM_CALL Oem_GetCurrentThreadId( DRM_VOID );
+
+DRM_API_VOID DRM_VOID DRM_CALL Oem_Hds_ClearBlockHeaderCache( DRM_VOID );
+
+DRM_API DRM_RESULT DRM_CALL Oem_Hds_CheckBlockHeaderCache(
+    __in      DRM_DWORD   f_dwBlockNumber,
+    __in_opt  OEM_FILEHDL f_hHDSFileHandle,
+    __out_opt DRM_DWORD  *f_pdwBlockHeaderMetadata,
+    __out_bcount_opt( f_cbBytesToRead ) DRM_BYTE   *f_pbBlock,
+    __in      DRM_DWORD   f_cbBytesToRead );
+
+DRM_API DRM_RESULT DRM_CALL Oem_Hds_UpdateBlockHeaderCache(
+    __in                                      DRM_DWORD   f_dwBlockNumber,
+    __in_opt                                  OEM_FILEHDL f_hHDSFileHandle,
+    __in                                      DRM_DWORD   f_dwBlockHeaderMetadata,
+    __in_bcount_opt( f_cbBytesToWrite ) const DRM_BYTE   *f_pbBlock,
+    __in                                      DRM_DWORD   f_cbBytesToWrite );
+
+DRM_API_VOID DRM_VOID DRM_CALL Oem_Hds_ClearBlockHeaderCacheForFile(
+    __in    OEM_FILEHDL f_hHDSFileHandle ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_API DRM_RESULT DRM_CALL Oem_Hds_GetParams(
+    __in_opt        DRM_VOID  *f_pOEMContext,
+    __in      const DRM_WCHAR *f_pwszDeviceStoreName,
+    __out_opt       DRM_DWORD *f_pdwDataStoreFileSizeInitKB,
+    __out_opt       DRM_DWORD *f_pdwDataStoreFileSizeGrowKB,
+    __out_opt       DRM_DWORD *f_pdwDataStoreBlockSize );
+
+typedef struct
+{
+    DRM_BOOL    fFreezeTickCount;
+    DRM_DWORD   dwTickCount;
+} DRM_TEST_OEM_CONTEXT;
+
+
+/* Code Coverage functions (oemimpl.c) */
+DRM_API_VOID DRM_VOID DRM_CALL Oem_CodeCoverage_FlushData(
+    __in_opt const DRM_VOID  *f_pOEMContext );
+
+typedef       DRM_VOID * OEM_CRYPTO_HANDLE;
+typedef const DRM_VOID * OEM_CRYPTO_CONST_HANDLE;
+#define OEM_CRYPTO_HANDLE_INVALID ((OEM_CRYPTO_HANDLE)0)
+
+typedef enum __tagDRM_PKCRYPTO_SUPPORTED_ALGORITHMS
+{
+    eDRM_ECC_Reserved_P160  = 1,     /* Do not reuse: Compatibility */
+    eDRM_ECC_P256           = 2,
+    eDRM_RSA                = 3
+} DRM_PKCRYPTO_SUPPORTED_ALGORITHMS;
+
+EXIT_PK_NAMESPACE;
+
+PREFAST_POP     /* __WARNING_NONCONST_PARAM_25004 */
+
+#endif /* __OEMCOMMON_H__ */
+
diff --git a/prebuilt-v4.4/noarch/include/oem/common/inc/oemcommonmem.h b/prebuilt-v4.4/noarch/include/oem/common/inc/oemcommonmem.h
new file mode 100644
index 0000000..e9359bc
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/oem/common/inc/oemcommonmem.h
@@ -0,0 +1,253 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __OEMCOMMONMEM_H__
+#define __OEMCOMMONMEM_H__
+
+#include <drmtypes.h>
+
+ENTER_PK_NAMESPACE;
+
+#undef OEM_SECURE_ZERO_MEMORY
+
+/* OEM special implementation functions (oemimpl.c). */
+#if defined(DRM_MSC_VER) || defined(DRM_GNUC_MAJOR)
+
+DRM_ALWAYS_INLINE DRM_VOID * DRM_CALL DRMCRT_ScrubMemory(
+    __out_bcount( f_cbCount ) DRM_VOID  *f_ptr,
+    __in DRM_DWORD  f_cbCount  ) DRM_ALWAYS_INLINE_ATTRIBUTE;
+
+DRM_ALWAYS_INLINE DRM_VOID * DRM_CALL DRMCRT_ScrubMemory(
+    __out_bcount( f_cbCount ) DRM_VOID  *f_ptr,
+    __in DRM_DWORD  f_cbCount  )
+{
+    /*
+    ** Casting the pointer to volatile makes MS and GNU compilers act
+    ** as if another thread can see and access the buffer. This
+    ** prevents the compiler from reordering or optimizing away
+    ** the writes.
+    */
+
+    volatile char *vptr = (volatile char *)f_ptr;
+
+    while (f_cbCount)
+    {
+        *vptr = 0;
+        vptr++;
+        f_cbCount--;
+    }
+
+    return f_ptr;
+}
+
+#define OEM_SECURE_ZERO_MEMORY DRMCRT_ScrubMemory
+
+#endif /* defined(DRM_MSC_VER) || defined(DRM_GNUC_MAJOR) */
+
+/*
+** OEM_MANDATORY:
+** For all devices, this macro MUST be implemented by the OEM.
+*/
+#ifndef OEM_SECURE_ZERO_MEMORY
+#error "Please provide implementation for OEM_SECURE_ZERO_MEMORY macro.\
+ OEM_SECURE_ZERO_MEMORY is called to scrub memory on critical pieces of data before freeing buffers or exiting local scope.\
+ Using of memset function on these buffers is not sufficient, since compiler\
+ may optimize out zeroing of buffers that are not used afterwards.\
+ Please verify the implementation will not be optimized out by your compiler.\
+ Consult the documentation for your compiler to see how this can be done. \
+ The Microsoft supplied example is only guaranteed to work on Microsoft compilers. "
+
+#endif /* ifndef OEM_SECURE_ZERO_MEMORY */
+
+#undef OEM_SECURE_MEMCPY
+#undef OEM_SECURE_MEMCPY_IDX
+#undef OEM_SECURE_MEMSET
+#undef OEM_SECURE_ARE_EQUAL
+#undef OEM_SECURE_DWORDCPY
+#undef OEM_SECURE_DIGITTCPY
+
+#if defined(DRM_MSC_VER) || defined(DRM_GNUC_MAJOR)
+
+DRM_ALWAYS_INLINE DRM_VOID * DRM_CALL DRMCRT_LocalMemcpy(
+    __out_bcount_full( f_cbCount )  DRM_VOID  *f_pOut,
+    __in_bcount( f_cbCount ) const  DRM_VOID  *f_pIn,
+    __in                            DRM_DWORD  f_cbCount ) DRM_ALWAYS_INLINE_ATTRIBUTE;
+
+DRM_ALWAYS_INLINE DRM_VOID * DRM_CALL DRMCRT_LocalMemcpy(
+    __out_bcount_full( f_cbCount )  DRM_VOID  *f_pOut,
+    __in_bcount( f_cbCount ) const  DRM_VOID  *f_pIn,
+    __in                            DRM_DWORD  f_cbCount )
+{
+    /* w/o volatile some compilers can figure out this is an
+       implementation of a memcpy */
+    volatile const char * pIn = (const char *) f_pIn;
+    char * pOut = (char *) f_pOut;
+    while (f_cbCount--)
+    {
+        *pOut++ = *pIn++;
+    }
+    return f_pOut;
+}
+
+DRM_ALWAYS_INLINE DRM_VOID * DRM_CALL DRMCRT_LocalMemset(
+    __out_bcount_full( f_cbCount )  DRM_VOID  *f_pOut,
+    __in                            DRM_BYTE   f_cbValue,
+    __in                            DRM_DWORD  f_cbCount ) DRM_ALWAYS_INLINE_ATTRIBUTE;
+
+DRM_ALWAYS_INLINE DRM_VOID * DRM_CALL DRMCRT_LocalMemset(
+    __out_bcount_full( f_cbCount )  DRM_VOID  *f_pOut,
+    __in                            DRM_BYTE   f_cbValue,
+    __in                            DRM_DWORD  f_cbCount )
+{
+    /* w/o volatile some compilers can figure out this is an
+       implementation of a memset */
+    volatile unsigned char * pOut = (unsigned char *) f_pOut;
+    while (f_cbCount--)
+    {
+        *pOut++ = f_cbValue;
+    }
+    return f_pOut;
+}
+
+DRM_ALWAYS_INLINE DRM_VOID * DRM_CALL DRMCRT_LocalDWORDSetZero(
+    __out_bcount_full( f_cdwCount ) DRM_DWORD  *f_pdwOut,
+    __in                            DRM_DWORD   f_cdwCount ) DRM_ALWAYS_INLINE_ATTRIBUTE;
+
+DRM_ALWAYS_INLINE DRM_VOID * DRM_CALL DRMCRT_LocalDWORDSetZero(
+    __out_bcount_full( f_cdwCount ) DRM_DWORD  *f_pdwOut,
+    __in                            DRM_DWORD   f_cdwCount )
+{
+    /* w/o volatile some compilers can figure out this is an
+       implementation of a memset */
+    volatile DRM_DWORD * pdwOut = f_pdwOut;
+    while (f_cdwCount--)
+    {
+        *pdwOut++ = 0;
+    }
+    return f_pdwOut;
+}
+
+DRM_ALWAYS_INLINE DRM_BOOL DRM_CALL DRMCRT_LocalAreEqual(
+    __in_bcount( f_cbCount ) const  DRM_VOID  *f_pLHS,
+    __in_bcount( f_cbCount ) const  DRM_VOID  *f_pRHS,
+    __in                            DRM_DWORD  f_cbCount ) DRM_ALWAYS_INLINE_ATTRIBUTE;
+
+DRM_ALWAYS_INLINE DRM_BOOL DRM_CALL DRMCRT_LocalAreEqual(
+    __in_bcount( f_cbCount ) const  DRM_VOID  *f_pLHS,
+    __in_bcount( f_cbCount ) const  DRM_VOID  *f_pRHS,
+    __in                            DRM_DWORD  f_cbCount )
+{
+    /*
+    ** Without volatile, some compilers can figure out this is an
+    ** implementation of a memcmp-similar function or can
+    ** optimize out checks which we don't want.
+    */
+    volatile DRM_DWORD dwResult = 0;
+
+#if TARGET_SUPPORTS_UNALIGNED_DWORD_POINTERS
+
+    /* Optimize: When unaligned pointers are allowed, compare in DRM_DWORD-sized groups. */
+    volatile const DRM_DWORD *pLHS = (const DRM_DWORD*) f_pLHS;
+    volatile const DRM_DWORD *pRHS = (const DRM_DWORD*) f_pRHS;
+
+    while( f_cbCount >= sizeof(DRM_DWORD) )
+    {
+        dwResult |= (*pLHS ^ *pRHS);
+        pLHS++;
+        pRHS++;
+        f_cbCount -= sizeof(DRM_DWORD);
+    }
+
+#else   /* TARGET_SUPPORTS_UNALIGNED_DWORD_POINTERS */
+
+    volatile const DRM_BYTE *pLHS = (const DRM_BYTE*) f_pLHS;
+    volatile const DRM_BYTE *pRHS = (const DRM_BYTE*) f_pRHS;
+
+#endif  /* TARGET_SUPPORTS_UNALIGNED_DWORD_POINTERS */
+
+    while( f_cbCount-- )
+    {
+PREFAST_PUSH_DISABLE_EXPLAINED( __WARNING_READ_OVERRUN_6385, "pLHS and pRHS both have length of f_cbCount and are properly checked before usage." )
+        volatile const DRM_BYTE bLHS = ((const DRM_BYTE*)pLHS)[f_cbCount];
+        volatile const DRM_BYTE bRHS = ((const DRM_BYTE*)pRHS)[f_cbCount];
+PREFAST_POP /* __WARNING_READ_OVERRUN_6385 */
+        dwResult |= (DRM_DWORD)( bLHS ^ bRHS );
+    }
+
+    return ( dwResult == 0 );
+}
+
+#if DRM_SUPPORT_INLINEDWORDCPY
+
+DRM_ALWAYS_INLINE DRM_VOID * DRM_CALL DRMCRT_LocalDWORDcpy(
+    __out_ecount_full( f_cdwCount )  DRM_DWORD  *f_pdwOut,
+    __in_ecount( f_cdwCount ) const  DRM_DWORD  *f_pdwIn,
+    __in                             DRM_DWORD  f_cdwCount ) DRM_ALWAYS_INLINE_ATTRIBUTE;
+
+PREFAST_PUSH_DISABLE_EXPLAINED( __WARNING_SUPERFLUOUS_CAST_25059, "Some compilers require the cast due to the volatile keyword" )
+DRM_ALWAYS_INLINE DRM_VOID * DRM_CALL DRMCRT_LocalDWORDcpy(
+    __out_ecount_full( f_cdwCount )  DRM_DWORD  *f_pdwOut,
+    __in_ecount( f_cdwCount ) const  DRM_DWORD  *f_pdwIn,
+    __in                             DRM_DWORD  f_cdwCount )
+{
+    /* w/o volatile some compilers can figure out this is an
+       implementation of a memcpy */
+    volatile const DRM_DWORD * pdwIn = (const DRM_DWORD *) f_pdwIn;
+    DRM_DWORD * pdwOut = (DRM_DWORD *) f_pdwOut;
+    while (f_cdwCount--)
+    {
+        *pdwOut++ = *pdwIn++;
+    }
+    return pdwOut;
+}
+PREFAST_POP     /* __WARNING_SUPERFLUOUS_CAST_25059 */
+
+#define OEM_SECURE_DWORDCPY(out, in, ecount) DRMCRT_LocalDWORDcpy((DRM_DWORD*)(out), (const DRM_DWORD*)(in), (ecount))
+#else   /* DRM_SUPPORT_INLINEDWORDCPY */
+#define OEM_SECURE_DWORDCPY(out, in, ecount) OEM_SECURE_MEMCPY((out), (in), (ecount)*sizeof(DRM_DWORD))
+#endif  /* DRM_SUPPORT_INLINEDWORDCPY */
+
+#if DRM_DWORDS_PER_DIGIT == 1
+#define OEM_SECURE_DIGITTCPY OEM_SECURE_DWORDCPY
+#define OEM_SECURE_DIGITZEROMEMORY DRMCRT_LocalDWORDSetZero
+#endif  /* DRM_DWORDS_PER_DIGIT == 1 */
+
+#define OEM_SECURE_MEMCPY DRMCRT_LocalMemcpy
+
+#define OEM_SECURE_MEMCPY_IDX(dest, dest_offset, source, source_offset, count) DRM_DO {             \
+    DRM_BYTE *pbDest   = (DRM_BYTE*)( dest );                                                       \
+    DRM_BYTE *pbSource = (DRM_BYTE*)( source );                                                     \
+    ChkArg( pbDest != NULL && pbSource != NULL );                                                   \
+    ChkDR( DRM_DWordPtrAdd( (DRM_SIZE_T)pbDest,   ( dest_offset ),   (DRM_SIZE_T*)&pbDest ) );      \
+    ChkDR( DRM_DWordPtrAdd( (DRM_SIZE_T)pbSource, ( source_offset ), (DRM_SIZE_T*)&pbSource ) );    \
+    __analysis_assume( pbDest == (dest)+(dest_offset) && pbSource == (source)+(source_offset) );    \
+    OEM_SECURE_MEMCPY( (char*)pbDest, (const char*)pbSource, (count) );                             \
+} DRM_WHILE_FALSE
+
+#define OEM_SECURE_MEMSET DRMCRT_LocalMemset
+
+#define OEM_SECURE_ARE_EQUAL DRMCRT_LocalAreEqual
+
+#endif /* defined(DRM_MSC_VER) || defined(DRM_GNUC_MAJOR) */
+
+/*
+** OEM_MANDATORY:
+** For all devices, these macros MUST be implemented by the OEM.
+*/
+#if !defined(OEM_SECURE_MEMCPY) || !defined(OEM_SECURE_MEMCPY_IDX) || !defined(OEM_SECURE_DWORDCPY) || !defined(OEM_SECURE_DIGITTCPY) || !defined(OEM_SECURE_DIGITZEROMEMORY)
+
+#error "Please provide implementation for OEM_SECURE_* macros.\
+ OEM_SECURE_* is used for copying or setting bytes where calls to CRT implementation of \
+ mem* functions cannot be used."
+
+#endif /* !defined(OEM_SECURE_MEMCPY) || !defined(OEM_SECURE_MEMCPY_IDX) || !defined(OEM_SECURE_DWORDCPY) || !defined(OEM_SECURE_DIGITTCPY) || !defined(OEM_SECURE_DIGITZEROMEMORY) */
+
+EXIT_PK_NAMESPACE;
+
+#endif /* __OEMCOMMONMEM_H__ */
+
diff --git a/prebuilt-v4.4/noarch/include/oem/common/inc/oemcryptoctx.h b/prebuilt-v4.4/noarch/include/oem/common/inc/oemcryptoctx.h
new file mode 100644
index 0000000..9d931a3
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/oem/common/inc/oemcryptoctx.h
@@ -0,0 +1,62 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+
+#ifndef __OEMCRYPTOCTX_H__
+#define __OEMCRYPTOCTX_H__
+
+#include <drmstkalloc.h>
+
+ENTER_PK_NAMESPACE;
+
+#define PKSYMM_ALG_TYPE_RC4        1
+
+/*
+** The largest single allocation in the crypto code is in mod_exp
+** which allocates up to this many bytes: (1 << MAX_BUCKET_WIDTH) * (max digits) * sizeof(digit)
+** MAX_BUCKET_WIDTH from modexp.c is 6, so (1 << MAX_BUCKET_WIDTH) == 0x40
+** Meanwhile, max digits is 0x80 used by 4096-bit-RSA.
+** So the largest single allocation is 0x40 * 0x80 * 4 == 0x8000 bytes.
+** This allocation dwarfs all the other buffer allocations that might be
+** used in conjunction with it by a factor of more than 0x10, and no
+** codepath that doesn't use mod_exp comes anywhere close to using this
+** large a buffer. Therefore, set the size to 0x8800:
+** 0x8000 for that one allocation and an additional
+** 0x0800 for all other allocations on that codepath.
+*/
+#define DRM_PKCRYPTO_CONTEXT_BUFFER_INTERNAL_SIZE 0x8800
+
+/* This is size for PK_DATA structure defined in oemeccp256.h.
+   This size of structure on x86 is 3036.
+   use 3200 to allow larger size for different architecture.
+*/
+#define DRM_PK_DATA_SIZE                          3200
+
+
+#define LNGQDW 5
+#define LNGQ DRM_DWORDS_TO_DIGITS(LNGQDW)
+#define QBITS (LNGQDW * DRM_RADIX_BITS)
+
+/*
+** Defines the buffer size for DRMBIGNUM_CONTEXT_STRUCT structure defined in oemeccp256.h
+** It is possible that the structure can be defined smaller by removing PK_DATA size,
+** but it is used in various places
+** with various assumptions. Because of that we choose to keep
+** this size as it is currently and decrease only when necessary.
+*/
+#define DRM_PKCRYPTO_CONTEXT_BUFFER_SIZE  ( DRM_PKCRYPTO_CONTEXT_BUFFER_INTERNAL_SIZE + sizeof( DRM_STACK_ALLOCATOR_CONTEXT ) + DRM_PK_DATA_SIZE + sizeof( DRM_DWORD ) + sizeof(DRM_VOID*) + DRM_OBFUS_PTR_WRAP_SIZE )
+
+typedef DRM_OBFUS_FIXED_ALIGN struct __tagDRM_CRYPTO_CONTEXT
+{
+    DRM_BYTE rgbCryptoContext[ DRM_PKCRYPTO_CONTEXT_BUFFER_SIZE ];   /* size of the buffer pkcrypto code needs. Note this may have alignment problems. */
+} DRM_CRYPTO_CONTEXT;
+
+EXIT_PK_NAMESPACE;
+
+#endif /* __OEMCRYPTOCTX_H__ */
+
diff --git a/prebuilt-v4.4/noarch/include/oem/common/inc/oemdebug.h b/prebuilt-v4.4/noarch/include/oem/common/inc/oemdebug.h
new file mode 100644
index 0000000..431af77
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/oem/common/inc/oemdebug.h
@@ -0,0 +1,58 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __OEMDEBUG_H__
+#define __OEMDEBUG_H__
+
+#include <drmnamespace.h>
+#include <drmtypes.h>
+#include <stdarg.h>
+
+ENTER_PK_NAMESPACE;
+#if DRM_BUILD_PROFILE == DRM_BUILD_PROFILE_ANDROID
+typedef va_list DRM_VA_LIST;
+#elif DRM_BUILD_PROFILE == DRM_BUILD_PROFILE_LINUX
+typedef va_list DRM_VA_LIST;
+#else
+typedef DRM_VOID* DRM_VA_LIST;
+#endif
+
+typedef DRM_VOID ( DRM_CALL *Oem_Debug_Trace_Hook_Callback )(
+    __in const DRM_CHAR     *f_pszFormat,
+    __in       DRM_VA_LIST   f_ArgList );
+
+typedef DRM_VOID ( DRM_CALL *Oem_Debug_Assert_Hook_Callback )(
+    __in           DRM_BOOL  fAssert,
+    __in_opt const DRM_CHAR *assertcmd,
+    __in_opt const DRM_CHAR *file,
+    __in           DRM_LONG  line );
+
+DRM_API_VOID DRM_VOID DRM_CALL Oem_Debug_Trace(
+    __in_z const DRM_CHAR *szFmt,
+    ... );
+
+DRM_API_VOID DRM_VOID DRM_CALL Oem_Debug_HookTrace(
+    __in Oem_Debug_Trace_Hook_Callback pNewTraceFcn );
+
+DRM_API_VOID DRM_VOID DRM_CALL Oem_Debug_Assert(
+    __in           DRM_BOOL  fAssert,
+    __in_opt const DRM_CHAR *assertcmd,
+    __in_opt const DRM_CHAR *file,
+    __in           DRM_LONG  line );
+
+DRM_API_VOID DRM_VOID DRM_CALL Oem_Debug_HookAssert(
+    __in Oem_Debug_Assert_Hook_Callback pNewAssertFcn );
+
+
+EXIT_PK_NAMESPACE;
+
+#endif /* __OEMDEBUG_H__ */
+
+
+
+
diff --git a/prebuilt-v4.4/noarch/include/oem/common/inc/oemdes.h b/prebuilt-v4.4/noarch/include/oem/common/inc/oemdes.h
new file mode 100644
index 0000000..6f23b50
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/oem/common/inc/oemdes.h
@@ -0,0 +1,87 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __OEMDES_H__
+#define __OEMDES_H__
+
+#include <drmtypes.h>
+
+ENTER_PK_NAMESPACE;
+
+#ifndef __DES_H__
+
+typedef struct _destable
+{
+    DRM_DWORD keytab[16][2];
+} DESTable;
+
+#define DES_TABLESIZE    sizeof(DESTable)
+#define DES_BLOCKLEN    8
+#define DES_KEYSIZE        8
+
+#endif /* __DES_H__ */
+
+#define DES_ENCRYPT     1
+#define DES_DECRYPT     0
+
+
+/*********************************************************************
+**
+**  Function:  deskey
+**
+**  Synopsis:  Fill in the DESTable struct with the decrypt and encrypt
+**               key expansions.
+**
+**               Assumes that the second parameter points to DES_KEYSIZE
+**             bytes of key.
+**
+**  Arguments:
+**     [pTable] -- A DESTable structure that will be filled according to the DES key-schedule algorithm.
+**     [rgbKey] -- The DES symmetric key to be used.
+**
+**  Returns:  None
+**
+*********************************************************************/
+
+DRM_API_VOID DRM_VOID DRM_CALL DRM_DES_KeySetup(
+    __out                            DESTable *pTable,
+    __in_bcount( DES_KEYSIZE ) const DRM_BYTE  rgbKey[ DES_KEYSIZE ] );
+
+
+/*********************************************************************
+**
+**  Function:  DRM_DES_Cipher
+**
+**  Synopsis:
+**
+**  Arguments:
+**     [rgbIn] -- Array of bytes to encrypt
+**     [rgbOut] -- Encrypted array of bytes
+**     [pTable] -- DES table initialized by DRM_DES_KeySetup
+**     [op] -- Operation to perform ( DES_ENCRYPT or DES_DECRYPT )
+**
+**  Returns:  None
+**
+*********************************************************************/
+
+DRM_API_VOID DRM_VOID DRM_CALL DRM_DES_Cipher(
+    __in_bcount( DES_BLOCKLEN )  const DRM_BYTE  rgbIn [ DES_BLOCKLEN ],
+    __out_bcount( DES_BLOCKLEN )       DRM_BYTE  rgbOut[ DES_BLOCKLEN ],
+    __in                               DESTable *pTable,
+    __in                               DRM_LONG  op );
+
+
+#define DRM_DES_Encrypt( x, y, z ) \
+    DRM_DES_Cipher( (x), (y), (z), DES_ENCRYPT )
+
+#define DRM_DES_Decrypt( x, y, z ) \
+    DRM_DES_Cipher( (x), (y), (z), DES_DECRYPT )
+
+EXIT_PK_NAMESPACE;
+
+#endif /* __OEMDES_H__ */
diff --git a/prebuilt-v4.4/noarch/include/oem/common/inc/oemeccp256.h b/prebuilt-v4.4/noarch/include/oem/common/inc/oemeccp256.h
new file mode 100644
index 0000000..693bf92
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/oem/common/inc/oemeccp256.h
@@ -0,0 +1,264 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+#ifndef __OEMECCP256_H__
+#define __OEMECCP256_H__
+
+#include <drmerr.h>
+#include <ecurve.h>
+#include <oemcryptoctx.h>
+
+ENTER_PK_NAMESPACE;
+
+/*
+** P256 integer size defines
+*/
+#define ECC_P256_INTEGER_SIZE_IN_BITS      256
+#define ECC_P256_INTEGER_SIZE_IN_BYTES     32
+#define ECC_P256_INTEGER_SIZE_IN_DIGITS    ( DRM_BITS_TO_DIGITS( ECC_P256_INTEGER_SIZE_IN_BITS ) )
+#define ECC_P256_INTEGER_SIZE_IN_ECAFFINES ( ECC_P256_INTEGER_SIZE_IN_BYTES / sizeof( digit_t ) )
+#define ECC_P256_PRIVKEY_SIZE_IN_BITS      ( ECC_P256_INTEGER_SIZE_IN_BITS ) /* privkeys are 256bit integers */
+#define ECC_P256_PRIVKEY_SIZE_IN_BYTES     ( ECC_P256_INTEGER_SIZE_IN_BYTES )
+
+/*
+** P256 point size defines
+*/
+#define ECC_P256_POINT_SIZE_IN_BITS        ( 2 * ECC_P256_INTEGER_SIZE_IN_BITS )
+#define ECC_P256_POINT_SIZE_IN_BYTES       ( 2 * ECC_P256_INTEGER_SIZE_IN_BYTES )
+#define ECC_P256_POINT_SIZE_IN_DIGITS      ( DRM_BITS_TO_DIGITS( ECC_P256_POINT_SIZE_IN_BITS ) )
+#define ECC_P256_POINT_SIZE_IN_ECAFFINES   ( 2 * ( ECC_P256_INTEGER_SIZE_IN_BYTES / sizeof( digit_t ) ) )
+#define ECC_P256_PUBKEY_SIZE_IN_BITS       ( ECC_P256_POINT_SIZE_IN_BITS ) /* pubkeys are EC Points */
+#define ECC_P256_PUBKEY_SIZE_IN_BYTES      ( ECC_P256_POINT_SIZE_IN_BYTES ) /* pubkeys are EC Points */
+
+
+/*
+** P256 integer size defines
+*/
+#define ECC_P256_CIPHERTEXT_SIZE_IN_BYTES  ( 2 * ECC_P256_POINT_SIZE_IN_BYTES )
+#define ECC_P256_PLAINTEXT_SIZE_IN_BYTES   ( ECC_P256_INTEGER_SIZE_IN_BYTES )
+#define ECDSA_P256_SIGNATURE_SIZE_IN_BYTES ( ECC_P256_POINT_SIZE_IN_BYTES )
+
+#define ECC_POINT_ADDITION    ( ( DRM_LONG ) 1 )
+#define ECC_POINT_SUBTRACTION ( ( DRM_LONG ) -1 )
+
+/*
+** Supplied temps needed for certain P256 EC functions. Note these are upper bounds,
+** some operations may not require as large of temps, this is a potential optimization.
+*/
+#define ECC_P256_LNGRED2          ( ( ECC_P256_INTEGER_SIZE_IN_DIGITS + 1 ) / 2 )
+#define ECC_P256_NDIGTEMPS        ( ( 19 * ECC_P256_INTEGER_SIZE_IN_DIGITS ) + 6 )
+#define ECC_P256_VERIFY_TEMPS     ( ECC_P256_NDIGTEMPS )
+#define ECC_P256_SIGN_TEMPS       ( ECC_P256_NDIGTEMPS )
+#define ECC_P256_ENCRYPT_TEMPS    ( ECC_P256_NDIGTEMPS )
+#define ECC_P256_POINTMUL_TEMPS   ( ECC_P256_NDIGTEMPS )
+#define ECC_P256_POINTADD_TEMPS   ( ECC_P256_NDIGTEMPS )
+#define ECC_P256_INTEGERADD_TEMPS ( ECC_P256_NDIGTEMPS )
+#define ECC_P256_DECRYPT_TEMPS    ( ECC_P256_NDIGTEMPS )
+#define ECC_P256_GENKEYPAIR_TEMPS ( ECC_P256_NDIGTEMPS )
+
+/*
+** Struct Defines for ECC P256 and the AES XMR struct that will be encrypted and decrypted by it.
+*/
+typedef struct __tagCIPHERTEXT_P256_2POINTS
+{
+    DRM_BYTE m_rgbC1[ ECC_P256_POINT_SIZE_IN_BYTES ];
+    DRM_BYTE m_rgbC2[ ECC_P256_POINT_SIZE_IN_BYTES ];
+} CIPHERTEXT_P256_2POINTS;
+
+typedef struct __tagPUBKEY_P256
+{
+    DRM_BYTE m_rgbPubkey[ ECC_P256_POINT_SIZE_IN_BYTES ];
+} PUBKEY_P256;
+
+typedef struct __tagPRIVKEY_P256
+{
+    DRM_BYTE m_rgbPrivkey[ ECC_P256_INTEGER_SIZE_IN_BYTES ];
+} PRIVKEY_P256;
+
+typedef struct __tagCIPHERTEXT_P256
+{
+    DRM_BYTE m_rgbCiphertext [ ECC_P256_CIPHERTEXT_SIZE_IN_BYTES ];
+} CIPHERTEXT_P256;
+
+typedef struct __tagSIGNATURE_P256
+{
+    DRM_BYTE m_rgbSignature[ ECDSA_P256_SIGNATURE_SIZE_IN_BYTES ];
+} SIGNATURE_P256;
+
+typedef struct __tagPLAINTEXT_P256
+{
+    /*
+    ** HMAC key goes in 1st half, content key goes in 2nd half.
+    */
+    DRM_BYTE m_rgbPlaintext[ ECC_P256_PLAINTEXT_SIZE_IN_BYTES ];
+} PLAINTEXT_P256;
+
+/*
+** Function Protos
+*/
+DRM_API DRM_RESULT DRM_CALL OEM_ECC_GenerateHMACKey_P256(
+    __inout PLAINTEXT_P256   *f_pKeys,
+    __inout struct bigctx_t  *f_pBigCtx,
+    __in    DRM_DWORD         f_cbBigCtx );
+
+DRM_API DRM_RESULT DRM_CALL OEM_ECC_CanMapToPoint_P256(
+    __in_ecount( ECC_P256_INTEGER_SIZE_IN_DIGITS ) const  digit_t   f_rgdNumber[],
+    __inout                                        struct bigctx_t *f_pBigCtx );
+
+DRM_API DRM_RESULT DRM_CALL OEM_ECC_MapX2PointP256(
+    __in_ecount(ECC_P256_INTEGER_SIZE_IN_DIGITS)   const digit_t          *f_pX,
+    __out_ecount(ECC_P256_INTEGER_SIZE_IN_DIGITS)        digit_t          *f_pY,
+    __inout_ecount_opt( ECC_P256_ENCRYPT_TEMPS )         digit_t           f_rgdSuppliedTemps[],
+    __inout                                       struct bigctx_t         *f_pBigCtx );
+
+DRM_API_VOID DRM_VOID DRM_CALL OEM_ECC_ZeroPublicKey_P256(
+    __inout        PUBKEY_P256     *f_pPubkey );
+
+DRM_API_VOID DRM_VOID DRM_CALL OEM_ECC_ZeroPrivateKey_P256(
+    __inout        PRIVKEY_P256    *f_pPrivkey );
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_ECC_GenerateTeeSigningPublicKey_P256(
+    __in    const   PUBKEY_P256    *f_pPubkeyOriginal,
+    __out           DRM_BYTE        f_rgbPubkeyDoubled[],
+    __inout struct  bigctx_t       *f_pBigCtx,
+    __in            DRM_DWORD       f_cbBigCtx );
+
+DRM_API DRM_RESULT DRM_CALL OEM_ECC_Decrypt_P256(
+    __in    const  PRIVKEY_P256    *f_pPrivkey,
+    __in    const  CIPHERTEXT_P256 *f_pCiphertext,
+    __out          PLAINTEXT_P256  *f_pPlaintext,
+    __inout struct bigctx_t        *f_pBigCtx,
+    __in           DRM_DWORD        f_cbBigCtx );
+
+DRM_API DRM_RESULT DRM_CALL OEM_ECC_Encrypt_P256(
+    __in    const  PUBKEY_P256      *f_pPubkey,
+    __in    const  PLAINTEXT_P256   *f_pPlaintext,
+    __out          CIPHERTEXT_P256  *f_pCiphertext,
+    __inout struct bigctx_t         *f_pBigCtx,
+    __in           DRM_DWORD         f_cbBigCtx );
+
+DRM_API DRM_RESULT DRM_CALL OEM_ECC_GenKeyPair_P256(
+    __out          PUBKEY_P256  *f_pPubKey,
+    __out          PRIVKEY_P256 *f_pPrivKey,
+    __inout struct bigctx_t     *f_pBigCtx,
+    __in           DRM_DWORD     f_cbBigCtx );
+
+DRM_API DRM_RESULT DRM_CALL OEM_ECC_GenKeyPairRestrictedPriv_P256(
+    __out          PUBKEY_P256  *f_pPubKey,
+    __out          PRIVKEY_P256 *f_pPrivKey,
+    __inout struct bigctx_t     *f_pBigCtx,
+    __in           DRM_DWORD     f_cbBigCtx );
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_ECDSA_Sign_P256(
+    __in_ecount( f_cbMessageLen ) const  DRM_BYTE         f_rgbMessage[],
+    __in                          const  DRM_DWORD        f_cbMessageLen,
+    __in                          const  PRIVKEY_P256    *f_pPrivkey,
+    __out                                SIGNATURE_P256  *f_pSignature,
+    __inout                       struct bigctx_t        *f_pBigCtx,
+    __in                                 DRM_DWORD        f_cbBigCtx ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_ECDSA_SignHash_P256(
+    __in_ecount( f_cbMessageLen ) const  DRM_BYTE         f_rgbMessage[],
+    __in                          const  DRM_DWORD        f_cbMessageLen,
+    __in                          const  PRIVKEY_P256    *f_pPrivkey,
+    __out                                SIGNATURE_P256  *f_pSignature,
+    __inout                       struct bigctx_t        *f_pBigCtx,
+    __in                                 DRM_DWORD        f_cbBigCtx ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_API DRM_RESULT DRM_CALL OEM_ECDSA_Verify_P256(
+    __in_ecount( f_cbMessageLen )              const  DRM_BYTE         f_rgbMessage[],
+    __in                                       const  DRM_DWORD        f_cbMessageLen,
+    __in                                       const  PUBKEY_P256     *f_pPubkey,
+    __in                                       const  SIGNATURE_P256  *f_pSignature,
+    __inout                                    struct bigctx_t        *f_pBigCtx,
+    __in                                              DRM_DWORD        f_cbBigCtx ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_API DRM_RESULT DRM_CALL Convert_BigEndianBytesToDigits(
+  __in_ecount( ( f_cBits + 7 ) / 8 )              const DRM_BYTE  f_rgbInBytes[],
+  __out_ecount( DRM_BITS_TO_DIGITS( f_cBits ) )         digit_t   f_rgdOutDigits[],
+  __in                                            const DRM_DWORD f_cBits );
+
+DRM_API DRM_RESULT DRM_CALL Convert_DigitsToBigEndianBytes(
+  __in_ecount( DRM_BITS_TO_DIGITS( f_cBits ) )      const digit_t   f_rgdInDigits[],
+  __out_ecount( ( f_cBits + 7 ) / 8 )                     DRM_BYTE  f_rgbOutBytes[],
+  __in                                              const DRM_DWORD f_cBits );
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL Convert_P256_PointToPlaintext(
+    __in_ecount( ECC_P256_POINT_SIZE_IN_ECAFFINES ) const  digit_t          f_rgptPoint[],
+    __in_ecount( 1 )                                const  ecurve_t        *f_pEcurve,
+    __out_ecount( 1 )                                      PLAINTEXT_P256  *f_pPlaintext ) DRM_NO_INLINE_ATTRIBUTE;
+
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL Convert_P256_BigEndianBytesToPoint(
+    __in_ecount( ECC_P256_POINT_SIZE_IN_BYTES )              const  DRM_BYTE   f_rgbInBytes[],
+    __in_ecount( 1 )                                         const  ecurve_t  *f_pEcurve,
+    __out_ecount( ECC_P256_POINT_SIZE_IN_ECAFFINES )                digit_t    f_rgptOutPoint[],
+    __inout                                                  struct bigctx_t  *f_pBigCtx ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_API DRM_RESULT DRM_CALL Convert_P256_BigEndianBytesToDigits(
+    __in_ecount( ECC_P256_INTEGER_SIZE_IN_BYTES )              const DRM_BYTE f_rgdInBytes[],
+    __out_ecount( ECC_P256_INTEGER_SIZE_IN_DIGITS )                  digit_t  f_rgbOutDigits[] );
+
+DRM_API DRM_RESULT DRM_CALL Convert_P256_BigEndianBytesToDigitsModOrder(
+    __in_ecount( ECC_P256_INTEGER_SIZE_IN_BYTES )   const DRM_BYTE  f_rgbBytes[],
+    __in_ecount( 1 )                                const ecurve_t *f_pEcurve,
+    __out_ecount( ECC_P256_INTEGER_SIZE_IN_DIGITS )       digit_t   f_rgdDigits[] );
+
+DRM_API DRM_RESULT DRM_CALL Convert_P256_ModularIntToDigitsModOrder(
+    __in_ecount( ECC_P256_INTEGER_SIZE_IN_ECAFFINES ) const  digit_t   f_rgecInModularInt[],
+    __in_ecount( 1 )                                  const  ecurve_t *f_pEcurve,
+    __out_ecount( ECC_P256_INTEGER_SIZE_IN_DIGITS )          digit_t   f_rgbOutDigits[] );
+
+DRM_API DRM_RESULT DRM_CALL Convert_P256_DigitsToBigEndianBytes(
+    __in_ecount( ECC_P256_INTEGER_SIZE_IN_DIGITS )              const digit_t  f_rgdInDigits[],
+    __out_ecount( ECC_P256_INTEGER_SIZE_IN_BYTES )                    DRM_BYTE f_rgbOutBytes[] );
+
+#define OEM_ECC_ZeroPrivateKey( pprivkey ) OEM_ECC_ZeroPrivateKey_P256( ( PRIVKEY_P256* )pprivkey );
+
+DRM_EXPORT_VAR extern DRM_GLOBAL_CONST ecurve_t g_Ecurve;
+
+#define OEM_ECC_PKInit( pContext, pOEMContext  ) OEM_ECC_InitializeBignumStackOEMCtx( pContext, pOEMContext )
+
+/* Zeroes out bignum stack, not thread safe */
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_ECC_InitializeBignumStack(
+    __inout DRM_VOID* f_pContext ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_ECC_InitializeBignumStackOEMCtx(
+    __inout DRM_VOID* f_pContext,
+    __in_opt DRM_VOID* f_pOEMContext ) DRM_NO_INLINE_ATTRIBUTE;
+
+typedef struct __DRMBIGNUM_CONTEXT_STRUCT
+{
+    DRM_STACK_ALLOCATOR_CONTEXT oHeap;
+    union
+    {
+        DRM_VOID *pOEMContext;
+        DRM_VOID *pOEMTEEContext;
+    } oContext;
+    DRM_BYTE  rgbHeap[ 1 ]; /* DRM_PKCRYPTO_CONTEXT_BUFFER_INTERNAL_SIZE for full RSA operation */
+} DRMBIGNUM_CONTEXT_STRUCT;
+
+#if DRM_SUPPORT_PRECOMPUTE_GTABLE
+#define BIGCTX_T_SIZE_FOR_ECC_ONLY  8182
+#else /* DRM_SUPPORT_PRECOMPUTE_GTABLE */
+#if DRM_64BIT_TARGET == 1
+#define BIGCTX_T_SIZE_FOR_ECC_ONLY  2100
+#else /* DRM_64BIT_TARGET == 1*/
+/*
+** can map point needs a bit less than 1800
+** sign and verify ECDSA are ok with around 1300
+** it is expected as can map point calculates square root,
+** while the others do not.
+*/
+#define BIGCTX_T_SIZE_FOR_ECC_ONLY  1800
+#endif /* DRM_64BIT_TARGET == 1*/
+#endif /* DRM_SUPPORT_PRECOMPUTE_GTABLE */
+
+EXIT_PK_NAMESPACE;
+
+#endif /* __OEMECCP256_H__ */
+
diff --git a/prebuilt-v4.4/noarch/include/oem/common/inc/oemeccp256impl.h b/prebuilt-v4.4/noarch/include/oem/common/inc/oemeccp256impl.h
new file mode 100644
index 0000000..53ed0a3
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/oem/common/inc/oemeccp256impl.h
@@ -0,0 +1,151 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+#ifndef __OEMECCP256IMPL_H__
+#define __OEMECCP256IMPL_H__
+
+#include <drmerr.h>
+#include <ecurve.h>
+#include <oemeccp256.h>
+
+ENTER_PK_NAMESPACE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_ECC_InitializeBignumStackOEMCtxImpl(
+    __inout  DRM_VOID* f_pContext,
+    __in     DRM_DWORD f_cbContextSize,
+    __in_opt DRM_VOID* f_pOEMContext ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_ECC_InitializeBignumStackImpl(
+    __inout  DRM_VOID* f_pContext,
+    __in     DRM_DWORD f_cbContextSize ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_API DRM_RESULT DRM_CALL OEM_ECC_GenerateHMACKey_P256Impl(
+    __inout                     PLAINTEXT_P256   *f_pKeys,
+    __inout_bcount(f_cbBigCtx)  struct bigctx_t  *f_pBigCtx,
+    __in                        DRM_DWORD         f_cbBigCtx ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_API DRM_RESULT DRM_CALL OEM_ECC_CanMapToPoint_P256Impl(
+    __in_ecount( ECC_P256_INTEGER_SIZE_IN_DIGITS ) const  digit_t   f_rgdNumber[],
+    __inout                                        struct bigctx_t *f_pBigCtx ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_API DRM_RESULT DRM_CALL OEM_ECC_MapX2PointP256Impl(
+    __in_ecount(ECC_P256_INTEGER_SIZE_IN_DIGITS)   const digit_t  *f_pX,
+    __out_ecount(ECC_P256_INTEGER_SIZE_IN_DIGITS)        digit_t  *f_pY,
+    __inout_ecount_opt( ECC_P256_ENCRYPT_TEMPS )         digit_t   f_rgdSuppliedTemps[],
+    __inout                                       struct bigctx_t *f_pBigCtx ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_API_VOID DRM_VOID DRM_CALL OEM_ECC_ZeroPublicKey_P256Impl(
+    __inout        PUBKEY_P256     *f_pPubkey );
+
+DRM_API_VOID DRM_VOID DRM_CALL OEM_ECC_ZeroPrivateKey_P256Impl(
+    __inout        PRIVKEY_P256    *f_pPrivkey );
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_ECC_GenerateTeeSigningPublicKey_P256Impl(
+    __in     const  PUBKEY_P256    *f_pPubkeyOriginal,
+    __out           DRM_BYTE        f_rgbPubkeyDoubled[],
+    __inout  struct bigctx_t       *f_pBigCtx,
+    __in            DRM_DWORD       f_cbBigCt ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_ECC_Decrypt_P256Impl(
+    __in    const  PRIVKEY_P256    *f_pPrivkey,
+    __in    const  CIPHERTEXT_P256 *f_pCiphertext,
+    __out          PLAINTEXT_P256  *f_pPlaintext,
+    __inout struct bigctx_t        *f_pBigCtx,
+    __in           DRM_DWORD        f_cbBigCtx ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_ECC_Encrypt_P256Impl(
+    __in    const  PUBKEY_P256      *f_pPubkey,
+    __in    const  PLAINTEXT_P256   *f_pPlaintext,
+    __out          CIPHERTEXT_P256  *f_pCiphertext,
+    __inout struct bigctx_t         *f_pBigCtx,
+    __in           DRM_DWORD         f_cbBigCtx ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_ECC_GenKeyPair_P256Impl(
+    __out          PUBKEY_P256  *f_pPubKey,
+    __out          PRIVKEY_P256 *f_pPrivKey,
+    __inout struct bigctx_t     *f_pBigCtx,
+    __in           DRM_DWORD     f_cbBigCtx ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_ECC_GenKeyPairRestrictedPriv_P256Impl(
+    __out          PUBKEY_P256  *f_pPubKey,
+    __out          PRIVKEY_P256 *f_pPrivKey,
+    __inout struct bigctx_t     *f_pBigCtx,
+    __in           DRM_DWORD     f_cbBigCtx ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_ECDSA_SignHash_P256Impl(
+    __in_ecount( f_cbHash )       const  DRM_BYTE        f_rgbHash[],
+    __in                          const  DRM_DWORD       f_cbHash,
+    __in                          const  PRIVKEY_P256   *f_pPrivkey,
+    __out                                SIGNATURE_P256 *f_pSignature,
+    __inout                       struct bigctx_t       *f_pBigCtx,
+    __in                                 DRM_DWORD       f_cbBigCtx ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_ECDSA_Sign_P256Impl(
+    __in_ecount( f_cbMessageLen ) const  DRM_BYTE         f_rgbMessage[],
+    __in                          const  DRM_DWORD        f_cbMessageLen,
+    __in                          const  PRIVKEY_P256    *f_pPrivkey,
+    __out                                SIGNATURE_P256  *f_pSignature,
+    __inout                       struct bigctx_t        *f_pBigCtx,
+    __in                                 DRM_DWORD        f_cbBigCtx ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_ECDSA_Verify_P256Impl(
+    __in_ecount( f_cbMessageLen )              const  DRM_BYTE        f_rgbMessage[],
+    __in                                       const  DRM_DWORD       f_cbMessageLen,
+    __in                                       const  PUBKEY_P256    *f_pPubkey,
+    __in                                       const  SIGNATURE_P256 *f_pSignature,
+    __inout                                    struct bigctx_t       *f_pBigCtx,
+    __in                                              DRM_DWORD       f_cbBigCtx ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL Convert_BigEndianBytesToDigitsImpl(
+  __in_ecount( ( f_cBits + 7 ) / 8 )              const DRM_BYTE  f_rgbInBytes[],
+  __out_ecount( DRM_BITS_TO_DIGITS( f_cBits ) )         digit_t   f_rgdOutDigits[],
+                                                  const DRM_DWORD f_cBits ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_API DRM_RESULT DRM_CALL Convert_DigitsToBigEndianBytesImpl(
+  __in_ecount( DRM_BITS_TO_DIGITS( f_cBits ) )      const digit_t   f_rgdInDigits[],
+  __out_ecount( ( f_cBits + 7 ) / 8 )                     DRM_BYTE  f_rgbOutBytes[],
+  __in                                              const DRM_DWORD f_cBits );
+
+DRM_API DRM_RESULT DRM_CALL Convert_P256_PointToPlaintextImpl(
+    __in_ecount( ECC_P256_POINT_SIZE_IN_ECAFFINES ) const  digit_t          f_rgptPoint[],
+    __in_ecount( 1 )                                const  ecurve_t        *f_pEcurve,
+    __out_ecount( 1 )                                      PLAINTEXT_P256  *f_pPlaintext );
+
+
+DRM_API DRM_RESULT DRM_CALL Convert_P256_BigEndianBytesToPointImpl(
+    __in_ecount( ECC_P256_POINT_SIZE_IN_BYTES )              const  DRM_BYTE   f_rgbInBytes[],
+    __in_ecount( 1 )                                         const  ecurve_t  *f_pEcurve,
+    __out_ecount( ECC_P256_POINT_SIZE_IN_ECAFFINES )                digit_t    f_rgptOutPoint[],
+    __inout                                                  struct bigctx_t  *f_pBigCtx );
+
+DRM_API DRM_RESULT DRM_CALL Convert_P256_BigEndianBytesToDigitsImpl(
+    __in_ecount( ECC_P256_INTEGER_SIZE_IN_BYTES )              const DRM_BYTE f_rgdInBytes[],
+    __out_ecount( ECC_P256_INTEGER_SIZE_IN_DIGITS )                  digit_t  f_rgbOutDigits[] );
+
+DRM_API DRM_RESULT DRM_CALL Convert_P256_BigEndianBytesToDigitsModOrderImpl(
+    __in_ecount( ECC_P256_INTEGER_SIZE_IN_BYTES )   const DRM_BYTE  f_rgbBytes[],
+    __in_ecount( 1 )                                const ecurve_t *f_pEcurve,
+    __out_ecount( ECC_P256_INTEGER_SIZE_IN_DIGITS )       digit_t   f_rgdDigits[] );
+
+DRM_API DRM_RESULT DRM_CALL Convert_P256_ModularIntToDigitsModOrderImpl(
+    __in_ecount( ECC_P256_INTEGER_SIZE_IN_ECAFFINES ) const  digit_t   f_rgecInModularInt[],
+    __in_ecount( 1 )                                  const  ecurve_t *f_pEcurve,
+    __out_ecount( ECC_P256_INTEGER_SIZE_IN_DIGITS )          digit_t   f_rgbOutDigits[] );
+
+DRM_API DRM_RESULT DRM_CALL Convert_P256_DigitsToBigEndianBytesImpl(
+    __in_ecount( ECC_P256_INTEGER_SIZE_IN_DIGITS )              const digit_t  f_rgdInDigits[],
+    __out_ecount( ECC_P256_INTEGER_SIZE_IN_BYTES )                    DRM_BYTE f_rgbOutBytes[] );
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL Convert_P256_PointToBigEndianBytes(
+    __in_ecount( ECC_P256_POINT_SIZE_IN_ECAFFINES )           const digit_t   f_rgptInPoint[],
+    __in_ecount( 1 )                                          const ecurve_t *f_pEcurve,
+    __out_ecount( ECC_P256_POINT_SIZE_IN_BYTES )                    DRM_BYTE  f_rgbOutBytes[] ) DRM_NO_INLINE_ATTRIBUTE;
+
+EXIT_PK_NAMESPACE;
+
+#endif /* __OEMECCP256IMPL_H__ */
+
diff --git a/prebuilt-v4.4/noarch/include/oem/common/inc/oemmd5.h b/prebuilt-v4.4/noarch/include/oem/common/inc/oemmd5.h
new file mode 100644
index 0000000..2509ef7
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/oem/common/inc/oemmd5.h
@@ -0,0 +1,31 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __OEMMD5_H__
+#define __OEMMD5_H__ 1
+
+#include <drmerr.h>
+#include <oemmd5types.h>
+
+ENTER_PK_NAMESPACE;
+
+DRM_API_VOID DRM_VOID DRM_CALL DRM_MD5_Init(
+    __inout DRM_MD5_CTX *f_contextMD5 );
+
+DRM_API_VOID DRM_VOID DRM_CALL DRM_MD5_Update(
+    __inout                     DRM_MD5_CTX *f_contextMD5,
+    __in_bcount(f_cbData) const DRM_VOID    *f_rgbData,
+    __in                        DRM_DWORD    f_cbData );
+
+DRM_API_VOID DRM_VOID DRM_CALL DRM_MD5_Final(
+    __inout DRM_MD5_CTX *f_contextMD5 );
+
+EXIT_PK_NAMESPACE;
+
+#endif /* __OEMMD5_H__ */
+
diff --git a/prebuilt-v4.4/noarch/include/oem/common/inc/oemmd5types.h b/prebuilt-v4.4/noarch/include/oem/common/inc/oemmd5types.h
new file mode 100644
index 0000000..8693550
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/oem/common/inc/oemmd5types.h
@@ -0,0 +1,35 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __OEMMD5TYPES_H__
+#define __OEMMD5TYPES_H__ 1
+
+#include <drmtypes.h>
+
+ENTER_PK_NAMESPACE;
+
+#define MD5DIGESTLEN 16
+
+typedef struct __tagDRM_MD5_CTX {
+    DRM_DWORD awaiting_data[16];
+                             /* Data awaiting full 512-bit block.       */
+                             /* Length (nbit_total[0] % 512) bits.      */
+                             /* Unused part of buffer (at end) is zero. */
+    DRM_DWORD partial_hash[4];
+                             /* Hash through last full block            */
+    DRM_DWORD nbit_total[2];
+                             /* Total length of message so far          */
+                             /* (bits, mod 2^64)                        */
+    DRM_BYTE digest[ MD5DIGESTLEN ];
+                             /* Actual digest after MD5Final completes  */
+} DRM_MD5_CTX;
+
+EXIT_PK_NAMESPACE;
+
+#endif /* __OEMMD5TYPES_H__ */
+
diff --git a/prebuilt-v4.4/noarch/include/oem/common/inc/oemprofile.h b/prebuilt-v4.4/noarch/include/oem/common/inc/oemprofile.h
new file mode 100644
index 0000000..ff79f75
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/oem/common/inc/oemprofile.h
@@ -0,0 +1,24 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+#ifndef __OEMPROFILE_H__
+#define __OEMPROFILE_H__
+
+#include <drmprofiletypes.h>
+
+ENTER_PK_NAMESPACE;
+
+#if DRM_SUPPORT_PROFILING
+
+DRM_API PERF_GLOBAL_CONTEXT * DRM_CALL Oem_Profiling_GetProfileContext( DRM_VOID );
+
+#endif /* DRM_SUPPORT_PROFILING */
+
+EXIT_PK_NAMESPACE;
+
+#endif /* __OEMPROFILE_H__ */
+
diff --git a/prebuilt-v4.4/noarch/include/oem/common/inc/oemrc4.h b/prebuilt-v4.4/noarch/include/oem/common/inc/oemrc4.h
new file mode 100644
index 0000000..bb53f0b
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/oem/common/inc/oemrc4.h
@@ -0,0 +1,98 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __OEMRC4_H__
+#define __OEMRC4_H__
+
+#include <drmerr.h>
+#include <oemrc4types.h>
+
+ENTER_EXTERN_C_NAMESPACE;
+
+DRM_API_VOID DRM_VOID DRM_CALL DRM_RC4_KeySetupImpl(
+    __out                      RC4_KEYSTRUCT  *pKS,
+    __in                       DRM_DWORD       cbKey,
+    __in_bcount( cbKey ) const DRM_BYTE       *pbKey );
+
+DRM_API_VOID DRM_VOID DRM_CALL DRM_RC4_CipherImpl(
+    __inout                  RC4_KEYSTRUCT *pKS,
+    __in                     DRM_DWORD      cbBuffer,
+    __inout_bcount(cbBuffer) DRM_BYTE      *pbBuffer );
+
+EXIT_EXTERN_C_NAMESPACE;
+
+ENTER_PK_NAMESPACE;
+
+DRM_API_VOID DRM_VOID DRM_CALL DRM_RC4_ZeroKey(
+    __inout           RC4_KEYSTRUCT    *pKS );
+
+#if !DRM_INLINING_SUPPORTED
+
+DRM_API_VOID DRM_VOID DRM_CALL DRM_RC4_KeySetup(
+    __out                      RC4_KEYSTRUCT  *pKS,
+    __in                       DRM_DWORD       cbKey,
+    __in_bcount( cbKey ) const DRM_BYTE       *pbKey );
+
+DRM_API_VOID DRM_VOID DRM_CALL DRM_RC4_Cipher(
+    __inout                  RC4_KEYSTRUCT *pKS,
+    __in                     DRM_DWORD      cbBuffer,
+    __inout_bcount(cbBuffer) DRM_BYTE      *pbBuffer );
+
+#else   /* !DRM_INLINING_SUPPORTED */
+
+/*********************************************************************
+**
+**  Function:  DRM_RC4_KeySetup
+**
+**  Synopsis:  Generate the key control structure.  Key can be any size.
+**
+**  Arguments:
+**     [pKS] -- A KEYSTRUCT structure that will be initialized.
+**     [cbKey] -- Size of the key, in bytes.
+**     [pbKey] -- Pointer to the key.
+**
+**  Returns:  None
+**
+*********************************************************************/
+
+DRM_ALWAYS_INLINE DRM_API_VOID DRM_VOID DRM_CALL DRM_RC4_KeySetup(
+    __out                      RC4_KEYSTRUCT  *pKS,
+    __in                       DRM_DWORD       cbKey,
+    __in_bcount( cbKey ) const DRM_BYTE       *pbKey )
+{
+    DRM_RC4_KeySetupImpl( pKS, cbKey, pbKey );
+}
+
+/*********************************************************************
+**
+**  Function:  DRM_RC4_Cipher
+**
+**  Synopsis:
+**
+**  Arguments:
+**     [pKS] -- Pointer to the KEYSTRUCT created using DRM_RC4_KeySetup.
+**     [cbBuffer] -- Size of buffer, in bytes.
+**     [pbBuffer] -- Buffer to be encrypted in place.
+**
+**  Returns:  None
+*********************************************************************/
+
+DRM_ALWAYS_INLINE DRM_API_VOID DRM_VOID DRM_CALL DRM_RC4_Cipher(
+    __inout                  RC4_KEYSTRUCT *pKS,
+    __in                     DRM_DWORD      cbBuffer,
+    __inout_bcount(cbBuffer) DRM_BYTE      *pbBuffer )
+{
+    DRM_RC4_CipherImpl( pKS, cbBuffer, pbBuffer );
+}
+
+#endif   /* !DRM_INLINING_SUPPORTED */
+
+EXIT_PK_NAMESPACE;
+
+#endif /* __OEMRC4_H__ */
+
diff --git a/prebuilt-v4.4/noarch/include/oem/common/inc/oemrc4types.h b/prebuilt-v4.4/noarch/include/oem/common/inc/oemrc4types.h
new file mode 100644
index 0000000..1bdfc26
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/oem/common/inc/oemrc4types.h
@@ -0,0 +1,28 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __OEMRC4TYPES_H__
+#define __OEMRC4TYPES_H__
+
+#include <drmerr.h>
+
+#define RC4_TABLESIZE 256
+
+ENTER_EXTERN_C_NAMESPACE;
+
+/* Key structure */
+typedef struct __tagRC4_KEYSTRUCT
+{
+    DRM_BYTE S[ RC4_TABLESIZE ];     /* State table */
+    DRM_BYTE i, j;        /* Indices */
+} RC4_KEYSTRUCT;
+
+EXIT_EXTERN_C_NAMESPACE;
+
+#endif /* __OEMRC4TYPES_H__ */
+
diff --git a/prebuilt-v4.4/noarch/include/oem/common/inc/oemrsa.h b/prebuilt-v4.4/noarch/include/oem/common/inc/oemrsa.h
new file mode 100644
index 0000000..b0bc7f5
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/oem/common/inc/oemrsa.h
@@ -0,0 +1,247 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __OEMRSA_H__
+#define __OEMRSA_H__
+
+#include <drmtypes.h>
+#include <oemrsaimpl.h>
+#include <oemrsacommon.h>
+#include <oemeccp256.h>
+
+ENTER_PK_NAMESPACE;
+
+#define BITS_TO_BYTES( nb ) ( ( ( nb ) + BITS_PER_STANDARD_BYTE - 1 ) / BITS_PER_STANDARD_BYTE )
+#define BYTES_TO_BITS( nb ) ( ( nb ) * BITS_PER_STANDARD_BYTE )
+
+extern DRM_EXPORT_VAR const DRM_BYTE rgbDRM_RSA_DEFAULT_PUBEXP[ DRM_RSA_CB_PUBEXP ];
+
+#define DRM_RSA_DEFAULT_PUBEXP_DWORD 65537
+
+/*
+** Sizes of internal RSA key structures:
+*/
+#define DRM_RSA_CB_PUBKEY_2048BIT   sizeof( INTERNAL_DRM_RSA_PUBLIC_KEY_2048BIT )
+#define DRM_RSA_CB_PRIVKEY_2048BIT  sizeof( INTERNAL_DRM_RSA_PRIVATE_KEY_2048BIT )
+
+/*
+** RSA public key
+**
+** The actual contents of the structure are opaque.
+** The opaque data is represented as a byte array below.
+** Do not access the array or assume the size of this structure.
+*/
+typedef struct __tagDRM_RSA_PUBLIC_KEY_2048BIT
+{
+    DRM_BYTE rgbOpaque[ DRM_RSA_CB_PUBKEY_2048BIT ];
+} DRM_RSA_PUBLIC_KEY_2048BIT;
+
+/*
+** RSA private key
+**
+** The actual contents of the structure are opaque.
+** The opaque data is represented as a byte array below.
+** Do not access the array or assume the size of this structure.
+*/
+typedef struct __tagDRM_RSA_PRIVATE_KEY_2048BIT
+{
+    DRM_BYTE rgbOpaque[ DRM_RSA_CB_PRIVKEY_2048BIT ];
+} DRM_RSA_PRIVATE_KEY_2048BIT;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_RSA_BigEndianBytesToDigits(
+    __in_ecount( BITS_TO_BYTES( f_cBitsData ) )       const DRM_BYTE  *f_pbData,
+    __in                                              const DRM_DWORD  f_cBitsData,
+    __out_ecount( DRM_BITS_TO_DIGITS( f_cBitsData ) )       digit_t   *f_pDigits ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_RSA_DigitsToBigEndianBytes(
+    __in_ecount( DRM_BITS_TO_DIGITS( f_cBitsData ) ) const digit_t   *f_pDigits,
+    __in                                             const DRM_DWORD  f_cBitsData,
+    __out_ecount( BITS_TO_BYTES( f_cBitsData ) )           DRM_BYTE  *f_pbData ) DRM_NO_INLINE_ATTRIBUTE;
+
+/*
+** Key management functions:
+*/
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_RSA_GetPublicKeyLength_2048BIT(
+    __in const DRM_RSA_PUBLIC_KEY_2048BIT            *f_pPublicKey,
+    __out      DRM_RSA_SUPPORTED_KEY_LENGTHS_2048BIT *f_peKeyLength ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_RSA_GetPrivateKeyLength_2048BIT(
+    __in const DRM_RSA_PRIVATE_KEY_2048BIT           *f_pPrivateKey,
+    __out      DRM_RSA_SUPPORTED_KEY_LENGTHS_2048BIT *f_peKeyLength ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_RSA_GetKeyLengthFromModulusLength_2048BIT(
+    __in const DRM_DWORD                              f_cbModulus,
+    __out      DRM_RSA_SUPPORTED_KEY_LENGTHS_2048BIT *f_peKeyLength ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_RSA_ParsePublicKey_2048BIT(
+    __in const                        DRM_RSA_PUBLIC_KEY_2048BIT            *f_pPublicKey,
+    __out_opt                         DRM_RSA_SUPPORTED_KEY_LENGTHS_2048BIT *f_peKeyLength,
+    __inout_opt                       DRM_DWORD                             *f_pcbPubExp,
+    __out_ecount_opt( *f_pcbPubExp )  DRM_BYTE                              *f_pbPubExp,
+    __inout_opt                       DRM_DWORD                             *f_pcbModulus,
+    __out_ecount_opt( *f_pcbModulus ) DRM_BYTE                              *f_pbModulus ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_RSA_ParsePrivateKey_2048BIT(
+    __in                              const DRM_RSA_PRIVATE_KEY_2048BIT           *f_pPrivateKey,
+    __out_opt                               DRM_RSA_SUPPORTED_KEY_LENGTHS_2048BIT *f_peKeyLength,
+    __inout_opt                             DRM_DWORD                             *f_pcbPrivExp,
+    __in_ecount_opt( *f_pcbPrivExp )  const DRM_BYTE                              *f_pbPrivExp,
+    __inout_opt                             DRM_DWORD                             *f_pcbPrimes,
+    __out_ecount_opt( *f_pcbPrimes )        DRM_BYTE                              *f_pbPrime0,
+    __out_ecount_opt( *f_pcbPrimes )        DRM_BYTE                              *f_pbPrime1 ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_RSA_SetPublicKey_2048BIT(
+    __in const                       DRM_RSA_SUPPORTED_KEY_LENGTHS_2048BIT  f_eKeyLength,
+    __in const                       DRM_DWORD                              f_cbPubExp,
+    __in_ecount( f_cbPubExp ) const  DRM_BYTE                              *f_pbPubExp,
+    __in const                       DRM_DWORD                              f_cbModulus,
+    __in_ecount( f_cbModulus ) const DRM_BYTE                              *f_pbModulus,
+    __out                            DRM_RSA_PUBLIC_KEY_2048BIT            *f_pPublicKey ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_RSA_SetPrivateKey_2048BIT(
+    __in const                       DRM_RSA_SUPPORTED_KEY_LENGTHS_2048BIT  f_eKeyLength,
+    __in const                       DRM_DWORD                              f_cbPrivExp,
+    __in_ecount( f_cbPrivExp ) const DRM_BYTE                              *f_pbPrivExp,
+    __in const                       DRM_DWORD                              f_cbPrimes,
+    __in_ecount( f_cbPrimes ) const  DRM_BYTE                              *f_pbPrime0,
+    __in_ecount( f_cbPrimes ) const  DRM_BYTE                              *f_pbPrime1,
+    __out                            DRM_RSA_PRIVATE_KEY_2048BIT           *f_pPrivateKey,
+    __inout                          DRM_CRYPTO_CONTEXT                    *f_pCryptoCtx ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_RSA_ZeroPublicKey_2048BIT(
+    __in       DRM_RSA_PUBLIC_KEY_2048BIT            *f_pPublicKey ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_API DRM_RESULT DRM_CALL OEM_RSA_ZeroPrivateKey_2048BIT(
+    __in       DRM_RSA_PRIVATE_KEY_2048BIT           *f_pPrivateKey ) DRM_NO_INLINE_ATTRIBUTE;
+
+/*
+** Encryption and decryption functions
+*/
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_RSA_Encrypt_2048BIT(
+    __in const                      DRM_RSA_PUBLIC_KEY_2048BIT *f_pPublicKey,
+    __in const                      DRM_DWORD                   f_cbDataIn,
+    __in_ecount( f_cbDataIn ) const DRM_BYTE                   *f_pbDataIn,
+    __out_ecount( f_cbDataIn )      DRM_BYTE                   *f_pbDataOut,
+    __in                            DRM_CRYPTO_CONTEXT         *f_pCryptoCtx ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_RSA_Decrypt_2048BIT(
+    __in const                      DRM_RSA_PRIVATE_KEY_2048BIT *f_pPrivateKey,
+    __in const                      DRM_DWORD                    f_cbDataIn,
+    __in_ecount( f_cbDataIn ) const DRM_BYTE                    *f_pbDataIn,
+    __out_ecount( f_cbDataIn )      DRM_BYTE                    *f_pbDataOut,
+    __in                            DRM_CRYPTO_CONTEXT          *f_pCryptoCtx ) DRM_NO_INLINE_ATTRIBUTE;
+
+/*
+** Key generation
+*/
+DRM_API DRM_RESULT DRM_CALL OEM_RSA_GenerateKeyPair_2048BIT(
+    __in const      DRM_RSA_SUPPORTED_KEY_LENGTHS_2048BIT  f_eKeyLength,
+    __out_ecount(1) DRM_RSA_PRIVATE_KEY_2048BIT           *f_pPrivateKey,
+    __out_ecount(1) DRM_RSA_PUBLIC_KEY_2048BIT            *f_pPublicKey,
+    __inout         DRM_CRYPTO_CONTEXT                    *f_pCryptoCtx ) DRM_NO_INLINE_ATTRIBUTE;
+
+/******************************************************************************
+**
+** RSA 4096BIT (512BYTE) support
+**
+******************************************************************************/
+
+#define DRM_RSA_CB_PUBKEY_4096BIT   sizeof( INTERNAL_DRM_RSA_PUBLIC_KEY_4096BIT )
+#define DRM_RSA_CB_PRIVKEY_4096BIT  sizeof( INTERNAL_DRM_RSA_PRIVATE_KEY_4096BIT )
+
+typedef struct __tagDRM_RSA_PUBLIC_KEY_4096BIT
+{
+    DRM_BYTE rgbOpaque[ DRM_RSA_CB_PUBKEY_4096BIT ];
+} DRM_RSA_PUBLIC_KEY_4096BIT;
+
+typedef struct __tagDRM_RSA_PRIVATE_KEY_4096BIT
+{
+    DRM_BYTE rgbOpaque[ DRM_RSA_CB_PRIVKEY_4096BIT ];
+} DRM_RSA_PRIVATE_KEY_4096BIT;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_RSA_GetPublicKeyLength_4096BIT(
+    __in const DRM_RSA_PUBLIC_KEY_4096BIT            *f_pPublicKey,
+    __out      DRM_RSA_SUPPORTED_KEY_LENGTHS_4096BIT *f_peKeyLength ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_RSA_GetPrivateKeyLength_4096BIT(
+    __in const DRM_RSA_PRIVATE_KEY_4096BIT           *f_pPrivateKey,
+    __out      DRM_RSA_SUPPORTED_KEY_LENGTHS_4096BIT *f_peKeyLength ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_RSA_GetKeyLengthFromModulusLength_4096BIT(
+    __in const DRM_DWORD                              f_cbModulus,
+    __out      DRM_RSA_SUPPORTED_KEY_LENGTHS_4096BIT *f_peKeyLength ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_RSA_ParsePublicKey_4096BIT(
+    __in const                        DRM_RSA_PUBLIC_KEY_4096BIT            *f_pPublicKey,
+    __out_opt                         DRM_RSA_SUPPORTED_KEY_LENGTHS_4096BIT *f_peKeyLength,
+    __inout_opt                       DRM_DWORD                             *f_pcbPubExp,
+    __out_ecount_opt( *f_pcbPubExp )  DRM_BYTE                              *f_pbPubExp,
+    __inout_opt                       DRM_DWORD                             *f_pcbModulus,
+    __out_ecount_opt( *f_pcbModulus ) DRM_BYTE                              *f_pbModulus ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_API DRM_RESULT DRM_CALL OEM_RSA_ParsePrivateKey_4096BIT(
+    __in const                              DRM_RSA_PRIVATE_KEY_4096BIT           *f_pPrivateKey,
+    __out_opt                               DRM_RSA_SUPPORTED_KEY_LENGTHS_4096BIT *f_peKeyLength,
+    __inout_opt                             DRM_DWORD                             *f_pcbPrivExp,
+    __in_ecount_opt( *f_pcbPrivExp )  const DRM_BYTE                              *f_pbPrivExp,
+    __inout_opt                             DRM_DWORD                             *f_pcbPrimes,
+    __out_ecount_opt( *f_pcbPrimes )        DRM_BYTE                              *f_pbPrime0,
+    __out_ecount_opt( *f_pcbPrimes )        DRM_BYTE                              *f_pbPrime1 ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_RSA_SetPublicKey_4096BIT(
+    __in const                       DRM_RSA_SUPPORTED_KEY_LENGTHS_4096BIT  f_eKeyLength,
+    __in const                       DRM_DWORD                              f_cbPubExp,
+    __in_ecount( f_cbPubExp ) const  DRM_BYTE                              *f_pbPubExp,
+    __in const                       DRM_DWORD                              f_cbModulus,
+    __in_ecount( f_cbModulus ) const DRM_BYTE                              *f_pbModulus,
+    __out                            DRM_RSA_PUBLIC_KEY_4096BIT            *f_pPublicKey ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_RSA_SetPrivateKey_4096BIT(
+    __in const                       DRM_RSA_SUPPORTED_KEY_LENGTHS_4096BIT  f_eKeyLength,
+    __in const                       DRM_DWORD                              f_cbPrivExp,
+    __in_ecount( f_cbPrivExp ) const DRM_BYTE                              *f_pbPrivExp,
+    __in const                       DRM_DWORD                              f_cbPrimes,
+    __in_ecount( f_cbPrimes ) const  DRM_BYTE                              *f_pbPrime0,
+    __in_ecount( f_cbPrimes ) const  DRM_BYTE                              *f_pbPrime1,
+    __out                            DRM_RSA_PRIVATE_KEY_4096BIT           *f_pPrivateKey,
+    __inout                          DRM_CRYPTO_CONTEXT                    *f_pCryptoCtx ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_RSA_ZeroPublicKey_4096BIT(
+    __in       DRM_RSA_PUBLIC_KEY_4096BIT            *f_pPublicKey ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_API DRM_RESULT DRM_CALL OEM_RSA_ZeroPrivateKey_4096BIT(
+    __in       DRM_RSA_PRIVATE_KEY_4096BIT           *f_pPrivateKey ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_RSA_Encrypt_4096BIT(
+    __in const                      DRM_RSA_PUBLIC_KEY_4096BIT *f_pPublicKey,
+    __in const                      DRM_DWORD                   f_cbDataIn,
+    __in_ecount( f_cbDataIn ) const DRM_BYTE                   *f_pbDataIn,
+    __out_ecount( f_cbDataIn )      DRM_BYTE                   *f_pbDataOut,
+    __in                            DRM_CRYPTO_CONTEXT         *f_pCryptoCtx ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_RSA_Decrypt_4096BIT(
+    __in const                      DRM_RSA_PRIVATE_KEY_4096BIT *f_pPrivateKey,
+    __in const                      DRM_DWORD                    f_cbDataIn,
+    __in_ecount( f_cbDataIn ) const DRM_BYTE                    *f_pbDataIn,
+    __out_ecount( f_cbDataIn )      DRM_BYTE                    *f_pbDataOut,
+    __in                            DRM_CRYPTO_CONTEXT          *f_pCryptoCtx ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_API DRM_RESULT DRM_CALL OEM_RSA_GenerateKeyPair_4096BIT(
+    __in const      DRM_RSA_SUPPORTED_KEY_LENGTHS_4096BIT  f_eKeyLength,
+    __out_ecount(1) DRM_RSA_PRIVATE_KEY_4096BIT           *f_pPrivateKey,
+    __out_ecount(1) DRM_RSA_PUBLIC_KEY_4096BIT            *f_pPublicKey,
+    __inout         DRM_CRYPTO_CONTEXT                    *f_pCryptoCtx ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API_VOID DRM_VOID DRM_CALL DRM_RSA_PKInitSize(
+    __inout DRM_VOID *f_pContext,
+    __in    DRM_DWORD f_dwSize ) DRM_NO_INLINE_ATTRIBUTE;
+
+EXIT_PK_NAMESPACE;
+
+#endif /* __OEMRSA_H__ */
+
diff --git a/prebuilt-v4.4/noarch/include/oem/common/inc/oemrsacommon.h b/prebuilt-v4.4/noarch/include/oem/common/inc/oemrsacommon.h
new file mode 100644
index 0000000..9ae6f15
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/oem/common/inc/oemrsacommon.h
@@ -0,0 +1,95 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __OEMRSACOMMON_H__
+#define __OEMRSACOMMON_H__
+
+ENTER_PK_NAMESPACE;
+
+/*
+** Supported key lengths
+*/
+typedef enum __tagDRM_RSA_SUPPORTED_KEY_LENGTHS_2048BIT
+{
+    eDRM_RSA_KEY_LENGTH_UNKNOWN_2048BIT  = 0,
+    eDRM_RSA_KEY_LENGTH_1024_2048BIT     = 1024,
+    eDRM_RSA_KEY_LENGTH_2048_2048BIT     = 2048,
+} DRM_RSA_SUPPORTED_KEY_LENGTHS_2048BIT;
+
+/* Value cannot from enum because it used to define DRM_RSA_CB_PRIME_MAX_2048BIT that used for SAL annotations */
+#define eDRM_RSA_MAXIMUM_KEY_LENGTH_2048BIT               2048
+
+#define IS_VALID_DRM_RSA_KEY_LENGTH_2048BIT( keyLength )  ( ( eDRM_RSA_KEY_LENGTH_1024_2048BIT == ( keyLength ) )   \
+                                                         || ( eDRM_RSA_KEY_LENGTH_2048_2048BIT == ( keyLength ) ) )
+
+/*
+** Primes are either 1024 or 2048 bits (128 or 256 bytes) each
+*/
+#define DRM_RSA_CB_PRIME( keyLength )           ( (DRM_WORD)( ( keyLength ) / BITS_PER_STANDARD_BYTE ) )
+#define DRM_RSA_CB_PRIME_MAX_2048BIT            DRM_RSA_CB_PRIME( eDRM_RSA_MAXIMUM_KEY_LENGTH_2048BIT )
+#define DRM_RSA_B64ENC_PRIME_MAX                344 /* CCH_BASE64_EQUIV(DRM_RSA_CB_PRIME_MAX_2048BIT) */
+
+/*
+** Modulus is 128/256 bytes or 1024/2048 bits
+*/
+#define DRM_RSA_CB_MODULUS( keyLength )         DRM_RSA_CB_PRIME( keyLength )
+#define DRM_RSA_CB_MODULUS_MAX_2048BIT          DRM_RSA_CB_MODULUS( eDRM_RSA_MAXIMUM_KEY_LENGTH_2048BIT )
+
+#define DRM_RSA_CBITS_MODULUS( keyLength )      ( (DRM_WORD)( DRM_RSA_CB_MODULUS( keyLength ) * BITS_PER_STANDARD_BYTE ) )
+#define DRM_RSA_CBITS_MODULUS_MAX_2048BIT       DRM_RSA_CBITS_MODULUS( eDRM_RSA_MAXIMUM_KEY_LENGTH_2048BIT )
+
+/*
+** RSA ciphertext length is the same as the prime length
+*/
+#define DRM_RSA_CB_CIPHERTEXT( keyLength )      DRM_RSA_CB_MODULUS( keyLength )
+#define DRM_RSA_CB_CIPHERTEXT_MAX_2048BIT       DRM_RSA_CB_CIPHERTEXT( eDRM_RSA_MAXIMUM_KEY_LENGTH_2048BIT )
+
+/*
+** Public and private exponent sizes
+*/
+#define DRM_RSA_CB_PUBEXP                       4
+#define DRM_RSA_CB_PRIVEXP( keyLength )         DRM_RSA_CB_MODULUS( keyLength )
+#define DRM_RSA_CB_PRIVEXP_MAX_2048BIT          DRM_RSA_CB_PRIVEXP( eDRM_RSA_MAXIMUM_KEY_LENGTH_2048BIT )
+
+/*
+** For regular encryption (not large encryption) the plaintext must be smaller than the modulus
+*/
+#define DRM_RSA_CB_MAX_PLAINTEXT( keyLength )   ( (DRM_WORD)( ( DRM_RSA_CB_MODULUS( keyLength ) - ( 2 * OEM_SHA1_DIGEST_LEN + 2 ) ) ) )
+#define DRM_RSA_CB_MAX_PLAINTEXT_MAX_2048BIT    DRM_RSA_CB_MAX_PLAINTEXT( eDRM_RSA_MAXIMUM_KEY_LENGTH_2048BIT )
+
+/******************************************************************************
+**
+** RSA 4096BIT (512BYTE) support
+**
+******************************************************************************/
+
+typedef enum __tagDRM_RSA_SUPPORTED_KEY_LENGTHS_4096BIT
+{
+    eDRM_RSA_KEY_LENGTH_UNKNOWN_4096BIT = 0,
+    eDRM_RSA_KEY_LENGTH_1024_4096BIT = 1024,
+    eDRM_RSA_KEY_LENGTH_2048_4096BIT = 2048,
+    eDRM_RSA_KEY_LENGTH_4096_4096BIT = 4096,
+} DRM_RSA_SUPPORTED_KEY_LENGTHS_4096BIT;
+
+#define eDRM_RSA_MAXIMUM_KEY_LENGTH_4096BIT               4096
+
+#define IS_VALID_DRM_RSA_KEY_LENGTH_4096BIT( keyLength )  ( ( eDRM_RSA_KEY_LENGTH_1024_4096BIT == ( keyLength ) )   \
+                                                         || ( eDRM_RSA_KEY_LENGTH_2048_4096BIT == ( keyLength ) )   \
+                                                         || ( eDRM_RSA_KEY_LENGTH_4096_4096BIT == ( keyLength ) ) )
+
+#define DRM_RSA_CB_PRIME_MAX_4096BIT            DRM_RSA_CB_PRIME( eDRM_RSA_MAXIMUM_KEY_LENGTH_4096BIT )
+#define DRM_RSA_CB_MODULUS_MAX_4096BIT          DRM_RSA_CB_MODULUS( eDRM_RSA_MAXIMUM_KEY_LENGTH_4096BIT )
+#define DRM_RSA_CBITS_MODULUS_MAX_4096BIT       DRM_RSA_CBITS_MODULUS( eDRM_RSA_MAXIMUM_KEY_LENGTH_4096BIT )
+#define DRM_RSA_CB_CIPHERTEXT_MAX_4096BIT       DRM_RSA_CB_CIPHERTEXT( eDRM_RSA_MAXIMUM_KEY_LENGTH_4096BIT )
+#define DRM_RSA_CB_PRIVEXP_MAX_4096BIT          DRM_RSA_CB_PRIVEXP( eDRM_RSA_MAXIMUM_KEY_LENGTH_4096BIT )
+#define DRM_RSA_CB_MAX_PLAINTEXT_MAX_4096BIT    DRM_RSA_CB_MAX_PLAINTEXT( eDRM_RSA_MAXIMUM_KEY_LENGTH_4096BIT )
+
+EXIT_PK_NAMESPACE;
+
+#endif /* __OEMRSACOMMON_H__ */
+
diff --git a/prebuilt-v4.4/noarch/include/oem/common/inc/oemrsaimpl.h b/prebuilt-v4.4/noarch/include/oem/common/inc/oemrsaimpl.h
new file mode 100644
index 0000000..bc2a9c4
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/oem/common/inc/oemrsaimpl.h
@@ -0,0 +1,101 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __OEMRSAIMPL_H__
+#define __OEMRSAIMPL_H__
+
+#include <drmtypes.h>
+#include <oemrsacommon.h>
+#include <bigdefs.h>
+#include <oembyteorder.h>
+
+ENTER_PK_NAMESPACE;
+
+#define CBITS_PUBEXP                    ( (DRM_WORD)( ( DRM_RSA_CB_PUBEXP * BITS_PER_STANDARD_BYTE ) ) )
+
+#define CBITS_PRIVEXP( keyLength )      ( (DRM_WORD)( ( DRM_RSA_CB_PRIVEXP( keyLength ) * BITS_PER_STANDARD_BYTE ) ) )
+#define CBITS_PRIVEXP_MAX_2048BIT       CBITS_PRIVEXP( eDRM_RSA_MAXIMUM_KEY_LENGTH_2048BIT )
+
+#define CDIGITS_MODULUS( keyLength )    ( (DRM_WORD)( DRM_BITS_TO_DIGITS( DRM_RSA_CBITS_MODULUS( keyLength ) ) ) )
+#define CDIGITS_MODULUS_MAX_2048BIT     CDIGITS_MODULUS( eDRM_RSA_MAXIMUM_KEY_LENGTH_2048BIT )
+
+#define CDIGITS_PUBEXP                  ( (DRM_WORD)( DRM_BITS_TO_DIGITS( CBITS_PUBEXP ) ) )
+
+#define CDIGITS_PRIVEXP( keyLength )    ( (DRM_WORD)( DRM_BITS_TO_DIGITS( CBITS_PRIVEXP( keyLength ) ) ) )
+#define CDIGITS_PRIVEXP_MAX_2048BIT     CDIGITS_PRIVEXP( eDRM_RSA_MAXIMUM_KEY_LENGTH_2048BIT )
+
+/*
+** Internal representation of public and private key structures
+*/
+
+/*
+** In the following structures, a digit_t array represents a single big number,
+** stored in big-endian format.  In other words, the most significant digit is
+** lowest in contiguous memory.  Since the digit_t itself is a multi-octet value,
+** please note that it is also stored in big-endian form; the most significant
+** octet of a given digit_t instance is lowest in contiguous memory.
+**
+** Thus, a "big-endian" digit array is a sequence of digit_t's stored in
+** big-endian order, with the individual octets of each digit_t also stored
+** in big-endian order.
+*/
+
+/*
+** Public key: Contains only the modulus and exponent
+*/
+typedef struct __tagINTERNAL_DRM_RSA_PUBLIC_KEY_2048BIT
+{
+    DRM_RSA_SUPPORTED_KEY_LENGTHS_2048BIT eKeyLength;                               /* key length in bits. */
+    DRM_DWORD                             cdModulus;                                /* count of digits in the public modulus. */
+    digit_t                               rgdPubExp[CDIGITS_PUBEXP];                /* public exponent; stored as big-endian digits. */
+    digit_t                               rgdModulus[CDIGITS_MODULUS_MAX_2048BIT];  /* public modulus; stored as big-endian digits. */
+} INTERNAL_DRM_RSA_PUBLIC_KEY_2048BIT;
+
+/*
+** Private key: Contains the primes, exponent, and chinese remainder theorem residuals
+*/
+typedef struct __tagINTERNAL_DRM_RSA_PRIVATE_KEY_2048BIT
+{
+    DRM_RSA_SUPPORTED_KEY_LENGTHS_2048BIT eKeyLength;                                       /* key length in bits. */
+    DRM_DWORD                             cdPrimes[2];                                      /* count of digits in each prime. */
+    digit_t                               rgdPrimes[2][CDIGITS_MODULUS_MAX_2048BIT];        /* larger prime (p) stored first; stored as big-endian digits. */
+    digit_t                               rgdCRTExponents[2][CDIGITS_MODULUS_MAX_2048BIT];  /* chinese remainder theorem exponents; stored as big-endian digits. */
+    digit_t                               rgdIQMP[CDIGITS_MODULUS_MAX_2048BIT];             /* stored as big-endian digits. */
+} INTERNAL_DRM_RSA_PRIVATE_KEY_2048BIT;
+
+/******************************************************************************
+**
+** RSA 4096BIT (512BYTE) support
+**
+******************************************************************************/
+
+#define CBITS_PRIVEXP_MAX_4096BIT       CBITS_PRIVEXP( eDRM_RSA_MAXIMUM_KEY_LENGTH_4096BIT )
+#define CDIGITS_MODULUS_MAX_4096BIT     CDIGITS_MODULUS( eDRM_RSA_MAXIMUM_KEY_LENGTH_4096BIT )
+#define CDIGITS_PRIVEXP_MAX_4096BIT     CDIGITS_PRIVEXP( eDRM_RSA_MAXIMUM_KEY_LENGTH_4096BIT )
+
+typedef struct __tagINTERNAL_DRM_RSA_PUBLIC_KEY_4096BIT
+{
+    DRM_RSA_SUPPORTED_KEY_LENGTHS_4096BIT eKeyLength;                               /* key length in bits. */
+    DRM_DWORD                             cdModulus;                                /* count of digits in the public modulus. */
+    digit_t                               rgdPubExp[CDIGITS_PUBEXP];                /* public exponent; stored as big-endian digits. */
+    digit_t                               rgdModulus[CDIGITS_MODULUS_MAX_4096BIT];  /* public modulus; stored as big-endian digits. */
+} INTERNAL_DRM_RSA_PUBLIC_KEY_4096BIT;
+
+typedef struct __tagINTERNAL_DRM_RSA_PRIVATE_KEY_4096BIT
+{
+    DRM_RSA_SUPPORTED_KEY_LENGTHS_4096BIT eKeyLength;                                       /* key length in bits. */
+    DRM_DWORD                             cdPrimes[2];                                      /* count of digits in each prime. */
+    digit_t                               rgdPrimes[2][CDIGITS_MODULUS_MAX_4096BIT];        /* larger prime (p) stored first; stored as big-endian digits. */
+    digit_t                               rgdCRTExponents[2][CDIGITS_MODULUS_MAX_4096BIT];  /* chinese remainder theorem exponents; stored as big-endian digits. */
+    digit_t                               rgdIQMP[CDIGITS_MODULUS_MAX_4096BIT];             /* stored as big-endian digits. */
+} INTERNAL_DRM_RSA_PRIVATE_KEY_4096BIT;
+
+EXIT_PK_NAMESPACE;
+
+#endif /* __OEMRSAIMPL_H__ */
+
diff --git a/prebuilt-v4.4/noarch/include/oem/common/inc/oemrsaoaeppss.h b/prebuilt-v4.4/noarch/include/oem/common/inc/oemrsaoaeppss.h
new file mode 100644
index 0000000..262c6b2
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/oem/common/inc/oemrsaoaeppss.h
@@ -0,0 +1,147 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef _OEMRSAOAEPPSS_H_
+#define _OEMRSAOAEPPSS_H_
+
+#include <oemrsa.h>
+#include <oemrsacommon.h>
+#include <drmtypes.h>
+
+ENTER_PK_NAMESPACE;
+
+/*
+** Definitions for OAEP padding scheme (see PKCS #1 v2.1)
+*/
+#define OAEP_IB_EM_START                    0
+#define OAEP_CB_EM_START                    1
+
+#define OAEP_IB_SEED                        ( OAEP_IB_EM_START + OAEP_CB_EM_START )
+#define OAEP_CB_SEED                        OEM_SHA1_DIGEST_LEN
+
+#define OAEP_IB_DATABLOCK                   ( OAEP_IB_SEED + OAEP_CB_SEED )
+#define OAEP_CB_DATABLOCK( keyLength )      ( (DRM_WORD)( OAEP_CB_ENCRYPTED_MSG( keyLength ) - OAEP_CB_EM_START - OAEP_CB_SEED ) )
+#define OAEP_CB_DATABLOCK_MAX               OAEP_CB_DATABLOCK( eDRM_RSA_MAXIMUM_KEY_LENGTH )
+
+#define OAEP_IB_DATABLOCK_HASH              OAEP_IB_DATABLOCK
+#define OAEP_CB_DATABLOCK_HASH              OEM_SHA1_DIGEST_LEN
+
+#define OAEP_IB_DATABLOCK_PS                ( OAEP_IB_DATABLOCK_HASH + OAEP_CB_DATABLOCK_HASH )
+#define OAEP_CB_DATABLOCK_PS( keyLength, msgLength ) \
+    ( OAEP_CB_DATABLOCK_MSG_MAX( keyLength ) - msgLength )
+
+#define OAEP_IB_DATABLOCK_MSG_START( keyLength, msgLength ) \
+    ( OAEP_IB_DATABLOCK_PS + OAEP_CB_DATABLOCK_PS( keyLength, msgLength ) )
+#define OAEP_CB_DATABLOCK_MSG_START         1
+
+#define OAEP_IB_DATABLOCK_MSG( keyLength, msgLength ) \
+    ( OAEP_IB_DATABLOCK_MSG_START( keyLength, msgLength ) + OAEP_CB_DATABLOCK_MSG_START )
+#define OAEP_CB_DATABLOCK_MSG( msgLength )  ( msgLength )
+#define OAEP_CB_DATABLOCK_MSG_MAX( keyLength ) \
+    ( (DRM_WORD)( OAEP_CB_ENCRYPTED_MSG( keyLength ) - OAEP_CB_EM_START - OAEP_CB_SEED - OAEP_CB_DATABLOCK_HASH - OAEP_CB_DATABLOCK_MSG_START ) )
+
+#define OAEP_B_EM_START                     0x00
+#define OAEP_B_MSG_START                    0x01
+
+/*
+** Definitions for PSS signature scheme (see PKCS #1 v2.1)
+*/
+#define PSS_B_END_MSG      0xBC
+#define PSS_CB_ZERO_PAD    8
+#define PSS_CB_SALT        0
+#define PSS_CB_MPRIME      ( BITS_PER_STANDARD_BYTE + OEM_SHA1_DIGEST_LEN + PSS_CB_SALT )
+#define PSS_IB_SALT        ( PSS_CB_ZERO_PAD + OEM_SHA1_DIGEST_LEN )
+
+/*
+** Definitions for mask generation (MGF1)
+*/
+#define MGF1_CB_MAX_SEED( keyLength )       OAEP_CB_DATABLOCK( keyLength )
+#define MGF1_CB_MAX_SEED_MAX_2048BIT        MGF1_CB_MAX_SEED( eDRM_RSA_MAXIMUM_KEY_LENGTH_2048BIT )
+#define MGF1_CB_MAX_MASK( keyLength )       ( (DRM_WORD)( ( ( OAEP_CB_DATABLOCK( keyLength ) / OEM_SHA1_DIGEST_LEN ) + 1 ) * OEM_SHA1_DIGEST_LEN ) )
+#define MGF1_CB_MAX_MASK_MAX_2048BIT        MGF1_CB_MAX_MASK( eDRM_RSA_MAXIMUM_KEY_LENGTH_2048BIT )
+
+#define OAEP_CB_ENCRYPTED_MSG( keyLength )  DRM_RSA_CB_CIPHERTEXT( keyLength )
+#define OAEP_CB_ENCRYPTED_MSG_MAX           DRM_RSA_CB_CIPHERTEXT( eDRM_RSA_MAXIMUM_KEY_LENGTH )
+
+#define OAEP_CB_DATABLOCK_MAX_2048BIT       OAEP_CB_DATABLOCK( eDRM_RSA_MAXIMUM_KEY_LENGTH_2048BIT )
+#define OAEP_CB_ENCRYPTED_MSG_MAX_2048BIT   DRM_RSA_CB_CIPHERTEXT( eDRM_RSA_MAXIMUM_KEY_LENGTH_2048BIT )
+
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_RSA_OaepDecrypt_2048BIT(
+    __in const                          DRM_RSA_PRIVATE_KEY_2048BIT *f_pPrivateKey,
+    __in const                          DRM_DWORD            f_cbCiphertext,
+    __in_ecount( f_cbCiphertext ) const DRM_BYTE            *f_pbCiphertext,
+    __inout                             DRM_DWORD           *f_pcbPlaintext,
+    __out_ecount( *f_pcbPlaintext )     DRM_BYTE            *f_pbPlaintext,
+    __in                                DRM_CRYPTO_CONTEXT  *f_pCryptoCtx
+    ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_API DRM_RESULT DRM_CALL OEM_RSA_OaepEncrypt_2048BIT(
+    __in_opt                               DRM_VOID                   *f_pOEMContext,
+    __in                             const DRM_RSA_PUBLIC_KEY_2048BIT *f_pPublicKey,
+    __in                             const DRM_DWORD                   f_cbPlaintext,
+    __in_ecount( f_cbPlaintext )     const DRM_BYTE                   *f_pbPlaintext,
+    __inout                                DRM_DWORD                  *f_pcbCiphertext,
+    __out_ecount( *f_pcbCiphertext )       DRM_BYTE                   *f_pbCiphertext,
+    __in                                   DRM_CRYPTO_CONTEXT         *f_pCryptoCtx );
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_RSA_PssVerify_2048BIT(
+    __in const                         DRM_RSA_PUBLIC_KEY_2048BIT  *f_pPublicKey,
+    __in                               DRM_DWORD            f_cbMsg,
+    __in_ecount( f_cbMsg ) const       DRM_BYTE            *f_pbMsg,
+    __in const                         DRM_DWORD            f_ibMsg,
+    __in const                         DRM_DWORD            f_cbSignature,
+    __in_ecount( f_cbSignature ) const DRM_BYTE            *f_pbSignature,
+    __in                                DRM_CRYPTO_CONTEXT *f_pCryptoCtx
+    ) DRM_NO_INLINE_ATTRIBUTE;
+
+/******************************************************************************
+**
+** RSA 4096BIT (512BYTE) support
+**
+******************************************************************************/
+
+#define OAEP_CB_DATABLOCK_MAX_4096BIT       OAEP_CB_DATABLOCK( eDRM_RSA_MAXIMUM_KEY_LENGTH_4096BIT )
+#define OAEP_CB_ENCRYPTED_MSG_MAX_4096BIT   DRM_RSA_CB_CIPHERTEXT( eDRM_RSA_MAXIMUM_KEY_LENGTH_4096BIT )
+#define MGF1_CB_MAX_SEED_MAX_4096BIT        MGF1_CB_MAX_SEED( eDRM_RSA_MAXIMUM_KEY_LENGTH_4096BIT )
+#define MGF1_CB_MAX_MASK_MAX_4096BIT        MGF1_CB_MAX_MASK( eDRM_RSA_MAXIMUM_KEY_LENGTH_4096BIT )
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_RSA_OaepDecrypt_4096BIT(
+    __in const                          DRM_RSA_PRIVATE_KEY_4096BIT *f_pPrivateKey,
+    __in const                          DRM_DWORD                    f_cbCiphertext,
+    __in_ecount( f_cbCiphertext ) const DRM_BYTE                    *f_pbCiphertext,
+    __inout                             DRM_DWORD                   *f_pcbPlaintext,
+    __out_ecount( *f_pcbPlaintext )     DRM_BYTE                    *f_pbPlaintext,
+    __in                                DRM_CRYPTO_CONTEXT          *f_pCryptoCtx
+    ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_API DRM_RESULT DRM_CALL OEM_RSA_OaepEncrypt_4096BIT(
+    __in_opt                           DRM_VOID                   *f_pOEMContext,
+    __in const                         DRM_RSA_PUBLIC_KEY_4096BIT *f_pPublicKey,
+    __in const                         DRM_DWORD                   f_cbPlaintext,
+    __in_ecount( f_cbPlaintext ) const DRM_BYTE                   *f_pbPlaintext,
+    __inout                            DRM_DWORD                  *f_pcbCiphertext,
+    __out_ecount( *f_pcbCiphertext )   DRM_BYTE                   *f_pbCiphertext,
+    __in                               DRM_CRYPTO_CONTEXT         *f_pCryptoCtx
+    );
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_RSA_PssVerify_4096BIT(
+    __in const                         DRM_RSA_PUBLIC_KEY_4096BIT  *f_pPublicKey,
+    __in                               DRM_DWORD                    f_cbMsg,
+    __in_ecount( f_cbMsg ) const       DRM_BYTE                    *f_pbMsg,
+    __in const                         DRM_DWORD                    f_ibMsg,
+    __in const                         DRM_DWORD                    f_cbSignature,
+    __in_ecount( f_cbSignature ) const DRM_BYTE                    *f_pbSignature,
+    __in                               DRM_CRYPTO_CONTEXT          *f_pCryptoCtx
+    ) DRM_NO_INLINE_ATTRIBUTE;
+
+
+EXIT_PK_NAMESPACE;
+
+#endif /* _OEMRSAOAEPPSS_H_ */
+
diff --git a/prebuilt-v4.4/noarch/include/oem/common/inc/oemrsaoaeppssimpl.h b/prebuilt-v4.4/noarch/include/oem/common/inc/oemrsaoaeppssimpl.h
new file mode 100644
index 0000000..6bfb91c
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/oem/common/inc/oemrsaoaeppssimpl.h
@@ -0,0 +1,79 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef _OEMRSAOAEPPSSIMPL_H_
+#define _OEMRSAOAEPPSSIMPL_H_
+
+#include <oemrsa.h>
+#include <oemrsacommon.h>
+#include <drmtypes.h>
+#include <oemrsaoaeppss.h>
+
+ENTER_PK_NAMESPACE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_RSA_OaepDecryptImpl_2048BIT(
+    __in const                          DRM_RSA_PRIVATE_KEY_2048BIT *f_pPrivateKey,
+    __in const                          DRM_DWORD            f_cbCiphertext,
+    __in_ecount( f_cbCiphertext ) const DRM_BYTE            *f_pbCiphertext,
+    __inout                             DRM_DWORD           *f_pcbPlaintext,
+    __out_ecount( *f_pcbPlaintext )     DRM_BYTE            *f_pbPlaintext,
+    __in                                DRM_CRYPTO_CONTEXT  *f_pCryptoCtx
+    ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_RSA_OaepEncryptImpl_2048BIT(
+    __in_opt                               DRM_VOID                   *f_pOEMContext,
+    __in const                             DRM_RSA_PUBLIC_KEY_2048BIT *f_pPublicKey,
+    __in const                             DRM_DWORD                   f_cbPlaintext,
+    __in_ecount( f_cbPlaintext )     const DRM_BYTE                   *f_pbPlaintext,
+    __inout                                DRM_DWORD                  *f_pcbCiphertext,
+    __out_ecount( *f_pcbCiphertext )       DRM_BYTE                   *f_pbCiphertext,
+    __in                                   DRM_CRYPTO_CONTEXT         *f_pCryptoCtx ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_RSA_PssVerifyImpl_2048BIT(
+    __in const                         DRM_RSA_PUBLIC_KEY_2048BIT  *f_pPublicKey,
+    __in                               DRM_DWORD            f_cbMsg,
+    __in_ecount( f_cbMsg ) const       DRM_BYTE            *f_pbMsg,
+    __in const                         DRM_DWORD            f_ibMsg,
+    __in const                         DRM_DWORD            f_cbSignature,
+    __in_ecount( f_cbSignature ) const DRM_BYTE            *f_pbSignature,
+    __in                                DRM_CRYPTO_CONTEXT *f_pCryptoCtx
+    ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_RSA_OaepDecryptImpl_4096BIT(
+    __in const                          DRM_RSA_PRIVATE_KEY_4096BIT *f_pPrivateKey,
+    __in const                          DRM_DWORD            f_cbCiphertext,
+    __in_ecount( f_cbCiphertext ) const DRM_BYTE            *f_pbCiphertext,
+    __inout                             DRM_DWORD           *f_pcbPlaintext,
+    __out_ecount( *f_pcbPlaintext )     DRM_BYTE            *f_pbPlaintext,
+    __in                                DRM_CRYPTO_CONTEXT  *f_pCryptoCtx
+    ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_API DRM_RESULT DRM_CALL OEM_RSA_OaepEncryptImpl_4096BIT(
+    __in_opt                           DRM_VOID           *f_pOEMContext,
+    __in const                         DRM_RSA_PUBLIC_KEY_4096BIT *f_pPublicKey,
+    __in const                         DRM_DWORD           f_cbPlaintext,
+    __in_ecount( f_cbPlaintext ) const DRM_BYTE           *f_pbPlaintext,
+    __inout                            DRM_DWORD          *f_pcbCiphertext,
+    __out_ecount( *f_pcbCiphertext )   DRM_BYTE           *f_pbCiphertext,
+    __in                               DRM_CRYPTO_CONTEXT *f_pCryptoCtx
+    );
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_RSA_PssVerifyImpl_4096BIT(
+    __in const                         DRM_RSA_PUBLIC_KEY_4096BIT  *f_pPublicKey,
+    __in                               DRM_DWORD            f_cbMsg,
+    __in_ecount( f_cbMsg ) const       DRM_BYTE            *f_pbMsg,
+    __in const                         DRM_DWORD            f_ibMsg,
+    __in const                         DRM_DWORD            f_cbSignature,
+    __in_ecount( f_cbSignature ) const DRM_BYTE            *f_pbSignature,
+    __in                                DRM_CRYPTO_CONTEXT *f_pCryptoCtx
+    ) DRM_NO_INLINE_ATTRIBUTE;
+
+EXIT_PK_NAMESPACE;
+
+#endif /* _OEMRSAOAEPPSSIMPL_H_ */
+
diff --git a/prebuilt-v4.4/noarch/include/oem/common/inc/oemsha1.h b/prebuilt-v4.4/noarch/include/oem/common/inc/oemsha1.h
new file mode 100644
index 0000000..685013a
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/oem/common/inc/oemsha1.h
@@ -0,0 +1,159 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+
+#ifndef __OEMSHA1_H__
+#define __OEMSHA1_H__
+
+#include <drmtypes.h>
+
+ENTER_PK_NAMESPACE;
+
+#ifndef OEM_SHA1_DIGEST_LEN
+#define OEM_SHA1_DIGEST_LEN 20    /* 5 32-bit numbers which is 20 BYTES */
+#endif  /* OEM_SHA1_DIGEST_LEN */
+
+#define OEM_SHA1_BLOCK_SIZE 64    /* Sha operates on 64 BYTE blocks */
+
+#define OEM_SHA1_B64ENC_DIGEST_LEN 28 /* CCH_BASE64_EQUIV( OEM_SHA1_DIGEST_LEN ) */
+
+
+/**********************************************************************
+** Struct:      OEM_SHA1_CONTEXT
+**
+** Synopsis:    Maintains the running state of a sha operations
+**
+** Members:        [dwHighByteCount] -- High order of the byte count
+**                [dwLowByteCount] -- Low order of the byte count
+**                [bTempBuffer] -- Maximum temp buffer we may need
+**                [ABCDE] -- current SHA state
+**
+***********************************************************************/
+typedef struct __tagOEM_SHA1_CONTEXT
+{
+    DRM_DWORD dwHighByteCount;
+    DRM_DWORD dwLowByteCount;
+    DRM_BYTE  bTempBuffer[ OEM_SHA1_BLOCK_SIZE ];
+    DRM_DWORD ABCDE[5];
+} OEM_SHA1_CONTEXT;
+
+typedef struct __tagOEM_SHA1_HMAC_CONTEXT
+{
+    DRM_BOOL         fInitialized;
+DRM_OBFUS_FILL_BYTES(4)
+    OEM_SHA1_CONTEXT shaContext;
+    DRM_BYTE         shaDigest[OEM_SHA1_DIGEST_LEN];
+    DRM_BYTE         rgbBuffer[OEM_SHA1_BLOCK_SIZE];
+} OEM_SHA1_HMAC_CONTEXT;
+
+/*********************************************************************
+**
+**  Function:  OEM_SHA1_Init
+**
+**  Synopsis:  Start a clean new instance of Sha
+**
+**  Arguments:
+**     [pShaContext] -- Pointer to context to hold current state of sha
+**
+**  Returns:  None
+**
+*********************************************************************/
+
+DRM_API DRM_RESULT DRM_CALL OEM_SHA1_Init(
+    __inout OEM_SHA1_CONTEXT* pShaContext );
+
+/*********************************************************************
+**
+**  Function:  OEM_SHA1_Update
+**
+**  Synopsis:
+**
+**  Arguments:
+**     [pbData] -- array of bytes to add to the sha computation
+**     [cbData] -- length of pbData in bytes
+**     [pShaContext] -- running sha context
+**
+**  Returns:
+**
+*********************************************************************/
+
+DRM_API DRM_RESULT DRM_CALL OEM_SHA1_Update(
+    __in_bcount( cbData ) const DRM_BYTE         *pbData,
+    __in                        DRM_DWORD         cbData,
+    __inout                     OEM_SHA1_CONTEXT *pShaContext );
+
+
+DRM_API DRM_RESULT DRM_CALL OEM_SHA1_UpdateOffset(
+    __in_bcount( ibData + cbDataRemaining ) const DRM_BYTE         *pbData,
+    __in                                          DRM_DWORD         ibData,
+    __in                                          DRM_DWORD         cbDataRemaining,
+    __inout                                       OEM_SHA1_CONTEXT *pShaContext );
+
+/*********************************************************************
+**
+**  Function:  OEM_SHA1_Finalize
+**
+**  Synopsis:
+**
+**  Arguments:
+**     [pShaContext] -- current running sha context
+**     [ShaDigest] -- resultant sha digest from sha operation
+**
+**  Returns:  None
+**
+*********************************************************************/
+
+DRM_API DRM_RESULT DRM_CALL OEM_SHA1_Finalize(
+    __in                                OEM_SHA1_CONTEXT    *pShaContext,
+    __out_bcount( OEM_SHA1_DIGEST_LEN ) DRM_BYTE             rgbDigest[ OEM_SHA1_DIGEST_LEN ] );
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_SHA1_HMAC_Init(
+    __inout_ecount( 1 )          OEM_SHA1_HMAC_CONTEXT         *f_pContextHMAC,
+    __in_bcount( f_cbKey ) const DRM_BYTE                      *f_pbKey,
+    __in                         DRM_DWORD                      f_cbKey ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_SHA1_HMAC_Update(
+    __inout_ecount( 1 )           OEM_SHA1_HMAC_CONTEXT  *f_pContextHMAC,
+    __in_bcount( f_cbData ) const DRM_BYTE               *f_pbData,
+    __in                          DRM_DWORD               f_cbData ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_SHA1_HMAC_Finalize(
+    __inout_ecount( 1 )           OEM_SHA1_HMAC_CONTEXT  *f_pContextHMAC,
+    __out_bcount( f_cbKeyedHash ) DRM_BYTE               *f_pbKeyedHash,
+    __in                          DRM_DWORD               f_cbKeyedHash ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_SHA1_HMAC_FinalizeOffset(
+    __inout_ecount( 1 )                                      OEM_SHA1_HMAC_CONTEXT  *f_pContextHMAC,
+    __out_bcount( f_cbKeyedHashRemaining + f_ibKeyedHash )   DRM_BYTE               *f_pbKeyedHash,
+    __in                                                     DRM_DWORD               f_ibKeyedHash,
+    __in                                                     DRM_DWORD               f_cbKeyedHashRemaining ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_SHA1_HMAC_CreateMAC(
+    __in_bcount( f_cbKey )                       const DRM_BYTE                      *f_pbKey,
+    __in                                               DRM_DWORD                      f_cbKey,
+    __in_bcount( f_cbDataRemaining + f_ibData )  const DRM_BYTE                      *f_pbData,
+    __in                                               DRM_DWORD                      f_ibData,
+    __in                                               DRM_DWORD                      f_cbDataRemaining,
+    __out_bcount( f_cbMACRemaining + f_ibMAC )         DRM_BYTE                      *f_pbMAC,
+    __in                                               DRM_DWORD                      f_ibMAC,
+    __in                                               DRM_DWORD                      f_cbMACRemaining ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_API DRM_RESULT DRM_CALL OEM_SHA1_HMAC_VerifyMAC(
+    __in_bcount( f_cbKey )                       const DRM_BYTE                      *f_pbKey,
+    __in                                               DRM_DWORD                      f_cbKey,
+    __in_bcount( f_cbDataRemaining + f_ibData )  const DRM_BYTE                      *f_pbData,
+    __in                                               DRM_DWORD                      f_ibData,
+    __in                                               DRM_DWORD                      f_cbDataRemaining,
+    __in_bcount( f_cbMACRemaining + f_ibMAC )    const DRM_BYTE                      *f_pbMAC,
+    __in                                               DRM_DWORD                      f_ibMAC,
+    __in                                               DRM_DWORD                      f_cbMACRemaining ) DRM_NO_INLINE_ATTRIBUTE;
+
+EXIT_PK_NAMESPACE;
+
+#endif /* __OEMSHA1_H__ */
+
diff --git a/prebuilt-v4.4/noarch/include/oem/common/inc/oemsha256.h b/prebuilt-v4.4/noarch/include/oem/common/inc/oemsha256.h
new file mode 100644
index 0000000..bf70d09
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/oem/common/inc/oemsha256.h
@@ -0,0 +1,37 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __OEMSHA256_H__
+#define __OEMSHA256_H__ 1
+
+#include <oemsha256types.h>
+
+ENTER_PK_NAMESPACE;
+
+DRM_API DRM_RESULT DRM_CALL OEM_SHA256_Init(
+    __out_ecount( 1 ) OEM_SHA256_CONTEXT *f_pShaContext );
+
+DRM_API DRM_RESULT DRM_CALL OEM_SHA256_Update(
+    __inout_ecount( 1 )             OEM_SHA256_CONTEXT *f_pShaContext,
+    __in_ecount( f_cbBuffer ) const DRM_BYTE            f_rgbBuffer[],
+    __in                            DRM_DWORD           f_cbBuffer );
+
+DRM_API DRM_RESULT DRM_CALL OEM_SHA256_UpdateOffset(
+    __inout_ecount( 1 )                                         OEM_SHA256_CONTEXT *f_pShaContext,
+    __in_ecount( f_cbBufferRemaining + f_ibBufferOffset ) const DRM_BYTE            f_rgbBuffer[],
+    __in                                                        DRM_DWORD           f_cbBufferRemaining,
+    __in                                                        DRM_DWORD           f_ibBufferOffset );
+
+DRM_API DRM_RESULT DRM_CALL OEM_SHA256_Finalize(
+    __inout_ecount( 1 ) OEM_SHA256_CONTEXT *f_pContext,
+    __out_ecount( 1 )   OEM_SHA256_DIGEST  *f_pDigest );
+
+EXIT_PK_NAMESPACE;
+
+#endif /* #ifndef __OEMSHA256_H__ */
+
diff --git a/prebuilt-v4.4/noarch/include/oem/common/inc/oemsha256types.h b/prebuilt-v4.4/noarch/include/oem/common/inc/oemsha256types.h
new file mode 100644
index 0000000..506800e
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/oem/common/inc/oemsha256types.h
@@ -0,0 +1,58 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __OEMSHA256TYPES_H__
+#define __OEMSHA256TYPES_H__ 1
+
+#include <drmtypes.h>
+
+ENTER_PK_NAMESPACE;
+
+/*
+** Sha-256 defines
+*/
+
+#define OEM_SHA256_DIGEST_SIZE_IN_BYTES  32
+#define OEM_SHA256_STATE_SIZE_IN_BYTES   256
+#define OEM_SHA256_STATE_SIZE_IN_DWORDS  8
+#define OEM_SHA256_STATE_SIZE_IN_INT64S  4
+#define OEM_SHA256_BLOCK_SIZE_IN_BYTES   64
+#define OEM_SHA256_BLOCK_SIZE_IN_DWORDS  16
+#define OEM_SHA256_NUM_ITERATIONS        64
+#define OEM_SHA256_NUM_FRONT_ITERATIONS  16
+
+#ifndef OEM_SHA1_DIGEST_LEN
+#define OEM_SHA1_DIGEST_LEN 20
+#endif  /* OEM_SHA1_DIGEST_LEN */
+
+/*
+** Structs
+*/
+typedef struct __tagOEM_SHA256_CONTEXT
+{
+    union
+    {
+#if DRM_64BIT_TARGET
+        DRM_UINT64 m_rgu64State64[ OEM_SHA256_STATE_SIZE_IN_INT64S ]; /* force alignment */
+#endif
+        DRM_DWORD  m_rgdwState[ OEM_SHA256_STATE_SIZE_IN_DWORDS ];   /* state (ABCDEFGH) */
+    } m_rgUnion; /* end union */
+
+    DRM_DWORD m_rgdwCount[ 2 ]; /* number of bytes, msb first */
+    DRM_DWORD m_rgdwBuffer[OEM_SHA256_BLOCK_SIZE_IN_DWORDS]; /* input buffer */
+} OEM_SHA256_CONTEXT;
+
+typedef struct __tagOEM_SHA256_DIGEST
+{
+    DRM_BYTE m_rgbDigest[ OEM_SHA256_DIGEST_SIZE_IN_BYTES ];
+} OEM_SHA256_DIGEST;
+
+EXIT_PK_NAMESPACE;
+
+#endif /* #ifndef __OEMSHA256TYPES_H__ */
+
diff --git a/prebuilt-v4.4/noarch/include/oem/common/inc/oemtee.h b/prebuilt-v4.4/noarch/include/oem/common/inc/oemtee.h
new file mode 100644
index 0000000..f04949d
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/oem/common/inc/oemtee.h
@@ -0,0 +1,706 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef _OEMTEE_H_
+#define _OEMTEE_H_ 1
+
+#include <oemteetypes.h>
+#include <oemeccp256.h>
+#include <oemaes.h>
+#include <oemsha256types.h>
+#include <drmteetypes.h>
+#include <drmteeproxystubcommon.h>
+#include <oemaeskeywraptypes.h>
+
+ENTER_PK_NAMESPACE;
+
+PREFAST_PUSH_DISABLE_EXPLAINED(__WARNING_NONCONST_PARAM_25004, "Out params can't be const")
+PREFAST_PUSH_DISABLE_EXPLAINED(__WARNING_NONCONST_BUFFER_PARAM_25033, "Out params can't be const")
+
+/*
+** Memory operations.
+*/
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_TEE_BASE_AllocTEEContext(
+    __inout                                               OEM_TEE_CONTEXT                    *f_pContext ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API_VOID DRM_VOID DRM_CALL OEM_TEE_BASE_FreeTEEContext(
+    __inout_opt                                           OEM_TEE_CONTEXT                    *f_pContextAllowNULL ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_TEE_BASE_GetVersion(
+    __inout                                               OEM_TEE_CONTEXT                    *f_pContext,
+    __out                                                 DRM_DWORD                          *f_pdwVersion ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_TEE_BASE_GetExtendedVersion(
+    __inout                                               OEM_TEE_CONTEXT                    *f_pContext,
+    __out_opt                                             DRM_DWORD                          *f_pcbVersion,
+    __deref_opt_out_bcount( *f_pcbVersion )               DRM_BYTE                          **f_ppbVersion ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_TEE_BASE_GetVersionInformation(
+    __inout                                               OEM_TEE_CONTEXT                    *f_pContext,
+    __out                                                 DRM_DWORD                          *f_pchManufacturerName,
+    __deref_out_ecount( *f_pchManufacturerName )          DRM_WCHAR                         **f_ppwszManufacturerName,
+    __out                                                 DRM_DWORD                          *f_pchModelName,
+    __deref_out_ecount( *f_pchModelName )                 DRM_WCHAR                         **f_ppwszModelName,
+    __out                                                 DRM_DWORD                          *f_pchModelNumber,
+    __deref_out_ecount( *f_pchModelNumber )               DRM_WCHAR                         **f_ppwszModelNumber,
+    __out_ecount_opt( DRM_TEE_METHOD_FUNCTION_MAP_COUNT ) DRM_DWORD                          *f_pdwFunctionMap,
+    __out_opt                                             DRM_DWORD                          *f_pcbProperties,
+    __deref_opt_out_bcount( *f_pcbProperties )            DRM_BYTE                          **f_ppbProperties ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_TEE_BASE_SecureMemAlloc(
+    __inout_opt                                           OEM_TEE_CONTEXT                    *f_pContextAllowNULL,
+    __in                                                  DRM_DWORD                           f_cbSize,
+    __deref_out_bcount(f_cbSize)                          DRM_VOID                          **f_ppv ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API_VOID DRM_VOID DRM_CALL OEM_TEE_BASE_SecureMemFree(
+    __inout_opt                                           OEM_TEE_CONTEXT                    *f_pContextAllowNULL,
+    __inout                                               DRM_VOID                          **f_ppv ) DRM_NO_INLINE_ATTRIBUTE;
+
+PREFAST_PUSH_DISABLE_EXPLAINED(__WARNING_COUNT_REQUIRED_FOR_VOIDPTR_BUFFER_25120, "OEM_TEE_MEMORY_HANDLE is OEM-defined and cannot be SAL annotated for size.");
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_TEE_BASE_SecureMemHandleAlloc(
+    __inout                                               OEM_TEE_CONTEXT                    *f_pContext,
+    __in                                                  DRM_DWORD                           f_dwDecryptionMode,
+    __in                                                  DRM_DWORD                           f_cbSize,
+    __out                                                 DRM_DWORD                          *f_pcbMemHandle,
+    __out                                                 OEM_TEE_MEMORY_HANDLE              *f_pMemHandle ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API_VOID DRM_VOID DRM_CALL OEM_TEE_BASE_SecureMemHandleFree(
+    __inout_opt                                           OEM_TEE_CONTEXT                    *f_pContextAllowNULL,
+    __inout                                               OEM_TEE_MEMORY_HANDLE              *f_pMemHandle ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_DWORD DRM_CALL OEM_TEE_BASE_SecureMemHandleGetSize(
+    __inout                                               OEM_TEE_CONTEXT                    *f_pContext,
+    __in                                            const OEM_TEE_MEMORY_HANDLE               f_hMem ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_TEE_BASE_SecureMemHandleWrite(
+    __inout                                               OEM_TEE_CONTEXT                    *f_pContext,
+    __in                                                  DRM_DWORD                           f_ibWrite,
+    __in                                                  DRM_DWORD                           f_cbWrite,
+    __in_bcount( f_cbWrite )                        const DRM_BYTE                           *f_pbWrite,
+    __inout                                               OEM_TEE_MEMORY_HANDLE               f_hMem ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_TEE_BASE_SecureMemHandleRead(
+    __inout                                               OEM_TEE_CONTEXT                    *f_pContext,
+    __in                                                  DRM_DWORD                           f_ibRead,
+    __in                                                  DRM_DWORD                           f_cbRead,
+    __out_bcount( f_cbRead )                              DRM_BYTE                           *f_pbRead,
+    __in                                            const OEM_TEE_MEMORY_HANDLE               f_hMem ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_DWORD DRM_CALL OEM_TEE_BASE_SecureMemHandleGetHandleSize(
+    __inout                                               OEM_TEE_CONTEXT                    *f_pContext ) DRM_NO_INLINE_ATTRIBUTE;
+PREFAST_POP;  /* __WARNING_COUNT_REQUIRED_FOR_VOIDPTR_BUFFER_25120 */
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_TEE_BASE_AllocKeyAES128(
+    __inout_opt                                           OEM_TEE_CONTEXT                    *f_pContextAllowNULL,
+    __out                                                 OEM_TEE_KEY                        *f_pKey ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_TEE_BASE_AllocKeyECC256(
+    __inout                                               OEM_TEE_CONTEXT                    *f_pContext,
+    __out                                                 OEM_TEE_KEY                        *f_pKey ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API_VOID DRM_VOID DRM_CALL OEM_TEE_BASE_FreeKeyAES128(
+    __inout_opt                                           OEM_TEE_CONTEXT                    *f_pContextAllowNULL,
+    __inout                                               OEM_TEE_KEY                        *f_pKey ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API_VOID DRM_VOID DRM_CALL OEM_TEE_BASE_FreeKeyECC256(
+    __inout                                               OEM_TEE_CONTEXT                    *f_pContext,
+    __inout                                               OEM_TEE_KEY                        *f_pKey ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_TEE_BASE_CopyKeyAES128(
+    __inout                                               OEM_TEE_CONTEXT                    *f_pContext,
+    __inout                                               OEM_TEE_KEY                        *f_pPreallocatedDestKey,
+    __in                                            const OEM_TEE_KEY                        *f_pSourceKey ) DRM_NO_INLINE_ATTRIBUTE;
+
+/*
+** Basic key operations
+*/
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_TEE_BASE_GetCTKID(
+    __inout_opt                                           OEM_TEE_CONTEXT                    *f_pContextAllowNULL,
+    __out                                                 DRM_DWORD                          *f_pdwidCTK ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_TEE_BASE_GetTKByID(
+    __inout_opt                                           OEM_TEE_CONTEXT                    *f_pContextAllowNULL,
+    __in                                                  DRM_DWORD                           f_dwid,
+    __inout                                               OEM_TEE_KEY                        *f_pTK ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_TEE_BASE_DeriveKey(
+    __inout_opt                                           OEM_TEE_CONTEXT                    *f_pContextAllowNULL,
+    __in                                            const OEM_TEE_KEY                        *f_pTKDeriver,
+    __in                                            const DRM_ID                             *f_pidLabel,
+    __in_opt                                        const DRM_ID                             *f_pidContext,
+    __inout                                               OEM_TEE_KEY                        *f_pTKDerived ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_TEE_BASE_AES128_SetKey(
+    __inout_opt                                           OEM_TEE_CONTEXT                    *f_pContextAllowNULL,
+    __in                                                  OEM_TEE_KEY                        *f_pKey,
+    __in_bcount( DRM_AES_BLOCKLEN )                 const DRM_BYTE                            f_rgbKey[ DRM_AES_BLOCKLEN ] ) DRM_NO_INLINE_ATTRIBUTE;
+
+/*
+** Signing and encryption operations
+*/
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_TEE_BASE_VerifyOMAC1Signature(
+    __inout_opt                                           OEM_TEE_CONTEXT                    *f_pContextAllowNULL,
+    __in                                            const OEM_TEE_KEY                        *f_pKey,
+    __in                                                  DRM_DWORD                           f_cbData,
+    __in_bcount( f_cbData )                         const DRM_BYTE                           *f_pbData,
+    __in                                                  DRM_DWORD                           f_cbSignature,
+    __in_bcount( f_cbSignature )                    const DRM_BYTE                           *f_pbSignature) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_TEE_BASE_SignWithOMAC1(
+    __inout_opt                                           OEM_TEE_CONTEXT                    *f_pContextAllowNULL,
+    __in                                            const OEM_TEE_KEY                        *f_pKey,
+    __in                                                  DRM_DWORD                           f_cbDataToSign,
+    __in_bcount( f_cbDataToSign )                   const DRM_BYTE                           *f_pbDataToSign,
+    __out_bcount( DRM_AES128OMAC1_SIZE_IN_BYTES )         DRM_BYTE                           *f_pbSignature ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_TEE_BASE_ECC256_GenerateTeeSigningPrivateKey(
+    __inout_opt                                        OEM_TEE_CONTEXT              *f_pContextAllowNULL,
+    __in_ecount( 1 )                             const OEM_TEE_KEY                  *f_pEccKey,
+    __out_ecount( 1 )                                  OEM_TEE_KEY                  *f_pSigningKey ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_TEE_BASE_ECDSA_P256_SignHash(
+    __inout                                               OEM_TEE_CONTEXT                    *f_pContext,
+    __in                                            const OEM_TEE_KEY                        *f_pSigningKey,
+    __in_bcount( ECC_P256_INTEGER_SIZE_IN_BYTES )   const DRM_BYTE                            f_rgbHashToSign[ECC_P256_INTEGER_SIZE_IN_BYTES],
+    __out                                                 SIGNATURE_P256                     *f_pSignature ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_TEE_BASE_ECDSA_P256_SignData(
+    __inout_opt                                           OEM_TEE_CONTEXT                    *f_pContextAllowNULL,
+    __in                                                  DRM_DWORD                           f_cbToSign,
+    __in_bcount( f_cbToSign )                       const DRM_BYTE                           *f_pbToSign,
+    __in                                            const OEM_TEE_KEY                        *f_pECC256SigningKey,
+    __out                                                 SIGNATURE_P256                     *f_pSignature ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_TEE_BASE_ECDSA_P256_Verify(
+    __inout_opt                                           OEM_TEE_CONTEXT                    *f_pContextAllowNULL,
+    __in                                                  DRM_DWORD                           f_cbDataToVerify,
+    __in_bcount( f_cbDataToVerify )                 const DRM_BYTE                           *f_pbDataToVerify,
+    __in                                            const PUBKEY_P256                        *f_pPubKey,
+    __in                                            const SIGNATURE_P256                     *f_pSignature ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_TEE_BASE_ECC256_Encrypt_AES128Keys(
+    __inout                                               OEM_TEE_CONTEXT                    *f_pContext,
+    __in                                            const PUBKEY_P256                        *f_pPubkey,
+    __in_opt                                        const OEM_TEE_KEY                        *f_pKey1,
+    __in                                            const OEM_TEE_KEY                        *f_pKey2,
+    __out                                                 CIPHERTEXT_P256                    *f_pCiphertext ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_TEE_BASE_ECC256_Decrypt_AES128Keys(
+    __inout                                               OEM_TEE_CONTEXT                    *f_pContext,
+    __in                                            const OEM_TEE_KEY                        *f_pPrivKey,
+    __in                                            const CIPHERTEXT_P256                    *f_pEncryptedKeys,
+    __inout_opt                                           OEM_TEE_KEY                        *f_pKey1,
+    __inout                                               OEM_TEE_KEY                        *f_pKey2 ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_API DRM_RESULT DRM_CALL OEM_TEE_BASE_AES128CBC_EncryptData(
+    __inout_opt                                           OEM_TEE_CONTEXT                    *f_pContextAllowNULL,
+    __in                                            const OEM_TEE_KEY                        *f_pKey,
+    __in_bcount( DRM_AES_BLOCKLEN )                 const DRM_BYTE                            f_rgbIV[ DRM_AES_BLOCKLEN ],
+    __in                                                  DRM_DWORD                           f_cbData,
+    __inout_bcount( f_cbData )                            DRM_BYTE                           *f_pbData ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_API DRM_RESULT DRM_CALL OEM_TEE_BASE_AES128CBC_DecryptData(
+    __inout_opt                                           OEM_TEE_CONTEXT                    *f_pContextAllowNULL,
+    __in                                            const OEM_TEE_KEY                        *f_pKey,
+    __in_bcount( DRM_AES_BLOCKLEN )                 const DRM_BYTE                            f_rgbIV[ DRM_AES_BLOCKLEN ],
+    __in                                                  DRM_DWORD                           f_cbData,
+    __inout_bcount( f_cbData )                            DRM_BYTE                           *f_pbData ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_TEE_BASE_AES128ECB_EncryptData(
+    __inout                                               OEM_TEE_CONTEXT                    *f_pContext,
+    __in                                            const OEM_TEE_KEY                        *f_pKey,
+    __in                                                  DRM_DWORD                           f_cbData,
+    __inout_bcount( f_cbData )                            DRM_BYTE                           *f_pbData ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_TEE_BASE_AES128ECB_DecryptData(
+    __inout                                               OEM_TEE_CONTEXT                    *f_pContext,
+    __in                                            const OEM_TEE_KEY                        *f_pKey,
+    __in                                                  DRM_DWORD                           f_cbData,
+    __inout_bcount( f_cbData )                            DRM_BYTE                           *f_pbData ) DRM_NO_INLINE_ATTRIBUTE;
+
+/*
+** Random Number/Key Generation operations
+*/
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_TEE_BASE_GenerateRandomBytes(
+    __inout_opt                                           OEM_TEE_CONTEXT                    *f_pContextAllowNULL,
+    __in                                                  DRM_DWORD                           f_cb,
+    __out_bcount( f_cb )                                  DRM_BYTE                           *f_pb ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_TEE_BASE_GenerateRandomAES128Key(
+    __inout                                               OEM_TEE_CONTEXT                    *f_pContext,
+    __inout                                               OEM_TEE_KEY                        *f_pKey ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_TEE_BASE_GenerateRandomAES128KeyPair(
+    __inout                                               OEM_TEE_CONTEXT                    *f_pContext,
+    __inout                                               OEM_TEE_KEY                        *f_pKey1,
+    __inout                                               OEM_TEE_KEY                        *f_pKey2 ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_TEE_BASE_GenerateRandomAES128KeyPairAndAES128ECBEncrypt(
+    __inout                                               OEM_TEE_CONTEXT                    *f_pContext,
+    __in                                            const OEM_TEE_KEY                        *f_pEncryptingKey,
+    __inout                                               OEM_TEE_KEY                        *f_pKey1,
+    __inout                                               OEM_TEE_KEY                        *f_pKey2,
+    __out_bcount( DRM_AES_KEYSIZE_128_X2 )                DRM_BYTE                           *f_pEncryptedKeys ) DRM_NO_INLINE_ATTRIBUTE;
+
+/*
+** Device Info operations specific to this device instance
+*/
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_TEE_BASE_GetDeviceUniqueID(
+    __inout                                               OEM_TEE_CONTEXT                    *f_pContext,
+    __out                                                 DRM_ID                             *f_pID ) DRM_NO_INLINE_ATTRIBUTE;
+
+/*
+** Shared decryption operations (requried for all playback)
+*/
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_TEE_DECRYPT_BuildExternalPolicyCryptoInfo(
+    __inout                                               OEM_TEE_CONTEXT                    *f_pContext,
+    __in                                            const DRM_ID                             *f_pidSession,
+    __in_opt                                        const DRM_TEE_BYTE_BLOB                  *f_pCDKB,
+    __in_opt                                        const OEM_TEE_KEY                        *f_pContentKey,
+    __in_opt                                        const OEM_TEE_KEY                        *f_pSampleProtectionKey,
+    __in                                                  DRM_DWORD                           f_cbOEMData,
+    __in_bcount_opt( f_cbOEMData )                  const DRM_BYTE                           *f_pbOEMData,
+    __in                                            const DRM_TEE_POLICY_INFO                *f_pPolicy,
+    __out                                                 DRM_DWORD                          *f_pcbInfo,
+    __deref_out_bcount( *f_pcbInfo )                      DRM_BYTE                          **f_ppbInfo ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_TEE_DECRYPT_ParseAndVerifyExternalPolicyCryptoInfo(
+    __inout                                               OEM_TEE_CONTEXT                    *f_pContext,
+    __in                                                  DRM_DWORD                           f_cbInfo,
+    __in_bcount( f_cbInfo )                         const DRM_BYTE                           *f_pbInfo,
+    __deref_out                                           DRM_TEE_POLICY_INFO               **f_ppPolicyInfo,
+    __out                                                 DRM_ID                             *f_pidSession,
+    __out                                                 OEM_TEE_KEY                        *f_pContentKey,
+    __out                                                 OEM_TEE_KEY                        *f_pSampleProtKey ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API_VOID DRM_VOID DRM_CALL OEM_TEE_DECRYPT_RemapRequestedDecryptionModeToSupportedDecryptionMode(
+    __inout                                               OEM_TEE_CONTEXT                    *f_pContext,
+    __inout                                               DRM_DWORD                          *f_pdwDecryptionMode ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_TEE_DECRYPT_DecryptContentKeysWithLicenseKey(
+    __inout                                               OEM_TEE_CONTEXT                    *f_pContext,
+    __in                                            const OEM_TEE_KEY                        *f_pRootCK,
+    __in                                                  DRM_DWORD                           f_cbCiphertext,
+    __in_bcount( f_cbCiphertext )                   const DRM_BYTE                           *f_pbCiphertext,
+    __inout                                               OEM_TEE_KEY                        *f_pCI,
+    __inout                                               OEM_TEE_KEY                        *f_pCK ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_TEE_DECRYPT_VerifyLicenseChecksum(
+    __inout                                               OEM_TEE_CONTEXT                    *f_pContext,
+    __in                                            const OEM_TEE_KEY                        *f_pCK,
+    __in_bcount( sizeof( DRM_ID ) )                 const DRM_BYTE                           *f_pbKID,
+    __in_bcount( f_cbChecksum )                     const DRM_BYTE                           *f_pbChecksum,
+    __in                                                  DRM_DWORD                           f_cbChecksum ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_TEE_DECRYPT_UnshuffleScalableContentKeys(
+    __inout                                               OEM_TEE_CONTEXT                    *f_pContext,
+    __inout                                               OEM_TEE_KEY                        *f_pCI,
+    __inout                                               OEM_TEE_KEY                        *f_pCK ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_TEE_DECRYPT_ShuffleScalableContentKeys(
+    __inout                                               OEM_TEE_CONTEXT                    *f_pContext,
+    __inout                                               OEM_TEE_KEY                        *f_pCI,
+    __inout                                               OEM_TEE_KEY                        *f_pCK ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_TEE_DECRYPT_CalculateContentKeyPrimeWithAES128Key(
+    __inout                                               OEM_TEE_CONTEXT                    *f_pContext,
+    __in                                            const OEM_TEE_KEY                        *f_pContentKey,
+    __in_bcount( DRM_AES_KEYSIZE_128 )              const DRM_BYTE                           *f_pbPrime,
+    __inout                                               OEM_TEE_KEY                        *f_pContentKeyPrime ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_TEE_DECRYPT_DeriveScalableKeyWithAES128Key(
+    __inout                                               OEM_TEE_CONTEXT                    *f_pContext,
+    __in                                            const OEM_TEE_KEY                        *f_pEncKey,
+    __in_bcount( DRM_AES_KEYSIZE_128 )              const DRM_BYTE                           *f_pbKey,
+    __inout                                               OEM_TEE_KEY                        *f_pDerivedScalableKey ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_TEE_DECRYPT_InitUplinkXKey(
+    __inout                                               OEM_TEE_CONTEXT                    *f_pContext,
+    __inout                                               OEM_TEE_KEY                        *f_pUplinkXKey ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_TEE_DECRYPT_UpdateUplinkXKey(
+    __inout                                               OEM_TEE_CONTEXT                    *f_pContext,
+    __in                                            const OEM_TEE_KEY                        *f_pLocationKey,
+    __inout                                               OEM_TEE_KEY                        *f_pUplinkXKey ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_TEE_DECRYPT_DecryptContentKeysWithDerivedKeys(
+    __inout                                               OEM_TEE_CONTEXT                    *f_pContext,
+    __in                                            const OEM_TEE_KEY                        *f_pSecondaryKey,
+    __in                                            const OEM_TEE_KEY                        *f_pUplinkxKey,
+    __in_bcount( DRM_AES_KEYSIZE_128_X2 )           const DRM_BYTE                           *f_pbCiphertext,
+    __inout                                               OEM_TEE_KEY                        *f_pCI,
+    __inout                                               OEM_TEE_KEY                        *f_pCK ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_TEE_DECRYPT_EnforcePolicy(
+    __inout                                               OEM_TEE_CONTEXT                    *f_pContext,
+    __in                                                  DRM_TEE_POLICY_INFO_CALLING_API     f_ePolicyCallingAPI,
+    __in                                            const DRM_TEE_POLICY_INFO                *f_pPolicy ) DRM_NO_INLINE_ATTRIBUTE;
+
+/*
+** AES128CTR Playback operations
+*/
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_TEE_AES128CTR_DecryptContentIntoClear(
+    __inout                                               OEM_TEE_CONTEXT                    *f_pContext,
+    __in                                                  DRM_TEE_POLICY_INFO_CALLING_API     f_ePolicyCallingAPI,
+    __in                                            const DRM_TEE_POLICY_INFO                *f_pPolicy,
+    __in                                            const OEM_TEE_KEY                        *f_pCK,
+    __in                                                  DRM_DWORD                           f_cEncryptedRegionMappings,
+    __in_ecount( f_cEncryptedRegionMappings )       const DRM_DWORD                          *f_pdwEncryptedRegionMappings,
+    __in                                                  DRM_UINT64                          f_ui64InitializationVectorHigh,
+    __in                                                  DRM_UINT64                          f_ui64InitializationVectorLow,
+    __in                                                  DRM_DWORD                           f_cEncryptedRegionSkip,
+    __in_ecount_opt( f_cEncryptedRegionSkip )       const DRM_DWORD                          *f_pcEncryptedRegionSkip,
+    __in                                                  DRM_DWORD                           f_cbEncryptedToClear,
+    __inout_bcount( f_cbEncryptedToClear )                DRM_BYTE                           *f_pbEncryptedToClear,
+    __in                                                  DRM_DWORD                           f_ibProcessing,
+    __out_opt                                             DRM_DWORD                          *f_pcbProcessed ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_TEE_AES128CTR_DecryptContentIntoHandle(
+    __inout                                               OEM_TEE_CONTEXT                    *f_pContext,
+    __in                                                  DRM_TEE_POLICY_INFO_CALLING_API     f_ePolicyCallingAPI,
+    __in                                            const DRM_TEE_POLICY_INFO                *f_pPolicy,
+    __in                                            const OEM_TEE_KEY                        *f_pCK,
+    __in                                                  DRM_DWORD                           f_cEncryptedRegionMappings,
+    __in_ecount( f_cEncryptedRegionMappings )       const DRM_DWORD                          *f_pdwEncryptedRegionMappings,
+    __in                                                  DRM_UINT64                          f_ui64InitializationVectorHigh,
+    __in                                                  DRM_UINT64                          f_ui64InitializationVectorLow,
+    __in                                                  DRM_DWORD                           f_cEncryptedRegionSkip,
+    __in_ecount_opt( f_cEncryptedRegionSkip )       const DRM_DWORD                          *f_pcEncryptedRegionSkip,
+    __in                                                  DRM_DWORD                           f_cbEncrypted,
+    __in_bcount( f_cbEncrypted )                    const DRM_BYTE                           *f_pbEncrypted,
+    __inout                                               OEM_TEE_MEMORY_HANDLE               f_hClear,
+    __in                                                  DRM_DWORD                           f_ibProcessing,
+    __out_opt                                             DRM_DWORD                          *f_pcbProcessed ) DRM_NO_INLINE_ATTRIBUTE;
+
+/*
+** AES128CBC Playback operations
+*/
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_TEE_AES128CBC_DecryptContentIntoClear(
+    __inout                                               OEM_TEE_CONTEXT                    *f_pContext,
+    __in                                                  DRM_TEE_POLICY_INFO_CALLING_API     f_ePolicyCallingAPI,
+    __in                                            const DRM_TEE_POLICY_INFO                *f_pPolicy,
+    __in                                            const OEM_TEE_KEY                        *f_pCK,
+    __in                                                  DRM_DWORD                           f_cEncryptedRegionMappings,
+    __in_ecount( f_cEncryptedRegionMappings )       const DRM_DWORD                          *f_pdwEncryptedRegionMappings,
+    __in                                                  DRM_UINT64                          f_ui64InitializationVectorHigh,
+    __in                                                  DRM_UINT64                          f_ui64InitializationVectorLow,
+    __in                                                  DRM_DWORD                           f_cEncryptedRegionSkip,
+    __in_ecount_opt( f_cEncryptedRegionSkip )       const DRM_DWORD                          *f_pcEncryptedRegionSkip,
+    __in                                                  DRM_DWORD                           f_cbEncryptedToClear,
+    __inout_bcount( f_cbEncryptedToClear )                DRM_BYTE                           *f_pbEncryptedToClear,
+    __in                                                  DRM_DWORD                           f_ibProcessing,
+    __out_opt                                             DRM_DWORD                          *f_pcbProcessed ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_TEE_AES128CBC_DecryptContentIntoHandle(
+    __inout                                               OEM_TEE_CONTEXT                    *f_pContext,
+    __in                                                  DRM_TEE_POLICY_INFO_CALLING_API     f_ePolicyCallingAPI,
+    __in                                            const DRM_TEE_POLICY_INFO                *f_pPolicy,
+    __in                                            const OEM_TEE_KEY                        *f_pCK,
+    __in                                                  DRM_DWORD                           f_cEncryptedRegionMappings,
+    __in_ecount( f_cEncryptedRegionMappings )       const DRM_DWORD                          *f_pdwEncryptedRegionMappings,
+    __in                                                  DRM_UINT64                          f_ui64InitializationVectorHigh,
+    __in                                                  DRM_UINT64                          f_ui64InitializationVectorLow,
+    __in                                                  DRM_DWORD                           f_cEncryptedRegionSkip,
+    __in_ecount_opt( f_cEncryptedRegionSkip )       const DRM_DWORD                          *f_pcEncryptedRegionSkip,
+    __in                                                  DRM_DWORD                           f_cbEncrypted,
+    __in_bcount( f_cbEncrypted )                    const DRM_BYTE                           *f_pbEncrypted,
+    __inout                                               OEM_TEE_MEMORY_HANDLE               f_hClear,
+    __in                                                  DRM_DWORD                           f_ibProcessing,
+    __out_opt                                             DRM_DWORD                          *f_pcbProcessed ) DRM_NO_INLINE_ATTRIBUTE;
+
+/*
+** Clock operations
+*/
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_TEE_CLOCK_GetSecurelySetSystemTime(
+    __inout                                               OEM_TEE_CONTEXT                    *f_pContext,
+    __out                                                 DRMFILETIME                        *f_pftSystemTime ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_TEE_CLOCK_GetTimestamp(
+    __inout_opt                                           OEM_TEE_CONTEXT                    *f_pContextAllowNULL,
+    __out                                                 DRMFILETIME                        *f_pftTimestamp ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_TEE_CLOCK_SetSecureSystemTime(
+    __inout                                               OEM_TEE_CONTEXT                    *f_pContext,
+    __in                                            const DRMFILETIME                        *f_pftSystemTime ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_BOOL DRM_CALL OEM_TEE_CLOCK_SecureClockNeedsReSync(
+    __inout                                               OEM_TEE_CONTEXT                    *f_pContext) DRM_NO_INLINE_ATTRIBUTE;
+
+/*
+** Domain operations
+*/
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_TEE_DOM_DecryptDomainKeyWithSessionKeys(
+    __inout                                               OEM_TEE_CONTEXT                    *f_pContext,
+    __in                                            const OEM_TEE_KEY                        *f_pSessionKey1,
+    __in                                            const OEM_TEE_KEY                        *f_pSessionKey2,
+    __in_bcount( ECC_P256_PRIVKEY_SIZE_IN_BYTES )   const DRM_BYTE                           *f_pbEncryptedDomainKey,
+    __inout                                               OEM_TEE_KEY                        *f_pDomainPrivKey ) DRM_NO_INLINE_ATTRIBUTE;
+
+/*
+** H.264 Operations
+*/
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_TEE_H264_PreProcessEncryptedData(
+    __inout                                               OEM_TEE_CONTEXT                    *f_pContext,
+    __in                                            const OEM_TEE_KEY                        *f_pCK,
+    __in                                                  DRM_DWORD                           f_cbOEMKeyInfo,
+    __in_bcount( f_cbOEMKeyInfo )                   const DRM_BYTE                           *f_pbOEMKeyInfo,
+    __inout_ecount( 1 )                                   DRM_UINT64                         *f_pui64InitializationVector,
+    __in                                                  DRM_DWORD                           f_cEncryptedRegionMappings,
+    __in_ecount( f_cEncryptedRegionMappings )       const DRM_DWORD                          *f_pdwEncryptedRegionMappings,
+    __out                                                 DRM_DWORD                          *f_pcbOpaqueFrameData,
+    __deref_out_bcount( *f_pcbOpaqueFrameData )           DRM_BYTE                          **f_ppbOpaqueFrameData,
+    __in                                                  DRM_DWORD                           f_cbEncryptedTranscryptedFullFrame,
+    __inout_bcount( f_cbEncryptedTranscryptedFullFrame )  DRM_BYTE                           *f_pbEncryptedTranscryptedFullFrame ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_TEE_H264_DecryptContentFragmentIntoClear(
+    __inout                                               OEM_TEE_CONTEXT                    *f_pContext,
+    __in                                                  DRM_TEE_POLICY_INFO_CALLING_API     f_ePolicyCallingAPI,
+    __in                                            const DRM_TEE_POLICY_INFO                *f_pPolicy,
+    __in                                            const OEM_TEE_KEY                        *f_pCK,
+    __in                                                  DRM_UINT64                          f_ui64InitializationVector,
+    __in                                                  DRM_UINT64                          f_ui64Offset,
+    __in                                                  DRM_BYTE                            f_bOffset,
+    __in                                                  DRM_DWORD                           f_cbFragmentEncryptedToClear,
+    __inout_bcount( f_cbFragmentEncryptedToClear )        DRM_BYTE                           *f_pbFragmentEncryptedToClear ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API_VOID DRM_VOID DRM_CALL OEM_TEE_H264_ZERO_MEMORY(
+    __inout_opt                                           OEM_TEE_CONTEXT                    *f_pContextAllowNULL,
+    __in                                                  DRM_DWORD                           f_cbEncryptedTranscryptedFullFrame,
+    __inout_bcount( f_cbEncryptedTranscryptedFullFrame )  DRM_BYTE                           *f_pbEncryptedTranscryptedFullFrame ) DRM_NO_INLINE_ATTRIBUTE;
+
+/*
+** Key wrapping and unwraping operations
+*/
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_TEE_BASE_WrapAES128KeyForPersistedStorage(
+    __inout                                                                          OEM_TEE_CONTEXT            *f_pContext,
+    __in                                                                       const OEM_TEE_KEY                *f_pWrappingKey,
+    __in                                                                       const OEM_TEE_KEY                *f_pKeyToBeWrapped,
+    __inout                                                                          DRM_DWORD                  *f_pibWrappedKeyBuffer,
+    __inout_ecount_opt( *f_pibWrappedKeyBuffer + sizeof( OEM_WRAPPED_KEY_AES_128 ) ) DRM_BYTE                   *f_pbWrappedKeyBuffer ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_TEE_BASE_WrapECC256KeyForPersistedStorage(
+    __inout                                                                          OEM_TEE_CONTEXT            *f_pContext,
+    __in                                                                       const OEM_TEE_KEY                *f_pWrappingKey,
+    __in                                                                       const OEM_TEE_KEY                *f_pKeyToBeWrapped,
+    __inout                                                                          DRM_DWORD                  *f_pibWrappedKeyBuffer,
+    __inout_ecount_opt( *f_pibWrappedKeyBuffer + sizeof( OEM_WRAPPED_KEY_ECC_256 ) ) DRM_BYTE                   *f_pbWrappedKeyBuffer ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_TEE_BASE_WrapAES128KeyForTransientStorage(
+    __inout                                                                          OEM_TEE_CONTEXT    *f_pContext,
+    __in                                                                       const OEM_TEE_KEY        *f_pWrappingKey,
+    __in                                                                       const OEM_TEE_KEY        *f_pKeyToBeWrapped,
+    __inout                                                                          DRM_DWORD          *f_pibWrappedKeyBuffer,
+    __inout_ecount_opt( *f_pibWrappedKeyBuffer + sizeof( OEM_WRAPPED_KEY_AES_128 ) ) DRM_BYTE           *f_pbWrappedKeyBuffer ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_TEE_BASE_UnwrapAES128KeyFromPersistedStorage(
+    __inout                                               OEM_TEE_CONTEXT                    *f_pContext,
+    __in                                            const OEM_TEE_KEY                        *f_pWrappingKey,
+    __inout                                               DRM_DWORD                          *f_pcbWrappedKeyBuffer,
+    __inout                                               DRM_DWORD                          *f_pibWrappedKeyBuffer,
+    __in_bcount(*f_pcbWrappedKeyBuffer)             const DRM_BYTE                           *f_pbWrappedKeyBuffer,
+    __inout                                               OEM_TEE_KEY                        *f_pPreallocatedUnwrappedKey ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_TEE_BASE_UnwrapECC256KeyFromPersistedStorage(
+    __inout                                               OEM_TEE_CONTEXT                    *f_pContext,
+    __in                                            const OEM_TEE_KEY                        *f_pWrappingKey,
+    __inout                                               DRM_DWORD                          *f_pcbWrappedKeyBuffer,
+    __inout                                               DRM_DWORD                          *f_pibWrappedKeyBuffer,
+    __in_bcount( *f_pcbWrappedKeyBuffer )           const DRM_BYTE                           *f_pbWrappedKeyBuffer,
+    __inout                                               OEM_TEE_KEY                        *f_pPreallocatedUnwrappedKey ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_TEE_BASE_UnwrapAES128KeyFromTransientStorage(
+    __inout_opt                                           OEM_TEE_CONTEXT                    *f_pContextAllowNULL,
+    __in                                            const OEM_TEE_KEY                        *f_pWrappingKey,
+    __inout                                               DRM_DWORD                          *f_pcbWrappedKeyBuffer,
+    __inout                                               DRM_DWORD                          *f_pibWrappedKeyBuffer,
+    __in_bcount( *f_pcbWrappedKeyBuffer )           const DRM_BYTE                           *f_pbWrappedKeyBuffer,
+    __inout                                               OEM_TEE_KEY                        *f_pPreallocatedUnwrappedKey ) DRM_NO_INLINE_ATTRIBUTE;
+
+/*
+** License Generation operations
+*/
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_TEE_LICGEN_EncryptContentOutOfClear(
+    __inout                                               OEM_TEE_CONTEXT                    *f_pContext,
+    __in                                            const OEM_TEE_KEY                        *f_pCK,
+    __in                                                  DRM_DWORD                           f_cEncryptedRegionMappings,
+    __in_ecount( f_cEncryptedRegionMappings )       const DRM_DWORD                          *f_pdwEncryptedRegionMappings,
+    __in                                                  DRM_DWORD                           f_cbClearToEncrypted,
+    __inout_bcount( f_cbClearToEncrypted )                DRM_BYTE                           *f_pbClearToEncrypted,
+    __out                                                 DRM_UINT64                         *f_pui64InitializationVector ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_TEE_LICGEN_EncryptContentOutOfHandle(
+    __inout                                               OEM_TEE_CONTEXT                    *f_pContext,
+    __in                                            const OEM_TEE_KEY                        *f_pCK,
+    __in                                                  DRM_DWORD                           f_cEncryptedRegionMappings,
+    __in_ecount( f_cEncryptedRegionMappings )       const DRM_DWORD                          *f_pdwEncryptedRegionMappings,
+    __in                                            const OEM_TEE_MEMORY_HANDLE               f_hClear,
+    __out                                                 DRM_DWORD                          *f_pcbEncrypted,
+    __deref_out_bcount( *f_pcbEncrypted )                 DRM_BYTE                          **f_ppbEncrypted,
+    __out                                                 DRM_UINT64                         *f_pui64InitializationVector ) DRM_NO_INLINE_ATTRIBUTE;
+
+/*
+** All types of provisioning operations
+*/
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_TEE_PROV_GenerateRandomECC256KeyPair(
+    __inout                                               OEM_TEE_CONTEXT                    *f_pContext,
+    __inout                                               OEM_TEE_KEY                        *f_pKey,
+    __out                                                 PUBKEY_P256                        *f_pPubKey ) DRM_NO_INLINE_ATTRIBUTE;
+
+/*
+** Local Provisioning operations
+*/
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_TEE_LPROV_UnprotectModelCertificatePrivateSigningKey(
+    __inout                                                                           OEM_TEE_CONTEXT   *f_pContext,
+    __in                                                                              DRM_DWORD          f_cbOEMProtectedModelCertificatePrivateKey,
+    __in_bcount( f_cbOEMProtectedModelCertificatePrivateKey )                   const DRM_BYTE          *f_pbOEMProtectedModelCertificatePrivateKey,
+    __out                                                                             DRM_DWORD         *f_pcbOEMDefaultProtectedModelCertificatePrivateKey,
+    __deref_out_bcount_opt( *f_pcbOEMDefaultProtectedModelCertificatePrivateKey )     DRM_BYTE         **f_ppbOEMDefaultProtectedModelCertificatePrivateKey,
+    __inout                                                                           OEM_TEE_KEY       *f_pModelCertPrivateKey ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_TEE_LPROV_UnprotectLeafCertificatePrivateKeys(
+    __inout                                                                           OEM_TEE_CONTEXT   *f_pContext,
+    __in                                                                              DRM_DWORD          f_cbOEMProtectedLeafCertificatePrivateKeys,
+    __in_bcount( f_cbOEMProtectedLeafCertificatePrivateKeys )                   const DRM_BYTE          *f_pbOEMProtectedLeafCertificatePrivateKeys,
+    __out                                                                             DRM_DWORD         *f_pcbOEMDefaultProtectedLeafCertificatePrivateKeys,
+    __deref_out_bcount_opt( *f_pcbOEMDefaultProtectedLeafCertificatePrivateKeys )     DRM_BYTE         **f_ppbOEMDefaultProtectedLeafCertificatePrivateKeys,
+    __inout                                                                           OEM_TEE_KEY       *f_pLeafCertificatePrivateSigningKey,
+    __inout                                                                           OEM_TEE_KEY       *f_pLeafCertificatePrivateEncryptionKey ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_BOOL DRM_CALL OEM_TEE_LPROV_IsModelCertificateExpected( DRM_VOID ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_TEE_LPROV_UnprotectCertificate(
+    __inout                                               OEM_TEE_CONTEXT                    *f_pContext,
+    __in                                                  DRM_DWORD                           f_cbInputCertificate,
+    __in_bcount( f_cbInputCertificate )             const DRM_BYTE                           *f_pbInputCertificate,
+    __out                                                 DRM_DWORD                          *f_pcbCertificate,
+    __deref_out_bcount( *f_pcbCertificate )               DRM_BYTE                          **f_ppbCertificate ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_TEE_LPROV_GetModelSecurityVersion(
+    __inout                                               OEM_TEE_CONTEXT                    *f_pContext,
+    __out                                                 DRM_DWORD                          *f_pdwSecurityVersion,
+    __out                                                 DRM_DWORD                          *f_pdwPlatformID ) DRM_NO_INLINE_ATTRIBUTE;
+
+/*
+** Remote provisioning operations
+*/
+DRM_NO_INLINE DRM_API DRM_BOOL DRM_CALL OEM_TEE_RPROV_IsBootstrapNecessary( DRM_VOID ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_TEE_RPROV_ProcessResponse(
+    __inout                                               OEM_TEE_CONTEXT                    *f_pOemTeeCtx,
+    __in_bcount( f_cbResponse )                     const DRM_BYTE                           *f_pbResponse,
+    __in                                                  DRM_DWORD                           f_cbResponse,
+    __in_ecount( RPROV_KEYPAIR_COUNT )              const PUBKEY_P256                        *f_poPubkeys,
+    __deref_out_bcount( *f_pcbCert )                      DRM_BYTE                          **f_ppbCert,
+    __out_ecount( 1 )                                     DRM_DWORD                          *f_pcbCert ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_TEE_RPROV_WrapProvisioningRequest(
+    __inout                                               OEM_TEE_CONTEXT                    *f_pOemTeeCtx,
+    __deref_inout_bcount( *f_pcbOutputMessage )           DRM_BYTE                          **f_ppbOutputMessage,
+    __inout_ecount( 1 )                                   DRM_DWORD                          *f_pcbOutputMessage ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_TEE_RPROV_GenerateBootstrapChallenge(
+    __inout                                               OEM_TEE_CONTEXT                    *f_pContext,
+    __inout                                               DRM_DWORD                          *f_pcbRProvContext,
+    __deref_inout_bcount( *f_pcbRProvContext )            DRM_BYTE                          **f_ppbRProvContext,
+    __out                                                 DRM_DWORD                          *f_pdwType,
+    __out                                                 DRM_DWORD                          *f_pdwStep,
+    __out                                                 DRM_DWORD                          *f_pdwAdditionalInfoNeeded,
+    __out                                                 DRM_DWORD                          *f_pcbChallenge,
+    __deref_out_bcount( *f_pcbChallenge )                 DRM_BYTE                          **f_ppbChallenge ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_TEE_RPROV_ProcessBootstrapResponse(
+    __inout                                               OEM_TEE_CONTEXT                    *f_pContext,
+    __inout                                               DRM_DWORD                          *f_pcbRProvContext,
+    __deref_inout_bcount( *f_pcbRProvContext )            DRM_BYTE                          **f_ppbRProvContext,
+    __in                                                  DRM_DWORD                           f_cbResponse,
+    __in_bcount_opt( f_cbResponse )                 const DRM_BYTE                           *f_pbResponse,
+    __inout                                               OEM_TEE_KEY                        *f_pKSession ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_TEE_RPROV_GetSecureMediaPathCapabilities(
+    __inout                                               OEM_TEE_CONTEXT                    *f_pContext,
+    __out                                                 DRM_DWORD                          *f_pcbSMPC,
+    __deref_out_bcount( *f_pcbSMPC )                      DRM_BYTE                          **f_ppbSMPC ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_DWORD DRM_CALL OEM_TEE_RPROV_GetLeafCertificateFeatures(
+    __inout                                               OEM_TEE_CONTEXT                    *f_pContext) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_TEE_RPROV_VerifyNonce(
+    __inout                                               OEM_TEE_CONTEXT                    *f_pContext,
+    __in                                                  DRM_DWORD                           f_cbNonce,
+    __in_bcount( f_cbNonce )                        const DRM_BYTE                           *f_pbNonce) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_TEE_RPROV_GenerateNonce(
+    __inout                                               OEM_TEE_CONTEXT                    *f_pContext,
+    __in                                                  DRM_DWORD                           f_cbNonce,
+    __out_bcount( f_cbNonce )                             DRM_BYTE                           *f_pbNonce ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_TEE_RPROV_GetModelAuthorizationCertificateAndPrivateSigningKey(
+    __inout                                               OEM_TEE_CONTEXT                    *f_pContext,
+    __out                                                 DRM_DWORD                          *f_pcbCertificate,
+    __deref_out_bcount( *f_pcbCertificate )               DRM_BYTE                          **f_ppbCertificate,
+    __inout                                               OEM_TEE_KEY                        *f_pModelCertPrivateKey ) DRM_NO_INLINE_ATTRIBUTE;
+
+/*
+** Sample Protection operations
+*/
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_TEE_SAMPLEPROT_ApplySampleProtection(
+    __inout                                               OEM_TEE_CONTEXT                    *f_pContext,
+    __in                                            const OEM_TEE_KEY                        *f_pSPK,
+    __in                                                  DRM_UINT64                          f_ui64InitializationVector,
+    __in                                                  DRM_DWORD                           f_cbClearToSampleProtected,
+    __inout_bcount( f_cbClearToSampleProtected )          DRM_BYTE                           *f_pbClearToSampleProtected ) DRM_NO_INLINE_ATTRIBUTE;
+
+/*
+** Secure Stop operations
+*/
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_TEE_SECURESTOP_GetGenerationID(
+    __inout                                               OEM_TEE_CONTEXT                    *f_pContext,
+    __in                                            const DRM_ID                             *f_pidEnvironment,
+    __out                                                 DRM_DWORD                          *f_pdwGenerationID ) DRM_NO_INLINE_ATTRIBUTE;
+
+/*
+** SecureStop2 operations
+*/
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_TEE_SECURESTOP2_StopDecryptors(
+    __inout                                               OEM_TEE_CONTEXT                    *f_pContext,
+    __in                                            const DRM_ID                             *f_pidLID ) DRM_NO_INLINE_ATTRIBUTE;
+
+/*
+** SHA256 functions
+*/
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_TEE_BASE_SHA256_Init(
+    __inout_opt                                           OEM_TEE_CONTEXT                    *f_pContextAllowNULL,
+    __out_ecount( 1 )                                     OEM_SHA256_CONTEXT                 *f_pShaContext ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_TEE_BASE_SHA256_Update(
+    __inout_opt                                           OEM_TEE_CONTEXT                    *f_pContextAllowNULL,
+    __inout_ecount( 1 )                                   OEM_SHA256_CONTEXT                 *f_pShaContext,
+    __in                                                  DRM_DWORD                           f_cbBuffer,
+    __in_ecount( f_cbBuffer )                       const DRM_BYTE                            f_rgbBuffer[] ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_TEE_BASE_SHA256_Finalize(
+    __inout_opt                                           OEM_TEE_CONTEXT                    *f_pContextAllowNULL,
+    __inout_ecount( 1 )                                   OEM_SHA256_CONTEXT                 *f_pShaContext,
+    __out_ecount( 1 )                                     OEM_SHA256_DIGEST                  *f_pDigest ) DRM_NO_INLINE_ATTRIBUTE;
+
+/*
+** Critical Section functions
+*/
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_TEE_BASE_CRITSEC_Initialize( DRM_VOID ) DRM_NO_INLINE_ATTRIBUTE;
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_TEE_BASE_CRITSEC_Uninitialize( DRM_VOID ) DRM_NO_INLINE_ATTRIBUTE;
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_TEE_BASE_CRITSEC_Enter( DRM_VOID ) DRM_NO_INLINE_ATTRIBUTE;
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_TEE_BASE_CRITSEC_Leave( DRM_VOID ) DRM_NO_INLINE_ATTRIBUTE;
+
+PREFAST_POP /* __WARNING_NONCONST_BUFFER_PARAM_25033 */
+PREFAST_POP /* __WARNING_NONCONST_PARAM_25004 */
+
+EXIT_PK_NAMESPACE;
+
+#endif /* _OEMTEE_H_ */
+
diff --git a/prebuilt-v4.4/noarch/include/oem/common/inc/oemteeproxy.h b/prebuilt-v4.4/noarch/include/oem/common/inc/oemteeproxy.h
new file mode 100644
index 0000000..f8b62d0
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/oem/common/inc/oemteeproxy.h
@@ -0,0 +1,75 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef _OEMTEEPROXY_H_
+#define _OEMTEEPROXY_H_ 1
+
+#include <oemteetypes.h>
+#include <oemeccp256.h>
+#include <drmteetypes.h>
+#include <drmxb.h>
+#include <drmteeproxyformat_generated.h>
+
+ENTER_PK_NAMESPACE;
+
+PREFAST_PUSH_DISABLE_EXPLAINED( __WARNING_NONCONST_BUFFER_PARAM_25033, "Prefast Noise: inout params should not be const. Functions are implemented by OEM." )
+PREFAST_PUSH_DISABLE_EXPLAINED( __WARNING_NONCONST_PARAM_25004, "Prefast Noise: inout params should not be const. Functions are implemented by OEM." )
+
+/*
+** The maximum size for any message crossing the TEE boundary. By default this value
+** is 12KB.  However, if the TEE can handle larger messages, the OEM can change this
+** value.
+*/
+#define OEM_TEE_PROXY_MAX_PRITEE_MESSAGE_SIZE (12 * 1024)
+/*
+** The default size for pre-allocated PRITEE reponse messages.  This value can be modified
+** by the OEM if the default size is too small.
+*/
+#define OEM_TEE_PROXY_OUTPUT_LENGTH__DEFAULT (2 * 1024)
+#define OEM_TEE_PROXY_OUTPUT_LENGTH__MAX     (OEM_TEE_PROXY_MAX_PRITEE_MESSAGE_SIZE - DRM_TEE_XB_PROXY_STACK_SIZE)
+#define OEM_TEE_PROXY_SIZEOF_TEE_CONTEXT     (sizeof(OEM_TEE_CONTEXT_INTERNAL) + sizeof(DRM_TEE_CONTEXT))
+
+/*
+** TEE Transport Abstraction Layer Client ("normal world") operations
+*/
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_TEE_PROXY_Initialize( DRM_VOID ) DRM_NO_INLINE_ATTRIBUTE;
+DRM_NO_INLINE DRM_API_VOID DRM_VOID DRM_CALL OEM_TEE_PROXY_Uninitialize( DRM_VOID ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_TEE_PROXY_MethodInvoke(
+    __in_opt                                DRM_VOID                    *f_pvUserCtx,
+    __in                                    DRM_DWORD                    f_dwFunctionMapOEMValue,
+    __in                                    DRM_DWORD                    f_cbRequestMessage,
+    __inout_bcount( f_cbRequestMessage )    DRM_BYTE                    *f_pbRequestMessage,
+    __inout_opt                             DRM_DWORD                   *f_pcbResponseMessage,
+    __inout_bcount_part_opt( *f_pcbResponseMessage, *f_pcbResponseMessage )
+                                            DRM_BYTE                    *f_pbResponseMessage )  DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_TEE_PROXY_TraceInvokeResults(
+    __in_opt                                DRM_VOID                    *f_pvUserCtx,
+    __in                                    DRM_DWORD                    f_dwFunctionMapOEMValue,
+    __in                                    DRM_DWORD                    f_dwFunctionIdValue,
+    __in                                    DRM_RESULT                   f_drMethodInvoke,
+    __in                                    DRM_RESULT                   f_drResponse,
+    __in                              const DRM_TEE_BYTE_BLOB           *f_pLog ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_TEE_PROXY_GetSerializationRequirements(
+    __in_opt                                DRM_VOID                                 *f_pvUserCtx,
+    __out_ecount( 1 )                       DRM_TEE_PROXY_SERIALIZATION_REQUIREMENTS *f_pRequirements ) DRM_NO_INLINE_ATTRIBUTE;
+
+DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL OEM_TEE_PROXY_GetMaxResponseMessageSize(
+    __in_opt                          const DRM_VOID                    *f_pvUserCtx,
+    __in                                    DRM_DWORD                    f_dwMethodID,
+    __inout_ecount( 1 )                     DRM_DWORD                   *f_pdwEstimatedResponseSize ) DRM_NO_INLINE_ATTRIBUTE;
+
+PREFAST_POP /* __WARNING_NONCONST_PARAM_25004 */
+PREFAST_POP /* __WARNING_NONCONST_BUFFER_PARAM_25033 */
+
+EXIT_PK_NAMESPACE;
+
+#endif /* _OEMTEEPROXY_H_ */
diff --git a/prebuilt-v4.4/noarch/include/oem/common/inc/oemteetypes.h b/prebuilt-v4.4/noarch/include/oem/common/inc/oemteetypes.h
new file mode 100644
index 0000000..4e49b95
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/oem/common/inc/oemteetypes.h
@@ -0,0 +1,221 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef _OEMTEETYPES_H_
+#define _OEMTEETYPES_H_ 1
+
+#include <drmtypes.h>
+#include <drmcrt.h>
+
+ENTER_PK_NAMESPACE;
+
+#define OEM_TEE_MEMCPY                  DRMCRT_memcpy
+
+#define OEM_TEE_MEMCPY_IDX(dest, dest_offset, source, source_offset, count) DRM_DO {                    \
+    DRM_BYTE *pbDest   = (DRM_BYTE*)( dest );                                                           \
+    DRM_BYTE *pbSource = (DRM_BYTE*)( source );                                                         \
+    ChkArg( pbDest != NULL && pbSource != NULL );                                                       \
+    ChkDR( DRM_DWordPtrAdd( (DRM_SIZE_T)pbDest, ( dest_offset ), (DRM_SIZE_T*)&pbDest ) );              \
+    ChkDR( DRM_DWordPtrAdd( (DRM_SIZE_T)pbSource, ( source_offset ), (DRM_SIZE_T*)&pbSource ) );        \
+    OEM_TEE_MEMCPY( (char*)pbDest, (const char*)pbSource, ( count ) );                                  \
+} DRM_WHILE_FALSE
+
+#define OEM_TEE_ZERO_MEMORY( pb, cb )   DRMCRT_memset( pb, 0, cb )
+
+/*
+** This defines a Platform ID value that can be used for the
+** the out parameter f_pdwPlatformID in the OEM TEE function
+** OEM_TEE_LPROV_GetModelSecurityVersion.  If this value is
+** used, validation of the model certificate's Platform ID will
+** be skipped during local provisioning.
+*/
+#define OEM_TEE_LPROV_PLATFORM_ID_IGNORE       DRM_MAX_UNSIGNED_TYPE(DRM_DWORD)
+
+/*
+** This defines a Security Version value that can be used for the
+** the out parameter f_pdwSecurityVersion in the OEM TEE function
+** OEM_TEE_LPROV_GetModelSecurityVersion.  If this value is
+** used, validation of the model certificate's Security Version will
+** be skipped during local provisioning.
+*/
+#define OEM_TEE_LPROV_SECURITY_VERSION_IGNORE  DRM_MAX_UNSIGNED_TYPE(DRM_DWORD)
+
+/*
+** This defines the maximum number of TEE sessions that will be
+** cached.  The cached sessions are used to determine the validity
+** of the DRM_TEE_CONTEXT for all PRITEE functions.  An overflow
+** of the cache will evict the oldest item in the cache and
+** therefore invalidating the DRM_TEE_CONTEXT associated with that
+** session.  This value MUST be less than or equal to 252.
+*/
+#define OEM_TEE_CACHE_MAX_ENTRIES 32
+
+/*
+** This defines the number of cached keys saved to reduce the number
+** of ECC operations when multiple licenses come down in a single
+** license acqusiition response.  If this value is zero, then
+** the XMR object OptimizedContentKey2 is ignored.
+** This value MUST be defined to a non-negative integer.
+*/
+#define OEM_TEE_OPTIMIZED_CONTENT_KEY2_CACHE_SIZE   4
+
+/*
+** WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING
+**
+** All data inside the OEM_TEE_CONTEXT is returned OUTSIDE the TEE
+** in the clear and unsigned.  It is completely unprotected against
+** reading, writing, and modification by code running outside the TEE.
+** By placing any data inside this structure, you acknowledge this
+** lack of protection and agree to ensure that any sensitive data
+** you include will be protected against reading, writing, and/or
+** modification using TEE-backed secure assets (such as the CTK)
+** with signing and/or encryption.  You must also assume that any data
+** contained within this structure, including but not limited to pointer
+** values, lengths, handles, keys, and raw bytes, may be maliciously
+** modified outside the TEE and cannot be trusted.
+** It is a violation of the PlayReady Compliance Rules to expose
+** sensitive data by placing said data inside this structure.
+**
+** WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING
+**
+** This type allows the OEM to define its own context to refer
+** to a single session inside the TEE and store its associated data.
+** This type is considered opaque outside TEE.
+**
+** The pbUnprotectedOEMData member will be passed outside the TEE
+** in the clear and unsigned.
+**
+** You must not modify this structure declaration.
+** However, you may use its contents in any way you wish.
+** You are provided with NO guarantees that your data will
+** not be read from, written to, or tampered with outside the TEE.
+**
+** It is recommended that you avoid using this structure if possible.
+** If you choose to use this structure, it is recommended that you
+** avoid placing any sensitive assets in it.
+** If you choose to place sensitive assets in it, you MUST protect
+** those assets as described in the WARNING section above.
+**
+** pbUnprotectedOEMData MUST be allocated with OEM_TEE_BASE_SecureMemAlloc
+** and MUST be freed with OEM_TEE_BASE_SecureMemFree.
+*/
+typedef struct __tagOEM_TEE_CONTEXT
+{
+    DRM_DWORD cbUnprotectedOEMData;
+    DRM_BYTE *pbUnprotectedOEMData;
+} OEM_TEE_CONTEXT;
+
+#define OEM_TEE_CONTEXT_EMPTY {0, NULL}
+
+/*
+** OEM_TEE_CONTEXT_INTERNAL is a sample implemenation of an OEM defined structure
+** for the contextual information required by the OEM layer of the TEE interface.
+** None of the current member variables are required and are only used for testing.
+*/
+typedef struct __tagOEM_TEE_CONTEXT_INTERNAL
+{
+    DRM_DWORD dwOEMContextClear;
+    DRM_WORD  wOEMContextEncrypted;
+} OEM_TEE_CONTEXT_INTERNAL;
+
+/*
+** This type allows the OEM to define its own type for
+** for AES128 and ECC256 keys.  This type is considered
+** opaque outside the OEM portion of the TEE layer.
+*/
+
+typedef struct __tagOEM_TEE_KEY
+{
+    DRM_VOID *pKey;
+} OEM_TEE_KEY;
+
+#define OEM_TEE_KEY_EMPTY   { NULL }
+
+/*
+** This enum defines the types of decryption modes
+** the OEM supports for content decryption.
+** Note that OEM_TEE_DECRYPTION_MODE_NOT_SECURE
+** MUST always be *listed* in this enum and
+** MUST take the value zero.
+** It lists the valid values for the following.
+** DRM_TEE_DECRYPT_PrepareToDecrypt (*f_pdwDecryptionMode)
+** DRM_FFLICENSE.dwDecryptionOutputMode
+** DRM_APP_CONTEXT_INTERNAL.dwDecryptionOutputMode
+** Note: The value of zero for
+** OEM_TEE_DECRYPTION_MODE_NOT_SECURE
+** must *NOT* be changed by the OEM.
+*/
+typedef enum
+{
+    OEM_TEE_DECRYPTION_MODE_NOT_SECURE        = 0x0,
+    OEM_TEE_DECRYPTION_MODE_HANDLE            = 0x1,
+    OEM_TEE_DECRYPTION_MODE_SAMPLE_PROTECTION = 0x2,
+} OEM_TEE_DECRYPTION_MODE;
+
+#define OEM_TEE_DECRYPTION_MODE_IS_HANDLE_TYPE( _dwMode ) ((_dwMode) == OEM_TEE_DECRYPTION_MODE_HANDLE)
+
+/* This macro defines the length of nonce used in remote provisioning, must not be changed */
+#define OEM_PROVISIONING_NONCE_LENGTH 16
+
+/*
+** If an OEM needs to have some extended secure media path capabilities data,
+** an OEM can agree with MSFT what information shall reside there and populate these structures.
+** Currently left empty.
+*/
+typedef struct __tagOEM_TEE_RPROV_SMPC_HEADER
+{
+    DRM_CHAR    rgbMagic[4]; /* {'S','M','P','C'}, */
+} OEM_TEE_RPROV_SMPC_HEADER;
+
+typedef struct __tagOEM_SMPC
+{
+    OEM_TEE_RPROV_SMPC_HEADER oHeader;
+} OEM_TEE_RPROV_SMPC;
+
+typedef enum
+{
+    OEM_TEE_RPROV_BOOTSTRAP_ID_MESSAGE_INVALID       = 0x0,
+    OEM_TEE_RPROV_BOOTSTRAP_ID_MESSAGE_S1            = 0x1,
+    OEM_TEE_RPROV_BOOTSTRAP_ID_MESSAGE_S2            = 0x2,
+    OEM_TEE_RPROV_BOOTSTRAP_ID_MESSAGE_S3            = 0x3,
+    OEM_TEE_RPROV_BOOTSTRAP_ID_MESSAGE_S4            = 0x4,
+    OEM_TEE_RPROV_BOOTSTRAP_ID_MESSAGE_LAST          = 0x4,
+} OEM_TEE_RPROV_BOOTSTRAP_ID_MESSAGE;
+
+/* For server compatibility, this value MUST remain 3 to include the PRND key */
+#define RPROV_KEYPAIR_COUNT ((DRM_DWORD)3)
+#define RPROV_KEYPAIR_SIGNING_IDX ((DRM_DWORD)0)
+
+typedef enum
+{
+    OEM_TEE_XB_SIGNATURE_TYPE_AES_OMAC1_TKD = 0x1,
+} OEM_TEE_XB_SIGNATURE_TYPE;
+
+typedef DRM_VOID* OEM_TEE_MEMORY_HANDLE;
+#define OEM_TEE_MEMORY_HANDLE_INVALID NULL
+
+/*
+** If TEE Supports secure clock that could accumulate a drift over time,
+** TEE will force a periodic resync of the secure clock.
+** The resync period is defined as the duration overwhich the TEE can
+** accumulate 2 minutes of clock drift
+** For example: a 3 seconds per day drift results in two minutes drift after 40 days
+** 60 Seconds * 60 Minutes * 24 Hours * 40 Days = 3456000
+**
+** For Perf, MAX_ALLOWED_TIME_BEFORE_CLOCK_RESYNC was pre-calculated.
+** If C_TICS_PER_SECOND is changed, make sure this expression is also updated.
+**
+** MAX_ALLOWED_TIME_BEFORE_CLOCK_RESYNC =
+**              3456000 * C_TICS_PER_SECOND
+*/
+#define MAX_ALLOWED_TIME_BEFORE_CLOCK_RESYNC ( (DRM_UINT64)DRM_UI64LITERAL( 0x1F6E, 0xA0860000 ) )
+
+EXIT_PK_NAMESPACE;
+
+#endif /* _OEMTEETYPES_H_ */
+
diff --git a/prebuilt-v4.4/noarch/include/oem/common/inc/oemtrace.h b/prebuilt-v4.4/noarch/include/oem/common/inc/oemtrace.h
new file mode 100644
index 0000000..12bbd17
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/oem/common/inc/oemtrace.h
@@ -0,0 +1,69 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __OEMTRACE_H__
+#define __OEMTRACE_H__
+
+#if DRM_SUPPORT_TRACING
+
+#include <oemtraceimpl.h>
+
+ENTER_PK_NAMESPACE;
+
+DRM_API DRM_TRACE_GLOBAL_CONTEXT * DRM_CALL Oem_Trace_GetGlobalContext( DRM_VOID );
+
+DRM_API DRM_RESULT DRM_CALL Oem_Trace_Info(
+    __in DRM_CHAR *f_pszFormat,
+    ... );
+
+DRM_API DRM_RESULT DRM_CALL Oem_Trace_ID(
+    __in DRM_DWORD f_dwFormatID,
+    __in DRM_RESULT f_dr,
+    __in DRM_DWORD f_cParam,
+    __in DRM_DWORD f_dwParam1,
+    __in DRM_DWORD f_dwParam2,
+    __in DRM_DWORD f_dwParam3 );
+
+DRM_API DRM_RESULT DRM_CALL Oem_Trace_Enter_Scope(
+    __in DRM_DWORD f_dwScopeID );
+
+DRM_API DRM_RESULT DRM_CALL Oem_Trace_Leave_Scope(
+    __in DRM_DWORD f_dwScopeID,
+    __in DRM_RESULT f_dr );
+
+DRM_API DRM_RESULT DRM_CALL Oem_Trace_Status_Code(
+    __in DRM_DWORD f_dwEventID,
+    __in DRM_RESULT f_dr );
+
+DRM_API DRM_RESULT DRM_CALL Oem_Trace_Start(
+    __in_opt DRM_VOID *f_poOEMContext,
+    __in_opt DRM_CONST_STRING *f_pdstrTraceLog );
+
+DRM_API DRM_RESULT DRM_CALL Oem_Trace_Stop( DRM_VOID );
+
+/* See drmtrace.h for detailed descriptions of each macro. */
+#define INVALID_TRACE_ID                0xFFFFFFFF
+#define DRM_TRACE_ID( dwTraceID )       INVALID_TRACE_ID
+
+#define DRM_TRACE( szFormat )                                               DRM_DO { _DRM_TRACE_IF_NOT_FILTERED { Oem_Trace_Info szFormat } } DRM_WHILE_FALSE
+#define DRM_TRACE_NO_SCOPE( szFormat )                                      DRM_DO { Oem_Trace_Info szFormat; } DRM_WHILE_FALSE
+#define DRM_TRACE_ID0( eRobust, dwID, dr )                                  DRM_DO { _DRM_TRACE_IF_NOT_FILTERED { Oem_Trace_ID( dwID, dr, 0, 0, 0 , 0 ); } } DRM_WHILE_FALSE
+#define DRM_TRACE_ID1( eRobust, dwID, dr, dwParam1 )                        DRM_DO { _DRM_TRACE_IF_NOT_FILTERED { Oem_Trace_ID( dwID, dr, 1, dwParam1, 0 , 0 ); } } DRM_WHILE_FALSE
+#define DRM_TRACE_ID2( eRobust, dwID, dr, dwParam1, dwParam2 )              DRM_DO { _DRM_TRACE_IF_NOT_FILTERED { Oem_Trace_ID( dwID, dr, 2, dwParam1, dwParam2 , 0 ); } } } DRM_WHILE_FALSE
+#define DRM_TRACE_ID3( eRobust, dwID, dr, dwParam1, dwParam2, dwParam3 )    DRM_DO { _DRM_TRACE_IF_NOT_FILTERED { Oem_Trace_ID( dwID, dr, 3, dwParam1, dwParam2 , dwParam3 ); } } } DRM_WHILE_FALSE
+#define DRM_TRACE_ENTER_SCOPE( eRobust, dwScopeID )                         DRM_DO { Oem_Trace_Enter_Scope( dwScopeID ); } DRM_WHILE_FALSE
+#define DRM_TRACE_LEAVE_SCOPE( eRobust, dwScopeID, dr )                     DRM_DO { Oem_Trace_Leave_Scope( dwScopeID, dr ); } DRM_WHILE_FALSE
+#define DRM_TRACE_STATUS_CODE( eRobust, dwEventID, dr )                     DRM_DO { _DRM_TRACE_IF_NOT_FILTERED { Oem_Trace_Status_Code( dwEventID, dr ); } } DRM_WHILE_FALSE
+#define DRM_TRACE_START( pOEMContext, pdstrFilename )                       DRM_DO { Oem_Trace_Start( pOEMContext, pdstrFilename ); } DRM_WHILE_FALSE
+#define DRM_TRACE_STOP()                                                    DRM_DO { Oem_Trace_Stop(); } DRM_WHILE_FALSE
+
+EXIT_PK_NAMESPACE;
+
+#endif  /* DRM_SUPPORT_TRACING */
+
+#endif  /* __OEMTRACE_H__ */
diff --git a/prebuilt-v4.4/noarch/include/oem/common/inc/oemxmlhash.h b/prebuilt-v4.4/noarch/include/oem/common/inc/oemxmlhash.h
new file mode 100644
index 0000000..9cb689c
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/oem/common/inc/oemxmlhash.h
@@ -0,0 +1,145 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+
+#ifndef __OEMXMLHASH_H__
+#define __OEMXMLHASH_H__
+
+#include <drmerr.h>
+#include <drmstkalloc.h>
+
+ENTER_PK_NAMESPACE;
+
+/*
+** Flag indicating whehther XMLHASH statistics is turned on.
+** Statistics will add a few more fields to the runtime data
+** structures used by XML hash.
+*/
+#define ENABLE_OEM_XMLHASH_STATISTICS   0
+
+/* Maximum number of hash table slots. */
+#define MAX_XML_ROOT_HASH       32
+
+/* Maximum size of stack buffer of each XML Hash context. */
+#define MAX_XML_HASH_STACK      1024
+
+/* Maximum number of threads that can use XML hash at the same time. */
+#define MAX_XML_HASH_THREAD     256
+
+/*
+** Data structure that stores the signature based on
+** the parameters used for XML substring search.
+*/
+typedef struct __tagDRM_XML_HASH_SIG
+{
+    /* String hash 1 of the source XML string. */
+    DRM_DWORD m_dwSourceHash1;
+
+    /* String hash 2 of the source XML string. */
+    DRM_DWORD m_dwSourceHash2;
+
+    /* String hash 1 of the XML tag to be searched. */
+    DRM_DWORD m_dwTagHash1;
+
+    /* String hash 2 of the XML tag to be searched. */
+    DRM_DWORD m_dwTagHash2;
+
+    /* Occurence of the XML tag within the source XML string. */
+    DRM_DWORD m_dwNode;
+
+    /* Number of XML hierarchy levels to skip for the search. */
+    DRM_DWORD m_dwLayer;
+
+#if ENABLE_OEM_XMLHASH_STATISTICS
+    /* Combined length of the source and tag strings. */
+    DRM_DWORD m_dwLen;
+#endif /* ENABLE_OEM_XMLHASH_STATISTICS */
+} DRM_XML_HASH_SIG;
+
+/*
+** Data structure that defines a hash node for the mapping
+** between DRM_XML_HASH_SIG and the XML search result.
+*/
+typedef struct __tagDRM_XML_HASH_NODE
+{
+    /* The signature of parameters of a XML substring search. */
+    DRM_XML_HASH_SIG m_oSig;
+
+    /* The search result (location) of the result XML node (including tag). */
+    DRM_SUBSTRING m_dasstrNode;
+
+    /* The search result (location) of the result XML node data (excluding tag). */
+    DRM_SUBSTRING m_dasstrNodeData;
+
+#if ENABLE_OEM_XMLHASH_STATISTICS
+    /* Total number of hash match. */
+    DRM_DWORD m_dwHit;
+#endif /* ENABLE_OEM_XMLHASH_STATISTICS */
+
+    struct __tagDRM_XML_HASH_NODE *m_poNext;
+} DRM_XML_HASH_NODE;
+
+/* Data structure of the per-thread XML hash context. */
+typedef struct __tagDRM_XML_HASH_CONTEXT
+{
+    /* Thread ID. */
+    DRM_DWORD m_dwThreadID;
+
+    /* Stack allocator context. */
+    DRM_STACK_ALLOCATOR_CONTEXT m_oXMLHashStackContext;
+
+    /* Flag indicating whether the data structure has been initialized. */
+    DRM_BOOL m_fXMLHashStackInit;
+
+    /* Buffer to support the stack allocation. */
+    DRM_BYTE m_rgbXMLHashStackBuffer[ MAX_XML_HASH_STACK ];
+
+    /* The hash table. */
+    DRM_XML_HASH_NODE *m_rgpoHashNodes[ MAX_XML_ROOT_HASH ];
+} DRM_XML_HASH_CONTEXT;
+
+DRM_API DRM_RESULT DRM_CALL Oem_XMLHash_Update(
+    __in DRM_XML_HASH_CONTEXT *f_poContext,
+    __in const DRM_XML_HASH_SIG *f_poSig,
+    __in const DRM_CONST_STRING *f_pdstrXML,
+    __in const DRM_CONST_STRING *f_pdstrNode,
+    __in const DRM_CONST_STRING *f_pdstrNodeData );
+
+DRM_API DRM_RESULT DRM_CALL Oem_XMLHash_Lookup(
+    __in          DRM_XML_HASH_CONTEXT  *f_poContext,
+    __in    const DRM_XML_HASH_SIG      *f_poSig,
+    __in    const DRM_CONST_STRING      *f_pdstrXML,
+    __in    const DRM_CONST_STRING      *f_pdstrTag,
+    __inout       DRM_CONST_STRING      *f_pdstrNodeOut,
+    __inout       DRM_CONST_STRING      *f_pdstrNodeDataOut );
+
+DRM_API DRM_RESULT DRM_CALL Oem_XMLHash_CalcParamSig(
+    __in const DRM_XML_HASH_CONTEXT *f_poContext,
+    __in const DRM_CONST_STRING *f_pdstrXML,
+    __in const DRM_CONST_STRING *f_pdstrTag,
+    __in const DRM_DWORD f_iNode,
+    __in const DRM_DWORD f_iLayer,
+    __out DRM_XML_HASH_SIG *f_poSig );
+
+DRM_API DRM_RESULT DRM_CALL Oem_XMLHash_GetContext(
+    __out DRM_XML_HASH_CONTEXT **f_ppoContext );
+
+DRM_API DRM_RESULT DRM_CALL Oem_XMLHash_Start( DRM_VOID );
+
+DRM_API DRM_RESULT DRM_CALL Oem_XMLHash_Stop( DRM_VOID );
+
+DRM_API DRM_RESULT DRM_CALL Oem_XMLHash_Init( DRM_VOID );
+
+DRM_API DRM_RESULT DRM_CALL Oem_XMLHash_UnInit( DRM_VOID );
+
+DRM_API DRM_RESULT DRM_CALL Oem_XMLHash_Cleanup( DRM_VOID );
+
+EXIT_PK_NAMESPACE;
+
+#endif /*__OEMXMLHASH_H__ */
+
diff --git a/prebuilt-v4.4/noarch/include/oemcompiler.h b/prebuilt-v4.4/noarch/include/oemcompiler.h
new file mode 100644
index 0000000..6783f0a
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/oemcompiler.h
@@ -0,0 +1,238 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __OEMCOMPILER_H__
+#define __OEMCOMPILER_H__
+
+/*
+** The default definitions for a number of compiler-specific settings are in drmcompiler.h.
+** This file is provided to enable you to change these settings.
+*/
+
+/*
+** +-----------------------+
+** | Turning on Debug Mode |
+** +-----------------------+
+**
+** By default, Debug Mode for the PlayReady PK is turned on iff the DBG macro is defined.
+** To turn on Debug Mode based on another macro defined by your compiler, define DRM_DBG to 1 here.
+**
+** Example:
+**   #if MY_COMPILER_IS_COMPILING_A_DEBUG_VERSION
+**   #define DRM_DBG 1
+**   #endif
+*/
+
+/*
+** +-----------------------------+
+** | Overriding Compiler version |
+** +-----------------------------+
+**
+** If you want the default compiler settings to match the defaults set for Microsoft's compilers,
+** define DRM_MSC_VER here instead to act as if _MSC_VER is set to the specified value.
+**
+** For example, adding the following will set the default drmcompiler.h settings to match MSC version 1300.
+**   #define DRM_MSC_VER 1300
+**
+** If you want the default compiler settings to match the defaults set for a specific version of GNU
+** but your compiler does not set the __GNUC__ macro, then set the following two macros to match the
+** desired major and minor version of GNU.  These correspond to the __GNUC__ and __GNUC_MINOR__ macros.
+**   DRM_GNUC_MAJOR
+**   DRM_GNUC_MINOR
+**
+** For example, adding the following will set the default drmcompiler.h settings to match GNU version 4.6.
+**   #define DRM_GNUC_MAJOR 4
+**   #define DRM_GNUC_MINOR 6
+*/
+
+/*
+** +------------------------------+
+** | Changing DRM_VOID definition |
+** +------------------------------+
+**
+** If you need to change the definition of DRM_VOID (unlikely), do so here and set DRM_VOID_DEFINED to 1.
+*/
+#ifndef DRM_VOID_DEFINED
+#define DRM_VOID_DEFINED 0
+#endif /* DRM_VOID_DEFINED */
+
+/*
+** +--------------------------------------------+
+** | Changing PRAGMA WARNING MACROS definitions |
+** +--------------------------------------------+
+**
+** If you need to set the definition of any of the following macros,
+** define ALL of them here and set DRM_PRAGMA_WARNING_MACROS_DEFINED to 1.
+**
+**  PRAGMA_INTRINSIC(func)
+**  PRAGMA_WARNING_DEFAULT(warningnum)
+**  PRAGMA_WARNING_DISABLE(warningnum)
+**  PRAGMA_WARNING_PUSH
+**  PRAGMA_WARNING_POP
+**  PRAGMA_WARNING_PUSH_WARN(warningnum)
+**  PRAGMA_PACK_PUSH_VALUE(packval)
+**  PRAGMA_PACK_POP
+**  PRAGMA_DIAG_OFF(x, reason)
+**  PRAGMA_DIAG_ON(x)
+*/
+#ifndef DRM_PRAGMA_WARNING_MACROS_DEFINED
+#define DRM_PRAGMA_WARNING_MACROS_DEFINED 0
+#endif /* DRM_PRAGMA_WARNING_MACROS_DEFINED */
+
+/*
+** +----------------------------+
+** | 64-BIT TARGET ARCHITECTURE |
+** +----------------------------+
+**
+** If you want to guarantee that the PlayReady PK is compiling for a 32-bit or 64-bit architecture,
+** set the following macros here, where DRM_64BIT_TARGET should be set to 0 for a
+** 32-bit architecture or 1 for a 64-bit architecture.
+**
+** #define DRM_64BIT_TARGET_DEFINED 1
+** #define DRM_64BIT_TARGET 1
+*/
+#ifndef DRM_64BIT_TARGET_DEFINED
+#define DRM_64BIT_TARGET_DEFINED 0
+#endif /* DRM_64BIT_TARGET_DEFINED */
+
+/*
+** +------------------------------------------------------------+
+** | Changing GS STRICT and DBG OPTIMIZATION PRAGMA definitions |
+** +------------------------------------------------------------+
+**
+** If you need to set the definition of any of the following macros,
+** define ALL of them here and set DRM_STRICT_AND_OPTIMIZATION_PRAGMAS_DEFINED to 1.
+**
+** PRAGMA_STRICT_GS_PUSH_ON
+** PRAGMA_STRICT_GS_POP
+** PRAGMA_DBG_OPTIMIZATION_OFF
+** PRAGMA_DBG_OPTIMIZATION_ON
+** PRAGMA_ARM_OPTIMIZATION_OFF
+** PRAGMA_ARM_OPTIMIZATION_ON
+** PRAGMA_GCC_OPTIMIZATION_OFF
+** PRAGMA_GCC_OPTIMIZATION_ON
+*/
+#ifndef DRM_STRICT_AND_OPTIMIZATION_PRAGMAS_DEFINED
+#define DRM_STRICT_AND_OPTIMIZATION_PRAGMAS_DEFINED 0
+#endif /* DRM_STRICT_AND_OPTIMIZATION_PRAGMAS_DEFINED */
+
+/*
+** +--------------------------------------------+
+** | Changing COMPILATION QUALIFIER DEFINITIONS |
+** +--------------------------------------------+
+**
+** If you need to set the definition of any of the following macros,
+** define ALL of them here and set DRM_COMPILATION_QUALIFIERS_DEFINED to 1.
+**
+** DRM_CCALL
+** DRM_DLLEXPORT
+** DRM_DLLIMPORT
+** DRM_ALIGN_4
+** DRM_ALIGN_8
+** DRM_PACKED
+** DRM_DISCARDABLE
+*/
+#ifndef DRM_COMPILATION_QUALIFIERS_DEFINED
+#define DRM_COMPILATION_QUALIFIERS_DEFINED 0
+#endif /* DRM_COMPILATION_QUALIFIERS_DEFINED */
+
+/*
+** +------------------------------+
+** | Setting COMPILATION BEHAVIOR |
+** +------------------------------+
+**
+** If you need to set the definition of any of the following macros,
+** define ALL of them here and set DRM_COMPILATION_BEHAVIOR_DEFINED to 1.
+**
+** Note that this is *required* unless either DRM_MSC_VER (potentially via _MSC_VER)
+** or DRM_GNUC_MAJOR (potentially via __GNUC__) is defined.
+**
+** DRM_NO_INLINE_ATTRIBUTE
+** DRM_ALWAYS_INLINE_ATTRIBUTE
+** DRM_CALL
+** DRM_ALWAYS_INLINE
+** DRM_EXTERN_INLINE
+** DRM_EXPORTED_INLINE
+** DRM_INLINING_SUPPORTED
+** DRM_DWORD_ALIGN
+** DRM_NO_INLINE
+*/
+#ifndef DRM_COMPILATION_BEHAVIOR_DEFINED
+#define DRM_COMPILATION_BEHAVIOR_DEFINED 0
+#endif /* DRM_COMPILATION_BEHAVIOR_DEFINED */
+
+/*
+** +----------------+
+** | Setting TARGET |
+** +----------------+
+**
+** If drmcompiler.h is unable to determine the target for which you are compiling
+** or you find that it is determining the platform incorrectly, you must set the
+** following two macros to 0 or 1 to indicate the endianness of the platform and
+** whether the platform supports unaligned pointers pointing to 32 bit values respectively.
+**
+** TARGET_LITTLE_ENDIAN
+** TARGET_SUPPORTS_UNALIGNED_DWORD_POINTERS
+*/
+
+/*
+** +-------------------------------------+
+** | Setting BASIC TYPE/SIZE DEFINITIONS |
+** +-------------------------------------+
+**
+** The PlayReady PK requires its basic types to have specific constant sizes on all platforms.
+** If any of these types has an incorrect size, a build break will occur in drmdebug.inc.
+** To resolve this build break, set DRM_BASIC_TYPE_SIZES_DEFINED to 1 and typedef all of
+** the following types to native types such that they have the sign and size indicated.
+**
+**   Type              Sign       Size      Notes
+**   ----              ----       ----      -----
+** DRM_BYTE          unsigned      1
+** DRM_CHAR            signed      1        Used to represent an ANSI character.
+** DRM_WORD          unsigned      2
+** DRM_WCHAR         unsigned      2        Used to represent a UTF 16 character in little endian.  For example, only typedef as wchar_t if wchar_t represents UTF16.
+** DRM_BOOL          unsigned      4
+** DRM_DWORD         unsigned      4
+** DRM_WCHAR32       unsigned      4        Used to represent a UTF 32 character in little endian.  Only used by unicode conversion code.
+** DRM_LONG            signed      4
+** DRM_WCHAR_NATIVE  unsigned      2        Used to represent a UTF 16 character in native platform endianness.
+*/
+#ifndef DRM_BASIC_TYPE_SIZES_DEFINED
+#define DRM_BASIC_TYPE_SIZES_DEFINED 0
+#endif /* DRM_BASIC_TYPE_SIZES_DEFINED */
+
+/*
+** +---------------------------------+
+** | Setting 64-BIT TYPE DEFINITIONS |
+** +---------------------------------+
+**
+** If your platform does NOT support native 64-bit types, you should set
+** DRM_SUPPORT_NATIVE_64BIT_TYPES to 0 in your compilation profile
+** and leave this section unchanged.
+**
+** Otherwise, your platform supports native 64-bit types (e.g. int64_t and uint64_t),
+** and you should set DRM_SUPPORT_NATIVE_64BIT_TYPES in your compilation profile.
+**
+** If you do this but you get a build break because your compiler is not recognized
+** by drmcompiler.h, set DRM_NATIVE_64BIT_TYPES_DEFINED to 1 and typedef all of
+** the following types to native types such that they have the sign and size indicated.
+**
+** Note that a 64-bit architecture (i.e. DRM_64BIT_TARGET is set to 1) requires
+** native support for 64-bit types.  
+**
+**   Type              Sign       Size
+**   ----              ----       ----
+** DRM_UINT64        unsigned      8
+** DRM_INT64           signed      8
+*/
+#ifndef DRM_NATIVE_64BIT_TYPES_DEFINED
+#define DRM_NATIVE_64BIT_TYPES_DEFINED 0
+#endif /* DRM_NATIVE_64BIT_TYPES_DEFINED */
+
+#endif   /* __OEMCOMPILER_H__ */
+
diff --git a/prebuilt-v4.4/noarch/include/oemresults.h b/prebuilt-v4.4/noarch/include/oemresults.h
new file mode 100644
index 0000000..01f484c
--- /dev/null
+++ b/prebuilt-v4.4/noarch/include/oemresults.h
@@ -0,0 +1,50 @@
+/**@@@+++@@@@******************************************************************
+**
+** Microsoft (r) PlayReady (r)
+** Copyright (c) Microsoft Corporation. All rights reserved.
+**
+***@@@---@@@@******************************************************************
+*/
+
+#ifndef __OEMRESULTS_H__
+#define __OEMRESULTS_H__
+
+/*
+** This file is provided for you to add your own error codes which you
+** can then return from your OEM functions.
+**
+** This file is included in drmresults.h where common error codes
+** for the PlayReady PK are defined.
+**
+** The error code range 0x8004DC80 to 0x8004DDFF is reserved for
+** your OEM-defined error codes.  Make sure to define your error
+** codes within this range to ensure that they are handled properly
+** both by the PlayReady PK and by higher-level components in the stack.
+**
+** This range is large enough to provide you with more than 380 unique
+** error codes.  Microsoft recommends that you use a unique error code
+** for every location where you use your own error code (except where
+** you are intentionally hiding information from hostile actors).
+**
+** Doing so will lower your troubleshooting and customer support costs
+** by enabling you to precisely pinpoint where an error is coming from.
+**
+** Here are examples of defining your own codes.
+** Again, note that they are in the range 0x8004DC80 to 0x8004DDFF.
+**
+** #define OEM_E_MY_FIRST_ERROR   ((DRM_RESULT)0x8004DC80L)
+** #define OEM_E_MY_SECOND_ERROR  ((DRM_RESULT)0x8004DC81L)
+** ...
+** #define OEM_E_MY_LAST_ERROR    ((DRM_RESULT)0x8004DDFFL)
+*/
+
+/*
+** Reminder: do not define error codes outside the range
+** OEM_E_MINIMUM_ERROR_CODE to OEM_E_MAXIMUM_ERROR_CODE
+*/
+#define OEM_E_MINIMUM_ERROR_CODE  ((DRM_RESULT)0x8004DC80L)
+#define OEM_E_MAXIMUM_ERROR_CODE  ((DRM_RESULT)0x8004DDFFL)
+
+
+#endif   /* __OEMRESULTS_H__ */
+
diff --git a/prebuilt-v4.4/noarch/pkgconfig/playready.pc b/prebuilt-v4.4/noarch/pkgconfig/playready.pc
new file mode 100644
index 0000000..3dd1077
--- /dev/null
+++ b/prebuilt-v4.4/noarch/pkgconfig/playready.pc
@@ -0,0 +1,10 @@
+ prefix=/usr
+exec_prefix=${prefix}
+libdir=/usr/lib
+includedir=${prefix}/include/playready
+
+Name: Playready
+Description: Playready
+Version: 4.4
+Libs: -L${libdir} -lplayready-4.4 -lteec
+Cflags: -I${includedir} -I${includedir}/inc -I${includedir}/results -I${includedir}/oem/common/inc -I${includedir}/oem/ansi/inc
-- 
2.29.2

